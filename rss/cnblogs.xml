<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ElasticSearch聚合分析 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/9499534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/9499534.html</guid>
<description>&lt;p&gt;聚合用于分析查询结果集的统计指标，我们以观看日志分析为例，介绍各种常用的ElasticSearch聚合操作。&lt;/p&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;首先展示一下我们要分析的文档结构:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;video_id&quot;: 1289643545120062253, // 视频id
    &quot;video_uid&quot;: 3931482202390368051, // 视频发布者id
    &quot;uid&quot;: 47381776787453866, // 观看用户id
    &quot;time&quot;: 1533891263224, // 时间发生时间
    &quot;watch_duration&quot;: 30 // 观看时长
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个文档记录了一个观看事件，我们通过聚合分析用户的观看行为。&lt;/p&gt;
&lt;p&gt;ElasticSearch引入了两个相关概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;桶(Buckets): 满足特定条件的文档的集合&lt;/li&gt;
&lt;li&gt;指标(Metrics): 桶中文档的统计值，如特定字段的平均值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先用sql语句描述这个查询:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT uid, count(*) as view_count, avg(watch_duration) as avg_duration 
FROM view_log
WHERE time &amp;gt;= #{since} AND time &amp;lt;= #{to} 
GROUP BY uid;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
   &quot;size&quot; : 0,
   &quot;query&quot;: {
       &quot;range&quot;: {
           &quot;time&quot;: {
               &quot;gte&quot;: 0, // since
               &quot;lte&quot;: 0 // to
           }
       }
   },
   &quot;aggs&quot;: {
      &quot;agg&quot;: { // agg为聚合的名称
        &quot;terms&quot;: { // 聚合的条件为 uid 相同
          &quot;field&quot;: &quot;uid&quot;
        },
        &quot;aggs&quot;: { // 添加统计指标(Metrics)
          &quot;avg_duration&quot;: { 
              &quot;avg&quot;: { // 统计 watch_duration 的平均值
                &quot;field&quot;: &quot;watch_duration&quot; 
              }
          }
        }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;response:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;took&quot;: 10,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 100000,
    &quot;max_score&quot;: 0,
    &quot;hits&quot;: []
  },
  &quot;aggregations&quot;: {
    &quot;agg&quot;: {
      &quot;buckets&quot;: [
        {
          &quot;key&quot;: 21836334489858688,
          &quot;doc_count&quot;: 4026,
          &quot;avg_duration&quot;: {
            &quot;value&quot;: 12778.882352941177
          }
        },
        {
          &quot;key&quot;: 31489302390368051,
          &quot;doc_count&quot;: 2717,
          &quot;avg_duration&quot;: {
            &quot;value&quot;: 2652.5714285714284
          }
        }
      ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;result.aggregations.agg.buckets列表中包含了查询的结果。&lt;/p&gt;
&lt;p&gt;因为我们按照terms:uid进行聚合，每个bucket为uid相同的文档集合，key字段即为uid。&lt;/p&gt;
&lt;p&gt;doc_count 字段表明bucket中文档的数目即sql语句中的&lt;code&gt;count(*) as view_count&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;avg_duration.value 表示 watch_duration 的平均值即该用户的平均观看时长。&lt;/p&gt;

&lt;p&gt;在实际应用中用户的数量非常惊人, 不可能通过一次查询得到全部结果因此我们需要分页器分批取回:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
   &quot;size&quot; : 0,
   &quot;query&quot;: {
       &quot;range&quot;: {
           &quot;time&quot;: {
               &quot;gte&quot;: 0, // since
               &quot;lte&quot;: 0 // to
           }
       }
   },
   &quot;aggs&quot;: {
      &quot;agg&quot;: { 
        &quot;terms&quot;: { 
            &quot;field&quot;: &quot;uid&quot;,
            &quot;size&quot;: 10000, // bucket 的最大个数
            &quot;include&quot;: { // 将聚合结果分为10页，序号为[0,9], 取第一页
                &quot;partition&quot;: 0,
                &quot;num_partitions&quot;: 10 
            }
        },
        &quot;aggs&quot;: { 
          &quot;avg_duration&quot;: { 
              &quot;avg&quot;: { 
                &quot;field&quot;: &quot;watch_duration&quot; 
              }
          }
        }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述查询与上节的查询几乎完全相同，只是在aggs.agg.terms字段中添加了include字段进行分页。&lt;/p&gt;

&lt;h2 id=&quot;单个视频uv&quot;&gt;单个视频uv&lt;/h2&gt;
&lt;p&gt;uv是指观看一个视频的用户数(user view)，与此相对没有按照用户去重的观看数称为pv(page view)。&lt;/p&gt;
&lt;p&gt;用SQL语句来描述:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT video_id, count(*) as pv, count(distinct uid) as uv
FROM view_log
WHERE video_id = #{video_id};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ElasticSearch可以方便的进行count(distinct)查询:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
    &quot;aggs&quot;: {
      &quot;uv&quot;: {
        &quot;cardinality&quot;: {
          &quot;field&quot;: &quot;uid&quot;
        }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;response:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;took&quot;: 255,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 17579,
    &quot;max_score&quot;: 0,
    &quot;hits&quot;: []
  },
  &quot;aggregations&quot;: {
    &quot;uv&quot;: {
      &quot;value&quot;: 11
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;批量查询视频uv&quot;&gt;批量查询视频uv&lt;/h2&gt;
&lt;p&gt;ElasticSearch也可以批量查询count(distinct), 先用SQL进行描述:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT video_id, count(*) as pv, count(distinct uid) as uv
FROM view_log
GROUP BY video_id;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot;: {
      &quot;video&quot;: {
        &quot;terms&quot;: {
          &quot;field&quot;: &quot;video_id&quot;
        },
        &quot;aggs&quot;: {
          &quot;uv&quot;: {
              &quot;cardinality&quot;: {
                &quot;field&quot;: &quot;uid&quot;
              }
          }
        }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;response:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;took&quot;: 313,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 16940,
    &quot;max_score&quot;: 0,
    &quot;hits&quot;: []
  },
  &quot;aggregations&quot;: {
    &quot;video&quot;: {
      &quot;buckets&quot;: [
        {
          &quot;key&quot;: 25417499722062, // 视频id
          &quot;doc_count&quot;: 427, // 视频观看次数 pv
          &quot;uv&quot;: {
            &quot;value&quot;: 124 // 观看视频的用户数 uv
          }
        },
        {
          &quot;key&quot;: 72446898144,
          &quot;doc_count&quot;: 744,
          &quot;uv&quot;: {
            &quot;value&quot;:233
          }
        }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;SQL可以使用HAVING语句根据聚合结果进行过滤，ElasticSearch可以使用pipeline aggregations达到此效果不过语法较为繁琐。&lt;/p&gt;
&lt;h2 id=&quot;根据-count-进行过滤&quot;&gt;根据 count 进行过滤&lt;/h2&gt;
&lt;p&gt;使用SQL查询观看超过200次的视频:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT video_id, count(*) as view_count
FROM view_log
GROUP BY video_id
HAVING count(*) &amp;gt; 200;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;view_count&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;video_id&quot;
      },
      &quot;aggs&quot;: {
        &quot;having&quot;: {
          &quot;bucket_selector&quot;: {
            &quot;buckets_path&quot;: { // 选择 view_count 聚合的 doc_count 进行过滤
              &quot;view_count&quot;: &quot;_count&quot;
            },
            &quot;script&quot;: {
              &quot;source&quot;: &quot;params.view_count &amp;gt; 200&quot;
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;response:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;took&quot;: 83,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 775,
    &quot;max_score&quot;: 0,
    &quot;hits&quot;: []
  },
  &quot;aggregations&quot;: {
    &quot;view_count&quot;: {
      &quot;buckets&quot;: [
        {
          &quot;key&quot;: 35025417499764062,
          &quot;doc_count&quot;: 529
        },
        {
          &quot;key&quot;: 19913672446898144,
          &quot;doc_count&quot;: 759
        }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ElasticSearch实现类似HAVING查询的关键在于使用[bucket_selector]选择聚合结果进行过滤。&lt;/p&gt;
&lt;h2 id=&quot;根据其它指标进行过滤&quot;&gt;根据其它指标进行过滤&lt;/h2&gt;
&lt;p&gt;接下来我们尝试查询平均观看时长大于5分钟的视频, 用SQL描述该查询:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT video_id FROM view_log
GROUP BY video_id
HAVING avg(watch_duration) &amp;gt; 300;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /view_log/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;video&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;video_id&quot;
      },
      &quot;aggs&quot;: {
        &quot;avg_duration&quot;: {
          &quot;avg&quot;: {
            &quot;field&quot;: &quot;watch_duration&quot;
          } 
        },
        &quot;avg_duration_filter&quot;: {
          &quot;bucket_selector&quot;: {
            &quot;buckets_path&quot;: {
              &quot;avg_duration&quot;: &quot;avg_duration&quot;
              },
              &quot;script&quot;: {
                &quot;source&quot;: &quot;params.avg_duration &amp;gt; 200&quot;
              }
          }  
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;response:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;took&quot;: 137,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 255,
    &quot;max_score&quot;: 0,
    &quot;hits&quot;: []
  },
  &quot;aggregations&quot;: {
    &quot;video&quot;: {
      &quot;buckets&quot;: [
        {
          &quot;key&quot;: 5417499764062,
          &quot;doc_count&quot;: 91576,
          &quot;avg_duration&quot;: {
            &quot;value&quot;: 103
          }
        },
        {
          &quot;key&quot;: 19913672446898144,
          &quot;doc_count&quot;: 15771,
          &quot;avg_duration&quot;: {
            &quot;value&quot;: 197
          }
        }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 18 Aug 2018 18:50:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>以观看日志分析为例，介绍各种常用的ElasticSearch聚合操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/9499534.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--17 利用几何着色器实现公告板效果 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9495616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9495616.html</guid>
<description>&lt;p&gt;上一章我们知道了如何使用几何着色器将顶点通过流输出阶段输出到绑定的顶点缓冲区。接下来我们继续利用它来实现一些新的效果，在这一章，你将了解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现公告板效果&lt;/li&gt;
&lt;li&gt;Alpha-To-Coverage&lt;/li&gt;
&lt;li&gt;对GPU资源进行读/写操作&lt;/li&gt;
&lt;li&gt;纹理数组&lt;/li&gt;
&lt;li&gt;实现雾效&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;虽然这部分与几何着色器并没有什么关系，但是雾的效果在该Demo中会用到，并且前面也没有讲过这部分内容，故先在这里提出来。&lt;/p&gt;
&lt;p&gt;有时候我们需要在游戏中模拟一些特定的天气条件，比如说大雾。它可以让物体平滑出现而不是突然蹦出来那样（物体的一部分留在视锥体内使得只能看到该部分，然后在逐渐靠近该物体的时候，该物体就像经过了一个无形的扫描门被逐渐构造出来那样）。通过让雾在某一范围内具有一定的层次（让不可见区域比视锥体裁剪区域还近），我们可以避免上面所说的情况。但即便是晴朗的天气，你可能仍希望包含一个较广范围的雾效，即距离达到很远的地方才逐渐看不清物体。&lt;/p&gt;
&lt;p&gt;我们可以使用这种方式来实现雾效：指定雾的颜色，以摄像机为原点的雾开始的最小距离，雾效范围值（超过起始距离+雾效范围值的范围外的颜色皆被指定的雾色取代）。在需要绘制的三角形内，某一像素片元的颜色如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{align} foggedColor &amp;amp;= litColor + s(fogColor - litColor)\\ &amp;amp;= (1-s) \cdot litColor + s \cdot fogColor\\ \end{align}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该函数对应HLSL中的lerp函数，s取0的时候最终颜色为litColor，然后逐渐增大并逼近1的时候，最终颜色就逐渐趋近于fogColor。然后参数s的值取决于下面的函数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(s = saturate(\frac{dist(\mathbf{p},\mathbf{E}) - fogStart}{fogRange})\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(saturate(x) = \begin{cases} x, 0 \le x \le 1\\ 0, x &amp;lt; 0\\ 1, x &amp;gt; 1\\ \end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中dist(&lt;strong&gt;p&lt;/strong&gt;,&lt;strong&gt;E&lt;/strong&gt;)指的是两点之间的距离值。配合下面的图去理解：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180817230016681-1800115404.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有注意一点，在每次清空重新绘制的时候，要用雾的颜色进行清空。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码&quot;&gt;HLSL代码&lt;/h2&gt;
&lt;p&gt;与雾效相关的值存储在下面的常量缓冲区中，并且绘制3D物体的顶点没有发生变化：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Basic.fx
// ...

cbuffer CBDrawingStates : register(b2)
{
    float4 gFogColor;
    int gFogEnabled;
    float gFogStart;
    float gFogRange;
}

// ...
struct Vertex3DIn
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float2 Tex : TEXCOORD;
};

struct Vertex3DOut
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION; // 在世界中的位置
    float3 NormalW : NORMAL; // 法向量在世界中的方向
    float2 Tex : TEXCOORD;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Basic_VS_3D.hlsl&lt;/code&gt;也与之前一样，没有什么变动：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Basic_VS_3D.hlsl
#include &quot;Basic.fx&quot;

// 顶点着色器(3D)
Vertex3DOut VS_3D(Vertex3DIn pIn)
{
    Vertex3DOut pOut;
    
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), gWorld).xyz;
    pOut.NormalW = mul(pIn.NormalL, (float3x3) gWorldInvTranspose);
    pOut.Tex = mul(float4(pIn.Tex, 0.0f, 1.0f), gTexTransform).xy;
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;Basic_PS_3D.hlsl&lt;/code&gt;现在使用了4盏方向光以保证4种不同方向的光能够均匀照射，并添加了雾效部分的处理：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Basic_PS_3D.hlsl
#include &quot;Basic.fx&quot;

// 像素着色器(3D)
float4 PS_3D(Vertex3DOut pIn) : SV_Target
{
    // 提前进行裁剪，对不符合要求的像素可以避免后续运算
    float4 texColor = tex.Sample(sam, pIn.Tex);
    clip(texColor.a - 0.05f);

    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 求出顶点指向眼睛的向量，以及顶点与眼睛的距离
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);
    float distToEye = distance(gEyePosW, pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 A = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 D = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 S = float4(0.0f, 0.0f, 0.0f, 0.0f);

    [unroll]
    for (int i = 0; i &amp;lt; 4; ++i)
    {
        ComputeDirectionalLight(gMaterial, gDirLight[i], pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    
    float4 litColor = texColor * (ambient + diffuse) + spec;

    // 雾效部分
    [flatten]
    if (gFogEnabled)
    {
        // 限定在0.0f到1.0f范围
        float fogLerp = saturate((distToEye - gFogStart) / gFogRange);
        // 根据雾色和光照颜色进行线性插值
        litColor = lerp(litColor, gFogColor, fogLerp);
    }

    litColor.a = texColor.a * gMaterial.Diffuse.a;
    return litColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于白天来说，我们可以使用&lt;code&gt;RGBA=(0.75f, 0.75f, 0.75f, 1.0f)&lt;/code&gt;来作为雾的颜色。&lt;/p&gt;
&lt;p&gt;而对于黑夜来说，这个雾效更像是战争迷雾的效果，我们使用&lt;code&gt;RGBA=(0.0f, 0.0f, 0.0f, 1.0f)&lt;/code&gt;来作为雾的颜色，这样远处的物体我们就让它看不见，而在可视范围内，距离越远的物体能见度越低。&lt;/p&gt;
&lt;p&gt;具体的演示效果在最后可以看到。&lt;/p&gt;

&lt;p&gt;当一棵树离摄像机太远的话，我们可以使用公告板技术，用一张树的贴图来进行绘制，取代原来绘制3D树模型的方式。首先我们给出树的纹理贴图组成：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180817215205852-1724469805.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注Alpha通道部分，白色区域指代Alpha值为1.0（完全不透明），而黑色区域指代Alpha值0.0（完全透明）。所以在渲染树纹理的时候，我们只需要对Alpha值为0.0的像素区域进行裁剪即可。&lt;/p&gt;
&lt;p&gt;实现公告板的关键点在于：公告板要永远正向摄像机（即视线要与公告板表面垂直），使得用户的视线在x0z面上的投影一直与贴图表面垂直。这样做省去了大量顶点的输入和处理，显得更加高效，并且这个小技巧还能够欺骗玩家让人误以为还是原来的3D模型（眼尖的玩家还是有可能认得出来），只要你别一开始就告诉人家这棵树的绘制用了公告板原理就行了(→_→)。&lt;/p&gt;
&lt;p&gt;现在不考虑坐标系的Y轴部分（即从上方俯视），从下面的图可以看到，公告板投影的中心部分的法向量是直接指向摄像机的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180814145646775-424398304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们可以得到公告板的u轴, v轴和w轴单位向量以及根据公告板构建的局部坐标系：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{w}=\frac{(E_x-C_x,0,E_z-C_z)}{E_x-C_x,0,E_z-C_z}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{v}=(0,1,0)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{u}=\mathbf{v}\times\mathbf{w}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后已知中心顶点位置、树宽度和高度，就可以求得2D树矩形的四个顶点了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 计算出公告板矩形的四个顶点
//            up
//       v1___|___v3
//        |   |   |
// right__|___|   |
//        |__/____|
//       v0 /     v2
//        look  
v[0] = float4(center + halfWidth * right - halfHeight * up, 1.0f);
v[1] = float4(center + halfWidth * right + halfHeight * up, 1.0f);
v[2] = float4(center - halfWidth * right - halfHeight * up, 1.0f);
v[3] = float4(center - halfWidth * right + halfHeight * up, 1.0f);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的加减运算是针对&lt;code&gt;float3&lt;/code&gt;进行的，然后用1.0f填充成4D向量。并且由于每个公告板所处的局部坐标系不一样，我们需要对它们分别计算出对应的坐标轴向量。&lt;/p&gt;
&lt;p&gt;若现在我们需要绘制公告板，则在输入的时候仅提供对应的中心顶点，然后图元类型选择&lt;code&gt;D3D11_PRIMITIVE_TOPOLOGY_POINTLIST&lt;/code&gt;，在几何着色阶段我们直接将顶点直传到几何着色阶段，这些顶点传递给几何着色器后就会解释成一个个矩形（两个三角形），产生公告板。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码-1&quot;&gt;HLSL代码&lt;/h2&gt;
&lt;p&gt;下面是&lt;code&gt;Basic.fx&lt;/code&gt;的完整代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Basic.fx

#include &quot;LightHelper.hlsli&quot;

Texture2D tex : register(t0);
Texture2DArray texArray : register(t1);
SamplerState sam : register(s0);


cbuffer CBChangesEveryDrawing : register(b0)
{
    row_major matrix gWorld;
    row_major matrix gWorldInvTranspose;
    row_major matrix gTexTransform;
    Material gMaterial;
}

cbuffer CBChangesEveryFrame : register(b1)
{
    row_major matrix gView;
    float3 gEyePosW;
}

cbuffer CBDrawingStates : register(b2)
{
    float4 gFogColor;
    int gFogEnabled;
    float gFogStart;
    float gFogRange;
}

cbuffer CBChangesOnResize : register(b3)
{
    row_major matrix gProj;
}

cbuffer CBNeverChange : register(b4)
{
    DirectionalLight gDirLight[4];
}



struct Vertex3DIn
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float2 Tex : TEXCOORD;
};

struct Vertex3DOut
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION; // 在世界中的位置
    float3 NormalW : NORMAL; // 法向量在世界中的方向
    float2 Tex : TEXCOORD;
};

struct PointSprite
{
    float3 PosW : POSITION;
    float2 SizeW : SIZE;
};

struct BillboardVertex
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;
    float3 NormalW : NORMAL;
    float2 Tex : TEXCOORD;
    uint PrimID : SV_PrimitiveID;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于顶点着色器，仅负责顶点的直传：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Billboard_VS.hlsl

#include &quot;Basic.fx&quot;

PointSprite VS(PointSprite pIn)
{
    return pIn;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而几何着色器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Billboard_GS.hlsl

#include &quot;Basic.fx&quot;

// 节省内存资源，先用float4向量声明。
static const float4 gVec[2] = { float4(0.0f, 1.0f, 0.0f, 0.0f), float4(1.0f, 1.0f, 1.0f, 0.0f) };
static const float2 gTex[4] = (float2[4])gVec;

[maxvertexcount(4)]
void GS(point PointSprite input[1], uint primID : SV_PrimitiveID, 
    inout TriangleStream&amp;lt;BillboardVertex&amp;gt; output)
{
    // 计算公告板所处的局部坐标系，其中公告板相当于
    // 被投影在了局部坐标系的xy平面，z轴

    float3 up = float3(0.0f, 1.0f, 0.0f);
    float3 look = gEyePosW - input[0].PosW;
    look.y = 0.0f;  // look向量只取投影到xz平面的向量
    look = normalize(look);
    float3 right = cross(up, look);

    // 计算出公告板矩形的四个顶点
    //            up
    //      v1 ___|___ v3
    //        |   |   |
    // right__|___|   |
    //        |  /    |
    //        |_/_____|
    //      v0 /       v2
    //       look  
    float4 v[4];
    float3 center = input[0].PosW;
    float halfWidth = 0.5f * input[0].SizeW.x;
    float halfHeight = 0.5f * input[0].SizeW.y;
    v[0] = float4(center + halfWidth * right - halfHeight * up, 1.0f);
    v[1] = float4(center + halfWidth * right + halfHeight * up, 1.0f);
    v[2] = float4(center - halfWidth * right - halfHeight * up, 1.0f);
    v[3] = float4(center - halfWidth * right + halfHeight * up, 1.0f);

    // 对顶点位置进行矩阵变换，并以TriangleStrip形式输出
    BillboardVertex gOut;
    row_major matrix viewProj = mul(gView, gProj);
    [unroll]
    for (int i = 0; i &amp;lt; 4; ++i)
    {
        gOut.PosW = v[i].xyz;
        gOut.PosH = mul(v[i], viewProj);
        gOut.NormalW = look;
        gOut.Tex = gTex[i];
        gOut.PrimID = primID;
        output.Append(gOut);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先一开始不用float2数组是因为每个float2元素会单独打包，浪费了一半的空间，因此这里采取一种特殊的语法形式使得内存可以得到充分利用。&lt;/p&gt;
&lt;p&gt;然后要注意&lt;code&gt;maxvertexcount&lt;/code&gt;的值要设为4，尽管Append的次数为4，但实际上输出的三角形顶点数为6。&lt;/p&gt;
&lt;h3 id=&quot;图元id&quot;&gt;图元ID&lt;/h3&gt;
&lt;p&gt;现在讲述系统值&lt;code&gt;SV_PrimitiveID&lt;/code&gt;，我们可以将它作为函数的额外形参进行提供。它告诉我们在输入装配阶段下自动分配的图元ID值。当我们调用了一个draw方法，需要绘制n个图元，那么第一个图元对应的ID值为0，第二个为1，直到最后一个为n-1.当前的所有图元ID仅在当前的单次调用绘制是唯一的。其中该系统值的写入操作允许在几何着色器和像素着色器进行，而读取操作则允许在几何/像素/外壳/域着色器中进行。&lt;/p&gt;
&lt;p&gt;在上面的例子中，我们将一个顶点产生的矩形四个顶点都标记为同一个图元ID，是因为到后续的像素着色器中，我们用该图元ID映射到纹理数组的索引值，来对应到要绘制的树的纹理。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 如果几何着色器没有提供图元ID，在像素着色器中也可以将它加进参数列表中以使用：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;float4 PS(Vertex3DOut pin, uint primID : SV_PrimitiveID) : SV_Target
{
// Pixel shader body…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果像素着色器提供了图元ID，渲染管线又绑定了几何着色器，则几何着色器必须提供该参数。在几何着色器中你可以使用或修改图元ID值。&lt;/p&gt;
&lt;h3 id=&quot;顶点id&quot;&gt;顶点ID&lt;/h3&gt;
&lt;p&gt;紧接着是系统值&lt;code&gt;SV_VertexID&lt;/code&gt;，在输入装配阶段的时候渲染管线就会为这些输入的顶点分配顶点ID值。若使用的是&lt;code&gt;Draw&lt;/code&gt;方法，则这些顶点将会按顺序从0到n-1被标记（n为顶点数目）；若使用的是&lt;code&gt;DrawIndexed&lt;/code&gt;方法，则顶点ID对应到的是该顶点所处的索引值。该参数仅能在顶点着色器的参数列表中提供：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;VertexOut VS(VertexIn vin, uint vertID : SV_VertexID)
{
// vertex shader body…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后给出像素着色器的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Billboard_PS.hlsl

#include &quot;Basic.fx&quot;

float4 PS(BillboardVertex pIn) : SV_Target
{
    // 每4棵树一个循环，尽量保证出现不同的树
    float4 texColor = texArray.Sample(sam, float3(pIn.Tex, pIn.PrimID % 4));
    // 提前进行裁剪，对不符合要求的像素可以避免后续运算
    clip(texColor.a - 0.05f);

    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 求出顶点指向眼睛的向量，以及顶点与眼睛的距离
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);
    float distToEye = distance(gEyePosW, pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 A = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 D = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 S = float4(0.0f, 0.0f, 0.0f, 0.0f);

    [unroll]
    for (int i = 0; i &amp;lt; 4; ++i)
    {
        ComputeDirectionalLight(gMaterial, gDirLight[i], pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }

    float4 litColor = texColor * (ambient + diffuse) + spec;

    // 雾效部分
    [flatten]
    if (gFogEnabled)
    {
        // 限定在0.0f到1.0f范围
        float fogLerp = saturate((distToEye - gFogStart) / gFogRange);
        // 根据雾色和光照颜色进行线性插值
        litColor = lerp(litColor, gFogColor, fogLerp);
    }

    litColor.a = texColor.a * gMaterial.Diffuse.a;
    return litColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里加上了刚才的雾效，并使用了纹理数组。&lt;/p&gt;

&lt;p&gt;之前在C++代码层中，我们的每一张纹理使用&lt;code&gt;ID3D11Texture2D&lt;/code&gt;的接口对象去单独存储。但实际上在我们创建&lt;code&gt;ID3D11Texture2D&lt;/code&gt;对象的时候，我们可以设置它的&lt;code&gt;ArraySize&lt;/code&gt;来指定该对象可以存放的纹理数目。&lt;/p&gt;
&lt;p&gt;但是我们创建纹理并不是使用&lt;code&gt;D3DX&lt;/code&gt;系列的函数，因为我们根本就不使用DirectX SDK。在之前我们创建纹理使用的是&lt;code&gt;DDSTextureLoader.h&lt;/code&gt;和&lt;code&gt;WICTextureLoader.h&lt;/code&gt;中的函数。这里再提及一下，这两个头文件对应的库可以在下面两个途径找到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/DirectXTex&quot;&gt;DirectXTex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/DirectXTK&quot;&gt;DirectXTK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回到HLSL代码，我们之所以不使用下面的这种形式创建纹理数组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Texture2D TexArray[4];

float4 PS(GeoOut pin) : SV_Target
{
    float4 c = TexArray[pin.PrimID%4].Sample(samLinear, pin.Tex);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是因为这样做的话HLSL编译器会报错：sampler array index must be a literal experssion，即pin.PrimID的值也必须是个字面值，而不是变量。但我们还是想要能够根据变量取对应纹理的能力。&lt;/p&gt;
&lt;p&gt;正确的做法应当是声明一个&lt;code&gt;Texture2DArray&lt;/code&gt;的数组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Texture2DArray texArray : register(t1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用的是索引为1的纹理寄存器是因为前面还有一个纹理已经绑定了t0.&lt;/p&gt;
&lt;h2 id=&quot;纹理数组的采样&quot;&gt;纹理数组的采样&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Texture2DArray&lt;/code&gt;同样也具有&lt;code&gt;Sample&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 每4棵树一个循环，尽量保证出现不同的树
float4 texColor = texArray.Sample(sam, float3(pIn.Tex, pIn.PrimID % 4));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数依然是采样器&lt;/p&gt;
&lt;p&gt;而第二个参数则是一个3D向量，其中x与y的值对应的还是纹理坐标，而z分量即便是个&lt;code&gt;float&lt;/code&gt;，主要是用于作为索引值选取纹理数组中的某一个具体纹理。同理索引值0对应纹理数组的第一张纹理，1对应的是第二张纹理等等...&lt;/p&gt;
&lt;p&gt;在我们的这个demo中，纹理数组存放了4张不同样式的树的纹理贴图，然后用&lt;code&gt;SV_Primitive&lt;/code&gt;模4的值来决定哪张树纹理贴图将被绘制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180818104507737-899622567.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用纹理数组的优势是，我们可以一次性预先创建好所有需要用到的纹理，并绑定到HLSL的纹理数组中，而不需要每次都重新绑定一个纹理。然后我们再使用索引值来访问纹理数组中的某一纹理。&lt;/p&gt;
&lt;h2 id=&quot;纹理数组的加载&quot;&gt;纹理数组的加载&lt;/h2&gt;
&lt;p&gt;现在我们手头上仅有的就是&lt;code&gt;DDSTextureLoader.h&lt;/code&gt;和&lt;code&gt;WICTextureLoader.h&lt;/code&gt;中的函数，但这里面的函数每次都只能加载一张纹理。我们还需要修改龙书样例中读取纹理的函数，具体的操作顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个个读取存有纹理的文件，创建出一系列&lt;code&gt;ID3D11Texture2D&lt;/code&gt;对象，这里的每个对象单独包含一张纹理；&lt;/li&gt;
&lt;li&gt;创建一个&lt;code&gt;ID3D11Texture2D&lt;/code&gt;对象，它同时也是一个纹理数组；&lt;/li&gt;
&lt;li&gt;将之前读取的所有纹理有条理地复制到刚创建的纹理数组对象中；&lt;/li&gt;
&lt;li&gt;为该纹理数组对象创建创建一个纹理资源视图（Shader Resource View）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先我们需要了解增强版的纹理创建函数。&lt;/p&gt;
&lt;h3 id=&quot;createddstexturefromfileex函数--使用更多的参数从文件中读取dds纹理&quot;&gt;CreateDDSTextureFromFileEx函数--使用更多的参数，从文件中读取DDS纹理&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateDDSTextureFromFileEx(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    ID3D11DeviceContext* d3dContext,        // [In]D3D设备上下文(可选)
    const wchar_t* szFileName,              // [In].dds文件名
    size_t maxsize,                         // [In]最大允许mipmap等级，默认0
    D3D11_USAGE usage,                      // [In]D3D11_USAGE枚举值类型，指定CPU/GPU读写权限
    unsigned int bindFlags,                 // [In]绑定标签，指定它可以被绑定到什么对象上
    unsigned int cpuAccessFlags,            // [In]CPU访问权限标签
    unsigned int miscFlags,                 // [In]杂项标签，忽略
    bool forceSRGB,                         // [In]强制使用SRGB，默认false
    ID3D11Resource** texture,               // [Out]获取创建好的纹理(可选)
    ID3D11ShaderResourceView** textureView, // [Out]获取创建好的纹理资源视图(可选)
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [Out]忽略(可选)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，图片的数据格式、宽度、高度等信息都是随文件读取的时候获得的，我们无法在这里指定。所以我们要求提供的所有DDS纹理宽度、高度、数据格式都应当一致。对于数据格式不一致的，我们可以使用&lt;code&gt;DirectX Texture Tool&lt;/code&gt;来修改，但是该程序包含在DirectX SDK中，这里我在Github上尝试提供单独的&lt;code&gt;DxTex.exe&lt;/code&gt;程序看能不能直接使用。现在我预先确保Demo中的4张树纹理都设置为同样的数据格式。&lt;/p&gt;
&lt;p&gt;第一步，读取一系列纹理的代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// 1. 读取所有纹理
//
size_t size = filenames.size();
std::vector&amp;lt;ComPtr&amp;lt;ID3D11Texture2D&amp;gt;&amp;gt; srcTex(size);
UINT mipLevel = maxMipMapSize;
UINT width, height;
DXGI_FORMAT format;
for (size_t i = 0; i &amp;lt; size; ++i)
{
    // 由于这些纹理并不会被GPU使用，我们使用D3D11_USAGE_STAGING枚举值
    // 使得CPU可以读取资源
    HR(CreateDDSTextureFromFileEx(device.Get(),
        deviceContext.Get(),
        filenames[i].c_str(),
        maxMipMapSize,
        D3D11_USAGE_STAGING,                            // Usage
        0,                                              // BindFlags
        D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ, // CpuAccessFlags
        0,                                              // MiscFlags
        false,
        (ID3D11Resource**)srcTex[i].GetAddressOf(),
        nullptr));

    // 读取创建好的纹理Mipmap等级, 宽度和高度
    D3D11_TEXTURE2D_DESC texDesc;
    srcTex[i]-&amp;gt;GetDesc(&amp;amp;texDesc);
    if (i == 0)
    {
        mipLevel = texDesc.MipLevels;
        width = texDesc.Width;
        height = texDesc.Height;
        format = texDesc.Format;
    }
    // 这里断言所有纹理的MipMap等级，宽度和高度应当一致
    assert(mipLevel == texDesc.MipLevels);
    assert(texDesc.Width == width &amp;amp;&amp;amp; texDesc.Height == height);
    // 这里要求所有提供的图片数据格式应当是一致的，若存在不一致的情况，请
    // 使用dxtex.exe(DirectX Texture Tool)将所有的图片转成一致的数据格式
    assert(texDesc.Format == format);
        
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的第二步就是创建纹理数组，我们使用第一个纹理的描述去填充纹理数组的一部分描述：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// 2.创建纹理数组
//
D3D11_TEXTURE2D_DESC texDesc, texArrayDesc;
srcTex[0]-&amp;gt;GetDesc(&amp;amp;texDesc);
texArrayDesc.Width = texDesc.Width;
texArrayDesc.Height = texDesc.Height;
texArrayDesc.MipLevels = texDesc.MipLevels;
texArrayDesc.ArraySize = size;
texArrayDesc.Format = texDesc.Format;
texArrayDesc.SampleDesc.Count = 1;
texArrayDesc.SampleDesc.Quality = 0;
texArrayDesc.Usage = D3D11_USAGE_DEFAULT;
texArrayDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
texArrayDesc.CPUAccessFlags = 0;
texArrayDesc.MiscFlags = 0;

ComPtr&amp;lt;ID3D11Texture2D&amp;gt; texArray;
HR(device-&amp;gt;CreateTexture2D(&amp;amp;texArrayDesc, nullptr, texArray.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第三步进行复制之前，我们还需要了解纹理的子资源&lt;/p&gt;
&lt;h3 id=&quot;纹理子资源texture-subresources&quot;&gt;纹理子资源(Texture Subresources)&lt;/h3&gt;
&lt;p&gt;从&lt;code&gt;WICTextureLoader&lt;/code&gt;或者&lt;code&gt;DDSTextureLoader&lt;/code&gt;读取出来的纹理数据实际上并不是由单纯的一个二维数组构成，而是多个不同大小的二维数组，不同的mipmap等级对应不同的二维数组，这些二维数组都是该纹理的子资源。比如512x512的纹理加载进来包含的mipmap等级数(Mipmap Levels)为10，包含了从512x512, 256x256, 128x128...到1x1的10个二维数组颜色数据，而Direct3D API使用Mip切片(Mip slice)来指定某一mipmap等级的纹理，也有点像索引。比如mip slice值为0时，对应的是512x512的纹理，而mip slice值1对应的是256x256，以此类推。&lt;/p&gt;
&lt;p&gt;对于纹理数组，每个元素就上面说的单个纹理对应的mipmap链，Direct3D API使用数组切片(array slice)来访问不同纹理，也是相当于索引.这样我们就可以把所有的纹理资源用下面的图来表示，假定下图有4个纹理，每个纹理包含3个子资源，则当前指定的是Array Slice为2，Mip Slice为1的子资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180818163805670-826248257.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;d3d11calcsubresource函数--计算子资源的索引值&quot;&gt;D3D11CalcSubresource函数--计算子资源的索引值&lt;/h3&gt;
&lt;p&gt;对于纹理数组的每一个子资源都可以用一个一维的索引值访问，索引值的增减是以Mip切片值为主递增的。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180818164554848-1396823168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后给定当前纹理数组的mipmap等级数(Mipmap Levels)，数组切片(Array Slice)和Mip切片(Mip Slice)，我们就可以用下面的函数来求得指定子资源的索引值：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline UINT D3D11CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT MipLevels )
{ return MipSlice + ArraySlice * MipLevels; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是映射相关的两个函数&lt;/p&gt;
&lt;h3 id=&quot;id3d11devicecontextmap函数--获取指向子资源中数据的指针并拒绝gpu对该子资源的访问&quot;&gt;ID3D11DeviceContext::Map函数--获取指向子资源中数据的指针并拒绝GPU对该子资源的访问&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11DeviceContext::Map(
    ID3D11Resource           *pResource,          // [In]包含ID3D11Resource接口的资源对象
    UINT                     Subresource,         // [In]子资源索引
    D3D11_MAP                MapType,             // [In]D3D11_MAP枚举值，指定读写相关操作
    UINT                     MapFlags,            // [In]填0，忽略
    D3D11_MAPPED_SUBRESOURCE *pMappedResource     // [Out]获取到的已经映射到内存的子资源
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;D3D11_MAP枚举值类型的成员如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_READ&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于读取。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_READ标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_WRITE标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_READ_WRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于读写。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_READ和D3D11_CPU_ACCESS_WRITE标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE_DISCARD&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入，之前的资源数据将会被抛弃。该&lt;br/&gt;资源在创建的时候必须绑定了D3D11_CPU_ACCESS_WRITE和&lt;br/&gt;D3D11_USAGE_DYNAMIC标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE_NO_OVERWRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入，但不能复写已经存在的资源。&lt;br/&gt;该枚举值只能用于顶点/索引缓冲区。该资源在创建的时候需要&lt;br/&gt;有D3D11_CPU_ACCESS_WRITE标签，在Direct3D 11不能用于&lt;br/&gt;设置了D3D11_BIND_CONSTANT_BUFFER标签的资源，但在&lt;br/&gt;11.1后可以。具体可以查阅MSDN文档&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;id3d11devicecontextunmap函数--让指向资源的指针无效并重新启用gpu对该资源的访问权限&quot;&gt;ID3D11DeviceContext::UnMap函数--让指向资源的指针无效并重新启用GPU对该资源的访问权限&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::Unmap(
    ID3D11Resource *pResource,      // [In]包含ID3D11Resource接口的资源对象
    UINT           Subresource      // [In]需要取消的子资源索引
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步的具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// 3.将所有的纹理子资源赋值到纹理数组中
//

// 每个纹理元素
for (size_t i = 0; i &amp;lt; size; ++i)
{
    // 纹理中的每个mipmap等级
    for (UINT j = 0; j &amp;lt; mipLevel; ++j)
    {
        D3D11_MAPPED_SUBRESOURCE mappedTex2D;
        // 允许映射索引i纹理中，索引j的mipmap等级的2D纹理
        HR(deviceContext-&amp;gt;Map(srcTex[i].Get(),
            j, D3D11_MAP_READ, 0, &amp;amp;mappedTex2D));
        deviceContext-&amp;gt;UpdateSubresource(
            texArray.Get(),
            D3D11CalcSubresource(j, i, mipLevel),   // i * mipLevel + j
            nullptr,
            mappedTex2D.pData,
            mappedTex2D.RowPitch,
            mappedTex2D.DepthPitch);
        // 停止映射
        deviceContext-&amp;gt;Unmap(srcTex[i].Get(), j);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一步就是要创建着色器资源视图。&lt;/p&gt;
&lt;h3 id=&quot;id3d11devicecontextcreateshaderresourceview--创建着色器资源视图&quot;&gt;ID3D11DeviceContext::CreateShaderResourceView--创建着色器资源视图&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateShaderResourceView(
    ID3D11Resource                        *pResource,   // [In]待绑定资源
    const D3D11_SHADER_RESOURCE_VIEW_DESC *pDesc,       // [In]着色器资源视图描述
    ID3D11ShaderResourceView              **ppSRView    // [Out]获取创建的着色器资源视图
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以还需要填充D3D11_SHADER_RESOURCE_VIEW_DESC结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_SHADER_RESOURCE_VIEW_DESC
{
    DXGI_FORMAT Format;     // 数据格式
    D3D11_SRV_DIMENSION ViewDimension;  // 视图维度，决定下面需要填充哪个共用体成员
    union 
    {
        D3D11_BUFFER_SRV Buffer;
        D3D11_TEX1D_SRV Texture1D;
        D3D11_TEX1D_ARRAY_SRV Texture1DArray;
        D3D11_TEX2D_SRV Texture2D;
        D3D11_TEX2D_ARRAY_SRV Texture2DArray;
        D3D11_TEX2DMS_SRV Texture2DMS;
        D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray;
        D3D11_TEX3D_SRV Texture3D;
        D3D11_TEXCUBE_SRV TextureCube;
        D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray;
        D3D11_BUFFEREX_SRV BufferEx;
    };
}   D3D11_SHADER_RESOURCE_VIEW_DESC;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一步的代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// 4.创建纹理数组的SRV
//
D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
viewDesc.Format = texArrayDesc.Format;
viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
viewDesc.Texture2DArray.MostDetailedMip = 0;
viewDesc.Texture2DArray.MipLevels = texArrayDesc.MipLevels;
viewDesc.Texture2DArray.FirstArraySlice = 0;
viewDesc.Texture2DArray.ArraySize = size;

ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texArraySRV;
HR(device-&amp;gt;CreateShaderResourceView(texArray.Get(), &amp;amp;viewDesc, texArraySRV.GetAddressOf()));

// 已经确保所有资源由ComPtr管理，无需手动释放

return texArraySRV;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;createddstexture2darrayshaderresourceview函数--创建用于dds纹理的数组着色器资源视图&quot;&gt;CreateDDSTexture2DArrayShaderResourceView函数--创建用于DDS纹理的数组着色器资源视图&lt;/h3&gt;
&lt;p&gt;该函数放到了GameApp类中，你也可以单独抽离出来。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; CreateDDSTexture2DArrayShaderResourceView(
    ComPtr&amp;lt;ID3D11Device&amp;gt; device,                    // [In]D3D设备
    ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext,      // [In]D3D设备上下文
    const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; filenames,     // [In]文件名数组
    int maxMipMapSize);    // [In]最大允许mipmap等级，若为0，则使用默认纹理mipmap等级&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的函数实现就是上面四步的所有代码。&lt;/p&gt;

&lt;p&gt;在Demo运行的时候，仔细观察可以发现树公告板的某些边缘部分有一些比较突出的黑边。&lt;/p&gt;
&lt;p&gt;这是因为当前默认使用的是Alpha Test，即HLSL中使用&lt;strong&gt;clip&lt;/strong&gt;函数将Alpha值为0的像素点给剔除掉，这些像素也不是树的一部分。该函数决定某一像素是留下还是抛弃，这会导致不平滑的过渡现象，在摄像机逐渐靠近该纹理时，图片本身也在不断放大，硬边部分也会被放大，就像下面那张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180818183502975-296386356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，你也可以使用透明混合的方式，但是透明混合对绘制的顺序是有要求的，要求透明物体按从后到前的顺序进行绘制，即需要在绘制透明物体前先对物体按到摄像机的距离排个序。当然如果需要绘制大量的草丛的话，这种方法所需要的开销会变得非常大，操作起来也十分麻烦。&lt;/p&gt;
&lt;p&gt;当然，我们可以考虑下使用MSAA(多重采样抗锯齿)，并配合Alpha Test进行。MSAA可以用于将多边形的锯齿边缘平滑处理，然后让Direct3D开启alpha-to-coverage技术，标记边缘部分。&lt;/p&gt;
&lt;p&gt;首先在创建后备缓冲区、深度/模板缓冲区的时候需要打开4倍多重采样的支持，我们只需要在GameApp的构造函数中这样写即可：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;GameApp::GameApp(HINSTANCE hInstance)
    : D3DApp(hInstance)
{
    // 开启4倍多重采样
    mEnable4xMsaa = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在之前的例子里，我们已经在&lt;code&gt;RenderStates&lt;/code&gt;类中预先创建好了混合状态：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_BLEND_DESC blendDesc;
ZeroMemory(&amp;amp;blendDesc, sizeof(blendDesc));
auto&amp;amp; rtDesc = blendDesc.RenderTarget[0];
// Alpha-To-Coverage模式
blendDesc.AlphaToCoverageEnable = true;
blendDesc.IndependentBlendEnable = false;
rtDesc.BlendEnable = false;
rtDesc.RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
HR(device-&amp;gt;CreateBlendState(&amp;amp;blendDesc, BSAlphaToCoverage.ReleaseAndGetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后只需要在需要的时候绑定该状态即可。&lt;/p&gt;

&lt;p&gt;常量缓冲区对应的结构体和BasicFX类的变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#ifndef BASICFX_H
#define BASICFX_H

#include &amp;lt;wrl/client.h&amp;gt;
#include &amp;lt;d3d11_1.h&amp;gt;
#include &amp;lt;d3dcompiler.h&amp;gt;
#include &amp;lt;directxmath.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &quot;LightHelper.h&quot;
#include &quot;RenderStates.h&quot;
#include &quot;Vertex.h&quot;

// 由于常量缓冲区的创建需要是16字节的倍数，该函数可以返回合适的字节大小
inline UINT Align16Bytes(UINT size)
{
    return (size + 15) &amp;amp; (UINT)(-16);
}

struct CBChangesEveryDrawing
{
    DirectX::XMMATRIX world;
    DirectX::XMMATRIX worldInvTranspose;
    DirectX::XMMATRIX texTransform;
    Material material;
};

struct CBChangesEveryFrame
{
    DirectX::XMMATRIX view;
    DirectX::XMFLOAT4 eyePos;
};

struct CBDrawingStates
{
    DirectX::XMFLOAT4 fogColor;
    int fogEnabled;
    float fogStart;
    float fogRange;
    float pad;
};

struct CBChangesOnResize
{
    DirectX::XMMATRIX proj;
};

struct CBNeverChange
{
    DirectionalLight dirLight[4];
};

class BasicFX
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    // 初始化Basix.fx所需资源并初始化光栅化状态
    bool InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);
    // 是否已经初始化
    bool IsInit() const;

    template &amp;lt;class T&amp;gt;
    void UpdateConstantBuffer(const T&amp;amp; cbuffer);

    // 默认状态绘制
    void SetRenderDefault();

    // 公告板绘制
    void SetRenderBillboard(bool enableAlphaToCoverage);

private:
    // objFileNameInOut为编译好的着色器二进制文件(.*so)，若有指定则优先寻找该文件并读取
    // hlslFileName为着色器代码，若未找到着色器二进制文件则编译着色器代码
    // 编译成功后，若指定了objFileNameInOut，则保存编译好的着色器二进制信息到该文件
    // ppBlobOut输出着色器二进制信息
    HRESULT CreateShaderFromFile(const WCHAR* objFileNameInOut, const WCHAR* hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob** ppBlobOut);

private:
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mBasicVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mBasicPS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mBillboardVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mBillboardGS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mBillboardPS;


    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosSizeLayout;         // 点精灵输入布局
    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosNormalTexLayout;    // 3D顶点输入布局

    ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; md3dImmediateContext;       // 设备上下文

    std::vector&amp;lt;ComPtr&amp;lt;ID3D11Buffer&amp;gt;&amp;gt; mConstantBuffers;     // 常量缓冲区
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化函数和&lt;code&gt;SetRenderDeafult&lt;/code&gt;方法这里就不赘述了。&lt;/p&gt;
&lt;h2 id=&quot;basicfxsetrenderbillboard方法--公告板绘制&quot;&gt;BasicFX::SetRenderBillboard方法--公告板绘制&lt;/h2&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderBillboard(bool enableAlphaToCoverage)
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosSizeLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mBillboardVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mBillboardGS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mBillboardPS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(nullptr, 0);
    md3dImmediateContext-&amp;gt;OMSetBlendState(
        (enableAlphaToCoverage ? RenderStates::BSAlphaToCoverage.Get() : nullptr),
        nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数&lt;code&gt;enableAlphaToCoverage&lt;/code&gt;决定是否要绑定渲染状态对象&lt;code&gt;RenderStates::BSAlphaToCoverage&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;类成员相关声明如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class GameApp : public D3DApp
{
public:
    // 摄像机模式
    enum class CameraMode { FirstPerson, ThirdPerson, Free };
    
public:
    GameApp(HINSTANCE hInstance);
    ~GameApp();

    bool Init();
    void OnResize();
    void UpdateScene(float dt);
    void DrawScene();

private:
    bool InitResource();
    void InitPointSpritesBuffer();

    // 根据给定的DDS纹理文件集合，创建2D纹理数组
    // 要求所有纹理的宽度和高度都一致
    // 若maxMipMapSize为0，使用默认mipmap等级
    // 否则，mipmap等级将不会超过maxMipMapSize
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; CreateDDSTexture2DArrayShaderResourceView(
        ComPtr&amp;lt;ID3D11Device&amp;gt; device,
        ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext,
        const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; filenames,
        int maxMipMapSize = 0);


private:
    
    ComPtr&amp;lt;ID2D1SolidColorBrush&amp;gt; mColorBrush;               // 单色笔刷
    ComPtr&amp;lt;IDWriteFont&amp;gt; mFont;                              // 字体
    ComPtr&amp;lt;IDWriteTextFormat&amp;gt; mTextFormat;                  // 文本格式

    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mPointSpritesBuffer;               // 点精灵顶点缓冲区
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; mTreeTexArray;         // 树的纹理数组
    Material mTreeMat;                                      // 树的材质

    GameObject mGround;                                     // 地面
    
    BasicFX mBasicFX;                                       // Basic特效管理类

    CameraMode mCameraMode;                                 // 摄像机模式
    std::shared_ptr&amp;lt;Camera&amp;gt; mCamera;                        // 摄像机

    bool mIsNight;                                          // 是否黑夜
    bool mEnableAlphaToCoverage;                            // 是否开启Alpha-To-Coverage

    CBChangesEveryDrawing mCBChangesEveryDrawing;           // 该缓冲区存放每次绘制更新的变量
    CBChangesEveryFrame mCBChangesEveryFrame;               // 该缓冲区存放每帧更新的变量
    CBDrawingStates mCBDrawingStates;                       // 该缓冲区存放绘制状态
    CBChangesOnResize mCBChangesOnReSize;                   // 该缓冲区存放仅在窗口大小变化时更新的变量
    CBNeverChange mCBNeverChange;                           // 该缓冲区存放不会再进行修改的变量
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameappinitpointspritesbuffer方法--初始化存放点精灵的缓冲区&quot;&gt;GameApp::InitPointSpritesBuffer方法--初始化存放点精灵的缓冲区&lt;/h2&gt;
&lt;p&gt;该方法会生成20个顶点，均匀并略带随机性地环绕在原点周围。这些顶点一经创建就不可以被修改了，它们将会被用于公告板的创建：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::InitPointSpritesBuffer()
{
    srand((unsigned)time(nullptr));
    VertexPosSize vertexes[16];
    float theta = 0.0f;
    for (int i = 0; i &amp;lt; 16; ++i)
    {
        // 取20-50的半径放置随机的树
        float radius = (float)(rand() % 31 + 20);
        float randomRad = rand() % 256 / 256.0f * XM_2PI / 16;
        vertexes[i].pos = XMFLOAT3(radius * cosf(theta + randomRad), 8.0f, radius * sinf(theta + randomRad));
        vertexes[i].size = XMFLOAT2(30.0f, 30.0f);
        theta += XM_2PI / 16;
    }

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_IMMUTABLE;  // 数据不可修改
    vbd.ByteWidth = sizeof (vertexes);
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertexes;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mPointSpritesBuffer.GetAddressOf()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameappinitresource方法--初始化资源&quot;&gt;GameApp::InitResource方法--初始化资源&lt;/h2&gt;
&lt;p&gt;该方法集成了所有资源的初始化，注意树的纹理数组要提供到输入槽1，对应纹理寄存器t1的&lt;code&gt;Texture2DArray&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool GameApp::InitResource()
{
    // 默认白天，开启AlphaToCoverage
    mIsNight = false;
    mEnableAlphaToCoverage = true;
    // ******************
    // 初始化各种物体

    // 初始化树纹理资源
    mTreeTexArray = CreateDDSTexture2DArrayShaderResourceView(
        md3dDevice,
        md3dImmediateContext,
        std::vector&amp;lt;std::wstring&amp;gt;{
        L&quot;Texture\\tree0.dds&quot;,
            L&quot;Texture\\tree1.dds&quot;,
            L&quot;Texture\\tree2.dds&quot;,
            L&quot;Texture\\tree3.dds&quot;});
    
    // 初始化点精灵缓冲区
    InitPointSpritesBuffer();

    // 初始化树的材质
    mTreeMat.Ambient = XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f);
    mTreeMat.Diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
    mTreeMat.Specular = XMFLOAT4(0.2f, 0.2f, 0.2f, 16.0f);

    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texture;
    // 初始化地板
    mGround.SetBuffer(md3dDevice, Geometry::CreatePlane(XMFLOAT3(0.0f, -5.0f, 0.0f), XMFLOAT2(100.0f, 100.0f), XMFLOAT2(10.0f, 10.0f)));
    HR(CreateDDSTextureFromFile(md3dDevice.Get(), L&quot;Texture\\Grass.dds&quot;, nullptr, texture.GetAddressOf()));
    mGround.SetTexture(texture);
    Material material;
    material.Ambient = XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f);
    material.Diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
    material.Specular = XMFLOAT4(0.2f, 0.2f, 0.2f, 16.0f);
    mGround.SetMaterial(material);
    mGround.SetWorldMatrix(XMMatrixIdentity());
    mGround.SetTexTransformMatrix(XMMatrixIdentity());

    // ******************
    // 初始化常量缓冲区的值

    mCBChangesEveryDrawing.material = mTreeMat;
    mCBChangesEveryDrawing.world = mCBChangesEveryDrawing.worldInvTranspose = XMMatrixIdentity();
    mCBChangesEveryDrawing.texTransform = XMMatrixIdentity();


    // 方向光
    mCBNeverChange.dirLight[0].Ambient = XMFLOAT4(0.1f, 0.1f, 0.1f, 1.0f);
    mCBNeverChange.dirLight[0].Diffuse = XMFLOAT4(0.25f, 0.25f, 0.25f, 1.0f);
    mCBNeverChange.dirLight[0].Specular = XMFLOAT4(0.1f, 0.1f, 0.1f, 1.0f);
    mCBNeverChange.dirLight[0].Direction = XMFLOAT3(-0.577f, -0.577f, 0.577f);
    mCBNeverChange.dirLight[1] = mCBNeverChange.dirLight[0];
    mCBNeverChange.dirLight[1].Direction = XMFLOAT3(0.577f, -0.577f, 0.577f);
    mCBNeverChange.dirLight[2] = mCBNeverChange.dirLight[0];
    mCBNeverChange.dirLight[2].Direction = XMFLOAT3(0.577f, -0.577f, -0.577f);
    mCBNeverChange.dirLight[3] = mCBNeverChange.dirLight[0];
    mCBNeverChange.dirLight[3].Direction = XMFLOAT3(-0.577f, -0.577f, -0.577f);

    // 摄像机相关
    mCameraMode = CameraMode::Free;
    auto camera = std::shared_ptr&amp;lt;FirstPersonCamera&amp;gt;(new FirstPersonCamera);
    mCamera = camera;
    camera-&amp;gt;SetPosition(XMFLOAT3());
    camera-&amp;gt;SetFrustum(XM_PI / 3, AspectRatio(), 1.0f, 1000.0f);
    camera-&amp;gt;LookTo(
        XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f),
        XMVectorSet(0.0f, 0.0f, 1.0f, 1.0f),
        XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f));
    camera-&amp;gt;UpdateViewMatrix();


    mCBChangesEveryFrame.view = camera-&amp;gt;GetView();
    XMStoreFloat4(&amp;amp;mCBChangesEveryFrame.eyePos, camera-&amp;gt;GetPositionXM());

    mCBChangesOnReSize.proj = camera-&amp;gt;GetProj();
    
    // 雾状态默认开启
    mCBDrawingStates.fogEnabled = 1;
    mCBDrawingStates.fogColor = XMFLOAT4(0.75f, 0.75f, 0.75f, 1.0f);    // 银色
    mCBDrawingStates.fogRange = 75.0f;
    mCBDrawingStates.fogStart = 15.0f;
    // 更新常量缓冲区资源
    mBasicFX.UpdateConstantBuffer(mCBChangesEveryDrawing);
    mBasicFX.UpdateConstantBuffer(mCBChangesEveryFrame);
    mBasicFX.UpdateConstantBuffer(mCBChangesOnReSize);
    mBasicFX.UpdateConstantBuffer(mCBDrawingStates);
    mBasicFX.UpdateConstantBuffer(mCBNeverChange);

    // 直接绑定树的纹理
    md3dImmediateContext-&amp;gt;PSSetShaderResources(1, 1, mTreeTexArray.GetAddressOf());
    
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其余方法限于篇幅就不放在这里了，读者可以查看源码观察剩余部分的代码实现。现在来看实现效果吧。&lt;/p&gt;

&lt;p&gt;可以观察到，在与公告版近距离接触时可以很明显地看到公告板在跟着摄像机旋转。如果距离很远的话转动的幅度就会很小，用户才会比较难以分辨出远处物体是否为公告板或3D模型了。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180819005146969-405726246.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面演示了白天和黑夜的雾效&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180819005238503-1001168458.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后则是Alpha-To-Coverage的开启/关闭效果对比&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180819010018280-853684362.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 17:12:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 上一章我们知道了如何使用几何着色器将顶点通过流输出阶段输出到绑定的顶点缓冲区。接下来我们继续利用它来实现一些新的效果，在这一章，你将了解： 1. 实现公告板效果 2. Alpha To Cove</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9495616.html</dc:identifier>
</item>
<item>
<title>惰性求值——lodash源码解读 - 我是leon</title>
<link>http://www.cnblogs.com/walls/p/9499454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walls/p/9499454.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;lodash受欢迎的一个原因，是其优异的计算性能。而其性能能有这么突出的表现，很大部分就来源于其使用的算法——惰性求值。&lt;br/&gt;本文将讲述lodash源码中，惰性求值的原理和实现。&lt;/p&gt;
&lt;h2 id=&quot;一惰性求值的原理分析&quot;&gt;一、惰性求值的原理分析&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;惰性求值（Lazy Evaluation），又译为惰性计算、懒惰求值，也称为传需求调用（call-by-need），是计算机编程中的一个概念，它的目的是要&lt;strong&gt;最小化计算机要做的工作&lt;/strong&gt;。&lt;br/&gt;惰性求值中的参数直到需要时才会进行计算。这种程序实际上是&lt;strong&gt;从末尾开始反向执行&lt;/strong&gt;的。它会判断自己需要返回什么，并继续向后执行来确定要这样做需要哪些值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是&lt;a href=&quot;http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/&quot;&gt;How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation.（如何提升Lo-Dash百倍算力？惰性计算的简介）&lt;/a&gt;文中的示例，形象地展示惰性求值。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function priceLt(x) {
   return function(item) { return item.price &amp;lt; x; };
}
var gems = [
   { name: 'Sunstone', price: 4 },
   { name: 'Amethyst', price: 15 },
   { name: 'Prehnite', price: 20},
   { name: 'Sugilite', price: 7  },
   { name: 'Diopside', price: 3 },
   { name: 'Feldspar', price: 13 },
   { name: 'Dioptase', price: 2 },
   { name: 'Sapphire', price: 20 }
];
 
var chosen = _(gems).filter(priceLt(10)).take(3).value();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序的目的，是对数据集&lt;code&gt;gems&lt;/code&gt;进行筛选，选出3个&lt;code&gt;price&lt;/code&gt;小于10的数据。&lt;/p&gt;
&lt;h3 id=&quot;一般的做法&quot;&gt;1.1 一般的做法&lt;/h3&gt;
&lt;p&gt;如果抛开&lt;code&gt;lodash&lt;/code&gt;这个工具库，让你用普通的方式实现&lt;code&gt;var chosen = _(gems).filter(priceLt(10)).take(3)&lt;/code&gt;;那么，可以用以下方式：&lt;br/&gt;&lt;code&gt;_(gems)&lt;/code&gt;拿到数据集，缓存起来。&lt;br/&gt;再执行&lt;code&gt;filter&lt;/code&gt;方法，遍历&lt;code&gt;gems&lt;/code&gt;数组（长度为10），取出符合条件的数据：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;[
   { name: 'Sunstone', price: 4 },
   { name: 'Sugilite', price: 7  },
   { name: 'Diopside', price: 3 },
   { name: 'Dioptase', price: 2 }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，执行&lt;code&gt;take&lt;/code&gt;方法，提取前3个数据。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;[
   { name: 'Sunstone', price: 4 },
   { name: 'Sugilite', price: 7  },
   { name: 'Diopside', price: 3 }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共遍历的次数为：&lt;code&gt;10+3&lt;/code&gt;。&lt;br/&gt;执行的示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangxiaokai.vip/images/2018-08-18-lazy-evaluation/1.gif&quot; alt=&quot;普通计算&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;惰性求值做法&quot;&gt;1.2 惰性求值做法&lt;/h3&gt;
&lt;p&gt;普通的做法存在一个问题：每个方法各做各的事，没有协调起来浪费了很多资源。&lt;br/&gt;如果能先把要做的事，用小本本记下来😎，然后等到真正要出数据时，再用最少的次数达到目的，岂不是更好。&lt;br/&gt;惰性计算就是这么做的。&lt;br/&gt;以下是实现的思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;_(gems)&lt;/code&gt;拿到数据集，缓存起来&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;filter&lt;/code&gt;方法，先记下来&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;take&lt;/code&gt;方法，先记下来&lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;value&lt;/code&gt;方法，说明时机到了&lt;/li&gt;
&lt;li&gt;把小本本拿出来，看下要求：要取出3个数，price&amp;lt;10&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;filter&lt;/code&gt;方法里的判断方法&lt;code&gt;priceLt&lt;/code&gt;对数据进行逐个裁决&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;[
    { name: 'Sunstone', price: 4 }, =&amp;gt; priceLt裁决 =&amp;gt; 符合要求，通过 =&amp;gt; 拿到1个
    { name: 'Amethyst', price: 15 }, =&amp;gt; priceLt裁决 =&amp;gt; 不符合要求
    { name: 'Prehnite', price: 20}, =&amp;gt; priceLt裁决 =&amp;gt; 不符合要求
    { name: 'Sugilite', price: 7  }, =&amp;gt; priceLt裁决 =&amp;gt; 符合要求，通过 =&amp;gt; 拿到2个
    { name: 'Diopside', price: 3 }, =&amp;gt; priceLt裁决 =&amp;gt; 符合要求，通过 =&amp;gt; 拿到3个 =&amp;gt; 够了，收工！
    { name: 'Feldspar', price: 13 },
    { name: 'Dioptase', price: 2 },
    { name: 'Sapphire', price: 20 }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，一共只执行了5次，就把结果拿到。&lt;br/&gt;执行的示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangxiaokai.vip/images/2018-08-18-lazy-evaluation/2.gif&quot; alt=&quot;普通计算&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;1.3 小结&lt;/h3&gt;
&lt;p&gt;从上面的例子可以得到惰性计算的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;延迟计算&lt;/strong&gt;，把要做的计算先缓存，不执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据管道&lt;/strong&gt;，逐个数据通过“裁决”方法，在这个类似安检的过程中，进行过关的操作，最后只留下符合要求的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;触发时机&lt;/strong&gt;，方法缓存，那么就需要一个方法来触发执行。lodash就是使用&lt;code&gt;value&lt;/code&gt;方法，通知真正开始计算&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二惰性求值的实现&quot;&gt;二、惰性求值的实现&lt;/h2&gt;
&lt;p&gt;依据上述的特点，我将lodash的惰性求值实现进行抽离为以下几个部分：&lt;/p&gt;
&lt;h3 id=&quot;实现延迟计算的缓存&quot;&gt;2.1 实现延迟计算的缓存&lt;/h3&gt;
&lt;p&gt;实现&lt;code&gt;_(gems)&lt;/code&gt;。我这里为了语义明确，采用&lt;code&gt;lazy(gems)&lt;/code&gt;代替。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var MAX_ARRAY_LENGTH = 4294967295; // 最大的数组长度

// 缓存数据结构体
function LazyWrapper(value){
    this.__wrapped__ = value;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
}

// 惰性求值的入口
function lazy(value){
    return new LazyWrapper(value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;this.__wrapped__&lt;/code&gt; 缓存数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this.__iteratees__&lt;/code&gt; 缓存数据管道中进行“裁决”的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this.__takeCount__&lt;/code&gt; 记录需要拿的符合要求的数据集个数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，一个基本的结构就完成了。&lt;/p&gt;
&lt;h3 id=&quot;实现filter方法&quot;&gt;2.2 实现&lt;code&gt;filter&lt;/code&gt;方法&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var LAZY_FILTER_FLAG = 1; // filter方法的标记

// 根据 筛选方法iteratee 筛选数据
function filter(iteratee){
    this.__iteratees__.push({
        'iteratee': iteratee,
        'type': LAZY_FILTER_FLAG
    });
    return this;
}

// 绑定方法到原型链上
LazyWrapper.prototype.filter = filter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;方法，将裁决方法&lt;code&gt;iteratee&lt;/code&gt;缓存起来。这里有一个重要的点，就是需要记录&lt;code&gt;iteratee&lt;/code&gt;的类型&lt;code&gt;type&lt;/code&gt;。&lt;br/&gt;因为在&lt;code&gt;lodash&lt;/code&gt;中,还有&lt;code&gt;map&lt;/code&gt;等筛选数据的方法，也是会传入一个裁决方法&lt;code&gt;iteratee&lt;/code&gt;。由于&lt;code&gt;filter&lt;/code&gt;方法和&lt;code&gt;map&lt;/code&gt;方法筛选方式不同，所以要用&lt;code&gt;type&lt;/code&gt;进行标记。&lt;br/&gt;这里还有一个技巧：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;(function(){
    // 私有方法
    function filter(iteratee){
        /* code */
    }

    // 绑定方法到原型链上
    LazyWrapper.prototype.filter = filter;
})();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原型上的方法，先用普通的函数声明，然后再绑定到原型上。如果工具内部需要使用&lt;code&gt;filter&lt;/code&gt;，则使用声明好的私有方法。&lt;br/&gt;这样的好处是，外部如果改变&lt;code&gt;LazyWrapper.prototype.filter&lt;/code&gt;，对工具内部，是没有任何影响的。&lt;/p&gt;
&lt;h3 id=&quot;实现take方法&quot;&gt;2.3 实现&lt;code&gt;take&lt;/code&gt;方法&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 截取n个数据
function take(n){
    this.__takeCount__ = n;
    return this;
};

LazyWrapper.prototype.take = take;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现value方法&quot;&gt;2.4 实现&lt;code&gt;value&lt;/code&gt;方法&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 惰性求值
function lazyValue(){
    var array = this.__wrapped__;
    var length = array.length;
    var resIndex = 0;
    var takeCount = this.__takeCount__;
    var iteratees = this.__iteratees__;
    var iterLength = iteratees.length;
    var index = -1;
    var dir = 1;
    var result = [];

    // 标签语句
    outer:
    while(length-- &amp;amp;&amp;amp; resIndex &amp;lt; takeCount){
        // 外层循环待处理的数组
        index += dir;

        var iterIndex = -1;
        var value = array[index];

        while(++iterIndex &amp;lt;　iterLength){
            // 内层循环处理链上的方法
            var data = iteratees[iterIndex];
            var iteratee = data.iteratee;
            var type = data.type;
            var computed = iteratee(value);

            // 处理数据不符合要求的情况
            if(!computed){
                if(type == LAZY_FILTER_FLAG){
                    continue outer;
                }else{
                    break outer;
                }
            }
        }

        // 经过内层循环，符合要求的数据
        result[resIndex++] = value;
    }

    return result;
}

LazyWrapper.prototype.value = lazyValue;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的一个重点就是：&lt;strong&gt;标签语句&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
    outer:
    while(length-- &amp;amp;&amp;amp; resIndex &amp;lt; takeCount){
        // 外层循环待处理的数组
        index += dir;

        var iterIndex = -1;
        var value = array[index];

        while(++iterIndex &amp;lt;　iterLength){
            // 内层循环处理链上的方法
            var data = iteratees[iterIndex];
            var iteratee = data.iteratee;
            var type = data.type;
            var computed = iteratee(value);

            // 处理数据不符合要求的情况
            if(!computed){
                if(type == LAZY_FILTER_FLAG){
                    continue outer;
                }else{
                    break outer;
                }
            }
        }

        // 经过内层循环，符合要求的数据
        result[resIndex++] = value;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前方法的数据管道实现，其实就是内层的&lt;code&gt;while&lt;/code&gt;循环。通过取出缓存在&lt;code&gt;iteratees&lt;/code&gt;中的裁决方法取出，对当前数据&lt;code&gt;value&lt;/code&gt;进行裁决。&lt;br/&gt;如果裁决结果是不符合，也即为&lt;code&gt;false&lt;/code&gt;。那么这个时候，就没必要用后续的裁决方法进行判断了。而是应该跳出当前循环。&lt;br/&gt;而如果用&lt;code&gt;break&lt;/code&gt;跳出内层循环后，外层循环中的&lt;code&gt;result[resIndex++] = value;&lt;/code&gt;还是会被执行，这是我们不希望看到的。&lt;br/&gt;应该一次性跳出内外两层循环，并且继续外层循环，才是正确的。&lt;br/&gt;标签语句，刚好可以满足这个要求。&lt;/p&gt;
&lt;h3 id=&quot;小检测&quot;&gt;2.5 小检测&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
var testArr = [1, 19, 30, 2, 12, 5, 28, 4];

lazy(testArr)
    .filter(function(x){
        console.log('check x='+x);
        return x &amp;lt; 10
    })
    .take(2)
    .value();

// 输出如下：
check x=1
check x=19
check x=30
check x=2

// 得到结果： [1, 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结-1&quot;&gt;2.6 小结&lt;/h3&gt;
&lt;p&gt;整个惰性求值的实现，重点还是在数据管道这块。以及，标签语句在这里的妙用。其实实现的方式，不只当前这种。但是，要点还是前面讲到的三个。掌握精髓，变通就很容易了。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;惰性求值，是我在阅读&lt;code&gt;lodash&lt;/code&gt;源码中，发现的最大闪光点。&lt;br/&gt;当初对惰性求值不甚理解，想看下javascript的实现，但网上也只找到上文提到的一篇文献。&lt;br/&gt;那剩下的选择，就是对lodash进行剖离分析。也因为这，才有本文的诞生。&lt;br/&gt;希望这篇文章能对你有所帮助。如果可以的话，给个star :)&lt;/p&gt;
&lt;p&gt;最后，附上本文实现的简易版&lt;code&gt;lazy.js&lt;/code&gt;完整源码：&lt;br/&gt;&lt;a href=&quot;https://github.com/wall-wxk/blogDemo/blob/master/lodash/lazy.js&quot; class=&quot;uri&quot;&gt;https://github.com/wall-wxk/blogDemo/blob/master/lodash/lazy.js&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 16:52:00 +0000</pubDate>
<dc:creator>我是leon</dc:creator>
<og:description>前言 lodash受欢迎的一个原因，是其优异的计算性能。而其性能能有这么突出的表现，很大部分就来源于其使用的算法——惰性求值。 本文将讲述lodash源码中，惰性求值的原理和实现。 一、惰性求值的原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walls/p/9499454.html</dc:identifier>
</item>
<item>
<title>为什么要配置环境变量? - 公子小白zx</title>
<link>http://www.cnblogs.com/z9x9x9/p/9499362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z9x9x9/p/9499362.html</guid>
<description>&lt;p&gt;1.安装jdk是java来发的基础,根据java语言的跨平台型可以在不同的操作系统上来安装相应的jdk;&lt;/p&gt;
&lt;p&gt;2.我们在自己的电脑上选择任意一款软件,然后右键(这里以QQ为例),会发现有打开文件位置这一选项,点击后,会发现他指向一个名字叫QQScLauncher.exe的可执行文件,&lt;/p&gt;
&lt;p&gt;我们想要运行QQ,可双击运行此文件,当然我们也可以在doc窗口来运行QQScLauncher.exe文件,我们在打开doc窗口后先进入到存放QQScLauncher.exe文件的目录下,然&lt;/p&gt;
&lt;p&gt;后输入QQScLauncher.exe,就可以了,同一个道理如果我们想要运行jvm虚拟机,同样也要执行E:\JDK\jdk1.6.0_20\bin\java.exe(在我本机上jdk存放的位置)文件;&lt;/p&gt;
&lt;p&gt;3.我们配置环境变量的目的就是想要E:\JDK\jdk1.6.0_20\bin\java.exe(在我本机上jdk存放的位置)文件,在我们本地电脑上任意目录下都可以执行E:\JDK\jdk1.6.0_20\bin\java.exe(在我本机上jdk存放的位置)文件,来方便后续的开发(具体怎么方便的学过开发后自己体会)&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 16:05:00 +0000</pubDate>
<dc:creator>公子小白zx</dc:creator>
<og:description>1.安装jdk是java来发的基础,根据java语言的跨平台型可以在不同的操作系统上来安装相应的jdk; 2.我们在自己的电脑上选择任意一款软件,然后右键(这里以QQ为例),会发现有打开文件位置这一选</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z9x9x9/p/9499362.html</dc:identifier>
</item>
<item>
<title>将HTML字符转换为DOM节点并动态添加到文档中 - 玄魂</title>
<link>http://www.cnblogs.com/xuanhun/p/9499348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuanhun/p/9499348.html</guid>
<description>&lt;p&gt;将字符串动态转换为DOM节点，在开发中经常遇到，尤其在模板引擎中更是不可或缺的技术。&lt;br/&gt;字符串转换为DOM节点本身并不难，本篇文章主要涉及两个主题：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1 字符串转换为HTML DOM节点的基本方法及性能测试&lt;/p&gt;&lt;p&gt;2 动态生成的DOM节点添加到文档中的方法及性能测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的示例： 有如下代码段&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id='container'&amp;gt;
&amp;lt;!-- 动态添加div 
    &amp;lt;div class='child'&amp;gt; XXX&amp;lt;/div&amp;gt;
 --&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任务是编写一个JavaScript函数，接收一个文本内容，动态生成一个包含该文本的div，返回该Node。&lt;/p&gt;

&lt;h2 id=&quot;innerhtml&quot;&gt;1.1.1 innerHTML&lt;/h2&gt;
&lt;p&gt;第一种方法，我们使用document.createElement方法创建新的元素，然后利用innerHTML将字符串注入进去，最后返回firstChild，得到动态创建的Node。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;script&amp;gt;
        function createNode(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;
            let tempNode = document.createElement('div');
            tempNode.innerHTML = template;
            return tempNode.firstChild;
        }
        const container = document.getElementById('container');
        container.appendChild(createNode('hello'));

    &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们看第二种方法&lt;/p&gt;
&lt;h2 id=&quot;domparser&quot;&gt;1.1.2 DOMParser&lt;/h2&gt;
&lt;p&gt;DOMParser 实例的parseFromString方法可以用来直接将字符串转换为document 文档对象。有了document之后，我们就可以利用各种DOM Api来进行操作了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  function createDocument(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;
            let doc = new DOMParser().parseFromString(template, 'text/html');
            let div = doc.querySelector('.child');
            return div;
        }
        
        const container = document.getElementById('container');
        container.appendChild(createDocument('hello'));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;documentfragment&quot;&gt;1.1.2 DocumentFragment&lt;/h2&gt;
&lt;p&gt;DocumentFragment 对象表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。&lt;/p&gt;
&lt;p&gt;利用document.createRange().createContextualFragment方法，我们可以直接将字符串转化为DocumentFragment对象。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; function createDocumentFragment(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;
            let frag = document.createRange().createContextualFragment(template);
            return frag;
        }

        const container = document.getElementById('container');
        container.appendChild(createDocumentFragment('hello'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意的是我们直接将生成的DocumentFragment对象插入到目标节点中，这会将其所有自己点插入到目标节点中，不包含自身。我们也可以使用&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;frag.firstChild&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来获取生成的div。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;1.1.3 性能测试&lt;/h2&gt;
&lt;p&gt;下面我们来简单比对下上面三种方法的性能,只是测试生成单个节点，在实际使用中并不一定有实际意义。&lt;/p&gt;
&lt;p&gt;先测试createNode。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  function createNode(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;

            let start = Date.now();
            for (let i = 0; i &amp;lt; 1000000; i++) {
                let tempNode = document.createElement('div');
                tempNode.innerHTML = template;
                let node = tempNode.firstChild;
            }
            console.log(Date.now() - start);

        }
        createNode('hello');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试100万个Node生成，用时 &lt;strong&gt;6322&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再来测试createDocument。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    function createDocument(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;
            let start = Date.now();
            for (let i = 0; i &amp;lt; 1000000; i++) {
                let doc = new DOMParser().parseFromString(template, 'text/html');
                let div = doc.firstChild;
            }
            console.log(Date.now() - start);
        }
    createDocument('hello');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试100万个Node生成，用时 &lt;strong&gt;55188&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后来测试createDocumentFragment.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; function createDocumentFragment(txt) {
            const template = `&amp;lt;div class='child'&amp;gt;${txt}&amp;lt;/div&amp;gt;`;
            let start = Date.now();
            for (let i = 0; i &amp;lt; 1000000; i++) {
            let frag = document.createRange().createContextualFragment(template);
            }
            console.log(Date.now() - start);
        }
        createDocumentFragment();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试100万个Node生成，用时 &lt;strong&gt;6210&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;createDocumentFragment方法和createNode方法，在这轮测试中不相上下。下面我们看看将生成的DOM元素动态添加到文档中的方法。&lt;/p&gt;
&lt;h2 id=&quot;批量添加节点&quot;&gt;1.2.0 批量添加节点&lt;/h2&gt;
&lt;p&gt;被动态创建出来的节点大多数情况都是要添加到文档中，显示出来的。下面我们来介绍并对比几种常用的方案。&lt;br/&gt;下面我们批量添加的方法都采用createDocumentFragment方法。&lt;/p&gt;
&lt;h2 id=&quot;直接append&quot;&gt;1.2.1 直接append&lt;/h2&gt;
&lt;p&gt;直接append方法，就是生成一个节点就添加到文档中，当然这会引起布局变化，被普遍认为是性能最差的方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; const template = &quot;&amp;lt;div class='child'&amp;gt;hello&amp;lt;/div&amp;gt;&quot;;

        function createDocumentFragment() {


            let frag = document.createRange().createContextualFragment(template);
            return frag;
        }
        // createDocumentFragment();
        const container = document.getElementById('container');
        let start = Date.now();
        for (let i = 0; i &amp;lt; 100000; i++) {
            container.appendChild(createDocumentFragment());
        }
        console.log(Date.now() - start);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码我们测算动态添加10万个节点。结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2634264-f5bbd8c30ba97855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试1000个节点耗时20毫秒，测试10000个节点耗时10001毫秒，测试100000个节点耗时46549毫秒。&lt;/p&gt;
&lt;h2 id=&quot;documentfragment-1&quot;&gt;1.2.2 DocumentFragment&lt;/h2&gt;
&lt;p&gt;上面我们已经介绍过DocumentFragment了，利用它转换字符串。下面我们利用该对象来作为临时容器，一次性添加多个节点。&lt;/p&gt;
&lt;p&gt;利用document.createDocumentFragment()方法可以创建一个空的DocumentFragment对象。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
        const template = &quot;&amp;lt;div class='child'&amp;gt;hello&amp;lt;/div&amp;gt;&quot;;

        function createDocumentFragment() {


            let frag = document.createRange().createContextualFragment(template);
            return frag;
        }
        // createDocumentFragment();
        const container = document.getElementById('container');
        let fragContainer = document.createDocumentFragment();
        let start = Date.now();
        for (let i = 0; i &amp;lt; 1000; i++) {
            fragContainer.appendChild(createDocumentFragment());
        }
        container.appendChild(fragContainer);
        console.log(Date.now() - start);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试1000个节点耗时25毫秒，10000个节点耗时2877毫秒，100000个节点浏览器卡死。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;1.3 小结&lt;/h2&gt;
&lt;p&gt;简单了介绍了几种方法，并没有什么技术含量。但是从动态添加节点来看，网上说的DocumentFragment方法性能远远好于直接append的说法在我的测试场景中并不成立。&lt;/p&gt;
&lt;p&gt;DocumentFragment正确的应用场景应该是作为虚拟DOM容器，在频繁修改查询但是并不需要直接渲染的场景中。&lt;/p&gt;
&lt;p&gt;更多精彩内容，请关注 微信订阅号“玄说前端”&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2634264-215576141921f1dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;qrcode_for_gh_f819d888c500_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:58:00 +0000</pubDate>
<dc:creator>玄魂</dc:creator>
<og:description>将HTML字符转换为DOM节点并动态添加到文档中 将字符串动态转换为DOM节点，在开发中经常遇到，尤其在模板引擎中更是不可或缺的技术。 字符串转换为DOM节点本身并不难，本篇文章主要涉及两个主题：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuanhun/p/9499348.html</dc:identifier>
</item>
<item>
<title>Python网络编程（基础总结、 入门经典） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9499301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9499301.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Linux下文件类型：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    bcd -lsp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         b（块、设备文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         c（字符设备文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         d（目录）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         -（普通文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         l（链接文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         s（套接字文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         p（管道文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;&lt;span&gt;kill -sig pid&lt;/span&gt;&lt;/strong&gt;：通过pid发送信号杀死指定进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;kill -l&lt;/strong&gt;&lt;/span&gt;：查看操作系统内所所有sig信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ps -aux ---&amp;gt; STAT表示进程状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    信号：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        SIGHUP   断开链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGINT   Ctrl + c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGQUIT  Ctrl + \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGTSTP  Ctrl + z&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGKILL  终止进程且不能被处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGSTOP  暂停进程且不能被处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGALRM  时钟信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SIGCHLD  子进程改变状态时父进程会收到此信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OSI七层模型 -----&amp;gt; 网络通信的标准化流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    应用层： 提供用户服务，具体的内容由特定的程序规定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    表示层： 提供数据的加密和压缩优化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    会话层： 确定建立应用链接，选择传输服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    传输层： 提供数据传输服务，进行流量控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    网络层： 路由选着，网络互联&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    链路层： 提供链路交换，具体消息的发送&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    物理层： 物理硬件，接口，网卡的规定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;网络协议：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用层：TFTP（文件传输）、HTTP（超文本传输协议）、DNS（域名解析）、SMTP（邮件传输）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传输层：TCP、UDP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络层：IP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物理层：IEEE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地使用：127.0.0.1 或 “localhost”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络地址：“0.0.0.0” 或 “172.168.40.53”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IPv4： 点分十进制   例如：192.168.1.3   取值0~255（32位）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IPv6： 128位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;socket模块：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ifconfig：查看本机IP （ens33：本地IP  lo：本地回还）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ipconfig：windoes中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.gethostname() ：                                       获取本机主机名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.gethostbyname('tedu') ：                           利用主机名获取ip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.gethostbyname('localhost')：                     获取本地ip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.gethostbyaddr('127.0.0.1')                         访问主机IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.inet_aton('192.168.1.2')                             IP十六进制转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.inet_ntoa(b'\xc0\xa8\x01\02')                     IP十进制转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    socket.getservbyname('ssh')                                 获取应用程序的端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建&lt;span&gt;TCP&lt;/span&gt;服务端套接字：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sockfd.socket（sock_family = AF_INET,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               sock_tpye = SOCK_STREAM,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               proto = 0）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sockfd.bind（addr）                                              绑定地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sockfd.listen(n)                                                      设置监听套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd，addr = sockfd.accept（）                         等待接受客户端链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  data = connfd.recv（buffersize）                           接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.send（data）                                              发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close（）                                                     关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建TCP客户端套接字：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sockfd.socket（sock_family = AF_INET,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               sock_tpye = SOCK_STREAM,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               proto = 0）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sockfd.bind（addr）                                             绑定地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.connect（addr）                                         链接服务端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  data = connfd.recv（buffersize）                           接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.send（data） 发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close（） 关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建&lt;span&gt;UDP&lt;/span&gt;客户端套接字：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.socket（sock_family = AF_INET,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               sock_tpye = SOCK_DGRAM,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               proto = 0）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sockfd.bind（addr）                                            绑定地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  data = sockfd.recvfrom（buffersize）                   接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.sendto（data, addr）                                发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close（）                                                   关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建UDP客户端套接字：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.socket（sock_family = AF_INET,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               sock_tpye = SOCK_DGRAM,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               proto = 0）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  data = sockfd.recvfrom（buffersize）                   接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.sendto（data, addr）                                发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close（）                                                  关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建&lt;span&gt;本地&lt;/span&gt;套接字服务端：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd = socket（AF_UNIX, SOCK_STREAM） &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.bind（file）                                                绑定套接字文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.listen(3)                                                      监听&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd,addr = sockfd.accept()                               等待链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.recv(buffersize)                                          接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.send(data)                                                 发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close()                                                        关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建本地套接字客户端：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd = socket（AF_UNIX, SOCK_STREAM） &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.connect(sock_file)                                     链接服务端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.recv(buffersize)                                         接收消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  connfd.send(data)                                                 发送消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.close()                                                        关闭套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;套接字属性：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.type                                                              返回套接字类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.family                                                           返回地址类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;套接字方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.fileno（）                                                     获取套接字的文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.getsockname（）                                         获取套结字绑定的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.getpeername（）                                        获取链接套接字客户端的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.setsockopt（level，optname， value）      设置端口可立即重用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.setblocking(False)                                       将套接字设置为非阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sockfd.settimeout（sec）                                       设置套接字的超时时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;select模块：&lt;/span&gt;&lt;/strong&gt;                                                            IO多路复用，阻塞等待监控的IO事件发生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rs， ws， xs = select（rlist，                                   等待处理的IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                     wlist                                     想要主动处理的IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                     xlist[，                                 出错希望去处理的IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                     timeout]）                            超时检测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p = select.poll                                                          创建poll对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.register(s， POLLIN | PLLERR)                           注册关注的IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;events = p.poll（）                                                   监控关注的IO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;multiprocessing模块：&lt;/span&gt;&lt;/strong&gt;                                            创建进程对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Process&lt;/strong&gt;(target，                                                       要绑定的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               name，                                                        给进程起的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               args，                                                         元组给target函数位置传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               kwargs)                                                       字典给target函数键值传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.start()                                                                     启动进程terget绑定函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.join([timeout])                                                         阻塞等待子进程退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.name                                                                       获取进程名（属性）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.daemon                                                                  设置为True主进程结束杀死所有子进程（必须start（）前设置）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.is_alive()                                                                 判断进程是处于alive状态（存活）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p.pid                                                                          获取创建进程的pid号（属性）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pool = &lt;strong&gt;pool&lt;/strong&gt;（x）                                                       创建进程池对象（进程池大小）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pool.apply_async(fun,                                               要执行的函数(异步执行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                             args,                                             以元组形式为fun传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                             kwds)                                            以字典形式为fun传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pool.apply(fun, args, kwds)                                       (同步执行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r = pool.map(fun,range(6))                                         将要执行的事件放入进程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pool.close()                                                                关闭进程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pool.join()                                                                    回收进程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fd1，fd2 = &lt;strong&gt;Pipe&lt;/strong&gt;(duplex=True)                                    创建管道（Flase：fd1只读，fd2只写）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fd.recv（）                                                                  从管道读取信息空则阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fd.send（data）                                                          向管道写入内容满则阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q = &lt;strong&gt;Queue&lt;/strong&gt;（maxsize=0）                                            创建队列对象（存放多少条消息）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q.put（data,                                                                   存入消息（支持Python数据类型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           [block,                                                                默认阻塞 False：非阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           timeout]）                                                          block为True是表示超时检测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data = q.get([block,timeout])                                         取出消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q.full（）                                                                       判断队列是否为满&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q.empty()                                                                      判断队列是否为空&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q.qsize()                                                                       获取队列中消息的数量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;q.close()                                                                        关闭队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shm = &lt;strong&gt;Value&lt;/strong&gt;（ctype，                                                  创建共享内存共享空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        obj）                                                       ctype字符串：（C语言数据类型），obj初始数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shm.value                                                                       表示共享内存的值（可以赋值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shm = &lt;strong&gt;Array&lt;/strong&gt;（ctype，obj）                                          创建共享内存共享空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sem = &lt;strong&gt;Semaphore&lt;/strong&gt;（num）                                          创建信号量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sem.acquire（）                                                            将信号量减1  0时阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sem.release（）                                                            将信号量加1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sem.get_value（）                                                         获取当前信号量的值（数量）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e = &lt;strong&gt;Event&lt;/strong&gt;（）                                                                创建Event事件对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.wait（[timeout]）                                                         阻塞进程 直到事件对象被set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.set.()                                                                            让事件对象变为被设置状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.clear（）                                                                     使事件对象清除设置状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.is_set（）                                                                    判断当前事件是否被set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Lock = &lt;strong&gt;Lock&lt;/strong&gt;（）                                                            创建锁对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lock.acquire（）                                                            上锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lock.release()                                                                 解锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;threading 模块：&lt;/span&gt;&lt;/strong&gt;                                                            创建线程对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;threshold.&lt;strong&gt;Thread&lt;/strong&gt;（target，                                            线程函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                               name,                                                线程名字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                args,                                                元组给线程函数位置传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                kwargs）                                         字典给线程函数位置传参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.start（）                                                                       启动线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.join（）                                                                         回收线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.name                                                                              线程名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.daemon = True                                                            主线程退出分支线程也退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.setDaemon(True)                                                       主线程退出分支线程也退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.isDaemon                                                                    查看daemon值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.setName（“name”）                                                   设置线程名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t.is_alive（）                                                                 查看线程状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;threading.currentThread()                                              获取当前进程对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e = threading.&lt;strong&gt;Event&lt;/strong&gt;()                                                    创建Event事件对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.wait([timeout])                                                             事件阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.set（）                                                                       设置事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e.clear（）                                                                    清除事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lock = threading.&lt;strong&gt;Lock&lt;/strong&gt;（）                                            创建锁对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lock.acquire() 上锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lock.release() 解锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;socketserver集成并发模块：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StreamRequestHandler                                                处理tcp请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DatagramRequestHandler                                            处理udp请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ForkingMixIn                                                                  创建多进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ThreadingMixIn                                                             创建多线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPServer                                                                   创建tcp  server&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UDPServer                                                                  创建udp  server&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ForkingTCPServer                                                        ForkingMixIn  +  TCPServer &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ForkingUDPServer                                                      ForkingMixIn  +  UDPServer &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ThreadingTCPServer                                                    ThreadingMixIn  +  TCPServer &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ThreadingUDPServer                                                    ThreadingMixIn  +  UDPServer &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;signal模块：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signal.alarm（sec）                                                       设置时钟信号给自己SIGALRM信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signal.pause（）                                                           阻塞进程，等待一个信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signal.signal（sig，                                                      要处理的信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        handler）                                               处理方法（SIG_DFL：默认 SIG_IGN：忽略 func：自定义函数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;sys模块补充：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sys.argv                              获取从命令行获取的参数内容列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sys.stdin      0                     标准输入IO文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sys.stdout   1                      标准输出IO文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sys.stderr   2                      错误IO文件描述符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    sys.exit（[status]）            退出一个进程（状态：退出提示字符串）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串方法补充：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    S.splitlines                          按行分隔&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;os模块补充：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.path.exists（file）                                 判断一个文件是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.remove（file）                                      删除文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.unlink（file）                                         删除文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pid = os.fork()                                             创建进程 失败-1 成功0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.getpid（）                                             获取进程的PID号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.getppid（）                                           获取父进程的PID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.exit（status）                                      退出一个进程（状态：整数 默认0）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pid,status = os.wait()                                 塞等待处理子进程的退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.WEXITSTATUS(status)                       获取原来退出状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pid,status = os.waitpid(pid,option)            阻塞等待处理子进程的退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.path.getsize('./1.txt')                            读取文件的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.kill（pid，sig）                                    发送一个信号给某个进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.listdir(path)                                         获取指定目录文件列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.path.isfile()                                         判断一个 文件是否为普通文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;os.path.isdir()                                         判断一个文件是否为目录 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;传输层服务：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    面向连接的传输服务&lt;strong&gt;（tcp协议）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        传输特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          可靠的数据传输：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            可靠性：无失序、无差错、无重复、无丢失、无重复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在数据传输前和传输后需要建立连接和断开链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          面向传输服务建立连接的过程：‘三次握手’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            1.客户端向服务器发送链接请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            2.服务器接受到请求进行确认，返回确认报文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            3.客户端收到服务器回复最终确认链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          面向传输服务断开链接的过程：‘四次挥手’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            1.主动方发送报文，告知被动方要断开链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.被动方回复报文，表示已经接受到请求，准备断开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.被动方再次发送报文，表示准备处理就绪，可以断开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    4.主动方发送确认报文，断开链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        应用情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    适用于传输较大的内容或文件，网络良好，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    需要保证传输可靠性的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    e.g.  信息聊天，文件上传下载，邮件，网页获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    面向无连接的传输服务&lt;strong&gt;（udp协议）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        不保证传输的可靠性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有建立连接和断开的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据的收发比较自由&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适用情况： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    网络情况较差，对可靠性要求不高，收发消息的两端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    e.g.：网络视频，群聊，广播等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;收发函数特性：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     recv特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       如果建立的另一端链接被断开， 则recv立即返回空字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       recv是从接受缓冲区取出内容，当缓冲区为空则阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       recv如果一次接受不完缓冲区的内容，下次执行会自动接受&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     send特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        如果发送的另一端不存在则会产生pipe...异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;send是从发送缓冲区发送内容当缓冲区为满则堵塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;http协议：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   超文本传输协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   用途：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      网站中浏览区器网页的获取，基于网站事物数据传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      编写基于http协议的数据传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   特点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1.应用层协议，传输层使用tcp服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2.简单、灵活，可以使用多种编程语言操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      3.无状态的协议，既不用记录用户的输入内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      4.http1.1  ---&amp;gt; http2.0（还没发布）  技术的成熟和稳定性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;  http请求&lt;/strong&gt;（request）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1.请求格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         1）请求行：说明具体的请求类别和内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          GET    /index.html    /HTTP/1.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                请求类别   请求内容    协议版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2）请求类别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        GET：获取网络资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;POST：提交一定的附加数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HEAD：获取相应头&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PUT：更新服务器资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DELETE：删除服务器资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONNECT：未使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TRACE：用于测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OPTIONS：获取服务器性能信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.请求头：对请求的具体描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     Accept：text/html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        每一个键值对占一行，描述了一个特定信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.空行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4.请求体：具体的参数或提交的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          get参数或者post提交的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;strong&gt;http响应&lt;/strong&gt;（response）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1.响应格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1）响应行:反馈具体的响应情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          HTTP/1.1     20       OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  版本协议   响应码   附加信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3）响应码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1xx：提示信息，表示请求已经接收&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2xx：响应成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3xx：响应需要定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4xx：客户端错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5xx：服务器端错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3）常见响应码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   200  成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   404  请求内容不存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   401  没有访问权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   500  服务器未知错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       503  服务器暂时无法执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2.响应头：对响应内容的具体描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      3.空行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      4.响应体：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         将客户端请求内容进行返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IO多路复用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过一个监测，可以同时监控多个IO事件的行为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当那个IO可以执行，让这个IO事件发生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时形成多个IO时间都可以操作的现象，不必逐个等待执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IO准备就绪：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IO事件即将发生时的临界状态是不可逆转的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在程序中存在的IO事件中选择要监测的事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建监测，将监测的IO事件注册&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等待监测的IO事件发生，判断是什么事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理相应的IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;poll方法实现IO多路复用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   1.创建poll对象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       p = select.poll&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2.注册关注的IO：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       p.register(s， POLLIN | PLLERR)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       不关注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          p.unregister(s)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       事件类别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          POLLIN  POLLOUT  POLLERR  POLLHUP   POLLPRI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          rlist    wlist    xlist     断开   紧急处理 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3.监控IO：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       events = p.poll（）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       功能：监控关注的IO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       返回值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           返回发生IO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   events是一个列表[(fileno, evnet), (), ()....]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   每个就绪IO对应一个元组（描述符，就绪事件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       IO地图：{s.fileno():s}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4.处理IO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;位运算：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   按照二进制位进行位运算操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp; 按为与   |按位或   ^按位异或&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;lt;&amp;lt; 左异    &amp;gt;&amp;gt;右移&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   11  1011&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   14  1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp;   1010  有0得0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   |   1111  有1得1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   ^   0101  相同为0不同为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   11 &amp;lt;&amp;lt; 2  == 44   右侧补零（乘2乘2次）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   14 &amp;gt;&amp;gt; 2  == 3    挤掉右侧的数字（地板除2除2次）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.在低层硬件时操作寄存器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.做标志位的过滤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多任务编程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    意义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;充分利用计算机资源，同时运行多个任务，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高程序整体的运行效率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过程序利用计算机的多个核心达到同时执行多个任务的目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此达到提升程序运行效率的目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    实施方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多进程编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    并行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        多个计算机核心在同时处理多个任务，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时多个任务之间是并行关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     并发：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        同时运行多个任务，内核在多个任务之间的不断切换，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;达到多个任务都会执行的处理效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时多个任务之间的并发关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    是一个可执行文件，是静态的，只占有磁盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    不占用计算机运行资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    程序在计算机中的一次执行过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    是一个动态过程，占有一定的计算机资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    有一定的生命周期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    同一个程序不同的运行过程是不同的进程，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    因为分配的资源和生命周期都不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程的创建过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.用户启动一个程序，或是调用接口发起进程创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.操作系统接收用户请求分配计算机资源创建进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.操作系统将一定状态的进程提供给用户使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    4.用户利用操作提供的进程完成任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CPU时间片：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如果有个进程占有CPU此时我们称为该进程占有CPU的时间片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    多个进程任务或轮流占有CPU时间片并形成并发效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程信息（process）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;   PCB&lt;/strong&gt;（进程控制块）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         进程创建后 会自动在内存中产生一个空间存放进程信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进程信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        进程ID 进程占有内存的位置  创建时间、创建位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看系统进程信息：ps -aux&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    PID（process ID）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在操作系统中每个进程都有唯一的PID值是由系统分配的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进程是操作系统分配资源的最小单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    每个进程拥有自己独立的运行空间（4个G的虚拟内存空间）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进程之间相互独立各不影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的状态：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;三态：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    就绪状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         进程具备执行条件，等待系统分配处理器资源进入运行态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    运行态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         进程占有CPU处于运行状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    等待态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         进程暂时不具备运行条件，需要阻塞等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;strong&gt; 五态：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         在三态的基础上增加新建和终止态 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 新建：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   创建一个新的程序，获取系统资源的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 终止：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   进程执行结束，释放资源的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps -aux ---&amp;gt; STAT表示进程状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;D&lt;/strong&gt;  等待态  阻塞  不可中断等待态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    S  等待态  睡眠  可中断等待态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    T  等待态  暂停  暂停执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    R  运行态（就绪态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Z  僵尸&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      +  前台进程（在终端运行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &amp;lt;  有较高优先级的进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      N  较低优先级的进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      s  回话组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      l  有进程链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的优先级：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    top 查看进程运行态优先级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    取值范围：-20~19   -20最高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  nice：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       以指定的优先级运行一个程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       nice -9 ./hello.py  以9的优先级运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;sudo nice --9 ./hello.py &lt;/span&gt;以-9优先级运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首行添加 #! /usr/bin/python3  指定执行器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      执行：./hello.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    修改程序权限添加可执行权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;  &lt;span&gt;chmod&lt;/span&gt;&lt;/strong&gt; 775 hello.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;孤儿进程 ： &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当父进程先于子进程退出，此时子进程就会成为孤儿进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    * 孤儿进程会被系统指定进程收养，即系统进程会成为孤儿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      进程新的父进程。系统进程会自动处理孤儿进程退出状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;僵尸进程 ：&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子进程先于父进程退出，父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* 僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   程会消耗系统的内存资源，所以要尽量避免僵尸进程产生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何避免僵尸进程产生？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* 父进程先退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* 父进程处理子进程退出状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* 创建二级子进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程池技术：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    产生原因：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如果有大量的任务需要多进程完成，而调用周期比较短且需要频繁创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时可能产生大量进程频繁创建销毁的情况  消耗计算机资源较大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    使用方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.创建进程池，在池内放入适当数量的进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.将事件封装成函数。放入到进程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.事件不断运行，直到所有放入进程池事件运行完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.关闭进程池，回收进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步互斥机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    目的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       解决对共有资源产生的资源争夺&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    临界资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         多个进程或线程都可以操作的资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    临界区：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        操作临界资源的代码段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  同步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    同步是一种合作关系，为完成某个任务，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多进程或者多个线程之间形成的一种协调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照约定执行，相互告知，共同完成任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    互斥：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    互斥是一种制约关系，当一个进程或者线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入临界区操作资源时采用上锁的方式，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻止其他进程操作，直到解锁后才能让出资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多线程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    什么是线程（thread）？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      线程也是一种多任务编程方式，可以使用计算机的多核资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      线程被称为轻量级的进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    线程的特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1.一个进程可以包含多个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2.线程是计算机内核使用的最小单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      3.线程也是一个运行过程，也要消耗计算机资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      4.多个线程共享共用进程的资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      5.线程也有自己的特征属性，TID、指令集、线程栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      6.多个线程之间独立运行互不干扰 空间不独立（都消耗进程空间）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      7.线程的创建删除消耗的资源要小于进程 线程/进程（1/20）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程通信：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               多个线程共用线程空间，所以进程的全局变量对进程内线程均可见&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               线程的通信方法就是使用去全局变量通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       注：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              线程间使用全局变量进程通信时，全局变量为共享资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               往往需要同步互斥机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程和线程的区别和联系：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.两者都是多任务编程的方式  都能够使用计算机的多核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.进程的创建和删除要比线程消耗更多的计算机资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.进程空间独立，数据安全性好，有专门的进程间的通信方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    4.线程使用全局变量，更加简单，但需要同步互斥操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5.一个进程可以包含多个线程，线程共享进程空间资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    6.进程线程都独立执行，有自己的特有属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.一个进程中并发任务比较多，比较简单，适合使用多线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.如果数据程序比较复杂，特别是可能多个任务通信比较多的时候&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      要考虑使用线程同步互斥的复杂性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.多个任务存在明显差异，和功能分离的时候没有必要一定写入到一个进程中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    4.使用Python要考虑到GIL的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Pyhthon线程GIL问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;GIL&lt;/strong&gt;&lt;/span&gt; （全局解释器锁）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Python ---&amp;gt;支持线程操作---&amp;gt;出现IO同步互斥---&amp;gt;加锁---&amp;gt;超级锁，给解释器加锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    后果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        同一时刻一个解释器只解释一个线程 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        此时其他线程需要等待。大大降低了Python线程的执行效率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        只能实现并发不能实现并行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Python GIL问题解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.修改c解释器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.尽量使用多进程进行并行操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.Python线程尽量用在高延迟多阻塞的IO情形&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.不使用CPython   使用C#、JAVA 做的得解释器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;网络服务器基础：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    循环服务器：：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        单进程程序，循环接受客户请求，处理请求，处理完毕后再接受下一次请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        特点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            每次只能处理一个客户端请求，如果客户端长期占有服务器则无法处理其他客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            实现简单，占用资源少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            无法同时处理多个客户端，体验差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        使用情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            任务短暂，可以快速完成，udp比tcp更适合循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    并发服务器：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        能够同时处理多个客户端任务请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        IO并发：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            IO多路复用 协程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                可以实现IO并发操作，占用系统资源少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                不能够监控CPU密集的情况，并不能有长期阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        多进程/线程并发：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            为每个客户端单独提供一个进程或线程，处理客户端请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                客户端可以长期占有服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                消耗计算机资源比较多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:42:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<og:description>Linux下文件类型： bcd -lsp b（块、设备文件） c（字符设备文件） d（目录） -（普通文件） l（链接文件） s（套接字文件） p（管道文件） kill -sig pid：通过pid发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9499301.html</dc:identifier>
</item>
<item>
<title>Numpy基本操作 - Dominic-Ji</title>
<link>http://www.cnblogs.com/Dominic-Ji/p/9499075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dominic-Ji/p/9499075.html</guid>
<description>&lt;h2&gt;NumPy:数组计算&lt;/h2&gt;
&lt;p&gt;NumPy是高性能科学计算和数据分析的基础包。它是Pandas等其他各种工具的基础&lt;/p&gt;
&lt;p&gt;NumPy的主要功能:&lt;/p&gt;
&lt;p&gt;　　ndarray,一个多维数据结构，高校且节省空间&lt;/p&gt;
&lt;p&gt;　　无需循环即可对整组数据进行快速运算的数学函数&lt;/p&gt;
&lt;p&gt;　　读写磁盘数据的工具以及用于操作内存映射文件的工具&lt;/p&gt;
&lt;p&gt;　　线性代数、随机数生成和傅里叶变化功能&lt;/p&gt;
&lt;p&gt;　　用于集成C、C++等代码的工具&lt;/p&gt;
&lt;p&gt;安装方法:pip install numpy(如果显示命令不存在可以尝试python -m install numpy)&lt;/p&gt;
&lt;p&gt;引用方式通常喜欢给numpy模块别名:import numpy as np&lt;/p&gt;
&lt;h3&gt;NumPy简单使用&lt;/h3&gt;
&lt;p&gt;例1：已知若干家跨国公司的市值（美元），将其换算为人民币&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818223600088-113794634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例2：已知购物车中每件商品的价格与商品件数，求总金额&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818224052858-990667204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;创建ndarray:np.array()&lt;/h3&gt;
&lt;p&gt;ndarray是多维数组结构，与列表的区别是：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;数组对象内的元素类型必须相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　数组大小不可修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 常用属性&lt;/h3&gt;
&lt;p&gt;T　　　　数组的转置(对二维及以上数组而言)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818225000337-851478618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dtype　　　数组元素的数据类型&lt;/p&gt;
&lt;p&gt;size　　　  数组元素的个数&lt;/p&gt;
&lt;p&gt;ndim　　    数组的维数&lt;/p&gt;
&lt;p&gt;shape　　  数组的维度大小(以元祖的形式) &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818225850122-1160363909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;ndarray创建&lt;/h3&gt;
&lt;p&gt;arange()　　　　比我们的python3里面的range更加强大，支持浮点数范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818230648922-578565600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;linspance()　　　　类似于arange(),第三个参数为数组长度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818230943338-180140571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zeros() 　　　　 根据指定形状和dtype创建全0数组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180818231411244-938283034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ones() 　　　　  根据指定形状和dtype创建全1数组&lt;/p&gt;
&lt;p&gt;empty() 　　　　根据指定形状和dtype创建空数组（随机值）&lt;/p&gt;
&lt;p&gt;eye() 　　　　　根据指定边长和dtype创建单位矩阵&lt;/p&gt;
&lt;h3&gt; NumPy索引切片&lt;/h3&gt;
&lt;p&gt;数组和标量(数字)之间的运算&lt;/p&gt;
&lt;p&gt;　　a+1 a*3 1//a a**0.5&lt;/p&gt;
&lt;p&gt;同样大小数组之间的运算&lt;/p&gt;
&lt;p&gt;　　a+b a/b a**b&lt;/p&gt;
&lt;p&gt;数组的索引&lt;/p&gt;
&lt;p&gt;一维数组：a[5]&lt;/p&gt;
&lt;p&gt;多维数组：&lt;/p&gt;
&lt;p&gt;　　列表式写法：a[2][3]&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;新式写法：a[2,3] (推荐)  逗号隔开，前面作用于行后面作用于列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组的切片&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一维数组：a[5:8] 　　　　a[4:] 　　　　a[2:10] = 1&lt;/p&gt;
&lt;p&gt;多维数组：a[1:2, 3:4] 　　a[:,3:5] 　　    a[:,1]&lt;/p&gt;
&lt;p&gt;与列表不同，数组切片时并不会自动复制，在切片数组上的修改会影响原数组(因为不会复制一份出去而是沿用原来的内存空间中的值)。 【解决方法：copy()】&lt;/p&gt;
&lt;h3&gt;NumPy布尔型索引&lt;/h3&gt;
&lt;p&gt;问题：给一个数组，选出数组中所有大于5的数。&lt;/p&gt;
&lt;p&gt;答案：a[a&amp;gt;5]&lt;/p&gt;
&lt;p&gt;原理： a&amp;gt;5会对a中的每一个元素进行判断，返回一个布尔数组 布尔型索引：将同样大小的布尔数组传进索引，会返回一个由所有True对应位置的元素的数组&lt;/p&gt;
&lt;p&gt;问题2：给一个数组，选出数组中所有大于5的偶数。&lt;/p&gt;
&lt;p&gt;问题3：给一个数组，选出数组中所有大于5的数和偶数。&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;　　　　a[(a&amp;gt;5) &amp;amp; (a%2==0)]&lt;/p&gt;
&lt;p&gt;　　　　a[(a&amp;gt;5) | (a%2==0)]&lt;/p&gt;
&lt;h3&gt;NumPy花式索引&lt;/h3&gt;
&lt;p&gt;问题1：对于一个数组，选出其第1，3，4，6，7个元素，组成新的二维数组。&lt;/p&gt;
&lt;p&gt;　　答案：a[[1,3,4,6,7]]&lt;/p&gt;
&lt;p&gt;问题2：对一个二维数组，选出其第一列和第三列，组成新的二维数组。&lt;/p&gt;
&lt;p&gt;　　答案：a[:,[1,3]]&lt;/p&gt;
&lt;h2&gt;必会知识点&lt;/h2&gt;
&lt;p&gt;浮点数特殊值&lt;/p&gt;
&lt;p&gt;浮点数：float&lt;/p&gt;
&lt;p&gt;浮点数有两个特殊值：&lt;/p&gt;
&lt;p&gt;　　nan(Not a Number)：不等于任何浮点数（nan != nan）&lt;/p&gt;
&lt;p&gt;　　inf(infinity)：比任何浮点数都大&lt;/p&gt;
&lt;p&gt;NumPy中创建特殊值：np.nan np.inf&lt;/p&gt;
&lt;p&gt;在数据分析中，nan常被用作表示数据缺失值&lt;/p&gt;
&lt;p&gt;sum 求和&lt;/p&gt;
&lt;p&gt;cumsum 求前缀和(截至当前元素及其前面所有的元素和)&lt;/p&gt;
&lt;p&gt;mean 求平均数&lt;/p&gt;
&lt;p&gt;std 求标准差&lt;/p&gt;
&lt;p&gt;var 求方差&lt;/p&gt;
&lt;p&gt;min 求最小值&lt;/p&gt;
&lt;p&gt;max 求最大值&lt;/p&gt;
&lt;p&gt;argmin 求最小值索引&lt;/p&gt;
&lt;p&gt;argmax 求最大值索引&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;数组中的数据类型必须一致，并且数组大小不可再被更改‘&lt;/p&gt;
&lt;p&gt;对于数组求相应值由四种不同的方式:&lt;/p&gt;
&lt;p&gt;　　正常的索引切片取值&lt;/p&gt;
&lt;p&gt;　　行列分开的切片取值&lt;/p&gt;
&lt;p&gt;　　布尔型(生成一个与原数组各元素一一对应的布尔值数组，原数组与该布尔值列表一一对应，值为True的放行~~~)&lt;/p&gt;


</description>
<pubDate>Sat, 18 Aug 2018 15:37:00 +0000</pubDate>
<dc:creator>Dominic-Ji</dc:creator>
<og:description>NumPy:数组计算 NumPy是高性能科学计算和数据分析的基础包。它是Pandas等其他各种工具的基础 NumPy的主要功能: ndarray,一个多维数据结构，高校且节省空间 无需循环即可对整组数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dominic-Ji/p/9499075.html</dc:identifier>
</item>
<item>
<title>微服务初步理解 - Tomorrow1</title>
<link>http://www.cnblogs.com/yucaikang/p/9499236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yucaikang/p/9499236.html</guid>
<description>&lt;h4 id=&quot;本文参考书籍&quot;&gt;本文参考书籍&lt;/h4&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;has-numbering&quot;&gt;https://github.com/oopsguy/microservices-from-design-to-deployment-chinese
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;微服务简介&quot;&gt;微服务简介&lt;/h4&gt;
&lt;h5 id=&quot;单体应用&quot;&gt;单体应用&lt;/h5&gt;
&lt;p&gt;在项目开发启动阶段，比如开发一个电商系统，该系统包括了订单模块、商品搜索模块、用户模块和后台等系统，启动阶段虽然按照业务逻辑分模块开发，但是最终成功上线运行的是一个单体应用，在项目开发的初期，单应用的架构有助于快速更改业务流程，快速迭代，当项目发展到一定时期后，一个庞大、复杂的单体，对于新的功能的开发可能就是陷入了很大的困境，无论是修复线上小的问题还是新需求的开发都设计到整个项目的重新部署和测试，并且降低了开发的效率。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog.csdn.net/qq_33339479/article/details/sample.png&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180804120429956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;单体应用架构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当项目发展到一定阶段后，不同模块存在资源需求的冲突，单体应用可能难以扩展；当单体应用在线上实际运行过程中，任何一个模块出现一个bug，都可能会导致整个单体应用不可用。当需要对项目中开发的某个模块进行灰度发布的时候，单体应用往往也不能满足很好的扩展性。那么如何进行改进呢？&lt;/p&gt;
&lt;h5 id=&quot;微服务&quot;&gt;微服务&lt;/h5&gt;
&lt;p&gt;通过将应用程序分解成一套比较小的互联服务，即微服务架构模式。一个服务通常实现了一组不同的特性或功能，例如用户模块等。每一个微服务都是一个迷你应用，都包括了自己实现的业务逻辑，暴露了对外服务的接口，服务可单独部署与开发。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog.csdn.net/qq_33339479/article/details/new_arh_blog.png&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180804120503105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;微服务架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序的每个功能区域都由相应的微服务实现，每个后端服务暴露相关接口，服务之间可以使用异步或基于消息的通信，一些API也暴露给移动端应用，但是应用不能直接访问后端服务，它们之间的通信都由一个API网关的中介负责，API网关负责负载均衡、缓存、访问控制、API计量和监控。微服务架构模式影响到了应用程序与数据局之间的关系，与其他共享单个数据库模式服务有所不同，其每一个服务都由自己的数据库模式，这样就可以实现松耦合的结构，并且服务可根据自身的需求选择不同的数据库，以达到最佳的适用场景。每个服务也可以选用不同的技术栈来实现不同场景的业务。&lt;/p&gt;
&lt;h4 id=&quot;微服务优缺点&quot;&gt;微服务优缺点&lt;/h4&gt;
&lt;h5 id=&quot;优点&quot;&gt;优点&lt;/h5&gt;
&lt;p&gt;1.解决了复杂的问题，将庞大的单体应用分解成一套服务，虽然功能数量不变，但是应用程序已经被分解成可管理的服务，每个服务都有一个明确定义的API，如RPC或消息驱动，每个服务能更快地开发并更容易理解与维护。&lt;/p&gt;
&lt;p&gt;2.每个服务都可以选用不同的技术栈，由不同的团队开发维护。&lt;/p&gt;
&lt;p&gt;3.每个服务都可以独立部署。&lt;/p&gt;
&lt;p&gt;4.微服务使得每个服务都能够独立扩展。&lt;/p&gt;
&lt;h5 id=&quot;缺点&quot;&gt;缺点&lt;/h5&gt;
&lt;p&gt;1.由于微服务是一个分布式系统，其使得整体项目变得复杂，开发者需要选择和实现基于消息或者rpc的进程间通信机制，此外，由于目标请求可能延迟或不可用，还需要额外的处理机制保证通信。&lt;/p&gt;
&lt;p&gt;2.微服务面临着分区数据库问题，在基于微服务的应用程序中，需要更新不同服务的数据库，一般不会选择分布式事务，不仅因为CAP定理，也是因为如果使用了NoSql数据库和消息代理，就没有很好的支持，最后使用最终一致性方法，这对开发人员来说更具挑战性。&lt;/p&gt;
&lt;p&gt;3.微服务的测试工作相对复杂，一个微服务的测试需要启动该服务所依赖的所有服务，增大了测试的难度。&lt;/p&gt;
&lt;p&gt;4.微服务的部署工作也相对复杂，一个单体应用可以很容易地部署到基于传统负载均衡器的一组服务器上，相比之下，微服务应用程序通常由大量的服务这次，每个服务都可以有多个运行时实例，这对服务的发现机制，服务的部署监控和扩展都提出了更高的要求。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;构建微服务本质上需要考虑的方向很多，需要根据当前项目的业务紧密相关联，单体应用适用于简单、轻量级的应用程序，如果应用发展到一定规模，微服务架构虽然复杂、维护大，但是保证了业务的灵活性和扩展性。如何选择需要实际业务进行选择。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:18:00 +0000</pubDate>
<dc:creator>Tomorrow1</dc:creator>
<og:description>本文参考书籍 微服务简介 在项目开发启动阶段，比如开发一个电商系统，该系统包括了订单模块、商品搜索模块、用户模块和后台等系统，启动阶段虽然按照业务逻辑分模块开发，但是最终成功上线运行的是一个单体应用，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yucaikang/p/9499236.html</dc:identifier>
</item>
<item>
<title>亿级流量场景下，大型缓存架构的虚拟机环境搭建 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9499225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9499225.html</guid>
<description>&lt;p&gt;---内容持续更新---&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818105315585-180048582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;小型电商：&lt;/h2&gt;
&lt;p&gt;静态模板是固定的 数据库中的数据全量喧嚷到模板中，下次请求来了直接返回，速度也很快；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818110106551-404540120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当数据上亿的时候，如果模板改定，把这些所有的数据在mysql中渲染进模板，非常耗时，不现实；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818110506644-357276788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;大型电商：&lt;/h2&gt;
&lt;p&gt;缓存数据生产服务；&lt;/p&gt;
&lt;p&gt;不需要再进行全量重新渲染，直接将最新的html模板推送到nginx服务器，请求过来后直接在nginx本地进行渲染进模板中返回请求；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818105211785-61724488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redis的重要性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818112452513-1323113298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 虚拟机环境设置一：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;虚拟机中安装CentOS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动一个virtual box虚拟机管理软件 使用CentOS 6.5镜像即可，CentOS-6.5-i386-minimal.iso。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vi /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/p&gt;
&lt;p&gt;DEVICE=eth0&lt;br/&gt;TYPE=Ethernet&lt;br/&gt;ONBOOT=yes&lt;br/&gt;BOOTPROTO=dhcp&lt;br/&gt;service network restart&lt;br/&gt;ifconfig&lt;/p&gt;
&lt;p&gt;BOOTPROTO=static&lt;br/&gt;IPADDR=192.168.0.X&lt;br/&gt;NETMASK=255.255.255.0&lt;br/&gt;GATEWAY=192.168.0.1&lt;br/&gt;service network restart&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置hosts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vi /etc/hosts&lt;br/&gt;配置本机的hostname到ip地址的映射&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置SecureCRT【本人使用的Xshell 感觉也很好用】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时就可以使用SecureCRT从本机连接到虚拟机进行操作了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭防火墙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;service iptables stop&lt;br/&gt;service ip6tables stop&lt;br/&gt;chkconfig iptables off&lt;br/&gt;chkconfig ip6tables off&lt;/p&gt;
&lt;p&gt;vi /etc/selinux/config&lt;br/&gt;SELINUX=disabled&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭windows的防火墙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置yum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yum clean all&lt;br/&gt;yum makecache&lt;br/&gt;yum install wget&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在每个CentOS中都安装Java和Perl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WinSCP，就是在windows宿主机和linux虚拟机之间互相传递文件的一个工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）安装JDK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、将jdk-7u60-linux-i586.rpm通过WinSCP上传到虚拟机中&lt;br/&gt;2、安装JDK：rpm -ivh jdk-7u65-linux-i586.rpm&lt;br/&gt;3、配置jdk相关的环境变量&lt;br/&gt;vi .bashrc&lt;br/&gt;export JAVA_HOME=/usr/java/latest&lt;br/&gt;export PATH=$PATH:$JAVA_HOME/bin&lt;br/&gt;source .bashrc&lt;br/&gt;4、测试jdk安装是否成功：java -version&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）安装Perl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yum install -y gcc&lt;/p&gt;
&lt;p&gt;wget http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz&lt;br/&gt;tar -xzf perl-5.16.1.tar.gz&lt;br/&gt;cd perl-5.16.1&lt;br/&gt;./Configure -des -Dprefix=/usr/local/perl&lt;br/&gt;make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install&lt;br/&gt;perl -v&lt;/p&gt;
&lt;p&gt;为什么要装perl？我们整个大型电商网站的详情页系统，复杂。java+nginx+lua，需要perl。&lt;/p&gt;
&lt;p&gt;perl，是一个基础的编程语言的安装，tomcat，跑java web应用&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、在4个虚拟机中安装CentOS集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）按照上述步骤，再安装三台一模一样环境的linux机器&lt;br/&gt;（2）另外三台机器的hostname分别设置为eshop-cache02，eshop-cache03，eshop-cache04&lt;br/&gt;（3）安装好之后，在每台机器的hosts文件里面，配置好所有的机器的ip地址到hostname的映射关系&lt;/p&gt;
&lt;p&gt;比如说，在eshop-cache01的hosts里面&lt;/p&gt;
&lt;p&gt;192.168.31.187 eshop-cache01&lt;br/&gt;192.168.31.xxx eshop-cache02&lt;br/&gt;192.168.31.xxx eshop-cache03&lt;br/&gt;192.168.31.xxx eshop-cache04&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、配置4台CentOS为ssh免密码互相通信【此时四台linux虚拟机可以通过ssh实现无密码输入通信】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）首先在四台机器上配置对本机的ssh免密码登录&lt;br/&gt;ssh-keygen -t rsa&lt;br/&gt;生成本机的公钥，过程中不断敲回车即可，ssh-keygen命令默认会将公钥放在/root/.ssh目录下&lt;br/&gt;cd /root/.ssh&lt;br/&gt;cp id_rsa.pub authorized_keys&lt;br/&gt;将公钥复制为authorized_keys文件，此时使用ssh连接本机就不需要输入密码了&lt;/p&gt;
&lt;p&gt;（2）接着配置三台机器互相之间的ssh免密码登录&lt;br/&gt;使用ssh-copy-id -i hostname命令将本机的公钥拷贝到指定机器的authorized_keys文件中&lt;/p&gt;

&lt;h2&gt; 虚拟机安装二：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、安装单机版redis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz&lt;br/&gt;tar -xzvf tcl8.6.1-src.tar.gz&lt;br/&gt;cd /usr/local/tcl8.6.1/unix/&lt;br/&gt;./configure&lt;br/&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;使用redis-3.2.8.tar.gz（截止2017年4月的最新稳定版）&lt;br/&gt;tar -zxvf redis-3.2.8.tar.gz&lt;br/&gt;cd redis-3.2.8&lt;br/&gt;make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、redis的生产环境启动方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一般的学习课程，你就随便用redis-server启动一下redis，做一些实验，这样的话，没什么意义&lt;/p&gt;
&lt;p&gt;要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动&lt;/p&gt;
&lt;p&gt;（1）redis utils目录下，有个redis_init_script脚本&lt;br/&gt;（2）将redis_init_script脚本拷贝到linux的/etc/init.d目录中（初始化目录），将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号&lt;br/&gt;（3）修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）&lt;br/&gt;（4）创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件，也就是后面要使用的redis备份）&lt;br/&gt;（5）修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf&lt;/p&gt;
&lt;p&gt;（6）修改redis.conf中的部分配置为生产环境&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;daemonize yes 让redis以daemon进程运行（守护线程，可以理解为java运行时的jvm线程，在后台进行service服务）&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;pidfile /var/run/redis_6379.pid 设置redis的pid文件位置 【/var/run 目录下放的是各程序的pid&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;strong&gt;port 6379 设置redis的监听端口号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;dir /var/redis/6379 设置持久化文件的存储位置&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（7）启动redis，执行cd /etc/init.d, chmod 777 redis_6379，./redis_6379 start&lt;/p&gt;
&lt;p&gt;（8）确认redis进程是否启动，ps -ef | grep redis&lt;/p&gt;
&lt;p&gt;（9）让redis跟随系统启动自动启动&lt;/p&gt;
&lt;p&gt;在redis_6379脚本中，最上面，加入两行注释&lt;/p&gt;
&lt;p&gt;# chkconfig: 2345 90 10&lt;/p&gt;
&lt;p&gt;# description: Redis is a persistent key-value database&lt;/p&gt;
&lt;p&gt;chkconfig redis_6379 on&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;3、redis cli的使用&lt;/p&gt;
&lt;p&gt;redis-cli SHUTDOWN，连接本机的6379端口停止redis进程&lt;/p&gt;
&lt;p&gt;redis-cli -h 127.0.0.1 -p 6379 SHUTDOWN，制定要连接的ip和端口号&lt;/p&gt;
&lt;p&gt;redis-cli PING，ping redis的端口，看是否正常&lt;/p&gt;
&lt;p&gt;redis-cli，进入交互式命令行&lt;/p&gt;
&lt;p&gt;存取删测试：&lt;/p&gt;
&lt;p&gt;SET k1 v1&lt;br/&gt;GET k1&lt;/p&gt;
&lt;p&gt;del k1&lt;/p&gt;
&lt;p&gt;redis的技术，包括4块&lt;/p&gt;
&lt;p&gt;redis各种数据结构和命令的使用，包括java api的使用&lt;br/&gt;redis一些特殊的解决方案的使用，pub/sub消息系统，&lt;span&gt;分布式锁，&lt;/span&gt;输入的自动完成，等等&lt;br/&gt;redis日常的管理相关的命令&lt;br/&gt;&lt;span&gt;redis企业级的集群部署和架构&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; Redis在不使用备份的情况下会产生缓存雪崩问题；&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818230550852-1985003621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






























&lt;p&gt;---恢复内容结束---&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>内容持续更新 小型电商： 静态模板是固定的 数据库中的数据全量喧嚷到模板中，下次请求来了直接返回，速度也很快； 当数据上亿的时候，如果模板改定，把这些所有的数据在mysql中渲染进模板，非常耗时，不现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9499225.html</dc:identifier>
</item>
<item>
<title>java8新特性（三）_Optional类的使用 - 养码青年</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9499073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9499073.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说实话，我第一次知道这个东西是从阿里规约中，因为公司前一段时间一直在搞代码审核，我的代码写的就感觉很烂，就像规范下。让别人看起来没那么烂。于是就开始看阿里规约，在看到NPE处理的时候，上面提到用Optional类进行处理。这就是我第一次知道这个东东。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;optional简介&quot;&gt;Optional简介&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Optional 类的引入很好的解决空指针异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;optional源码查看&quot;&gt;Optional源码查看&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里建议大家自行阅读其完整源码，这里只分析filter 和 map 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;类的属性和方法&quot;&gt;类的属性和方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/20180818222207.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看出，它的构造方法都是private修饰的。其实是一个单例模式的应用。&lt;/p&gt;
&lt;h4 id=&quot;filter-方法&quot;&gt;filter 方法&lt;/h4&gt;
&lt;p&gt;该方法是过滤方法，过滤符合条件的Optional对象，这里的条件用Lambda表达式来定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Optional&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate) {
        //如果入参predicate对象为null将抛NullPointerException异常
        Objects.requireNonNull(predicate);
        //如果Optional对象的值为null，将直接返回该Optional对象
        if (!isPresent())
            return this;
        //如果Optional对象的值符合限定条件（Lambda表达式来定义），返回该值，否则返回空的Optional对象
        else
            return predicate.test(value) ? this : empty();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;map方法&quot;&gt;map方法&lt;/h4&gt;
&lt;p&gt;map方法用于修改该值，并返回修改后的Optional对象,一般会在多级取值的时候用到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper) {
        //如果入参mapper对象为null将抛NullPointerException异常
        Objects.requireNonNull(mapper);
        //如果Optional对象的值为null，将直接返回该Optional对象
        if (!isPresent())
            return empty();
        //执行传入的lambda表达式，并返回经lambda表达式操作后的Optional对象
        else {
            return Optional.ofNullable(mapper.apply(value));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实战演练&quot;&gt;实战演练&lt;/h3&gt;
&lt;h4 id=&quot;判断不为null然后进行操作&quot;&gt;判断不为null然后进行操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;     /**
     * 不为null时进行操作
     *
     * @param name
     */
    public static void doThing(String name) {
        if (name != null) {
            System.out.println(name);
        }
    }

    public static void doThingOptional(String name) {
        Optional.ofNullable(name)
                .ifPresent(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多层级取值&quot;&gt;多层级取值&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 多级取值
     *
     * @param user
     * @return
     */
    public static String getAddress(UserEntity user) {
        if (user != null) {
            AddressEntity addressEntity = user.getAddressEntity();
            if (addressEntity != null) {
                String address = addressEntity.getAddress();
                if (address != null &amp;amp;&amp;amp; address.length() &amp;gt; 3) {
                    return address;
                }

            }
        }

        return null;
    }

    public static String getAddressOptional(UserEntity user) {
        return Optional.ofNullable(user)
                .map(u -&amp;gt; u.getAddressEntity())
                .map(a -&amp;gt; a.getAddress())
                .filter(s -&amp;gt; s.length() &amp;gt; 3)
                .orElse(null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，玩的开心.&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 14:44:00 +0000</pubDate>
<dc:creator>养码青年</dc:creator>
<og:description>说实话，我第一次知道这个东西是从阿里规约中，因为公司前一段时间一直在搞代码审核，我的代码写的就感觉很烂，就像规范下。让别人看起来没那么烂。于是就开始看阿里规约，在看到NPE处理的时候，上面提到用Opt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9499073.html</dc:identifier>
</item>
</channel>
</rss>