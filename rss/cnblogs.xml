<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>redis调优的实战经验 - 大叔据</title>
<link>http://www.cnblogs.com/uncleData/p/9689322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uncleData/p/9689322.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文根据redis的info命令查看redis的内存使用情况以及state状态，来观察redis的运行情况以及需要作出的相应优化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
&lt;code&gt;1.memory
used_memory:13409011624 #used_memory=实际缓存占用的内存+Redis自身运行所占用的内存(如元数据、lua)。
                        #这个值是由Redis使用内存分配器分配的内存，不包括内存碎片浪费的内存。
used_memory_rss:13740019719  #从操作系统上显示已经分配的内存总量。
used_memory_peak:13409011624  #内存使用的峰值大小
total_system_memory:33567678464  #系统总内存
used_memory_lua:37888  #Lua脚本引擎所使用的内存大小。
maxmemory:0  #最大可用内存(可配置，默认为total_system_memory)
maxmemory_policy:noeviction  #淘汰机制,noneviction为禁止淘汰数据
mem_fragmentation_ratio:1.02;  #内存碎片率
mem_allocator:jemalloc-4.0.3; #编译时指定的Redis内存分配器，可以是libc、jemalloc、tcmalloc。

2.stats
total_commands_processed:3500  #自启动起Redis服务处理命令的总数&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;引发内存交换&quot;&gt;1.1.引发内存交换&lt;/h2&gt;
&lt;p&gt;  当Redis内存使用率超过可用内存(maxmemory可配置)的95%时，操作系统会进行内存与swap空间数据交换。&lt;strong&gt;把内存中旧的或不再使用的内容写入硬盘上即Swap分区，以便腾出新的物理内存给新页或活动页(page)使用&lt;/strong&gt;。 在硬盘上进行读写操作要比在内存上进行读写操作，时间上慢了近&lt;strong&gt;5个数量级&lt;/strong&gt;，内存是0.1μs单位、而硬盘是10ms。如果Redis进程上发生内存交换，那么Redis和依赖Redis上数据的应用会受到严重的性能影响。&lt;/p&gt;
&lt;h2 id=&quot;rdb持久化风险&quot;&gt;1.2.rdb持久化风险&lt;/h2&gt;
&lt;p&gt;  在没有开启持久化的情况下，&lt;strong&gt;redis宕机或者内存使用率超过95%会有丢数据的风险&lt;/strong&gt;。若使用快照(rdb)持久化，Redis会fork一个子进程把当前内存中的数据完全复制一份写入到硬盘上(&lt;strong&gt;fork使用的内存和redis当前使用的内存会一样多&lt;/strong&gt;)。因此若是当前使用内存&lt;strong&gt;超过可用内存的45%时&lt;/strong&gt;触发快照功能，那么此时进行的内存交换会变的非常危险(可能会丢失数据)。 倘若在这个时候实例上有大量频繁的更新操作，问题会变得更加严重。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;尽可能的使用Hash数据结构&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。所以&lt;strong&gt;在不需要集合(set)操作或list的push/pop操作的时候，尽可能的使用Hash结构&lt;/strong&gt;。比如，在一个web应用程序中，需要存储一个对象表示用户信息，使用单个key表示一个用户，其每个属性存储在Hash的字段里，这样要比给每个属性单独设置一个key-value要高效的多。 通常情况下倘若有数据使用string结构，用多个key存储时，那么应该转换成单key多字段的Hash结构。 如上述例子中介绍的Hash结构应包含，单个对象的属性或者单个用户各种各样的资料。Hash结构的操作命令是HSET(key, fields, value)和HGET(key, field)，使用它可以存储或从Hash中取出指定的字段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;设置key的过期时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  一个减少内存使用率的简单方法就是，&lt;strong&gt;每当存储对象时确保设置key的过期时间&lt;/strong&gt;。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用Redis过期时间命令(expire,expireat, pexpire, pexpireat)去设置过期时间，这样Redis会在key过期时自动删除key。 假如你知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;回收key&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  在Redis配置文件Redis.conf中，&lt;strong&gt;通过设置“maxmemory”属性的值可以限制Redis最大使用的内存&lt;/strong&gt;，修改后重启实例生效。 也可以使用客户端命令config set maxmemory 去修改值，这个命令是立即生效的，但会在重启后会失效，需要使用config rewrite命令去刷新配置文件。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。&lt;/li&gt;
&lt;li&gt;如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;淘汰策略&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  当内存使用&lt;strong&gt;达到设置的最大阀值&lt;/strong&gt;时，需要选择一种&lt;strong&gt;key的回收策略&lt;/strong&gt;，可在Redis.conf配置文件中修改“maxmemory-policy”属性值。 若是Redis数据集中的key都设置了过期时间，那么“volatile-ttl”策略是比较好的选择。但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间。那么设置为“allkeys-lru”值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。&lt;/p&gt;
&lt;p&gt;Redis还提供了一些其他淘汰策略，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。
volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。
volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。
allkeys-lru：使用LRU算法从所有数据集合中淘汰数据。
allkeys-random：从数据集合中任意选择数据淘汰
no-enviction：禁止淘汰数据。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  通过设置maxmemory为系统可用内存的45%或95%(取决于持久化策略)和设置“maxmemory-policy”为“volatile-ttl”或“allkeys-lru”(取决于过期设置)，可以比较准确的限制Redis最大内存使用率，&lt;strong&gt;在绝大多数场景下使用这2种方式可确保Redis不会进行内存交换&lt;/strong&gt;。倘若你担心由于限制了内存使用率导致丢失数据的话，可以设置noneviction值禁止淘汰数据。&lt;/p&gt;

&lt;p&gt;  当mem_fragmentation_ratio远大于1时即used_memory_rss/used_memory（稍大于1正常）,说明redis中存在大量的内存碎片,一个比较好的解决办法就是重启redis，这里需要注意的是&lt;strong&gt;如果用的是aof持久化，那么重启之前要进行rewriteaof操作，否则会无效&lt;/strong&gt;。还有可以指定Redis使用的内存分配器，一般管理员不推荐，麻烦而且要重新编译。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://redis.io/documentation&quot;&gt;redis官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.datadoghq.com/wp-content/uploads/2013/09/Understanding-the-Top-5-Redis-Performance-Metrics.pdf&quot;&gt;不错的英文文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;评论不能及时回复可直接加公众号提问或交流，知无不答，谢谢 。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3334524-a32f634684a8d101.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;欢迎关注大叔&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 21 Sep 2018 22:47:00 +0000</pubDate>
<dc:creator>大叔据</dc:creator>
<og:description>本文根据redis的info命令查看redis的内存使用情况以及state状态，来观察redis的运行情况以及需要作出的相应优化。 info 1.used_memory 过大导致的问题 1.1.引发内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uncleData/p/9689322.html</dc:identifier>
</item>
<item>
<title>5年后、10年后，你想成为什么样的自己？ - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/what-do-you-want-to-be.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/what-do-you-want-to-be.html</guid>
<description>&lt;div id=&quot;js_content&quot; class=&quot;rich_media_content&quot; readability=&quot;71&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191097/201809/191097-20180922022824553-681320968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 年后、10 年后，你想成为什么样的自己？你认真思考过这个问题吗？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能你思考过这个问题，但一直没有给自己一个明确的答案，也可能你从来没想过这个问题。这都很正常，毕竟我们都太容易陷入一日复一日的漩涡里。每天早上起来乘一样的交通工具行一样的路去工作，做一样的事情；下班行一样的路回家，做一样的事情；闲暇时去差不多一样的地方玩，去看差不多一样的影剧。然后一天的日子就变成了一年，很快就变成了一生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥有稳定的生活固然很好，但我们还是要有意识地引导自己去往更好的未来。就像处在漆黑的屋子里，你必须找到那个电灯开关，按下去，这样才能看清周围的样子，心中才能不恐慌。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 年后、10 年后，你想成为什么样的自己？归根结底，问的是你是否有清晰的目标。说到目标，确实，目标是非常重要的，没有目标就不知道自己要去哪里，没有目标就没有出发的动力。但是有目标还不够，有目标不表示你会有持久的动力，不表示你在追求的过程中能感受到快乐。设定目标只是一种技巧，清晰才是真正的力量。如何才能有清晰的目标，你要清楚地回答下面的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;你自己现在是个什么样的人？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在职业上，你的能力达到了什么水平？你是一个合格的小兵，还是一个能够独挡一面的大将军？在生活上，你有哪些品质又有哪些缺点？你是否能够很好地维护家庭关系？你是否能够让身边的人感到快乐？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2. &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;未来你想成为一个什么样的自己？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你是想成为受人尊敬有影响力的人？还是想可以做想做的事而不用担心生活？要想成为那样的自己，你要拥有什么样的能力？是会说流利的英文，还是成为某个技术领域的专家？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;工作和生活中，哪些事情对你来说是真的有意义的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;回到当下的&lt;/span&gt;生活和工作中，你的第一目标分别是什么？你还有哪些事情没做？你现在所做的是否和你的目标吻合？你是否浪费了太多的时间和精力在没有意义的事情上面？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要试图在短时间内就把这些问题回答清楚，因为每个人随着认知的提高和环境的改变，看问题的角度也会发生变化。重要的是你要开始问自己，把这些问句变成日常生活的一部分，不断反复问自己，不断让答案越来越清晰。这样才能突破自己的现状，才能每走一步都感觉到离 5 年后、10 年后的那个自己更近一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hi，未来路上，我们结伴同行可好？&lt;/span&gt; &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 21 Sep 2018 18:25:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>5 年后、10 年后，你想成为什么样的自己？你认真思考过这个问题吗？ 可能你思考过这个问题，但一直没有给自己一个明确的答案，也可能你从来没想过这个问题。这都很正常，毕竟我们都太容易陷入一日复一日的漩涡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/what-do-you-want-to-be.html</dc:identifier>
</item>
<item>
<title>并行编程（Parallel Framework） - Jonins</title>
<link>http://www.cnblogs.com/jonins/p/9558276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonins/p/9558276.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;并行编程：&lt;/strong&gt;通过编码方式利用多核或多处理器称为并行编程，多线程概念的一个子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行处理&lt;/strong&gt;：把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。多线程的一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行编程分为如下几个结构&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;并行的&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;LINQ&lt;/strong&gt;&lt;/span&gt;或&lt;span&gt;&lt;strong&gt;PLINQ&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;&lt;strong&gt;Parallel&lt;/strong&gt;&lt;/span&gt;类&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;任务并行结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;并发集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;span&gt;&lt;strong&gt;SpinLock&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;SpinWait&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这些是.NET 4.0引入的功能，一般被称为&lt;strong&gt;PFX（Parallel Framework，并行框架）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Parallel&lt;/span&gt;&lt;/strong&gt;类和&lt;strong&gt;任务并行结构&lt;/strong&gt;称为&lt;strong&gt;TPL（Task Parallel Library，任务并行库）&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;并行框架（PFX）&lt;/h2&gt;
&lt;h3&gt;1.并行框架基础&lt;/h3&gt;
&lt;p&gt;当前CPU技术达到瓶颈，而制造商将关注重点转移到提高内核技术上，而标准单线程代码并不会因此而自动提高运行速度。&lt;br/&gt;利用多核提升程序性能通常需要对计算密集型代码进行一些处理：&lt;br/&gt;1.将代码划分成块。&lt;br/&gt;2.通过多线程并行执行这些代码块。&lt;br/&gt;3.结果变为可用后，以线程安全和高性能的方式整合这些结果。&lt;br/&gt;传统多线程结构虽然实现功能，但难度颇高且不方便，特别是划分和整理的步骤（本质问题是：多线程同时使用相同数据时，出于线程安全考虑进行锁定的常用策略会&lt;strong&gt;引发大量竞争&lt;/strong&gt;）。&lt;br/&gt;而&lt;strong&gt;并行框架（Parallel Framework）&lt;/strong&gt;专门用于在这些应用场景中提供帮助。&lt;/p&gt;
&lt;h3&gt;2.并行框架组成&lt;/h3&gt;
&lt;p&gt;PFX：高层由两个数据并行API组成：PLINQ或Parallel类。底层包含任务并行类和一组另外的结构为并行编程提供帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1440910/201809/1440910-20180911215911345-1561819809.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;基础并行语言集成查询（PLINQ）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语言集成查询（Language Integrated Query,LINQ）&lt;/strong&gt;提供了一个简捷的语法来查询数据集合。而这种由一个线程顺序处理数据集合的方式我们称为&lt;strong&gt;顺序查询（sequential query）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行语言集成查询（Parallel LINQ）&lt;/strong&gt;是&lt;strong&gt;LINQ&lt;/strong&gt;的&lt;strong&gt;并行版&lt;/strong&gt;。它将顺序查询转换为并行查询，在内部使用任务，将集合中数据项的处理工作分散到多个CPU上，以并发处理多个数据项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PLINQ将自动并行化本地的LINQ查询&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;System.Linq.ParallelEnumerable&lt;/strong&gt;&lt;/span&gt;类（它定义在System.Core.dll中，需要引用System.Linq）公开了所有&lt;strong&gt;标准LINQ操作符的并行版本&lt;/strong&gt;。这些所有方法是依据&lt;span&gt;&lt;strong&gt;System.Linq.ParallelQuery&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;扩展而来。&lt;/p&gt;
&lt;h3&gt;1.LINQ to PLINQ&lt;/h3&gt;
&lt;p&gt;要让LINQ查询调用并行版本，必须将自己的&lt;strong&gt;顺序查询（基于IEnumerable或IEnumerable&amp;lt;T&amp;gt;）&lt;/strong&gt;转换成&lt;strong&gt;并行查询（基于ParallelQuery或ParallelQuery&amp;lt;T&amp;gt;）&lt;/strong&gt;,使用&lt;span&gt;&lt;strong&gt;ParallelEnumerable&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;AsParallel&lt;/strong&gt;&lt;/span&gt;方法实现,如示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = Enumerable.Range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             ParallelQuery parallelQuery =
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;from&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; numbers.AsParallel()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为并行&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;where&lt;/span&gt; n &amp;gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;select&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; parallelQuery)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                Console.WriteLine(item);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：使用Enumerable.Range生成的集合是顺序的，但是经过并行查询后顺序被打乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180914151707589-427256261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.PLINQ to LINQ&lt;/h3&gt;
&lt;p&gt; 将执行并行查询的操作切换回执行顺序查询（并不常用），通过&lt;strong&gt;&lt;span&gt;ParalleIEnumerable&lt;/span&gt;&lt;/strong&gt;的&lt;span&gt;&lt;strong&gt;AsSequential&lt;/strong&gt;&lt;/span&gt;实现。此时操作只由一个线程执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = Enumerable.Range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; enumerable = numbers.AsParallel().AsSequential().Where(c =&amp;gt; c &amp;gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerable)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                Console.WriteLine(item);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.整合结果集（ForAll）&lt;/h3&gt;
&lt;p&gt;通常，一个LINQ查询的结果数据是让某个线程执行一个&lt;span&gt;foreach&lt;/span&gt;来处理，此时只有一个线程遍历查询的所有结果，如果希望&lt;strong&gt;以并行方式处理查询结果&lt;/strong&gt;，通过&lt;span&gt;&lt;strong&gt;ParalleIEnumerable&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;ForAll&lt;/strong&gt;&lt;/span&gt;方法处理查询，如示例：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = Enumerable.Range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             (&lt;span&gt;from&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; numbers.AsParallel() &lt;span&gt;where&lt;/span&gt; n &amp;gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; n).ForAll((d) =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;             {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                  d = d + &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                 Console.WriteLine(d);&lt;span&gt;//Console在此回损害性能，因为内部回对线程进行同步，此处因演示所以暂且一用
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;             });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180914165239749-357172300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;解析PLINQ&lt;/h2&gt;
&lt;h3&gt;1.PLINQ执行模型&lt;/h3&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180914165748027-2031355513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.异常处理&lt;/h3&gt;
&lt;p&gt;PLINQ的报错将以&lt;span&gt;&lt;strong&gt;AggregateException&lt;/strong&gt;&lt;/span&gt;形式被重抛，其中&lt;strong&gt;&lt;span&gt;InnerExceeptions&lt;/span&gt;&lt;/strong&gt;属性包含一个或多个真正异常，示例可看 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/jonins/p/9558275.html&quot; target=&quot;_blank&quot;&gt;异步编程（async&amp;amp;await）&lt;/a&gt;&lt;/strong&gt;内的异常处理部分。&lt;/p&gt;
&lt;h3&gt;3.PLINQ结果的排序&lt;/h3&gt;
&lt;p&gt; 并行化查询当整理结果时不能保持初始化数据的原始次序。如果要保持序列的原始序列，可以通过在&lt;span&gt;&lt;strong&gt;AsParallel&lt;/strong&gt;&lt;/span&gt;之后调用&lt;span&gt;&lt;strong&gt;AsOrdered&lt;/strong&gt;&lt;/span&gt;来强制实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             IEnumerable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = Enumerable.Range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; enumerable = numbers.AsParallel().Where(c =&amp;gt; c &amp;gt; &lt;span&gt;3&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用&lt;span&gt;&lt;strong&gt;AsOrdered&lt;/strong&gt;&lt;/span&gt;时，因为PLINQ要保持跟踪每个元素的原始位置，会导致性能损失。&lt;/p&gt;
&lt;p&gt;调用&lt;span&gt;&lt;strong&gt;AsUnordered&lt;/strong&gt;&lt;/span&gt;,可以在后续的查询中低效&lt;strong&gt;&lt;span&gt;AsOrdered&lt;/span&gt;&lt;/strong&gt;产生的副作用，允许查询从调用&lt;span&gt;&lt;strong&gt;AsUnordered&lt;/strong&gt;&lt;/span&gt;时起更高效的执行。&lt;/p&gt;
&lt;h3&gt;4.PLINQ存在的局限与限制&lt;/h3&gt;
&lt;p&gt;1.若要使PLINQ发挥作用，&lt;strong&gt;必须具有一定数量的计算密集型工作&lt;/strong&gt;可分配给工作者线程。&lt;strong&gt;大多数的LINQ to Objects查询执行速度很快&lt;/strong&gt;，不仅没有必要并行化，而且划分、整理和协调额外线程的开销实际上会降低执行速度。而且查询若调用了非线程安全的方法，PLINQ的结果有可能不正确。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;PLINQ能够并行化的内容还有些限制&lt;/strong&gt;，以下查询运算符防止查询被并行化，&lt;strong&gt;除非源元素位于他们的元素索引位置&lt;/strong&gt;：Take、TakeWhile、Skip和SkipWhileSelect、SelectMany和ElementAt的索引版本。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;以下查询运算符是并行化的&lt;/strong&gt;，但所使用的复杂划分策略有时可能比顺序处理的速度还要低：Join、GroupBy、GroupJonin、Distinct、Union、Intersect和Except。&lt;/p&gt;
&lt;h3&gt;5.PLINQ的结果&lt;/h3&gt;
&lt;p&gt;和普通LINQ查询一样，PLINQ查询也是延迟求值的。意味着执行只在开始使用时触发。但是列举结果集时和普通顺序查询有区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序查询：&lt;/strong&gt;完全由使用者从输入序列中“拉取”每个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行查询：&lt;/strong&gt;通常使用独立线程来获取序列中的元素，时间上比使用者需要它们时要提前，再通过查询链并行处理元素后将结果保存在一块缓存中，以便使用者按需取用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;：过早暂停结果列举，查询处理器也会暂停或结束，目的是不浪费CPU的时间或内存。在调用&lt;span&gt;&lt;strong&gt;AsParallel&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之后调用&lt;/span&gt;WithMergeOptions&lt;/strong&gt;&lt;/span&gt;可以调节PLINQ的缓冲行为。&lt;/p&gt;
&lt;h3&gt;6.如何使用PLINQ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为何优化将LINQ都并行化是不可取的，因为LINQ能解决大多数问题，执行速度也很快，因此无法从并行化中收益。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种更好的方式是找出CPU密集的瓶颈，然后考虑通过LINQ的形式表达（这类重构，LINQ往往会使代码量变少，而且增强可读性）。&lt;/p&gt;
&lt;p&gt;PLINQ十分适用于易并行问题。他还可以很好地处理结构化的阻塞任务。&lt;/p&gt;
&lt;p&gt;PLINQ不适于镜像制作，因为将数百万元素整理为一个输出序列将带来瓶颈，相反将元素写入一个数组或托管内存块中，然后使用Parallel类或任务并行管理多线程是更好的选择。&lt;/p&gt;

&lt;h2&gt;Parallel类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Parallel&lt;/strong&gt;&lt;/span&gt;类是对线程的一个很好的抽象。该类位于&lt;span&gt;&lt;strong&gt;System.Threading.Tasks&lt;/strong&gt;&lt;/span&gt;命名空间中，&lt;strong&gt;提供了数据和任务并行性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PFX通过&lt;span&gt;&lt;strong&gt;Parallel&lt;/strong&gt;&lt;/span&gt;类中的三个静态方法，提供了一种基本形式的结构化并行机制：&lt;/p&gt;
&lt;h3&gt;1.Parallel.Invoke&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Parallel.Invoke&lt;/strong&gt;&lt;/span&gt;：&lt;strong&gt;用于并行执行一组委托&lt;/strong&gt;，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            Parallel.Invoke(
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 () =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id:{Thread.CurrentThread.ManagedThreadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 () =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id:{Thread.CurrentThread.ManagedThreadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                );
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180921105034551-979650521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Parallel.Invoke&lt;/strong&gt;&lt;/span&gt;方法并行执行一组&lt;span&gt;Action&lt;/span&gt;委托，然后等待它们完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Invoke(&lt;span&gt;params&lt;/span&gt; Action[] actions);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例看起来像是创建和等待两个Task对象的一种捷径。但两者存在重要的区别：&lt;br/&gt;如果传入一个包含数据量非常大的委托数组时，&lt;span&gt;&lt;strong&gt;Parallel.Invoke&lt;/strong&gt;&lt;/span&gt;方法仍然能高效工作，这是因为在底层，&lt;span&gt;&lt;strong&gt;Parallel.Invoke&lt;/strong&gt;&lt;/span&gt;方法是&lt;span&gt;&lt;strong&gt;将大量元素划分成较小的块&lt;/strong&gt;&lt;/span&gt;，分配给底层的&lt;span&gt;Task&lt;/span&gt;执行,而不是每个委托创建一个独立&lt;span&gt;Task&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;2.Parallel.For&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Parallel.For&lt;/strong&gt;&lt;/span&gt;：&lt;strong&gt;执行C# for循环的并行化等价循环&lt;/strong&gt;，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序循环&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    Test(i);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并行化for开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序执行转换为并行化&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 Parallel.For(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, i =&amp;gt;&lt;span&gt; Test(i));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序执行转换为并行化（更简单的方式）&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 Parallel.For(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, Test);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id：{Thread.CurrentThread.ManagedThreadId},输出结果为：{i}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180921111657142-1262749091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.Parallel.ForEach&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Parallel.ForEach&lt;/strong&gt;&lt;/span&gt;：&lt;strong&gt;执行C# foreach循环的并行化等价循环&lt;/strong&gt;，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] data = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;four&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;five&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;six&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序循环&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    Test(num);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并行化foreach开始&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序执行转换为并行化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 Parallel.ForEach(data, num =&amp;gt;&lt;span&gt; Test(num));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id：{Thread.CurrentThread.ManagedThreadId},输出结果为：{str}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180921111503975-1717420999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：以上三个方法都&lt;strong&gt;会引发阻塞直到所有工作完成为止&lt;/strong&gt;。和PLINQ一样，在出现未处理的异常之后，余下的工作者在它们当前的迭代之后停止，而一场将被抛回给调用者，并封装在一个&lt;span&gt;&lt;strong&gt;AggregateException&lt;/strong&gt;&lt;/span&gt;中。&lt;/p&gt;
&lt;h3&gt;4.索引&amp;amp;跳出（ParallelLoopState）&lt;/h3&gt;
&lt;p&gt;有时迭代索引很有用处，但是切忌&lt;strong&gt;不可像顺序循环的用法使用共享变量&lt;/strong&gt;（循环内i++）的方式使用，因为&lt;strong&gt;共享变量值在并行上下文中是线程不安全的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同样的，因为并行&lt;strong&gt;&lt;span&gt;For&lt;/span&gt;&lt;/strong&gt;或&lt;strong&gt;&lt;span&gt;ForEach&lt;/span&gt;&lt;/strong&gt;中的循环体是一个委托，所以无法使用&lt;span&gt;break&lt;/span&gt;语句提前退出循环，必须调用&lt;strong&gt;&lt;span&gt;ParallelLoopState&lt;/span&gt;&lt;/strong&gt;对象上的&lt;strong&gt;&lt;span&gt;Break&lt;/span&gt;&lt;/strong&gt;或&lt;strong&gt;&lt;span&gt;Stop&lt;/span&gt;&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;以&lt;span&gt;&lt;strong&gt;ForEach&lt;/strong&gt;&lt;/span&gt;为例，&lt;strong&gt;&lt;span&gt;ForEach&lt;/span&gt;&lt;/strong&gt;重载的其中之一如下，它包含&lt;span&gt;&lt;strong&gt;Acton&lt;/strong&gt;&lt;/span&gt;的其中有三个参数（&lt;span&gt;TSourec&lt;/span&gt;=子元素，&lt;span&gt;ParallelLoopState&lt;/span&gt;=并行循环状态，&lt;span&gt;long&lt;/span&gt;=索引）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ParallelLoopResult ForEach&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt; source, Action&amp;lt;TSource, ParallelLoopState, &lt;span&gt;long&lt;/span&gt;&amp;gt; body)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，想要得到索引和提前跳出的正确方式如示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] data = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;four&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;five&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;six&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Parallel.ForEach(data, (num, state, i) =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前索引为:{i},状态为:{state}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                Test(num);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (num == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;six&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    state.Break();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id：{Thread.CurrentThread.ManagedThreadId},输出结果为：{str}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180921154634847-1261841989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;For&lt;/strong&gt;&lt;/span&gt;的版本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] data = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;four&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;five&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;six&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Parallel.For(&lt;span&gt;0&lt;/span&gt;, data.Length, (i, state) =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前索引为:{i},状态为:{state}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                Test(data[i]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[i] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;six&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    state.Break();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程Id：{Thread.CurrentThread.ManagedThreadId},输出结果为：{str}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;任务并行&lt;/h2&gt;
&lt;p&gt;对于任务并行的内容，请戳 &lt;a href=&quot;https://www.cnblogs.com/jonins/p/9444374.html&quot; target=&quot;_blank&quot;&gt;任务（Task）&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/jonins/p/9558275.html&quot; target=&quot;_blank&quot;&gt;异步编程（async&amp;amp;await）&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;并发集合概述&lt;/h2&gt;
&lt;p&gt;.NET 4.0在&lt;span&gt;System.Collections.Concurrent&lt;/span&gt;命名空间中提供了一组新的集合。所有这些集合都完全是&lt;strong&gt;线程安全&lt;/strong&gt;的：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201809/1440910-20180921171719513-1653445596.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这些集合不仅是为使用带锁的普通集合提供了快捷方式，而且可以在一般的多线程中使用并发集合，但需要&lt;span&gt;注意&lt;/span&gt;：&lt;br/&gt;1.并发集合针对并行编程进行了调整。&lt;strong&gt;只有在高度并发的应用场景中，传统集合的性能才能胜过它们&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;线程安全的集合不能确保使用它的代码也是安全的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3.如果枚举一个并发集合的同时，另一个线程要修改它，不会抛出任何异常，相反，得到旧内容与新内容的混合。&lt;/p&gt;
&lt;p&gt;4.不存在任何List&amp;lt;T&amp;gt;的并发版本。&lt;/p&gt;
&lt;p&gt;5.它们的内存利用率没有非并发的Stack和Queue类高效，但对于并发访问的效果更好。&lt;/p&gt;
&lt;h3&gt;1.结构概述&lt;/h3&gt;
&lt;p&gt;这些并发集合与传统集合的区别是：它们公开了特殊方法来执行原子测试和行动操作，而这些方法都是通过&lt;span&gt;&lt;strong&gt;IProducerConsumerCollection&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;接口提供的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IProducerConsumerCollection&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;接口代表一个线程安全的生产者/消费者集合，这三个类继承并实现了&lt;span&gt;&lt;strong&gt;IProducerConsumerCollection&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;接口：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConcurrentStack&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;、&lt;strong&gt;&lt;span&gt;ConcurrentQueue&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/strong&gt;、&lt;span&gt;&lt;strong&gt;ConcurrentBag&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;它们实现的&lt;span&gt;&lt;strong&gt;TryAdd&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;TryTake&lt;/strong&gt;&lt;/span&gt;方法用于测试一个添加/删除操作能否执行，如果可以，则执行添加/删除操作。测试与行动不需要对传统集合上锁。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConcurrentBag&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;用于保存对象的无需集合，适用于调用Take或TryTake时不关心获取那个元素的额情况。&lt;/p&gt;
&lt;p&gt;相对于并发队列或堆栈，在多线程同时调用一个ConcurrentBag的&lt;span&gt;Add&lt;/span&gt;时，不存在竞争，但队列或堆栈并行调用&lt;span&gt;Add&lt;/span&gt;会引起一些竞争，所以ConcurrentBag上调用&lt;span&gt;&lt;strong&gt;Take&lt;/strong&gt;&lt;/span&gt;方法非常高效。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;BlockingCollection&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;类似阻塞集合，适用于等待新元素的出现，可以把它看作一个容器，使用一个阻塞集合封装所有实现IProducerConsumerCollection&amp;lt;T&amp;gt;的集合，并且允许从封装的集合中去除元素，若没有元素，操作会阻塞&lt;/p&gt;
&lt;h3&gt;2.基础方法&lt;/h3&gt;
&lt;p&gt;常用的一些方法，整理自 &lt;a href=&quot;https://blog.csdn.net/wangzhiyu1980&quot; target=&quot;_blank&quot;&gt;zy__&lt;/a&gt; ：&lt;/p&gt;
&lt;blockquote readability=&quot;60&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ConcurrentQueue&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：完全无锁，但面临资源竞争失败时可能会陷入自旋并重试操作。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Enqueue：在队尾插入元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryDequeue：尝试删除队头元素，并通过out参数返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryPeek：尝试将对头元素通过out参数返回，但不删除该元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ConcurrentStack&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：完全无锁，但面临资源竞争失败时可能会陷入自旋并重试操作。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Push：向栈顶插入元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryPop：从栈顶弹出元素，并且通过out 参数返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryPeek：返回栈顶元素，但不弹出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ConcurrentBag&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：一个无序的集合，程序可以向其中插入元素，或删除元素。在同一个线程中向集合插入，删除元素的效率很高。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Add：向集合中插入元素 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryTake：从集合中取出元素并删除 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryPeek：从集合中取出元素，但不删除该元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;BlockingCollection&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：一个支持界限和阻塞的容器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;Add ：向容器中插入元素&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryTake：从容器中取出元素并删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryPeek：从容器中取出元素，但不删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CompleteAdding：告诉容器，添加元素完成。此时如果还想继续添加会发生异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IsCompleted：告诉消费线程，生产者线程还在继续运行中，任务还未完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ConcurrentDictionary&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：&lt;em id=&quot;__mceDel&quot;&gt;对于读操作是完全无锁的，当很多线程要修改数据时，它会使用细粒度的锁。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddOrUpdate：如果键不存在，方法会在容器中添加新的键和值，如果存在，则更新现有的键和值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetOrAdd：如果键不存在，方法会向容器中添加新的键和值，如果存在则返回现有的值，并不添加新值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;TryAdd：尝试在容器中添加新的键和值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryGetValue：尝试根据指定的键获得值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryRemove：尝试删除指定的键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TryUpdate：有条件的更新当前键所对应的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetEnumerator：返回一个能够遍历整个容器的枚举器。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;根据&lt;strong&gt;ConcurrentBag&lt;/strong&gt;编写&lt;strong&gt;线程安全&lt;/strong&gt;的生产者消费者请戳：&lt;a href=&quot;https://www.cnblogs.com/InCerry/p/9497729.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;说实在的写这篇文章挺烦的，主要涉及的知识点太多讲的太细篇幅会很长况且我自己有些也还没用过，所以是概述性文章，对PFX有个基本的认识，当需要具体深入使用某些知识时再查询相关文档。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://www.cnblogs.com/jonins/category/1253133.html&quot; target=&quot;_blank&quot;&gt;并发编程（Concurrent programming）&lt;/a&gt;更新到这里基本已经完结，&lt;span&gt;&lt;strong&gt;谢谢大家的支持&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因个人的兴趣，所以准备沉淀下来专攻 &lt;strong&gt;数据结构和算法&lt;/strong&gt;，然后研究 &lt;strong&gt;人工智能&lt;/strong&gt;（Microsoft的人工智能平台Windows ML不会涉及，选择研究Google的第二代人工智能学习系统&lt;strong&gt;TensorFlow&lt;/strong&gt; ）。&lt;/p&gt;
&lt;p&gt;接下来会对&lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Python&lt;/strong&gt;进行基础的学习并更新文章。&lt;/p&gt;
&lt;p&gt;但是最核心的还是&lt;strong&gt;数据结构&amp;amp;算法&lt;/strong&gt;使用那种编程语言并不重要&lt;strong&gt;，&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;感兴趣的朋友可以关注。&lt;/p&gt;

&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;CLR via C#（第4版） Jeffrey Richter&lt;/p&gt;
&lt;p&gt;C#高级编程（第10版） C# 6 &amp;amp; .NET Core 1.0   Christian Nagel  &lt;/p&gt;
&lt;p&gt;果壳中的C# C#5.0权威指南  Joseph Albahari&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 17:24:00 +0000</pubDate>
<dc:creator>Jonins</dc:creator>
<og:description>前言 并行编程：通过编码方式利用多核或多处理器称为并行编程，多线程概念的一个子集。 并行处理：把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。多线程的一种。 并行编程分为如下几个结构： 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jonins/p/9558276.html</dc:identifier>
</item>
<item>
<title>Sqlserver 数据库数据位置讲解 及 脚本备份 - StitchWang</title>
<link>http://www.cnblogs.com/LaoWang666/p/9689155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LaoWang666/p/9689155.html</guid>
<description>&lt;p&gt;在我们实际开发过程中，使用会经常连接系统数据库（一般为开发使用内网访问）。所以导致我们回家或者是出差想要使用数据时（当然不建议回家加班），很尴尬所以赋值数据库到本地是必不可少的。&lt;/p&gt;
&lt;p&gt;为什么不使用 Sql server的 .bak 备份还原文件呢？&lt;/p&gt;
&lt;p&gt;因为有的在内网测试的数据库在备份的时候，会把备份文件放在服务器的磁盘上，导致本地磁盘无法使用（当然你如果有服务器的登陆权限也可以远程连接将.bak文件拷贝到本地使用）&lt;/p&gt;
&lt;p&gt;再说执行数据脚本之前先说一下数据库的存储构成：主要文件（.mdf）、次要文件（.ndf）、日志文件（.ldf）&lt;/p&gt;
&lt;p&gt;注：在不使用表分区的时候.ndf文件是不会生成的，默认建数据库产生的数据保存在.mdf文件里，.ldf主要记录对数据的操作日志&lt;/p&gt;
&lt;p&gt;那这些保存数据的文件由放在哪里呢？&lt;/p&gt;
&lt;p&gt;我们在安装的Sqlserver 数据库的时候默认放在C 系统盘，所以在不更改数据库最初建立的位置的情况下会在&lt;/p&gt;
&lt;p&gt;C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA  这个文件夹里面&lt;/p&gt;
&lt;p&gt;可以 右键数据库连接名 点击属性 ---- 在左侧导航页中找到 数据库设置项 选择  ----- 在右侧数据库默认位置 中 可以看到你的数据 保存的位置&lt;/p&gt;
&lt;p&gt;好了我们开始脚本备份了&lt;/p&gt;
&lt;p&gt;首先选中要备份的数据库右键 任务 ----  生成脚本&lt;/p&gt;
&lt;p&gt;好了开始上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921172645867-504897901.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921172717295-1262659863.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;418&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921172838442-1742848799.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921173106879-1400801624.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921173308572-2044116494.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;688&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180921173651111-517946990.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是到本地生成数据库了：&lt;/p&gt;
&lt;p&gt;双击脚本文件进入SQL server 查询窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345034/201809/1345034-20180922002331950-1431132715.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;363&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切记切记，文件夹一定要存在，不存在可以改一下（因为有的服务器的数据库数据保存的不在默认位置，导致生成失败）。那会刚被老大鄙视完。连路径有误都看不出&lt;/p&gt;
&lt;p&gt;一脸尴尬。。。。。&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 16:33:00 +0000</pubDate>
<dc:creator>StitchWang</dc:creator>
<og:description>在我们实际开发过程中，使用会经常连接系统数据库（一般为开发使用内网访问）。所以导致我们回家或者是出差想要使用数据时（当然不建议回家加班），很尴尬所以赋值数据库到本地是必不可少的。 为什么不使用 Sql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LaoWang666/p/9689155.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Steeltoe集成Zuul实现统一API网关 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_zuul.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_zuul.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;，本篇接上一篇《&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_eureka.html&quot; target=&quot;_blank&quot;&gt;基于Steeltoe使用Eureka实现服务注册与发现&lt;/a&gt;》，所演示的示例也是基于上一篇的基础上而扩展的。&lt;/p&gt;

&lt;p&gt;　　API Gateway（API GW / API 网关），顾名思义，是出现在系统边界上的一个面向API的、串行集中式的强管控服务，这里的边界是企业IT系统的边界。&lt;/p&gt;
&lt;p&gt;　　Zuul 是Netflix 提供的一个开源组件，致力于在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架，也有很多公司使用它来作为网关的重要组成部分。Spring Cloud 体系收录的该模块，主要用于提供动态路由、监控、安全控制、限流配额等，可以将内部微服务API同意暴露。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921170215716-745008206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有关Zuul的更多内容，请参考我的这一篇：《&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/java_spring_cloud_foundation_sample_list.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud微服务架构学习笔记与示例&lt;/a&gt;》，这里不是本文重点，不再赘述。&lt;/p&gt;

&lt;p&gt;　　（1）pom.xml添加相关依赖包：本示例的版本 =&amp;gt; Spring Boot 1.5.15.RELEASE，Spring Cloud Edgware.SR3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- zuul --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-zuul&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- eureka --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 热启动，热部署依赖包，为了调试方便，加入此包 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;!-- spring cloud dependencies --&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;Edgware.SR3&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）启动类添加@EnableZuulProxy注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableZuulProxy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZuulServiceApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ZuulServiceApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）添加必要配置（application.yml）：主要是针对Eureka的配置，本示例将Zuul也作为一个Eureka Client注册到Eureka Server中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;5000&lt;span&gt;

spring:
  application:
    name: zuul&lt;/span&gt;-gateway-&lt;span&gt;service

eureka:
  client:
    serviceUrl:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;span&gt;  instance:
    prefer&lt;/span&gt;-ip-address: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; # 优先注册IP地址而不是hostname
    instance&lt;/span&gt;-id: zuul-gateway-&lt;span&gt;container:${server.port}
  healthcheck:
    enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt; # 启用健康检查,注意:需要引用spring boot actuator

management:
  security:
    enabled: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt; # 默认为true，改为false以便可以看到routes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动Eureka Server和Zuul Server之后：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921164029967-1081030826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　示例代码：&lt;a title=&quot;zuul-service&quot; href=&quot;https://github.com/EdisonChou/Microservice.PoC.Steeltoe/tree/master/springcloud&quot; target=&quot;_blank&quot;&gt;https://github.com/EdisonChou/Microservice.PoC.Steeltoe/tree/master/springcloud/zuul-service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　基于第一篇的三个已注册到Eureka的ASP.NET Core WebAPI示例项目（示例代码：&lt;a href=&quot;https://github.com/EdisonChou/Microservice.PoC.Steeltoe/tree/master/src/Chapter1-ServiceDiscovery&quot; target=&quot;_blank&quot;&gt;https://github.com/EdisonChou/Microservice.PoC.Steeltoe/tree/master/src/Chapter1-ServiceDiscovery&lt;/a&gt;），无须做任何修改，启动并注册到Eureka之后的服务列表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921164219195-1372672284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（1）通过Zuul访问Agent-Service&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921163211723-467970859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）通过Zuul访问Premium-Service&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921163218688-825329879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）通过Zuul访问Client-Service （多Client-Service实例，验证负载均衡）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201809/381412-20180921163231618-437962436.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本文极简地介绍了一下Spring Cloud Zuul，并使用Java快速地编写了一个API网关Zuul Server，然后基于上一篇的三个ASP.NET Core演示了一下API网关的效果。当然，对于Zuul还有很多内容，这里就不再一一演示，有兴趣的童鞋或者对这种混搭式的架构感兴趣的童鞋可以去了解一下。&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 21 Sep 2018 16:06:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>Tip: 此篇已加入.NET Core微服务基础系列文章索引，本篇接上一篇《基于Steeltoe使用Eureka实现服务注册与发现》，所演示的示例也是基于上一篇的基础上而扩展的。 一、关于S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_zuul.html</dc:identifier>
</item>
<item>
<title>记一次尴尬的Java应用内存泄露排查 - fairjm</title>
<link>http://www.cnblogs.com/fairjm/p/java_application_offheap_memory_leak_analyze.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fairjm/p/java_application_offheap_memory_leak_analyze.html</guid>
<description>&lt;p&gt;这星期被线上JVM内存占用不断增大的问题所困扰,自己提出了一些假设,然后去实施验证都一一失败了,有一些经验和教训在这里分享下.&lt;br/&gt;之所以是尴尬,是最后因为修复了另一个看似不相关的问题导致内存不再上升,但这之间的关系还未明了,还需要继续追踪.&lt;br/&gt;这里讲述一下这次排查的过程.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;服务器的JVM配置为&lt;code&gt;Xmx3g&lt;/code&gt;,使用G1,没有设置&lt;code&gt;Xms&lt;/code&gt;考虑自然收缩和fgc之后的空间回拢.&lt;br/&gt;没有发生过fgc,且堆内存的增长正常,排除掉堆内存的问题.&lt;br/&gt;使用NMT查看各个区域的内存正常,committed内存不足4G,但实际情况内存占用不断增大,甚至出现了OOM killer杀掉java进程.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Total: reserved=5037MB, committed=3926MB
-                 Java Heap (reserved=3072MB, committed=3072MB)
                            (mmap: reserved=3072MB, committed=3072MB)

-                     Class (reserved=1196MB, committed=192MB)
                            (classes #29793)
                            (malloc=6MB #86203)
                            (mmap: reserved=1190MB, committed=186MB)

-                    Thread (reserved=186MB, committed=186MB)
                            (thread #184)
                            (stack: reserved=184MB, committed=184MB)
                            (malloc=1MB #922)
                            (arena=1MB #366)

-                      Code (reserved=273MB, committed=171MB)
                            (malloc=29MB #39947)
                            (mmap: reserved=244MB, committed=142MB)

-                        GC (reserved=176MB, committed=176MB)
                            (malloc=30MB #114115)
                            (mmap: reserved=146MB, committed=146MB)

-                  Compiler (reserved=1MB, committed=1MB)

-                  Internal (reserved=88MB, committed=88MB)
                            (malloc=88MB #83467)

-                    Symbol (reserved=31MB, committed=31MB)
                            (malloc=27MB #312661)
                            (arena=4MB #1)

-    Native Memory Tracking (reserved=10MB, committed=10MB)
                            (tracking overhead=10MB)

-                   Unknown (reserved=6MB, committed=0MB)
                            (mmap: reserved=6MB, committed=0MB)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921225245348-1616182920.png&quot;/&gt;&lt;br/&gt;内存增长情况(中间下降是进行fgc或重启服务)&lt;/p&gt;
&lt;p&gt;最开始考虑是直接内存的问题,观察GC行为发现没有发生过一次fgc,想当然觉得应该是直接内存无法回收,并且在手动执行gc之后内存占用的确是下降的.&lt;br/&gt;于是调整了一波JVM参数,将堆大小设置为2500M,并配置MaxDirectMemory用来触发fgc.&lt;br/&gt;但最后发现内存依旧增长,且还是没有fgc.&lt;br/&gt;再观察了下heap(jmap -heap)的情况,发现手工触发fgc后,heap释放的大小和内存下降几乎一致.&lt;br/&gt;在使用JMX查看了direct pool(java.nio.BufferPool)后惊奇地发现..直接内存并没有多少使用(我们底层用了netty,下意识认为出了问题):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921230143974-1129789118.png&quot;/&gt;&lt;br/&gt;图中所示最大只用了4M左右.&lt;/p&gt;
&lt;p&gt;最后设置了&lt;code&gt;Xms&lt;/code&gt;之后发现fgc已经没有作用,内存的使用量不会再下降,排除掉了这个因素.&lt;br/&gt;这个错误的判断最主要的原因还是先入为主,没有收集支撑的直接证据.&lt;/p&gt;

&lt;p&gt;接下去只能使用&lt;code&gt;pmap&lt;/code&gt;(pamp -X pid)看下具体的内存信息.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921230450727-543896772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现了一些有趣的东西,大量的64M块.&lt;br/&gt;直觉告诉我,快找出问题了.&lt;br/&gt;搜索了下发现类似的问题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921230615858-2043303086.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方法也很直接换一个分配内存的库.&lt;br/&gt;可选的也只有tcmalloc和jemalloc.&lt;/p&gt;
&lt;p&gt;选择了前者,配置之后效果出众.&lt;br/&gt;已经没有上图中那么多的64M块了.&lt;br/&gt;并且启动后的内存使用是掉了下来,但是好景不长.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921230953366-1591448704.png&quot;/&gt;&lt;br/&gt;(蓝线是使用了tcmalloc,红线是对比方)&lt;br/&gt;刚开始的确蓝线内存使用好一点(红线在20:00的时候重启 内存降低了).&lt;br/&gt;但随后还是增长了,比较迷的一点是在8点后内存陡降(但JVM没有重启,PID也没有变化),恢复到了最初的水平.&lt;/p&gt;
&lt;p&gt;看来问题不在这里.&lt;/p&gt;

&lt;p&gt;周常部署的时候出现一个问题,导致heap OOM,我跟了下发现了一段代码内存溢出,但看似和这个堆外内存引起的问题没有关联就没怎么在意.&lt;/p&gt;
&lt;p&gt;第二天同事修复了这个问题,迁移走了这个接口到另一个服务.&lt;br/&gt;tcmalloc的heap profiling无法使用,一开启&lt;code&gt;libunwind&lt;/code&gt;就&lt;code&gt;segment fault&lt;/code&gt;退出,换成jemalloc后开启.&lt;br/&gt;还在想是不是常见的那个zip溢出的问题,但是搜索了代码库没有发现忘记关闭的情况,等着看下增长和dump验证下.&lt;br/&gt;观察了一会儿,突然发现内存不再增长了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921231556902-865599480.png&quot;/&gt;&lt;br/&gt;(蓝线是之前一直留着的机器,中间降低是进行了重启)&lt;br/&gt;非常平稳地度过了一天.&lt;/p&gt;
&lt;p&gt;那坨profiling也失去了意义... ...&lt;/p&gt;
&lt;p&gt;这就感觉非常尴尬了...&lt;/p&gt;

&lt;p&gt;更尴尬的是另一个服务炸了... ...&lt;br/&gt;继续跟进,先把jemalloc配置过去,等下一次增长看下dump.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;随着时间的推移遇见了各种各样的问题.&lt;br/&gt;这次排查除了对之前积累的知识的运用,更多像是一次对搜索引擎熟练度的提升 :( .&lt;/p&gt;
&lt;p&gt;但过程还是很不错的,也看到了一些自己以前没有接触过的知识.&lt;br/&gt;深深感受到自己知识的匮乏,就像深渊(??)一样,逐渐深入才会发现不一样的风景.&lt;br/&gt;生活中还是要多(xie)些bug才会更精彩的啊... ...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201809/1244488-20180921233424486-892720676.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lovestblog.cn/blog/2015/05/12/direct-buffer/&quot; class=&quot;uri&quot;&gt;http://lovestblog.cn/blog/2015/05/12/direct-buffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/227924&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/227924&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jeffgriffith/native-jvm-leaks&quot; class=&quot;uri&quot;&gt;https://github.com/jeffgriffith/native-jvm-leaks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;glibc issue原问题:&lt;br/&gt;&lt;a href=&quot;https://serverfault.com/questions/341579/what-consumes-memory-in-java-process?newreg=394e0ea40e55493d8149010909011719&quot; class=&quot;uri&quot;&gt;https://serverfault.com/questions/341579/what-consumes-memory-in-java-process?newreg=394e0ea40e55493d8149010909011719&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于NMT的internal 包含了直接内存 不包含DirectMemory:&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47309859/what-is-contained-in-code-internal-sections-of-jcmd&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/47309859/what-is-contained-in-code-internal-sections-of-jcmd&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 15:36:00 +0000</pubDate>
<dc:creator>fairjm</dc:creator>
<og:description>这星期被线上JVM内存占用不断增大的问题所困扰,自己提出了一些假设,然后去实施验证都一一失败了,有一些经验和教训在这里分享下. 之所以是尴尬,是最后因为修复了另一个看似不相关的问题导致内存不再上升,但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fairjm/p/java_application_offheap_memory_leak_analyze.html</dc:identifier>
</item>
<item>
<title>RMQ_第一弹_Sparse Table - 31415926535x</title>
<link>http://www.cnblogs.com/31415926535x/p/9688994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/31415926535x/p/9688994.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: RMQ_第一弹_Sparse Table&lt;br/&gt;date: 2018-09-21 21:33:45&lt;br/&gt;tags:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;acm&lt;/li&gt;
&lt;li&gt;RMQ&lt;/li&gt;
&lt;li&gt;ST&lt;/li&gt;
&lt;li&gt;dp&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;算法&lt;br/&gt;categories:&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;acm&quot;&gt;ACM&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RMQ (Range Minimum/Maximum Query)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，，&lt;/p&gt;
&lt;p&gt;暑假集训的时候学习了 &lt;strong&gt;线段树&lt;/strong&gt; ，，，&lt;/p&gt;
&lt;p&gt;也可以对给定数组查询任意区间的最值问题，，，，&lt;/p&gt;
&lt;p&gt;这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 &lt;strong&gt;Sparse Table&lt;/strong&gt; 算法不能进行点修改，，&lt;/p&gt;
&lt;p&gt;或者说这样修改一次重预处理一次不划算，，，&lt;/p&gt;
&lt;p&gt;所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，，&lt;/p&gt;

&lt;h2 id=&quot;算法原理&quot;&gt;算法原理&lt;/h2&gt;
&lt;p&gt;基本思想是dp,,,,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dp的状态&lt;/strong&gt; : 对于数组 &lt;span class=&quot;math inline&quot;&gt;\(a[1-n]\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(F[i , j]\)&lt;/span&gt;表示从第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个位置开始 ， &lt;strong&gt;长度&lt;/strong&gt; 为&lt;span class=&quot;math inline&quot;&gt;\(2^j\)&lt;/span&gt; 个数这个区间中的最值，，，;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dp的初始值&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , 0] = a[i]\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移方程&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt; : &lt;span class=&quot;math inline&quot;&gt;\(F[i , j]\)&lt;/span&gt; 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 &lt;span class=&quot;math inline&quot;&gt;\(2^{j - 1}\)&lt;/span&gt; 个元素，，&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int maxn = 5e4 + 10;
int n , q;
int a[maxn];
int mx[maxn][20];
int mi[maxn][20];
void rmq()
{
    for (int i = 1; i &amp;lt;= n; ++i)
        mx[i][0] = mi[i][0] = a[i];

    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
    {
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
        {
            mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
            mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？&lt;br/&gt;答案是不可以。因为我们需要理解这个状态转移方程的意义。&lt;/p&gt;
&lt;p&gt;状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。&lt;/p&gt;
&lt;p&gt;而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/niushuai666/article/details/6624672?utm_source=copy&quot;&gt;本段来自某大佬博客&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;思想&quot;&gt;思想&lt;/h2&gt;
&lt;p&gt;假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。&lt;/p&gt;
&lt;p&gt;因为这个区间的长度为 &lt;span class=&quot;math inline&quot;&gt;\(j - i + 1\)&lt;/span&gt; ,所以我们可以取 &lt;span class=&quot;math inline&quot;&gt;\(k=log2( j - i + 1)\)&lt;/span&gt; ，则有：&lt;span class=&quot;math inline&quot;&gt;\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;举例说明，要求区间[2，8]的最大值，&lt;span class=&quot;math inline&quot;&gt;\(k = log_2（8 - 2 + 1）= 2\)&lt;/span&gt;，即求 &lt;span class=&quot;math inline&quot;&gt;\(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)&lt;/span&gt;；&lt;/p&gt;
&lt;h2 id=&quot;实现-1&quot;&gt;实现&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int ans(int l , int r)
{
    int k = 0;
    int len = r - l + 1;
    while ((1 &amp;lt;&amp;lt; (k + 1)) &amp;lt;= len)
        ++k;

    return max (mx[l][k] , mx[r - (1 &amp;lt;&amp;lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &amp;lt;&amp;lt; k) + 1][k]);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=3264&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差&lt;/p&gt;
&lt;p&gt;直接套板子，，，，&lt;/p&gt;
&lt;p&gt;ac代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;
const int maxn = 5e4 + 10;
int n , q;
int a[maxn];
int mx[maxn][20];
int mi[maxn][20];
void rmq()
{
    for (int i = 1; i &amp;lt;= n; ++i)
        mx[i][0] = mi[i][0] = a[i];

    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
    {
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
        {
            mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
            mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &amp;lt;&amp;lt; (j - 1))][j - 1]);
        }
    }
}
int ans(int l , int r)
{
    int k = 0;
    int len = r - l + 1;
    while ((1 &amp;lt;&amp;lt; (k + 1)) &amp;lt;= len)
        ++k;

    return max (mx[l][k] , mx[r - (1 &amp;lt;&amp;lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &amp;lt;&amp;lt; k) + 1][k]);
}
using namespace std;
int main(){ 
    while (scanf(&quot;%d%d&quot; , &amp;amp;n , &amp;amp;q) != EOF)
    {
        for (int i = 1; i &amp;lt;= n; ++i)
            scanf(&quot;%d&quot; , &amp;amp;a[i]);

        rmq();
        
        while (q--)
        {
            int l , r;
            scanf(&quot;%d%d&quot; , &amp;amp;l , &amp;amp;r);
            printf(&quot;%d\n&quot; , ans(l , r));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一维:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int MAXN = 50010;
int dp[MAXN][20];
int mm[MAXN];
//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改
void initRMQ(int n,int b[])
{
    mm[0] = −1;
    for(int i = 1; i &amp;lt;= n; i++)
    {
        mm[i] = ((i&amp;amp;(i−1)) == 0)?mm[i−1]+1:mm[i−1];
        dp[i][0] = b[i];
    }
    for(int j = 1; j &amp;lt;= mm[n]; j++)
        for(int i = 1; i + (1&amp;lt;&amp;lt;j) −1 &amp;lt;= n; i++)
            dp[i][j] = max(dp[i][j−1],dp[i+(1&amp;lt;&amp;lt;(j−1))][j−1]);
}
 //查询最大值
int rmq(int x,int y)
{
    int k = mm[y−x+1];
    return max(dp[x][k],dp[y−(1&amp;lt;&amp;lt;k)+1][k]);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Sep 2018 15:23:00 +0000</pubDate>
<dc:creator>31415926535x</dc:creator>
<og:description>title: RMQ_第一弹_Sparse Table date: 2018 09 21 21:33:45 tags: acm RMQ ST dp 数据结构 算法 categories: ACM 概述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/31415926535x/p/9688994.html</dc:identifier>
</item>
<item>
<title>WPF 语言格式化文本控件 - 唐宋元明清2188</title>
<link>http://www.cnblogs.com/kybs0/p/9688933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kybs0/p/9688933.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章讲述正确添加语言资源的方式，以及一段语言资源的多种样式显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：“@&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;Winter&lt;/strong&gt;，你好！感谢已使用软件 &lt;span&gt;800&lt;/span&gt; 天！&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在添加如上多语言资源项时，“XX，你好！感谢已使用软件 X 天！”&lt;/p&gt;
&lt;p&gt;那么，你是怎么添加语言资源的呢？&lt;/p&gt;
&lt;p&gt;分别添加，“，你好！”、“&lt;span&gt;感谢已使用软件&lt;/span&gt;”、“年”3个，再通过界面绑定动态变量 &lt;strong&gt;昵称和使用天数&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;假如你是按照如上添加语言资源的，那么问题来了，添加如上英文语言资源呢？是不是也分别添加单个资源，再拼凑绑定？&lt;/p&gt;

&lt;p&gt;正确的做法是，添加整个语言资源，&lt;span&gt;“&lt;span&gt;{0}，你好！感谢已使用软件 {1} 天！&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：&lt;/span&gt;&lt;span&gt;使用格式化的语言资源，那么将中文资源翻译成英文或者其它语言后，得到的译文才符合原有的含义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不然，一段一段翻译后的文本拼接，得到的只会是，&lt;span&gt;中式英文之类的&lt;/span&gt;。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在添加了语言资源后，如何在WPF界面显示呢？&lt;/p&gt;
&lt;h2&gt;简单的文本样式&lt;/h2&gt;
&lt;p&gt;假如只是实现简单的文本拼接，且样式相同时，可以直接绑定动态变量值 - 昵称和使用年限，然后通过StringFormat或者Conveter去处理格式化文本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果只有一个动态变量，直接使用&lt;span&gt;StringFormat处理即可。&lt;/span&gt;Text=&quot;{Binding Name,StringFormat={StaticResource TheFormatedText}}&quot;&lt;/li&gt;
&lt;li&gt;如果多个动态变量，可以使用多重绑定+Converter，实现文本格式化。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;复杂的文本样式&lt;/h2&gt;
&lt;p&gt;假如格式化文本，需要实现复杂的样式和操作，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文本+按钮&lt;/li&gt;
&lt;li&gt;文本+超链接&lt;/li&gt;
&lt;li&gt;加粗文本+普通文本+红色文本&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上，如何处理？&lt;/p&gt;
&lt;h2&gt;语言格式化控件实现&lt;/h2&gt;
&lt;p&gt;Demo显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201809/685541-20180921224554537-1066896742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 1. 添加一个继承TextBlock的用户控件ComplexTextBlock&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 解决复杂文本格式化样式的文本框控件
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如&quot;已使用软件 {0} 天&quot;，天数需要标红加粗，或者用于【文本】【文字按钮】【文本】的组合
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComplexTextBlock : TextBlock
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 重写文本依赖属性&lt;/p&gt;
&lt;p&gt;为了监听文本变更，所以重写文本的依赖属性。文本变更事件处理，之后会详细介绍~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DependencyProperty TextProperty =
&lt;span&gt; 2&lt;/span&gt;         DependencyProperty.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(ComplexTextBlock), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(TextPropertyChanged));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetText(DependencyObject element)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)element.GetValue(TextProperty);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetText(DependencyObject element, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        element.SetValue(TextProperty, value);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        LoadComplexContent(d);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 添加动态变量显示的控件列表&lt;/p&gt;
&lt;p&gt;如“@&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;Winter&lt;/strong&gt;，你好！感谢已使用软件 &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;800&lt;/span&gt; 天，可查看&lt;span&gt;详情&lt;/span&gt;！”，可以将&lt;strong&gt;昵称、使用时间、详情&lt;/strong&gt;，分别设置为&lt;strong&gt;文本控件、文本控件、超链接按钮&lt;/strong&gt;，然后添加到动态控件列表中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DependencyProperty ContentFormatsProperty =
&lt;span&gt; 2&lt;/span&gt;         DependencyProperty.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ContentFormats&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(ContentFormatsCollection), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ComplexTextBlock),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; PropertyMetadata(&lt;span&gt;default&lt;/span&gt;&lt;span&gt;(ContentFormatsCollection), ContentFormatsPropertyChanged));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 格式化内容列表
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContentFormatsCollection ContentFormats
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; (ContentFormatsCollection)GetValue(ContentFormatsProperty);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;set&lt;/span&gt; =&amp;gt;&lt;span&gt; SetValue(ContentFormatsProperty, value);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ContentFormatsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        LoadComplexContent(d);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 处理格式化文本&lt;/p&gt;
&lt;p&gt;处理方法，主要是将当前格式化的文本拆分为多个文本段落和格式化字符“{0}”，然后将待显示的动态变量（文本控件/按钮等）替换拆分后列表中的格式化字符。组合成完整的显示文本。&lt;/p&gt;
&lt;p&gt;其中，需要注意的是，文本的样式继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FormattedKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加载复杂文本
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dependencyObject&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadComplexContent(DependencyObject dependencyObject)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(dependencyObject &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ComplexTextBlock complexTextBlock))
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; text =&lt;span&gt; GetText(complexTextBlock);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; contentFormats =&lt;span&gt; complexTextBlock.ContentFormats;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(text) || contentFormats == &lt;span&gt;null&lt;/span&gt; || contentFormats.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contentFormats.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             text = text.Replace(i.ToString(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; GetTextList(text);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空当前文本&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         complexTextBlock.Text = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分段加载文本&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; stackPanel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StackPanel();
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         stackPanel.Orientation =&lt;span&gt; Orientation.Horizontal;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         stackPanel.VerticalAlignment =&lt;span&gt; VerticalAlignment.Center;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; formatIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; paraText &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (paraText ==&lt;span&gt; FormattedKey)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 stackPanel.Children.Add(contentFormats[formatIndex++&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; textLine = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextBlock();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (complexTextBlock.Style != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     textLine.Style =&lt;span&gt; complexTextBlock.Style;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                     textLine.VerticalAlignment =&lt;span&gt; complexTextBlock.VerticalAlignment;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                     textLine.HorizontalAlignment =&lt;span&gt; complexTextBlock.HorizontalAlignment;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     textLine.Background =&lt;span&gt; complexTextBlock.Background;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                     textLine.FontFamily =&lt;span&gt; complexTextBlock.FontFamily;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     textLine.FontSize =&lt;span&gt; complexTextBlock.FontSize;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                     textLine.Foreground =&lt;span&gt; complexTextBlock.Foreground;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     textLine.FontWeight =&lt;span&gt; complexTextBlock.FontWeight;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     textLine.FontStyle =&lt;span&gt; complexTextBlock.FontStyle;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 textLine.Text =&lt;span&gt; paraText;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                stackPanel.Children.Add(textLine);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        complexTextBlock.Inlines.Add(stackPanel);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取分段文本列表
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetTextList(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; formatIndex =&lt;span&gt; text.IndexOf(FormattedKey, StringComparison.Ordinal);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.不存在格式化关键字，则直接返回当前文本&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            list.Add(text);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.存在格式化关键字&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            list.Add(FormattedKey);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             list.Add(text.Substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, formatIndex));
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            list.Add(FormattedKey);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一格式化文本&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (formatIndex &amp;lt;&lt;span&gt; text.Length)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             list.AddRange(GetTextList(text.Substring(formatIndex +&lt;span&gt; FormattedKey.Length)));
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 控件的使用&lt;/p&gt;
&lt;p&gt;界面显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685541/201809/685541-20180922013509496-1289404411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;local:ComplexTextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;小王,好好{0}，详见{1}!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ComplexTextBlockStyle}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0 10 0 0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;local:ComplexTextBlock.ContentFormats&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;local:ContentFormatsCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;学习&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;ButtonBase_OnClick&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;LinkedButton&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;学习计划&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;LinkedButton_OnClick&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource LinkedTextBlock}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;local:ContentFormatsCollection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;local:ComplexTextBlock.ContentFormats&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;local:ComplexTextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细代码实现，可查看&lt;a href=&quot;https://github.com/Kybs0/ComplexTextBlock&quot; target=&quot;_blank&quot;&gt;Github源码Demo&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 15:19:00 +0000</pubDate>
<dc:creator>唐宋元明清2188</dc:creator>
<og:description>前言 本章讲述正确添加语言资源的方式，以及一段语言资源的多种样式显示。 例如：“@Winter，你好！感谢已使用软件 800 天！” 在添加如上多语言资源项时，“XX，你好！感谢已使用软件 X 天！”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kybs0/p/9688933.html</dc:identifier>
</item>
<item>
<title>MyBatis框架原理3：缓存 - AbcBoy</title>
<link>http://www.cnblogs.com/abcboy/p/9688961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abcboy/p/9688961.html</guid>
<description>&lt;p&gt;上一篇[MyBatis框架原理2：SqlSession运行过程][1]介绍了MyBatis的工作流程，其中涉及到了MyBatis缓存的使用，首先回顾一下工作流程图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231419887-780392574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果开启了二级缓存，数据查询执行过程就是首先从二级缓存中查询，如果未命中则从一级缓存中查询，如果也未命中则从数据库中查询。MyBatis的一级和二级缓存都是基于Cache接口的实现，下面先来看看Cache接口和其各种实现类。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;public interface Cache {
  String getId();
  //缓存中添加数据，key为生成的CacheKey,value为查询结果
  void putObject(Object key, Object value);
  //查询
  Object getObject(Object key);
  //删除
  Object removeObject(Object key);
  //清空缓存
  void clear();
  //获取缓存数量
  int getSize();
  //获取读写锁
  ReadWriteLock getReadWriteLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cache接口位于MyBatis的cache包下，定义了缓存的基本方法，其实现类采用了装饰器模式，通过实现类的组装，可以实现操控缓存的功能。cache包结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231443649-1402966429.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PerpetualCache是Cache接口的实现类，通过内部的HashMap来对缓存进行基本的操作，通常配合装饰器类一起使用。&lt;/li&gt;
&lt;li&gt;BlockingCache装饰器：保证只有一个线程到数据库中查询指定key的数据，如果该线程在BlockingCache中未查找到数据，就获取key对应的锁，阻塞其他查询这个key的线程，通过其内部ConcurrentHashMap来实现，源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class BlockingCache implements Cache {

  //阻塞时长
  private long timeout;
  private final Cache delegate;
  //key和ReentrantLock对象一一对应
  private final ConcurrentHashMap&amp;lt;Object, ReentrantLock&amp;gt; locks;

  @Override
  public Object getObject(Object key) {
    //获取key的锁
    acquireLock(key);
    //根据key查询
    Object value = delegate.getObject(key);
    //如果命中缓存，释放锁，未命中则继续持有锁
    if (value != null) {
      releaseLock(key);
    }        
    return value;
  }
 @Override
  //从数据库获取结果后，将结果放入BlockingCache,然后释放锁
  public void putObject(Object key, Object value) {
    try {
      delegate.putObject(key, value);
    } finally {
      releaseLock(key);
    }
  }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FifoCache装饰器: 先入先出规则删除最早的缓存，通过其内部的Deque实现。&lt;/li&gt;
&lt;li&gt;LruCache装饰器: 删除最近使用最少的缓存， 通过内部的LinkedHashMap实现。&lt;/li&gt;
&lt;li&gt;SynchronizedCache装饰器：同步Cache。&lt;/li&gt;
&lt;li&gt;LoggingCache装饰器： 提供日志功能，记录和输出缓存命中率。&lt;/li&gt;
&lt;li&gt;SerializedCache装饰器：序列化功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CacheKey对象是用来确认缓存项的唯一标识，由其内部ArrayList添加的所有对象来确认两个CacheKey是否相同，通常ArrayList内将添加MappedStatement的id,SQL语句，用户传递给SQL语句的参数以及查询结果集范围RowBounds等，CacheKey源码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CacheKey implements Cloneable, Serializable {
...
  private final int multiplier;
  private int hashcode;
  private long checksum;
  private int count;
  private List&amp;lt;Object&amp;gt; updateList;

  public CacheKey() {
    this.hashcode = DEFAULT_HASHCODE;
    this.multiplier = DEFAULT_MULTIPLYER;
    this.count = 0;
    this.updateList = new ArrayList&amp;lt;Object&amp;gt;();
  }

  //向updateLis中添加对象
  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }


  @Override
  //重写equals方法判断CacheKey是否相同
  public boolean equals(Object object) {
    if (this == object) {
      return true;
    }
    if (!(object instanceof CacheKey)) {
      return false;
    }

    final CacheKey cacheKey = (CacheKey) object;

    if (hashcode != cacheKey.hashcode) {
      return false;
    }
    if (checksum != cacheKey.checksum) {
      return false;
    }
    if (count != cacheKey.count) {
      return false;
    }
    //比较updateList中每一项
    for (int i = 0; i &amp;lt; updateList.size(); i++) {
      Object thisObject = updateList.get(i);
      Object thatObject = cacheKey.updateList.get(i);
      if (!ArrayUtil.equals(thisObject, thatObject)) {
        return false;
      }
    }
    return true;
  }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一级缓存是session级别缓存，只存在当前会话中，在没有任何配置下，MyBatis默认开启一级缓存，当一个SqlSession第一次执行SQL语句和参数查询时，将生成的CacheKey和查询结果放入缓存中，下一次通过相同的SQL语句和参数查询时，就会从缓存中获取，当进行更新或者插入操作时，一级缓存会进行清空。在上一篇中说到，MayBatis进行一级缓存查询和写入是由BaseExecutor执行的，源码如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化缓存：&lt;br/&gt;一级缓存是Cache接口的PerpetualCache实现类对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class BaseExecutor implements Executor {

  ...
  protected PerpetualCache localCache;
  protected PerpetualCache localOutputParameterCache;
  protected Configuration configuration;

  protected int queryStack;
  private boolean closed;

  protected BaseExecutor(Configuration configuration, Transaction transaction) {
    this.transaction = transaction;
    this.deferredLoads = new ConcurrentLinkedQueue&amp;lt;DeferredLoad&amp;gt;();
    //一级缓存初始化
    this.localCache = new PerpetualCache(&quot;LocalCache&quot;);
    this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);
    this.closed = false;
    this.configuration = configuration;
    this.wrapper = this;
  }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成CacheKey&lt;br/&gt;key在CachingExecutor中生成，CacheKey的updateList中放入了MappedStatement,传入SQL的参数，结果集范围rowBounds和boundSql:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将查询结果和CacheKey放入缓存：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    //缓存中放入CacheKey和占位符
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //在数据库中查询操作
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //缓存中放入CacheKey和结果集
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    //返回结果
    return list;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;再次执行相同查询条件时从缓存获取结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      //从缓存获取结果
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
      //未命中缓存，则从数据库查询
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新操作时清空缓存：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //清空缓存
    clearLocalCache();
    return doUpdate(ms, parameter);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以下代码验证下，分别开两个session进行相同的查询，第一个session查询两次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testSelect() {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        User user = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user);
        User user2 = sqlSession.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user2);
        sqlSession.close();
        System.out.println(&quot;sqlSession closed!===================================&quot;);
        //新建会话
        SqlSession sqlSession2 = sqlSessionFactory.openSession();
        User user3 = sqlSession2.selectOne(&quot;findUserById&quot;, 1);
        System.out.println(user3);
        sqlSession2.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把日志设置为DEBUG级别得到运行日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Returned connection 369241501 to pool.
sqlSession closed!===================================
DEBUG [main] - Opening JDBC Connection
DEBUG [main] - Checked out connection 369241501 from pool.
DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@16022d9d]
DEBUG [main] - Returned connection 369241501 to pool.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次会话中，虽然查询了两次id为1的用户，但是只执行了一次SQL，关闭会话后开启一次新的会话，再次查询id为1的用户，SQL再次执行，说明了一级缓存只存在SqlSession中，不同SqlSession不能共享。&lt;/p&gt;

&lt;p&gt;二级缓存是Mapper级别缓存，也就是同一Mapper下不同的session共享二级缓存区域。&lt;br/&gt;只需要在XML映射文件中增加cache标签或cache-ref标签标签就可以开启二级缓存，cache-ref标签配置的是共享其指定Mapper的二级缓存区域。具体配置信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;blocking : 是否使用阻塞缓存&lt;/li&gt;
&lt;li&gt;readOnly : 是否只读&lt;/li&gt;
&lt;li&gt;eviction: 缓存策略，可指定Cache接口下装饰器类FifoCache、LruCache、SoftCache和WeakCache&lt;/li&gt;
&lt;li&gt;flushInterval : 自动刷新缓存时间&lt;/li&gt;
&lt;li&gt;size : 设置缓存个数&lt;/li&gt;
&lt;li&gt;type : 设置缓存类型，用于自定义缓存类，默认为PerpetualCache&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二级缓存是在MyBatis的解析配置文件时初始化，在XMLMapperBuilder中将缓存配置解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void cacheElement(XNode context) throws Exception {
    if (context != null) {
      //指定默认类型为PerpetualCache
      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);
      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);
      //默认缓存策略为LruCache
      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);
      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);
      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);
      Integer size = context.getIntAttribute(&quot;size&quot;);
      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);
      boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);
      Properties props = context.getChildrenAsProperties();
      //委托builderAssistant构建二级缓存
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt; typeClass,
      Class&amp;lt;? extends Cache&amp;gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    Cache cache = new CacheBuilder(currentNamespace)
        //设置缓存类型，默认为PerpetualCache
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        //设置缓存策略，默认使用LruCache装饰器
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        //设置刷新时间
        .clearInterval(flushInterval)
        //设置大小
        .size(size)
        //设置是否只读
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    configuration.addCache(cache);
    currentCache = cache;
    return cache;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到默认的二级缓存对象结构为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180921231630252-95335430.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CachingExecutor将初始化的Cache对象用TransactionalCache包装后放入TransactionalCacheManager的Map中，下面代码中的tcm就是TransactionalCacheManager对象，CachingExecutor执行二级缓存操作过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    //从Configuration的MappedStatement中获取二级缓存
    Cache cache = ms.getCache();
    if (cache != null) {
     //判断是否需要刷新缓存，SELECT不刷新，INSERT|UPDATE|DELETE刷新缓存
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        //从二级缓存中获取数据
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);
        if (list == null) {
          //委托BaseExecutor查询
          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          //查询结果放入二级缓存
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    return delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过之前一级缓存的例子验证二级缓存，只需要在UserMapper映射文件中加入cache标签，并且让相关POJO类实现java.io.Serializable接口，运行得到日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG [main] - ==&amp;gt;  Preparing: SELECT * FROM user WHERE id = ? 
DEBUG [main] - ==&amp;gt; Parameters: 1(Integer)
DEBUG [main] - &amp;lt;==      Total: 1
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Cache Hit Ratio [com.kkb.mybatis.mapper.UserMapper]: 0.0
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5c072e3f]
DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5c072e3f]
DEBUG [main] - Returned connection 1543974463 to pool.
sqlSession closed!===================================
DEBUG [main] - Cache Hit Ratio [com.kkb.mybatis.mapper.UserMapper]: 0.3333333333333333
User [id=1, username=小明, birthday=null, sex=1, address=四川成都]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同session查询同一条记录时，总共只执行了一次SQL语句，并且日志打印出了缓存的命中率，这时候不同session已经共享了二级缓存区域。&lt;br/&gt;[1]: https://www.cnblogs.com/abcboy/p/9656302.html&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 15:17:00 +0000</pubDate>
<dc:creator>AbcBoy</dc:creator>
<og:description>上一篇[MyBatis框架原理2：SqlSession运行过程][1]介绍了MyBatis的工作流程，其中涉及到了MyBatis缓存的使用，首先回顾一下工作流程图： 如果开启了二级缓存，数据查询执行过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abcboy/p/9688961.html</dc:identifier>
</item>
<item>
<title>高并发第九弹:逃不掉的Map --&gt; HashMap,TreeMap,ConcurrentHashMap - 爱呼吸的鱼</title>
<link>http://www.cnblogs.com/aihuxi/p/9688711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aihuxi/p/9688711.html</guid>
<description>&lt;p&gt;平时大家都会经常使用到 Map,面试的时候又经常会遇到问Map的,其中主要就是 &lt;span&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;,在说ConcurrentHashMap.我们还是先看一下,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他两个基础的 Map 类: HashMap  和 TreeMap&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161027110129194&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;443&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap: &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable,Serializable {   // 这里有个很逗的事情 hashMap 继承了AvstractMap 为什么还要实现Map? 据说,作者说的 这只是个错误的写法 Q_Q
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TreeMap:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; NavigableMap&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable&lt;p&gt;public interface NavigableMap&amp;lt;K,V&amp;gt; extends SortedMap&amp;lt;K,V&amp;gt; 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;遍历&lt;/td&gt;
&lt;td&gt;性能损耗&lt;/td&gt;
&lt;td&gt;键值对&lt;/td&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;效率&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;SortMap接口，基于红黑树 &lt;/td&gt;
&lt;td&gt;默认按键的升序排序 &lt;/td&gt;
&lt;td&gt;Iterator遍历是排序的&lt;/td&gt;
&lt;td&gt;插入、删除&lt;/td&gt;
&lt;td&gt;键、值都不能为null &lt;/td&gt;
&lt;td&gt;非并发安全Map &lt;/td&gt;
&lt;td&gt;适用于在Map中插入、删除和定位元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;基于哈希散列表实现&lt;/td&gt;
&lt;td&gt;随机存储&lt;/td&gt;
&lt;td&gt;Iterator遍历是随机的 &lt;/td&gt;
&lt;td&gt;基本无&lt;/td&gt;
&lt;td&gt;只允许键、值均为null&lt;/td&gt;
&lt;td&gt;非并发安全Map&lt;/td&gt;
&lt;td&gt;适用于按自然顺序或自定义顺序遍历键(key)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;那么现在就聊一下 HashMap和ConcurrentHashMap &lt;/strong&gt; &lt;br/&gt;&lt;span&gt;我们都知道ConcurrentHashMap 是线程安全的.那为什么HashMap就线程不安全了呢?&lt;br/&gt;这里有很不错的解释&lt;a href=&quot;https://my.oschina.net/hosee/blog/673521&quot; target=&quot;_blank&quot;&gt;https://my.oschina.net/hosee/blog/673521&lt;/a&gt;&lt;br/&gt;还有一个路径太长了.给个短的 &lt;a title=&quot;也还可以就是路径太长了&quot; href=&quot;https://blog.csdn.net/jesonjoke/article/details/79978855#3hashmap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0%E4%B8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF&quot; target=&quot;_blank&quot;&gt;还可以的&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;总结起来就是:&lt;br/&gt;　　&lt;/span&gt;&lt;span&gt;1. resize死循环&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　&lt;span&gt;我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。&lt;br/&gt;在rehash的时候,在多线程的时候容易造成环形链表&lt;br/&gt;　　2.fail-fast &lt;br/&gt;　　　如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这个异常意在提醒开发者及早意识到线程安全问题，具体原因请查看&lt;a href=&quot;http://my.oschina.net/hosee/blog/612718&quot; rel=&quot;nofollow&quot;&gt;ConcurrentModificationException的原因以及解决措施&lt;/a&gt;  看了这个 我觉得需要去修改一下我原来说的CopyAndWriteArrayList 了&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;ConcurrentHashMap来了.面试以前遇到了很多次&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;（1）结构 [Java7与Java8不同]&lt;/p&gt;
&lt;p&gt;JDK7&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180418110431880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.ConcurrentHashMap中的分段锁称为Segment,它即类似于HashMap（&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/618953&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;JDK7与JDK8中HashMap的实现&lt;/a&gt;）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）&lt;/p&gt;
&lt;p&gt;2 . 当我们读取某个Key的时候它先取出key的Hash值，并将Hash值得高sshift位与Segment的个数取模，决定key属于哪个Segment。接着像HashMap一样操作Segment。 为了保证不同的Hash值保存到不同的Segment中，ConcurrentHashMap对Hash值也做了专门的优化。&lt;/p&gt;
&lt;p&gt;3. 如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）&lt;/p&gt;
&lt;h2 id=&quot;h2_9&quot;&gt;2. JDK8中的实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180418111414251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap在JDK8中进行了巨大改动，很需要通过源码来再次学习下Doug Lea的实现方法。&lt;/p&gt;
&lt;p&gt;它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/618953&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;JDK7与JDK8中HashMap的实现&lt;/a&gt;)，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。&lt;/p&gt;
&lt;h2 id=&quot;h2_28&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。&lt;/p&gt;
&lt;p&gt;jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。&lt;/p&gt;
&lt;p&gt;主要设计上的变化有以下几点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不采用segment而采用node，锁住node来实现减小锁粒度。&lt;/li&gt;
&lt;li&gt;设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。&lt;/li&gt;
&lt;li&gt;使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。&lt;/li&gt;
&lt;li&gt;sizeCtl的不同值来代表不同含义，起到了控制的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。&lt;/p&gt;
&lt;p&gt;总结: &lt;/p&gt;
&lt;p&gt;HashMap非线程安全、ConcurrentHashMap线程安全      (可以看下这个,很有&lt;a class=&quot;external&quot; href=&quot;http://my.oschina.net/hosee/blog/675423&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ConcurrentHashMap能完全替代HashTable吗？&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;HashMap允许Key与Value为空，ConcurrentHashMap不允许&lt;/p&gt;
&lt;p&gt;HashMap不允许通过迭代器遍历的同时修改，ConcurrentHashMap允许。并且更新可见&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>爱呼吸的鱼</dc:creator>
<og:description>平时大家都会经常使用到 Map,面试的时候又经常会遇到问Map的,其中主要就是 ConcurrentHashMap,在说ConcurrentHashMap.我们还是先看一下, 其他两个基础的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aihuxi/p/9688711.html</dc:identifier>
</item>
</channel>
</rss>