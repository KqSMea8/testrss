<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何访问 Service？- 每天5分钟玩转 Docker 容器技术（99） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7909136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7909136.html</guid>
<description>&lt;p&gt;前面我们已经学习了如何部署 service，也验证了 swarm 的 failover 特性。不过截止到现在，有一个重要问题还没有涉及：如何访问 service？这就是本节要讨论的问题。&lt;/p&gt;
&lt;p&gt;为了便于分析，我们重新部署 web_server。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;488.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd342e7ef.png&quot; alt=&quot;488.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;①&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker service rm&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;删除 web_server，service 的所有副本（容器）都会被删除。&lt;/p&gt;
&lt;p&gt;② 重新创建 service，这次直接用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;--replicas=2&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;创建两个副本。&lt;/p&gt;
&lt;p&gt;③ 每个 worker node 上运行了一个副本。&lt;/p&gt;
&lt;p&gt;好了，现在 service 已经在那里了，我们如何访问呢？&lt;/p&gt;
&lt;p&gt;要访问 http 服务，最起码网络得通吧，服务的 IP 我们得知道吧，但这些信息目前我们都不清楚。不过至少我们知道每个副本都是一个运行的容器，要不先看看容器的网络配置吧。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;489.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd333d9b7.png&quot; alt=&quot;489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 swarm-worker1 上运行了一个容器，是 web_server 的一个副本，容器监听了&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;80&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;端口，但并没有映射到 Docker Host，所以只能通过容器的 IP 访问。查看一下容器的 IP。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;490.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd3494b9a.png&quot; alt=&quot;490.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器 IP 为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;172.17.0.2&lt;/span&gt;&lt;/code&gt;，实际上连接的是 Docker 默认&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;bridge&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;网络。&lt;/p&gt;
&lt;p&gt;我们可以直接在 swarm-worker1 上访问容器的 http 服务。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;491.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd352f402.png&quot; alt=&quot;491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这样的访问也仅仅是容器层面的访问，服务并没有暴露给外部网络，只能在 Docker 主机上访问。换句话说，当前配置下，我们无法访问 service web_server。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;从外部访问 service&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;要将 service 暴露到外部，方法其实很简单，执行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;docker service update --publish-add 8080:80 web_server&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;492.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd35a95b9.png&quot; alt=&quot;492.png&quot;/&gt;如果是新建 service，可以直接用使用&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;--publish&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;span&gt;参数，比如：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;docker service create --name web_server --publish 8080:80 --replicas=2 httpd&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;容器在 80 端口上监听 http 请求，&lt;code&gt;&lt;span&gt;--publish-add 8080:80&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;将容器的 80 映射到主机的 8080 端口，这样外部网络就能访问到 service 了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;493.png&quot; src=&quot;https://i.imgsafe.org/cd/cdd361acbe.png&quot; alt=&quot;493.png&quot;/&gt;大家可能会奇怪，为什么 curl 集群中任何一个节点的 8080 端口，都能够访问到 web_server？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这实际上就是使用 swarm 的好处了，这个功能叫做 routing mesh，我们下一节重点讨论。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 23:16:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7909136.html</dc:identifier>
</item>
<item>
<title>Winform界面中实现通用工具栏按钮的事件处理 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/7912916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/7912916.html</guid>
<description>&lt;p&gt;在一个给客户做的项目中，界面要求修改增加通用工具栏按钮的事件处理，也就是在主界面中放置几个固定的功能操作按钮，打开不同的页面的时候，实现对应页面的功能处理，这种和我标准的界面处理方式有所不同，标准的列表界面，一般在界面中放置了一些常规的按钮，如查询/更新、新建、编辑、删除、导入、导出等常规操作，现在是需要把这些提升到主界面的层次上放置按钮，这种处理方式也算是提供一种方便吧。本篇随笔介绍实现这个功能的思路和代码实现逻辑。&lt;/p&gt;
&lt;h3&gt;1、界面功能介绍&lt;/h3&gt;
&lt;p&gt;这里要实现的通用工具栏按钮的事件处理，具体的界面是这样的，我们处于一个多文档的主界面中，在主界面的顶部工具栏放置这些通用的工具栏按钮，以便提高相关的处理便利和效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/8867/201711/8867-20171128235103050-1872667665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的界面我们可以看到，程序主界面的顶部工具栏上有一些常规的操作，包括如查询、新建、编辑、删除、导入、导出等按钮，可以为程序的功能操作提供方便。&lt;/p&gt;
&lt;p&gt;当我们打开一个新的窗体页面，那么对应的按钮事件也应该和这个窗体相关，或者我们切换到其他窗体，那么按钮的处理事件也应该跟着变化到对应的窗体上，这种就是我们需要的效果。&lt;/p&gt;
&lt;p&gt;上面的逻辑也就是我们新建一个窗体、或者切换一个窗体，那么需要通知顶部工具栏进行更新或者进行一个对接的处理才可以。&lt;/p&gt;
&lt;h3&gt;2、界面窗体基类的处理&lt;/h3&gt;
&lt;p&gt;由于我们想尽可能的减少开发的工作量，因此希望在基类进行一些事件或者接口的封装，以便降低新建列表窗体的时候的代码编写。&lt;/p&gt;
&lt;p&gt;对于一个如查询操作的处理事件，我们需要定义一个接口来实现这个功能，这样我们才可以在打开的窗体的时候，把它转换为对应的接口处理。&lt;/p&gt;
&lt;p&gt;例如我们定义一个IMenuAction的接口，以更新事件为例，需要实现三部分的接口，一个是事件定义，一个是判断是否包含更新事件，一个是具体的处理逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义菜单中的通用按钮事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMenuAction
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Refresh_MenuEvent;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含更新事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventRefresh { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessRefresh(&lt;span&gt;object&lt;/span&gt; sender, EventArgs e);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于其他总共6个标准的按钮事件处理，我们也同样一样定义，那么整个IMenuAction的接口定义如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义菜单中的通用按钮事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMenuAction
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Refresh_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 新建按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Add_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 编辑按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Edit_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Delete_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导入按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Import_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Export_MenuEvent;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含更新事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventRefresh { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含增加事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventAdd { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含编辑事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventEdit { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含删除事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventDelete { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含导入事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventImport { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含导出事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; HasEventExport { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessRefresh(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 增加操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessAdd(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 编辑操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessEdit(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessDelete(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导入操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessImport(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; ProcessExport(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么对于列表界面的基类窗体，我们除了让他继承自XtraForm这个标准的窗体外，我们还让它实现对应的IMenuAction接口，如下是列表界面基类BaseDock的窗体定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用于一般列表界面的基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseDock : XtraForm, &lt;strong&gt;&lt;span&gt;IMenuAction&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这个BaseDock的基类需要实现那些通用按钮事件的接口，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;#region&lt;/span&gt; 通用按钮菜单事件
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新按钮事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Refresh_MenuEvent;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据事件判断是否有
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HasEventRefresh
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Refresh_MenuEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用事件定义
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProcessRefresh(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Refresh_MenuEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Refresh_MenuEvent(sender, e);
            }
        }

        .......................

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过基类的这样处理，我们就可以在具体列表窗体里，赋值给对应的事件就可以了。&lt;/p&gt;
&lt;h3&gt;3、列表窗体界面的处理&lt;/h3&gt;
&lt;p&gt;例如我们处理一个应用菜单的列表管理界面，定义窗体如下所示，继承了我们所实现IMenuAction的基类BaseDock。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用菜单管理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FrmApplicationMenu : BaseDock
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们需要指定它的几个处理事件，初始化代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化公用菜单按钮的处理
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitMenuAction()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Refresh_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { btnSearch_Click(s, e); };
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Add_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { btnAddNew_Click(s, e); };
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Edit_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { winGridViewPager1_OnEditSelected(s, e); };
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Delete_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { winGridViewPager1_OnDeleteSelected(s, e); };
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Import_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { btnImport_Click(s, e); };
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Export_MenuEvent += (s, e) =&amp;gt;&lt;span&gt; { btnExport_Click(s,e);};
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就知道对应接口是如何和具体的页面事件发生关系了。&lt;/p&gt;

&lt;h3&gt;4、主窗体界面的处理&lt;/h3&gt;
&lt;p&gt;我们在构建主界面的左侧功能树的时候，我们通过树列表的选中事件加载对应的窗体，具体代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理树形菜单的点击操作，如果TAG存在，则解析并加载对应的页面到多文档里面&lt;/span&gt;
    treeView.AfterSelect += (sender, e) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; tag = e.Node.Tag &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(tag))
        {
            &lt;span&gt;&lt;strong&gt;LoadPlugInForm&lt;/strong&gt;&lt;/span&gt;(tag);
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个函数里面，我们最终是通过配置动态构建对应的窗体，LoadPlugInForm逻辑的最终实现的部分代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; form = LoadMdiForm(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainForm, objType, isShowDialog);
    RefreshButton(form);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们构建窗体或者激活窗体都获得一个窗体对象，然后刷新功能按钮的状态处理即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新按钮状态
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;form&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;当前窗体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RefreshButton(Form form)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CurrentForm =&lt;span&gt; form;
        IMenuAction action &lt;/span&gt;= form &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件处理后再判断&lt;/span&gt;
            menuButton.refresh.Enabled =&lt;span&gt; (action.HasEventRefresh);
            menuButton.add.Enabled &lt;/span&gt;=&lt;span&gt; (action.HasEventAdd);
            menuButton.edit.Enabled &lt;/span&gt;=&lt;span&gt; (action.HasEventEdit);
            menuButton.delete.Enabled &lt;/span&gt;=&lt;span&gt; (action.HasEventDelete);
            menuButton.import.Enabled &lt;/span&gt;=&lt;span&gt; (action.HasEventImport);
            menuButton.export.Enabled &lt;/span&gt;=&lt;span&gt; (action.HasEventExport);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的处理，就可以实现了在主界面的多文档处理中，不管我们是新建一个列表窗体，还是激活切换到一个其他的窗体的时候，按钮的状态和对应的窗体绑定，实现随时更新显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/8867/201711/8867-20171129002343300-1291282582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然通用工具栏按钮的事件我们需要初始化，它是根据当前选中的窗体进行统一的处理的，具体代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化菜单按钮的事件处理
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitMenuEvent()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件绑定
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先实现事件绑定&lt;/span&gt;
            menuButton.add.ItemClick += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessAdd(s, e);
                    }
                }
            };
            menuButton.edit.ItemClick &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessEdit(s, e);
                    }
                }
            };
            menuButton.delete.ItemClick &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessDelete(s, e);
                    }
                }
            };
            menuButton.import.ItemClick &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessImport(s, e);
                    }
                }
            };
            menuButton.export.ItemClick &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessExport(s, e);
                    }
                }
            };
            menuButton.refresh.ItemClick &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CurrentForm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    IMenuAction action &lt;/span&gt;= CurrentForm &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMenuAction;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        action.ProcessRefresh(s, e);
                    }
                }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个事件只需要绑定一次，不会造成按钮的事件多次绑定问题，虽然一次绑定，它的具体处理还是和当前窗体有关，它会把当前窗体转换为对应的IMenuAction接口，然后调用对应的处理函数实现功能的绑定。&lt;/p&gt;
&lt;p&gt;以上就是我对于实现这种通用按钮事件处理的思路和具体逻辑代码，供大家参考学习，有错漏之处还请多多包涵。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 16:29:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/7912916.html</dc:identifier>
</item>
<item>
<title>MongoDB中MapReduce介绍与使用 - 踏雪无痕SS</title>
<link>http://www.cnblogs.com/chenpingzhao/p/7913247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpingzhao/p/7913247.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在用MongoDB查询返回的数据量很大的情况下，做一些比较复杂的统计和聚合操作做花费的时间很长的时候，可以用MongoDB中的MapReduce进行实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapReduce是个非常灵活和强大的数据聚合工具。它的好处是可以把一个聚合任务分解为多个小的任务，分配到多服务器上并行处理。MongoDB也提供了MapReduce，当然查询语肯定是JavaScript。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MongoDB中的MapReduce主要有以下几阶段：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Map:把一个操作Map到集合中的每一个文档&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Shuffle: 根据Key分组对文档，并且为每个不同的Key生成一系列(&amp;gt;=1个)的值表(List of values)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Reduce: 处理值表中的元素，直到值表中只有一个元素。然后将值表返回到Shuffle过程，循环处理，直到每个Key只对应一个值表，并且此值表中只有一个元素，这就是MR的结果。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Finalize：此步骤不是必须的。在得到MR最终结果后，再进行一些数据“修剪”性质的处理。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;MongoDB中使用emit函数向MapReduce提供Key/Value对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Reduce函数接受两个参数：Key,emits. Key即为emit函数中的Key。 emits是一个数组，它的元素就是emit函数提供的Value。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Reduce函数的返回结果必须要能被Map或者Reduce重复使用，所以返回结果必须与emits中元素结构一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map或者Reduce函数中的this关键字，代表当前被Mapping文档。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;二、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;db.runCommand({  
    mapreduce:&amp;lt;collection&amp;gt;,  
    map:&amp;lt;mapfunction&amp;gt;,
    reduce:&amp;lt;reducefunction&amp;gt;,
    [,query:&amp;lt;query filter object&amp;gt;]
    [,sort:&amp;lt;sorts the input objects using this key.Useful for optimization,like sorting by the emit key for fewer reduces&amp;gt;]
    [,limit:&amp;lt;number of objects to return from collection&amp;gt;]
    [,out:&amp;lt;see output options below&amp;gt;]
    [,keeptemp:&amp;lt;true|false&amp;gt;]
    [,finalize:&amp;lt;finalizefunction&amp;gt;]
    [,scope:&amp;lt;object where fields go into javascript global scope&amp;gt;]
    [, jsMode : boolean，default true]
    [,verbose:true]
});
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;参数说明：&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Mapreduce：要操作的目标集合&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Map：映射函数（生成键值对序列，作为reduce函数参数）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Reduce：统计函数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Query：目标记录过滤&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Sort：目标记录排序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Limit：限制目标记录数量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Out：统计结果存放集合（不指定使用临时集合，在客户端断开后自动删除）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Keeptemp：是否保留临时集合&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Finalize：最终处理函数（对reduce返回结果进行最终整理后存入结果集合）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Scope：向map、reduce、finalize导入外部变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;jsMode说明:为false时 BSON--&amp;gt;JS--&amp;gt;map--&amp;gt;BSON--&amp;gt;JS--&amp;gt;reduce--&amp;gt;BSON,可处理非常大的mapreduce,为true时 BSON--&amp;gt;js--&amp;gt;map--&amp;gt;reduce--&amp;gt;BSON&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Verbose：显示详细的时间统计信息&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;行查询的步骤&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MapReduce对指定的集合Collection进行查询&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;对A的结果集进行mapper方法采集&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;对B的结果执行finalize方法处理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;最终结果集输出到临时Collection中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;断开连接，临时Collection删除或保留&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;需要注意的&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;以下是来自&lt;a href=&quot;http://docs.mongodb.org/manual/core/map-reduce/&quot;&gt;文档&lt;/a&gt;的图，可以清楚的说明 Map-Reduce 的执行过程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/268981/201711/268981-20171128233129034-2049304656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;17.522292993631&quot;&gt;
&lt;p&gt;&lt;span&gt;In this map-reduce operation, MongoDB applies the &lt;em&gt;map&lt;/em&gt; phase to each input document (i.e. the documents in the collection that match the query condition). The map function emits key-value pairs. For those keys that have multiple values, MongoDB applies the &lt;em&gt;reduce&lt;/em&gt; phase, which collects and condenses the aggregated data. MongoDB then stores the results in a collection. Optionally, the output of the reduce function may pass through a &lt;em&gt;finalize&lt;/em&gt; function to further condense or process the results of the aggregation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;All map-reduce functions in MongoDB are JavaScript and run within the &lt;a class=&quot;reference internal&quot; title=&quot;mongod&quot; href=&quot;https://docs.mongodb.com/manual/reference/program/mongod/#bin.mongod&quot;&gt;&lt;code class=&quot;xref mongodb mongodb-program docutils literal&quot;&gt;mongod&lt;/code&gt;&lt;/a&gt; process. Map-reduce operations take the documents of a single &lt;a class=&quot;reference internal&quot; href=&quot;https://docs.mongodb.com/manual/reference/glossary/#term-collection&quot;&gt;collection&lt;/a&gt; as the &lt;em&gt;input&lt;/em&gt; and can perform any arbitrary sorting and limiting before beginning the map stage. &lt;a class=&quot;reference internal&quot; title=&quot;mapReduce&quot; href=&quot;https://docs.mongodb.com/manual/reference/command/mapReduce/#dbcmd.mapReduce&quot;&gt;&lt;code class=&quot;xref mongodb mongodb-dbcommand docutils literal&quot;&gt;mapReduce&lt;/code&gt;&lt;/a&gt; can return the results of a map-reduce operation as a document, or may write the results to collections. The input and the output collections may be sharded.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;admonition note&quot; readability=&quot;7.327731092437&quot;&gt;
&lt;blockquote readability=&quot;8.2436974789916&quot;&gt;
&lt;p class=&quot;first admonition-title&quot;&gt;&lt;span&gt;NOTE&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;last&quot;&gt;&lt;span&gt;For most aggregation operations, the &lt;a class=&quot;reference internal&quot; href=&quot;https://docs.mongodb.com/manual/core/aggregation-pipeline/&quot;&gt;Aggregation Pipeline&lt;/a&gt; provides better performance and more coherent interface. However, map-reduce operations provide some flexibility that is not presently available in the aggregation pipeline.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Map-Reduce 的执行过程是先 &lt;code&gt;map&lt;/code&gt; 然后 &lt;code&gt;reduce&lt;/code&gt; 么？仔细再看一遍上文的图，不是每次 &lt;code&gt;map&lt;/code&gt; 都有 &lt;code&gt;reduce&lt;/code&gt; 的！如果 &lt;code&gt;map&lt;/code&gt; 的结果不是数组，mongodb 就不会执行 &lt;code&gt;reduce&lt;/code&gt;。很合理的处理逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于 &lt;code&gt;map&lt;/code&gt; 到的数据，如果在 &lt;code&gt;reduce&lt;/code&gt; 时希望做统一的处理，一定会发现数据结果是不完整的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、查询分析&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;测试数据：&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; db.test.find()
{ &quot;_id&quot; : ObjectId(&quot;5a1d45ab893253f4d2e4bf91&quot;), &quot;name&quot; : &quot;yy1&quot;, &quot;age&quot; : &quot;22&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5a1d45b1893253f4d2e4bf92&quot;), &quot;name&quot; : &quot;yy2&quot;, &quot;age&quot; : &quot;23&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5a1d45c5893253f4d2e4bf93&quot;), &quot;name&quot; : &quot;yy3&quot;, &quot;age&quot; : &quot;24&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5a1d45d4893253f4d2e4bf94&quot;), &quot;name&quot; : &quot;yy5&quot;, &quot;age&quot; : &quot;25&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5a1d45f7893253f4d2e4bf95&quot;), &quot;name&quot; : &quot;yy6&quot;, &quot;age&quot; : &quot;26&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5a1d45ff893253f4d2e4bf96&quot;), &quot;name&quot; : &quot;yy4&quot;, &quot;age&quot; : &quot;25&quot; }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;1、查询年龄大于23岁的&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;map：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;var m  = function(){if(this.age &amp;gt; 23) emit(this.age,{name:this.name})};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;reduce：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;var r = function(key,values){return JSON.stringify(values);}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;var r = function(key,values){ var ret={names:values};return ret;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生成结果集：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;var res = db.runCommand({mapreduce:&quot;test&quot;,map:m,reduce:r,out:&quot;emp_res&quot;})
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; db.emp_res.find()
{ &quot;_id&quot; : &quot;24&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy3&quot; } }
{ &quot;_id&quot; : &quot;25&quot;, &quot;value&quot; : &quot;[{\&quot;name\&quot;:\&quot;yy5\&quot;},{\&quot;name\&quot;:\&quot;yy4\&quot;}]&quot; }
{ &quot;_id&quot; : &quot;26&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy6&quot; } }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; db.emp_res.find()
{ &quot;_id&quot; : &quot;24&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy3&quot; } }
{ &quot;_id&quot; : &quot;25&quot;, &quot;value&quot; : { &quot;names&quot; : [ { &quot;name&quot; : &quot;yy5&quot; }, { &quot;name&quot; : &quot;yy4&quot; } ] } }
{ &quot;_id&quot; : &quot;26&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy6&quot; } }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后，还可以编写finalize函数对reduce的返回值做最后处理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;var f=function(key,rval){ if(key==24){ rval.msg=&quot;do somethings&quot;;} return rval }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生成结果集：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; var f=function(key,rval){ if(key==24){ rval.msg=&quot;do somethings&quot;;} return rval }
&amp;gt; db.emp_res.find()
{ &quot;_id&quot; : &quot;24&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy3&quot;, &quot;msg&quot; : &quot;do somethings&quot; } }
{ &quot;_id&quot; : &quot;25&quot;, &quot;value&quot; : { &quot;names&quot; : [ { &quot;name&quot; : &quot;yy5&quot; }, { &quot;name&quot; : &quot;yy4&quot; } ] } }
{ &quot;_id&quot; : &quot;26&quot;, &quot;value&quot; : { &quot;name&quot; : &quot;yy6&quot; } }
&amp;gt; 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;2、过滤出来age=25的&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;方法1：&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; var m  = function(){ emit(this.age,{name:this.name})};
&amp;gt; var r = function(key,values){ var ret={names:values};return ret;}
&amp;gt; var res = db.runCommand({mapreduce:&quot;test&quot;,map:m,reduce:r,finalize:f,query:{age:&quot;25&quot;},out:&quot;emp_res&quot;})
&amp;gt; db.emp_res.find()
{ &quot;_id&quot; : &quot;25&quot;, &quot;value&quot; : { &quot;names&quot; : [ { &quot;name&quot; : &quot;yy5&quot; }, { &quot;name&quot; : &quot;yy4&quot; } ] } }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;方法2：&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; var m  = function(){ emit(this.age,{p:[this.name]})};
&amp;gt; var r = function(key, values) {
    var ret = {p:[]};
    for(var i = 0; i &amp;lt; values.length; i++){
        ret.p.push(values[i].p[0]);
    }
    return ret;
};
&amp;gt; var res = db.runCommand({mapreduce:&quot;test&quot;,map:m,reduce:r,finalize:f,query:{age:&quot;25&quot;},out:&quot;emp_res&quot;})
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;方法3：&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;&amp;gt; var m = function() {
    emit(this.age, {name:[this.name]});
};
&amp;gt; var r = func       tion(key, values) {
    var ret = {locs:[]}
    for(var i = 0; i &amp;lt; values.length; i++){
        ret.locs.push(values[i].locs[0]);
    }
    return ret;    
};
&amp;gt; var res = db.runCommand({mapreduce:&quot;test&quot;,map:map,reduce:reduce,finalize:f,query:{age:&quot;25&quot;},out:&quot;emp_res&quot;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;1.148&quot;&gt;
&lt;p&gt;&lt;span&gt;这个过程中遇到很多坑，需要多练习，多debug&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 28 Nov 2017 16:27:00 +0000</pubDate>
<dc:creator>踏雪无痕SS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenpingzhao/p/7913247.html</dc:identifier>
</item>
<item>
<title>javascript执行机制 - 菜鸟的飞翔梦</title>
<link>http://www.cnblogs.com/HanJie0824/p/7913003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HanJie0824/p/7913003.html</guid>
<description>&lt;p&gt;文的目的就是要保证你彻底弄懂&lt;strong&gt;javascript的执行机制&lt;/strong&gt;，如果读完本文还不懂，可以揍我。&lt;/p&gt;
&lt;p&gt;不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：&lt;/p&gt;
&lt;p&gt;看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;let a = '1';&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log(a);&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;let b = '2';&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log(b);&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然而实际上js是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;setTimeout(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　console.log('定时器开始啦')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;});&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;new Promise(function(resolve) {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　console.log('马上执行for循环啦');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　for (var i = 0; i &amp;lt; 10000; i++) {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　i == 99 &amp;amp;&amp;amp; resolve();&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}).then(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　console.log('执行then函数啦')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;});&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;console.log('代码执行结束');&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;依照 js是按照语句出现的顺序执行 这个理念，我自信的写下输出结果：&lt;/p&gt;
&lt;pre&gt;
//&quot;定时器开始啦&quot;//&quot;马上执行for循环啦&quot;//&quot;执行then函数啦&quot;//&quot;代码执行结束&quot;
&lt;/pre&gt;
&lt;p&gt;去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？&lt;/p&gt;
&lt;p&gt;我们真的要彻底弄明白javascript的执行机制了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.关于javascript&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;j&lt;strong&gt;avascript是一门 单线程 语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的&quot;多线程&quot;都是用单线程模拟出来的，一切javascript多线程都是纸老虎！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.javascript事件循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步任务&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步任务&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/46f90000a6cc851976e3&quot; alt=&quot;这一次，彻底弄懂javascript执行机制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导图要表达的内容用文字来表述的话：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;当指定的事情完成时，Event Table会将这个函数移入Event Queue。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;上述过程会不断重复，也就是常说的Event Loop(事件循环)。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们不禁要问了，那怎么知道主线程执行栈为空啊？&lt;strong&gt;&lt;span&gt;js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说了这么多文字，不如直接一段代码更直白：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;let data = [];&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;$.ajax({&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　url: www.javascript.com,&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　data: data,&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　success: () = &amp;gt;{&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　console.log('发送成功!');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) console.log('代码执行结束');&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面是一段简易的 ajax 请求代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ajax进入Event Table，注册回调函数 success 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行 console.log('代码执行结束') 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ajax事件完成，回调函数 success 进入Event Queue。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主线程从Event Queue读取回调函数 success 并执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.又爱又恨的setTimeout&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 setTimeout 无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;setTimeout(() =&amp;gt; {&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　console.log('延时3秒');&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;},3000)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;渐渐的 setTimeout 用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;setTimeout(() = &amp;gt;{&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　task();&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　},&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;3000) console.log('执行console');&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据前面我们的结论， setTimeout 是异步的，应该先执行 console.log 这个同步任务，所以我们的结论是：&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;/执行console//task()&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;去验证一下，结果正确！&lt;/p&gt;

&lt;p&gt;然后我们修改一下前面的代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;setTimeout(() = &amp;gt;{&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　task()&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　},&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;3000) sleep(10000000)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行 task() 需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？&lt;/p&gt;

&lt;p&gt;这时候我们需要重新理解 setTimeout 的定义。我们先说上述代码是怎么执行的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;task() 进入Event Table并注册,计时开始。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行 sleep 函数，很慢，非常慢，计时仍在继续。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3秒到了，计时事件 timeout 完成， task() 进入Event Queue，但是 sleep 也太慢了吧，还没执行完，只好等着。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sleep 终于执行完了， task() 终于从Event Queue进入了主线程执行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为 task() )加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。&lt;/p&gt;

&lt;p&gt;我们还经常遇到 setTimeout(fn,0) 这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？&lt;/p&gt;

&lt;p&gt;答案是不会的， setTimeout(fn,0) 的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：&lt;/p&gt;
&lt;pre&gt;
//代码1console.log('先执行这里');setTimeout(() =&amp;gt; { console.log('执行啦')},0);
&lt;/pre&gt;
&lt;pre&gt;
//代码2console.log('先执行这里');setTimeout(() =&amp;gt; { console.log('执行啦')},3000);
&lt;/pre&gt;
&lt;p&gt;代码1的输出结果是：&lt;/p&gt;
&lt;pre&gt;
//先执行这里//执行啦
&lt;/pre&gt;
&lt;p&gt;代码2的输出结果是：&lt;/p&gt;
&lt;pre&gt;
//先执行这里// ... 3s later// 执行啦
&lt;/pre&gt;
&lt;p&gt;关于 setTimeout 要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.又恨又爱的setInterval&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面说完了 setTimeout ，当然不能错过它的孪生兄弟 setInterval 。他俩差不多，只不过后者是循环的执行。对于执行顺序来说， setInterval 会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。&lt;/p&gt;
&lt;p&gt;唯一需要注意的一点是，对于 setInterval(fn,ms) 来说，我们已经知道不是每过 ms 秒会执行一次 fn ，而是每过 ms 秒，会有 fn 进入Event Queue。一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms ，那么就完全看不出来有时间间隔了 。这句话请读者仔细品味。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.Promise与process.nextTick(callback)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;传统的定时器部分我们已经研究过了，接下来我们看下 Promise 与 process.nextTick(callback) 的表现。&lt;/p&gt;
&lt;p&gt;Promise 的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而 process.nextTick(callback) 类似node.js版的&quot;setTimeout&quot;，在事件循环的下一次循环中调用 callback 回调函数。&lt;/p&gt;
&lt;p&gt;我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;macro-task(宏任务)：包括整体代码script，setTimeout，setInterval&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;micro-task(微任务)：Promise，process.nextTick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同类型的任务会进入对应的Event Queue，比如 setTimeout 和 setInterval 会进入相同的Event Queue。&lt;/p&gt;
&lt;p&gt;事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;setTimeout(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('setTimeout');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) new Promise(function(resolve) {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('promise');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}).then(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('then');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) console.log('console');&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这段代码作为宏任务，进入主线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先遇到 setTimeout ，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来遇到了 Promise ， new Promise 立即执行， then 函数分发到微任务Event Queue。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遇到 console.log() ，立即执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 then 在微任务Event Queue里面，执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中 setTimeout 对应的回调函数，立即执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件循环，宏任务，微任务的关系如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/46f7000470d74d6395f8&quot; alt=&quot;这一次，彻底弄懂javascript执行机制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;console.log('1');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;setTimeout(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　console.log('2');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　process.nextTick(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　console.log('3');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　}) new Promise(function(resolve) {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　console.log('4');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　resolve();&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　}).then(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　console.log('5')&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　})&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) process.nextTick(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('6');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) new Promise(function(resolve) {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('7');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　resolve();&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}).then(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('8')&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) setTimeout(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('9');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　process.nextTick(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('10');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}) new Promise(function(resolve) {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('11');&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　resolve();&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;}).then(function() {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　console.log('12')&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　})&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;})&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一轮事件循环流程分析如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整体script作为第一个宏任务进入主线程，遇到 console.log ，输出1。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;遇到 setTimeout ，其回调函数被分发到宏任务Event Queue中。我们暂且记为 setTimeout1 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;遇到 process.nextTick() ，其回调函数被分发到微任务Event Queue中。我们记为 process1 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;遇到 Promise ， new Promise 直接执行，输出7。 then 被分发到微任务Event Queue中。我们记为 then1 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;又遇到了 setTimeout ，其回调函数被分发到宏任务Event Queue中，我们记为 setTimeout2 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p9.pstatp.com/large/46fc000069461e06f479&quot; alt=&quot;这一次，彻底弄懂javascript执行机制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。&lt;/p&gt;
&lt;p&gt;我们发现了 process1 和 then1 两个微任务。&lt;/p&gt;
&lt;p&gt;执行 process1 ,输出6。&lt;/p&gt;
&lt;p&gt;执行 then1 ，输出8。&lt;/p&gt;
&lt;p&gt;好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从 setTimeout1 宏任务开始：&lt;/p&gt;
&lt;p&gt;首先输出2。接下来遇到了 process.nextTick() ，同样将其分发到微任务Event Queue中，记为 process2 。 new Promise 立即执行输出4， then 也分发到微任务Event Queue中，记为 then2 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/46fa0000a87715602412&quot; alt=&quot;这一次，彻底弄懂javascript执行机制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二轮事件循环宏任务结束，我们发现有 process2 和 then2 两个微任务可以执行。&lt;/p&gt;
&lt;p&gt;输出3。&lt;/p&gt;
&lt;p&gt;输出5。&lt;/p&gt;
&lt;p&gt;第二轮事件循环结束，第二轮输出2，4，3，5。&lt;/p&gt;
&lt;p&gt;第三轮事件循环开始，此时只剩setTimeout2了，执行。&lt;/p&gt;
&lt;p&gt;直接输出9。&lt;/p&gt;
&lt;p&gt;将 process.nextTick() 分发到微任务Event Queue中。记为 process3 。&lt;/p&gt;
&lt;p&gt;直接执行 new Promise ，输出11。&lt;/p&gt;
&lt;p&gt;将 then 分发到微任务Event Queue中，记为 then3 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3.pstatp.com/large/46f80003d5ef46fdb8ba&quot; alt=&quot;这一次，彻底弄懂javascript执行机制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三轮事件循环宏任务执行结束，执行两个微任务 process3 和 then3 。&lt;/p&gt;
&lt;p&gt;输出10。&lt;/p&gt;
&lt;p&gt;输出12。&lt;/p&gt;
&lt;p&gt;第三轮事件循环结束，第三轮输出9，11，10，12。&lt;/p&gt;
&lt;p&gt;整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。&lt;/p&gt;
&lt;p&gt;6.写在最后&lt;/p&gt;
&lt;p&gt;(1)js的异步&lt;/p&gt;
&lt;p&gt;我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。&lt;/p&gt;
&lt;p&gt;(2)事件循环Event Loop&lt;/p&gt;
&lt;p&gt;事件循环是js实现异步的一种方法，也是js的执行机制。&lt;/p&gt;
&lt;p&gt;(3)javascript的执行和运行&lt;/p&gt;
&lt;p&gt;执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。&lt;/p&gt;
&lt;p&gt;(4)setImmediate&lt;/p&gt;
&lt;p&gt;微任务和宏任务还有很多种类，比如 setImmediate 等等，执行都是有共同点的，有兴趣的同学可以自行了解。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;修改：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;JS执行周期 浏览器（1 7 6 8      2 4 3 5      9 11 10 12）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-tasks queue macro-tasks queue&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-tasks queue macro-tasks queue&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-tasks queue NodeJS（1 7 6 8     2 4 9 11      3 10 5 12）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-tasks queue macro-tasks queue&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-tasks queue macro-tasks queue&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;说明（优先级由上往下） main(主线程任务) 由上往下顺序执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;micro-task(微任务) Promise，process.nextTick&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;content-html&quot; data-v-7f6a837b=&quot;&quot;&gt;macro-task(宏任务) script，setTimeout，setInterval&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;console.log('1');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;setTimeout(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('2');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;new Promise(function(resolve) {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('4');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;resolve();&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}).then(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('5')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;})&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}) new Promise(function(resolve) {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('7');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;resolve();&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}).then(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('8')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}) setTimeout(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('9');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;new Promise(function(resolve) {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('11');&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;resolve();&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;}).then(function() {&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;console.log('12')&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;})&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;})输出：1 7 8 2 4 5 9 11 12&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：process.nextTick 优先级大于 promise.then；浏览器中未支持 process.nextTick&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/944376/201711/944376-20171129000341019-849719776.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 16:02:00 +0000</pubDate>
<dc:creator>菜鸟的飞翔梦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HanJie0824/p/7913003.html</dc:identifier>
</item>
<item>
<title>【读书笔记】《触点 服务设计的全球语境》第1章：从股东价值到共享价值 - 疯子王</title>
<link>http://www.cnblogs.com/FirstTom/p/7912905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FirstTom/p/7912905.html</guid>
<description>&lt;p&gt;服务设计相对而言，还是一个比较新的东西，区别于用户体验设计（UED）。国内使用的公司并不多，能够体现到系统实施，而不仅仅体现在理论阶段的，更是凤毛麟角。&lt;/p&gt;
&lt;p&gt;很庆幸，现在的公司正在实施服务设计，并且已经有不少系统采用服务设计的理念成功上线，投产使用。&lt;/p&gt;

&lt;p&gt;目前正在学习《This is service design thinking》和《触点 服务设计的全球语境》这两本书，借此机会整理读书笔记。先从《触点 服务设计的全球语境》开始。&lt;/p&gt;

&lt;p&gt;下面是第一章“从股东价值到共享价值”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/432936/201711/432936-20171128233733003-1357969508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 15:41:00 +0000</pubDate>
<dc:creator>疯子王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FirstTom/p/7912905.html</dc:identifier>
</item>
<item>
<title>Java精选笔试题 - 小山博客</title>
<link>http://www.cnblogs.com/peke/p/7912888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peke/p/7912888.html</guid>
<description>&lt;p&gt;合抱之木，生于毫末；九层之台，起于垒土；千里之行；始于足下。赶快测测你的Java基础知识掌握的如何？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1，下列说法正确的是（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.一个文件里可以同时存在两个public修饰的类&lt;/p&gt;
&lt;p&gt;B.构造函数可以被重写（override）&lt;/p&gt;
&lt;p&gt;C.子类不能访问父类非public和protected修饰的属性&lt;/p&gt;
&lt;p&gt;D.final修饰的类可以被继承&lt;/p&gt;
&lt;p&gt;答案：C&lt;/p&gt;
&lt;p&gt;        一个Java源文件中最多只能有一个public类，当有一个public类时，源文件名必须与之一致，否则无法编译，如果源文件中没有一个public类，则文件名与类中没有一致性要求。至于main()不是必须要放在public类中才能运行程序。&lt;/p&gt;
&lt;p&gt;　　重写是子类继承父类后对父类的方法进行修改。方法名，参数，返回值必须一样。 不能重写被标示为final的方法。如果不能继承一个方法，则不能重写这个方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;扩展：重写override，重载overload的区别&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　 &lt;strong&gt;&lt;em&gt; java的方法重载&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法,而且返回值类型可以相同也可以不相同，这也是面向对象的多态性。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　&lt;strong&gt;  java的方法重写&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        子类函数的访问修饰权限不能少于父类的；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2，for(int x=0,y=0;(y!=0)&amp;amp;&amp;amp;(x&amp;lt;4);x++)循环的执行次数是（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.无限次　　　　&lt;/p&gt;
&lt;p&gt;B.执行4次　　　　&lt;/p&gt;
&lt;p&gt;C.执行3次　　　　&lt;/p&gt;
&lt;p&gt;D.一次也不执行&lt;/p&gt;
&lt;p&gt;答案：D&lt;/p&gt;
&lt;p&gt;        y初始值为0，在整个for循环中，y的值不变，故判断语句中的(y!=0)不成立，故一次也不执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3，关于 JAVA 堆,下面说法错误的是( )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A.所有类的实例和数组都是在堆上分配内存的　　　　　　　　&lt;/p&gt;
&lt;p&gt;B.对象所占的堆内存是由自动内存管理系统回收&lt;/p&gt;
&lt;p&gt;C.堆内存由存活和死亡的对象，空闲碎片区组成　　　　　　　&lt;/p&gt;
&lt;p&gt;D.数组是分配在栈中的&lt;/p&gt;
&lt;p&gt;答案：D&lt;/p&gt;
&lt;p&gt;        首先数组是分配在堆中的，故D的说法不正确。&lt;/p&gt;
&lt;p&gt;        Java堆的结构：JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4，在使用super 和this关键字时，以下描述正确的是（）&lt;/strong&gt;&lt;br/&gt;A.在子类构造方法中使用super（）显示调用父类的构造方法；&lt;/p&gt;
&lt;p&gt;    super（）必须写在子类构造方法的第一行，否则编译不通过&lt;br/&gt;B.super（）和this（）不一定要放在构造方法内第一行&lt;br/&gt;C.this（）和super（）可以同时出现在一个构造函数中&lt;br/&gt;D.this（）和super（）可以在static环境中使用，包括static方法和static语句块&lt;/p&gt;
&lt;p&gt;答案：A&lt;/p&gt;
&lt;p&gt;        Java关键字this只能用于方法方法体内。当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。&lt;/p&gt;
&lt;p&gt;        super关键和this作用类似，是被屏蔽的成员变量或者成员方法或变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。&lt;/p&gt;
&lt;p&gt;        不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5，下列语句哪一个正确（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A．Java程序经编译后会产生machine code&lt;/p&gt;
&lt;p&gt;B．Java程序经编译后会产生byte code&lt;/p&gt;
&lt;p&gt;C．Java程序经编译后会产生DLL&lt;/p&gt;
&lt;p&gt;D．以上都不正确&lt;/p&gt;
&lt;p&gt;答案：B&lt;/p&gt;
&lt;p&gt;        Java字节码是Java源文件编译产生的中间文件&lt;/p&gt;
&lt;p&gt;        java虚拟机是可运行java字节码的假想计算机 java的跨平台性也是相对与其他编程语言而言的 。&lt;/p&gt;
&lt;p&gt;        先介绍一下c语言的编译过程：c的文件经过C编译程序编译后生成windows可执行文件exe文件然后在windows中执行。&lt;/p&gt;
&lt;p&gt;        再介绍java的编译过程：java的文件由java编译程序将java字节码文件就是class文件在java虚拟机中执行。机器码是由CPU来执行的；Java编译后是字节码。&lt;/p&gt;
&lt;p&gt;        电脑只能运行机器码。Java在运行的时候把字节码变成机器码。C/C++在编译的时候直接编译成机器码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6，下列哪一种叙述是正确的（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A．abstract修饰符可修饰字段、方法和类&lt;/p&gt;
&lt;p&gt;B．抽象方法的body部分必须用一对大括号{ }包住&lt;/p&gt;
&lt;p&gt;C．声明抽象方法，大括号可有可无&lt;/p&gt;
&lt;p&gt;D．声明抽象方法不可写出大括号&lt;/p&gt;
&lt;p&gt;答案：D&lt;/p&gt;
&lt;p&gt;        abstract修饰符用来修饰类和成员方法 &lt;/p&gt;
&lt;p&gt;        用abstract修饰的类表示抽象类，抽象类位于继承树的抽象层，抽象类不能被实例化。 &lt;/p&gt;
&lt;p&gt;        用abstract修饰的方法表示抽象方法,抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现。 &lt;/p&gt;
&lt;p&gt;        Abstract是Java中的一个重要关键字，可以用来修饰一个类或者一个方法。&lt;/p&gt;
&lt;p&gt;        修饰一个方法时，表示该方法只有特征签名（signature），没有具体实现，而是把具体实现留给继承该类的子类，所以不能有大括号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7，下列说法正确的有（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A．class中的constructor不可省略&lt;/p&gt;
&lt;p&gt;B．constructor必须与class同名，但方法不能与class同名&lt;/p&gt;
&lt;p&gt;C．constructor在一个对象被new时执行&lt;/p&gt;
&lt;p&gt;D．一个class只能定义一个constructor&lt;/p&gt;
&lt;p&gt;答案：C &lt;/p&gt;
&lt;p&gt;        这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8，GC线程是否为守护线程（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案：是&lt;/p&gt;
&lt;p&gt;        线程分为守护线程和非守护线程（即用户线程）。&lt;/p&gt;
&lt;p&gt;        只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。&lt;/p&gt;
&lt;p&gt;        守护线程最典型的应用就是 GC (垃圾回收器)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9，关于sleep()和wait()，以下描述错误的一项是（ ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. sleep是线程类（Thread）的方法，wait是Object类的方法；&lt;/p&gt;
&lt;p&gt;B. sleep不释放对象锁，wait放弃对象锁；&lt;/p&gt;
&lt;p&gt;C. sleep暂停线程、但监控状态仍然保持，结束后会自动恢复；&lt;/p&gt;
&lt;p&gt;D. wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。&lt;/p&gt;
&lt;p&gt;答案：D&lt;/p&gt;
&lt;p&gt;        sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。&lt;/p&gt;
&lt;p&gt;        wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10，方法resume()负责恢复哪些线程的执行（ ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A，通过调用stop()方法而停止的线程。&lt;/p&gt;
&lt;p&gt;B，通过调用sleep()方法而停止的线程。&lt;/p&gt;
&lt;p&gt;C，通过调用wait()方法而停止的线程。&lt;/p&gt;
&lt;p&gt;D，通过调用suspend()方法而停止的线程。&lt;/p&gt;
&lt;p&gt;答案：D&lt;/p&gt;
&lt;p&gt;        suspend可以挂起一个线程，就是把这个线程暂停了，它占着资源，但不运行，用resume是恢复挂起的线程，让这个线程继续执行下去。&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 15:37:00 +0000</pubDate>
<dc:creator>小山博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peke/p/7912888.html</dc:identifier>
</item>
<item>
<title>【Android开发学习笔记之一】5大布局方式详解 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Android中常用的5大布局方式有以下几种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线性布局（LinearLayout）：按照垂直或者水平方向布局的组件。&lt;/li&gt;
&lt;li&gt;帧布局（FrameLayout）：组件从屏幕左上方布局组件。&lt;/li&gt;
&lt;li&gt;表格布局（TableLayout）：按照行列方式布局组件。&lt;/li&gt;
&lt;li&gt;相对布局（RelativeLayout）：相对其它组件的布局方式。&lt;/li&gt;
&lt;li&gt; 绝对布局（AbsoluteLayout）：按照绝对坐标来布局组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;线性布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线性布局是Android开发中最常见的一种布局方式，它是按照垂直或者水平方向来布局，通过“android:orientation”属性可以设置线性布局的方向。属性值有垂直（vertical）和水平（horizontal）两种。&lt;/p&gt;
&lt;p&gt;常用的属性：&lt;/p&gt;
&lt;p&gt;android:orientation：可以设置布局的方向&lt;br/&gt;android:gravity:用来控制组件的对齐方式&lt;br/&gt;layout_weight：控制各个组件在布局中的相对大小&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;第一个实例&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128231720894-1832251801.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②核心代码如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;main.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt;       
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EditText 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; android:gravity=&quot;right&quot;表示Button组件向右对齐 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;确定&quot;&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;取消&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt;    
&lt;span&gt;34&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;第二个实例&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①效果图：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128231759612-2035346771.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②核心代码：&lt;/p&gt;
&lt;p&gt;mian.xml&lt;/p&gt;
&lt;div readability=&quot;12.3955535661&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt; android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;      
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;           
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;red&quot;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#aa0000&quot;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;android:gravity=&quot;center_horizontal&quot;水平居中 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
&lt;span&gt;21&lt;/span&gt;          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;layout_weight属性以控制各个控件在布局中的相对大小。layout_weight属性是一个非负整数值。  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;             线性布局会根据该控件layout_weight值与其所处布局中所有控件layout_weight值之和的比值为该控件分配占用的区域。  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            例如，在水平布局的LinearLayout中有两个Button，这两个Button的layout_weight属性值都为1，  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            那么这两个按钮都会被拉伸到整个屏幕宽度的一半。如果layout_weight指为0，控件会按原大小显示，不会被拉伸；  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            对于其余layout_weight属性值大于0的控件，系统将会减去layout_weight属性值为0的控件的宽度或者高度，  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            再用剩余的宽度或高度按相应的比例来分配每一个控件显示的宽度或高度&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Teal&quot;&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#008080&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;           
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;blue&quot;&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#0000aa&quot;&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;           
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;orange&quot;&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFA500&quot;&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;               
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;           
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row one&quot;&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#aa0000&quot;&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;  &lt;span&gt;--&amp;gt;&lt;/span&gt;   
&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row two&quot;&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#DDA0DD&quot;&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;           
&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row three&quot;&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#008080&quot;&lt;/span&gt; 
&lt;span&gt;82&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt;    
&lt;span&gt;86&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row four&quot;&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFA500&quot;&lt;/span&gt; 
&lt;span&gt;90&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;93&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt;       
&lt;span&gt;94&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;95&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. &lt;strong&gt;帧布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;帧布局是从屏幕的左上角（0,0）坐标开始布局，多个组件层叠排列，第一个添加的组件放到最底层，最后添加到框架中的视图显示在最上面。上一层的会覆盖下一层的控件。&lt;/p&gt;
&lt;p&gt;简单的例子&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232137847-1348176364.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9.3359543632439&quot;&gt;
&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt;main.xml&lt;/p&gt;
&lt;div readability=&quot;16.212418300654&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;   
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#00BFFF&quot;&lt;/span&gt;          
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;260dp&quot;&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;260dp&quot;&lt;/span&gt;   
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFC0CB&quot;&lt;/span&gt;          
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;220dp&quot;&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;220dp&quot;&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#0000FF&quot;&lt;/span&gt;          
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FrameLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.&lt;strong&gt;表格布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表格布局是一个ViewGroup以表格显示它的子视图（view）元素，即行和列标识一个视图的位置。&lt;/p&gt;
&lt;p&gt;表格布局常用的属性如下：&lt;/p&gt;
&lt;p&gt;android:collapseColumns：隐藏指定的列&lt;br/&gt;android:shrinkColumns：收缩指定的列以适合屏幕，不会挤出屏幕&lt;br/&gt;android:stretchColumns：尽量把指定的列填充空白部分&lt;br/&gt;android:layout_column:控件放在指定的列&lt;br/&gt;android:layout_span:该控件所跨越的列数&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;简单的例子：&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div readability=&quot;6.3317929759704&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232248722-957320473.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt; main.xml&lt;/p&gt;
&lt;div readability=&quot;11.197936210131&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button3&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button4&quot;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;android:layout_span&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;Button5&quot;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;           
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.&lt;strong&gt;相对布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对布局是按照组件之间的相对位置来布局，比如在某个组件的左边，右边，上面和下面等。&lt;/p&gt;

&lt;p&gt;简单的例子&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232721112-758227716.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt;main.xml&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        android:padding&lt;/span&gt;&lt;span&gt;=&quot;10px&quot;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tev1&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;   
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            android:layout_marginBottom&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;Please Type Here:&quot;&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EditText 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tev1&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/btn1&quot;&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            android:layout_alignParentRight&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;确定&quot;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/btn2&quot;&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            android:layout_toLeftOf&lt;/span&gt;&lt;span&gt;=&quot;@id/btn1&quot;&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            android:layout_marginRight&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;取消&quot;&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. &lt;strong&gt;绝对布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 绝对布局通过指定子组件的确切X,Y坐标来确定组件的位置，在Android2.0 API文档中标明该类已经过期，可以使用FrameLayout或者RelativeLayout来代替。所以这里不再详细介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 28 Nov 2017 15:29:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</dc:identifier>
</item>
<item>
<title>JavaWeb框架SSH_Struts2_(三) - Mairr</title>
<link>http://www.cnblogs.com/Mairr/p/7906086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mairr/p/7906086.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. Struts2的拦截器（使用拦截器实现权限控制）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;拦截器简介&lt;br/&gt;&lt;ul&gt;&lt;li&gt;拦截器概述&lt;/li&gt;
&lt;li&gt;拦截器工作原理&lt;/li&gt;
&lt;li&gt;拦截器的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Struts2的内建拦截器
&lt;ul&gt;&lt;li&gt;内建拦截器的介绍&lt;/li&gt;
&lt;li&gt;内建拦截器的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自定义拦截器
&lt;ul&gt;&lt;li&gt;实现自定义拦截器&lt;/li&gt;
&lt;li&gt;应用案例--&amp;gt;使用拦截器实现权限控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 具体内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 拦截器的概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;拦截器是Struts2的核心组成部分，它可以动态的拦截Action调用的对象，类似与Servlet中的过滤器。Struts2的拦截器是AOP(Aspect-Object-Programming,面向切面编程)的一种实现策略，是可插拔的，需要某一个功能时就“插入”这个功能的拦截器，不需要这个功能就“拔出”拦截器。开发者只需要提供拦截器的实现类，并将其配置在Struts.xml中即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 拦截器的工作原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通常情况下，拦截器都是一代理的方式调用的，它&lt;span&gt;&lt;em&gt;&lt;strong&gt;在一个Action执行前后进行拦截&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;，围绕着Action和Result的执行而执行，其工作方式如下图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171127204404300-1173413336.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Struts2拦截器实现原理与Servlet过滤器实现原理类似，它以链式执行，&lt;strong&gt;&lt;span&gt;&lt;em&gt;对真正要执行的方法（execute（））进行拦截&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;。首先执行Action配置的拦截器，在Action和Result执行之后，拦截器会再次执行（与先前调用的顺序相反），在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action及Result的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.3 拦截器的配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1） 拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;拦截器的配置在struts.xml文件中完成的，它通常以&amp;lt;interceptor&amp;gt;标签开头，以&amp;lt;/interceptor&amp;gt;标签结束。定义拦截器的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorName&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;paramName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;paramValue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法格式中，name属性用来指定拦截器的名称，class属性用于指定拦截器的实现类。在定义时，使用&amp;lt;param&amp;gt;标签传入参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2） 拦截器栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在实际开发中，在Action执行前同时执行多个拦截动作，如用户登陆检查等，这时可以把多个拦截器组成拦截器栈。在使用时，可以将栈内的多个拦截器当成一个整体来引用。当拦截器栈被附加到一个Action上时，在执行Action之前必须先执行拦截器栈中的每一个拦截器。&lt;/p&gt;
&lt;p&gt;　　定义拦截器栈使用&amp;lt;interceptors&amp;gt;和&amp;lt;interceptor-stack&amp;gt;子元素，当配置多个拦截器时，需要使用&amp;lt;interceptor-ref&amp;gt;元素来指定多个拦截器，配置语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorStackName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
              ...
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法中，interceptorStackName值表示配置的拦截器栈的名称，interceptorName值表示拦截器的名称。除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，实例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;拦截器的声明&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义一个拦截器栈mystack,该拦截器栈中包括两个拦截器和一个拦截器栈&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中定义的拦截器栈是myStack，在myStack栈中，除了引用了两个自定义的拦截器interceptor1和interceptor2外，还引用了一个内置拦截器栈defaultStack，这个拦截器是必须要引入的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3） 默认拦截器栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　默认拦截器可以对其指定包中的所有Action起到拦截的作用。一旦为某个包指定了默认拦截器，并且该包中的Action未显式地指定拦截器，则会使用默认拦截器。默认拦截器需要使用&amp;lt;default-interceptor-ref&amp;gt;元素，此元素为&amp;lt;package&amp;gt;元素的子元素。其语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;拦截器(栈)的名称&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法格式中，name属性的值必须是已经存在的拦截器或拦截器栈的名称。下面用该语法格式配置一个默认拦截器，示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;拦截器的声明&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;拦截器栈的名称&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义一个拦截器栈mystack,该拦截器栈中包括两个拦截器和一个拦截器栈&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置该包下的默认拦截器，既可以是拦截器，也可以是拦截器栈 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.itcast.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中，指定了包下的默认拦截器是一个拦截器栈，该拦截器栈将会作用于包下所有的Action。&lt;/p&gt;
&lt;p&gt;　　Notice：一个包下只能定义一个默认拦截器，如果需要多个拦截器作为默认拦截器，则可以将这些拦截器定义为一个拦截器栈，再将这个拦截器栈作为默认拦截器即可。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 Struts2的内建拦截器&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.1 内建拦截器的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;只要自定义的包继承了Struts2的struts-default包，就可以使用默认包中的拦截器，否则需要自己定义拦截器。在Struts-default.xml中每一个拦截器都具有不同的意义（具体拦截器说明---&amp;gt;省略）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2.2 内建拦截器的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面2.1已经介绍过相关配置，此处不再赘述。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 Struts2自定义拦截器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　struts2的内置拦截器可以实现大部分的拦截任务，但是一些与系统逻辑相关的通用功能（如权限的控制、用户登陆控制等），则需要通过自定义拦截器来实现。本节详讲如何自定义拦截器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 实现自定义拦截器&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在程序开发过程中，如果需要开发自己的拦截器类，就需要直接或间接地实现com.opensymphony.xwork2. interceptor. Interceptor接口，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.DefaultActionInvocation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Interceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy();
    String interceptor (DefaultActionInvocation)&lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该接口提供一下三个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;void init（）：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期只有内只被调用一次。可以在该方法中对相关的资源进行必要的初始化;&lt;/li&gt;
&lt;li&gt;void destroy（）：该方法与init（）方法相对应，在拦截器实例被销毁之前，将调用该方法来释放与拦截器相关的资源。它在拦截器的生命周期内也只被调用一次。&lt;/li&gt;
&lt;li&gt;Spring intercept（ActionInvocation invocation）throws Exception：该方法是拦截器的核心方法，用来真正执行拦截工作的代码，实现具体的拦截工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.3.2 应用案例-----使用拦截器实现权限控制&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;通过之前对拦截器学习，可以将自定义拦截器的使用分为一下三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户自定义拦截器类，必须实现Interceptor接口或者继承AbstractInterceptor类;&lt;/li&gt;
&lt;li&gt;需要在struts.xml中，定义自定义拦截器;&lt;/li&gt;
&lt;li&gt;在struts.xml中的Action中使用拦截器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;

&lt;p&gt;（1）在intellij idea中创建Struts2的项目（可参考之前的博客 http://www.cnblogs.com/Mairr/p/7846747.html）&lt;/p&gt;
&lt;p&gt;（2）web.xml配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;&lt;span&gt;=&quot;3.1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;struts2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;struts2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;首页(这一块儿是自己加进来的)&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）在src目录下创建java包，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128213936175-2091634270.png&quot; alt=&quot;&quot; width=&quot;241&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）User.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.domin;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)LoginAction.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.Mairr.domin.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven &amp;lt;User&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String execute() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取ActionContext&lt;/span&gt;
        ActionContext actionContext =&lt;span&gt; ActionContext.getContext();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;Mairr&quot;.equals(user.getUsername()) &amp;amp;&amp;amp; &quot;123&quot;&lt;span&gt;.equals(user.getPassword())) {
            actionContext.getSession().put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;, user);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            actionContext.put(&lt;/span&gt;&quot;msg&quot;, &quot;用户名或者密码不正确&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INPUT;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(6) BookAction.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;book add&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String del(){
        System.out.println(&lt;/span&gt;&quot;book del&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String update(){
        System.out.println(&lt;/span&gt;&quot;book update&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String find(){
        System.out.println(&lt;/span&gt;&quot;book find&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(7)PrivilegeInterceptor.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.interceptor;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.Action;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionInvocation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.interceptor.AbstractInterceptor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PrivilegeInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractInterceptor{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String intercept(ActionInvocation invocation)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到ActionContext&lt;/span&gt;
        ActionContext actionContext =&lt;span&gt; invocation.getInvocationContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取user对象&lt;/span&gt;
        Object user = actionContext.getSession().get(&quot;user&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.invoke();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            actionContext.put(&lt;/span&gt;&quot;msg&quot;,&quot;您还未登录，请先登陆&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Action.LOGIN;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户如果不存在，返回login直&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(8) main.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:18
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book del&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book add&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book update&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book find&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(9) login.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:17
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登陆&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        ${requestScope.msg}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;login.action&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;密码：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt; colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;登陆&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(10)success.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:42
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;成功页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
用户${user.username}操作成功
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(11) struts.xml配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts2&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;声明拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;privilege&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.interceptor.PrivilegeInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;privilege&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;用户登陆操作&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;关于book操作&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;book_*&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.action.BookAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;{1}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;在action中使用自定义拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;完成上述程序之后，发布程序，登录本机http端口，查看拦截器实现功能;（http://localhost:8080/login.jsp）&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录界面如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128221525706-1283913007.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---------&amp;gt;(登陆失败)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128221737347-1513695899.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登陆成功（用户名：Mairr   密码：123 ）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222037300-495010381.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-----------&amp;gt;(登陆成功，页面跳转到操作界面)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222234206-1143041419.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;

&lt;p&gt;--------&amp;gt;(选择操作)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222515894-1575007049.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;上面的案例中，创建了一个方法过滤拦截器PrivilegeInterceptor，然后在Struts.xml中配置了该拦截器，如果用户没有登陆，则无法对页面进行相应的操作，只有登陆后才有权操作页面的相应功能。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 14:31:00 +0000</pubDate>
<dc:creator>Mairr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mairr/p/7906086.html</dc:identifier>
</item>
<item>
<title>Kafka设计解析（八）- Exactly Once语义与事务机制原理 - 郭俊Jason</title>
<link>http://www.cnblogs.com/jasongj/p/7912348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jasongj/p/7912348.html</guid>
<description>&lt;blockquote readability=&quot;3.3650793650794&quot;&gt;
&lt;p&gt;原创文章，首发自&lt;a href=&quot;http://www.jasongj.com/&quot;&gt;&lt;strong&gt;作者个人博客&lt;/strong&gt;&lt;/a&gt;，转载请务必将下面这段话置于文章开头处。&lt;br/&gt;本文转发自&lt;a href=&quot;http://www.jasongj.com/&quot;&gt;&lt;strong&gt;技术世界&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.jasongj.com/kafka/transaction/&quot;&gt;原文链接&lt;/a&gt;　&lt;a href=&quot;http://www.jasongj.com/kafka/transaction/&quot; class=&quot;uri&quot;&gt;http://www.jasongj.com/kafka/transaction/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文所有Kafka原理性的描述除特殊说明外均基于Kafka 1.0.0版本。&lt;/p&gt;

&lt;p&gt;Kafka事务机制的实现主要是为了支持&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Exactly Once&lt;/code&gt;即正好一次语义&lt;/li&gt;
&lt;li&gt;操作的原子性&lt;/li&gt;
&lt;li&gt;有状态操作的可恢复性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;exactly-once&quot;&gt;2.1 &lt;code&gt;Exactly Once&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;《&lt;a href=&quot;http://www.cnblogs.com/2015/03/10/KafkaColumn1/#Kafka-delivery-guarantee&quot;&gt;Kafka背景及架构介绍&lt;/a&gt;》一文中有说明Kafka在0.11.0.0之前的版本中只支持&lt;code&gt;At Least Once&lt;/code&gt;和&lt;code&gt;At Most Once&lt;/code&gt;语义，尚不支持&lt;code&gt;Exactly Once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;但是在很多要求严格的场景下，如使用Kafka处理交易数据，&lt;code&gt;Exactly Once&lt;/code&gt;语义是必须的。我们可以通过让下游系统具有幂等性来配合Kafka的&lt;code&gt;At Least Once&lt;/code&gt;语义来间接实现&lt;code&gt;Exactly Once&lt;/code&gt;。但是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该方案要求下游系统支持幂等操作，限制了Kafka的适用场景&lt;/li&gt;
&lt;li&gt;实现门槛相对较高，需要用户对Kafka的工作机制非常了解&lt;/li&gt;
&lt;li&gt;对于Kafka Stream而言，Kafka本身即是自己的下游系统，但Kafka在0.11.0.0版本之前不具有幂等发送能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，Kafka本身对&lt;code&gt;Exactly Once&lt;/code&gt;语义的支持就非常必要。&lt;/p&gt;
&lt;h2 id=&quot;操作原子性&quot;&gt;2.2 操作原子性&lt;/h2&gt;
&lt;p&gt;操作的原子性是指，多个操作要么全部成功要么全部失败，不存在部分成功部分失败的可能。&lt;/p&gt;
&lt;p&gt;实现原子性操作的意义在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作结果更可控，有助于提升数据一致性&lt;/li&gt;
&lt;li&gt;便于故障恢复。因为操作是原子的，从故障中恢复时只需要重试该操作（如果原操作失败）或者直接跳过该操作（如果原操作成功），而不需要记录中间状态，更不需要针对中间状态作特殊处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;幂等性发送&quot;&gt;3.1 幂等性发送&lt;/h2&gt;
&lt;p&gt;上文提到，实现&lt;code&gt;Exactly Once&lt;/code&gt;的一种方法是让下游系统具有幂等处理特性，而在Kafka Stream中，Kafka Producer本身就是“下游”系统，因此如果能让Producer具有幂等处理特性，那就可以让Kafka Stream在一定程度上支持&lt;code&gt;Exactly once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;为了实现Producer的幂等语义，Kafka引入了&lt;code&gt;Producer ID&lt;/code&gt;（即&lt;code&gt;PID&lt;/code&gt;）和&lt;code&gt;Sequence Number&lt;/code&gt;。每个新的Producer在初始化的时候会被分配一个唯一的PID，该PID对用户完全透明而不会暴露给用户。&lt;/p&gt;
&lt;p&gt;对于每个PID，该Producer发送数据的每个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;都对应一个从0开始单调递增的&lt;code&gt;Sequence Number&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似地，Broker端也会为每个&lt;code&gt;&amp;lt;PID, Topic, Partition&amp;gt;&lt;/code&gt;维护一个序号，并且每次Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号（即最后一次Commit的消息的序号）大一，则Broker会接受它，否则将其丢弃：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果消息序号比Broker维护的序号大一以上，说明中间有数据尚未写入，也即乱序，此时Broker拒绝该消息，Producer抛出&lt;code&gt;InvalidSequenceNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出&lt;code&gt;DuplicateSequenceNumber&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述设计解决了0.11.0.0之前版本中的两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Broker保存消息后，发送ACK前宕机，Producer认为消息未发送成功并重试，造成数据重复&lt;/li&gt;
&lt;li&gt;前一条消息发送失败，后一条消息发送成功，前一条消息重试后成功，造成数据乱序&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事务性保证&quot;&gt;3.2 事务性保证&lt;/h2&gt;
&lt;p&gt;上述幂等设计只能保证单个Producer对于同一个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的&lt;code&gt;Exactly Once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;另外，它并不能保证写操作的原子性——即多个写操作，要么全部被Commit要么全部不被Commit。&lt;/p&gt;
&lt;p&gt;更不能保证多个读写操作的的原子性。尤其对于Kafka Stream应用而言，典型的操作即是从某个Topic消费数据，经过一系列转换后写回另一个Topic，保证从源Topic的读取与向目标Topic的写入的原子性有助于从故障中恢复。&lt;/p&gt;
&lt;p&gt;事务保证可使得应用程序将生产数据和消费数据当作一个原子单元来处理，要么全部成功，要么全部失败，即使该生产或消费跨多个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，有状态的应用也可以保证重启后从断点处继续处理，也即事务恢复。&lt;/p&gt;
&lt;p&gt;为了实现这种效果，应用程序必须提供一个稳定的（重启后不变）唯一的ID，也即&lt;code&gt;Transaction ID&lt;/code&gt;。&lt;code&gt;Transactin ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;可能一一对应。区别在于&lt;code&gt;Transaction ID&lt;/code&gt;由用户提供，而&lt;code&gt;PID&lt;/code&gt;是内部的实现对用户透明。&lt;/p&gt;
&lt;p&gt;另外，为了保证新的Producer启动后，旧的具有相同&lt;code&gt;Transaction ID&lt;/code&gt;的Producer即失效，每次Producer通过&lt;code&gt;Transaction ID&lt;/code&gt;拿到PID的同时，还会获取一个单调递增的epoch。由于旧的Producer的epoch比新Producer的epoch小，Kafka可以很容易识别出该Producer是老的Producer并拒绝其请求。&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;Transaction ID&lt;/code&gt;后，Kafka可保证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨Session的数据幂等发送。当具有相同&lt;code&gt;Transaction ID&lt;/code&gt;的新的Producer实例被创建且工作时，旧的且拥有相同&lt;code&gt;Transaction ID&lt;/code&gt;的Producer将不再工作。&lt;/li&gt;
&lt;li&gt;跨Session的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么Commit要么Abort，使得新实例从一个正常状态开始工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，上述的事务保证是从Producer的角度去考虑的。从Consumer的角度来看，该保证会相对弱一些。尤其是不能保证所有被某事务Commit过的所有消息都被一起消费，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于压缩的Topic而言，同一事务的某些消息可能被其它版本覆盖&lt;/li&gt;
&lt;li&gt;事务包含的消息可能分布在多个Segment中（即使在同一个Partition内），当老的Segment被删除时，该事务的部分数据可能会丢失&lt;/li&gt;
&lt;li&gt;Consumer在一个事务内可能通过seek方法访问任意Offset的消息，从而可能丢失部分消息&lt;/li&gt;
&lt;li&gt;Consumer可能并不需要消费某一事务内的所有Partition，因此它将永远不会读取组成该事务的所有消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;事务性消息传递&quot;&gt;4.1 事务性消息传递&lt;/h2&gt;
&lt;p&gt;这一节所说的事务主要指原子性，也即Producer将多条消息作为一个事务批量发送，要么全部成功要么全部失败。&lt;/p&gt;
&lt;p&gt;为了实现这一点，Kafka 0.11.0.0引入了一个服务器端的模块，名为&lt;code&gt;Transaction Coordinator&lt;/code&gt;，用于管理Producer发送的消息的事务性。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;Transaction Coordinator&lt;/code&gt;维护&lt;code&gt;Transaction Log&lt;/code&gt;，该log存于一个内部的Topic内。由于Topic数据具有持久性，因此事务的状态也具有持久性。&lt;/p&gt;
&lt;p&gt;Producer并不直接读写&lt;code&gt;Transaction Log&lt;/code&gt;，它与&lt;code&gt;Transaction Coordinator&lt;/code&gt;通信，然后由&lt;code&gt;Transaction Coordinator&lt;/code&gt;将该事务的状态插入相应的&lt;code&gt;Transaction Log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Log&lt;/code&gt;的设计与&lt;code&gt;Offset Log&lt;/code&gt;用于保存Consumer的Offset类似。&lt;/p&gt;
&lt;h2 id=&quot;事务中offset的提交&quot;&gt;4.2 事务中Offset的提交&lt;/h2&gt;
&lt;p&gt;许多基于Kafka的应用，尤其是Kafka Stream应用中同时包含Consumer和Producer，前者负责从Kafka中获取消息，后者负责将处理完的数据写回Kafka的其它Topic中。&lt;/p&gt;
&lt;p&gt;为了实现该场景下的事务的原子性，Kafka需要保证对Consumer Offset的Commit与Producer对发送消息的Commit包含在同一个事务中。否则，如果在二者Commit中间发生异常，根据二者Commit的顺序可能会造成数据丢失和数据重复：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果先Commit Producer发送数据的事务再Commit Consumer的Offset，即&lt;code&gt;At Least Once&lt;/code&gt;语义，可能造成数据重复。&lt;/li&gt;
&lt;li&gt;如果先Commit Consumer的Offset，再Commit Producer数据发送事务，即&lt;code&gt;At Most Once&lt;/code&gt;语义，可能造成数据丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用于事务特性的控制型消息&quot;&gt;4.3 用于事务特性的控制型消息&lt;/h2&gt;
&lt;p&gt;为了区分写入Partition的消息被Commit还是Abort，Kafka引入了一种特殊类型的消息，即&lt;code&gt;Control Message&lt;/code&gt;。该类消息的Value内不包含任何应用相关的数据，并且不会暴露给应用程序。它只用于Broker与Client间的内部通信。&lt;/p&gt;
&lt;p&gt;对于Producer端事务，Kafka以Control Message的形式引入一系列的&lt;code&gt;Transaction Marker&lt;/code&gt;。Consumer即可通过该标记判定对应的消息被Commit了还是Abort了，然后结合该Consumer配置的隔离级别决定是否应该将该消息返回给应用程序。&lt;/p&gt;
&lt;h2 id=&quot;事务处理样例代码&quot;&gt;4.4 事务处理样例代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Producer&amp;lt;String, String&amp;gt; producer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;(props);
    
&lt;span class=&quot;co&quot;&gt;// 初始化事务，包括结束该Transaction ID对应的未完成的事务（如果有）&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 保证新的事务在一个正确的状态下启动&lt;/span&gt;
producer.&lt;span class=&quot;fu&quot;&gt;initTransactions&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;// 开始事务&lt;/span&gt;
producer.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;// 消费数据&lt;/span&gt;
ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);

&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;// 发送数据&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&lt;span class=&quot;st&quot;&gt;&quot;Topic&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Key&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Value&quot;&lt;/span&gt;));
    
    &lt;span class=&quot;co&quot;&gt;// 发送消费数据的Offset，将上述数据消费与数据发送纳入同一个Transaction内&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;sendOffsetsToTransaction&lt;/span&gt;(offsets, &lt;span class=&quot;st&quot;&gt;&quot;group1&quot;&lt;/span&gt;);

    &lt;span class=&quot;co&quot;&gt;// 数据发送及Offset发送均成功的情况下，提交事务&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;commitTransaction&lt;/span&gt;();
} &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) {
    &lt;span class=&quot;co&quot;&gt;// 数据发送或者Offset发送出现异常时，终止事务&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;abortTransaction&lt;/span&gt;();
} &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 关闭Producer和Consumer&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    consumer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;完整事务过程&quot;&gt;4.5 完整事务过程&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;http://www.jasongj.com/img/kafka/KafkaColumn8/KafkaTransaction.png&quot; alt=&quot;Kafka Transaction&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;找到transaction-coordinator&quot;&gt;4.5.1 找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;Transaction Coordinator&lt;/code&gt;是分配PID和管理事务的核心，因此Producer要做的第一件事情就是通过向任意一个Broker发送&lt;code&gt;FindCoordinator&lt;/code&gt;请求找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;的位置。&lt;/p&gt;
&lt;p&gt;注意：只有应用程序为Producer配置了&lt;code&gt;Transaction ID&lt;/code&gt;时才可使用事务特性，也才需要这一步。另外，由于事务性要求Producer开启幂等特性，因此通过将&lt;code&gt;transactional.id&lt;/code&gt;设置为非空从而开启事务特性的同时也需要通过将&lt;code&gt;enable.idempotence&lt;/code&gt;设置为true来开启幂等特性。&lt;/p&gt;
&lt;h3 id=&quot;获取pid&quot;&gt;4.5.2 获取PID&lt;/h3&gt;
&lt;p&gt;找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;后，具有幂等特性的Producer必须发起&lt;code&gt;InitPidRequest&lt;/code&gt;请求以获取PID。&lt;/p&gt;
&lt;p&gt;注意：只要开启了幂等特性即必须执行该操作，而无须考虑该Producer是否开启了事务特性。&lt;/p&gt;
&lt;p&gt;*** 如果事务特性被开启 ***&lt;br/&gt;&lt;code&gt;InitPidRequest&lt;/code&gt;会发送给&lt;code&gt;Transaction Coordinator&lt;/code&gt;。如果&lt;code&gt;Transaction Coordinator&lt;/code&gt;是第一次收到包含有该&lt;code&gt;Transaction ID&lt;/code&gt;的InitPidRequest请求，它将会把该&lt;code&gt;&amp;lt;TransactionID, PID&amp;gt;&lt;/code&gt;存入&lt;code&gt;Transaction Log&lt;/code&gt;，如上图中步骤2.1所示。这样可保证该对应关系被持久化，从而保证即使&lt;code&gt;Transaction Coordinator&lt;/code&gt;宕机该对应关系也不会丢失。&lt;/p&gt;
&lt;p&gt;除了返回PID外，&lt;code&gt;InitPidRequest&lt;/code&gt;还会执行如下任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加该PID对应的epoch。具有相同PID但epoch小于该epoch的其它Producer（如果有）新开启的事务将被拒绝。&lt;/li&gt;
&lt;li&gt;恢复（Commit或Abort）之前的Producer未完成的事务（如果有）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;code&gt;InitPidRequest&lt;/code&gt;的处理过程是同步阻塞的。一旦该调用正确返回，Producer即可开始新的事务。&lt;/p&gt;
&lt;p&gt;另外，如果事务特性未开启，&lt;code&gt;InitPidRequest&lt;/code&gt;可发送至任意Broker，并且会得到一个全新的唯一的PID。该Producer将只能使用幂等特性以及单一Session内的事务特性，而不能使用跨Session的事务特性。&lt;/p&gt;
&lt;h3 id=&quot;开启事务&quot;&gt;4.5.3 开启事务&lt;/h3&gt;
&lt;p&gt;Kafka从0.11.0.0版本开始，提供&lt;code&gt;beginTransaction()&lt;/code&gt;方法用于开启一个事务。调用该方法后，Producer本地会记录已经开启了事务，但&lt;code&gt;Transaction Coordinator&lt;/code&gt;只有在Producer发送第一条消息后才认为事务已经开启。&lt;/p&gt;
&lt;h3 id=&quot;consume-transform-produce&quot;&gt;4.5.4 Consume-Transform-Produce&lt;/h3&gt;
&lt;p&gt;这一阶段，包含了整个事务的数据处理过程，并且包含了多种请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AddPartitionsToTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;一个Producer可能会给多个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送数据，给一个新的&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送数据前，它需要先向&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送&lt;code&gt;AddPartitionsToTxnRequest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;会将该&lt;code&gt;&amp;lt;Transaction, Topic, Partition&amp;gt;&lt;/code&gt;存于&lt;code&gt;Transaction Log&lt;/code&gt;内，并将其状态置为&lt;code&gt;BEGIN&lt;/code&gt;，如上图中步骤4.1所示。有了该信息后，我们才可以在后续步骤中为每个&lt;code&gt;Topic, Partition&amp;gt;&lt;/code&gt;设置COMMIT或者ABORT标记（如上图中步骤5.2所示）。&lt;/p&gt;
&lt;p&gt;另外，如果该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;为该事务中第一个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;，&lt;code&gt;Transaction Coordinator&lt;/code&gt;还会启动对该事务的计时（每个事务都有自己的超时时间）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ProduceRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;Producer通过一个或多个&lt;code&gt;ProduceRequest&lt;/code&gt;发送一系列消息。除了应用数据外，该请求还包含了PID，epoch，和&lt;code&gt;Sequence Number&lt;/code&gt;。该过程如上图中步骤4.2所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AddOffsetsToTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;为了提供事务性，Producer新增了&lt;code&gt;sendOffsetsToTransaction&lt;/code&gt;方法，该方法将多组消息的发送和消费放入同一批处理内。&lt;/p&gt;
&lt;p&gt;该方法先判断在当前事务中该方法是否已经被调用并传入了相同的Group ID。若是，直接跳到下一步；若不是，则向&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送&lt;code&gt;AddOffsetsToTxnRequests&lt;/code&gt;请求，&lt;code&gt;Transaction Coordinator&lt;/code&gt;将对应的所有&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;存于&lt;code&gt;Transaction Log&lt;/code&gt;中，并将其状态记为&lt;code&gt;BEGIN&lt;/code&gt;，如上图中步骤4.3所示。该方法会阻塞直到收到响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TxnOffsetCommitRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;作为&lt;code&gt;sendOffsetsToTransaction&lt;/code&gt;方法的一部分，在处理完&lt;code&gt;AddOffsetsToTxnRequest&lt;/code&gt;后，Producer也会发送&lt;code&gt;TxnOffsetCommit&lt;/code&gt;请求给&lt;code&gt;Consumer Coordinator&lt;/code&gt;从而将本事务包含的与读操作相关的各&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Offset持久化到内部的&lt;code&gt;__consumer_offsets&lt;/code&gt;中，如上图步骤4.4所示。&lt;/p&gt;
&lt;p&gt;在此过程中，&lt;code&gt;Consumer Coordinator&lt;/code&gt;会通过PID和对应的epoch来验证是否应该允许该Producer的该请求。&lt;/p&gt;
&lt;p&gt;这里需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写入&lt;code&gt;__consumer_offsets&lt;/code&gt;的Offset信息在当前事务Commit前对外是不可见的。也即在当前事务被Commit前，可认为该Offset尚未Commit，也即对应的消息尚未被完成处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consumer Coordinator&lt;/code&gt;并不会立即更新缓存中相应&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Offset，因为此时这些更新操作尚未被COMMIT或ABORT。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;commit或abort事务&quot;&gt;4.5.5 Commit或Abort事务&lt;/h3&gt;
&lt;p&gt;一旦上述数据写入操作完成，应用程序必须调用&lt;code&gt;KafkaProducer&lt;/code&gt;的&lt;code&gt;commitTransaction&lt;/code&gt;方法或者&lt;code&gt;abortTransaction&lt;/code&gt;方法以结束当前事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;EndTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;commitTransaction&lt;/code&gt;方法使得Producer写入的数据对下游Consumer可见。&lt;code&gt;abortTransaction&lt;/code&gt;方法通过&lt;code&gt;Transaction Marker&lt;/code&gt;将Producer写入的数据标记为&lt;code&gt;Aborted&lt;/code&gt;状态。下游的Consumer如果将&lt;code&gt;isolation.level&lt;/code&gt;设置为&lt;code&gt;READ_COMMITTED&lt;/code&gt;，则它读到被Abort的消息后直接将其丢弃而不会返回给客户程序，也即被Abort的消息对应用程序不可见。&lt;/p&gt;
&lt;p&gt;无论是Commit还是Abort，Producer都会发送&lt;code&gt;EndTxnRequest&lt;/code&gt;请求给&lt;code&gt;Transaction Coordinator&lt;/code&gt;，并通过标志位标识是应该Commit还是Abort。&lt;/p&gt;
&lt;p&gt;收到该请求后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会进行如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;消息写入&lt;code&gt;Transaction Log&lt;/code&gt;，如上图中步骤5.1所示&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;WriteTxnMarker&lt;/code&gt;请求以&lt;code&gt;Transaction Marker&lt;/code&gt;的形式将&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;信息写入用户数据日志以及&lt;code&gt;Offset Log&lt;/code&gt;中，如上图中步骤5.2所示&lt;/li&gt;
&lt;li&gt;最后将&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;信息写入&lt;code&gt;Transaction Log&lt;/code&gt;中，如上图中步骤5.3所示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;补充说明：对于&lt;code&gt;commitTransaction&lt;/code&gt;方法，它会在发送&lt;code&gt;EndTxnRequest&lt;/code&gt;之前先调用flush方法以确保所有发送出去的数据都得到相应的ACK。对于&lt;code&gt;abortTransaction&lt;/code&gt;方法，在发送&lt;code&gt;EndTxnRequest&lt;/code&gt;之前直接将当前Buffer中的事务性消息（如果有）全部丢弃，但必须等待所有被发送但尚未收到ACK的消息发送完成。&lt;/p&gt;
&lt;p&gt;上述第二步是实现将一组读操作与写操作作为一个事务处理的关键。因为Producer写入的数据Topic以及记录Comsumer Offset的Topic会被写入相同的&lt;code&gt;Transactin Marker&lt;/code&gt;，所以这一组读操作与写操作要么全部COMMIT要么全部ABORT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;WriteTxnMarkerRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;上面提到的&lt;code&gt;WriteTxnMarkerRequest&lt;/code&gt;由&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送给当前事务涉及到的每个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Leader。收到该请求后，对应的Leader会将对应的&lt;code&gt;COMMIT(PID)&lt;/code&gt;或者&lt;code&gt;ABORT(PID)&lt;/code&gt;控制信息写入日志，如上图中步骤5.2所示。&lt;/p&gt;
&lt;p&gt;该控制消息向Broker以及Consumer表明对应PID的消息被Commit了还是被Abort了。&lt;/p&gt;
&lt;p&gt;这里要注意，如果事务也涉及到&lt;code&gt;__consumer_offsets&lt;/code&gt;，即该事务中有消费数据的操作且将该消费的Offset存于&lt;code&gt;__consumer_offsets&lt;/code&gt;中，&lt;code&gt;Transaction Coordinator&lt;/code&gt;也需要向该内部Topic的各Partition的Leader发送&lt;code&gt;WriteTxnMarkerRequest&lt;/code&gt;从而写入&lt;code&gt;COMMIT(PID)&lt;/code&gt;或&lt;code&gt;COMMIT(PID)&lt;/code&gt;控制信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;写入最终的&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;消息&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;写完所有的&lt;code&gt;Transaction Marker&lt;/code&gt;后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会将最终的&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;消息写入&lt;code&gt;Transaction Log&lt;/code&gt;中以标明该事务结束，如上图中步骤5.3所示。&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;Transaction Log&lt;/code&gt;中所有关于该事务的消息全部可以移除。当然，由于Kafka内数据是Append Only的，不可直接更新和删除，这里说的移除只是将其标记为null从而在Log Compact时不再保留。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;的写入并不需要得到所有Rreplica的ACK，因为如果该消息丢失，可以根据事务协议重发。&lt;/p&gt;
&lt;p&gt;补充说明，如果参与该事务的某些&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;在被写入&lt;code&gt;Transaction Marker&lt;/code&gt;前不可用，它对&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer不可见，但不影响其它可用&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的COMMIT或ABORT。在该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;恢复可用后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会重新根据&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;向该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送&lt;code&gt;Transaction Marker&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4.6 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PID&lt;/code&gt;与&lt;code&gt;Sequence Number&lt;/code&gt;的引入实现了写操作的幂等性&lt;/li&gt;
&lt;li&gt;写操作的幂等性结合&lt;code&gt;At Least Once&lt;/code&gt;语义实现了单一Session内的&lt;code&gt;Exactly Once&lt;/code&gt;语义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transaction Marker&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;提供了识别消息是否应该被读取的能力，从而实现了事务的隔离性&lt;/li&gt;
&lt;li&gt;Offset的更新标记了消息是否被读取，从而将对读操作的事务处理转换成了对写（Offset）操作的事务处理&lt;/li&gt;
&lt;li&gt;Kafka事务的本质是，将一组写操作（如果有）对应的消息与一组读操作（如果有）对应的Offset的更新进行同样的标记（即&lt;code&gt;Transaction Marker&lt;/code&gt;）来实现事务中涉及的所有读写操作同时对外可见或同时对外不可见&lt;/li&gt;
&lt;li&gt;Kafka只提供对Kafka本身的读写操作的事务性，不提供包含外部系统的事务性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;exception处理&quot;&gt;5.1 Exception处理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidProducerEpoch&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;这是一种Fatal Error，它说明当前Producer是一个过期的实例，有&lt;code&gt;Transaction ID&lt;/code&gt;相同但epoch更新的Producer实例被创建并使用。此时Producer会停止并抛出Exception。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidPidMapping&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;没有与该&lt;code&gt;Transaction ID&lt;/code&gt;对应的PID。此时Producer会通过包含有&lt;code&gt;Transaction ID&lt;/code&gt;的&lt;code&gt;InitPidRequest&lt;/code&gt;请求创建一个新的PID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NotCorrdinatorForGTransactionalId&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;该&lt;code&gt;Transaction Coordinator&lt;/code&gt;不负责该当前事务。Producer会通过&lt;code&gt;FindCoordinatorRequest&lt;/code&gt;请求重新寻找对应的&lt;code&gt;Transaction Coordinator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;违反了事务协议。正确的Client实现不应该出现这种Exception。如果该异常发生了，用户需要检查自己的客户端实现是否有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;CoordinatorNotAvailable&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;仍在初始化中。Producer只需要重试即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;DuplicateSequenceNumber&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;发送的消息的序号低于Broker预期。该异常说明该消息已经被成功处理过，Producer可以直接忽略该异常并处理下一条消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidSequenceNumber&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;这是一个Fatal Error，它说明发送的消息中的序号大于Broker预期。此时有两种可能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据乱序。比如前面的消息发送失败后重试期间，新的消息被接收。正常情况下不应该出现该问题，因为当幂等发送启用时，&lt;code&gt;max.inflight.requests.per.connection&lt;/code&gt;被强制设置为1，而&lt;code&gt;acks&lt;/code&gt;被强制设置为all。故前面消息重试期间，后续消息不会被发送，也即不会发生乱序。并且只有ISR中所有Replica都ACK，Producer才会认为消息已经被发送，也即不存在Broker端数据丢失问题。&lt;/li&gt;
&lt;li&gt;服务器由于日志被Truncate而造成数据丢失。此时应该停止Producer并将此Fatal Error报告给用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidTransactionTimeout&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;InitPidRequest&lt;/code&gt;调用出现的Fatal Error。它表明Producer传入的timeout时间不在可接受范围内，应该停止Producer并报告给用户。&lt;/p&gt;
&lt;h2 id=&quot;处理transaction-coordinator失败&quot;&gt;5.2 处理&lt;code&gt;Transaction Coordinator&lt;/code&gt;失败&lt;/h2&gt;
&lt;h3 id=&quot;写prepare_commitprepare_abort前失败&quot;&gt;5.2.1 写&lt;code&gt;PREPARE_COMMIT/PREPARE_ABORT&lt;/code&gt;前失败&lt;/h3&gt;
&lt;p&gt;Producer通过&lt;code&gt;FindCoordinatorRequest&lt;/code&gt;找到新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;，并通过&lt;code&gt;EndTxnRequest&lt;/code&gt;请求发起&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;流程，新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;继续处理&lt;code&gt;EndTxnRequest&lt;/code&gt;请求——写&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，写&lt;code&gt;Transaction Marker&lt;/code&gt;，写&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;写完prepare_commitprepare_abort后失败&quot;&gt;5.2.2 写完&lt;code&gt;PREPARE_COMMIT/PREPARE_ABORT&lt;/code&gt;后失败&lt;/h3&gt;
&lt;p&gt;此时旧的&lt;code&gt;Transaction Coordinator&lt;/code&gt;可能已经成功写入部分&lt;code&gt;Transaction Marker&lt;/code&gt;。新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;会重复这些操作，所以部分Partition中可能会存在重复的&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;，但只要该Producer在此期间没有发起新的事务，这些重复的&lt;code&gt;Transaction Marker&lt;/code&gt;就不是问题。&lt;/p&gt;
&lt;h3 id=&quot;写完complete_commitabort后失败&quot;&gt;5.2.3 写完&lt;code&gt;COMPLETE_COMMIT/ABORT&lt;/code&gt;后失败&lt;/h3&gt;
&lt;p&gt;旧的&lt;code&gt;Transaction Coordinator&lt;/code&gt;可能已经写完了&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;但在返回&lt;code&gt;EndTxnRequest&lt;/code&gt;之前失败。该场景下，新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;会直接给Producer返回成功。&lt;/p&gt;
&lt;h2 id=&quot;事务过期机制&quot;&gt;5.3 事务过期机制&lt;/h2&gt;
&lt;h3 id=&quot;事务超时&quot;&gt;5.3.1 事务超时&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;transaction.timeout.ms&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;终止过期事务&quot;&gt;5.3.2 终止过期事务&lt;/h3&gt;
&lt;p&gt;当Producer失败时，&lt;code&gt;Transaction Coordinator&lt;/code&gt;必须能够主动的让某些进行中的事务过期。否则没有Producer的参与，&lt;code&gt;Transaction Coordinator&lt;/code&gt;无法判断这些事务应该如何处理，这会造成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这种进行中事务太多，会造成&lt;code&gt;Transaction Coordinator&lt;/code&gt;需要维护大量的事务状态，大量占用内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transaction Log&lt;/code&gt;内也会存在大量数据，造成新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;启动缓慢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer需要缓存大量的消息，造成不必要的内存浪费甚至是OOM&lt;/li&gt;
&lt;li&gt;如果多个&lt;code&gt;Transaction ID&lt;/code&gt;不同的Producer交叉写同一个Partition，当一个Producer的事务状态不更新时，&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer为了保证顺序消费而被阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了避免上述问题，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会周期性遍历内存中的事务状态Map，并执行如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果状态是&lt;code&gt;BEGIN&lt;/code&gt;并且其最后更新时间与当前时间差大于&lt;code&gt;transaction.remove.expired.transaction.cleanup.interval.ms&lt;/code&gt;（默认值为1小时），则主动将其终止：1）未避免原Producer临时恢复与当前终止流程冲突，增加该Producer对应的PID的epoch，并确保将该更新的信息写入&lt;code&gt;Transaction Log&lt;/code&gt;；2）以更新后的epoch回滚事务，从而使得该事务相关的所有Broker都更新其缓存的该PID的epoch从而拒绝旧Producer的写操作&lt;/li&gt;
&lt;li&gt;如果状态是&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;，完成后续的COMMIT流程————向各&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;写入&lt;code&gt;Transaction Marker&lt;/code&gt;，在&lt;code&gt;Transaction Log&lt;/code&gt;内写入&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果状态是&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，完成后续ABORT流程&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;终止transaction-id&quot;&gt;5.3 终止&lt;code&gt;Transaction ID&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;某&lt;code&gt;Transaction ID&lt;/code&gt;的Producer可能很长时间不再发送数据，&lt;code&gt;Transaction Coordinator&lt;/code&gt;没必要再保存该&lt;code&gt;Transaction ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;等的映射，否则可能会造成大量的资源浪费。因此需要有一个机制探测不再活跃的&lt;code&gt;Transaction ID&lt;/code&gt;并将其信息删除。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;会周期性遍历内存中的&lt;code&gt;Transaction ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;映射，如果某&lt;code&gt;Transaction ID&lt;/code&gt;没有对应的正在进行中的事务并且它对应的最后一个事务的结束时间与当前时间差大于&lt;code&gt;transactional.id.expiration.ms&lt;/code&gt;（默认值是7天），则将其从内存中删除并在&lt;code&gt;Transaction Log&lt;/code&gt;中将其对应的日志的值设置为null从而使得Log Compact可将其记录删除。&lt;/p&gt;

&lt;h2 id=&quot;postgresql-mvcc&quot;&gt;6.1 PostgreSQL MVCC&lt;/h2&gt;
&lt;p&gt;Kafka的事务机制与《&lt;a href=&quot;http://www.cnblogs.com/sql/mvcc/&quot;&gt;MVCC PostgreSQL实现事务和多版本并发控制的精华&lt;/a&gt;》一文中介绍的PostgreSQL通过MVCC实现事务的机制非常类似，对于事务的回滚，并不需要删除已写入的数据，都是将写入数据的事务标记为Rollback/Abort从而在读数据时过滤该数据。&lt;/p&gt;
&lt;h2 id=&quot;两阶段提交&quot;&gt;6.2 两阶段提交&lt;/h2&gt;
&lt;p&gt;Kafka的事务机制与《&lt;a href=&quot;http://www.cnblogs.com/big_data/two_phase_commit/#两阶段提交原理&quot;&gt;分布式事务（一）两阶段提交及JTA&lt;/a&gt;》一文中所介绍的两阶段提交机制看似相似，都分PREPARE阶段和最终COMMIT阶段，但又有很大不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka事务机制中，PREPARE时即要指明是&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;还是&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，并且只须在&lt;code&gt;Transaction Log&lt;/code&gt;中标记即可，无须其它组件参与。而两阶段提交的PREPARE需要发送给所有的分布式事务参与方，并且事务参与方需要尽可能准备好，并根据准备情况返回&lt;code&gt;Prepared&lt;/code&gt;或&lt;code&gt;Non-Prepared&lt;/code&gt;状态给事务管理器。&lt;/li&gt;
&lt;li&gt;Kafka事务中，一但发起&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，则确定该事务最终的结果应该是被&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;。而分布式事务中，PREPARE后由各事务参与方返回状态，只有所有参与方均返回&lt;code&gt;Prepared&lt;/code&gt;状态才会真正执行COMMIT，否则执行ROLLBACK&lt;/li&gt;
&lt;li&gt;Kafka事务机制中，某几个Partition在COMMIT或ABORT过程中变为不可用，只影响该Partition不影响其它Partition。两阶段提交中，若唯一收到COMMIT命令参与者Crash，其它事务参与方无法判断事务状态从而使得整个事务阻塞&lt;/li&gt;
&lt;li&gt;Kafka事务机制引入事务超时机制，有效避免了挂起的事务影响其它事务的问题&lt;/li&gt;
&lt;li&gt;Kafka事务机制中存在多个&lt;code&gt;Transaction Coordinator&lt;/code&gt;实例，而分布式事务中只有一个事务管理器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;zookeeper&quot;&gt;6.3 Zookeeper&lt;/h2&gt;
&lt;p&gt;Zookeeper的原子广播协议与两阶段提交以及Kafka事务机制有相似之处，但又有各自的特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka事务可COMMIT也可ABORT。而Zookeeper原子广播协议只有COMMIT没有ABORT。当然，Zookeeper不COMMIT某消息也即等效于ABORT该消息的更新。&lt;/li&gt;
&lt;li&gt;Kafka存在多个&lt;code&gt;Transaction Coordinator&lt;/code&gt;实例，扩展性较好。而Zookeeper写操作只能在Leader节点进行，所以其写性能远低于读性能。&lt;/li&gt;
&lt;li&gt;Kafka事务是COMMIT还是ABORT完全取决于Producer即客户端。而Zookeeper原子广播协议中某条消息是否被COMMIT取决于是否有一大半FOLLOWER ACK该消息。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 28 Nov 2017 13:56:00 +0000</pubDate>
<dc:creator>郭俊Jason</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jasongj/p/7912348.html</dc:identifier>
</item>
<item>
<title>基于 nodejs 的 webSockt （socket.io） - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/7911937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/7911937.html</guid>
<description>&lt;h3 id=&quot;基于-nodejs-的-websockt-socket.io-理解&quot;&gt;基于 nodejs 的 webSockt （socket.io） 理解&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;本文的业务基础是在基于 nodejs 的 socket.io 的直播间聊天室（IM）应用来的。

项目中具体的 框架如下 express + mongodb + socket.io

在介绍 socket.io  之前，我们有必要对 webSocket 进行根本的原理的理解。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一websocket-的前生今世&quot;&gt;一、webSocket 的前生今世&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1、什么是 webSocket？
2、如何去用？
3、经常使用的场景？
4、需要注意的地方
好了，下面我们就按照上面 提到的四点来进行分析。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;什么是-websocket&quot;&gt;1、 什么是 websocket&lt;/h5&gt;
&lt;p&gt;官方文档解读： &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API&quot;&gt;webSocket&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这个是 MDN 的官方文档。详细的内容需要读者自己仔细去阅读了，笔者这里只介绍 容易出错的问题。

1、WebSockets 是一个可以创建和服务器间进行双向会话的高级技术。通过这个API你可以向服务器发送消息并接受基于事件驱动的响应，这样就不用向服务器轮询获取数据了。

当然这个只是说用来解决 不用向服务器轮询获取数据问题。 这么来说的话其实还是不太够 ‘官方’。

非官方理解： B/S 结构的软件项目中，客户端通过 http、https 等方式获得服务器消息，但是默认的 http 协议只支持 请求响应模式，这种模式简化了 web 服务器，减少服务器负担，加快网站的响应速度。 但是不能满足 我们实时消息推送，聊天室等功能，这个时候 websocket 这个本 作为 unix 进程通信机制 就被嫁接到了 应用程序间网络通信，从而就有了如今的 socket&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-通信模型&quot;&gt;2、Websocket: 通信模型&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675289/201711/675289-20171128114429503-1348300976.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。

特点： 事件驱动、异步 使用 ws 或者 wss 协议的 socket、 实现真正意义上的 推送功能

这里的  ws 和 wss 区别跟 http 和 https 的区别一样（安全性）

缺点就是 兼容性（今年已经 2017年了，应该可以不用考虑这个问题了）&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-客户端&quot;&gt;3、 websocket 客户端&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;官方文档中回提供系列的 api 具体如下：

分类如下：

a） 连接类：

    1、send() 向远程服务器发送数据
    2、close() 关闭该websocket链接

b) 监听函数类：

    1、onopen 当网络连接建立时触发该事件
    2、onerror 当网络发生错误时触发该事件
    3、onclose 当 websocket 被关闭时触发该事件
    4、onmessage 当 websocket 接收到服务器发来的消息的时触发的事件，也是通信中最重要的一个监听事件。 其中 我们可以定义各类 onmessage 事件的 type 从而 扩展我们的 onmessage 事件。

c) websocket还定义了一个readyState属性:

    1、CONNECTING(0) websocket正尝试与服务器建立连接
    2、OPEN(1) websocket与服务器已经建立连接
    3、CLOSING(2) websocket正在关闭与服务器的连接
    4、CLOSED(3) websocket已经关闭了与服务器的连接&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-服务端&quot;&gt;4、 websocket 服务端&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;服务端就像是一个分发中心， 但是首先都得通过 connect 创建连接 从而形成 ws 的长连接。

只要 长连接 连接成功，那么接下来的事情就很好操作了， 比如在服务端 emit 触发一个事件，那么在 服务端就需要监听 on 方法来监听同一个事件，最后如果需要让 当前房间（注: 这里有个 单房间 和 多房间的概念，我们在后面的介绍中会仔细的提到的）内的所有连接用户都被通知到这则消息，那么 在监听到服务端触发的消息的同时，再来触发一个广播给 客户端， 这个时候只要是在当前 ws 连接线上的所有用户都会被 emit 触发到这个事件，从而实现了 广播。

上面的这一长段话，可能暂时不太好理解，但是如果 亲手来写上这么一个 demo 就会理解很多了。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二-基于-nodejs-的-websocket-框架-socket.io&quot;&gt;二、 基于 nodeJs 的 webSocket 框架 socket.io&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;socket.io 是这篇文章的主角，因为它对 webSocket 做了一个非常完善的封装， 并且提出了 多房间  多命名空间的 概念，让多聊天室同时存在不再是一个问题，所以，下面就会详细的来介绍下 socket.io 这个框架&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://socket.io/&quot;&gt;http://socket.io&lt;/a&gt; 这个是官网&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们在官网中 可以看到非常简洁的 socket.io 的应用方法。

并且还展示了一个全世界通用的 IM （虽然这里常常可以看到 f**k xxx）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，下面就针对 这个 socket.io 再进行一个详细的介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、 Server api

2、 Client api

3、 Rooms and NameSpace&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这要就针对这三个来进行介绍&lt;/p&gt;
&lt;h5 id=&quot;server-api&quot;&gt;1、 Server api&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;服务端初始化 io 对象&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// or&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Server &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Server&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;这个时候就需要看 你的后台 服务的语言， php java nodejs 等等

我是用的 nodejs 所以直接 使用 express or koa2 均可

然后创建 http-server 服务&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; socket &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;express&lt;/span&gt;()

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; server &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;http&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createServer&lt;/span&gt;(app)

io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;socket&lt;/span&gt;(server)

&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(socket) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// to do somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;上面的这个步骤就可以轻松的 通过 nodejs + express 创建了一个 socket 服务端的 服务了&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;client-api&quot;&gt;2、 Client api&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;上面的步骤中已经在 服务端进行了 一些列 的操作 ，这个时候就需要 在服务端 创建 连接


首先是 需要在 前端引用 这个 socket 文件&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/socket.io/socket.io.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  const socket = io&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'http://localhost'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/script&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io-client'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// or with import syntax&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'socket.io-client'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后 创建 连接&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; socket &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后 触发监听  'connection'&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; (socket) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; token &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;handshake&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;query&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;加入这个时候你在 服务端 打印 debug 如果顺利 就可以轻松 完成了第一个 socket 的链接啦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;rooms-and-namespace&quot;&gt;3、 Rooms and NameSpace&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;最后这里 介绍到的  rooms 和 namespace 的概念

在多房间 聊天室 中 占据了很大的作用

其中 介绍下 rooms  的 概念 ， 关于 namespace 相关可以到 socket.io 官网中进行查看&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 广播给当前房间除了自己以外的所有人 &lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;broadcast&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;to&lt;/span&gt;(roomId).&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;   
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;// 广播给当前房间中自己&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)


&lt;span class=&quot;co&quot;&gt;// 广播给当前房间的所有人 &lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;to&lt;/span&gt;(roomId).&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后再结合上面的 监听 、 触发 方法，完成一系列的需求任务。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恩，今天先到这里，有什么问题，可以留言互相学习。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 12:35:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/7911937.html</dc:identifier>
</item>
</channel>
</rss>