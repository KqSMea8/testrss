<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>万类之父——Object - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8445910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8445910.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;jdk1.8.0_144&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　Object类作为Java中的顶级类，位于java.lang包中。所有的类直接或者间接都继承自它。所以Object类中的方法在所有类中都可以直接调用。在深入介绍它的API时，先插一句它和泛型之间的关系。&lt;/p&gt;
&lt;p&gt;　　在JDK1.5之前是没有泛型的，集合能够装下任意的类型，这就导致了一个潜在的问题——不能在编译时做类型检查，也就可能导致程序bug出现的概率。JDK1.5出现了泛型，在定义一个集合时指定一个泛型，这就能在编译时能做类型检查，避免了一些低级bug的出现。时至今日，实际上在JDK源码中遗留了部分不是特别优美的代码，从今天的角度来看是能够将其泛型化的（例如Map的get方法），但在当时需要考虑向后兼容不得不放弃对某些方法和类的泛型化，才导致了一丝瑕疵。&lt;/p&gt;
&lt;p&gt;　　接下来将详细的剖析Object类中的一些方法，其中某些方法会延伸到其他方面（例如：wait和notify等）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public final native Class&amp;lt;?&amp;gt; getClass()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Class对象实例。Class类有点“特殊”，因为它在我们的日常代码逻辑中不常出现，它所出现的地方往往是一些基础框架或者基础工具。　　&lt;/p&gt;
&lt;p&gt;　　Class类所处的包同样是java.lang，毫无疑问它的父类还是Object。在学习面向对象编程时，我们知道类是对一个事物抽象的定义，对象实例是表示的是一个具体的事物。那么Class这个名字有点含糊的类抽象的是什么呢？它的实例有代表的是什么呢？&lt;/p&gt;
&lt;p&gt;　　在程序中定义一个People类，我们将男人、女人抽象为了人类——People，它的实例表示的是男人或女人。程序中类似People这样的类千千万万，Class类就是千千万万类和接口的抽象，Class类的对象实例就这千千万万中具体的某个类或接口。再继续，男人和女人能被抽象为People类，这是因为男人和女人都有很多相同的特征，那千千万万类和接口都有名字、方法等也就意味着它们也能被抽象，故Class类就千千万万类和接口的抽象，Class类的对象实例就这千千万万中具体的某个类或接口。&lt;/p&gt;
&lt;p&gt;　　Class类作为类和接口的抽象，它存在的意义在哪里呢？它是类和接口的抽象，它的实例是某个具体的类，那为何不直接通过People p = new People()来实例化一个People对象呢？而是麻烦的需要先获取Class类，再获取它的实例，再通过它的实例创造一个类的对象。&lt;/p&gt;
&lt;p&gt;　　通常情况下使用Class类来获取某个类在实际编码中确实不常见，但这是JVM的执行机制。每个类被创建编译过后都对应一个.class文件，这个.class文件包含了它对应的Class对象，这个类的Class对象会被载入内存，它就会被JVM来创建这个类的所有实例对象。当然在实际运用中，Java的反射机制是离不开Class类的。 所以，回到Object类的getClass方法，提供的是该类的Class对象，每个类都可以通过这个方法获取它对应的Class对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public native int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是一个native本地方法，它的具体实现是有C++实现的。在Java程序中，每个对象实例（注意是对象实例）都有一个唯一的hashCode值（哈希码值），可以通过对比两个对象实例是否相同来判断是否指向同一个对象实例。&lt;/p&gt;
&lt;p&gt;　　它有这么一个性质，例如判断两个String字符串是否相等，使用“==”表示的两个对象的引用是否相等，而使用equals则表示两个对象的值是否相等。&lt;strong&gt;equals相等，则hashCode值一定相等；hashCode值相等，而equals不一定相等。&lt;/strong&gt;并且它被应用在我们熟悉的Map集合中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public boolean equals(Object obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　该方法用于比较两个对象是否“相等”。之所以相等有引号，是这个相等在代码逻辑中分为两种情况：对象引用相等；对象值相等。&lt;/p&gt;
&lt;p&gt;　　Object中equals方法有一个默认实现，它直接使用“==”进行比较，也就是说在Object中equals和“==”是等价的。但是在String和Integer等中， equals方法是被重写的，它们的equals方法代表的是值相等，而不是引用相等。&lt;/p&gt;
&lt;p&gt;　　注意在重写equals方法时，需要遵守以下几个原则：&lt;/p&gt;
&lt;p&gt;　　1. 自反性。也就是说自己调用equals方法和自己比较时，必须返回true。（自己都不和自己相等，那谁才相等）&lt;/p&gt;
&lt;p&gt;　　2. 对称性。我和你比较返回ture，你和我比较也要返回true，a.equals(b)返回true，b.equals(a)返回true。&lt;/p&gt;
&lt;p&gt;　　3. 传递性。这个根据名字就很好理解。a.equals(b)返回true，b.equals(c)返回true，a.equals(c)也需要返回true。&lt;/p&gt;
&lt;p&gt;　　4. 一致性。也就是在没有修改两个对象的情况下，多次调用返回的结果应该是一样的。&lt;/p&gt;
&lt;p&gt;　　5. 非空性。非空对象与null值比较必须返回false。&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('583e9a5f-04a2-4df4-8ced-0e26f3e0cb41')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_583e9a5f-04a2-4df4-8ced-0e26f3e0cb41&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_583e9a5f-04a2-4df4-8ced-0e26f3e0cb41&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('583e9a5f-04a2-4df4-8ced-0e26f3e0cb41',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_583e9a5f-04a2-4df4-8ced-0e26f3e0cb41&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.customequals;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Studen类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/10.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 姓名
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 年龄
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * 性别
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Student(String name, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; sex) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; getSex() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSex(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; sex) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Student)) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         Student other =&lt;span&gt; (Student)obj;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (other.getName().equals(&lt;span&gt;this&lt;/span&gt;.name) &amp;amp;&amp;amp; other.getAge() == &lt;span&gt;this&lt;/span&gt;.age &amp;amp;&amp;amp; other.getSex() == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e33284c5-afa3-4e57-9e66-ad1cfadf04a8')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_e33284c5-afa3-4e57-9e66-ad1cfadf04a8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e33284c5-afa3-4e57-9e66-ad1cfadf04a8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e33284c5-afa3-4e57-9e66-ad1cfadf04a8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e33284c5-afa3-4e57-9e66-ad1cfadf04a8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.customequals;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertEquals;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * 测试Student类equals方法
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/10.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentTest {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Student a, b, c;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUp() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         a = &lt;span&gt;new&lt;/span&gt; Student(&quot;Kevin&quot;, 23, (&lt;span&gt;byte&lt;/span&gt;)0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         b = &lt;span&gt;new&lt;/span&gt; Student(&quot;Kevin&quot;, 23, (&lt;span&gt;byte&lt;/span&gt;)0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         c = &lt;span&gt;new&lt;/span&gt; Student(&quot;Kevin&quot;, 23, (&lt;span&gt;byte&lt;/span&gt;)0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 自反性
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReflexive() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, a.equals(a));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * 对称性
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSymmetric() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, a.equals(b));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, b.equals(a));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;     * 传递性
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTransitive() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, a.equals(b));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, b.equals(c));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, a.equals(c));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;     * 一致性
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testConsistent() {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, a.equals(b));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;     * 非空性
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testNonNullity() {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         assertEquals(&lt;span&gt;false&lt;/span&gt;, a.equals(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从上面重写的equals的测试结果来看是通过的，但是实际上是错误的，如果在你的程序中只使用这个类的equals方法，而不会使用到集合，那没问题，但是一旦使用Map集合，上面的错误立马暴露。例如如果运行以下测试方法，返回的结果将会是null。&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('acc938c8-3497-43f9-9470-3ea7cd0cdf21')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_acc938c8-3497-43f9-9470-3ea7cd0cdf21&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_acc938c8-3497-43f9-9470-3ea7cd0cdf21&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('acc938c8-3497-43f9-9470-3ea7cd0cdf21',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_acc938c8-3497-43f9-9470-3ea7cd0cdf21&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 测试equals方法
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMap() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     Map&amp;lt;Student, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     map.put(a, &quot;this is map.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     assertEquals(&quot;this is map.&quot;&lt;span&gt;, map.get(b));
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　但明明逻辑中a和b是相等的，b也应该能取出值来，这就是没有重写hashCode方法a和b对象的hashCode值不一致导致的问题，这不是bug，这是没有满足JDK的规定。上面的hashCode方法末尾提到了equals相等，hashCode值也相等；hashCode值相等，equals不一定相等。上面的代码3个对象的hashCode值是不相等的，所以导致b不能从Map中取出相应的值，相等的对象必须具有相等的hashCode值。&lt;/p&gt;
&lt;p&gt;　　这就涉及到如何设计一个良好运作的散列函数。一个好的散列函数，更能较为平均地散列到散列通中，而不是造成大量的散列冲突，大量的散列冲突会使得散列表退化成链表形式，这会使得效率大大降低。设计上要设计一个好的散列函数并不是一件容易的事，下面为Student类设计的散列函数是根据《Effective Java》中的解决办法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; result = 17&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     result = name.hashCode() +&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     result = 31 * result +&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     result = 31 * result + (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)sex;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2070e0ff-4399-41c5-935e-7967959a8632')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_2070e0ff-4399-41c5-935e-7967959a8632&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2070e0ff-4399-41c5-935e-7967959a8632&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2070e0ff-4399-41c5-935e-7967959a8632',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2070e0ff-4399-41c5-935e-7967959a8632&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 测试hashCode值是否相等
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testHashCode() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     assertEquals(&lt;span&gt;true&lt;/span&gt;, a.hashCode() ==&lt;span&gt; b.hashCode());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;protected native Object clone() throws CloneNotSupportedException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　“克隆”，也称为“复制”。这个方法在访问权限不同于其他方法，它在Object类中是protected修饰的方法。protected意味着只能在它的子类调用Object类中的clone方法，而不能直接在外部调用，想要使用对象的clone方法，需要在方法中调用父类的clone方法，并且需要实现Cloneable接口。&lt;/p&gt;
&lt;p&gt;　　这个方法如其名，复制一个相同的对象示例，而不是将引用拷贝给它，所以复制后的对象实例一个新的对象示例。&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5412d0ac-7f41-4187-aadf-4e9298a79a90')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_5412d0ac-7f41-4187-aadf-4e9298a79a90&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5412d0ac-7f41-4187-aadf-4e9298a79a90&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5412d0ac-7f41-4187-aadf-4e9298a79a90',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5412d0ac-7f41-4187-aadf-4e9298a79a90&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还是上面Student类，重写clone方法，并且实现Cloneable接口&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Student clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (Student) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a5d32f17-2bc6-46bf-ac88-c1a5c38e32d9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a5d32f17-2bc6-46bf-ac88-c1a5c38e32d9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5d32f17-2bc6-46bf-ac88-c1a5c38e32d9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a5d32f17-2bc6-46bf-ac88-c1a5c38e32d9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5d32f17-2bc6-46bf-ac88-c1a5c38e32d9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 测试clone方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testClone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     Student cloneA =&lt;span&gt; (Student) a.clone();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     assertEquals(&lt;span&gt;false&lt;/span&gt;, cloneA ==&lt;span&gt; a);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     assertEquals(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, cloneA.equals(a));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法呢，坑比较多。它有一个比较重要的地方——“深复制”和“浅复制”。&lt;/p&gt;
&lt;p&gt;　　一个复杂类的成员属性有“基本数据类型”和“引用数据类型”。&lt;/p&gt;
&lt;p&gt;　　假设现在需要对对象A复制一个对象B。&lt;/p&gt;
&lt;p&gt;　　对于浅复制来讲，对象B的基本数据类型和A的基本数据类型它们相等，且互相不会受到影响。但是如果修改了对象B中的引用数据类型，此时将会影响到A对应的引用数据类型。&lt;/p&gt;
&lt;p&gt;　　但对于深复制来讲，对象B就是完完全全和A一样的对象实例，不管是基本的还是引用的数据类型都不会相互影响。&lt;/p&gt;
&lt;p&gt;　　如果像上面的示例代码重写clone方法，它所实现的就是浅复制（当然在Student类中并没有引用类型），如果在Student类中有一个Course引用类型的话，想要它实现深复制需要完成以下2点：&lt;/p&gt;
&lt;p&gt;　　1. Course本身也已经实现Cloneable接口，且重写了clone方法。&lt;/p&gt;
&lt;p&gt;　　2. Student类中在调用了父类的clone方法后，还需要调用Course的clone方法。&lt;/p&gt;
&lt;p&gt;　　如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Student clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     Student s = (Student) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     s.course = (Course) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.course.clone();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重写实现clone方法时一定要仔细，切记需要调用父类的clone方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public String toString()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回类的一些描述信息。“最佳的编程实践”是最好对每个类都重写toString方法。在Object类中这个方法的实现是调用getClass返回类信息+@符号+16进制的hashCode值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public final native void notify()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public final native void notifyAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public final native void wait(long timeout) throws InterruptedException;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public final void wait(long timeout, int nanos) throws InterruptedException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public final void wait() throws InterruptedException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这几个方法拿到一块来说是因为它们用于多线程并发编程当中。&lt;/p&gt;
&lt;p&gt;　　上面的5个方法实际上只有前3个核心方法，后两个只是wait方法的重载而已。我们先了解前3个，后两个也会迎刃而解。&lt;/p&gt;
&lt;p&gt;　　开头提到这用于多线程并发编程中，众所周知Java应用程序号称“一次编译，到处运行”的奥秘就在于Java应用程序是运行在Java虚拟机（JVM）之上的，而JVM的设计实际上是类同于一个操作系统的。在操作系统中谈的更多是进程与进程之间的关系，例如进程间的同步与通信，进程和进程的并发等等。Java应用程序在操作系统中只是1个进程，在JVM中就蕴含了N个线程，就类似于操作系统的N个进程，所以在Java中提及更多的是线程间的同步与通信，线程和线程的并发等。&lt;/p&gt;
&lt;p&gt;　　Java中的线程用于自己的运行空间，称之为虚拟机栈，这块空间是线程所独占的。如果Java应用程序中的N个线程相互孤立互不干扰的运行，可以说这个应用程序并没有多大的价值，最大的价值是N个线程之间相互配合完成工作。那自然就会涉及到多个线程间的通信问题。在本文只着重讲解线程间的通信，而对于线程安全这个议题不做过多深究。&lt;/p&gt;
&lt;p&gt;　　在操作系统中，对于进程间同步有这么一个定义：为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。将定义中的进程换为线程，即可当做在Java中对同步的定义。&lt;/p&gt;
&lt;p&gt;　　例如：线程T1运行到某处时，需要线程T2完成另一项任务才能继续运行下去，此时T1对CPU的占用就需要让位给T2，而T1此时只能等待T2完成。当T2完成任务后通知T1重新获取对CPU的占用继续完成未完成的任务。这个例子就是简单的同步示例，其中涉及到的等待、通知即表示线程间的通信，wait和notify、notifyAll所代表的就是线程间的通信。&lt;/p&gt;
&lt;p&gt;　　所以，Object类中的wait和notify、notifyAll方法是用于线程间的通信，且它们的调用需要在获取对象锁的情况下才可以（也就是说需要在线程安全的条件下调用），在具体一点是只有在synchronized关键字所修饰的同步方法或者同步代码块才可以使用，并不是任何地方都可以调用。这里有一个有关线程间通信的经典示例——生产者消费者模型。通过仔细咀嚼这个模型我们能好的理解线程间的通信。&lt;/p&gt;
&lt;p&gt;e.g.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('95a666a9-88c2-499d-9acd-fc7c97458591')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_95a666a9-88c2-499d-9acd-fc7c97458591&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_95a666a9-88c2-499d-9acd-fc7c97458591&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('95a666a9-88c2-499d-9acd-fc7c97458591',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_95a666a9-88c2-499d-9acd-fc7c97458591&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.communication;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Queue;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Producer
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/13.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Producer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Queue&amp;lt;String&amp;gt;&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Producer(Queue&amp;lt;String&amp;gt;&lt;span&gt; queue) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.queue =&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (queue) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (queue.size() == 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     System.out.println(&quot;生产线程&quot; + Thread.currentThread().getId() + &quot;执行，队列为满，生产者等待&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    queue.wait();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                queue.add(String.valueOf(System.currentTimeMillis()));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 System.out.println(&quot;生产线程&quot; + Thread.currentThread().getId() + &quot;执行，队列不为满，生产者生产：&quot; + String.valueOf(System.currentTimeMillis()) + &quot;，容量&quot; +&lt;span&gt; queue.size());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                queue.notifyAll();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('472b67f1-15be-46dd-ab65-4650bbdb2293')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_472b67f1-15be-46dd-ab65-4650bbdb2293&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_472b67f1-15be-46dd-ab65-4650bbdb2293&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('472b67f1-15be-46dd-ab65-4650bbdb2293',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_472b67f1-15be-46dd-ab65-4650bbdb2293&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.communication;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Queue;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Consumer
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/13.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Queue&amp;lt;String&amp;gt;&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Consumer(Queue&amp;lt;String&amp;gt;&lt;span&gt; queue) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.queue =&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (queue) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (queue.isEmpty()) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     System.out.println(&quot;消费线程&quot; + Thread.currentThread().getId() + &quot;执行，队列为空，消费者等待&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    queue.wait();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 System.out.println(&quot;消费线程&quot; + Thread.currentThread().getId() + &quot;执行，队列不为空，消费者消费:&quot; + queue.remove() + &quot;，容量&quot; +&lt;span&gt; queue.size());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                queue.notifyAll();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c8f91198-5620-4b99-b927-70e67732a6e1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c8f91198-5620-4b99-b927-70e67732a6e1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8f91198-5620-4b99-b927-70e67732a6e1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c8f91198-5620-4b99-b927-70e67732a6e1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8f91198-5620-4b99-b927-70e67732a6e1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.communication;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Queue;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * Test Producer &amp;amp; Consumer
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/13.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerConsumerTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     Queue&amp;lt;String&amp;gt;&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUp() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(queue)).start();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(queue)).start();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(queue)).start();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(queue)).start();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这个生产者消费者模型很好的演示了线程间是如何通过Object中的wait和notify、notifyAll方法进行通信的。在程序中使用的是notifyAll方法而不是notify方法，实际当中也多用notify方法。它们俩的区别就是notify方法只会唤醒等待队列中的一个线程使之进入同步队列进而使之有了争夺CPU执行的权力，而notify方法是会唤醒等待队列中的所有线程使之进入同步队列。注意，它们都是让等待线程从等待队列进入同步队列，它们仅仅是拥有了争夺CPU的权力，调用这两个方法不代表它们就会拥有CPU执行的权力。&lt;/p&gt;
&lt;p&gt;　　至于wait方法另外个重载方法：&lt;/p&gt;
&lt;p&gt;　　wait(long)：等待N毫秒没用收到通知就超时返回；&lt;/p&gt;
&lt;p&gt;　　wait(long, int)：同样也是超时等待指定的时间没有收到通知超时返回，不同的是第二个参数可以达到更加细粒度的时间控制——纳秒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protected void finalize() throws Throwable { }&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法在对象在被GC前会被调用，需要着重强调的是，千万不要依赖此方法在其中做一些资源的关闭，因为我们不能保证JVM何时进行GC，所以我们也就无法判断该方法何时会被执行，除非你不在意它执行的时间，否则千万不要重写它。它不能当做是C++中的析构函数。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 17:55:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8445910.html</dc:identifier>
</item>
<item>
<title>------- 软件调试——注销 QQ 过滤驱动设置的事件通知 CallBack （完）------- - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8445895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8445895.html</guid>
<description>&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本系列的最后一篇演示如何通过调试手段摘除 QQ 过滤驱动设置的事件通知 CallBack。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内核中有几个全局的数组用来存放这些事件通知 CallBack 的指针，第一个就是 &lt;span&gt;nt!PspCreateProcessNotifyRoutine&lt;/span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当有进程被创建时，该数组中的函数指针就会依次被调用，与此类似，当有线程被创建时，&lt;span&gt;nt!PspCreateThreadNotifyRoutine&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组中的函数指针就被调用；&lt;span&gt;nt!PspLoadImageNotifyRoutine&lt;/span&gt; 中的回调则是在有内核模块加载时被调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;驱动程序通过向这些数组中加入 CallBack 指针，就能够监控相应的事件&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先来看下哪些驱动程序正在监控系统范围的进程创建事件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; r @$t0=poi(nt!&lt;span&gt;PspCreateProcessNotifyRoutineCount);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; r @$t1=nt!&lt;span&gt;PspCreateProcessNotifyRoutine;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; .&lt;span&gt;for&lt;/span&gt;(r @$t2=&lt;span&gt;0&lt;/span&gt;; @$t2&amp;lt;@$t0; r @$t2=@$t2+&lt;span&gt;1&lt;/span&gt;){dds (poi(@$t1+@$t2*&lt;span&gt;4&lt;/span&gt;)^&lt;span&gt;7&lt;/span&gt;)+&lt;span&gt;4&lt;/span&gt; l1;}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213004431624-251431572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图您可以看到，QQFrmMgr.sys 中有一个例程正在监视着进程创建事件。除此之外的其它内核模块都是合法的，比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“avkmgr”与“avdevprot”是安装德国小红伞反病毒软件时，附带安装的两个内核模式驱动程序，它们注册了各自的回调在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监控着进程创建事件，这是实现 Real-Time Protection 用到的系统底层机制之一；“tcpip”不用我说各位也知道，它是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Windows 内核网络栈的主要实现模块之一：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213004555124-108033991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;注意，系统最多支持注册 8 枚事件回调指针，&lt;span&gt;nt!PspCreateProcessNotifyRoutineCount&lt;/span&gt; 存储当前注册的回调指针数量，如下图，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个全局变量的值与第一张图片中的事件回调指针枚数一致：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213004701437-899983702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在，我们尝试从中摘除 QQFrmMgr.sys 的监控例程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213004757218-360185206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005001452-1061948625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 使用类似的手段，检查 QQFrmMgr.sys 有没有监控线程创建与内核模块加载事件：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; r @$t0=poi(nt!&lt;span&gt;PspCreateThreadNotifyRoutineCount);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; r @$t1=nt!&lt;span&gt;PspCreateThreadNotifyRoutine;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; .&lt;span&gt;for&lt;/span&gt;(r @$t2=&lt;span&gt;0&lt;/span&gt;; @$t2&amp;lt;@$t0; r @$t2=@$t2+&lt;span&gt;1&lt;/span&gt;){dds (poi(@$t1+@$t2*&lt;span&gt;4&lt;/span&gt;)^&lt;span&gt;7&lt;/span&gt;)+&lt;span&gt;4&lt;/span&gt;&lt;span&gt; l1;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; r @$t0=poi(nt!&lt;span&gt;PspLoadImageNotifyRoutineCount);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; r @$t1=nt!&lt;span&gt;PspLoadImageNotifyRoutine;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; .&lt;span&gt;for&lt;/span&gt;(r @$t2=&lt;span&gt;0&lt;/span&gt;; @$t2&amp;lt;@$t0; r @$t2=@$t2+&lt;span&gt;1&lt;/span&gt;){dds (poi(@$t1+@$t2*&lt;span&gt;4&lt;/span&gt;)^&lt;span&gt;7&lt;/span&gt;)+&lt;span&gt;4&lt;/span&gt; l1;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005125437-144998699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;您看，这家伙监控的地方还真不少，为的就是保护它自己免受其它恶意软件攻击！或许你会好奇：图中的“&lt;span&gt;XLGuard&lt;/span&gt;”是啥东&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;东？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它就是在安装“迅雷”（一种基于 BitTorrent 协议的 P2P 下载/分享软件）时，一并安装的内核模式驱动程序之一，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005223859-53079870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;从名称中的“Guard”来看，应该也是用来保护迅雷自身组件的——&lt;span&gt;现在的软件都比女性还懂得怎么保护自己呢&lt;/span&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以使用前述的方法来阻止 QQFrmMgr.sys 监控线程创建与内核模块加载事件——就布置成家庭作业吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;———————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;写到这里，本系列算是大致功德圆满了。。。。还记得上一篇我抱怨说“!chkimg”调试器扩展命令不能用吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;折腾的这几天总算找出问题所在了——从 MSDN 网站下载的 Windows 7 &lt;span&gt;零售版&lt;/span&gt;符号包中的 ntoskrnl.exe 版本问题——我听信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该站点的建议下载了 Windows 7 Service Pack 1 x86 零售符号，结果其中的 ntoskrnl.exe 内核映像版本被最新版的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WinDbg 排斥，所以我换用了 Windows 8.1 x86 32 位零售符号，以便双机物理调试环境中检查目标机器上的 Windows 8.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内核工作情况，也证实了 QQ 驱动没有采取反虚拟机技术，它的行为模式与在真实机器上的表现一致（至少在写作本文的时间点上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是如此，以后就难说了，搞不好也会引入反调试技术。。。），如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005430421-1920252417.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后贴上在 32 位 Windows 8.1 上利用“!chkimg”自动检查并恢复 SSDT 的过程，以飨读者：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005548531-1709922545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005603077-2009358146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;NND，为啥前面手工检查 SSDT 能够发现的 QQ hooks，通过“!chkimg”自动检查却探测不到，只识别了 inline hook ？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阅读一下该扩展命令的官方文档，原来是需要指定一个特殊的选项：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005719296-1926953010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正如图中红框部分所讲的那样：Hal.dll 与 Ntoskrnl.exe 中的某些特定地址不会被检查，因为当这些部分被载入时，会发生某些改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包含 &lt;span&gt;-nospec&lt;/span&gt; 选项则可以检查这些地址。事实上，这就是我在前一篇谈到的——每次系统启动时都随机创建 SSDT 的基址，所以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“!chkimg”就忽略了这些“随机”的部分，偏偏给 QQ 驱动留下了可乘之机。。。。添加 -nospec 选项后，我们成功地&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析出 SSDT 中的所有 hooks，下面我仅截取了输出的前三个 hooks，&lt;span&gt;它们对应于前面有一张“dps”命令解析图中的三个 hooks&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213005850890-195258180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;以上图中的黄框部分为例，第一个 hook 是从 8151b3a8 到 8151b3aa 的三个字节修改；&lt;span&gt;冒号左边是磁盘文件中的原始字节&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;序列，&lt;/span&gt;&lt;span&gt;&lt;span&gt;冒号右边是内存映像中的已修改字节序列&lt;/span&gt;，该项 hook 距离 nt!KiServiceTable 起始地址的偏移量为 0xC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们看看前三个 hook 的受害例程（原始系统服务）是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213010033656-216820658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原来 QQFrmMgr.sys hook 了 NtWriteVirtualMemory()（写入任意进程的虚拟内存）、NtUnmapViewOfSection()（取消映射 section 的视图）、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以及 NtTerminateProcess()（终止进程），这与我前一篇的手工分析一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最后，让我们用“!chkimg”的“-f”开关，自动修正内存映像中的错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213010146452-1706342990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180213010207281-832786980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;小结：本篇讨论了摘除恶意事件通知回调函数的相关技巧，并演示自动修复关键系统设施的方法，文中介绍的调试技术只是&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;内核攻防中的冰山一角，而且这些方法随着内核与恶意软件的不断进化也正面临着挑战！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;持续研究与探索不同内核驱动/rootkit 的行为模式仍旧是必要的！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 17:03:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8445895.html</dc:identifier>
</item>
<item>
<title>GIT工作流 - 前程明亮</title>
<link>http://www.cnblogs.com/0zcl/p/8444460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0zcl/p/8444460.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言:&lt;/span&gt;&lt;/strong&gt; 关于git的使用, 之前就已经写过一篇博客了: &lt;a href=&quot;http://www.cnblogs.com/0zcl/p/6874588.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/0zcl/p/6874588.html&lt;/a&gt;. 看完这篇博客, 你就基本可以使用git了. 这种使用, 仅限了一两人的开发. 如果团队有多人, 而且位置较分散. 那这开发就更需要规范了. 因此, 这篇博客来说一下GIT工作流.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;本来以为我用git命令行可以解决GIT工作流上的问题，但其实只用命令行还是蛮困难的&lt;/span&gt;。下面&lt;span&gt;先看看GIT的规范, 这部分比较无聊&lt;/span&gt;, 下面会图文并茂的, 好吧. 如果你瞄了一眼, 觉得这SB博客, 写得太low了, 然后就关掉这篇博客, 我感觉还是错过一些东东.&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;GIT工作流-提交规则&quot;&gt;&lt;span&gt;一、提交规则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;[feature] 新增功能、更新的提交，例如“[feature] add a new data layer for reading jpeg images”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[bugfix] bug修正的提交，有bugid的补充bugid，例如“[bugfix] now data layer reads single-channel images correctly”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[optimize] 优化的提交：性能等方面，feature分之下的单次优化要指明，优化分支下的用[feature]即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[refactor] 代码等重构的提交，feature分之下的单次重构要指明，重构分支下的用[feature]即可&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每次提交应该只能有一个修改，不能将多个逻辑修改放在一个提交中;不可将一个逻辑修改分成多个提交&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;例如: 同时修复一个bug，同时做了重构或优化，就要把提交分成两个(bugfix、refactor/optimize)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每次merged到develop分支的代码必须为可运行的，并且保证多平台可用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多人协作过程中如果在开发同一个feature，不可以在同一个feature分支进行开发，需要各自拉出新feature分支独立开发，完成后merge到共同的feature分支&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每日至少一次Git提交，防止代码丢失&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;feature分支在完成后合并到develop&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GIT工作流-版本号的定义&quot;&gt;&lt;span&gt;二、版本号的定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;A.B.C。例如1.1.0。按照功能来定：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果是&lt;span&gt;大的版本更新，则A+1&lt;/span&gt;，并且B和C都设置为0；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果是&lt;span&gt;小的版本更新，则B+1&lt;/span&gt;，并且A不变，C设置为0；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果是&lt;span&gt;修复bug的版本更新，则C+1&lt;/span&gt;，并且A和B都不变。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GIT工作流-Git工作流&quot;&gt;&lt;span&gt;三、Git工作流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;添加一个工程文件以后，点击：（仓库）——（git flow）——（初始化仓库）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个的目的是为了方便git各种分支的自动生成，同时也是为了后续工作流的方便使用。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;GIT工作流-develop&quot;&gt;&lt;span&gt;develop&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前版本最新开发进展，未测试或者测试中，对于单人开发小模块可以直接提交，多人协作及大模块必须通过合并具体功能子分支，接受来自feature，release，hotfix的合并。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建分支必须通过（git flow）——（建立新的功能）从develop来进行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;GIT工作流-feature分支&quot;&gt;&lt;span&gt;feature分支&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个分支主要是为了各种研发方案执行使用。（必须推送远端，完成feature后合并到develop，以及测试下是否可以执行）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;分支命名以版本号+开发者+模块的形式来，例如：feature/1.0.0_aidy_newfeature。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当分支特性开发完成后合并到develop，主要是通过（git flow）——（完成功能）来进行合并，或者手动合并。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当出现合并冲突时，记得与冲突者当面一起沟通与合并，并确认效果ok。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;GIT工作流-release分支&quot;&gt;&lt;span&gt;release分支&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个分支主要是给研发方案差不多确定时使用，主要是为了fixbug等。（完成feature后，必须推送远端，以及测试下是否可以执行）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个分支只来自develop，当研发差不多了以后，就开始做release分支。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;命名为版本号，例如1.0.0。主要是通过（git flow）——（建立新的发布版本）来进行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当realease分支差不多了，就通过（git flow）——（完成发布版本）来进行。并会打一个版本号的标签。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;完成后并入develop和master。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;GIT工作流-hotfix分支&quot;&gt;&lt;span&gt;hotfix分支&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要用于最新发布版本的bug修复。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;GIT工作流-当前版本&quot;&gt;当前版本&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;就通过（git flow）——（建立新的修复补丁）来进行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当完成以后，通过（git flow）——（完成新的修复补丁）来进行合并。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当出现合并冲突时，记得与冲突的修改者当面一起沟通与合并，并确认效果ok&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;以上来自GIT规范，然而看完GIT规范感觉还是没有顿悟的感觉&lt;/span&gt;。so，必须得会使用smartgit呀。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;四、使用SmartGit&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;看完GIT规范，你已经知道，&lt;span&gt;feature分支是平时开发功能用的，完成feature分支开发后，合并到develop分支，合并成功后，删除该feature分支&lt;/span&gt;。这用smartgit可以轻松实现，用命令行的话是比较麻烦，但也可以实现呀。现在的问题是，&lt;span&gt;用smartgit如何轻松实现创建feature分支，删除feature分支？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击Git-Flow，再点击configure，可出现如下图：如果你找不到下图这个界面，那必然是你操作的姿势有问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144613046-200580113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到没有，神奇呀，在上图中，你&lt;span&gt;只需点击OK，GIT就会自动帮你创建feature, release, hot-fix, develop分支&lt;/span&gt;。这超牛逼的。这步操作很重要。完成这步操作后，会出现develop分支，此时需要把develop分支推到远程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144644874-994018671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常情况下，你&lt;span&gt;远程仓库应该有两个分支了，分别是master和develop分支。如果没有，把它们推到远程&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;啥，不知道怎么push？有两种方式，在上图的左下角的Branches窗口下，你可以点击master分支，然后鼠标右击，再点击push to ；也可以在左下角的Branches窗口下，双击要push的分支A，此时分切换到A分支，然后再点击上图左上方的Push推到远程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、feature分支的使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;OK，此时远程仓库应该有两个分支master/develop，然而这还远远不够呀，你看到同事的项目有一个feature分支。so，你肯定也是需要feature分支的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击Git-Flow，会出现下图。如果没出现Start Feature; Start Release这些，必然是你最开始的configure有问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144805921-181553994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击Start Feature来创建一个feature分支&lt;/span&gt;，分支命令要参考命名规范。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144825218-743373180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在你已经有一个feature分支了。在该分支提交些东西，commit后，提交到远程。你会惊喜的发现&lt;span&gt;远程的仓库出现feature分支&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144843312-1376285191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在你可以不断地开发，提交代码到feature分支上，&lt;span&gt;但feature分支只负责一个功能的开发而已，当这个功能开发完成后，必然需要把该feature分支删除&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单粗暴地说，就是当feature/0.0.2_zzy_example分支负责的功能开发完毕时，需要把feature分支合并到develop分支，合并完成后，feature分支删除，此时远程仓库就看不到feature/0.0.2_zzy_example分支。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实smartgit已经帮我们简化了工作。牛逼呀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你创建feature分支时，会自动切换到feature分支。&lt;span&gt;完成功能开发后，想把feature分支合并到develop分支，如何做呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需点击Git-Flow，就会出现下图。注意，此时你应该是处于feature分支的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144911031-998653913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到上图的Delete feature branch没，当你合并完成后，就会把feature分支删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来你需要&lt;span&gt;把develop分支推到远程。你会发现远程的feature分支不见了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212144930109-937837158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，是feature分支开发的流程。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;六、发布版本&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;今天，团长想考下git方面的操作。给我一个需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212145726343-1140518081.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看GIT规范对于release分支是如何介绍的:&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;GIT工作流-release分支.1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;release分支&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个分支主要是&lt;span&gt;给研发方案差不多确定时使用&lt;/span&gt;，主要是为了fixbug等。（完成feature后，必须推送远端，以及测试下是否可以执行）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个分支只来自develop，当研发差不多了以后，就开始做release分支。&lt;/li&gt;
&lt;li&gt;命名为版本号，例如1.0.0。主要是通过（git flow）——（建立新的发布版本）来进行。&lt;/li&gt;
&lt;li&gt;当realease分支差不多了，就通过（git flow）——（完成发布版本）来进行。并会打一个版本号的标签。&lt;/li&gt;
&lt;li&gt;完成后并入develop和master。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;第一步&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先创建一个release分支：点击Git-Flow，再点击start release:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212145931827-2008104362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入release分支名，分支名参考GIT规范。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;第二步&lt;/span&gt;：可以在release分支commit, push到远程。此时你的远程除master, develop外，应该得有一个release分支&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;第三步&lt;/span&gt;：发布版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212150007640-176611819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击finish，就会发布版本啦，这里需要给版本打一个tag，tag默认会自动显示为你的版本号&lt;/span&gt;。同时&lt;span&gt;会把release合并到master与develop分支&lt;/span&gt;。再同时发布之后，会删除该release分支。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此时远程如下显示：没有release分支。多了一个Tags版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212150045062-775919259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，团长交待的任务完成！&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;七、附本人测试用了GIT分支图：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212150117343-323434607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212150123984-2073560767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;八、总结：&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;由于最开始就没用好smartgit，比如下面这张图的操作。之前就没用到，导致后面的操作不顺。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不要用命令行，不要用命令行，不要用命令行。命令行操作add, commit, push还可以，但对于分支操作，版本发布，用smartgit,用smartgit,用smartgit。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我想git这块我顿悟了。佛系佛系，喝怀奶荼冷静一下。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212150226906-1464326787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 16:04:00 +0000</pubDate>
<dc:creator>前程明亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0zcl/p/8444460.html</dc:identifier>
</item>
<item>
<title>菜鸟之旅——学习线程（2） - 愉悦的绅士</title>
<link>http://www.cnblogs.com/nbclw/p/8441317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbclw/p/8441317.html</guid>
<description>&lt;p&gt;　　前面两篇回顾线程和线程池的使用方法，微软在.NET4.5推出了新的线程模型-Task。本篇将简单的介绍Task的使用方法。&lt;/p&gt;

&lt;p&gt;　　Task与线程或者说线程池关系紧密，可以说是基于线程池实现的，虽说任务最终还是要抛给线程去执行，但是Task仍然会比线程、线程池的开销要小，并且提供了可靠的API来控制线任务执行。&lt;/p&gt;
&lt;p&gt;　　使用Task来执行的任务最终会交给线程池来执行，若该任务需要长时间执行，可以将其标记为LongRunning，这是便会单独去请求创建线程来执行该任务。&lt;/p&gt;

&lt;h2&gt;　创建&lt;/h2&gt;
&lt;p&gt;　　Task的创建也存在两种方式，使用new或者使用静态工厂方式来创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Task t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task(Menthod1);
            t.Start();

            Task.Factory.StartNew(Menthod2);
            
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod2()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面说到使用Task执行任务最终还是需要线程池来执行，若不想让线程池来执行，可以添加LongRunning标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Task t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task(Menthod1, TaskCreationOptions.LongRunning);
        t.Start();

        Task.Factory.StartNew(Menthod2, TaskCreationOptions.LongRunning);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　TaskCreationOptions还有很多枚举值，用来控制任务的更多属性。&lt;/p&gt;
&lt;h2&gt;　参数与返回值&lt;/h2&gt;
&lt;p&gt;　　使用Task也可以传入参数（object类型）与返回值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Task.Factory.StartNew(Menthod1, &lt;/span&gt;&lt;span&gt;233&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int result = Task.Factory.StartNew(new Func&amp;lt;object, int&amp;gt;(Menthod3), 233).Result;&lt;/span&gt;
            Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; t = Task.Factory.StartNew(&lt;span&gt;new&lt;/span&gt; Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(Menthod3), &lt;span&gt;233&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; t.Result;

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod1(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Menthod3(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;6000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程3的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;obj&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这里为了获取返回值，阻塞了主线程，这里请注意一下。&lt;/p&gt;
&lt;h2&gt;　等待Task&lt;/h2&gt;
&lt;p&gt;　　可以使用Task实例的Wait方法来实现等待任务结束，也可以向多线程一样，使用WaitAll和WaitAny一样来等待多个任务结束，不过操作更为简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        t.Wait();
        Task.WaitAll(t1, t2 ...);
        Task.WaitAny(t1, t2 ...);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　取消Task&lt;/h2&gt;
&lt;p&gt;　　任务也是可以事先取消的，不过需要使用CancellationTokenSource：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Factory.StartNew(Menthod1);

            CancellationTokenSource cancelTokenSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
            Task.Factory.StartNew(Menthod2, cancelTokenSource.Token);
            cancelTokenSource.Cancel();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码就可以将线程2给取消掉，当然，Cancel方法可以自己找个合适的地方调用。&lt;/p&gt;

&lt;h2&gt;　继续Task&lt;/h2&gt;
&lt;p&gt; 　　在Task中，可以实现在一个任务结束后开启另一个新的任务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task t &lt;/span&gt;=&lt;span&gt; Task.Factory.StartNew(Menthod1);
            t.ContinueWith(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Action&amp;lt;Task&amp;gt;&lt;span&gt;(Menthod4));

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod4(Task t)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程4的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里因为使用了委托，也可以使用lambda表达式，更简单一些调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Task t =&lt;span&gt; Task.Factory.StartNew(Menthod1);
        t.ContinueWith(task &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程4的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　使用传统线程方式来进行多线程编程的时候，对线程的控制总是不到位，产生一些奇奇怪怪的问题；或是代码写得很杂乱；或是开发人员乱用线程，比方说无限制的创建线程、将线程池线程占满，等等。&lt;/p&gt;
&lt;p&gt;　　Task的出现，实现对传统线程操作的封装，提供可靠高效的API来控制线程，极大的方便多线程编程，所以可以用到Task的地方尽量使用Task；当然，这里仍会产生线程安全的问题，同样需要进行线程同步，与上一篇处理方式类似。&lt;/p&gt;
&lt;p&gt;　　Task的内容还有很多，更深层的运行原理、封装还等着我们去了解，现在只把我用到的东西分享出来，希望能帮助到需要的人。&lt;/p&gt;
&lt;p&gt;　　线程的学习就先告一段落了，敬请期待新的内容吧。&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 15:37:00 +0000</pubDate>
<dc:creator>愉悦的绅士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nbclw/p/8441317.html</dc:identifier>
</item>
<item>
<title>JSON入门看这一篇就够了 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8445746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8445746.html</guid>
<description>&lt;p&gt;JSON：&lt;strong&gt;JavaScript Object Notation&lt;/strong&gt; 【JavaScript 对象表示法】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON 是存储和交换文本信息的语法。类似 XML。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON采用完全独立于任何程序语言的文本格式，使JSON成为理想的数据交换语言S&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提到JSON，我们就应该和XML来进行对比。XML也是一种存储和交换文本信息的手段。那么JSON好在哪里呢？？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON 比 XML 更小、更快，更易解析&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;javaScript原生支持JSON，解析速度会很快&lt;/li&gt;
&lt;li&gt;XML解析成DOM对象的时候，浏览器【IE和fireFox】会有差异&lt;/li&gt;
&lt;li&gt;使用JSON会更简单&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170518132651669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更加容易创建JavaScript对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'city'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'北京'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'上海'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'广州'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'深圳'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;city&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;city&lt;/span&gt;[i]&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;br/&amp;gt;&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;客户端与服务端的交互数据无非就是两种&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是乎，JSON所表示的数据要么就是对象，要么就是数据&lt;/p&gt;
&lt;p&gt;JSON语法是javaScript语法的子集，&lt;strong&gt;javaScript用[]中括号来表示数组，用{}大括号来表示对象，JSON亦是如此&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;json数组&quot;&gt;JSON数组：&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; employees &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Bill&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Gates&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;George&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Bush&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Thomas&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Carter&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;json对象&quot;&gt;JSON对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;dt&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我爱学习&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;当然啦，数组可以包含对象，在对象中也可以包含数组&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;javaScript原生支持JSON的，&lt;strong&gt;我们可以使用eval()函数来解析JSON，把JSON文本数据转换成一个JavaScript对象。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//在写JOSN的时候，记得把带上逗号&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; txt &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;{a:123,&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;st&quot;&gt;&quot;b:'zhongfucheng'}&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//使用eval解析JSON字符串，需要增添()&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; aa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;eval&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;(&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; txt &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;)&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(aa)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170407091040539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用Strus2的时候，Struts2自带了组件能够让JavaBean对象、集合转成是JSON，不用我们自己拼接...这是非常方便的。&lt;/li&gt;
&lt;li&gt;使用SpringMVC的时候，SpringMVC也支持将JavaBean转成JSON&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，我们不一定使用框架来做开发呀。因此，我们还得&lt;strong&gt;学习使用第三方库来将JavaBean对象、集合转成JSON&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入开发包&quot;&gt;导入开发包&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;commons-io-2.0.1.jar&lt;/li&gt;
&lt;li&gt;commons-lang-2.5.jar&lt;/li&gt;
&lt;li&gt;commons-collections-3.1.jar&lt;/li&gt;
&lt;li&gt;commons-beanutils-1.7.0.jar&lt;/li&gt;
&lt;li&gt;ezmorph-1.0.3.jar&lt;/li&gt;
&lt;li&gt;json-lib-2.1-jdk15.jar&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事例代码&quot;&gt;事例代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package cn.itcast.javaee.js.bean2json;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import net.sf.json.JSONArray;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.*;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 使用第三方工具，将JavaBean对象/List或Set或Map对象转成JSON &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;AdminTC&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestBean2Json {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;javabean2json&lt;/span&gt;() {
        City city = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;);
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(city);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;list2json&lt;/span&gt;() {
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;珠海&quot;&lt;/span&gt;));
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(cityList);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;珠海&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;set2json&lt;/span&gt;() {
        Set&amp;lt;City&amp;gt; citySet = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;City&amp;gt;();
        citySet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;));
        citySet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;珠海&quot;&lt;/span&gt;));
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(citySet);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;珠海&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;javabeanlist2json&lt;/span&gt;() {
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;中山&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;佛山&quot;&lt;/span&gt;));
        Province province = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Province&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广东&quot;&lt;/span&gt;,cityList);
        
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(province);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          [&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;id&quot;:1,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;name&quot;:&quot;广东&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;cityList&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;中山&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;佛山&quot;}],&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          ]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;map2json&lt;/span&gt;() {
        
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;中山&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;佛山&quot;&lt;/span&gt;));
        
        Map&amp;lt;String,Object&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String,Object&amp;gt;();
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;total&quot;&lt;/span&gt;,cityList.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());&lt;span class=&quot;co&quot;&gt;//表示集合的长度&lt;/span&gt;
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;rows&quot;&lt;/span&gt;,cityList);&lt;span class=&quot;co&quot;&gt;//rows表示集合&lt;/span&gt;
        
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(map);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;total&quot;:2,&quot;rows&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;中山&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;佛山&quot;}]}]&lt;/span&gt;
        
        jsonJAVA = jsonJAVA.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,jsonJAVA.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;把要解析成JSON 的javaBena对象、集合放进下面这段代码即可！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(map);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;无论放进去什么，返回的都是数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170518132718061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，可以关注微信公众号:Java3y&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 12 Feb 2018 14:37:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8445746.html</dc:identifier>
</item>
<item>
<title>.net下使用socket.io随笔记录 - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8443395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8443395.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前公司在互联网产品上需要程序与前端部分要进行一个实时交互，在进行一定程度上的选型后，决定使用&lt;a href=&quot;https://socket.io/&quot; target=&quot;_blank&quot;&gt;socket.io&lt;/a&gt;框架进行一个实践，算是公司的一个新的 尝试，也算是给自己增加增长见闻，由于我是做后端以及桌面程序开发，所以前端部分就不细聊，主要是针对桌面程序如何连接socket.io进行一个尝试&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、基本逻辑图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/465472/201802/465472-20180211222553185-1326709745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本地应用程序：部署在局域网内（可以联通外网），主要负责相关数据获取&lt;/p&gt;
&lt;p&gt;　　Web浏览器端：跟本地应用程序不是处于同一个网络，请求发起方&lt;/p&gt;
&lt;p&gt;　　中转服务（重点）：中转服务集成认证功能，必须经过认证的客户端才允许进行连接，并且对于客户端要有唯一指定的ID进行连接操作&lt;/p&gt;
&lt;p&gt;　　整体思路如以上的流程图，由Web浏览器端开始发起请求，Web浏览器端通过连接中转服务，将信息发送给指定的本地应用程序，应用程序处理完成后，将结果通过原路径进行一个反馈&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、客户端程序开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　客户端SDK采用&lt;a href=&quot;https://github.com/Quobject/SocketIoClientDotNet&quot; data-pjax=&quot;#js-repo-pjax-container&quot;&gt;SocketIoClientDotNet&lt;/a&gt;，这是一个github上开源的，可以连接socket.io的客户端，支持.net 3.5及以上，可以方便的帮助我们进行连接socket.io的开发&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 Socket  socket = IO.Socket(&quot;ws://192.168.7.4:3000&quot;, new IO.Options()
            {
                Reconnection = true,
                Cookies = new Dictionary&amp;lt;string, string&amp;gt;() { { &quot;companyId&quot;, GlobalStatic.COMPANY.COMPANY_ID }, { &quot;userId&quot;, GlobalStatic.UserDomain.user.USER_ID } },
                Timeout = 60000,
                ReconnectionDelay = 1000,

                Transports = new List&amp;lt;string&amp;gt;() { &quot;websocket&quot; },
                Path =&quot;heart&quot;
            });

            socket.On(Socket.EVENT_CONNECT, () =&amp;gt;
            {

                JObject jObject = JObject.Parse(Newtonsoft.Json.JsonConvert.SerializeObject(new
                {
                    companyId = GlobalStatic.COMPANY.COMPANY_ID,
                    token = GlobalStatic.TOKEN,
                    hostId = GlobalStatic.HOST_ID,
                    hostName = GlobalStatic.HOST_NAME,
                    printerNames = GlobalStatic.HOSTINFO.PrinterName,
                    source = &quot;assistant&quot;,
                    userId = GlobalStatic.UserDomain.user.USER_ID
                }));
                socket.Emit(&quot;authentication&quot;, jObject);
                Debug.WriteLine(&quot;authentication&quot;);
            });
            socket.On(Socket.EVENT_DISCONNECT, (data) =&amp;gt;
            {
                Debug.WriteLine(&quot;心跳断开连接&quot; + data);
                flag = false;
                OnConnectionStatus?.Invoke(flag);
                socket.Disconnect();
            });
            socket.On(&quot;authenticated&quot;, (obj) =&amp;gt;
            {
                flag = true;
                OnConnectionStatus?.Invoke(flag);
                Debug.WriteLine(&quot;心跳认证成功：&quot; + obj);
            });
            socket.On(&quot;unauthorized&quot;, (obj) =&amp;gt;
            {
                Debug.WriteLine(&quot;心跳认证失败&quot; + obj);
                socket.Disconnect();
            });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SocketIoClientDotNet注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;emit的数据必须为字符串或者JObject（Newtonsoft.Json中的）&lt;/li&gt;
&lt;li&gt;从实际情况来看，内部每个On的监听都是维护了一个线程，所有如果是不想要阻塞的话，那在on的方法中还需要自己起线程去完成&lt;/li&gt;
&lt;li&gt;如果不在options中设置AutoConnect=false的话，那实例化socket成功之后就会进行connect动作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;三、关于SocketIoClientDotNet坑的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在实际的使用过程中，偶然发现在程序开了很久 之后，线程数会一直增多，尝试调节各种参数都毫无作用，最后只能无奈的跟踪源码部分，在Thread文件夹下找到Heartbeat_net35.cs文件中，发现run方法里的while一直无法跳出去，并且注册DoWork越来越多，如下所示，导致线程越来越多，目前解决办法是将该代码注释掉，还没发现什么问题，如果有哪位知道这段代码作用的话，望告知，谢谢&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using System.ComponentModel;
using System.Threading;

namespace Quobject.EngineIoClientDotNet.Thread
{
    public class Heartbeat
    {
        private volatile bool gotHeartbeat = false;
        private BackgroundWorker heartBeatTimer= new BackgroundWorker();
        private CancellationTokenSource ts;

        private Heartbeat()
        {
            ts = new CancellationTokenSource();
        }

        public static Heartbeat Start(Action onTimeout, int timeout)
        {
            Heartbeat heartbeat = new Heartbeat();
            heartbeat.Run(onTimeout, timeout);
            return heartbeat;            
        }

        public void OnHeartbeat()
        {
            gotHeartbeat = true;
        }

        private void Run(Action onTimeout, int timeout)
        {
            heartBeatTimer = new BackgroundWorker();

            heartBeatTimer.DoWork += (s, e) =&amp;gt;
            {
               while (!ts.IsCancellationRequested)
               {
                    System.Threading.Thread.Sleep(timeout);
                    if (!gotHeartbeat &amp;amp;&amp;amp; !ts.IsCancellationRequested)
                    {
                        onTimeout();
                        break;
                    }
                }
            };

            heartBeatTimer.RunWorkerAsync();
        }

        public void Stop()
        {
            ts.Cancel();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docket等互联网相关&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出, &lt;a href=&quot;http://www.cnblogs.com/OMango/p/8443395.html&quot;&gt;原文链接&lt;/a&gt; 如有问题， 可邮件（hongjb@yizit.com）咨询.&lt;/p&gt;



</description>
<pubDate>Mon, 12 Feb 2018 14:13:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8443395.html</dc:identifier>
</item>
<item>
<title>AMDP + XLSX Workbench 报表开发模式 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/8422711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/8422711.html</guid>
<description>&lt;p&gt;本文介绍了我和同事通过使用AMDP + XLSX Workbench缩短报表开发周期、分离数据查询处理逻辑和前端展示工作的经验。欢迎讨论。&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近接到了一套人力资源报表的开发需求，需要以EXCEL表格的方式输出，且包含大量sheet页，每个sheet相当于一个独立的报表。&lt;/p&gt;
&lt;p&gt;这种情况下，如果让同一个人开发所有内容，将会花费较长的开发周期，因此，要将程序分解成若干个部分，最好每个报表（sheet）都是一个独立的子模块，让不同的人同时开发。&lt;/p&gt;
&lt;p&gt;对于这类报表，我们之前的做法是，使用OLE输出EXCEL文件，在report程序中，使用逻辑数据库获取数据，引入常用的OLE方法，为每个sheet创建一个include文件，实现不同sheet的代码分离。&lt;/p&gt;
&lt;p&gt;代码类似这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;REPORT&lt;/span&gt;&lt;span&gt; zhr_report .

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;***********************************************************************&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; INCLUDES&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;***********************************************************************&lt;/span&gt;
&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_top.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//数据定义&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_s01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//选择屏幕```````````&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; z_ole_excel_hr.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//通用EXCEL操作子程序&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_m01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//事件&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_f01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//通用模块&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex01.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet1&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report ex02.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet2&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex03.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet3&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex04.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet4&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;INCLUDE &lt;span&gt;zhr_report_ex05&lt;/span&gt;.  &lt;span&gt;&quot;&lt;span&gt;//Sheet5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212200519874-1852854270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过将通用的OLE方法封装到一个包含文件中，并使sheet页的处理放到不同的包含文件，可以使对它们的同时编辑成为可能。但是，这种做法也是有问题的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;包含文件不是单独的程序，这意味着只要有一个include文件中有语法错误，语法检查时就会给出提示，从而无法激活整个程序。&lt;/li&gt;
&lt;li&gt;命名空间相同，这意味着定义子程序或FORM名时，很容易发生冲突&lt;/li&gt;
&lt;li&gt;只能通过增加包含文件实现程序的横向扩展，较难实现程序的纵向扩展。通用部分一旦确定，再想修改会比较困难。&lt;/li&gt;
&lt;li&gt;OLE的性能较差。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决这些问题，我们引入了AMDP + XLSX Workbench的报表开发模式。&lt;/p&gt;
&lt;p&gt;改进后的模式示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180210153705920-1446687735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: AMDP + XSLX Workbench 报表开发模式&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/8422711.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/8422711.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;名词解释&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;AMDP&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;全称ABAP-Managed Database Procedure，一种ABAP on HANA的实现方式，提供了在ABAP中运行SQL Script的可能，并且与ABAP中的类和数据类型有良好的集成。之前的有关AMDP的文章：&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/7976533.html&quot;&gt;ABAP中的AMDP（ABAP-Managed Database Procedures ）&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;XLSX Workbench&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;一种可视化表单生成工具，相比复杂的OLE，可以用少量代码+一些拖拽和配置来生成EXCEL报表，性能更好。按XLSX Workbench的文档介绍，它有九大特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无需ABAP编程技能&lt;/li&gt;
&lt;li&gt;可视化设计方式&lt;/li&gt;
&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;支持后台处理&lt;/li&gt;
&lt;li&gt;强大的表单格式特性支持&lt;/li&gt;
&lt;li&gt;支持公式&lt;/li&gt;
&lt;li&gt;支持图片&lt;/li&gt;
&lt;li&gt;支持图表&lt;/li&gt;
&lt;li&gt;支持树&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;官方文档：&lt;a href=&quot;https://sites.google.com/site/sapxlwb/home&quot; target=&quot;_blank&quot;&gt;https://sites.google.com/site/sapxlwb/home&lt;/a&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;代码例子&lt;/h2&gt;
&lt;p&gt;注意，本部分内容会假设读者已经有使用AMDP的XLSX Workbench的初步经验（至少是能输出Hello World的水平）。如果不是这样的话，可能会对其中的某些内容感到困惑。&lt;/p&gt;
&lt;p&gt;1，首先，创建一个接口ZIF_XLSX_REPORT。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INTERFACE&lt;/span&gt;&lt;span&gt; zif_xlsx_report

  &lt;/span&gt;&lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt; .

  &lt;/span&gt;&lt;span&gt;METHODS&lt;/span&gt;&lt;span&gt; get_data&lt;/span&gt;&lt;span&gt;CHANGING&lt;/span&gt;&lt;span&gt;
      !data            &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; sflight_t
    &lt;span&gt;RAISING&lt;/span&gt;
      cx_amdp_error .

&lt;/span&gt;&lt;span&gt;ENDINTERFACE&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口包含一个get_data方法，方法有一个参数&lt;span&gt;data，它数据类型，即为将要输出给XLSX Workbench表单的的数据类型。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2，为接口创建实现类。&lt;/p&gt;
&lt;p&gt; 为接口创建一个实现类，在方法ZIF_XLSX_REPORT~GET_DATA中调用AMDP类方法，进行数据处理后，将得到的数据填充进chaging参数data中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CLASS&lt;/span&gt; zcl_xlsx_report1 &lt;span&gt;DEFINITION&lt;/span&gt;

  &lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt;
  FINAL
  &lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt; .

  &lt;/span&gt;&lt;span&gt;PUBLIC&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.

    &lt;/span&gt;&lt;span&gt;INTERFACES&lt;/span&gt;&lt;span&gt; zif_xlsx_report .
  &lt;/span&gt;&lt;span&gt;PROTECTED&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.
  &lt;/span&gt;&lt;span&gt;PRIVATE&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;ENDCLASS&lt;/span&gt;&lt;span&gt;.



&lt;/span&gt;&lt;span&gt;CLASS&lt;/span&gt; ZCL_XLSX_REPORT1 &lt;span&gt;IMPLEMENTATION&lt;/span&gt;&lt;span&gt;.


&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &amp;lt;SIGNATURE&amp;gt;---------------------------------------------------------------------------------------+&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | Instance Public Method ZCL_XLSX_REPORT1-&amp;gt;ZIF_XLSX_REPORT~GET_DATA&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; +-------------------------------------------------------------------------------------------------+&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | [&amp;lt;--&amp;gt;] DATA                           TYPE        SFLIGHT_T&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | [!CX!] CX_AMDP_ERROR&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; +--------------------------------------------------------------------------------------&amp;lt;/SIGNATURE&amp;gt;&lt;/span&gt;
  &lt;span&gt;METHOD&lt;/span&gt;&lt;span&gt; zif_xlsx_report~get_data.


    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用AMDP类的方法&lt;/span&gt;

    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据处理&lt;/span&gt;


  &lt;span&gt;ENDMETHOD&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;ENDCLASS&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，在report程序中调用各个实现类。&lt;/p&gt;

&lt;p&gt;这是关键的一步：在report程序中动态地获取全部实现类，并依次实例化、调用其接口方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;CONSTANTS&lt;/span&gt;: c_interface &lt;span&gt;TYPE&lt;/span&gt; seoclsname VALUE &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZIF_XLSX_REPORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;TRY&lt;/span&gt;&lt;span&gt;.

      &lt;/span&gt;&lt;span&gt;DATA&lt;/span&gt;(gt_classes) = cl_sic_configuration=&amp;gt;&lt;span&gt;get_classes_for_interface( c_interface ).

    &lt;/span&gt;&lt;span&gt;CATCH&lt;/span&gt;&lt;span&gt; cx_class_not_existent .

  &lt;/span&gt;&lt;span&gt;ENDTRY&lt;/span&gt;&lt;span&gt;.


  &lt;/span&gt;&lt;span&gt;LOOP&lt;/span&gt; &lt;span&gt;AT&lt;/span&gt; gt_classes &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;DATA&lt;/span&gt;&lt;span&gt;(gs_class).

    &lt;/span&gt;&lt;span&gt;TRY&lt;/span&gt;&lt;span&gt; .

        &lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;OBJECT&lt;/span&gt; go_ref &lt;span&gt;TYPE&lt;/span&gt; (gs_class-&lt;span&gt;clsname).

      &lt;/span&gt;&lt;span&gt;CATCH&lt;/span&gt;&lt;span&gt; cx_sy_create_object_error.

    &lt;/span&gt;&lt;span&gt;ENDTRY&lt;/span&gt;&lt;span&gt;.

    &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; go_ref &lt;span&gt;IS&lt;/span&gt;&lt;span&gt; BOUND.

          go_ref&lt;/span&gt;-&amp;gt;get_data( &lt;span&gt;CHANGING&lt;/span&gt; data =&lt;span&gt; g_data_structure ).

    &lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

  &lt;/span&gt;&lt;span&gt;ENDLOOP&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;由于XLSX Workbench中的一个表单在同一时间只能由一个人编辑，对于多sheet页的表格，无法让两个人并行开发表单。但是，因为表单独立于ABAP 程序，二者只需要通过约定好的内表结构（在示例中是SFLIGHT_T）通信。因此，可以在约定好通信结构的前提下，由一个人进行XLSX Workbench中表单的组件编辑、上下文绑定等工作，另一个（或多个）人进行数据逻辑处理工作。如果在引入了HANA开发人员，还可以把主要逻辑下推至HANA，从而使多人同时在不同层级上开发同一个套表，以提高总体开发速度。&lt;/li&gt;
&lt;li&gt;将每个sheet页写成一个类，所有类继承同一个接口，在report程序中动态地调用，可以将报表主程序的代码稳定下来，实现程序的解耦。不同的类之间也是个例的，可以方便地进行单独的单元测试，而不会在语法检查时受到其他人的开发内容的干扰。&lt;/li&gt;
&lt;li&gt;相比于本文开头提到的INCLUDE的方式，使用面向对象的新开发模式不仅提供了更好的横向扩展能力（只要增加新的实现类和结构字段即可实现数据处理逻辑和报表内容的扩展），而且也提供了更好的纵向扩展能力，可以通过面向对象的强大特性——继承——来实现对报表中相似部分进行抽象整合。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 align=&quot;left&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;总结了几点我们在实际开发中的经验，以供参考。&lt;/p&gt;
&lt;h3&gt;AMDP与SELECT-OPTIONS&lt;/h3&gt;
&lt;p&gt;细心的读者可能已经注意到上文的示例代码中并未处理选择屏幕这一关键问题。在Open SQL中我们可以很方便地直接使用range table。而在AMDP中使用它话需要一点点额外的代码：&lt;/p&gt;
&lt;p&gt;可以通过CL_SHDB_SELTAB=&amp;gt;COMBINE_SELTABS( )来将选择屏幕的输入条件转换为AMDP中的SQL Script中的WHERE条件字符串，并使用APPLY_FILTER函数应用这一条件，具体的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212211244062-1981454659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212211253890-893579063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（引用自 &lt;a href=&quot;https://blogs.sap.com/2015/03/30/handling-of-select-options-parameters-within-amdp/&quot; target=&quot;_blank&quot;&gt;Handling of SELECT-OPTIONS parameters within AMDP&lt;/a&gt;）&lt;/p&gt;
&lt;h3&gt;异常处理&lt;/h3&gt;
&lt;p&gt;在本文介绍的开发模式下，HANA视图、XLSX Workbench表单和ABAP类是可以并行开发的，这意味着开发阶段的HANA视图可能处于不稳定的状态。ABAP开发者应注意在AMDP方法中显式地声明异常、并在调用它是进行处理。不然会很容易遇到程序dump的情况:)&lt;/p&gt;
&lt;p&gt;具体的异常可见：&lt;a href=&quot;http://www.cnblogs.com/hhelibeb/p/7976533.html#_label4&quot;&gt;AMDP异常&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;自建结构/表命名&lt;/h3&gt;
&lt;p&gt;无论是AMDP方法还是XLSX Workbench表单，在实践中都需要自建结构/表来接收数据。在开发内容分离的情况下，&lt;strong&gt;作为通信定义的结构/表类型的命名尤其重要&lt;/strong&gt;。应当有一套合理的规则来为它们以及其中的字段命名。特别是XLSX Workbench表单的参数结构，在表单复杂的情况下，参数结构同样会是复杂的深度结构。如果命名不当的话，将会给开发和沟通带来相当的负担。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: AMDP + XSLX Workbench 报表开发模式&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/8422711.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/8422711.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 13:38:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/8422711.html</dc:identifier>
</item>
<item>
<title>Go基础之--接口 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8445614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8445614.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;在Go语言中，一个类只要实现了接口要求的所有函数，我们就说这个类实现了该接口&lt;/p&gt;
&lt;p&gt;interface类型可以定义一组方法，用来表示一个对象的行为特征，interface不能包含任何变量，接口是引用类型。&lt;/p&gt;
&lt;p&gt;举个简单的例子，一个动物的接口，动物有吃的能力，有叫的能力，等等，这里省略，假如动物就只有吃和叫的能力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;

type Animal interface {
    Eat()
    Talk()
}

type Dog struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;dog eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;dog talking....&quot;&lt;span&gt;)
}

type Cat struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Cat) Eat(){
    fmt.Println(&lt;/span&gt;&quot;cat eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Cat) Talk(){
    fmt.Println(&lt;/span&gt;&quot;cat talking....&quot;&lt;span&gt;)
}



func main(){
    var d Dog

    var a Animal
    a &lt;/span&gt;= &amp;amp;&lt;span&gt;d
    a.Eat()
    a.Talk()

    var c Cat
    a &lt;/span&gt;= &amp;amp;&lt;span&gt;c
    a.Eat()
    a.Talk()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子中，Cat和Dog实现了Animal的所有方法，所以Cat和Dog都是动物&lt;/p&gt;
&lt;p&gt;小结一下：&lt;br/&gt;Go中的接口不需要显示的实现，只要一个对象实现了接口类型中的所有方法，那么这个对象就实现了这个接口，当然如果一个对象实现了多个interface类型的方法，那么这个对象就实现了多个接口&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;用于理解接口的一个例子&lt;/h2&gt;
&lt;p&gt;我们都知道现在的手机有很多支付方式，如：微信支付，支付宝支付，银联支付等等，这里可以通过一个实现支付接口的例子来理解接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; 定义一个支付的接口
type Pay interface {
    pay(userId int64,money float32) error
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个struct
type AliPay struct {

}
&lt;/span&gt;//&lt;span&gt; 这里给AliPay添加一个支付方法，实现了Pay接口中的pay方法
func (a &lt;/span&gt;*&lt;span&gt;AliPay) pay(userId int64,money float32) error{
    fmt.Println(&lt;/span&gt;&quot;1.连接到阿里支付的服务器&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;2.连接到对应的用户&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;3.检查余额&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;4.扣钱&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;5.返回支付是否成功&quot;&lt;span&gt;)

    return nil
}

&lt;/span&gt;//&lt;span&gt; 微信支付
type WeChatPay struct {

}

&lt;/span&gt;//&lt;span&gt; 这里也是实现了Pay接口中的pay方法
func (w &lt;/span&gt;*&lt;span&gt;WeChatPay) pay(userId int64,money float32) error{
    fmt.Println(&lt;/span&gt;&quot;1.连接到微信支付的服务器&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;2.连接到对应的用户&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;3.检查余额&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;4.扣钱&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;5.返回支付是否成功&quot;&lt;span&gt;)

    return nil
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个手机struct,并通过字典方式存储自己开通的支付方式
type Phone struct {
   PayMap map[string]Pay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) OpenWeChatPay(){
    weChatPay :&lt;/span&gt;= &amp;amp;&lt;span&gt;WeChatPay{}
    p.PayMap[&lt;/span&gt;&quot;weChatPay&quot;] =&lt;span&gt; weChatPay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) OpenAliPay(){
    AliPay :&lt;/span&gt;= &amp;amp;&lt;span&gt;AliPay{}
    p.PayMap[&lt;/span&gt;&quot;aLiPay&quot;] =&lt;span&gt; AliPay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) PayMoney(name string,money float32)(err error){
    pay,ok:&lt;/span&gt;=&lt;span&gt; p.PayMap[name]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok{
        err &lt;/span&gt;= fmt.Errorf(&quot;不支持【%s】支付方式&quot;&lt;span&gt;,name)
        return
    }
    err &lt;/span&gt;= pay.pay(1024&lt;span&gt;,money)
    return
}


func main(){
    &lt;/span&gt;//&lt;span&gt; 这里切记 字典类型的数据是需要初始化的
    phone :&lt;/span&gt;= &amp;amp;&lt;span&gt;Phone{
        PayMap:make(map[string]Pay,&lt;/span&gt;10&lt;span&gt;),
}

    &lt;/span&gt;//&lt;span&gt; 这里是用于开通自己有哪些支付方式
    &lt;/span&gt;//&lt;span&gt;phone.OpenWeChatPay()
    phone.OpenAliPay()


    err :&lt;/span&gt;= phone.PayMoney(&quot;weChatPay&quot;,100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        &lt;/span&gt;//&lt;span&gt; 如果微信支付失败了，用支付宝支付
        fmt.Printf(&lt;/span&gt;&quot;支付失败，失败原因：%v\n&quot;&lt;span&gt;,err)
        fmt.Println(&lt;/span&gt;&quot;使用支付宝支付&quot;&lt;span&gt;)
        err &lt;/span&gt;= phone.PayMoney(&quot;aLiPay&quot;,100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
            fmt.Printf(&lt;/span&gt;&quot;支付失败，失败原因：%v\n&quot;&lt;span&gt;,err)
            return
        }
    }
    fmt.Println(&lt;/span&gt;&quot;支付成功，欢迎再次光临&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然可以把上面中关于开通支付方式的两个方法，用一个通用的方法实现，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
func (p *&lt;span&gt;Phone) OpenPay(name string,pay Pay){
    &lt;/span&gt;//&lt;span&gt; 可以把上面两个方法更改为这一个方法
    p.PayMap[name] &lt;/span&gt;=&lt;span&gt; pay
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;空接口&lt;/h2&gt;
&lt;p&gt;空接口没有任何方法，所有的类型都实现了空接口,空接口什么类型都可以存，如下例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main


import &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;

func main()  {
    &lt;/span&gt;//&lt;span&gt; 通过这个例子我们可以发现我们定义的一个空接口可以存任何类型的变量
    var a interface{}
    var b &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; = 10&lt;span&gt;
    a &lt;/span&gt;=&lt;span&gt; b
    fmt.Println(a)

    var c string &lt;/span&gt;= &quot;hello&quot;&lt;span&gt;
    a &lt;/span&gt;=&lt;span&gt; c
    fmt.Println(a)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;接口的嵌套&lt;/h2&gt;
&lt;p&gt;一个接口可以嵌套在另外的接口里面，同时一个接口也可以嵌套多个接口&lt;br/&gt;通过下面的例子来理解接口嵌套的概念&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&quot;fmt&quot;

//&lt;span&gt; 这里定义一个Eater接口
type Eater interface {
    Eat()
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个Talker接口
type Talker interface {
    Talk()
}

&lt;/span&gt;//&lt;span&gt; 这里定义个动物的接口，同时嵌套了Eater和Talker接口
type Animal interface {
    Eater
    Talker
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个Dog的struct，并实现talk方法和eat方法，这样就实现了动物的接口
type Dog struct {

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;talk....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;eating....&quot;&lt;span&gt;)
}

func main() {
    d :&lt;/span&gt;= &amp;amp;&lt;span&gt;Dog{}
    var a Animal
    a &lt;/span&gt;=&lt;span&gt; d
    a.Eat()
    a.Talk()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;类型断言&lt;/h2&gt;
&lt;p&gt;如果我们反向想要知道这个接口变量里面实际存储的是哪个类型的对象，可以用下面方法：&lt;br/&gt;通过下面这个例子理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;
)

type Animal interface {
    Eat()
    Talk()
}

type Dog struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;dog eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;dog talking....&quot;&lt;span&gt;)
}

type Cat struct{

}

func (c &lt;/span&gt;*&lt;span&gt;Cat) Eat(){
    fmt.Println(&lt;/span&gt;&quot;cat eating.....&quot;&lt;span&gt;)
}

func (c &lt;/span&gt;*&lt;span&gt;Cat) Talk(){
    fmt.Println(&lt;/span&gt;&quot;cat talking....&quot;&lt;span&gt;)
}

func justify(a Animal){
    &lt;/span&gt;//&lt;span&gt; 进行强制转换，如果转换失败则提示错误
    dog,ok :&lt;/span&gt;= a.(*&lt;span&gt;Dog)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok{
        fmt.Println(&lt;/span&gt;&quot;convert to dog failed&quot;&lt;span&gt;)
        return
    }
    dog.Eat()
}

func main()  {
    &lt;/span&gt;//&lt;span&gt; 分别实例化一个Dog和Cat,并通过justify来进行判断
    d :&lt;/span&gt;= &amp;amp;&lt;span&gt;Dog{}
    var a Animal
    a &lt;/span&gt;=&lt;span&gt; d
    a.Eat()
    justify(a)

    c :&lt;/span&gt;= &amp;amp;&lt;span&gt;Cat{}
    a &lt;/span&gt;=&lt;span&gt; c
    justify(a)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再写一个例子，用于判断函数中传入的参数的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;
)
&lt;/span&gt;//&lt;span&gt; 这里通过...interface{}表示传入的是可变参数
func justify(items ...interface{}){
    for index,v :&lt;/span&gt;=&lt;span&gt; range items{
       &lt;/span&gt;//&lt;span&gt;v.(type)表示获取变量的类型
        switch v.(type){
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is int\n&quot;&lt;span&gt;,index)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; float32:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is float32\n&quot;&lt;span&gt;,index)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; string:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is string\n&quot;&lt;span&gt;,index)
        }
    }
}

func main() {
    var a float32
    var b string
    var c &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    justify(a,b,c)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于猫和狗代码例子中justify方法还可以更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func justify2(a Animal){
    switch t:&lt;/span&gt;=&lt;span&gt;a.(type){
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; *&lt;span&gt;Dog:
        t.Eat()
        fmt.Printf(&lt;/span&gt;&quot;t is Dog\n&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; *&lt;span&gt;Cat:
        t.Eat()
        fmt.Printf(&lt;/span&gt;&quot;t is Cat\n&quot;&lt;span&gt;)
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;判断一个变量是否实现了指定的接口&lt;/h2&gt;
&lt;p&gt;在最开始的时候写了一个关于理解接口的例子，如果我们现在想要判断一个变量是否实现了指定的支付的接口，可以通过如下代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
weChat := &amp;amp;&lt;span&gt;WeChatPay{}
&lt;/span&gt;//&lt;span&gt; 这里需要一个空接口
var tmp interface{} &lt;/span&gt;=&lt;span&gt; weChat
_,ok :&lt;/span&gt;=&lt;span&gt; tmp.(Pay)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ok{
    fmt.Println(&lt;/span&gt;&quot;weChat is implement Pay interface&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Feb 2018 13:35:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8445614.html</dc:identifier>
</item>
<item>
<title>spring security 4 filter 顺序及作用 - snowater</title>
<link>http://www.cnblogs.com/snowater/p/8443100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowater/p/8443100.html</guid>
<description>&lt;p&gt;Spring Security 有两个作用：认证和授权&lt;/p&gt;
&lt;h2&gt;一、Srping security 4 filter 别名及顺序&lt;/h2&gt;
&lt;p&gt;spring security 4 标准filter别名和顺序，因为经常要用就保存到自己博客吧  &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/4.2.4.RELEASE/reference/html/ns-config.html#ns-custom-filters&quot; target=&quot;_blank&quot;&gt;点击访问官网链接&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;strong&gt;Table 6.1. Standard Filter Aliases and Ordering&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;table-contents&quot;&gt;
&lt;table summary=&quot;Standard Filter Aliases and Ordering&quot; align=&quot;left&quot;&gt;&lt;colgroup&gt;&lt;col class=&quot;col_1&quot;/&gt;&lt;col class=&quot;col_2&quot;/&gt;&lt;col class=&quot;col_3&quot;/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Alias&lt;/th&gt;
&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Filter Class&lt;/th&gt;
&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Namespace Element or Attribute&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CHANNEL_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ChannelProcessingFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/intercept-url@requires-channel&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;SECURITY_CONTEXT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SecurityContextPersistenceFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;CONCURRENT_SESSION_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ConcurrentSessionFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;session-management/concurrency-control&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;HEADERS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;HeaderWriterFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/headers&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CSRF_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;CsrfFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/csrf&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;LOGOUT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;LogoutFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/logout&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;X509_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;X509AuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/x509&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;PRE_AUTH_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;AbstractPreAuthenticatedProcessingFilter&lt;/code&gt;Subclasses&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CAS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;CasAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;FORM_LOGIN_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/form-login&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;BASIC_AUTH_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;BasicAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/http-basic&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SERVLET_API_SUPPORT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SecurityContextHolderAwareRequestFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/@servlet-api-provision&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;JAAS_API_SUPPORT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;JaasApiIntegrationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/@jaas-api-provision&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;REMEMBER_ME_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;RememberMeAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/remember-me&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;ANONYMOUS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;AnonymousAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/anonymous&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SESSION_MANAGEMENT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SessionManagementFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;session-management&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;EXCEPTION_TRANSLATION_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ExceptionTranslationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;FILTER_SECURITY_INTERCEPTOR&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;FilterSecurityInterceptor&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;SWITCH_USER_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SwitchUserFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

























&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;二、Spring security filter作用&lt;/h2&gt;
&lt;h3&gt;2.1 默认filter链&lt;/h3&gt;
&lt;p&gt;在程序启动时会打印出如下日志，该日志打印出了默认的filter链和顺序，其中SecurityContextPersistenceFilter为第一个filter，FilterSecurityInterceptor为最后一个filter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
2018-02-11 15:24:17,204  INFO DefaultSecurityFilterChain - Creating filter chain: 
org.springframework.security.web.util.matcher.AnyRequestMatcher@1, 
[org.springframework.security.web.context.SecurityContextPersistenceFilter@3cf3957d, 
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@7ff34bd, 
org.springframework.security.web.header.HeaderWriterFilter@4dad11a2, 
org.springframework.security.web.authentication.logout.LogoutFilter@5be6ee89, 
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@5426eed3, 
org.springframework.security.web.savedrequest.RequestCacheAwareFilter@5da2a66c, 
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@23169e35, 
org.springframework.security.web.session.SessionManagementFilter@5b1627ea, 
org.springframework.security.web.access.ExceptionTranslationFilter@70b913f5, 
org.springframework.security.web.access.intercept.FilterSecurityInterceptor@2dfe7327]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 默认filter链作用&lt;/h3&gt;
&lt;p&gt;默认有10条过滤链，下面逐个看下去。&lt;/p&gt;
&lt;h4&gt;2.2.1 /index.html at position 1 of 10 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter'&lt;/h4&gt;
&lt;p&gt;SecurityContextPersistenceFilter 两个主要职责：&lt;/p&gt;
&lt;p&gt;a.请求到来时，通过HttpSessionSecurityContextRepository接口从Session中读取SecurityContext，如果读取结果为null，则创建之。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; requestResponseHolder.getRequest();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; requestResponseHolder.getResponse();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpSession httpSession = request.getSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从session中获取SecurityContext&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         SecurityContext context =&lt;span&gt; readSecurityContextFromSession(httpSession);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;No SecurityContext was available from the HttpSession: &quot;
&lt;span&gt;11&lt;/span&gt;                         + httpSession + &quot;. &quot; + &quot;A new one will be created.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未读取到SecurityContext则新建一个SecurityContext&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             context =&lt;span&gt; generateNewContext();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         SaveToSessionResponseWrapper wrappedResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SaveToSessionResponseWrapper(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 response, request, httpSession != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, context);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        requestResponseHolder.setResponse(wrappedResponse);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isServlet3) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             requestResponseHolder.setRequest(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Servlet3SaveToSessionRequestWrapper(
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    request, wrappedResponse));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获得SecurityContext之后，会将其存入SecurityContextHolder，其中SecurityContextHolder默认是ThreadLocalSecurityContextHolderStrategy实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((strategyName == &lt;span&gt;null&lt;/span&gt;) || &quot;&quot;&lt;span&gt;.equals(strategyName)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set default&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             strategyName =&lt;span&gt; MODE_THREADLOCAL;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (strategyName.equals(MODE_THREADLOCAL)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             strategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocalSecurityContextHolderStrategy();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下内容省略&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ThreadLocalSecurityContextHolderStrategy中的ContextHolder定义如下，注意这是一个ThreadLocal变量，线程局部变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SecurityContext&amp;gt; contextHolder = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SecurityContext&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.请求结束时清空SecurityContextHolder，并将SecurityContext保存到Session中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             SecurityContext contextAfterChainExecution =&lt;span&gt; SecurityContextHolder
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                    .getContext();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Crucial removal of SecurityContextHolder contents - do this before anything
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; else.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.clearContext();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            repo.saveContext(contextAfterChainExecution, holder.getRequest(),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    holder.getResponse());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            request.removeAttribute(FILTER_APPLIED);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 logger.debug(&quot;SecurityContextHolder now cleared, as request processing completed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.2 /index.html at position 2 of 10 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter'&lt;/h4&gt;
&lt;p&gt;提供了对securityContext和WebAsyncManager的集成，其会把SecurityContext设置到异步线程中，使其也能获取到用户上下文认证信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilterInternal(HttpServletRequest request,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            HttpServletResponse response, FilterChain filterChain)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         WebAsyncManager asyncManager =&lt;span&gt; WebAsyncUtils.getAsyncManager(request);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         SecurityContextCallableProcessingInterceptor securityProcessingInterceptor =&lt;span&gt; (SecurityContextCallableProcessingInterceptor) asyncManager
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                .getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (securityProcessingInterceptor == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecurityContextCallableProcessingInterceptor());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        filterChain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.3 /index.html at position 3 of 10 in additional filter chain; firing Filter: 'HeaderWriterFilter'&lt;/h4&gt;
&lt;p&gt;用来给http response添加一些Header，比如X-Frame-Options、X-XSS-Protection*、X-Content-Type-Options。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilterInternal(HttpServletRequest request,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            HttpServletResponse response, FilterChain filterChain)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         HeaderWriterResponse headerWriterResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeaderWriterResponse(request,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 response, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.headerWriters);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            filterChain.doFilter(request, headerWriterResponse);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向response header中添加header&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            headerWriterResponse.writeHeaders();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.4 /index.html at position 4 of 10 in additional filter chain; firing Filter: 'LogoutFilter'&lt;/h4&gt;
&lt;p&gt;处理退出登录的Filter，如果请求的url为/logout则会执行退出登录操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否需要logout，判断request url是否匹配/logout&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (requiresLogout(request, response)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Authentication auth =&lt;span&gt; SecurityContextHolder.getContext().getAuthentication();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;Logging out user '&quot; +&lt;span&gt; auth
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         + &quot;' and transferring to logout destination&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行一系列的退出登录操作&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (LogoutHandler handler : handlers) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                handler.logout(request, response, auth);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 退出成功，执行logoutSuccessHandler进行重定向等操作&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            logoutSuccessHandler.onLogoutSuccess(request, response, auth);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.5 /index.html at position 5 of 10 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter'&lt;/h4&gt;
&lt;p&gt;表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的UsernamePasswordAuthenticationFilter，在整个Spring Security的认证体系中则扮演着至关重要的角色。&lt;/p&gt;
&lt;p&gt;UsernamePasswordAuthenticationFilter是继承自AbstractAuthenticationProcessingFilter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否需要执行登录认证，判断request url 是否能匹配/login&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;requiresAuthentication(request, response)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             logger.debug(&quot;Request is to process authentication&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        Authentication authResult;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationFilter 实现该方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             authResult =&lt;span&gt; attemptAuthentication(request, response);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (authResult == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类未完成认证，立即返回&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            sessionStrategy.onAuthentication(authResult, request, response);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在认证过程中抛出异常&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InternalAuthenticationServiceException failed) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            logger.error(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &quot;An internal error occurred while trying to authenticate the user.&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    failed);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            unsuccessfulAuthentication(request, response, failed);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException failed) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication failed&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            unsuccessfulAuthentication(request, response, failed);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication success&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (continueChainBeforeSuccessfulAuthentication) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        successfulAuthentication(request, response, chain, authResult);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在UsernamePasswordAuthenticationFilter中实现了类attemptAuthentication，不过该类只实现了一个非常简化的版本，如果真的需要通过表单登录，是需要自己继承UsernamePasswordAuthenticationFilter并重载attemptAuthentication方法的。&lt;/p&gt;
&lt;p&gt;在AbstractAuthenticationProcessingFilter的doFilter方法中一开始是判断是否有必要进入到认证filter，这个过程其实是判断request url是否匹配/login，当然也可以通过filterProcessesUrl属性去配置匹配所使用的pattern。&lt;/p&gt;
&lt;h4&gt;2.2.6 /index.html at position 6 of 10 in additional filter chain; firing Filter: 'RequestCacheAwareFilter'&lt;/h4&gt;
&lt;p&gt;将request存到session中，用于缓存request请求，可以用于恢复被登录而打断的请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest request, ServletResponse response,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从session中获取与当前request匹配的缓存request，并将缓存request从session删除&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         HttpServletRequest wrappedSavedRequest =&lt;span&gt; requestCache.getMatchingRequest(
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                (HttpServletRequest) request, (HttpServletResponse) response);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;// 如果requestCache中缓存了request，则使用缓存的request&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         chain.doFilter(wrappedSavedRequest == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; request : wrappedSavedRequest,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;                response);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处从session中取出request，存储request是在ExceptionTranslationFilter中。具体可以参考&lt;a href=&quot;https://blog.coding.net/blog/Explore-the-cache-request-of-Security-Spring&quot; target=&quot;_blank&quot;&gt;探究 Spring Security 缓存请求&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;2.2.7 /index.html at position 7 of 10 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter'&lt;/h4&gt;
&lt;p&gt;此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         chain.doFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestFactory.create((HttpServletRequest) req,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                (HttpServletResponse) res), res);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.8 /index.html at position 8 of 10 in additional filter chain; firing Filter: 'SessionManagementFilter'&lt;/h4&gt;
&lt;p&gt;和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止&lt;code&gt;session-fixation protection attack&lt;/code&gt;，以及限制同一用户开启多个会话的数量&lt;/p&gt;
&lt;p&gt;与登录认证拦截时作用一样，持久化用户登录信息，可以保存到session中，也可以保存到cookie或者redis中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (request.getAttribute(FILTER_APPLIED) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        request.setAttribute(FILTER_APPLIED, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;securityContextRepository.containsContext(request)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Authentication authentication =&lt;span&gt; SecurityContextHolder.getContext()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    .getAuthentication();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (authentication != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;trustResolver.isAnonymous(authentication)) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The user has been authenticated during the current request, so call the
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; session strategy&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    sessionAuthenticationStrategy.onAuthentication(authentication,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                            request, response);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SessionAuthenticationException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The session strategy can reject the authentication&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    logger.debug(
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             &quot;SessionAuthenticationStrategy rejected the authentication object&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            e);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    SecurityContextHolder.clearContext();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    failureHandler.onAuthenticationFailure(request, response, e);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eagerly save the security context to make it available for any possible
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-entrant
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; requests which may occur before the current request completes.
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SEC-1396.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                securityContextRepository.saveContext(SecurityContextHolder.getContext(),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        request, response);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No security context or authentication present. Check for a session
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (request.getRequestedSessionId() != &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                         &amp;amp;&amp;amp; !&lt;span&gt;request.isRequestedSessionIdValid()) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         logger.debug(&quot;Requested session ID &quot;
&lt;span&gt;48&lt;/span&gt;                                 + request.getRequestedSessionId() + &quot; is invalid.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (invalidSessionStrategy != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                        invalidSessionStrategy
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                                .onInvalidSessionDetected(request, response);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.9 /index.html at position 9 of 10 in additional filter chain; firing Filter: 'ExceptionTranslationFilter'&lt;/h4&gt;
&lt;p&gt;异常拦截，其处在Filter链后部分，只能拦截其后面的节点并且只处理AuthenticationException与AccessDeniedException两个异常。&lt;/p&gt;
&lt;p&gt;AuthenticationException指的是未登录状态下访问受保护资源，AccessDeniedException指的是登陆了但是由于权限不足（比如普通用户访问管理员界面）。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接执行后面的filter，并捕获异常&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             logger.debug(&quot;Chain processed normally&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从异常堆栈中提取SpringSecurityException&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             Throwable[] causeChain =&lt;span&gt; throwableAnalyzer.determineCauseChain(ex);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             RuntimeException ase =&lt;span&gt; (AuthenticationException) throwableAnalyzer
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     .getFirstThrowableOfType(AuthenticationException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, causeChain);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ase == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 ase =&lt;span&gt; (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         AccessDeniedException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, causeChain);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ase != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                handleSpringSecurityException(request, response, chain, ase);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rethrow ServletExceptions and RuntimeExceptions as-is&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletException) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (ServletException) ex;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) ex;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wrap other Exceptions. This shouldn't actually happen
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; as we've already covered all the possibilities for doFilter&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(ex);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个catch代码中通过从异常堆栈中捕获到Throwable[]，然后通过handleSpringSecurityException方法处理异常，在该方法中只会去处理AuthenticationException和AccessDeniedException异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AuthenticationException) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 认证异常，由sendStartAuthentication方法发起认证过程&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             logger.debug(&quot;Authentication exception occurred; redirecting to authentication entry point&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            sendStartAuthentication(request, response, chain, (AuthenticationException) exception);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AccessDeniedException) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问权限异常&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (authenticationTrustResolver.isAnonymous(SecurityContextHolder.getContext().getAuthentication())) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;Access is denied (user is anonymous); redirecting to authentication entry point&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匿名用户重定向到认证入口点执行认证过程&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 sendStartAuthentication(request, response, chain, &lt;span&gt;new&lt;/span&gt; InsufficientAuthenticationException(&quot;Full authentication is required to access this resource&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝访问，由accessDeniedHandler处理，response 403&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 logger.debug(&quot;Access is denied (user is not anonymous); delegating to AccessDeniedHandler&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                accessDeniedHandler.handle(request, response, (AccessDeniedException) exception);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SEC-112: Clear the SecurityContextHolder's Authentication, as the existing Authentication is no longer considered valid
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将SecurityContext中的Authentication置为null&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         SecurityContextHolder.getContext().setAuthentication(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在调用认证前先将request保存到session&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        requestCache.saveRequest(request, response);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         logger.debug(&quot;Calling Authentication entry point.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重定向到认证入口点执行认证&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        authenticationEntryPoint.commence(request, response, reason);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.10 /index.html at position 10 of 10 in additional filter chain; firing Filter: 'FilterSecurityInterceptor'&lt;/h4&gt;
&lt;p&gt; 这个filter用于授权验证。FilterSecurityInterceptor的工作流程引用一下，可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;         FilterInvocation fi = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterInvocation(request, response, chain);
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;        invoke(fi);
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     
&lt;span&gt;  6&lt;/span&gt;     
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; invoke(FilterInvocation fi) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((fi.getRequest() != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; observeOncePerRequest) {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; filter already applied to this request and user wants us to observe
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; once-per-request handling, so don't re-do security checking&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; first time this request being called, so perform security checking&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fi.getRequest() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;             InterceptorStatusToken token = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.beforeInvocation(fi);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果后面还有filter则继续执行&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存securityContext&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.finallyInvocation(token);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;.afterInvocation(token, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; InterceptorStatusToken beforeInvocation(Object object) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         Assert.notNull(object, &quot;Object was null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; debug =&lt;span&gt; logger.isDebugEnabled();
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getSecureObjectClass().isAssignableFrom(object.getClass())) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &quot;Security invocation attempted for object &quot;
&lt;span&gt; 40&lt;/span&gt;                             +&lt;span&gt; object.getClass().getName()
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                             + &quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot;
&lt;span&gt; 42&lt;/span&gt;                             +&lt;span&gt; getSecureObjectClass());
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取配置的权限属性&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         Collection&amp;lt;ConfigAttribute&amp;gt; attributes = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obtainSecurityMetadataSource().getAttributes(object);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (attributes == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; attributes.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rejectPublicInvocations) {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                         &quot;Secure object invocation &quot;
&lt;span&gt; 52&lt;/span&gt;                                 +&lt;span&gt; object
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                                 + &quot; was denied as public invocations are not allowed via this interceptor. &quot;
&lt;span&gt; 54&lt;/span&gt;                                 + &quot;This indicates a configuration error because the &quot;
&lt;span&gt; 55&lt;/span&gt;                                 + &quot;rejectPublicInvocations property is set to 'true'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 logger.debug(&quot;Public object - authentication not attempted&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PublicInvocationEvent(object));
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no further work post-invocation&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             logger.debug(&quot;Secure object: &quot; + object + &quot;; Attributes: &quot; +&lt;span&gt; attributes);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (SecurityContextHolder.getContext().getAuthentication() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            credentialsNotFound(messages.getMessage(
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                     &quot;AbstractSecurityInterceptor.authenticationNotFound&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     &quot;An Authentication object was not found in the SecurityContext&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                    object, attributes);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Authentication，如果没有进行认证则认证后返回authentication&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         Authentication authenticated =&lt;span&gt; authenticateIfRequired();
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attempt authorization&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用voter决策是否拥有资源需要的权限&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accessDecisionManager.decide(authenticated, object, attributes);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AccessDeniedException accessDeniedException) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 捕获到异常继续上抛&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthorizationFailureEvent(object, attributes, authenticated, accessDeniedException));
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; accessDeniedException;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             logger.debug(&quot;Authorization successful&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (publishAuthorizationSuccess) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthorizedEvent(object, attributes, authenticated));
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attempt to run as a different user&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;         Authentication runAs = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.runAsManager.buildRunAs(authenticated, object,
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                attributes);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (runAs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 logger.debug(&quot;RunAsManager did not change Authentication object&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no further work post-invocation&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterceptorStatusToken(SecurityContextHolder.getContext(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                    attributes, object);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 logger.debug(&quot;Switching to RunAs Authentication: &quot; +&lt;span&gt; runAs);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;             SecurityContext origCtx =&lt;span&gt; SecurityContextHolder.getContext();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.getContext().setAuthentication(runAs);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; need to revert to token.Authenticated post-invocation&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterceptorStatusToken(origCtx, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, attributes, object);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;https://blog.coding.net/blog/Explore-the-cache-request-of-Security-Spring&lt;/p&gt;
&lt;p&gt;http://blog.didispace.com/xjf-spring-security-4/&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/benjamin_whx/article/details/39204679&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 10:31:00 +0000</pubDate>
<dc:creator>snowater</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowater/p/8443100.html</dc:identifier>
</item>
<item>
<title>安卓微信页面的调试 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/8445031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/8445031.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;在开发移动端页面时，一般都得保证在微信页面中能够正常访问，虽说微信内置浏览器统一了各个不同安卓机的WebView，但在不同的机子上，还是会出现不一样的兼容问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试页面，有几个维度要考虑：&lt;/strong&gt;能够访问页面、审查元素查看页面输出、抓包查看请求模拟登陆、断点调试、性能测试、在模拟器上调试、在真机上调试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;一、能够访问页面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在开发安卓微信页面时，刚开始一般是会在PC上进行，等到开发后期的自测阶段再转到安卓模拟器上、转到各种真机上自测，上线了如果出问题还需要在真机上调试测试。&lt;/p&gt;
&lt;p&gt;能够访问页面，当然简单，但难在能够访问页面，并能为接下去的调试页面打好基础。&lt;/p&gt;
&lt;p&gt;很多公司会有内外网之分，开发环境是在内网，外网访问不到，就需要使用代理工具作一个中转。&lt;/p&gt;
&lt;p&gt;某个活动页的开发环境地址是， &lt;span&gt;local.abc.com/wx/page-spring&lt;/span&gt;  ，测试机上估计也会有对应的一个地址&lt;span&gt;  test.abc.com/wx/page-spring&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了访问这个页面，在PC的开发机上会设置HOST： &lt;span&gt;127.0.0.1  local.abc.com     12.70.0.1  test.abc.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的移动端手机为了能够访问，也需要设置HOST，但大部分机型都需要进行ROOT，不可取&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Fiddler工具，手机设置代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 首先，使手机和PC处在同一个局域网中，查看PC的IP（目前为 11.22.33.44）&lt;/p&gt;
&lt;p&gt;2. 开启Fiddler，在 options 中设置 Allow remote computers to connect ， 如果是HTTPS的页面，还需要设置允许HTTPS的解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110334374-2093061355.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110340265-1398964802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 如果是HTTPS，就先在手机上安装Fiddler的证书，在手机浏览器中访问IP:port 然后按照提示进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110737046-1544685031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 在手机的Wi-Fi连接上设置代理，设置成 IP:port&lt;/p&gt;
&lt;p&gt;不同手机修改方式不一样，但也类似，一般在更多或者高级修改网络里头&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111308796-591555408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，就可以在手机上直接用域名进行访问页面了。&lt;/p&gt;
&lt;p&gt;但在手机上设置代理还是稍微麻烦了一点，还可以使用Fiddler的开放端口功能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Fiddler工具，开放端口直连&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;省略上面的第四步，改为使用Fiddler开放一个端口（比如8877），在命令行中执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111857609-600921564.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111849952-1481712176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在FiddlerScript脚本面板中添加替换规则，请求前匹配IP:port来进行host转换，然后保存应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212112131640-117194888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在PC上访问 &lt;span&gt;11.22.33.44:8877/wx/page-spring&lt;/span&gt;  试看是否正常转换，再在手机上访问这个链接即可&lt;/p&gt;

&lt;p&gt;另外，有些页面需要绑定微信oAuth授权，这些页面上线之后（比如为  &lt;span&gt;www.abc.com/wx/page-spring&lt;/span&gt;），如果想在PC上直接访问调试，就会出问题了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212112754937-735078720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Fiddler，请求前设置Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信授权其实是绑定了OpenID，并和我们自己的系统中做了对应，那我们只要拿到这个登陆cookie就能实现模拟登陆了&lt;/p&gt;
&lt;p&gt;在Fiddler中，有很多种为请求设置cookie的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 获取Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用上面的方法，让手机访问的请求能被Fiddler捕获，取某条请求，获取其中的Cookie（比如这个PHPSESSID）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212113442937-1922220762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Fiddler为请求设置Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以打断点，在PC上访问链接，然后在Raw或相应的Tab修改Cookie，再返回即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212113741671-1102983779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114010531-1094219764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114236499-312685848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 手动打断点是有点麻烦的，也可以直接使用FiddlerScript简单地替换设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114430468-260717381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然也可以使用AutoResponder来直接匹配处理来访问这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114711921-1518390383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 二、审查元素查看页面输出&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;遇到样式的兼容性问题时，需要通过审查元素来调试。第一个调试基础是查看页面的元素和基本的日志输出。&lt;/p&gt;
&lt;p&gt;这类工具有很多，最常见的要属Chrome的开发者调试工具，在PC上我们可以直接通过设备模拟来使用原生支持的DevTools，在真机上我们可以使用它的远程调试功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Chrome设备模拟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个就很常见了，这里不多说&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212134939406-494583165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Chrome远程调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;远程调试，代名词，其实只是在PC上调试手机中访问的页面，通过USB连接进行调试。&lt;/p&gt;
&lt;p&gt;PC的Chrome DevTools不仅能识别到手机端的Chrome浏览器，其他一些WebView浏览器也支持（比如微信内置X5浏览器 ，小米浏览器，华为浏览器等）&lt;/p&gt;
&lt;p&gt;手机USB连接电脑，在手机开发者人员设置中开启 允许USB调试，在电脑控制面板设备管理上看到设备驱动安装成功（可以直接使用刷机精灵来帮助安装驱动）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144323093-2062244905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在Chrome中访问 &lt;a href=&quot;chrome://inspect/#devices&quot; target=&quot;_blank&quot;&gt;chrome://inspect/#devices &lt;/a&gt;，在手机上访问某个页面，在这里就能识别出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212135941015-865947968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图按顺序为 手机Chrome、小米浏览器、微信X5浏览器 打开的页面&lt;/p&gt;
&lt;p&gt;以微信中的 CSS Triggers页面为例来审查， 点击 inspect将弹出一个类似 DevTools的调试窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212140622265-1641999200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很多时候只能看到一个空白的页面，那是因为在远程调试的时候，Chrome要先请求下载调试工具包（为什么不跟随浏览器安装包来打包呢？可能是觉得打包之后体积太大，而且这个调试工具包是有版本控制的，各个环境不一致），需要FQ才行。&lt;/p&gt;
&lt;p&gt;首次调试某个（手机）浏览器环境需要获取，后续则直接使用离线的缓存。&lt;/p&gt;
&lt;p&gt;科学上网工具自行解决  ，能访问这个域名就行 &lt;a href=&quot;%20https://chrome-devtools-frontend.appspot.com/#&quot; target=&quot;_blank&quot;&gt; https://chrome-devtools-frontend.appspot.com/#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里提供一个host，可能后面会失效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 216.239.38.126 chrome-devtools-&lt;span&gt;frontend.appspot.com
&lt;/span&gt;216.58.203.244 chrome-devtools-frontend.appspot.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就能开始审查了，功能和DevTools基本一致（跟随Chrome版本）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212141419374-1206949654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过要注意的是，UC浏览器是识别不出的，需要使用PC的UC浏览器开发版和移动端的UC浏览器开发版才能调试，方法类似&lt;/p&gt;
&lt;p&gt;其他的WebView也不一定能识别，需要WebView本身开启支持了调试&lt;/p&gt;
&lt;p&gt;小米浏览器默认是支持的，微信X5在去年的时候也是默认支持的，不过最近需要手动开启了，在微信里访问 &lt;a href=&quot;http://debugx5.qq.com/&quot; target=&quot;_blank&quot;&gt;http://debugx5.qq.com/&lt;/a&gt; ， 然后打开 Inspector调试功能，重新访问页面即可&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212142224359-1076910824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 搭建 &lt;a href=&quot;https://github.com/nupthale/weinre&quot; target=&quot;_blank&quot;&gt;Weinre&lt;/a&gt; 调试环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Weinre，原理是往页面插入一段脚本，不支持断点调试功能&lt;/p&gt;
&lt;p&gt;使用NPM安装之后，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i -&lt;span&gt;g weinre

weinre &lt;/span&gt;--boundHost localhost --httpPort 9876
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212143803827-739858357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将这串脚本放到要调试的页面中即可，详细用法可查看 &lt;a href=&quot;https://github.com/nupthale/weinre&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;功能虽然比较简单，但这是最通用的调试方法，基本大部分环境下都能使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144225062-982698246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 4. 使用微信开发者工具进行调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信开发者工具的调试分为两种，一种是基于Weinre的网络连接调试，另一种是基于USB线缆连接的调试。安卓可以使用两种，iOS只能使用前者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用简单的调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要手机与PC同处于一个局域网，在手机中设置代理，然后在微信里打开某个页面进行调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144913156-194315421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212145032109-526405459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212145138687-570824018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用方法类似普通的Weinre，不过有个缺陷，就是不支持HTTPS，所以访问HTTPS的页面会出现白屏&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用USB调试X5内核&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法可以调试微信浏览器、QQ浏览器 或其他使用了X5内核的相关页面，可以进行脚本的断点调试&lt;/p&gt;
&lt;p&gt;同样的，需要先保证X5打开了可调试的选项，打开页面后开始调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212150157343-1378451773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在页面列表中选择inspect审查即可，同样地会调用开发者工具集成的Chrome DevTools，所以初次也需要爬墙找调试工具包&lt;/p&gt;
&lt;p&gt;调试情况与Chrome的远程调试类似，差的是微信开发工具里调试功能的稍微旧了些，好的是它可以识别一些Chrome识别不到的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 5. 使用 &lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot; target=&quot;_blank&quot;&gt;spy-debugger&lt;/a&gt;   进行调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对Weinre来说，除了使用微信开发者工具的集成之外，还有另一个稍好的方案&lt;/p&gt;
&lt;p&gt;spy-debugger本质上也是基于weinre进行开发调试的，除此之外它还支持HTTPS页面，支持简单的网络抓包以及文件映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm i spy-debugger -g

spy-debugger&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装之后启动，同局域网下手机设置好代理（默认端口为 9888）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151450093-1294482966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151413827-1976038007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可见对HTTPS页面做了一定的支持（需要先 &lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot; target=&quot;_blank&quot;&gt;按步骤&lt;/a&gt; 设置好证书）&lt;/p&gt;
&lt;p&gt;另外也提供了基础的抓包功能（默认使用AnyProxy，还可以自行设置），也是蛮实用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151755796-516923645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 使用 &lt;a href=&quot;https://github.com/Tencent/vConsole&quot; target=&quot;_blank&quot;&gt;VConsole&lt;/a&gt; 进行调试 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面所说都只是为了能够审查页面的元素，以便做一些基础的调试。&lt;/p&gt;
&lt;p&gt;不过，似乎都是在PC上操作的，那有没有能直接在手机上用的工具呢？&lt;/p&gt;
&lt;p&gt;近段时间发现这个小工具，如果电脑不在身边，对移动端的调试还是蛮有帮助的&lt;/p&gt;
&lt;p&gt;在新版QQ浏览器中，已经集成了这个选项，使用手机QQ浏览器访问 &lt;a href=&quot;http://debugx5.qq.com&quot; target=&quot;_blank&quot;&gt;http://debugx5.qq.com&lt;/a&gt; ，设置为开启即可在右下方看到功能入口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153534249-1333861391.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153620202-1818743433.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153623390-2045823486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击后可以看到几个面板，能够满足基本的页面审查、请求查看、命令执行，需要的话也可以自己添加插件&lt;/p&gt;
&lt;p&gt;而在微信内置浏览器中访问页面时，则需要手动引入 VConsole.js 这个文件，然后调用一下即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vConsole = &lt;span&gt;new&lt;/span&gt; VConsole();
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、抓包查看请求模拟登陆&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 很多时候我们希望获取某个页面所发起的请求和响应，对数据进行分析。抓包工具有很多，在Windows上有Fiddler，在Mac上有Charles，在手机上也有其他工具&lt;/p&gt;
&lt;p&gt; Fiddler的功能用法是很强大的，但大部分人只知道基本的功能，还有很多东西未曾了解。比如其中的自定义脚本FiddlerScript部分，可以实现很多扩展&lt;/p&gt;
&lt;p&gt;本文不展开来讲，推荐好好看一下&lt;a href=&quot;https://book.douban.com/subject/25835263/&quot; target=&quot;_blank&quot;&gt;《Fiddler调试指南》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大部分其他工具可以查看请求或返回，但无法进行自定义修改。这是Fiddler和Charles的独到之处&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212155153593-885536868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，使用Fiddler就得使用电脑，如果只是想直接在手机上看看请求的话，还有两个工具可以推荐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 使用 &lt;a href=&quot;http://kaywu.xyz/2016/02/28/PacketCapture/&quot; target=&quot;_blank&quot;&gt;Packet Capture&lt;/a&gt; 进行抓包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安卓机子中，安装之后，在它的设置项里配置一下证书&lt;/p&gt;
&lt;p&gt;点击绿色按钮开启监听，它会监听到所有APP的各种协议，也可以选择监听某一个APP&lt;/p&gt;
&lt;p&gt;比如，这里监听了我在微信里访问博客园，查看捕获的列表可以看到相关的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160340374-984384560.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160403249-801881534.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160447843-1777019288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;2. 使用 &lt;a href=&quot;https://github.com/JZ-Darkal/AndroidHttpCapture&quot; target=&quot;_blank&quot;&gt;HttpInterceptor&lt;/a&gt; 抓包工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对前者来说，这个东西功能算是多了点&lt;/p&gt;
&lt;p&gt;它内置了一个WebView浏览器，可以直接在里头访问连接分析页面，也可以设置代理，设置host（免ROOT），修改返回数据等&lt;/p&gt;
&lt;p&gt;如果PC上的开发环境设置了host ，PC的IP是 11.22.33.44，那么就可以在这里的host 设置为PC的IP，即可通过域名进行访问&lt;/p&gt;
&lt;p&gt;如果想监听其他APP（比如微信里的页面），则设置代理为 127.0.0.1:8888 即可（有点Fiddler的影子了），注意不用的时候（或者此进程被杀死）把代理关掉，否则访问不了网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162002343-1015602494.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162255124-1968051462.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162342812-1352358412.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162422296-1073593133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 点击预览可以看到捕获的请求列表，然后点击进去可以看到请求和返回的数据详情&lt;/p&gt;
&lt;p&gt; 如果想修改返回数据，可以在这里进行设置。比如结合上述的 VConsole 来使用，可以在不借助电脑的情况下就能做一些基本的调试功能&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162538202-433865339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、断点调试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 断点调试，包括JS的调试，以及DOM节点元素的树结构、属性改变的调试，它在调试过程中是很重要的，一般来说都需要使用到开发者工具。&lt;/p&gt;
&lt;p&gt;在这个维度上看，调试方法要属Chrome的设备模拟和远程调试&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、性能测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 某些时候还需要对页面进行性能的测试，从加载时的时间线性能，到运行时的流畅度性能，再到页面占用的内容性能等角度来分析&lt;/p&gt;
&lt;p&gt;要比较准确地显示地考量这些指标，一般都需要在真机上进行调试，也少不了开发者工具&lt;/p&gt;
&lt;p&gt;一般设计到这一环时，Chrome远程调试就是必须的了。&lt;/p&gt;
&lt;p&gt;本文先不展开，后续会有关于Chrome DevTools 的调试整理，敬请期待~&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、在真机上调试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 关于移动端页面的测试，有三个层次：&lt;/p&gt;
&lt;p&gt;1. 在PC上用浏览器设备模拟测试&lt;/p&gt;
&lt;p&gt;2. 在PC上用模拟器模拟测试&lt;/p&gt;
&lt;p&gt;3. 使用真机模拟测试&lt;/p&gt;
&lt;p&gt;浏览器的设备模拟多是从样式上来模拟，安卓模拟器有了一些硬件上的倾向性，在真机上最为可靠&lt;/p&gt;
&lt;p&gt;然而现在大多数的手机浏览器都自带了工具栏，而华为手机上自带了虚拟键盘，导致一个页面的高度不统一。也许在设备模拟页面上正常了，在真机却被挤压元素被覆盖了。&lt;/p&gt;
&lt;p&gt;所以说，有机会的话都要搜集常见的机型来进行真机测试，或者至少要进行模拟器的测试。&lt;/p&gt;


&lt;p&gt;以调试安卓微信页面为基础，本文列举了几个常见的调试工具和相应的使用方法&lt;/p&gt;
&lt;p&gt;并不是每个方法都保证可行，所以在调试过程中会有很多的备选方案&lt;/p&gt;
&lt;p&gt;要说最重要的，应该就是Fiddler和DevTools的结合了，DevTools解决不了的再找Weinre&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 09:03:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/8445031.html</dc:identifier>
</item>
</channel>
</rss>