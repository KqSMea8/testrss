<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>OLEDB数据源 - GunLun</title>
<link>http://www.cnblogs.com/lanuage/p/8278087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanuage/p/8278087.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: OLEDB数据源&lt;br/&gt;date: 2018-01-12 21:42:37&lt;br/&gt;tags: [OLEDB, 数据库编程, VC++, 数据库]&lt;br/&gt;categories: windows 数据库编程&lt;br/&gt;keywords: OLEDB, 数据库编程, VC++, 数据库&lt;br/&gt;---&lt;br/&gt;数据源在oledb中指数据提供者，这里可以简单的理解为数据库程序。数据源对象代表数据库的一个连接，是需要创建的第一个对象。而数据源对象主要用于配置数据库连接的相关属性如连接数据库的用户名密码等等&lt;/p&gt;&lt;p&gt;数据源主要完成的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行数据库身份认证&lt;/li&gt;
&lt;li&gt;为每个连接准备对应的资源，如对应的数据缓冲，网络连接资源&lt;/li&gt;
&lt;li&gt;设置连接属性，给访问者何种权限，设置连接的超时值等等，对象会根据对应的属性打开对应的接口。它的这些设置都是通过属性进行的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OLEDB虽然是基于COM的一组接口，但是它与标准的COM接口有点不同，它的一大特色在于它自身的属性设置，有的接口虽然对象中存在但是调用QueryInterface是查询不出来的，只有设置相应的接口才会打开，有的接口可以根据属性值表现不同的行为。比如设置了对应的只读属性则不允许使用更新接口。&lt;br/&gt;每个属性都有值、类型、说明和读写属性，对于行集对象，还有一个用于指示是否可以逐列应用它的指示器。&lt;br/&gt;属性由一个GUID和一个整数ID进行唯一标识。&lt;br/&gt;属性集是所有具有相同 组GUID 的一组属性。在逻辑上它们都用于同一种功能，比如有的属性集用于设置数据源连接属性，有的用于设置行集属性等等。它们是应用在同一个特定对象上的一组属性。在每个这样的属性组中都有属性每个属性属于一个或者多个属性组。&lt;br/&gt;属性定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROP {
   DBPROPID        dwPropertyID; &lt;span class=&quot;co&quot;&gt;//属性GUID&lt;/span&gt;
   DBPROPOPTIONS   dwOptions; &lt;span class=&quot;co&quot;&gt;//属性的操作方式&lt;/span&gt;
   DBPROPSTATUS    dwStatus; &lt;span class=&quot;co&quot;&gt;//属性设置状态&lt;/span&gt;
   DBID            colid; &lt;span class=&quot;co&quot;&gt;//属性ID，一般给DB_NULLID&lt;/span&gt;
   VARIANT         vValue; &lt;span class=&quot;co&quot;&gt;//属性值&lt;/span&gt;
} DBPROP;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dwOptions:属性的操作方式有3种，但是一般只使用其中的两种：DBPROPOPTIONS_REQUIRED表示必须设置成功，如果设置失败，则设置属性的操作失败，DBPROPOPTIONS_OPTIONAL，表示可选，即即使该属性设置失败，设置属性的操作也返回成功。DBPROPOPTIONS_SETIFCHEAP表示如果在设置属性操作时在在dwStatus参数中返回该属性设置的状态，是否成功，失败的原因等等。&lt;br/&gt;属性集的定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROPSET {
   DBPROP *   rgProperties; &lt;span class=&quot;co&quot;&gt;//属性数组的指针&lt;/span&gt;
   ULONG      cProperties; &lt;span class=&quot;co&quot;&gt;//属性数组中元素个数&lt;/span&gt;
   GUID       guidPropertySet; &lt;span class=&quot;co&quot;&gt;//属性集的GUID&lt;/span&gt;
} DBPROPSET;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前属性组包括初始化属性组、数据源属性组、会话属性组、行集属性组、表属性组和列属性组等等。&lt;br/&gt;设置属性一般包含如下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配一个属性类型DBPRO的数组，一般倾向于多分配一个，最后一个数组元素全0，作为结尾&lt;/li&gt;
&lt;li&gt;确定每个属性的属性GUID，即明确我们需要设置的是对象的哪个属性&lt;/li&gt;
&lt;li&gt;填充对应的属性值，属性操作方式&lt;/li&gt;
&lt;li&gt;填充对应的属性集DBPROPSET结构。设置该属性集的GUID&lt;/li&gt;
&lt;li&gt;调用对应的接口设置属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据源对象的接口定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;CoType TDataSource {
   [mandatory]   interface IDBCreateSession; &lt;span class=&quot;co&quot;&gt;//创建回话对象&lt;/span&gt;
   [mandatory]   interface IDBInitialize; &lt;span class=&quot;co&quot;&gt;//创建数据源连接对象&lt;/span&gt;
   [mandatory]   interface IDBProperties; &lt;span class=&quot;co&quot;&gt;///&lt;/span&gt;创建数据源的属性操作对象
   [mandatory]   interface IPersist;
   [optional]    interface IConnectionPointContainer;
   [optional]    interface IDBAsynchStatus;
   [optional]    interface IDBDataSourceAdmin;
   [optional]    interface IDBInfo;
   [optional]    interface IObjectAccessControl;
   [optional]    interface IPersistFile;
   [optional]    interface ISecurityInfo;
   [optional]    interface ISupportErrorInfo;
   [optional]    interface ITrusteeAdmin;
   [optional]    interface ITrusteeGroupAdmin;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中，mandatory表示是数据源必须提供的接口，optional表示的是可选性提供的接口，在创建对应的接口时尽量使用必须实现的接口，如果需要使用可选择的接口，一定要判断数据源是否支持。在数据源对象中最主要的还是前三个必须提供的接口&lt;/p&gt;

&lt;p&gt;连接到数据源一般使用IDBInitialize接口的Initialize方法，但是生成IDBInitialize接口有几种不同的方式，下面一一列举出来&lt;/p&gt;
&lt;h2 id=&quot;直接创建idbinitialize接口&quot;&gt;直接创建IDBInitialize接口&lt;/h2&gt;
&lt;p&gt;这种方式一般调用CoCreateInstance函数创建，下面是具体的代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;tchar.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;windows.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;strsafe.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define COM_NO_WINDOWS_H    &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//如果已经包含了Windows.h或不使用其他Windows库函数时&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define OLEDBVER 0x0260     &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//MSDAC2.6版&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledb.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledberr.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_ALLOC(sz)       HeapAlloc(GetProcessHeap(),0,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_CALLOC(sz)      HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFEFREE(p)     if(NULL != p){HeapFree(GetProcessHeap(),0,p);p=NULL;}&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_USEPRINTF() TCHAR pBuf[1024] = {}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//定义输出宏&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_PRINTF(...) &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    GRS_USEPRINTF();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    StringCchPrintf(pBuf,1024,__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),pBuf,lstrlen(pBuf),NULL,NULL);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安全释放，为了养成良好的编码习惯，特作此宏定义&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFERELEASE(I)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(NULL != (I))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)-&amp;gt;Release();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)=NULL;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//检测上一步的操作是否成功&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_COM_CHECK(hr,...)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(FAILED(hr))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        GRS_PRINTF(__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        goto CLEAR_UP;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _tmain(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, TCHAR* argv[])
{
    CoInitialize(NULL);
    &lt;span class=&quot;co&quot;&gt;//创建OLEDB init接口&lt;/span&gt;
    IDBInitialize *pDBInit = NULL;
    IDBProperties *pIDBProperties = NULL;
    &lt;span class=&quot;co&quot;&gt;//设置链接属性&lt;/span&gt;
    DBPROPSET dbPropset[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    DBPROP dbProps[&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    CLSID clsid_MSDASQL = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;}; &lt;span class=&quot;co&quot;&gt;//sql server 的数据源对象&lt;/span&gt;
    
    HRESULT hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid_MSDASQL);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取SQLOLEDB的CLSID失败，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CoCreateInstance(clsid_MSDASQL, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pDBInit);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;无法创建IDBInitialize接口，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//指定数据库实例名，这里使用了别名local，指定本地默认实例&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwPropertyID = DBPROP_INIT_DATASOURCE;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定数据库库名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwPropertyID = DBPROP_INIT_CATALOG;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Study&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_USERID;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;sa&quot;&lt;/span&gt;));
    
    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户密码&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_PASSWORD;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;));
    
    
    &lt;span class=&quot;co&quot;&gt;//设置属性&lt;/span&gt;
    hRes = pDBInit-&amp;gt;QueryInterface(IID_IDBProperties, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBProperties);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询IDBProperties接口失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    dbPropset-&amp;gt;guidPropertySet = DBPROPSET_DBINIT;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].cProperties = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].rgProperties = dbProps;
    hRes = pIDBProperties-&amp;gt;SetProperties(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dbPropset);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;设置属性失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//链接数据库&lt;/span&gt;
    hRes = pDBInit-&amp;gt;Initialize();
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败：错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//do something&lt;/span&gt;
    pDBInit-&amp;gt;Uninitialize();

    GRS_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;数据库操作成功!!!!!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
CLEAR_UP:
    GRS_SAFEFREE(pDBInit);
    GRS_SAFEFREE(pIDBProperties);
    CoUninitialize();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一份完整的可执行代码，后续的部分对于重复的代码将不再给出。&lt;br/&gt;在上述代码中我们首先根据字符串SQLOLEDB查找到SQL Server对应的数据源对象，然后根据数据源对象查询出IDBProperties对象，接着分配一些空间来设置属性和属性集，调用IDBProperties接口的SetProperties函数来设置对应的数据源对象的接口。最后调用IDBInitialize接口的Initialize链接数据源，调用Uninitialize函数来断开连接。&lt;br/&gt;一般数据源对象的属性集合的GUID为DBPROPSET_DBINIT，下面包含的属性最主要的有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DBPROP_INIT_DATASOURCE:数据连接实例（具体的DBMS实例名）&lt;/li&gt;
&lt;li&gt;DBPROP_INIT_CATALOG：目录名（在SQL Server中对应的是具体的数据库名称，对于ORACLE来说没有意义）&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_USERID: 用户名&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_PASSWORD: 密码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们也注意到上面调用SysAllocString的BSTR类型的字符串并没有调用对应的函数进行释放，会不会发生内存泄露？其实不用担心OLEDB在断开连接的时候已经帮助我们释放了这部分空间。&lt;/p&gt;
&lt;h2 id=&quot;使用idbpromptinitialize接口来创建数据源对象&quot;&gt;使用IDBPromptInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;上述方法是依托于标准的COM，虽然也成功创建的数据源连接，但是无法在标准的com之上进行更多的初始化操作，导致了有些特定的高级功能无法使用，所以在实践中常用的还是利用IDBPromptInitialize和IDataInitialize的方式比较多。&lt;br/&gt;IDBPromptInitialize创建时会弹出一个数据源选择的对话框，供用户选择相关配置信息（数据源/用户名/密码等）然后根据这些配置自动生成连接对象。&lt;br/&gt;下面看一个弹出数据源对话框的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByDialog() &lt;span class=&quot;co&quot;&gt;//通过弹出对话框来链接SQL SERVER数据库&lt;/span&gt;
{
    DECLARE_BUFFER();
    DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);

    HWND hDesktop = GetDesktopWindow();
    HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//调用该函数弹出数据源对话框&lt;/span&gt;
    hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDesktop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));

    hRes = pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDBPromptInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了这种方式，他还可以直接创建出IDBInitialize接口，利用之前设置属性的方式来连接到数据库，下面是一个演示的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建接口IDBInitialize失败：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询SQLOLEDB CLSID 失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDataInitialize-&amp;gt;CreateDBInstance(clsid, NULL,
        CLSCTX_INPROC_SERVER, NULL, IID_IDBInitialize,
        (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//后续的代码就是我们之前写的那段定义属性，设置属性，连接数据库的代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用idatainitialize接口来创建数据源对象&quot;&gt;使用IDataInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;使用IDataInitialize接口可以直接使用连接字串连接到数据库，下面是使用连接字串的例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByConnstr() &lt;span class=&quot;co&quot;&gt;//通过连接字符串连接数据库&lt;/span&gt;
{
    DECLARE_OLEDB_INTERFACE(IDataInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);
    DECLARE_BUFFER();
    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDataInitialize-&amp;gt;GetDataSource(NULL, CLSCTX_INPROC_SERVER, 
        OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;Password = 123456;Initial Catalog=Study;Data Source=LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS;&quot;&lt;/span&gt;), 
        IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
    pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDataInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实除了上面这种直接创建IDataInitialize接口的方法外，还可以使用IDBPromptInitialize接口Query出一个IDataInitialize接口，然后再设置连接字串连接到数据库。&lt;br/&gt;其实在OLEDB中，可以认为连接字串最终被翻译为对应的属性，也就是说OLEDDB保存着对应连接的属性，我们可以通过不同的方式来获取不同类型的属性，比如使用IDBProperties接口来获取对应的链接属性，或者使用IDataInitialize的GetInitializationString函数来获取连接的链接字串。&lt;br/&gt;既然它保存着每个连接的对应属性，那么是不是可以将用户在数据源对话框上的操作最终保存为数据连接字串呢，答案是肯定的。实现的思路如下：&lt;/p&gt;
&lt;ol readability=&quot;0.48894062863795&quot;&gt;&lt;li&gt;调用IDBPromptInitialize接口的PromptDataSourc方法弹出数据源对话框，让用户操作&lt;/li&gt;
&lt;li&gt;根据IDBPromptInitialize接口Query出IDataInitialize接口&lt;/li&gt;
&lt;li readability=&quot;17.561257216164&quot;&gt;
&lt;p&gt;调用IDataInitialize接口的GetInitializationString来获取连接字串&lt;br/&gt;下面是具体实现的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GetConnectString()
{
DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
DECLARE_OLEDB_INTERFACE(IDataInitialize);
DECLARE_OLEDB_INTERFACE(IDBInitialize);
DECLARE_BUFFER();

LPOLESTR pConnStr = NULL;
HWND hDeskTop = GetDesktopWindow();
HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDeskTop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);


hRes= pIDBPromptInitialize-&amp;gt;QueryInterface(IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

hRes = pIDataInitialize-&amp;gt;GetInitializationString(pIDBInitialize, TRUE, &amp;amp;pConnStr);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取连接字串失败失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接字符串:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), pConnStr);
SysAllocString(pConnStr);
__CLEAN_UP:
SAFE_RELEASE(pIDataInitialize);
SAFE_RELEASE(pIDBInitialize);
SAFE_RELEASE(pIDBPromptInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;为了节约篇幅，这些笔记内容只会列举部分关键的代码，至完整的代码我会随着博客内容的进度慢慢上传到GitHub项目中，并在博文的最末尾给出对应文件的地址&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/ConnectDB.cpp&quot;&gt;本次代码地址1&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/DataSource.cpp&quot;&gt;本次代码地址2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 12 Jan 2018 15:41:00 +0000</pubDate>
<dc:creator>GunLun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanuage/p/8278087.html</dc:identifier>
</item>
<item>
<title>【ASP.NET 系列】浅谈缓存技术在ASP.NET中的运用 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8271403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8271403.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110033829004-2140333139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章虽不谈架构，但是Cache又是架构中不可或缺的部分，因此，在讲解Cache的同时，将会提及到部分架构知识，关于架构部分，读者可以不用理解，或者直接跳过涉及架构部分的内容，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你只需关心Cache即可，具体的架构，会在后续文章中与大家分享，如果你感兴趣，只需关注即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一   为什么要在ASP.NET 项目中引入缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 我们先来考虑一个问题，通常，面临高并发问题时，我们应该怎么处理？&lt;/p&gt;
&lt;p&gt;下图为常规的处理思路和方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112225929254-1826453911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.为什么引入Cache呢？&lt;/p&gt;
&lt;p&gt;        我们知道，造成高并发的根本原因是大量读写的问题，一般地，对于一个系统，读总是比写多，如我们总是逛淘宝，京东，天猫，唯品会等，但我们并不一定买东西（买东西，即下单，下单的操作，对应DB的Write操作），&lt;/p&gt;
&lt;p&gt;缓存主要解决都的问题（当然，在后期的文章中，我会讲到消息队列MQ，也是一种缓存机制，其不仅仅解决都得问题，还解决写的问题）。&lt;/p&gt;
&lt;p&gt;        很好，我们知道缓存主要解决都得问题，那么，我们都得东西很多，是不是缓存所有都得内容呢？答案是否定的。缓存主要解决那些高频访问，吃服务器资源，实时性要求比较低，不常更新的内容。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二   ASP.NET 缓存技术概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;（一）ASP.NET缓存技术种类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ASP.NET实际项目开发中，我们可以采取基本的三种缓存技术：页面缓存、局部页面和数据缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112015859019-13930935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;1.整页缓存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  所谓整页缓存，指缓存整个页面，且设置刷新间隔时间，刷新间隔时间一般以秒为单位（缓存不能全部刷新，且刷新间隔不依赖外部事件）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.部分页面缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   所谓部分页面缓存，也叫局部页面缓存，指通过设定影响页面的参数，此时的缓存存储页面的多个版本，一般情况需要按照参数值为这些页面版本设置索引；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.运用程序缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   所谓运用程序缓存，也叫数据缓存，指将需要大量服务器资源的对象存储在内存中，在ASP.NET中，由Cache类来实现（Cache类的每个实例对应具体的每个运用程序，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其生存期依赖于运用程序的生存期，当然，如果系统重启或者断电，则另当别论。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（二）二级缓存技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ASP.NET一般的项目中，我们采用二级缓存就可以解决服务器缓存问题了，如下为二级缓存的轮廓图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112032109082-519775954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.何为一级缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   一级缓存，指不借助于外部缓存的缓存，上图中的二级缓存去掉外部缓存部分即为一级缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.组成：由Web服务器、数据库服务器和二级缓存系统构成；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.请求-处理流程：对于都数据，采用从内向外的顺序：内部缓存=》外部缓存=》数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    (1)首次请求读数据：蓝色的箭头表示首次请求，从数据库服务器DB中取得数据，并将数据缓存在二级缓存系统中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    (2)非首次请求读数据：先从二级缓存内部缓存中取数据显示页面，如果没有数据，则去二级缓存外部缓存中取数据显示页面，若外部缓存中没有数据，则再去数据库服务器中取数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112031124394-1557879729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;(4)对于写数据，才有从外向内顺序：数据库=》外部缓存=》内部缓存（这样做的目的，主要是维护数据的一致性）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.构成二级缓存系统的外部缓存系统，一般我们可选择MongoDB,Redis,Mencached等;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.基于SOA+Redis的的一般系统架构(当然，本片文章不谈架构，因此不会分析架构，但会在后续的文章中单独讲解架构)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112030205910-1321486861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;6.如何保证数据的一致性？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对于读数据，采用从内向外的顺序；对于写数据，采用从外向内的顺序；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 7.缓存的有效期？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们以Memcached做外部缓存为例，我对于ASP.NET内部缓存，我们会担心内存不够用，而对于Memcached，则可以不用担心内存不够用的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    采用二级缓存方案，Memcaches缓存与ASP.NET缓存都要进行严格的管理和控制，因为Memcached工作在外层，直接对数据库中的数据进行读取，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;且他的内存空间一般较大，故它的缓存数据有效期应该根据缓存数据在运用中的实际缓存有效期来设定，不会受到内部不足而被释放的影响，而ASP.NET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存工作在内层，直接与运用程序中的数据进行交互，且ASP.NET框架对自身缓存的内存空间有所限制，缓存空间过大会影响整个运用的性能，为了在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同的内存空间下缓存更多的数据，ASP.NET缓存的有效期应该小于或等于Memcached缓存的有效期，有效期具体多长时间视内存空间和运用程序访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;频率的高低而定，ASP.NET对同意缓存数据的有效期之和不能大于其在Memcached中的有效期，这样才能达到缓存数据的一致性，两个缓存的协同工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，可以对运用程序的访问速度带啦很大的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）缓存涉及到的一些相关技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存是一门技术，不可能花较少的篇幅即可讲明白，如下简要列举一些Cache相关的技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112034014285-840301807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;1.Cahe维护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;维护网络上的，本地的Cache;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.路由策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的路由策略要根据Cache架构和设计来设定，大致讲解一下本地缓存路由策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112035710832-453790588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.替换算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.预取技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.Cache性能分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;借助一些性能分析工具来分析，主要关注命中率/缓存对象大小之间关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112040621301-1150966080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;6.过期策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合理设置过期间隙，一般以秒为单位；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.数据一致性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保证主从同步，读写数据的顺序等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.缓存级别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的级别，根据具体的业务需求来设定；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.Cache技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;磁盘缓存，存储器缓存，WWW服务器缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.数据缓存技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 客户端数据缓存，分布式数据缓存，集中式数据缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三   Cache在ASP.NET MVC中的运用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）整页缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.ASP.NET MVC中有哪些整页缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 整页缓存是一种比较简单且常用的缓存方式，缓存这个页面。在ASP.NET中，整页缓存一般包括控制器缓存，Action缓存，Web.config缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.哪些页面需要整页缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 一般地，整页缓存页面具有“读取频繁，数据不常更新、编译时需要占用大量时间和资源”等特点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.ASP.NET MVC中整页缓存的语法格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112214757191-412555397.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (1)控制器缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器缓存指把缓存作用于控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; PageCacheController.cs&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CacheDemo.Controllers
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     [OutputCache(Duration = &lt;span&gt;70&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerCacheController : Controller
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Default&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ControllerCache()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;             ViewBag.CurrentTime =&lt;span&gt; System.DateTime.Now;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PageCache.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ViewBag.Title = &quot;ControllerCache&quot;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ControllerCache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    ViewBag的值：@ViewBag.CurrentTime
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Result:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112205300051-466496545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(2)Action缓存&lt;/p&gt;
&lt;p&gt;Action缓存指把缓存作用于Action。控制方法缓存与控制器缓存原理差不多，只不过控制器缓存把缓存作用于控制器，控制器方法缓存把缓存作用于控制器方法。这里就不讲解了。&lt;/p&gt;
&lt;p&gt;(3)Web.config缓存&lt;/p&gt;
&lt;p&gt;Web.config缓存，有点类似于我们将数据库连接字符串添加在配置文件一样，看看下面的代码，是否很熟悉呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&quot;SqlserverConstr&quot; connectionString=&quot;Server=IP;db=DataBaseName;uid=UserName;pwd=Password&quot; providerName=&quot;System.Data.SqlClient&quot; /&amp;gt;
  &amp;lt;/connectionStrings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Web.config将需要缓存的Controller或Action提取抽象到配置文件中，其实就相当于我们使用数据库连接字符串，使用时，调用即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;system.web&amp;gt;
    &amp;lt;caching&amp;gt;
      &amp;lt;outputCacheSettings&amp;gt;
        &amp;lt;outputCacheProfiles&amp;gt;
          &amp;lt;add name =&quot;WebConfiCache&quot; duration=&quot;70&quot;/&amp;gt;
        &amp;lt;/outputCacheProfiles&amp;gt;
      &amp;lt;/outputCacheSettings&amp;gt;
    &amp;lt;/caching&amp;gt;
    &amp;lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.6.1&quot; /&amp;gt;
    &amp;lt;httpRuntime targetFramework=&quot;4.6.1&quot; /&amp;gt;
  &amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将上面的控制器缓存参数用Web.config来配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CacheDemo.Controllers
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[OutputCache(Duration = 70)]&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     [OutputCache(CacheProfile = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebConfiCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerCacheController : Controller
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Default&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ControllerCache()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             ViewBag.CurrentTime =&lt;span&gt; System.DateTime.Now;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;其实相当简单，就当作数据库连接字符串来操作或者&amp;lt;appSetting&amp;gt;操作即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112211654707-432577428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）缓存依赖&lt;/p&gt;
&lt;p&gt;留给读者朋友们去研究，比较简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）部分页面缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 部分页面缓存，也叫页面部分缓存，主要解决在页面缓存中需要经常实时更新的一部分内容。&lt;/p&gt;
&lt;p&gt; 页面部分缓存就是缓存页面的一部分，而不是缓存整个页面，它适用于页面内某些部分可能需要更新的数据的情况，在常用页面部分缓存的技术下经常采用先将整个页面缓存，然后再替换页面中不需要缓存的部分。(用AJAX局部刷新来理解)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）运用程序缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;运用程序缓存是用来存储与运用程序有关的对象，主要由Cache类来实现（命名空间System.Web.Caching），可以以编码的方式灵活地控制缓存的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112222139066-1292018943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四   版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:08:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8271403.html</dc:identifier>
</item>
<item>
<title>SQL Server-聚焦sp_executesql执行动态SQL查询性能真的比exec好？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8277713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8277713.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;之前我们已经讨论过动态SQL查询呢？这里为何再来探讨一番呢？因为其中还是存在一定问题，如标题所言，很多面试题也好或者有些博客也好都在说在执行动态SQL查询时sp_executesql的性能比exec好，但是事实真是如此？下面我们来一探究竟。&lt;/p&gt;
&lt;h2&gt;探讨sp_executesql和exec执行动态SQL查询性能&lt;/h2&gt;
&lt;p&gt; 首先我们创建如下测试表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; dbo.TestDynamicSQL
    (
      Col1 &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; ,
      Col2 &lt;/span&gt;&lt;span&gt;SMALLINT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
      CreatedTime &lt;/span&gt;&lt;span&gt;DATETIME&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;() ,
      OtherValue &lt;/span&gt;&lt;span&gt;CHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着再来插入数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt;&lt;span&gt;  dbo.TestDynamicSQL
        ( Col1,
          Col2
        )
        &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;number&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ,
                &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;
        &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    master..spt_values
        &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终查询为如下测试数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112212913301-1354551394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们执行如下两个SQL查询语句，执行4次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    dbo.TestDynamicSQL
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   Col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; Col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    dbo.TestDynamicSQL
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   Col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; Col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着我们通过如下SQL语句来查询缓存计划。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  q.&lt;span&gt;text&lt;/span&gt;&lt;span&gt; ,
        cp.usecounts ,
        cp.objtype ,
        p.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; ,
        q.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; ,
        cp.plan_handle
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    sys.dm_exec_cached_plans cp
        &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt;&lt;span&gt; APPLY sys.dm_exec_query_plan(cp.plan_handle) p
        &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; APPLY sys.dm_exec_sql_text(cp.plan_handle) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; q
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   cp.cacheobjtype &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Compiled Plan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; q.&lt;span&gt;text&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%dbo.TestDynamicSQL%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; q.&lt;span&gt;text&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%sys.dm_exec_cached_plans %&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112213336644-1611930703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，我们看到存在两个查询计划且每个执行了4次，也就是说每一次查询都会重新生成一个新的计划。清除查询计划缓存，通过如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; FREEPROCCACHE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续往下走，我们接下来通过EXEC来执行动态SQL查询，如下，执行查询完毕后再来看看查询计划次数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112213940722-1704775525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就不做过多解释，我们依然要清除查询计划缓存，我们再利用sp_executesql来查询，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;24&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;
&lt;span&gt;Go&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112214222504-1395004764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比exec执行动态SQL查询得到的结果是一模一样，正如我所演示的，我们有两个计划，每个执行次数为4。不是说sp_executesql执行动态SQL查询会重用计划缓存么，这是因为我们没有正确使用sp_executesql所以导致SQL引擎无法重用计划。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;当参数值改变为语句是唯一变化时，可以使用sp_executesql代替存储过程多次执行Transact-SQL语句。 因为Transact-SQL语句本身保持不变，只有参数值发生变化，因此SQL Server查询优化器可能会重用为第一次执行生成的执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是正确参数化的查询方式，我们在字符串里面有一些变量，在执行的时候，我们通过其他变量传递值给它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112215941426-622205865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到只有一个计数为8的计划，而不是像我们上述那样运行查询。 我们也可以只需要声明一次，然后我们只需要在执行之前更改参数的值，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
 
 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
 
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;change param values and run the same query&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终查询计划缓存次数和上述正确方式一致。正确使用sp_executesql对于性能非常有利，而且使用sp_executesql还可以为我们提供一些EXEC无法实现的功能。比如如何得到一个表中的行数？ 利用EXEC我们需要使用一个临时表和填充，而用sp_executesql我们只需要使用一个输出变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; IO &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; TIME &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;EXEC (SQL)&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
 
 
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #&lt;span&gt;temp&lt;/span&gt; (Totalcount &lt;span&gt;INT&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Insert into #temp Select Count(*) from dbo.TestDynamicSQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;EXEC&lt;/span&gt;( &lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; Totalcount
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;    #&lt;span&gt;temp&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; Totalcount
 
&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #&lt;span&gt;temp&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;sp_executesql&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TableCount&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT @InnerTableCount = COUNT(*) FROM  dbo.TestDynamicSQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;EXEC&lt;/span&gt; SP_EXECUTESQL &lt;span&gt;@SQL&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerTableCount INT OUTPUT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@TableCount&lt;/span&gt;&lt;span&gt; OUTPUT
 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@TableCount&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112221423191-641697760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然除了EXEC无法实现的功能外，最重要的一点则是SP_EXECUTESQL能够防止SQL注入问题。 &lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;执行SQL动态查询SP_EXECUTESQL比EXEC性能更好的存储过程能够被重用，但是存储过程能够被重用的前提则是正确使用参数，使用参数化查询，否则SP_EXECUTESQL将不会提供任何性能益处。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:07:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8277713.html</dc:identifier>
</item>
<item>
<title>GO开发[一]：golang开发初探 - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8278019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8278019.html</guid>
<description>&lt;p&gt;&lt;span&gt;一.Golang的安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.https://dl.gocn.io/ （国内下载地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112221343613-1630022180.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.https://golang.org/dl/ （国外下载地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112232832707-6725384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.现在studygolang中文网也可以了https://studygolang.com/dl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mac darwin-adm64.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;linux amd64.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;windows amd64.msi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.window编辑器 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;atom配合go-plus插件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;sublime配合gosublime插件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;emacs + spacemacs配置（相对来说比较麻烦，也是mac的一个不错的选择.）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Goland JetBrains&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　直接安装的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222901644-1164871321.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Windows推荐goland &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222424191-744545265.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222804566-1597214610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222813488-1883081446.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 、Ubuntu安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apt install golang-&lt;span&gt;go
root@greg:&lt;/span&gt;&lt;span&gt;# go env
GOARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOBIN&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOEXE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GORACE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOTOOLDIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.7/pkg/tool/linux_amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOGCCFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build765188684=/tmp/go-build -gno-record-gcc-switches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CXX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_ENABLED&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;默认安装了1.7，可以自定义更新到最新版1.9&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;root@greg:/usr/local/src/go1.&lt;span&gt;9.2&lt;/span&gt;/src# ./&lt;span&gt;make.bash
##### Building Go bootstrap tool.
cmd&lt;/span&gt;/&lt;span&gt;dist
ERROR: Cannot find &lt;/span&gt;/root/go1.&lt;span&gt;4&lt;/span&gt;/bin/&lt;span&gt;go.
Set $GOROOT_BOOTSTRAP to a working Go tree &lt;/span&gt;&amp;gt;= Go &lt;span&gt;1.4&lt;/span&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;报错了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决：export GOROOT_BOOTSTRAP=/usr/lib/go-1.7&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;初始化环境

    GOROOT放置go的标准库和工具链
        $HOME&lt;/span&gt;/local/&lt;span&gt;go (linux,mac)
        c:\local\go (windows)

    GOPATH放置第三方代码和自己的工程
        $HOME&lt;/span&gt;/&lt;span&gt;go(linux,mac)
        c:\go(windows)
        
    PATH
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/&lt;span&gt;bin:$PATH
        
        

    vim &lt;/span&gt;~/&lt;span&gt;.bashrc
        export GOROOT&lt;/span&gt;=$HOME/local/&lt;span&gt;go
        export GOPATH&lt;/span&gt;=$HOME/&lt;span&gt;go
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/&lt;span&gt;bin:$PATH


    我的Ubuntu是这样的
        GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/bin:$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 三、golang特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 天然并发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在单核时代：一个线程就能把CPU跑满，没必要多个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多核：内存操作、io操作，可以多线程，多进程的流畅执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nginx：多进程架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;redis：单进程单线程，单进程只能跑满一个cpu，目前服务器大部分多于8核，redis一个机器上跑个6/7个，榨干cpu&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;go 天然支持并发，跑一个进程就能使用7/8个核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C++和Java线程是重量级线程，高并发--&amp;gt;线程池，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;纯内存：8核8线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;go降低研发成本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;goroute，轻量级线程，创建成千上万个goroute成为可能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.垃圾回收&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存自动回收，不需要开发人员管理内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发人员专注业务实现，降低了心智负担&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要new分配内存，不需要释放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. channel&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管道，类似unix/linux中的pipe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个goroute之间通过channel进行通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持任何类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多返回值，一个函数返回多个值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四.go第一个程序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

func main(){
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello golang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;五.运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.&lt;span&gt;编译运行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;
    go build hello.go
    ll
        &lt;/span&gt;-rwxr-xr-x  &lt;span&gt;1&lt;/span&gt; greg greg &lt;span&gt;1859967&lt;/span&gt; 12月 &lt;span&gt;23&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt; hello*
        -rw-r--r--  &lt;span&gt;1&lt;/span&gt; greg greg      &lt;span&gt;75&lt;/span&gt; 12月 &lt;span&gt;23&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; hello.go


    greg@greg:&lt;/span&gt;~/go$ ./&lt;span&gt;hello
    hello golang&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;  跟go没有关系了，脱离了go&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
greg@greg:~/&lt;span&gt;go$ file hello
hello: ELF &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-bit LSB executable, x86-&lt;span&gt;64&lt;/span&gt;, version &lt;span&gt;1&lt;/span&gt; (SYSV), statically linked, not stripped
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;2.go run hello.go&lt;br/&gt;3.各个版本的编译&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;把mac编程Linux程序
    file hello.lua
    go build hello.go
    
    GOOS&lt;/span&gt;=&lt;span&gt;linux go build hello.go
    GOOS&lt;/span&gt;=&lt;span&gt;windows go build hello.go
    GOOS&lt;/span&gt;=&lt;span&gt;darwin go build hello.go
    
GOOS&lt;/span&gt;=linux go build -&lt;span&gt;o hello.linux hello.go
GOOS&lt;/span&gt;=windows go build -&lt;span&gt;o hello.exe hello.go
GOOS&lt;/span&gt;=darwin go build -&lt;span&gt;o hello.mac hello.go


greg@greg:&lt;/span&gt;~/&lt;span&gt;go$ file hello.mac 
hello.mac: Mach&lt;/span&gt;-O &lt;span&gt;64&lt;/span&gt;-bit x86_64 executable, flags:&amp;lt;NOUNDEFS&amp;gt;&lt;span&gt;
greg@greg:&lt;/span&gt;~/go$ ./&lt;span&gt;hello.linux 
hello golang
greg@greg:&lt;/span&gt;~/&lt;span&gt;go$ file hello.exe 
hello.exe: PE32&lt;/span&gt;+ executable (console) x86-&lt;span&gt;64&lt;/span&gt; (stripped to external PDB), &lt;span&gt;for&lt;/span&gt;&lt;span&gt; MS Windows


&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; GOOS=&lt;span&gt;windows
go build hello.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;六、go常用工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gofmt -w hello.go代码完美&lt;/p&gt;
&lt;p&gt;goimports -w hello.go 没有包就加上，有多余的包就删除&lt;/p&gt;
&lt;p&gt;一键编译go build&lt;/p&gt;
&lt;p&gt;go build github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;一键测试：go test&lt;/p&gt;
&lt;p&gt;go test github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;一键下载更新依赖并编译go get&lt;/p&gt;
&lt;p&gt;go get github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;自动文档工具godoc&lt;/p&gt;
&lt;p&gt;godoc -http=:9090&lt;/p&gt;
&lt;p&gt;在线查看文档&lt;/p&gt;
&lt;p&gt;godoc.org/github.com/golang/protobuf/proto&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_11003&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8278019.html</dc:identifier>
</item>
<item>
<title>CSS属性：背景属性（图文详解） - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8277895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8277895.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8277895.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;background系列属性&quot;&gt;background系列属性&lt;/h2&gt;
&lt;h3 id=&quot;常见背景属性&quot;&gt;常见背景属性&lt;/h3&gt;
&lt;p&gt;CSS样式中，常见的背景属性有以下几种：（经常用到，要记住）&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-color:#ff99ff;&lt;/code&gt; 设置元素的背景颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-image:url(images/2.gif);&lt;/code&gt; 将图像设置为背景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background-repeat: no-repeat;&lt;/code&gt; 设置背景图片是否重复及如何重复，默认平铺满。（重要）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no-repeat&lt;/code&gt;不要平铺；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-x&lt;/code&gt;横向平铺；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-y&lt;/code&gt;纵向平铺。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-position:center top;&lt;/code&gt; 设置背景图片在当前容器中的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-attachment:scroll;&lt;/code&gt; 设置背景图片是否跟着滚动条一起移动。&lt;br/&gt;属性值可以是：&lt;code&gt;scroll&lt;/code&gt;（背景图片不动）、&lt;code&gt;fixed&lt;/code&gt;（背景图片跟着滚动条一起移动）。注意属性值的含义不要搞反了，它的含义是根据滚动条来定义的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另外还有一个简写属性叫做&lt;code&gt;background&lt;/code&gt;，它的作用是：将上面的多个属性写在一个声明中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这几个属性经常用到，需要记住。现在我们逐个进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;background-color背景颜色的表示方法&quot;&gt;background-color：背景颜色的表示方法&lt;/h3&gt;
&lt;p&gt;css2.1中，背景颜色的表示方法有三种：单词、rgb表示法、十六进制表示法。&lt;/p&gt;
&lt;p&gt;比如红色可以有下面的三种表示方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color: red;
    background-color: rgb(255,0,0);
    background-color: #ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面分别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用英语单词来表示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够用英语单词来表述的颜色，都是简单颜色。比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: red;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、rgb表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rgb表示三原色“红”red、“绿”green、“蓝”blue。&lt;/p&gt;
&lt;p&gt;光学显示器中，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。r、g、b的值，每个值的取值范围0~255，一共256个值。&lt;/p&gt;
&lt;p&gt;比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(255,0,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;黑色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(0,0,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;颜色可以叠加，比如黄色就是红色和绿色的叠加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(255,255,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、十六进制表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: #ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS:所有用#开头的值，都是16进制的。&lt;/p&gt;
&lt;p&gt;这里，我们就要学会16进制与10进制之间的转换。下面举几个例子。&lt;/p&gt;
&lt;p&gt;问：16进制中28等于10进制多少？&lt;br/&gt;答：2*16+8 = 40。&lt;/p&gt;
&lt;p&gt;16进制中的af等于10进制多少？&lt;br/&gt;答：10 * 16 + 15 = 175&lt;/p&gt;
&lt;p&gt;所以，#ff0000就等于rgb(255,0,0)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;background-color: #123456;&lt;/code&gt;等价于&lt;code&gt;background-color: rgb(18,52,86);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十六进制可以简化为3位，所有#aabbcc的形式，能够简化为#abc&lt;/strong&gt;。举例如下：&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#f00;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#112233;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#123;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，比如下面这个是无法简化的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#222333;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如，下面这个也是无法简化的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#123123;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几种常见的颜色简写可以记住。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #000   黑
    #fff   白
    #f00   红
    #222   深灰
    #333   灰
    #ccc   浅灰&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;background-repeat属性重要&quot;&gt;&lt;code&gt;background-repeat&lt;/code&gt;属性（重要）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;background-repeat:no-repeat;&lt;/code&gt;设置背景图片是否重复及如何重复，默认平铺满。属性值可以是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no-repeat&lt;/code&gt;（不要平铺）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-x&lt;/code&gt;（横向平铺）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-y&lt;/code&gt;（纵向平铺）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个属性在开发的时候也是经常用到的。我们通过设置不同的属性值来看一下效果吧：&lt;/p&gt;
&lt;p&gt;（1）不加这个属性时：（即默认时）（背景图片会被平铺满）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：padding的区域也是有背景图的。&lt;/p&gt;
&lt;p&gt;（2）属性值为&lt;code&gt;no-repeat&lt;/code&gt;（不要平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）属性值为&lt;code&gt;repeat-x&lt;/code&gt;（横向平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-21.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这种属性的作用还是很广的。举个例子，设计师设计一张宽度只有1px、颜色纵向渐变的图片，然后我们通过这个属性将其进行水平方向的平铺，就可以看到整个页面都是渐变的了。&lt;/p&gt;
&lt;p&gt;在搜索引擎上搜“&lt;strong&gt;平铺背景&lt;/strong&gt;”，就可以发现，&lt;strong&gt;周期性的图片&lt;/strong&gt;可以采用此种方法进行平铺。&lt;/p&gt;
&lt;p&gt;（4）属性值为&lt;code&gt;repeat-y&lt;/code&gt;（纵向平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-22.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;background-position属性&quot;&gt;&lt;code&gt;background-position&lt;/code&gt;属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;background-position&lt;/code&gt;属性指的是&lt;strong&gt;背景定位&lt;/strong&gt;属性。公式如下：&lt;/p&gt;
&lt;p&gt;在描述属性值的时候，有两种方式：用像素描述、用单词描述。下面分别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用像素值描述属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-position:向右偏移量 向下偏移量;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性值可以是正数，也可以是负数。比如：&lt;code&gt;100px 200px&lt;/code&gt;、&lt;code&gt;-50px -120px&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1643.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、用单词描述属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-position: 描述左右的词 描述上下的词;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;描述左右的词：left、center、right&lt;/li&gt;
&lt;li&gt;描述上下的词：top 、center、bottom&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如说，&lt;code&gt;right center&lt;/code&gt;表示将图片放到右边的中间；&lt;code&gt;center center&lt;/code&gt;表示将图片放到正中间。&lt;/p&gt;
&lt;p&gt;位置属性有很多使用场景的。我们来举两个例子。&lt;/p&gt;
&lt;p&gt;场景1：（大背景图）&lt;/p&gt;
&lt;p&gt;打开“暗黑3 台湾”的官网&lt;a href=&quot;https://tw.battle.net/d3/zh/&quot; class=&quot;uri&quot;&gt;https://tw.battle.net/d3/zh/&lt;/a&gt;，可以看到官网的效果是比较炫的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1945.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查网页后，找到网站背景图片的url：&lt;a href=&quot;https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg&quot; class=&quot;uri&quot;&gt;https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg&lt;/a&gt;。背景图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1950.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，我们是通过把这张图片作为网站的背景图来达到显示效果的。只需要给body标签加如下属性即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        body{
            background-image: url(/Users/smyhvae/Dropbox/img/20170812_1950.jpg);
            background-repeat: no-repeat;
            background-position: center top;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，如果没加&lt;code&gt;background-position&lt;/code&gt;这个属性，背景图会默认处于浏览器的左上角（显得很丑）；加了此属性之后，图片在水平方向就位于浏览器的中间了。&lt;/p&gt;
&lt;p&gt;场景2：（通栏banner）&lt;/p&gt;
&lt;p&gt;很多网站的首页都会有banner图（网站最上方的全屏大图叫做「&lt;strong&gt;通栏banner&lt;/strong&gt;」），这种图要求横向的宽度特别大。比如说，设计师给你一张1920*465的超大banner图，如果我们把这个banner图作为img标签直接插入网页中，会有问题的：首先，图片不在网页的中间；其次，肯定会出现横向滚动条。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1102.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的做法是，将banner图作为div的背景图，这样的话，背景图超出div的部分，会自动移溢出。需要给div设置的属性如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;        div&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;465px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-image:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;url(&lt;/span&gt;http://img&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;smyhvae&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;com/&lt;span class=&quot;dt&quot;&gt;20170813&lt;/span&gt;_1053&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;jpg&lt;span class=&quot;dt&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-repeat:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;no-repeat&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码中，我们给div设置height（高度为banner图的高度），不需要设置宽度（因为宽度会自动霸占整行）。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1119.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出，将banner图作为div的背景后，banner图会永远处于网页的正中间（水平方向来看）。&lt;/p&gt;
&lt;h3 id=&quot;background-attachment属性&quot;&gt;background-attachment属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;background-attachment:scroll;&lt;/code&gt; 设置背景图片是否固定。属性值可以是：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;fixed&lt;/code&gt;（背景就会被固定住，不会被滚动条滚走）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scroll&lt;/code&gt;（与fixed属性相反，默认属性）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;background-attachment:fixed;&lt;/code&gt;的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1158.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;background综合属性&quot;&gt;background综合属性&lt;/h3&gt;
&lt;p&gt;background属性和border一样，是一个综合属性，可以将多个属性写在一起。(在&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/7256371.html&quot;&gt;盒子模型&lt;/a&gt;这篇文章中专门讲到boder)&lt;/p&gt;
&lt;p&gt;举例1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background:red url(1.jpg) no-repeat 100px 100px fixed;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:red;
    background-image:url(1.jpg);
    background-repeat:no-repeat;
    background-position:100px 100px;
    background-attachment:fixed;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以后，我们可以用小属性层叠掉大属性。&lt;/p&gt;
&lt;p&gt;上面的属性中，可以任意省略其中的一部分。&lt;/p&gt;
&lt;p&gt;比如说，对于下面这样的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background: blue url(images/wuyifan.jpg) no-repeat 100px 100px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：以后的CSS3内容中，我们会接触到更多的background属性： background-origin、background-clip、background-size（在CSS2.1背景图片是不能调整尺寸，IE9开始兼容）、多背景。&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 14:13:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8277895.html</dc:identifier>
</item>
<item>
<title>js上传图片 - 大兔兔</title>
<link>http://www.cnblogs.com/daijie/p/8277747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daijie/p/8277747.html</guid>
<description>&lt;p&gt;额    呆坐许久  感觉 有很多想写的  就是不知从何写起。。贼尴尬。  &lt;/p&gt;
&lt;p&gt;其实 我平时项目中 基本上传图片什么的  都是跟着from 表单 一起提交给后台的  &lt;/p&gt;
&lt;p&gt;实行起来 简单暴力  &lt;/p&gt;
&lt;p&gt;连图片预览的都没有写    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其实 实行图片的预览功能 非常简单的&lt;/span&gt;&lt;/strong&gt;   比如 代码如下&lt;/p&gt;
&lt;p&gt;html 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img'  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='img'  &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;='图片的预览'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js 代码&lt;/p&gt;
&lt;p&gt;需要先加载 jquery.js 哈  不然  会报错的 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 预览 方法一   &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 这个是 在对象发生改变时触发  也就是对应的我们 选择完成图片后  会触发&lt;/span&gt;
 $(&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取图片对象数组 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; file=$(&quot;#pic&quot;)[0].files[0&lt;span&gt;];
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片生成blob额  这儿我也不知道叫什么  可以生成一个 本地的临时预览图片的字符串  &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;暂且叫他 blob对象吧   有知道叫什么的大佬 记得留言告诉我哈  省得改天出门丢人了&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; blob=&lt;span&gt; window.URL.createObjectURL(file);
        $(&lt;/span&gt;&quot;#img&quot;).attr('src',blob);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将blob字符串 赋予给 img标签  即可完成图片的预览&lt;/span&gt;
&lt;span&gt;    })

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 预览 方法二&lt;/span&gt;
&lt;span&gt;将file对象 转成 dataURL  进行预览   
 $(&lt;/span&gt;&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取图片对象数组 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; file=$(&quot;#pic&quot;)[0].files[0&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个。。好吧 我也不知道这个是叫什么对象  &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fr=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();
        fr.readAsDataURL(file);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入图片对象 将其转成base64字符串&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个 onload是指的加载完毕的意思  在加载完毕后 将 转好的字符串给赋值给img标签&lt;/span&gt;
        fr.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            $(&lt;/span&gt;&quot;#img&quot;).attr('src',&lt;span&gt;this&lt;/span&gt;.result);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值 进行预览&lt;/span&gt;
&lt;span&gt;        }
    })    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面俩种方式  我更喜欢 blob 一些 &lt;/p&gt;
&lt;p&gt;blob    生成的预览地址  短   只能客户端 本地浏览  退出浏览器时 就会失效   （恩 好像是这样的）&lt;/p&gt;
&lt;p&gt;dataURL     生成的字符串比较长   但是 可以远程访问  或者 直接将这个字符串 发送给后台  返回 进行 base64解码  即可转回二进制  也就是图片数据  然后写出图片 &lt;/p&gt;

&lt;p&gt;图片的预览就说到这里了  不过 单单只是图片预览 那怎么能行   当然还得用js进行提交&lt;/p&gt;
&lt;p&gt;相对于 直接from的表单提交  js提交 有它非常显著的优势  &lt;/p&gt;
&lt;p&gt;1、 页面无需刷新  即可完成提交上传  返回上传状态  给用户良好的体验效果&lt;/p&gt;
&lt;p&gt;2、服务器不给力 或者 上传的图片过大时  会有较长的 等待时间  用js的话 可以做弹出loading 加载层  避免用户重复点击  重复的上传 也是非常利于用户体验度&lt;/p&gt;
&lt;p&gt;3、可以做循环单张上传  实时的告诉用户 上传了几张  还有几张待上传  &lt;/p&gt;
&lt;p&gt;反正就是用户体验度大大加强了&lt;/p&gt;

&lt;p&gt;ajax 提交上传图片demo&lt;/p&gt;
&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;='提交上传' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='sub()'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sub(){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个。。额  参数对象吧  原谅我野路子出身 可以用来添加一些 表单参数的&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fromObj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图片对象&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; files=$(&quot;#pic&quot;)[0&lt;span&gt;].files;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片对象 添加进待上传参数中&lt;/span&gt;
   fromObj.append('pic'&lt;span&gt;,files);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jquery 的ajax方法   也是我们常用的 前后台交互工具&lt;/span&gt;
&lt;span&gt;        $.ajax({
            url:&lt;/span&gt;'http://localhost/demo/farmer/app-main-pic',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传的路径&lt;/span&gt;
            type:'POST'&lt;span&gt;,
            data:fromObj,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传的方式&lt;/span&gt;
            contentType:&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            processData:&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            success:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
               console.log(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印页面返回的内容&lt;/span&gt;
&lt;span&gt;            }
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后端代码的话 就跟我们平常 接收表单上传的图片一样 &lt;/p&gt;
&lt;p&gt;比如 php的话  就是   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就可以查看 我们上传的图片信息了 &lt;/span&gt;
 &lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$_FILES&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在  我们就知道了 怎么js预览上传的图片  以及 用js进行上传图片了  但是仅仅这样 依然是达不到我们的理想效果 &lt;/p&gt;
&lt;p&gt;我们可能还会需要  对预览中的图片 进行 删除操作  图片传多了 不想上传某张图片了&lt;/p&gt;
&lt;p&gt;继续往下看代码吧    天太冷了  代码没怎么整理 仅做了点基础实现  样式优化的话 还得小伙伴们自己努力下哈&lt;/p&gt;
&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;='提交上传' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='sub()'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='show'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 因为有多张图片 所以不适合写死一个img标签了 这儿用来存放img &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这个用来 存img的样式的 没有用js去拼接字符串 直接写好样式后 用js进行 关键字替换 这样 以后修改样式也会毕竟方便 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='display: &lt;/span&gt;&lt;span&gt;none' id&lt;/span&gt;&lt;span&gt;='jsText'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='{{url}}' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;='{{title}}' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='del(this)' &lt;/span&gt;&lt;span&gt;data-name&lt;/span&gt;&lt;span&gt;='{{name}}' &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;='图片的预览'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个 存放上传的图片数据的对象  因为 file标签里面 第二次选择的图片 会覆盖掉 第一次的图片 所以 这个是有必要的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ajax_files=&lt;span&gt;{};
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;预览图片&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    $(&lt;/span&gt;&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 获取图片对象 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; files=$(&quot;#pic&quot;)[0&lt;span&gt;].files;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们写好的img模板&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; text=$('#jsText'&lt;span&gt;).html();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环选中的图片&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;files.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否已经选择过该图片&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;ajax_files.hasOwnProperty(files[i].name)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建blob对象字符串&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; blob=&lt;span&gt; window.URL.createObjectURL(files[i]);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换img模板里面的关键字  其实和js的字符串拼接img代码 是一个意思&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; str=reload(text,{url:blob,title:files[i].name+' 【单击删除】'&lt;span&gt;,name:files[i].name});
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拼接好的img 放入用于显示的div里面&lt;/span&gt;
                $('#show'&lt;span&gt;).append(str);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并将改图片数据 保存到全局的图片对象内&lt;/span&gt;
                ajax_files[files[i].name]=&lt;span&gt;files[i];
            }
        }
    })
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; del(obj){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图片本身&lt;/span&gt;
&lt;span&gt;        $(obj).remove();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name=$(obj).attr('data-name'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在全局图片对象中删除当前图片&lt;/span&gt;
        &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ajax_files[name];
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;js上传&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sub(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建参数对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fromObj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
        console.log(&lt;/span&gt;&quot;以下为待上传图片&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ajax_files){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在控制台打印待上传的图片数据&lt;/span&gt;
&lt;span&gt;            console.log(ajax_files[i].name,ajax_files[i].type,ajax_files[i].size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片添加至待上传对象中&lt;/span&gt;
             fromObj.append('avatar[]'&lt;span&gt;,ajax_files[i]);
        }
        $.ajax({
            url:&lt;/span&gt;'http://localhost/demo/farmer/app-main-pic'&lt;span&gt;,
            type:&lt;/span&gt;'POST'&lt;span&gt;,
            data:fromObj,
            contentType:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            processData:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(e);&lt;/span&gt;
&lt;span&gt;            }
        })
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字符串替换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; reload(text,data){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = &lt;span&gt;new&lt;/span&gt; RegExp('({{'+key+'}})','g'&lt;span&gt;);
            text&lt;/span&gt;=&lt;span&gt;text.replace(reg,data[key]);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; text;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无比丑陋的ui界面   一开始选择了4涨图片 不过  有删除了一张 再进行的上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210608/201801/1210608-20180112211800551-1001623712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上就是本篇文章的全部代码了   首先感谢 小伙伴们耐心的看完了本文章  希望能对你有所帮助&lt;/p&gt;
&lt;p&gt;代码有什么错误 或者 不理解的地方 可以直接联系我哈   能解决的 会尽量帮忙解决哈&lt;/p&gt;

&lt;p&gt;那么。。。晚安了各位！！&lt;/p&gt;

&lt;p&gt; ------------------------该文章来自一只贼蠢贼蠢的程序员&lt;/p&gt;



</description>
<pubDate>Fri, 12 Jan 2018 13:21:00 +0000</pubDate>
<dc:creator>大兔兔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daijie/p/8277747.html</dc:identifier>
</item>
<item>
<title>ActiveMQ入门介绍 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/activemq.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/activemq.html</guid>
<description>&lt;h3&gt; 1.JMS简介&lt;/h3&gt;
&lt;p&gt;    JMS的全称是Java Message Service，即Java消息服务。它主要用于在生产者和消费者之间进行消息传递，生产者负责产生消息，而消费者负责接收消息。把它应用到实际的业务需求中可以在特定的时候利用生产者生成消息，并进行发送，对应的消费者在接收到对应的消息后去完成对应的业务逻辑。对于消息的传递有两种类型，一种是点对点的，即一个生产者和一个消费者一一对应；另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMS编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) ConnectionFactory&lt;/p&gt;
&lt;p&gt;    创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。&lt;/p&gt;
&lt;p&gt;(2) Destination&lt;/p&gt;
&lt;p&gt;    Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。&lt;/p&gt;
&lt;p&gt;(3) Connection&lt;/p&gt;
&lt;p&gt;    Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。&lt;/p&gt;
&lt;p&gt;(4) Session&lt;/p&gt;
&lt;p&gt;    Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。&lt;/p&gt;
&lt;p&gt;(5) 消息的生产者&lt;/p&gt;
&lt;p&gt;    消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。&lt;/p&gt;
&lt;p&gt;(6) 消息消费者&lt;/p&gt;
&lt;p&gt;    消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。&lt;/p&gt;
&lt;p&gt;(7) MessageListener&lt;/p&gt;
&lt;p&gt;    消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。&lt;/p&gt;
&lt;h3&gt; 2.ActiveMQ简介&lt;/h3&gt;
&lt;p&gt;    ActiveMQ是Apache软件基金下的一个开源软件，它遵循JMS规范（Java Message Service），是消息驱动中间件软件（MOM）。它为企业消息传递提供高可用，出色性能，可扩展，稳定和安全保障。ActiveMQ使用Apache许可协议。因此，任何人都可以使用和修改它而不必反馈任何改变。这对于商业上将ActiveMQ用在重要用途的人尤为关键。MOM的工作是在分布式的各应用之间调度事件和消息，使之到达指定的接收者。所以高可用，高性能，高可扩展性尤为关键。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ActiveMQ特性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    ⒈支持多种语言客户端,如:Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议有 OpenWire,Stomp REST,WS Notification,XMPP,AMQP。&lt;/p&gt;
&lt;p&gt;    ⒉ 完全支持JMS1.1和J2EE1.4规范,它们包括同步和异步消息传递，一次和只有一次的消息传递，对于预订者的持久消息等。依附于JMS规范意味着，不论JMS消息提供者是谁，同样的基本特性（持久化，XA消息，事务)都是有效的。&lt;/p&gt;
&lt;p&gt;    ⒊ 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去。&lt;/p&gt;
&lt;p&gt;    ⒋ 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上。&lt;/p&gt;
&lt;p&gt;    ⒌ ActiveMQ提供各种连接选择，包括HTTP，HTTPS，IP多点传送，SSL，STOMP，TCP，UDP，XMPP等。大量的连接协议支持使之具有更好的灵活性。很多现有的系统使用一种特定协议并且不能改变，所以一个支持多种协议的消息平台降低了使用的门槛。虽然连接很重要，但是和其他容器集成也同样重要。&lt;/p&gt;
&lt;p&gt;    6.ActiveMQ提供多种持久性方案可供选择，也可以完全按自己需求定制验证和授权。例如，ActiveMQ通过KahaDB提供自己的超快速消息持久方案（ultra-fast message persistence），但也支持标准的JDBC方案。ActiveMQ可以通过配置文件提供简单的验证和授权，也提供标准的JAAS登陆模块。&lt;/p&gt;
&lt;p&gt;    7.ActiveMQ是为开发者设计的。它并不需要专门的管理工具，因为它提供各种易用且强大的管理特性。有很多方法去监控ActiveMQ的各个方面，可以通过JMX使用JConsole或ActiveMQ web console；可以运行ActiveMQ消息报告；可以用命令行脚本；可以通过日志。&lt;/p&gt;
&lt;p&gt;    8.代理器集群（Broker clustering）----为了利于扩展，多个ActiveMQ broker能够联合工作。这个方式就是network of brokers并且能支持多种拓扑结构;支持客户端-服务器，点对点。&lt;/p&gt;
&lt;p&gt;    9.支持Ajax, 支持与Axis的整合&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ActiveMQ优势&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    1.与OpenJMS、JbossMQ等开源jms provider相比，ActiveMQ有Apache的支持，持续发展的优势明显。&lt;/p&gt;
&lt;p&gt;    2.消息处理速度很快&lt;/p&gt;
&lt;p&gt;    3.提高系统资源的利用率，主要是任务的派发不是24小时平均的，而是高峰时期任务量很多，比如1秒1000多个，有的时候很低，比如十几秒钟才来一个。应用服务通过JMS队列一个一个的取任务，做完一个再领一个，使系统资源的运用趋于平均。比如ActiveMQ在赛扬（2.40GHz）机器上能够达到2000/s，消息大小为1-2k。好一些的服务器可以达到2万以上/秒。&lt;/p&gt;
&lt;h3&gt; 3.ActiveMQ安装&lt;/h3&gt;
&lt;p&gt;    ActiveMQ在linux服务上安装操作如下：&lt;/p&gt;
&lt;p&gt;    1.在官网下载activemq安装文件。地址：&lt;a href=&quot;http://activemq.apache.org/download.html&quot; target=&quot;_blank&quot;&gt;http://activemq.apache.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    2.上传下载的tar.gz安装文件到linux服务器上，并解压到指定目录：如 tar -xf apache-activemq-5.15.2-bin.tar.gz&lt;/p&gt;
&lt;p&gt;    3.运行activemq，进入到解压的 apache-activemq-5.15.2/bin目录，执行命令：activemq start&lt;/p&gt;
&lt;p&gt;    4.开放端口8161，61616，保证端口可访问。&lt;/p&gt;
&lt;p&gt;   运行activemq截图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111214446472-1994868127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 本机访问启动成功的activemq截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111214502285-1679284127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 4.ActiveMQ类别及开发流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;   1)、Point-to-Point (点对点)消息模式开发流程&lt;/strong&gt;&lt;br/&gt;       1、生产者（producer）开发流程： &lt;/p&gt;
&lt;p&gt;         1.1 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         1.2 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;         1.3 创建Destination对象： 需指定其对应的主题（subject）名称，producer和consumer将根据subject来发送/接收对应的消息。 &lt;/p&gt;
&lt;p&gt;         1.4 创建MessageProducer： 根据Destination创建MessageProducer对象，同时设置其持久模式。 &lt;/p&gt;
&lt;p&gt;         1.5 发送消息到队列（Queue）： 封装Message消息，使用MessageProducer的send方法将消息发送出去。 &lt;/p&gt;
&lt;p&gt;       2、消费者（consumer）开发流程： &lt;/p&gt;
&lt;p&gt;         2.1 实现MessageListener接口： 消费者类必须实现MessageListener接口，然后在onMessage()方法中监听消息的到达并处理。 &lt;/p&gt;
&lt;p&gt;         2.2 创建Connection： 根据url，user和password创建一个jms Connection，如果是durable模式，还需要给connection设置一个clientId。 &lt;/p&gt;
&lt;p&gt;         2.3 创建Session和Destination： 与ProducerTool.java中的流程类似，不再赘述。 &lt;/p&gt;
&lt;p&gt;         2.4 创建replyProducer【可选】：可以用来将消息处理结果发送给producer。 &lt;/p&gt;
&lt;p&gt;         2.5 创建MessageConsumer：  根据Destination创建MessageConsumer对象。 &lt;/p&gt;
&lt;p&gt;         2.6 消费message：  在onMessage()方法中接收producer发送过来的消息进行处理，并可以通过replyProducer反馈信息给producer &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   样例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在消息生产者中定义一个队列，destination_request,提供消息，同时定义一个监听消息的队列拥有接受消费者回复的消息，destination_response。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.Email;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.service.ProducerService;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerSendTest {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        ConnectionFactory connectionFactory;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        Connection connection;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        Session session;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        Destination destination_request,destination_response;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        MessageProducer producer;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        MessageConsumer consumer;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            connection.start();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是是否是事务型消息，设置为true,第二个参数无效
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数是
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Session.AUTO_ACKNOWLEDGE为自动确认，客户端发送和接收消息不需要做额外的工作。异常也会确认消息，应该是在执行之前确认的
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Session.CLIENT_ACKNOWLEDGE为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会删除消息。可以在失败的
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时候不确认消息,不确认的话不会移出队列，一直存在，下次启动继续接受。接收消息的连接不断开，其他的消费者也不会接受（正常情况下队列模式不存在其他消费者）
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DUPS_OK_ACKNOWLEDGE允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。在需要考虑资源使用时，这种模式非常有效。
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待测试&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.CLIENT_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             destination_request = session.createQueue(&quot;request-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             destination_response = session.createQueue(&quot;response-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             producer =&lt;span&gt; session.createProducer(destination_request);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             consumer =&lt;span&gt; session.createConsumer(destination_response);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;优先级不能影响先进先出。。。那这个用处究竟是什么呢呢呢呢&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             TestMqBean bean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestMqBean();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             bean.setAge(13&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 bean.setName(&quot;send to data -&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                producer.send(session.createObjectMessage(bean));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            producer.close();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             System.out.println(&quot;消息发送成功...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; message) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             TextMessage textMsg =&lt;span&gt; (TextMessage) message;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             System.out.println(&quot;收到回馈消息&quot; +&lt;span&gt;textMsg.getText());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    在消息消费者中定义一个队列，destination_request,用于接受消息，同时定义一个回复收到消息的队列回复生产者已经收到消息，destination_response。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerReceiveTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        ConnectionFactory connectionFactory;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Connection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Session session;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destination ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        Destination destination_request,destination_response;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者，消息接收者&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        MessageConsumer consumer;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回复接收到的消息&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageProducer producer;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造从工厂得到连接对象&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            connection.start();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取操作连接
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个最好还是有事务&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             session =&lt;span&gt; connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session注意参数值xingbo.xu-queue是一个服务器的queue，须在在ActiveMq的console配置&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             destination_request = session.createQueue(&quot;request-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             destination_response = session.createQueue(&quot;response-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             consumer =&lt;span&gt; session.createConsumer(destination_request);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             producer=&lt;span&gt; session.createProducer(destination_response);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         TestMqBean bean =&lt;span&gt; (TestMqBean) ((ObjectMessage) message).getObject();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        System.out.println(bean);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; message) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             System.out.println(&quot;收到消息&quot; +&lt;span&gt; bean.getName());
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                             Message textMessage = session.createTextMessage(&quot;已经成功收到消息，现在开始回复&quot;+&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                            producer.send(textMessage);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    消息消费者收到消息，并打印出来，同时发送回复消息。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111212654957-1210408589.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    消息生产者生产消息，同时接受到消费者回复的消息并打印出来。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111212731051-2120619361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   2)、Publisher/Subscriber(发布/订阅者)消息模式开发流程 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       1、订阅者（Subscriber）开发流程： &lt;/p&gt;
&lt;p&gt;         1.1 实现MessageListener接口： 在onMessage()方法中监听发布者发出的消息队列，并做相应处理。 &lt;/p&gt;
&lt;p&gt;         1.2 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         1.3 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;          1.4 创建Topic：  创建2个Topic， topictest.messages用于接收发布者发出的消息，topictest.control 用于向发布者发送消息，实现双方的交互。 &lt;/p&gt;
&lt;p&gt;         1.5 创建consumer和producer对象：根据topictest.messages创建consumer，根据topictest.control创建 producer。 &lt;/p&gt;
&lt;p&gt;         1.6 接收处理消息：在onMessage()方法中，对收到的消息进行处理，可直接简单在本地显示消息，或者根据消息内容不同处理对应的业务逻辑（比如：数据库更新、文件操作等等），并且可以使用producer对象将处理结果返回给发布者。 &lt;/p&gt;
&lt;p&gt;       2、发布者（Publisher）开发流程：&lt;/p&gt;
&lt;p&gt;         2.1 实现MessageListener接口：在onMessage()方法中接收订阅者的反馈消息。 &lt;/p&gt;
&lt;p&gt;         2.2 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         2.3 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;         2.4 创建Topic： 创建2个Topic，topictest.messages用于向订阅者发布消息，topictest.control用于接 收订阅者反馈的消息。这2个topic与订阅者开发流程中的topic是一一对应的。 &lt;/p&gt;
&lt;p&gt;         2.5 创建consumer和producer对象： 根据topictest.messages创建publisher； 根据topictest.control 创建consumer，同时监听订阅者反馈的消息。&lt;/p&gt;
&lt;p&gt;         2.6 给所有订阅者发送消息，并接收反馈消息。 注：可同时运行多个订阅者测试查看此模式效果 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   样例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    消息发布者发布消息，定义一个主题example.A&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicProducerSendTest {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String user = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String password = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String url = &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConnectionFactory ：连接工厂，JMS 用它创建连接&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveMQConnectionFactory(user,password,url);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection 启动&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        connection.start();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;Connection is start...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Session session =&lt;span&gt; connection.createSession(Boolean.TRUE,Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Topicr ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         Topic  destination = session.createTopic(&quot;example.A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MessageProducer：消息发送者&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         MessageProducer producer =&lt;span&gt; session.createProducer(destination);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不持久化，此处学习，实际根据项目决定&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        producer.setDeliveryMode(DeliveryMode.PERSISTENT);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造消息，此处写死，项目就是参数，或者方法获取&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        sendMessage(session, producer);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        connection.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         System.out.println(&quot;send text ok.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMessage(Session session, MessageProducer producer)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 10; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有限制&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             TextMessage message = session.createTextMessage(&quot;ActiveMq 发送的消息&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息到目的地方&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            producer.send(message);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;     消息订阅者接收消息，定义一个与发布者相对应的主题example.A。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicSubscriberTest {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String user = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String password = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String url = &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConnectionFactory ：连接工厂，JMS 用它创建连接&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveMQConnectionFactory(user,password,url);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        connection.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Session session =&lt;span&gt; connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destination ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Topic destination=session.createTopic(&quot;example.A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者，消息接收者&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         MessageConsumer consumer =&lt;span&gt; session.createConsumer(destination);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt; MessageListener(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有事务限制&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     TextMessage textMessage=&lt;span&gt;(TextMessage)message;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     System.out.println(&quot;接收到消息：&quot;+&lt;span&gt;textMessage.getText());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e1) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    session.commit();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    消息发布者发布消息，并打印截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111213951566-1861631683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  消息订阅者接受消息并打印截图如下：（消息订阅者需在发布者之前启动，可保证能取到订阅的消息）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111213920176-923231449.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Jan 2018 13:19:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/activemq.html</dc:identifier>
</item>
<item>
<title>深入理解ES6之—数据解构 - 寻找石头鱼</title>
<link>http://www.cnblogs.com/xzsty/p/8277695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xzsty/p/8277695.html</guid>
<description>&lt;p&gt;对象解构语法在赋值语句的左侧使用了对象字面量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let node = {
    type: true,
    name: false
}

//既声明又赋值
let {
    type,
    name
} = node;

//或者先声明再赋值
let type, name
({type,name} = node);
console.log(type);//true
console.log(name);//false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type与name标识符既声明了本地变量，也读取了对象的相应属性值。&lt;/p&gt;
&lt;p&gt;解构赋值表达式的值为表达式右侧的值。当解构表达式的右侧的计算结果为null或者undefined时，会抛出错误。&lt;/p&gt;
&lt;h2 id=&quot;默认值&quot;&gt;默认值&lt;/h2&gt;
&lt;p&gt;当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为undefined&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let node = {
    type: true,
    name: false
},
    type, name, value;
({type,value,name} = node);

console.log(type);//true
console.log(name);//false
console.log(value);//undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let node = {
        type: true,
        name: false
    },
    type, name, value;
({
    type,
    value = true,
    name
} = node);

console.log(type);//true
console.log(name);//false
console.log(value);//true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;赋值给不同的本地变量名&quot;&gt;赋值给不同的本地变量名&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;let node = {
    type: true,
    name: false,
    value: &quot;dd&quot;
}
let {
    type: localType,
    name: localName,
    value: localValue = &quot;cc&quot;
} = node;
console.log(localType);
console.log(localName);
console.log(localValue);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type:localType这种语法表示要读取名为type的属性，并把它的值存储在变量localType上。该语法与传统对象字面量的语法相反&lt;/p&gt;
&lt;h2 id=&quot;嵌套的对象结构&quot;&gt;嵌套的对象结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;let node = {
type: &quot;Identifier&quot;,
name: &quot;foo&quot;,
loc: {
    start: {
        line: 1,
        column: 1
    },
    end: {
        line: 1,
        column: 4
    }
}
}

let {
loc: localL,
loc: {
    start: localS,
    end: localE
}
} = node;

console.log(localL);// start: {line: 1,column: 1},end: {line: 1,column: 4}
console.log(localS);//{line: 1,column: 1}
console.log(localE);//{line: 1,column: 4}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中（loc: {start: localS,end: localE}）&lt;/p&gt;

&lt;p&gt;数组解构的语法看起来跟对象解构非常相似，只是将对象字面量换成了数组字面量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
let [firstC, secondC, thirdC, thursC = &quot;yellow&quot;] = colors;
console.log(firstC//red
console.log(secondC);//blue
console.log(thirdC);//green
console.log(thursC);//yellow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以在解构模式中忽略一些项，并只给感兴趣的项提供变量名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];

let [,,thirdC] = colors;
console.log(thirdC);//blue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thirdC之前的逗号是为数组前面的项提供的占位符。使用这种方法，你就可以轻易从数组任意位置取出值，而无需给其他项提供名称。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;let colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;],
    firstColor = &quot;black&quot;,
    secondColor = &quot;purple&quot;;
[firstColor,secondColor] = colors;
console.log(firstColor);//red
console.log(secondColor);//green&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组解构有一个非常独特的用例，能轻易的互换两个变量的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a =1,b =2;
[a,b] = [b,a];
console.log(a);//2
console.log(b);//1&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt; let colors = [&quot;red&quot;, [&quot;green&quot;, &quot;blue&quot;], &quot;yellow&quot;];
let [firstC, [, ssc]] = colors;
console.log(ssc);//blue&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
let [firstC, ...restC] = colors;
console.log(firstC);
console.log(...restC);
console.log(restC[0]);//green
console.log(restC[1]);//blue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用剩余项可以进行数组克隆&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
let [...restC] = colors;
console.log(restC);//[&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;let node = {
type: &quot;Identifier&quot;,
name: 'foo',
loc: {
    start: {
        line: 1,
        column: 1
    },
    end: {
        line: 1,
        column: 4
    }
},
range: [0, 3]
}

let {
type,
name: localName,
loc: {
    start: {
        line: ll
    },
    end: {
        column: col
    }
},
range: [, second]
} = node;

console.log(type);//Identifier
console.log(localName);//foo
console.log(ll);//1
console.log(col);//4
console.log(second);//3&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 12 Jan 2018 13:18:00 +0000</pubDate>
<dc:creator>寻找石头鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xzsty/p/8277695.html</dc:identifier>
</item>
<item>
<title>掌握一门语言Go - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/go.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/go.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;摘要：Go语言的优势不必多说，通过本篇文章，让我们花时间来掌握一门外语，Let's Go!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;关键字：Go语言，闭包，基本语法，函数与方法，指针，slice，defer,channel，goroutine，select&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;go开发环境&quot;&gt;Go开发环境&lt;/h2&gt;
&lt;p&gt;针对Go语言，有众多老牌新厂的IDE。本地需要下载Go安装包，无论Windows还是Linux，安装差不多。这里推荐手动安装方式，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装包下载地址：&lt;a href=&quot;https://www.golangtc.com/download&quot; class=&quot;uri&quot;&gt;https://www.golangtc.com/download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解压缩存放相应位置（linux可选位置usr/local），设置环境变量GOROOT指向Go安装目录，并将GOROOT/bin目录放置PATH路径下&lt;/li&gt;
&lt;li&gt;设置环境变量GOPATH，这个目录就是告诉Go你的workspace，一个Go工程对应一个workspace。每个workspace内的结构一般包含src，pkg，bin三个目录，其实是仿照Go安装目录，建立了一个独立的Go环境，可以执行bin中我们自己构建的命令。&lt;/li&gt;
&lt;li&gt;Go语言开发相当于堆积木，Go安装目录下已有的内容为积木的底座，为了防止我们构建的包与标准库有区分，我们需要独立的命名空间，例如普遍采用开发者本人github账户的命名空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gopath和goroot&quot;&gt;GOPATH和GOROOT&lt;/h3&gt;
&lt;p&gt;为了避免混淆加深印象，这里再针对GOPATH和GOROOT进行一个区分详解。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;GOROOT是GO的安装目录，存放GO的源码文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;GOPATH是我们使用GO开发的工作空间，类似于workspace的概念，但由于GO是高复用型，就像叠积木那样，我们开发的Go程序与GO标准库中的无异，我们编译的Go命令也与GOROOT/bin中的源码命令同级，因此对于一个GO工程，我们就要创建一个工作间添加到GOPATH中去，这个工程中的新开发的包都在该工作间目录结构下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一个GO工程工作间的目录结构包括:bin,src,pkg。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说src目录，该目录是我们开发的Go代码的所在地，bin是我们通过go install 将Go源码编译生成的一个可执行文件的存放地，pkg是go get获取的第三方依赖库，源码中使用到的第三方依赖包都会从pkg中去寻找，当然了也会在$GOROOT/pkg标准库中寻找。对了，在我看来，库和包的概念没有什么差异。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们还可以直接使用go build编译我们的源码，那将会直接在源码位置生成一个可执行文件，而不是像go install那样将该可执行文件安装在$GOPATH/bin目录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们应该将GOROOT和GOPATH均放到$HOME/.profile中去作为环境变量，同时要将$GOROOT/bin以及$GOPATH/bin均放到PATH中，以方便我们在任何位置直接访问go的命令以及我们自己生成的go命令。&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;hello, world&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你的helloworld一定要交给我 ✿◡‿◡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以来 &lt;a href=&quot;https://play.golang.org/&quot; class=&quot;uri&quot;&gt;https://play.golang.org/&lt;/a&gt; 玩一玩，但我不推荐，下面我们来搞一个完整helloworld。&lt;/p&gt;
&lt;p&gt;我们已完成上面介绍的开发环境的搭建，然后我们进入到GOPATH目录下，并进入src下我们设置的命名空间目录，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@ubuntu1604:~/workspace/src/github.com$ mkdir hello
liuwenbin@ubuntu1604:~/workspace/src/github.com$ cd hello/
liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ vi hello.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们创建了一个包hello，在包内又创建了一个hello.go文件，下面是具体helloworld代码编写内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
        fmt.Println(&quot;hello,world&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简单啰嗦两句。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个可执行的Go程序都需要满足：1、有一个main函数，2、程序第一行引入了package main。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的代码满足可执行条件，下面继续：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ go install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行go install将Go程序代码打包为可执行文件，保存在GOPATH/bin下，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ ls ~/workspace/bin
hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过检查，证实了可执行文件hello已被自动install成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ ~/workspace/bin/hello 
hello,world
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ export PATH=$HOME/workspace/bin:$PATH
liuwenbin@ubuntu1604:~/workspace/src/github.com/hello$ cd
liuwenbin@ubuntu1604:~$ hello
hello,world
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将GOPATH/bin加入到PATH当中，然后在任何位置键入hello都会执行我们的程序。&lt;/p&gt;
&lt;h2 id=&quot;ide&quot;&gt;IDE&lt;/h2&gt;
&lt;p&gt;IDE就选择官方主推的JetBrains家的goLand吧，亲测好用，至于激活码什么的，谷歌百度你懂的。&lt;/p&gt;
&lt;p&gt;goLand可以帮助我们：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时刻管理Go工程目录结构：包括源码位置、包管理一目了然，SDK或第三方依赖显而易见。&lt;/li&gt;
&lt;li&gt;统一管理环境变量，作用域可以是全局、工程以及模块。&lt;/li&gt;
&lt;li&gt;代码开发语法高亮，自动补全，代码候选项，源码搜索，文件对比，函数跳转，初步代码结构审查，格式化，根据你的习惯设置更方面的快捷键，设置TODO，任务列表。&lt;/li&gt;
&lt;li&gt;代码编译执行可视化，断点调试bug易于追踪。&lt;/li&gt;
&lt;li&gt;IDE内部直接调取终端，不用切换。&lt;/li&gt;
&lt;li&gt;可集成各种插件扩展功能，例如版本控制Git，github客户端，REST客户端等。&lt;/li&gt;
&lt;li&gt;多种数据库连接客户端可视化。&lt;/li&gt;
&lt;li&gt;更炫酷的界面，多种配色主题可选。&lt;/li&gt;
&lt;li&gt;自定义宏小工具集成到IDE，更加方便扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;go基本语法&quot;&gt;Go基本语法&lt;/h2&gt;
&lt;h3 id=&quot;包&quot;&gt;包&lt;/h3&gt;
&lt;p&gt;每个Go程序都是由包组成，程序的入口为main包，bin中的自定义命令就是一个Go程序，入口为main包的main函数，该入口程序文件还会依赖其他库的内容，可以是标准库，第三方库或者自己编写的库。这时要通过关键字import导入。而导入的库的程序文件的包名一定是导入路径的最后一个目录，例如import &quot;math/rand&quot;，&quot;math/rand&quot;包一定是由package rand开始。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
)

func main() {
    fmt.Println(&quot;rand number &quot;, rand.Intn(10))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;package声明当钱包，import导入依赖包，这与Java很相似。另外这里的rand.Intn方法也与其他语言一样是一个伪随机数，根据种子的变化而变化，如果种子相同，则生成的“随机数”也相同，这其实就是一种哈希算法。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;打包：观察代码可以发现，这里的import结构与上面编写helloworld的 import &quot;fmt&quot;相比发生了变化。这里导入了两个包，用圆括号组合了导入，这种方式称为“打包”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它等同于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import &quot;fmt&quot;
import &quot;math&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是仍旧提倡使用打包的方式来导入多个包。&lt;/p&gt;
&lt;p&gt;下面贴一个官方包的api地址： &lt;a href=&quot;https://go-zh.org/pkg/&quot; class=&quot;uri&quot;&gt;https://go-zh.org/pkg/&lt;/a&gt; ，这里面的包除了标准库，还有一些其他的附加包，新增包等，我们都可以通过上面提到的方式进行导入，在我们自己的代码中复用他们。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;
&lt;p&gt;这里面最大的不同之处在于函数的参数类型是在变量名的后面的，相应的，返回值的类型也在参数列表的后面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&quot;hello&quot;, &quot;world&quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相同类型的变量可以只在最后用一个类型表示。这里声明了返回值为两个string类型数据（string, string)。我们可以在这里通过声明返回值的类型返回任意数量的值。&lt;/p&gt;
&lt;p&gt;Go语言的函数与其他语言最大的不同除了数据类型在变量名后面进行声明以外，函数的返回值也是可以被命名的。上面讲到了可以直接定义返回值的数量以及数据类型，除此之外，还可以进一步对返回值进行定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(x, y int)定义了返回值的数量，类型，以及变量名，这些变量名在方法体内部处理进行赋值，方法在返回时return后面无需任何内容即可返回x和y的值。&lt;/p&gt;
&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;变量的声明定义创建以及初始化需要关键字var&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, &quot;no!&quot;
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，var后面加变量名，然后是变量类型，后面还可以直接等号加入初始化内容。var定义的变量的作用域可以在函数内也可在函数外。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;函数内部的短声明变量 :=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在函数内部，在明确类型的情况下，也即变量声明即初始化情况下，可以使用短声明变量的方式，省略了var关键字以及变量类型，例如k := 3，与var k int = 3等同，但要注意同一个变量不能被var或者:=声明两次，也即var或:=只能作用于新变量上。但是要注意只有函数内部才可以使用。函数外每条语句必须是var func等关键字为开头。&lt;/p&gt;
&lt;h3 id=&quot;基本类型&quot;&gt;基本类型&lt;/h3&gt;
&lt;p&gt;Go语言的数据基本类型包括bool，string，int，uint，float，complex。其中bool是布尔类型不多介绍，string是字符串，注意开头s是小写。int根据长度不同包括int8 int16 int32(rune) int64。uint为无符号整型类型，无符号整型就代表只能为正整数，根据长度也分为uint8(byte) uint16 uint32 uint64 uintptr。float浮点型包括float32 float64，复数类型包括complex64 complex128，Go语言支持了复数类型，这是java所不具备的。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;关键字&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;complex&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;包含&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;int8/16/32(rune)/64&lt;/td&gt;
&lt;td&gt;uint8(byte)/16/32/64 uintptr&lt;/td&gt;
&lt;td&gt;float32/64&lt;/td&gt;
&lt;td&gt;complex64/128&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;true, false&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;td&gt;正负整数&lt;/td&gt;
&lt;td&gt;正整数&lt;/td&gt;
&lt;td&gt;小数&lt;/td&gt;
&lt;td&gt;复数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;零值&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;&quot;&quot;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0(注意浮点的零值也为0，而不是0.0)&lt;/td&gt;
&lt;td&gt;(0+0i)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：int，uint，uintptr类型在32位系统上的长度是32位，在64位系统上是64位，经过测试可知，Go Playground后台是32位系统，因为int溢出了。另外，复数的运算一般都是与数学运算相关联，与业务处理关系较少。所以常用的类型就是bool，string，int，float四种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go数据类型的转换直接采用以类型关键字为函数名，参数为待转换变量的方式即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var i int = 42
var f float64 = float64(i)
var u uint = uint(f)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数内，直接使用短声明变量的方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i := 42
f := float64(i)
u := uint(f)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go作为功能强大的新型编程语言，也具备自动类型推导的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    var v = 1
    k:=3.1
    fmt.Printf(&quot;v is of type %T\n&quot;, v)
    fmt.Printf(&quot;k is of type %T\n&quot;, k)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;v is of type int
k is of type float64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型推导：即在未显示指定变量类型的时候，可以根据赋值情况来自动推导出变量类型。然而，当你在前面已经通过赋值推导出某变量的类型以后，再改变其值为其他类型就会报错。&lt;/p&gt;
&lt;p&gt;另外，在Println表达式中，%v代表值的默认形式，%T代表值的类型。&lt;/p&gt;
&lt;h3 id=&quot;常量&quot;&gt;常量&lt;/h3&gt;
&lt;p&gt;使用关键字const声明，可以是字符、字符串、布尔或数字类型的值，不能使用 := 语法定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

const Pi = 3.14

func main() {
    const World = &quot;世界&quot;
    fmt.Println(&quot;Hello&quot;, World)
    fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)

    const Truth = true
    fmt.Println(&quot;Go rules?&quot;, Truth)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Hello 世界
Happy 3.14 Day
Go rules? true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，还有数值常量，数值常量往往是高精度的值，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const (
    Big   = 1 &amp;lt;&amp;lt; 100
    Small = Big &amp;gt;&amp;gt; 99
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到了位运算符&amp;lt;&amp;lt;和&amp;gt;&amp;gt;，这里再复习一些位运算的知识。首先定义运算符左侧为原值，右侧为操作位数，运算符“&amp;lt;&amp;lt;”代表左移，即将原值用二进制方式表示，然后将其中的值左移相应位数，再还原回十进制表示结果，反之则为运算符“&amp;gt;&amp;gt;”。那么用一种更加容易理解的方式来讲是左移即为乘以2的n次方，n=操作位数，右移即除以2的n次方，n=操作位数。&lt;/p&gt;
&lt;h3 id=&quot;循环&quot;&gt;循环&lt;/h3&gt;
&lt;p&gt;同样的，关键字也为for，for的循环结构也与java相似，有初始化语句，循环终止条件，以及后置变化语句（例如自增自减）。不一样的地方是，这个循环结构没有圆括号，初始化变量的作用域在整个循环体内，另外，for也可以相当于其他语言的while使用，即去掉初始化语句和后置变化语句，只有一个循环终止条件，同样没有圆括号，但是循环体必须用花括号包围{}。下面看例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    for i := 0; i &amp;lt; 10; i++ {
        sum += i
    }
    // 如果初始化语句和后置变化都去掉的话，则省略分号；
    for ; sum &amp;lt; 10; {
        sum += sum
    }
    // 相当于while
    for sum &amp;lt; 10 {
        sum += sum
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化语句和后置变化语句都可以被省略，如果终止条件语句也被省略，循环就成了死循环。简洁的表示为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断语句&quot;&gt;判断语句&lt;/h3&gt;
&lt;p&gt;Go的if语句也不要用圆括号括起来，但方法体还是要用花括号{}的。与for一样，if语句也可以包含一个初始化语句，然后再接判断表达式，这个初始化变量的作用域仅在if语句内，包括与其成对的else语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &amp;lt; lim {
        return v
    }
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pow函数复写了math.pow(x,y float64)，加入了一个限制lim参数，当加幂值结果超过lim的时候，返回lim，未超过则返回结果。通过这个例子，可以看到if语句在判断表达式中加入了初始化语句。此外，main函数中的Println输出多条信息的方式，与前面介绍的import打包，const数值常量集都很相似，可以说明这种形式是Go的一种编程习惯。&lt;/p&gt;
&lt;p&gt;switch的逻辑同其他语言并没有太多出入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t := time.Now()
    switch {
    case t.Hour() &amp;lt; 12:
        fmt.Println(&quot;Good morning!&quot;)
    case t.Hour() &amp;lt; 17:
        fmt.Println(&quot;Good afternoon.&quot;)
    default:
        fmt.Println(&quot;Good evening.&quot;)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：Good evening.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于现在已经17：37，确实过了17点，所以输出为晚上好是合理的。此外，这里面引用到了time包，获取了当前时间，time.Now()，同样的，这可以通过上面给出的标准包文档查看。&lt;/p&gt;
&lt;h3 id=&quot;延迟执行&quot;&gt;延迟执行&lt;/h3&gt;
&lt;p&gt;这是一个Go语言独特的内容，关键字为defer，意思是defer声明的一行代码要它的上层函数执行完毕返回的时候再执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    defer fmt.Println(&quot;world&quot;)

    fmt.Println(&quot;hello&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello
world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defer关键字的声明使得world的输出虽然写在hello输出的上方，但必须等待hello输出完毕以后再输出。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;defer下压栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当defer关键字声明的代码不止一行的时候，就引入了defer下压栈的特性，这也是Go比骄强大的地方，根据下压栈的特点，后压入的那行代码会在上层函数执行完毕后先执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;counting&quot;)

    for i := 0; i &amp;lt; 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println(&quot;done&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;counting
done
9
8
7
6
5
4
3
2
1
0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;指针&quot;&gt;指针&lt;/h3&gt;
&lt;p&gt;指针我们都熟悉，大学时期学习C语言的时候折磨我们好久，Go语言中也支持指针，但它并不像我们印象中那么恐怖，因为它并不包含C的指针运算。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;指针保存了变量的内存地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&amp;amp; 符号会【生成】一个指向其作用对象的指针。&lt;/li&gt;
&lt;li&gt;* 符号表示指针指向的【底层的值】。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    i, j := 42, 2701

    p := &amp;amp;i         // p为i的指针
    fmt.Println(*p) // 通过指针显示的是i的值
    *p = 21         // 通过指针修改的是i的值
    fmt.Println(i) 

    p = &amp;amp;j         // 没有：了，因为是第二次修改值，不是初始化，将p改为j的指针
    *p = *p / 37   // 通过指针操作的是j的值，除以37的结果重新通过指针赋给j
    fmt.Println(j)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;42
21
73&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结构体struct&quot;&gt;结构体struct&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Vertex struct {
    X int
    Y int
}

func main() {
    fmt.Println(Vertex{1, 2})
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以type开头，用来声明创建一种类型，创建以后可以被var声明该类型的变量。&lt;/li&gt;
&lt;li&gt;关键字struct，它相当于一个字段的集合，使用方式与基本类型相似，也是写在变量名后面。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    v := Vertex{1, 2}
    fmt.Println(v.X)
    // 输出1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用短声明方式定义一个变量，通过点获得相关字段的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    p := &amp;amp;v
    p.X = 1e9
    fmt.Println(v)
    // 输出{1000000000 2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构体同样可以像一个普通变量那样有指针，通过指针可以操作结构体字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Vertex struct {
    X, Y int
}

var (
    v1 = Vertex{1, 2}  // 类型为 Vertex
    v2 = Vertex{X: 1}  // Y:0 被省略
    v3 = Vertex{}      // X:0 和 Y:0
    p  = &amp;amp;Vertex{1, 2} // 类型为 *Vertex
)

func main() {
    fmt.Println(v1, v2, v3, p)
}
// 输出：{1 2} {1 0} {0 0} &amp;amp;{1 2}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对结构体的字段操作，用一个变量来接受，可以重新组装新的结构体。以上代码中，使用var圆括号列表的方式，分别定义了v1，v2，v3和p四个变量，前三个对原结构体的数据进行了不同的赋值，p为结构体的指针，输出也是带有&amp;amp;符号的结果。&lt;/p&gt;
&lt;h3 id=&quot;数组和slice&quot;&gt;数组和slice&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类型 [n]T 是一个有 n 个类型为 T 的值的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数组的声明方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var a [10]int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个数组变量，变量名为a，长度为10，数据类型为int。Go的数组与其他语言一样，都是定长的，一旦声明无法自动伸缩，但Go提供了更好的解决方案，就是slice。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[]T 是一个元素类型为 T 的 slice。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;slice与数组最大的区别就是不必定义数组的长度，它可以根据赋值的长度来设定自己的长度，而不是提前设定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(len(s))
    fmt.Println(&quot;s ==&quot;, s)

    for i := 0; i &amp;lt; len(s); i++ {
        fmt.Printf(&quot;s[%d] == %d\n&quot;, i, s[i])
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;6
s == [2 3 5 7 11 13]
s[0] == 2
s[1] == 3
s[2] == 5
s[3] == 7
s[4] == 11
s[5] == 13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过len(s)方法可以获得slice当前的长度。此外，上面代码中Printf中的格式化字符串的&amp;amp;d，与C和java相同，都代表是整型数字。&lt;/p&gt;
&lt;p&gt;数组和slice都可以是二维的。&lt;/p&gt;
&lt;p&gt;slice可以内部重新切片s[lo:hi]，lo是低位，hi是高位，hi&amp;gt;lo，若hi=lo则为空。&lt;/p&gt;
&lt;p&gt;slice除了上面的直接字面量赋值以外，还可以通过make创建。func make([]T, len, cap) []T&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a := make([]int, 5)  // len(a)=5 cap(a)=5
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
// slice内部继续切片，空为从头，这不是下标的概念，而是个数的概念。
b = b[:cap(b)] // len(b)=5, cap(b)=5，b原来的容量为5，重切以后的切片是b[:5]意思是b的前五个数组成的切片，顺序不变。
b = b[1:]      // len(b)=4, cap(b)=4，b原来的容量为5，重切以后的切片是b[1:]意思是除去前一个数（即第一个数）剩余的数组成的切片，顺序不变。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;slice的零值是nil。Go语言中的空值用nil来表示。一个 nil 的 slice 的长度和容量是 0。&lt;/p&gt;
&lt;p&gt;slice是通过append函数来添加元素。&lt;/p&gt;
&lt;h4 id=&quot;range遍历slice和map&quot;&gt;range遍历slice和map&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&quot;2^%d = %d\n&quot;, i, v)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意使用range的格式，返回值i，v分别代表了当前下标，下标对应元素的拷贝。&lt;/p&gt;
&lt;h4 id=&quot;利用下划线_作占位符&quot;&gt;利用下划线_作占位符&lt;/h4&gt;
&lt;p&gt;当我们不需要当前下标的时候，可以将i用下划线_代替。然而如果只想要下标，可以把, v直接去掉，不必加占位符。&lt;/p&gt;
&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;
&lt;p&gt;与其他语言一样，map也是一个映射键值对的数据类型。在Go中，与slice相同的是，它也需要使用make来创建，零值为nil，注意值为nil的map不可被赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Vertex struct {
    Lat, Long float64
}

// []中的为key数据类型，[]外面紧跟着的是value的数据类型，这里value的数据类型是上面type新创建的struct类型。
var m map[string]Vertex

func main() {
    m = make(map[string]Vertex)
    m[&quot;Bell Labs&quot;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&quot;Bell Labs&quot;])
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，map在赋值时必须有键名。赋值的时候可以省略类型名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var m = map[string]Vertex{
    &quot;Bell Labs&quot;: {40.68433, -74.39967},
    &quot;Google&quot;:    {37.42202, -122.08408},
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改map中一个元素的内容：m[key]=elem&lt;/li&gt;
&lt;li&gt;获得map中的一个元素：elem=m[key]&lt;/li&gt;
&lt;li&gt;删除元素：delete(m,key)&lt;/li&gt;
&lt;li&gt;elem, ok = m[key]判断key是否存在m中，如果没有ok为false，elem=map零值，如果有ok为true，elem为key对应的value&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    m := make(map[string]int)
    // 赋值key为&quot;Answer&quot;，值为42。
    m[&quot;Answer&quot;] = 42
    // 检查key是否存在，此时是存在的。那么v=42。
    v, ok := m[&quot;Answer&quot;]
    fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)
    // 删除key
    delete(m, &quot;Answer&quot;)
    fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])
    
    // 注意下面没有冒号了，因为是第二次赋值，再次检查key是否存在，此时是不存在的。那么v=0，整型的零值是0。
    v, ok = m[&quot;Answer&quot;]
    fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The value: 42 Present? true
The value: 0
The value: 0 Present? false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;与javascript似曾相识&quot;&gt;与JavaScript似曾相识？&lt;/h3&gt;
&lt;p&gt;函数值概念：函数也是值，可以像其他值一样被传递和操作，例如可以当作函数的参数和返回值，这非常强大，跟JavaScript的思想如出一辙。&lt;/p&gt;
&lt;p&gt;闭包：当时学习JavaScript闭包概念的时候也是蒙圈，没想到Go语言也支持，下面我们再来复习一下。闭包是基于函数值概念的，它引用了函数体之外的变量，可以对该变量进行访问和赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;adder函数的返回值类型为func(int) int，好叼哦。也就是说返回的是另一个函数，它没有函数名（有点匿名内部类的意思哈），该函数只有一个int型的参数，返回值为int。继续我们来看函数体，声明并赋值给sum变量为0，然后是return阶段的确返回了符合上面定义的一个函数。在这个返回函数的函数体内，我们直接使用到了外部的sum变量，对其进行了操作并返回，这就是闭包的概念（一个无名函数小子和一个大家闺秀变量的感情纠葛）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    pos, neg := adder(), adder()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们在main函数中调用这个adder函数。首先声明并初始化变量pos和neg为adder函数值，然后定义一个循环，直接调用pos和neg变量并传参，相当于调用了adder函数。&lt;/p&gt;
&lt;p&gt;以上就是函数值和闭包的概念的学习，根据以上知识完成斐波那契数列的练习：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

// fibonacci 函数会返回一个返回 int 的函数。
func fibonacci() func() int {
    back1,back2 := 0,1
    return func() int{
        temp := back1
        // 重新赋值back1和back2的值，下面是关键代码
        back1,back2 = back2, (back2+back1)
        return temp
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &amp;lt; 10; i++ {
        fmt.Println(f())
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类的概念go的方法&quot;&gt;类的概念？Go的方法&lt;/h3&gt;
&lt;p&gt;Go中是没有类的概念的，但是可以实现与类相同的功能。在java中，如果一个方法属于一个类，我们是如何做的？直接在类文件中加入方法即可，外部调用的时候，我们可以通过类的实例来调用该方法，如果是静态类的话，可以直接通过类名调用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么在Go中是如何实现“类的方法”的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法，属于一个“东西”的函数被称为这个“东西”的方法。Go中是通过绑定的方式来处理的。我们先type定义一个结构体类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Vertex struct {
    X, Y float64
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码我们上面已经学习过了，应该没有任何疑问。接着，我们要创建一个Vertex类型的变量（java中称为对象的实例，就看你怎么解读了），并且让这个变量拥有一个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们慢慢来看，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正常的函数是func Abs() float64， 但我们在func和函数名之间加入了一个东西，定义了一个Vertex指针类型的变量v。&lt;/li&gt;
&lt;li&gt;在该函数体中，我们可以直接把v当作参数来使用，因为v是一个结构体类型的对象指针，所以v可以调用结构体中的各个字段。（TODO:Go语言圣经继续深入研究这一部分）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;func main() {
    v := &amp;amp;Vertex{3, 4}
    fmt.Println(v.Abs())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在main函数中可以直接通过变量v调用上面的函数Abs，此时函数Abs就是v的方法了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，type关键字可以创建任意类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;type MyFloat float64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyFloat就是一个类型，我们在下面可以直接使用，该类型仍然可以与函数绑定。&lt;/p&gt;
&lt;p&gt;下面我们再来重申区分一下函数和方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数是func后面直接跟函数名，跟任何类型都无关系。&lt;/li&gt;
&lt;li&gt;方法是func后面加入类型的变量，然后再加函数名，这个类型的变量本身也是该方法的参数，同时该方法是属于该类型的，但要用类型的对象来调用（Go没有静态方法）。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面我们分别使用了结构体指针和自定义类型，使用指针的好处就是可以避免在每个方法调用中拷贝值同时可以修改接收者指向的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := &amp;amp;Vertex{3, 4}
    fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())
    v.Scale(5)
    fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())
}
/* 输出:
    Before scaling: &amp;amp;{X:3 Y:4}, Abs: 5
    After scaling: &amp;amp;{X:15 Y:20}, Abs: 25
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当Scale使用Vertex而不是*Vertex的时候，main函数中调用v.Scale(5)没有任何作用，此时输出结果应该毫无变化“After scaling: &amp;amp;{X:3 Y:4}, Abs: 5”。因为接收者为值类型时，修改的是Vertex的副本而不是原始值。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当我们修改Abs的函数接收者为Vertex的时候，并不会影响函数执行结果，原因是这里只是读取v而没有修改v，读取的话无论是指针还是值的副本都不受影响，但是修改的话就只会修改值的副本，然而打印程序打印的是原始值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;p&gt;Go的接口定义了一组方法，同样的没有实现方法体。接口类型的值可以存放任意实现这些方法的值。&lt;/p&gt;
&lt;p&gt;首先，我们来看一个接口是如何定义的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Abser interface {
    Abs() float64
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再type创建两个类型，并绑定与接口相同方法名，参数，返回值的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &amp;lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们定义了一个MyFloat类型和Vertex类型，在他们类型定义的下方都绑定了方法Abs() float64，并有各自具体的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    a=f
    fmt.Println(a.Abs())
}

//输出：1.4142135623730951&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们在main函数中去做具体操作，首先定义一个接口类型的值var a Abser，然后我们先定义一个刚刚我们创建的MyFloat类型的值f，将f赋值给a，接口类型值a就存放了实现了接口方法Abs的MyFloat类型的值f，最后我们去用a调用Abs方法，实际上调用的是f的Abs方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    var a Abser
    v := Vertex{3, 4}
    a = &amp;amp;v // a *Vertex 实现了 Abser
    //a = v //等于v为什么不行，而必须是v的指针？
    fmt.Println(a.Abs())
}
// 输出：5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们来测试上面创建的另一个类型Vertex，创建并初始化Vertex的值变量v，将v的指针赋值为接口类型值a，用a调用Abs方法，实际上调用的是*Vertex的Abs方法。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;解答代码注释里的问题：因为我们实现接口方法的时候，绑定的是*Vertex而不是Vertex，所以必须是Vertex的指针类型才拥有该方法，如果使用Vertex的值类型而不是指针，则会报错“Vertex does not implement Abser”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go的接口属于隐式接口，类型通过实现接口方法来实现接口，方法也不必像java那样必须全部实现，没有显示声明，也就没有“implements”关键字。隐式接口解耦了实现接口的包和定义接口的包：互不依赖。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Stringer接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;type Stringer interface {
    String() string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的一个接口就是Stringer接口，它就如同java复写toString方法，输出对象的时候不必显示调用toString，而是直接输出该接口的实现方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    // Sprintf 根据于格式说明符进行格式化并返回其结果字符串。
    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
}

func main() {
    a := Person{&quot;Arthur Dent&quot;, 42}
    z := Person{&quot;Zaphod Beeblebrox&quot;, 9001}
    fmt.Println(a, z)
}
// 输出：Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到新创建的类型Person，它实现了Stringer的String方法（注意这里开头S是大写，与基本类型string不同）。我们在fmt.Println的时候会默认调用该方法输出。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;发现一个问题：Person的实现接口方法以及main函数初始化Person调用String方法输出，这整个过程都没有出现真正的原接口名称“Stringer”！这是非常有意思的部分，我们日后要注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么原因是什么？我们来分析一下，上面我们调用接口方法的时候是需要利用接口类型值来调用的（如var a Abser，a.Abs())。然而这里由于特殊原因（跟其他语言一样，大家都不会显示调用toString吧），并没有显式使用&lt;br/&gt;接口类型变量，所以全文没有出现接口名称，这种情况在之后的Go工作中，应该不少见，还望注意。&lt;/p&gt;
&lt;h3 id=&quot;error&quot;&gt;error&lt;/h3&gt;
&lt;p&gt;error在Go中是一个接口类型，与Stringer一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type error interface {
    Error() string// 注意接口方法为Error()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般函数都会返回一个error值，调用函数的代码要对这个error进行判断，如果为空nil则说明成功，如果不为空则需要做相应处理，例如报告出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, err := strconv.Atoi(&quot;42&quot;)
if err != nil {
    fmt.Printf(&quot;couldn't convert number: %v\n&quot;, err)
    return
}
fmt.Println(&quot;Converted integer:&quot;, i)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go语言的io包中的Reader接口定义了从数据流结尾读取的方法，标准库中有很多包对Reader的这个接口方法进行了实现，包括文件、网络连接、加密、压缩等。该Read方法的声明为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (T) Read(b []byte) (n int, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面使用strings包中的NewReader实现方法，它的介绍是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;func NewReader(s string) *Reader&lt;br/&gt;NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会返回一个新的读取参数字符串的Reader类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strings&quot;
)

func main() {
    r := strings.NewReader(&quot;Hello, Reader!&quot;)

    b := make([]byte, 8)//定义一个8位字节数组用来存上面的字符串
    for {// 无限循环here
        n, err := r.Read(b)
        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])// b[:n]输出字节数组b的所有值，n是最大长度
        if err == io.EOF {//随着不断循环，上面字符串已经读取完毕，当前字节数组为空，返回EOF(已到结尾)错误
            break// 手动置顶break跳出循环
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;http-web服务器&quot;&gt;HTTP web服务器&lt;/h3&gt;
&lt;p&gt;主要通过调用标准库的http包来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package http

type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们创建一个结构体类型，实现该接口方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;log&quot;
)

type Hello struct{}

func (h Hello) ServeHTTP(
    w http.ResponseWriter,
    r *http.Request) {
    fmt.Fprint(w, &quot;hello, Go server!&quot;)
}
func main() {
    var h Hello
    err := http.ListenAndServe(&quot;localhost:4000&quot;, h)
    if err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在编写这段代码过程中，针对goland有两点收获：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;import内容完全不必手写，goland会全程帮助你自动补全代码。&lt;/li&gt;
&lt;li&gt;每次goland自动补全的时候都会自动格式化你的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，我们发现对于Handler接口的ServeHTTP方法，我们自定义的结构体类型Hello全程并未见到Handler的字样，这个问题我在前面已经研究过，这里的Hello的实例h直接作为参数传给了http的ListenAndServe方法，可能在这个方法内部才会有Handler的出现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因此，这种我实现了你的接口方法，但根本不知道你是谁的情况在Go中十分常见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想深层原因就是Go并没有强连接的关系例如继承，显式implements关键字去实现，这是一种解耦的，松散的实现接口方法的方式，才会有这种情况的出现。这个特点称不上好坏，但需要适应。&lt;/p&gt;
&lt;p&gt;下面让我们直接在goland中将该文件run起来，会发现在控制台中该程序处于监听状态。然后我们可以&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过浏览器去访问http://localhost:4000/&lt;/li&gt;
&lt;li&gt;通过终端curl &lt;a href=&quot;http://localhost:4000/&quot; class=&quot;uri&quot;&gt;http://localhost:4000/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;通过goLand的REST client输入网址http://localhost:4000/，get的方式run&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，最终会得到结果：hello, Go server!一个简单的web服务器通过GO就搭建完成了。&lt;/p&gt;
&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;
&lt;h3 id=&quot;goroutine&quot;&gt;goroutine&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;goroutine 是由 Go 运行时runtime环境管理的轻量级线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;goroutine 使用关键字go来执行，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go f(x, y, z)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思为开启一个新的goroutine来执行f(x,y,z)函数。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般来讲，多线程通信都需要处理共享内存同步的问题，Go也有sync功能，但是不常用，后面继续研究。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func say(s string) {
    for i := 0; i &amp;lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say(&quot;world&quot;)
    say(&quot;hello&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了一个函数say，函数体为一个循环输出，每隔100微秒输出一遍参数值，共输出5次。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Go的time包中定义了多个常量来表示时间，我们可以直接调用而不需要再自行计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package time

type Duration int64

const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们在main函数中调用了两遍say函数，不同的是第一行调用加入了关键字go，这就使得这两行调用并不存在依次顺序，而是两个线程互不干扰的在跑。我们来看一下结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;world
hello
hello
world
world
hello
hello
world
world
hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，world和hello的输出并没有显然顺序，而是交替输出。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;然而经测试，这个输出虽然是交替但顺序不变，这说明了goroutine并不是“完全的多线程”，也就是说goroutine是通过程序控制内存资源的调配的，而不是真正意义的互不干扰独立的并行地享用各自的内存空间运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;channel&quot;&gt;channel&lt;/h3&gt;
&lt;p&gt;我们在之前学习java的nio的时候就介绍过channel，编程语言都是换汤不换药，各取所需，所以本质上区别不大，下面我们来具体介绍一下Go的通道。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;channel 是有类型的管道，使用chan关键字定义，可以用 channel 操作符 &amp;lt;- 对其发送或者接收值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们要使用通道，记住这个次操作符即可，箭头就是数据流的方向，不过注意你只能调整箭头左右的对象，这两个对象至少有一个是channel类型的，而不能改变操作符的箭头方向，操作符只有这一个，方向就是从右向左。&lt;/p&gt;
&lt;p&gt;与map和slice一样，channel创建也要使用make&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ch := make(chan int)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ch是变量名，chan声明了这是一个channel，int说明这个channel的数据类型是整型。chan有点像java的final或static关键字的用法，它是用来修饰变量的，与数据类型不冲突。判断一个变量是不是通道值，就看它的定义中是否有关键字chan即可。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：在channel传输数据的操作中，只要另一端没有准备好，发送和接收都会阻塞，这使得goroutine可以在没有明确锁或竞态变量的情况下进行同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func sum(a []int, c chan int) {
    sum := 0
    for _, v := range a {
        sum += v
    }
    c &amp;lt;- sum // 将和送入 c
}

func main() {
    a := []int{7, 2, 8, -9, 4, 0}

    ch := make(chan int)
    go sum(a[4:], ch)
    go sum(a[:1], ch)

    x, y := &amp;lt;-ch, &amp;lt;-ch // 从 ch 中获取

    fmt.Println(x, y, x+y)
}
// 输出：7 4 11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数sum很好理解，我们就把channel c当做普通的整型值，意思就是将第一个参数的整型数组的值之和传给c。&lt;/p&gt;
&lt;p&gt;main函数中，先定义了一个整型切片a，根据初始化值可以确定它的长度和容量均为6。&lt;/p&gt;
&lt;p&gt;然后借助make定义了一个通道变量ch，它的数据类型是整型。&lt;/p&gt;
&lt;p&gt;下面我们使用goroutine来“多线程”调用sum函数，除了都传入了通道变量ch以外，第一个调用传入的是a的后6-4个数组成的新切片a[4:]等于{4,0}，第二个调用传入的是前1个数组成的新切片a[:1]等于{7}&lt;/p&gt;
&lt;p&gt;因此可以得出，第一个调用sum以后，ch接收到值为4+0=4，第二个调用sum以后，ch接收到值为7。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么下一行代码是如何执行的？ x和y应该如何分配ch的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;x, y := &amp;lt;-ch, &amp;lt;-ch&lt;/p&gt;
&lt;p&gt;这一行代码我也比较confuse，首先来看x是先得到ch的值，y是后得到ch的值。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么关于ch的值到底在传给x和传给y这之间发生了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到goroutine的特性，我们上面已经分析了一波，它不是真正的独立多线程，而是有序的，有章法地通过语言底层逻辑来实现资源调配，那么经测试，我可以总结出来这两个调用的执行顺序是第一个调用的结果后传给ch，第二个调用的结果先传给ch。那么是否可以总结出来，第二个调用的结果给到了先接收的x，第一个调用的结果给到了后接收的y。&lt;/p&gt;
&lt;p&gt;以上的分析完全是结果反推的，我不确定是否正确，但我是根据结果这么理解的。(TODO:参照其他书籍的解释)&lt;/p&gt;
&lt;h4 id=&quot;channel的缓冲区概念&quot;&gt;channel的缓冲区概念&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    ch := make(chan int, 2)
    ch &amp;lt;- 1
    ch &amp;lt;- 2
    ch &amp;lt;- 3
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在正常的创建channel变量ch的结构ch := make(chan int)的make后面加入了第二个参数2。这个2代表了当前通道变量ch的缓冲区大小为2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2的意思是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们从长计议，再回到上面的channel的概念继续分析，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;
func add(i int,c chan int){
    c&amp;lt;-i
}
func main() {
    ch := make(chan int)
    go add(1,ch)
    fmt.Println(&amp;lt;-ch)
}
// 输出：1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;channel这种类型的变量必须伴随这goroutine的使用，而goroutine必须修饰的是函数，也就是说线程执行的一定是函数，而不能是一行代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你写 go c:=1 就是错的，go只能用于函数不能用于一行代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我写了一个add函数来做这行代码相同的事，然后用go来修饰。这才能通过fmt.Println(&amp;lt;-ch)打印出ch的值。&lt;/p&gt;
&lt;p&gt;我们再继续测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    ch := make(chan int)
    go add(3,ch)
    go add(2,ch)
    go add(5,ch)
    go add(11,ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出情况如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;11
3
2
5
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    /tmp/sandbox859149002/main.go:17 +0x360&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出结果继续分析，我写了4个go修饰的add函数调用，然而下面使用&amp;lt;-ch了5次，第五次的输出报错了，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;报错信息为：所有的goroutine都睡眠了，死锁，下面是通道接收报错，main函数是在tmp临时目录下建立了一个沙盒sandbox加沙盒id的目录，在这个目录下执行main函数时，第17行出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第17行对应的就是第五次输出。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这说明了通道channel传输的次数一定要等于go调用函数的次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含通道channel类型参数的函数必须要用goroutine来调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好，这种情况我们来评判一下是好是坏呢？我觉得这是一种规定，但是稍显死板，必须是相等的才行。那么Go也提供了一种机制来变通，就是上面提到的channel的缓冲区概念。下面来看代码，深入体验一下缓冲区的“疗效”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    ch := make(chan int,4)
    ch&amp;lt;-1
    ch&amp;lt;- 100
    go add(3,ch)
    go add(2,ch)
    go add(5,ch)
    go add(11,ch)
    add(12,ch)
    add(222,ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
    fmt.Println(&amp;lt;-ch)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
100
12
222
11
3
2
5
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    /tmp/sandbox119279221/main.go:25 +0x640&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来描述一下上面发生了什么，上面代码中我们定义了四次goroutine调用add函数，四次针对通道channel变量ch进行的普通赋值操作，然后下方对通道变量的接受者输出了九次。&lt;/p&gt;
&lt;p&gt;下面我们来总结一下Go语言中通道channel缓冲区的特性。可以发现，如果没有缓冲区的话，不能对通道进行非线程操作，也就是说不使用goroutine调用函数来操作通道的话，就会报错。而有了缓冲区以后，通道可以按照你设定的缓冲区大小来做普通的非goroutine参与的非线程的同步操作，从上面的输出结果我们也能看出来了，非goroutine参与的代码都是按照先后顺序执行的，只有goroutine参与的是无序的，但是所有的goroutine参与的操作一定是在所有普通操作结束以后再执行的，1,100,12,222就是普通操作的结果，后面的都是goroutine的操作结果。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最后一行的报错信息是因为通道ch被接受值的次数多于通道ch被发送值的次数一次，所以有一次报错，但这与缓冲区大小无关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，让我尝试一下用精简的一句话来总结一下通道缓冲的概念。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通道缓冲定义了通道变量允许被最多普通操作的次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么它的意义是什么？&lt;/p&gt;
&lt;p&gt;我好像又绕回来了，上面讲过那么一大段通道缓冲的存在意义了。下面再来一句话解释通道缓冲区。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;缓冲区大小是可以发送到通道而没有发送阻塞的元素数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的解释更加清晰了，就是通道有了缓冲区可以存放（通道作为接受者）一定大小的数据而不是直接进入阻塞。&lt;/p&gt;
&lt;h4 id=&quot;缓冲区的高级用法rangeclose&quot;&gt;缓冲区的高级用法range,close&lt;/h4&gt;
&lt;p&gt;可以通过for range 语句来遍历缓冲区，close是关闭通道的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i &amp;lt; n; i++ {
        c &amp;lt;- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    for i := range c {
        fmt.Println(i)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;斐波那契函数我们前面练习过，这里对函数做了修改，加入了通道参数，用通道来替代temp（不懂temp的来历的请翻到上面斐波那契函数）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;temp是需要返回的，但通道不需要，通道可以与线程共享数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先来看上面代码发生了什么？&lt;/p&gt;
&lt;p&gt;通道变量c被定义了大小为10的缓冲区，goroutine调用斐波那契函数向通道发送值，每发送一次，会被下面的for range循环的循环体中接收通道的值并输出，也就是说通道c接收到一个值就会立马在goroutine线程发送出去，所以goroutine调用斐波那契函数和下面的for range循环是并行的。直到for range将通道c的缓冲区遍历结束，通道c由于缓冲区大小的限制也不会继续再接收值了，这时就会被close掉。&lt;/p&gt;
&lt;p&gt;总结几点注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;close方法是放在了斐波那契函数内尾部而不是想当然的放在for循环后面。原因是Go规定了只有发送者可以关闭通道，作为发送者的只有斐波那契函数，for循环是作为接受者的，它无权对通道进行关闭操作。&lt;/li&gt;
&lt;li&gt;我们在斐波那契函数中的循环次数为手动输入的通道的缓冲区大小，如果不是这样的话，发送次数超过了缓冲区大小就会报错。&lt;/li&gt;
&lt;li&gt;for range循环在对通道c进行遍历的时候，它并不会自动按照c的缓冲区大小来循环，而是通道c被关闭以后，触发了for range循环的中止，而如果不是这样的话，通道一般是不需要被close的。&lt;/li&gt;
&lt;li&gt;向一个已经关闭的 channel 发送数据会引起 panic（可以理解为一种error）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;select&quot;&gt;select&lt;/h3&gt;
&lt;p&gt;select的用法有点像switch，基于上面我们对通道的深入了解，结合select我们可以做很多事，select可以根据判断执行哪个分支，下面看代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &amp;lt;- x:
            x, y = y, x+y
        case &amp;lt;-quit:
            fmt.Println(&quot;quit&quot;)
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &amp;lt; 10; i++ {
            fmt.Println(&amp;lt;-c)
        }
        quit &amp;lt;- 0
    }()
    fibonacci(c, quit)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0
1
1
2
3
5
8
13
21
34
quit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看这段程序都发生了什么，我们又对斐波那契函数进行了改动，函数内有一个for死循环，这就要求我们在循环体中去设置中止办法。循环体中用到了select关键字，它就像switch那样，这里有两个case判断：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个是判断c是否可以接收值，如果可以就执行第一个分支，那么c在什么情况下不能接收值呢？上面我们研究过多次了，这是没有缓冲区的通道，它的接收次数一定要与它的发送次数相等，当它的发送结束的时候，它也就不能再继续接收值了。&lt;/li&gt;
&lt;li&gt;第二个判断是quit通道是否可以发送值，同样的道理，通道的发送次数一定与它的接收次数相等，当quit通道接收了值，这个判断的分支就可以被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;只要有goroutine的函数，执行时一定会与普通函数并行，无论这个普通函数的调用是写在它的前面还是后面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有缓冲区的通道，在代码中它的接收次数和发送次数一定是相等的，这个主动权当然是在main函数里，因为只有main函数才是真正开始执行的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以下面来看main函数。&lt;/p&gt;
&lt;p&gt;main函数定义了一个go修饰的匿名函数，函数体内是一个循环10次发送通道c的循环，然后是一次quit通道的接收。上面说了主动权在main，所以main函数要求的这些次数必将在斐波那契函数中得以平衡（即发送次数与接收次数相等）。所以下面的斐波那契函数并行地执行了对应的10次通道c的接收和1次quit通道的发送，这些操作放到select的判断中去就是执行10次的斐波那契数列，每次通道c接收到数列的一个值就会被go匿名函数发送打印出去，10次结束以后，会接收quit通道的值，return中止斐波那契函数内部的死循环。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;select 操作很像switch，所以select也有default判断的分支，当其他分支不满足的时候，就会走default分支，一般default分支会执行一个时间的休眠等待，等待外部其他函数的通道操作能够满足select的某些分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sync.mutex&quot;&gt;sync.Mutex&lt;/h3&gt;
&lt;p&gt;sync.Mutex是一个互斥锁类型，它有Lock和Unlock一个上锁一个解锁的方法，Lock和Unlock之间的代码只会被一个goroutine访问共享变量（共享变量不仅是通道，普通类型的实例也可以，例如struct类型），从而保证一段代码的互斥执行。目前没有什么太好的例子，以后有机会再学而时习之吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结里面依然不说Go的优势，只对本篇文章做一个总结，本篇文章的目标是一次系统性的从零到一的学习Go语言。我本想多看基本书概况总结他们来放到这篇文章中去，但我觉得学习分为理论和实践，比例约为2：8，不能再多了，也由于项目紧留给我搞理论的时间实在不多，因此我就顺着官方文档这一支完完整整地捋下来，对其中每一个特性，语法细节都做了仔细的研究，开发环境的逐步搭建，也对源码进行了复现，甚至自己也开发了一些测试代码。当然，这篇文章远远不能称为Go语言的高级深入使用手册，只是一个入门到了解的过程，未来还有着长久的实践，在使用中会有更多的心得，到时有机会我再总结一篇深入版吧，可以基于《effective go》来写。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;《A Tour of Go》&lt;/p&gt;

</description>
<pubDate>Fri, 12 Jan 2018 11:39:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/go.html</dc:identifier>
</item>
<item>
<title>浅谈JavaScript的面向对象程序设计（四） - 水击三千</title>
<link>http://www.cnblogs.com/ggz19/p/8277420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ggz19/p/8277420.html</guid>
<description>&lt;p&gt;　　本文继续讲解JavaScript的面向对象程序设计。继承是面向对象语言中的一个基本概念，面向对象语言支持两种继承实现方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。但是在JavaScript中函数时没有签名的，所以无法实现接口继承。JavaScript支持实现继承，而且其实现继承主要是通过原型链继承的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;JavaScript中有原型链的概念，并将原型链作为实现继承的主要方法。基本实现思想是让一个函数的原型继承另外一个函数的原型的属性和方法。每一个函数都有一个原型对象，原型对象包含一个指向构造函数的指针，实例包含一个指向原型对象的指针。原型链的概念就是，一个原型对象指向另一个函数的原型，同样另一个函数的原型又指向其他函数的原型，层层递进，就构成了原型链。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 SubType.prototype=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperType();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ExtendType(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 ExtendType.prototype = &lt;span&gt;new&lt;/span&gt; SubType();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码展示了原型链的概念，ExtendType的原型指向了SubType实例，SubType的原型指向了SuperType实例，SuperType的原型指向了Object的原型。这样就形成了一个原型链。原型链本质上是扩展了前面介绍的原型搜素机制。当访问实例的属性或者方法时，首先搜索实例的属性或者方法，再搜索实例的原型。通过原型链，可以一直向上搜索，直至搜索到Object的原型。&lt;/p&gt;
&lt;p&gt;　　前面也简单地介绍了确认原型的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; extendtype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtendType();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 console.log(extendtype &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Object);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 console.log(extendtype &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SubType);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 console.log(extendtype &lt;span&gt;instanceof&lt;/span&gt; SuperType);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码中2、3、4行都输出true，这说明extendtype中能找到函数的原型。也可以通过另外一种方法实现原型的判断，就是通过原型的isPrototypeOf方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;console.log(Object.prototype.isPrototypeOf(extendtype));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;                console.log(SubType.prototype.isPrototypeOf(extendtype));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 console.log(SuperType.prototype.isPrototypeOf(extendtype));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码通过isPrototypeOf方法来判断实例的类型。同样，输出都是true。&lt;/p&gt;
&lt;p&gt;　　通过原型链在JavaScript中实现的继承依然存在一定的问题。原型链会将实例中的所有属性都共享，但是我们在构造函数中定义属性，二不在原型中定义属性就是为了不共享属性&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Super(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.colors=[&quot;green&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sub(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Sub.prototype= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Super();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 sub.colors.push(&quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 console.log(sub.colors.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,red&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 console.log(sub2.colors.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green.red&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码定义两个对象super和sub，sub的原型继承了super的实例。我们创建了sub的两个实例，对其中的一个实例colors的属性添加了一个元素，但是我们发现两个实例的属性都改变了。因为该两个实例的colors属性都指向super中的属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;借用构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　借用构造函数的思想就是在子类型的构造函数中调用父类的构造函数，可以通过apply或者call调用父类构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Super(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.colors=[&quot;green&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sub(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     Super.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 sub.colors.push(&quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 console.log(sub.colors.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,red&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 console.log(sub2.colors.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码在子类的函数中调用了父类的构造函数，通过call。同时，我们实例化了两个子类对象，发现sub的操作并没有影响sub2的结果。每次实例化都会调用父类的构造函数，这样每个sub都有自己的colors属性。&lt;/p&gt;
&lt;p&gt;　　同时，通过借用构造函数，我们还能传递参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Super(name){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.colors=[&quot;green&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sub(name){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     Super.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt; Sub(&quot;hehe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 sub.colors.push(&quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 console.log(sub.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub2 = &lt;span&gt;new&lt;/span&gt; Sub(&quot;haha&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 console.log(sub2.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码，我们通过构造函数传递了参数，并通过call方法传递参数给父类的构造函数。借用构造函数和构造函数模式创建对象拥有同样的问题，方法和属性都在构造函数中定义，因为函数无法复用。也无法判断函数的类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;组合式继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;组合继承是指将原型链和构造函数的技术组合在一起。它的思路是通过原型链实现属性和方法的继续，通过借用构造函数模式实现实例属性的继承。这样在原型链上实现方法，保证函数的复用，同时又保证每个实例有自己的属性。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Super(name){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Super.prototype.getName=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sub(name,age){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     Super.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Sub.prototype= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Super();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt; Sub(&quot;haha&quot;,18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 console.log(sub.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 console.log(sub.age);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sub2 = &lt;span&gt;new&lt;/span&gt; Sub(&quot;hehe&quot;,19&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 console.log(sub2.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 console.log(sub2.age);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码中Super定义了一个属性name和一个原型方法getName，sub定义了一个实例属性age。sub继承了super的实例。也就是sub用super的原型方法，同时能够调用super的实例属性。在后面定义了两个sub实例，他们是不同的实例，拥有不同的实例属性，但是他们共享了原型方法。&lt;/p&gt;
&lt;p&gt;　　组合继承避免了原型链和构造函数的缺陷，是一种常用的继承实现方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原型式继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　克罗克福德提出了原型式继承的方法。他的方法是借助原型基于已有的对象创建新的对象，同时还不必因此创建自定义类型。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(o){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                     F.prototype=&lt;span&gt;o;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在create函数内部，先创建了零时行的函数F，并将F的原型指向参数o，参数o是另一个对象的原型，最后返回F的实例，并且该实例继承了传递进行来的对象的原型。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(o){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     F.prototype=&lt;span&gt;o;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; Person=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &quot;name&quot;:&quot;haha&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                      getName:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; oneperson=&lt;span&gt;create(Person.prototype);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 oneperson.name=&quot;hehe&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 console.log(oneperson.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; twoperson =&lt;span&gt; create(Person.prototype);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 twoperson.name=&quot;jack&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 console.log(twoperson.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码，基于create函数创建了两个对象，这两个对象继承了Person。这就意味着Person中的属性和方法，oneperson中同样拥有。ECMAScript5中定义了新的方法Object.create()方法，该方法有两个参数，一个参数是一个对象原型，另一个参数是需要生成的新属性。与上面的方法类似。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;寄生式继承&lt;/strong&gt;　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　寄生式继承与寄生式函数的工厂模式类似，也是创建一个用于封装继承过程的函数。在函数内部以一定的方式增强对象，最后返回对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(o){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     F.prototype=&lt;span&gt;o;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(o){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; f=&lt;span&gt;create(o);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     o.sayHi=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         console.log(&quot;hi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; Person=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     name:&quot;haa&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     age:&quot;8&quot;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; one=createPerson(Person);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的one不仅继承了person的属性，同时还拥有增强属性sayHi。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　前面说过最常用的继承方式是组合式继承，但是组合继承，不论什么情况，都要父类构造函数两次。第一次是在子类继承父类的实例时候，第二次是子类实例化过程中。&lt;/p&gt;
&lt;p&gt;　　寄生组合式继承，通过借用构造函数来继承属性，通过原型链来继承方法。使用寄生式继承来继承父类的原型，不必通过实例化来继承父类，这样减少了调用父类构造函数的次数，只用调用一次。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; create(o){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     F.prototype=&lt;span&gt;o;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(name){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sub(name,age){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         SuperType.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     Sub.prototype=&lt;span&gt;create(SuperType.prototype);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     Sub.prototype.getName=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sub = &lt;span&gt;new&lt;/span&gt; Sub(&quot;haha&quot;,19&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     console.log(sub.getName());&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sub2 = &lt;span&gt;new&lt;/span&gt; Sub(&quot;hehe&quot;,18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     console.log(sub2.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 12 Jan 2018 11:34:00 +0000</pubDate>
<dc:creator>水击三千</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ggz19/p/8277420.html</dc:identifier>
</item>
</channel>
</rss>