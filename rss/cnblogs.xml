<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java IO（3）非阻塞式输入输出（NIO） - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8095326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8095326.html</guid>
<description>&lt;p&gt;　　在上篇&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/7995559.html&quot; target=&quot;_blank&quot;&gt;《Java IO（2）阻塞式输入输出（BIO）》&lt;/a&gt;的末尾谈到了什么是阻塞式输入输出，通过Socket编程对其有了大致了解。现在再重新回顾梳理一下，对于只有一个“客户端”和一个“服务器端”来讲，服务器端需要阻塞式接收客户端的请求，这里的阻塞式表示服务器端的应用代码会被挂起直到客户端有请求过来，在高并发的应用场景有多个客户端发起连接下非阻塞式IO（NIO）是不二之选（且只需要在服务器端使用1个线程来管理，并不需要多个线程来处理多个连接）。在现实情况下，Tomcat、Jetty等很多Web服务器均使用了NIO技术。&lt;/p&gt;
&lt;p&gt;　　接下来对于非阻塞式输入输出（NIO）的学习以及理解首先从它的三个基础概念讲起。&lt;/p&gt;

&lt;p&gt;　　在NIO中，你需要忘掉“流”这个概念，取而代之的是“通道”。举例在网络应用程序中有多个客户端连接，此时数据传输的概念并不是“流”而“通道”，通道与流最大的不同就是，通道是双向的，而流是单向的（例如InputStream、OutputStream）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224011945834-1739208232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在NIO中并不是简单的将流的概念替换为了通道，与通道搭配的是缓冲区。在BIO的字节流中并不会使用到缓冲区，而是直接操作文件通过字节方式直接读取，而NIO则不同，它会将通道中的数据读入缓存区，或者将缓存区的数据写入通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224012022490-341023930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如果使用NIO的应用程序中只有一个Channel，选择器则是可以不需要的，而如果有多个Channel，换言之有多个连接时，此时通过选择器，在服务器端的应用程序中就只需要1个线程对多个连接进行管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224005614412-952603084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然从最开始就说到Channel是双向的，所以在最终图的示例为下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224011824678-440734084.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下面再重新回到这三个概念，详细解释它们是如何协同工作的。&lt;/p&gt;

&lt;p&gt;　　通常情况下Channel会和Buffer配合使用，但可以不使用Channel。首先需要明确的是，应用程序不管是从文件（包括网络或者其他什么地方）中读取数据，还是写入数据到文件（包括网络或者其他什么地方）都需要Buffer。&lt;/p&gt;
&lt;h2&gt;1. 直接将数据写入Buffer，应用程序从Buffer中获取数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ByteBuffer buffer = ByteBuffer.allocate(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; b = 121&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;buffer.put(b);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; buffer.flip();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读写转换，由“写模式”转换为“读模式”&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; System.out.println((&lt;span&gt;char&lt;/span&gt;)buffer.get());    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第1行，分配一个1KB大小的Buffer缓冲区，ByteBuffer.allcoate返回HeapByteBuffer实例。&lt;/p&gt;
&lt;p&gt;　　第3行，向Buffer中写入一个字节。&lt;/p&gt;
&lt;p&gt;　　第4行，Buffer由“写模式”转换为“读模式”。&lt;/p&gt;
&lt;p&gt;　　第5行，ByteBuffer.get方法读取Buffer中的数据，并且position索引+1。 在上面的代码中有一个重点——flip方法，这个方法的存在是由于Buffer兼顾了读和写的操作，在ByteBuffer的实现中有三个重要的成员变量需要注意： capacity——Buffer容量 position——索引位置 limit——读时表示最大容量，即limit = capacity；写时表示最后一个数据所在的索引位置。 用图例来说明上面代码的执行过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224005921381-202188784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224010023287-1056636325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224010112725-1104610757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可以清晰的看到Buffer内部是如何进行读写操作的，其中调用flip方法是很关键且重要的一个步骤，试想如果不调用flip进行读写转换，此时position、limit、capacity的索引位置将会如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224010145975-554045538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时进行读的操作将会得到一个错误数据（0）。 尽管在讲这个小标题“直接将数据写入Buffer，应用程序从Buffer中获取数据”，但实际上已经简要介绍了Buffer的内部实现原理。&lt;/p&gt;
&lt;p&gt;　　通过上面的例子可以看到，Channel和Buffer并不一定要在一起，单独使用Buffer也是可以的，但要使用Chnnel那就必须得配合Buffer。&lt;/p&gt;
&lt;h2&gt;2. 从文件中读取数据写入Buffer，应用程序从Buffer中获取数据&lt;/h2&gt;
&lt;p&gt;　　此时的数据来源是文件，开头提过在NIO中忘掉“流”，记住“通道”。在NIO中可以通过传统的流获取通道。例如从输入流FileInputSteram中调用getChannel，或者从输出流FileOutputStream中调用getChannel，当然还有兼顾输入和输出的RandomAccessFile类从中调用getChannel。&lt;/p&gt;
&lt;p&gt;　　BIO中首先获取流，NIO中首先获取通道。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; RandomAccessFile file = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;/Users/yulinfeng/Documents/Coding/Idea/simplenio/src/main/java/com/demo/test.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; FileChannel channel =&lt;span&gt; file.getChannel();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ByteBuffer buffer = ByteBuffer.allocate(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;channel.read(buffer);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;buffer.flip();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; System.out.println(&lt;span&gt;new&lt;/span&gt; String(buffer.array()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看到这段NIO读取文件数据的代码，心中默写传统的BIO是如何读取文件数据的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('610723ba-7cae-4d45-996d-253f131164f5')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_610723ba-7cae-4d45-996d-253f131164f5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_610723ba-7cae-4d45-996d-253f131164f5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('610723ba-7cae-4d45-996d-253f131164f5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_610723ba-7cae-4d45-996d-253f131164f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; InputStream in = &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;/Users/yulinfeng/Documents/Coding/Idea/simplenio/src/main/java/com/demo/test.json&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;in.read(bytes);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(&lt;span&gt;new&lt;/span&gt; String(bytes));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　展开代码可以看到，基本上如出一辙，在NIO中就是多了Buffer这个媒介来读取数据。&lt;/p&gt;
&lt;p&gt;　　回到NIO读取文件数据的代码。 第1行，获取文件流。 第2行，获取Channel通道。 第3-6行，创建Buffer缓冲区，并将数据读取从通道读取到缓冲区。 同样还是用图例来说明上面代码的执行过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224010418756-1285602917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201712/630246-20171224010450928-804522574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后调用ByteBuffer.array方法返回缓冲区中的值，此时并未移动position的数组下标。这个例子结合图例我相信能很清楚地看到NIO是如何从文件中读取数据的，下面这个例子将输出数据到文件。&lt;/p&gt;
&lt;h2&gt;3. 从应用程序中将数据输出到文件中&lt;/h2&gt;
&lt;p&gt;　　前面都是应用程序从Buffer中获取数据并且用图例的方式了解了它的内部运行原理。本例将把数据通过Buffer写到文件中，当然得记住还需要通过Channel才能写入文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; RandomAccessFile file = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;E:\\IdeaProjects\\simplenio\\src\\main\\java\\com\\demo\\out\\test.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; FileChannel channel =&lt;span&gt; file.getChannel();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ByteBuffer buffer = Charset.forName(&quot;utf-8&quot;).encode(&quot;{\&quot;name\&quot;: \&quot;Kevin\&quot;}&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会自动进行读写转换，第1个例子需要手动调用flip方法进行读写模式的转换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上面的例子很容易想到，首先需要通道，那么就利用可读可写的RandomAccessFile获取通道；其次需要缓冲区；最后将缓冲区的数据写入到通道中即可。这段代码其实可以把重点放到是如何从缓冲区写到管道的。&lt;/p&gt;
&lt;p&gt;　　第1-2行，通过可读可写的RandomAccessFile类获取Channel通道。（要是只需要写文件，也可以通过FileOutputStream.getChannel获得）&lt;/p&gt;
&lt;p&gt;　　第3行，将字符串{“name”: “Kevin”}通过UTF-8编码写入Buffer缓冲区，NIO会对自动对其进行读写模式的转换，不需要手动调用flip方法。&lt;/p&gt;
&lt;p&gt;　　第4行，将Buffer中的数据写入通道。&lt;/p&gt;
&lt;h2&gt;4. 从一个文件读数据，再写到另一个文件&lt;/h2&gt;
&lt;p&gt;　　NIO不易掌握，需要反复练习，所以本文会给出多个例子反复操练并领会NIO的设计哲学。&lt;/p&gt;
&lt;p&gt;　　这个例子有两种实现方式，第一种基于上面的例子就能拼凑出来，第二种则需要掌握一个新的API——&lt;strong&gt;transferFrom / transferTo&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.1通过上面的知识读文件再写文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; RandomAccessFile readFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;E:\\IdeaProjects\\simplenio\\src\\main\\java\\com\\demo\\inout\\from.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; FileChannel readChannel =&lt;span&gt; readFile.getChannel();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ByteBuffer buffer = ByteBuffer.allocate(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;readChannel.read(buffer);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; buffer.flip();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读写转换&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; RandomAccessFile writeFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;E:\\IdeaProjects\\simplenio\\src\\main\\java\\com\\demo\\inout\\to.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; FileChannel writeChannel =&lt;span&gt; writeFile.getChannel();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; writeChannel.write(buffer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过上面的几个例子写出这个示例应该没什么问题，需要注意的是第x行的buffer.flip方法是读写转换，这在上面有提到过。&lt;/p&gt;
&lt;h3&gt;4.2 通过新的API——transferFrom读文件并写文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; RandomAccessFile fromFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;E:\\IdeaProjects\\simplenio\\src\\main\\java\\com\\demo\\inout\\from.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; FileChannel fromChannel =&lt;span&gt; fromFile.getChannel();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; RandomAccessFile toFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;E:\\IdeaProjects\\simplenio\\src\\main\\java\\com\\demo\\inout\\to.json&quot;, &quot;rw&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; FileChannel toChannel =&lt;span&gt; toFile.getChannel();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; toChannel.transferFrom(fromChannel, 0, fromChannel.size());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过transferFrom就能将一个通道直接输出到另一个通道而不需要缓冲区做中转。&lt;/p&gt;
&lt;h2&gt;5. Socket网络应用程序是如何使用NIO的&lt;/h2&gt;
&lt;p&gt;　　前面的例子全是有关本地文件的读写操作，在一个应用程序中有可能免不了通过网络来传输数据，传统的Socket编程利用的是BIO，也就是阻塞式输入输出。而NIO同样也可应用到Socket网络编程中。下面两个例子均是1个客户端对应1个服务器端。此时并不能很好的体会BIO和NIO的区别，若多个客户端对应1个服务器端，此时NIO的优点便很快显现，不过要实现多个客户端对应1个服务器端则需要Selector（选择器），由于现在还并未详细认识它所以将“多个客户端对应1个服务器端”放置在后面提及。  &lt;/p&gt;
&lt;h3&gt;5.1 阻塞式网络编程（BIO Socket）&lt;/h3&gt;
&lt;p&gt;　　BIO Socket是我取的名字，意思是利用传统的阻塞式IO来进行Socket编程，本文虽主讲NIO，但也需要了解并熟练掌握BIO。故，在此先使用传统的IO来进行Socket编程以便能对下文的NIO Socket有一个类比。在本例中使用UDP协议传输数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * BIO客户端
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/18.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         String data = &quot;this is Client.&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         DatagramSocket socket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatagramSocket();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         DatagramPacket packet = &lt;span&gt;new&lt;/span&gt; DatagramPacket(data.getBytes(), data.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 8989&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        socket.send(packet);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 服务器端
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * BIO Created by Kevin on 2017/12/18.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         DatagramSocket socket = &lt;span&gt;new&lt;/span&gt; DatagramSocket(8989&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         DatagramPacket packet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatagramPacket(data, data.length);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         socket.receive(packet);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器端在未收到数据时，会在此处被阻塞挂起&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(packet.getData()));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是我们比较熟悉的Socket编程，其中有特点的就是在服务器端的第x行代码，此处若未收到来自客户端的数据，服务器端将会被阻塞。&lt;/p&gt;
&lt;h3&gt;5.2 非阻塞式网络编程（NIO Socket）&lt;/h3&gt;
&lt;p&gt;　　在通常情况下，对于网络编程用的比较多的还是阻塞式。非阻塞式在应用程序中并不是特别常见，但它在Tomcat等Web服务器中却很常见。这是因为对于非阻塞式的网络编程其最大的优点或者说是最大的使用场景就是面对多个客户端时良好的性能表现。&lt;/p&gt;
&lt;p&gt;　　此处我们还是在单一的客户端场景下使用非阻塞式网络编程（多个客户端就会使用到Selector选择器，下文会展开）。同样在本例中使用UDP协议传输数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * NIO客户端
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/18.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         DatagramChannel channel = DatagramChannel.open();       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似读取本地文件，首先都需要建立一个通道&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ByteBuffer buffer = Charset.forName(&quot;utf-8&quot;).encode(&quot;this is Client.&quot;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其次建立一个缓冲区&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         channel.send(buffer, &lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;127.0.0.1&quot;, 8989&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; *NIO 服务器端
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/18.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         DatagramChannel channel =&lt;span&gt; DatagramChannel.open();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         channel.socket().bind(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;127.0.0.1&quot;, 8989&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         ByteBuffer buffer = ByteBuffer.allocate(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         channel.receive(buffer);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器端没有收到来自客户端的数据，会在这里和BIO Socket一样被阻塞&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(buffer.array()));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于NIO Socket的服务器端第10行可能会感到疑惑，既然是非阻塞的那么为什么在这个地方还是被阻塞了呢？在未收到客户端的数据时为什么还是被阻塞挂起了呢？这就需要用开头提到的这是1个客户端对应1个服务器端的场景，BIO和NIO并无明显区别，对于BIO或许更有优势，因为它的API相对来说更简单一些。而如果是多个客户端，如果使用NIO，服务器端会利用Selector（选择器）来选择准备好了的数据，而不会想此例一样一直等待一个客户端传输数据。接下来就是对Selector选择器的进一步认识。&lt;/p&gt;

&lt;p&gt;　　看到这里对于NIO似乎还只有一个认识，API变得负责了，莫名其妙地从“流”的概念转换为了“通道”“+“缓冲区”，并且似乎和BIO并无多大区别。要我说，最大的区别和改进莫过于彻底理解NIO中的Selector（选择器）。 在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/7995559.html&quot; target=&quot;_blank&quot;&gt;《Java IO（2）阻塞式输入输出（BIO）》&lt;/a&gt;一文的末尾提到了在服务器端利用线程来处理数据以便使得程序能拥有更大的吞吐量，这种利用新开一个线程来处理接收到的数据不失为一种常用的计策。但是，在程序中，我个人认为还是要谨慎使用多线程，毕竟线程的上下文切换是有一定的开销的，况且线程如果过多还有可能造成Java虚拟机的栈溢出。Selector选择器的出现就可以使用1个线程来管理。&lt;/p&gt;
&lt;p&gt;　　上面的示例程序都只有一个通道，也就是说同时只会读取或写入一个文件，如果现在有多个客户端，此时也就有多个通道，Selector选择器将会选择已经准备好了的通道读取数据。&lt;/p&gt;
&lt;p&gt;　　要使用Selector选择器，免不了大致会经过以下几个流程：创建Selector选择器；将Channel通道修改为非阻塞模式（只有Socket才能修改为非阻塞模式，FileChannel不能修改），并将通道注册至Selector；Selector调用select方法对通道进行选择。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * NIO 客户端，此处只有一个客户端连接
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/24.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         DatagramChannel channel =&lt;span&gt; DatagramChannel.open();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         ByteBuffer buffer = Charset.forName(&quot;utf-8&quot;).encode(&quot;this is Client.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         channel.send(buffer, &lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;127.0.0.1&quot;, 8989&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上注释所说，此处的示例仍然是只有一个客户端连接，对于服务器端的连接下面将会使用Selector选择器，重要部分在注释中已说明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * NIO 服务器端
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/23.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Selector selector = Selector.open();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Selector选择器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         DatagramChannel channel = DatagramChannel.open();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Channel通道&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         channel.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         channel.bind(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&quot;127.0.0.1&quot;, 8989&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         channel.register(selector, SelectionKey.OP_READ);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此通道注册在Selector时关注是否可读&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             selector.select();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有一个注册到此Selector上的通道就绪，则阻塞；反之，只要有一个通道就绪则不会被阻塞。selectNow方法不论是否有通道就绪，都不会阻塞。&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择就绪的通道&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 SelectionKey key =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                iterator.remove();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (key.isReadable()) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;收到客户端数据&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    receive(key);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (key.isWritable()) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器端通道准备好向客户端发送数据&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    send(key);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * 服务器端收到客户端数据，并做处理
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receive(SelectionKey key) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         DatagramChannel channel =&lt;span&gt; (DatagramChannel) key.channel();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         ByteBuffer byteBuffer = ByteBuffer.allocate(1024&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        channel.receive(byteBuffer);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(byteBuffer.array()));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     * 服务器端通道已准备好向客户端发送数据
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send(SelectionKey key) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于使用Selector选择器，可以使得服务器端只使用1个线程来管理多个连接，尽管在上面的例子没有给出示例代码，但这种场景在Web应用中可以说是必然的，因为对于客户端（浏览器）一定是很多的，而服务器就只有一个，此时正是NIO场景的最大使用，当然上面的例子也可以看到JDK原生NIO编程相比于BIO是略微有点复杂的，市面上也有很多优秀的第三方NIO框架——Netty、Mina均是对NIO的再次封装，这在以后也会提到，此篇关于NIO的了解暂到此处，以后将会在对此有更深刻的理解时再次讲解。下篇将介绍——AIO（异步输入输出）。 &lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 17:16:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8095326.html</dc:identifier>
</item>
<item>
<title>2017，知识与财富 - shoufengwei</title>
<link>http://www.cnblogs.com/shoufengwei/p/8095183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufengwei/p/8095183.html</guid>
<description>&lt;h2 id=&quot;纪念这逝去的一年芳华&quot;&gt;纪念这逝去的一年芳华&lt;/h2&gt;
&lt;p&gt;不知是何原因，当我想要去总结这一年的时候脑子里突然就蹦出了这两个词，依稀记得去年写的是感恩乐观努力。时间过的真快，在还没有忘记上一年关键词的时候这一年已经过去了。就是在这一年年的总结中时间匆匆流逝，然而还是不得不总结一下，以对得起这流失的一年芳华，也为来年提供一个方向。&lt;/p&gt;
&lt;p&gt;要说这一年是知识和财富大丰收，那显然没有，各方面四平八稳的过着，惊不起一点涟漪。至于为何叫知识与财富，似乎是想要说明一些问题，比如阐述一下知识与财富的关系、知识与财富哪个重要等等，这些问题个个都是大问题，我只能通过自己这一年的实际情况来谈谈相关的体会与感悟。&lt;/p&gt;
&lt;h2 id=&quot;回顾2017&quot;&gt;回顾2017&lt;/h2&gt;
&lt;p&gt;先来看一下2016年总结给自己定的目标的完成情况。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2017要以全新的角度来认识自己，以更加积极乐观的心态面对这个世界，以更加努力的态度解决未知。努力实现以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继续进行分布式地理信息系统研究&lt;/li&gt;
&lt;li&gt;&lt;em&gt;继续学英语，争取考一次雅思或托福&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;找准方向，为出第一本书或者翻译第一本书进行技术储备&lt;/li&gt;
&lt;li&gt;锻炼身体&lt;/li&gt;
&lt;li&gt;多读书&lt;/li&gt;
&lt;li&gt;常回家看看，多陪陪父母及朋友&lt;/li&gt;
&lt;li&gt;多旅游&lt;/li&gt;
&lt;li&gt;&lt;em&gt;多挣钱&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;第一句总语很关键，基本实现。这一年从多方面对自己有了全新的认识，心态更加积极乐观，只是“更加努力”有点差强人意，某些方面稍微有些放纵。&lt;/p&gt;
&lt;p&gt;凡是正体的都是完成了的，斜体未完成，下同。本身定的目标就缺少量化标准，有点随心所欲。下面的部分会详细介绍完成情况，这里主要介绍一下为什么有些没有完成（找借口）。&lt;/p&gt;
&lt;p&gt;英语倒是有学，总体提高不大，没敢去尝试考一次雅思或托福，主要是懈怠，但是也翻译了一本技术书籍，读了两本英文原著，对英语的理解从应试到了应用，真正的将其作为等同于汉语的一门语言来看待，对英语学习有了一点点小感悟，个人感觉读原著应该是最好的学习方式，除了直接处在英语的氛围内。平时也想去学会英语，可是时间总是这么不经意的就流逝了，一闭一睁一天、一周、一年就过去了。&lt;/p&gt;
&lt;p&gt;多挣钱基本无从谈起，当时考虑可能要换工作，所以定了这么一个目标，结果日子照旧，钱没挣上。但是同样对金钱有了一点新的感悟。&lt;/p&gt;
&lt;p&gt;锻炼身体这一条勉强通过，一年平均每周一至两个3公里，消失的6块腹肌又有了雏形，但是坐的时间太长活动还是太少，导致腰和脖子都不太舒服，这一点2018能有好转吗？必须！&lt;/p&gt;
&lt;p&gt;总体上来说这一年是达到了自己16年总结定下的目标的，接下来开始详细回顾2017。&lt;/p&gt;
&lt;h2 id=&quot;知识篇&quot;&gt;知识篇&lt;/h2&gt;
&lt;h3 id=&quot;技术&quot;&gt;技术&lt;/h3&gt;
&lt;p&gt;这一年显然不是知识领悟涨幅最大的一年，这一年并没有把很多精力投入到学习上，忙于各种事情，飞了大概有30次，看上去时间仿佛过的很快，一周周转瞬即逝，不免发出“时间总是过的很快，有些人觉得很快，也有些人觉得很快。”的感叹。但是静下心来发现时间大部分都被耽误掉了，并没有很好的利用点滴时间。前几年还有大段的几个月的时间供自己静下心来研究一件事情，现在是越来越难了，各种事情，一言难尽。。。但知识也确实在增长，这更多的是一种在前几年储备的基础上的增长，看上去也涨了不少，更多靠的是惯性，建立在之前已有的基础上。&lt;/p&gt;
&lt;p&gt;就拿Geotrellis来说，目前总共写了35篇博客介绍使用方法及感悟，排除刚开始瞎写的因素，从16年4月开始研究，本年度只写了8篇，虽说今年解决了一些问题，但明显没有去年对此技术研究的那么深入。&lt;/p&gt;
&lt;p&gt;全年一直贯穿着使用Python进行地理信息处理工作，包括矢量数据、栅格数据、连接数据库、可视化等一套完整的数据处理和可视化流程。Python是这两年比较火的语言，未来在地理信息和人工智能方面应用会更广。&lt;/p&gt;
&lt;p&gt;OpenStack和Docker两个云平台和虚拟化技术应该是自己今年最大的收获，通过这两个技术基本上把各大技术串接到了一起，从做网线开始到网络规划、网络管理、服务器规划、服务器管理、云平台搭建、分布式集群搭建等等一系列技术，这些技术都是自己利用闲暇时间一点点摸索出来的，学的是痛并快乐着，收获很多，但这也是基于前几年对数据中心各方面技术上的事务不断探索积累的结果，有了这些积累后在面对这些新问题的时候能够不慌张，知道该朝什么方向努力，经过不懈的一点点的尝试终于小有所获。&lt;/p&gt;
&lt;p&gt;后期又学习了GO语言，研究了三维可视化表达，大致了解了WebGL的原理等，又尝试了Cesium三维地信可视化框架，这是个不错的东西，做出来的前端地图效果非常炫。&lt;/p&gt;
&lt;p&gt;12月开始进行人工智能有关知识学习，准备充当一次被风吹起的猪。这块之前接触过一点，做过一点机器视觉方面的工作，目前正在学习吴恩达的课程，Python倒是派上了用场。&lt;/p&gt;
&lt;p&gt;这一年写了些技术文章，不知道能不能帮助到其他人，起码我自己在这个过程中收获很多，即总结了自己的思路又提高了表达能力。这里就不放全部链接了，详情查看&lt;a href=&quot;http://www.cnblogs.com/shoufengwei/&quot;&gt;博客园&lt;/a&gt;或者&lt;a href=&quot;http://www.jianshu.com/u/d35a64082cb3&quot;&gt;简书&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本年度读了几本技术书籍，详情如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://wsf1990.gitbooks.io/shapeless-guide/content/&quot;&gt;shapeless-guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Scala函数式编程&lt;/li&gt;
&lt;li&gt;网络攻防实践&lt;/li&gt;
&lt;li&gt;Linux命令行与Shell脚本编程大全&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;技术书籍读的不多，大部分时间都是看博客和教程，这一点需要改进，一些经典的书籍还是值得一读。&lt;/p&gt;
&lt;p&gt;其中&lt;a href=&quot;https://www.gitbook.com/book/wsf1990/shapeless-guide/details&quot;&gt;shapeless-guide&lt;/a&gt;是我翻译的第一本技术书籍，跟小伙伴一起大概用了两个多月的时间完成。第一次尝试，刚开始有些困难，走过一遍之后心里就有底了，这也为读两本有中文对照的英文书刊奠定了基础。&lt;/p&gt;
&lt;h3 id=&quot;文学&quot;&gt;文学&lt;/h3&gt;
&lt;p&gt;当然知识不仅是技术，作为一个技术人我时刻想要认识自己、认识世界，于是选择读书，这一年读了30本左右的文学作品，罗列如下：&lt;/p&gt;
&lt;p&gt;每本书读完都写了读后感，有的还写了多篇，写的不好，谨以此记录自己的读书轨迹。其中最要提的就是《红楼梦》，以前怎么都看不进去这本书，今年偶然买了一本，拿起就放不下，读了一遍还想再读第二遍；关于蒋介石的两本书让我对蒋介石和那段历史有了全新的认识，当然这两本书也不能代表真正的历史，只能是个参考；《老人与海》先读的中文版又读了英文版，《中国哲学简史》直接读的英文版，读这两个英文原著对自己的英语感觉培养提升很大，起码不再惧怕直接看英文的东西；读了几本东野圭吾的小说，东野先生的作品参差不齐，有些非常好，如《解忧杂货店》和《白夜行》，但是《假面系列》、《名侦探的守则》、《东野圭吾在坏笑》则非常一般，未能坚持读完。读了这些书之后我感觉读书是找到更好的自己的最好也是最省钱的方式。&lt;/p&gt;
&lt;p&gt;电影这一年也没少看，基本上每个月得欣赏那么两三部，也有在自己电脑上欣赏的经典片子。感觉比较好的如下：&lt;/p&gt;
&lt;h3 id=&quot;行走&quot;&gt;行走&lt;/h3&gt;
&lt;p&gt;这一年走了不少地方，欣赏了很多美景和古迹，见到了许许多多的人。最难忘的是4月份去的西藏，都说这是一片神奇的土地，但是没去之前一切只能停留在想象中，当真正的站在这块土地呼吸那里的空气的时候，会不由自主的在心底嗷地一声：原来是这样的啊。神奇的山、神奇的水、蓝蓝的天空、美丽的草原、悠闲自得的羊马群，最重要的是那些充满信仰的灵魂。还去了伊犁大草原、敦煌莫高窟、麦积山石窟等地方，每个地方都有一段不一样的收获和感悟。这一年的行走记录如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;兰州 2017.4&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9855af697605&quot;&gt;面朝五泉，春暖花开&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/11220bc39b0f&quot;&gt;春风又绿河两岸，睹物思人又一春&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;西藏 2017.4&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/572a43bccd42&quot;&gt;直指灵魂的旅行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/01c4458c971c&quot;&gt;寻佛之旅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/ccdd7c0f13db&quot;&gt;穿越四季的遇见—巴松措&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/135b8986ed40&quot;&gt;圣洁的水啊你为什么如此圣洁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/e740b45cf658&quot;&gt;人生难免无意外&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/be418ca8ccc0&quot;&gt;不畏千辛万苦两世弘法路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/c98eec16db6c&quot;&gt;醉美西藏——扎西德勒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/1b9d37c6a009&quot;&gt;千回万转，不过梦一场&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/dd7c291950f7&quot;&gt;转山转水转佛塔&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-89da36bf5dbc11c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-80e612a936106db5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-f33cc102a032ade1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-a573845c698035a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;武汉 2017.5&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/4c08311f115a&quot;&gt;五元夜游武汉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/3fb4e89b68ae&quot;&gt;武汉如此多娇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/6b4a49e7fcfd&quot;&gt;尽览大好河山，饱读天下诗书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-58184754a78c29bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;酒泉 2017.5&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/e20f68cc0189&quot;&gt;大漠孤烟，长河落日&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/15c6900b7948&quot;&gt;弱水三千，滋养大漠绿叶&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-387bf27d0322181a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;伊犁 2017.6&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/d807bcb46e87&quot;&gt;伊犁——一个不愿再来的美景&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-a1dc4c6c6f0b00d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-dee299dd982c7819.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-779e1e8d60c5359d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-10f651e20c53d4d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;乌鲁木齐 2017.7&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;南山&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-8c3d3b94f2d01eae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上海 2017.8&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;外滩&lt;/li&gt;
&lt;li&gt;东方明珠&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-1d8fd8461c8666cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;敦煌 2017.10.1&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/89936db3ecd4&quot;&gt;熟悉的大漠，熟悉的味道，跨越千年的旅行&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-89b0ef935580b178.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;吐鲁番 2017.10.2&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/a125ab3fb24d&quot;&gt;十年百年千年万年 那年芳华，静待花开&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-8a40930daa58d3fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;北京 2017.11&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;香山&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/b43b68652ecc&quot;&gt;天坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5896d9fbf41c&quot;&gt;南锣鼓巷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5896d9fbf41c&quot;&gt;地坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5896d9fbf41c&quot;&gt;雍和宫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5896d9fbf41c&quot;&gt;德云社&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/4d2162ee22a5&quot;&gt;国家大剧院&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-0b89f9228c1dba70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1457239-74034a1f34c00091.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;天水 2017.12&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;麦积山石窟&lt;/li&gt;
&lt;li&gt;街亭温泉&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些走过的路看过的风景都将记录在我岁月的年轮里，见证世界的神奇也见证自己在苍茫的大地上移动的轨迹。&lt;/p&gt;
&lt;h2 id=&quot;财富篇&quot;&gt;财富篇&lt;/h2&gt;
&lt;p&gt;这一年对财富有了新的思考，以前自己还算是个比较节俭的人，这一年钱没少花，但我觉得花的挺值，不是说感悟到钱是挣出来的不是省出来的等等，而是我明白了一个道理，一个人当下有多少钱与将来有多少钱之间没有必然的联系。&lt;/p&gt;
&lt;p&gt;比如说拆迁拿到了1000万，那么恐怕这辈子也就这1000万了，手里握着这些钱会无所事事，不知道自己要去干什么，估计是买几套房子（最理想的情况）买个车，然后靠房租四平八稳的过着下半生，不出大问题肯定饿不着。这样的生活也是大部分人向往的，我也想要这样的生活，但是恐怕是没有这个拆迁的机会了。我不反对任何一种生活方式，只要自己觉得OK又不妨碍到其他人那么这就是适合自己的。&lt;/p&gt;
&lt;p&gt;但是一个人真正拥有的财富恐怕在与自己的价值，有1000万和让自己值1000万这完全是两个概念，值1000万即使现在身无分文也一定会拿到手这1000万，还可能是几倍、几十倍的，在这个过程中“身价”也会继续增长。真正的财富是无论身处何处、无论当下有多少钱都有从头再来、东山再起的能力。&lt;/p&gt;
&lt;p&gt;这一年面临多次抉择，不能说自己的选择到底是对还是错，本身选择也就没有对错，人生只有一次，不可能会有重新选择其他方案的机会。几次选择都跟金钱和前途有些关系，年中的时候写过一篇文章，说世界上有那么路，而我一直在选最难走的那条，最终如同崔健的那首歌：可你却总是笑我，一无所有。但难走的路才能让自己提高，难走的路才能让自己看清自己，难走的路也才能提高自己的“身价”，否则生活就如一碗水，永远不会有一点波澜，碗里的水如何能够去见识这个世界，碗里的水如何能够取得真正属于自己的“财富”。最终“我要给你我的追求，还有我的自由。”。&lt;/p&gt;
&lt;h2 id=&quot;二者关系&quot;&gt;二者关系&lt;/h2&gt;
&lt;p&gt;然而人到中年就很容易产生危机。最近42岁中兴程序员跳楼在IT圈炒的沸沸扬扬，不对此人做任何评价，就事论事，当然此事绝对很复杂。随着这一跃，其身价顿时化为0，虽然人到中年压力确实很大，但他更应该提前准备好让自己拥有东山再起的能力和机会。&lt;/p&gt;
&lt;p&gt;什么是“身价”？“身价”源于对自己和外部世界清醒的认识，认识这二者都非常困难，我们只有通过不断的知识积累、不断努力、不断行走在这个世界来一点点的靠近目标，最终“不役于物”的时候你就拥有了整个世界，更无需说财富，这就是庄子的《逍遥游》。当然“身价”也包括自身拥有的或者继承的财富。&lt;/p&gt;
&lt;p&gt;大学学马列主义的时候，被老师抽中做了个随意的演讲，思考半天写了一篇《论家庭环境对伟人的影响》。大概是说毛、邓、马克思、列宁这些伟人，绝不可能出自贫下中农，因为伟人必须要站的比别人高才能比别人看的远，只有身处社会中上层才能看清这个社会、看清自己，他们才拥有了绝对高的“身价”。&lt;/p&gt;
&lt;p&gt;所谓寒门再难出人才不是因为富人的打压，无可厚非富人占据了更多的社会资源，但重要的是贫穷限制了想象力，使得“寒门”无法去想象外面的世界，更不用谈去认识这个世界。本身就占据的资源少，又无法坚持去通过努力提高自己，也就更不用谈去认识自己，“身价”自然就低了。然而只要知道自己要的是什么，不断坚持去提高自己，去多看看这个世界，终究会达到让自己吃惊的程度。&lt;/p&gt;
&lt;p&gt;读书和远行绝对是提升自己的最好方式，无论是技术书籍还是文学作品，读过的任何一本书、学到的任何一个技术、走过的每一步路、看过的每一个景最终都会变成“身价”累加到流逝的芳华中。&lt;/p&gt;
&lt;p&gt;所以知识（广义）决定“身价”，“身价”决定未来，这就是我所认为的知识与财富的关系，孰重孰轻一目了然。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;2018&lt;/h2&gt;
&lt;p&gt;2018要保持谦虚谨慎的心态，不以物喜，不以己悲，把握自己的内心，丰富自己的生活，去体验和享受生活、体验这个世界。努力完成以下几项任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;技术研究，永不停息：地信、大数据、&lt;strong&gt;机器学习&lt;/strong&gt;、&lt;strong&gt;硬件开发&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;继续学英语，最少&lt;strong&gt;读1本英文原著&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;增强人际交往能力、涉足管理&lt;/li&gt;
&lt;li&gt;锻炼身体，全年&lt;strong&gt;300公里&lt;/strong&gt;以上、&lt;strong&gt;腹肌保持&lt;/strong&gt;、打&lt;strong&gt;羽毛球&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多读书，&lt;strong&gt;20本以上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多旅游，&lt;strong&gt;蹦一次极&lt;/strong&gt;、&lt;strong&gt;潜一次泳&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;事业&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几年技术研究都是浮于表面，涉足的领域很广，但是没有专心去精通一门，这一点2018要有所改进，在某一方面找到自己的兴趣，并持之以恒的进行深入的学习；读书已经融入我的血液，2018多读些好书和经典书籍；2018最想干的两件事，蹦极和潜泳，有些事情年轻的时候不干就再也没有机会了，正是说的这些吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;时间都去哪儿了，他总是这么轻易的流逝，流逝在我读过的每一本书、在我走过的每一条路、在我发过的每一个呆，这些流逝的时间会穿成一条线，记录下我平凡而美好的生活，我要做的就是让这条线上的每个点都是有意义的不是虚度的，努力让这条线拥有更高的高度，撑起生命的厚度，最终收获一个充盈的自己。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 16:48:00 +0000</pubDate>
<dc:creator>shoufengwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufengwei/p/8095183.html</dc:identifier>
</item>
<item>
<title>单点登录系统实现 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8094722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8094722.html</guid>
<description>&lt;p&gt;今天的干货有点湿，里面夹杂着我的泪水。可能也只有代码才能让我暂时的平静。通过本章内容你将学到单点登录系统和传统登录系统的区别，单点登录系统设计思路，Spring4 Java配置方式整合HttpClient，整合SolrJ ，HttpClient简易教程。还在等什么？撸起袖子开始干吧！&lt;br/&gt;效果图：8081端口是sso系统，其他两个8082和8083端口模拟两个系统。登录成功后检查Redis数据库中是否有值。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171223175305193-1149592447.gif&quot; alt=&quot;效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;技术：SpringBoot，SpringMVC，Spring，SpringData，Redis，HttpClient&lt;br/&gt;说明：本章的用户登录注册的代码部分已经在SpringBoot基础入门中介绍过了，这里不会重复贴代码。&lt;br/&gt;源码：见文章底部&lt;br/&gt;SpringBoot基础入门：&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/8047132.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/p/8047132.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;单点登录系统简介&quot;&gt;单点登录系统简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171223225633553-1173436321.png&quot; alt=&quot;单点登录系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统的系统，或者是只有一个服务器的系统中。Session在一个服务器中，各个模块都可以直接获取，只需登录一次就进入各个模块。若在服务器集群或者是分布式系统架构中，每个服务器之间的Session并不是共享的，这会出现每个模块都要登录的情况。这时候需要通过单点登录系统（Single Sign On）将用户信息存在Redis数据库中实现Session共享的效果。从而实现一次登录就可以访问所有相互信任的应用系统。&lt;/p&gt;
&lt;h2 id=&quot;单点登录系统实现&quot;&gt;单点登录系统实现&lt;/h2&gt;
&lt;p&gt;Maven项目核心配置文件 pom.xml 需要在原来的基础上添加 httpclient和jedis jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;    &amp;lt;!-- http client version is 4.5.3 --&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;    &amp;lt;!-- redis java client version is 2.9.0  --&amp;gt;
        &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring4-java配置方式&quot;&gt;Spring4 Java配置方式&lt;/h2&gt;
&lt;p&gt;这里，我们需要整合httpclient用于各服务之间的通讯(也可以用okhttp)。同时还需要整合redis用于存储用户信息(Session共享)。&lt;br/&gt;在Spring3.x之前，一般在&lt;strong&gt;应用的基本配置&lt;/strong&gt;用xml，比如数据源、资源文件等。&lt;strong&gt;业务开发&lt;/strong&gt;用注解，比如Component，Service，Controller等。其实在Spring3.x的时候就已经提供了Java配置方式。现在的Spring4.x和SpringBoot都开始推荐使用Java配置方式配置bean。它可以使bean的结构更加的清晰。&lt;/p&gt;
&lt;h3 id=&quot;整合-httpclient&quot;&gt;整合 HttpClient&lt;/h3&gt;
&lt;p&gt;HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。&lt;br/&gt;HttpClient4.5系列教程 : &lt;a href=&quot;http://blog.csdn.net/column/details/httpclient.html&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/column/details/httpclient.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在src/main/resources 目录下创建 httpclient.properties 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#设置整个连接池默认最大连接数
http.defaultMaxPerRoute=100
#设置整个连接池最大连接数
http.maxTotal=300
#设置请求超时
http.connectTimeout=1000
#设置从连接池中获取到连接的最长时间
http.connectionRequestTimeout=500
#设置数据传输的最长时间
http.socketTimeout=10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 src/main/java/com/itdragon/config 目录下创建 HttpclientSpringConfig.java 文件&lt;br/&gt;这里用到了四个很重要的注解&lt;br/&gt;@Configuration : 作用于类上，指明该类就相当于一个xml配置文件&lt;br/&gt;@Bean : 作用于方法上，指明该方法相当于xml配置中的，注意方法名的命名规范&lt;br/&gt;@PropertySource : 指定读取的配置文件，引入多个value={&quot;xxx:xxx&quot;,&quot;xxx:xxx&quot;},ignoreResourceNotFound=true 文件不存在是忽略&lt;br/&gt;@Value : 获取配置文件的值，该注解还有很多语法知识，这里暂时不扩展开&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.config;

import java.util.concurrent.TimeUnit;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.client.IdleConnectionEvictor;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.context.annotation.Scope;

/**
 * @Configuration   作用于类上，相当于一个xml配置文件
 * @Bean            作用于方法上，相当于xml配置中的&amp;lt;bean&amp;gt;
 * @PropertySource  指定读取的配置文件
 * @Value           获取配置文件的值
 */
@Configuration
@PropertySource(value = &quot;classpath:httpclient.properties&quot;)
public class HttpclientSpringConfig {

    @Value(&quot;${http.maxTotal}&quot;)
    private Integer httpMaxTotal;

    @Value(&quot;${http.defaultMaxPerRoute}&quot;)
    private Integer httpDefaultMaxPerRoute;

    @Value(&quot;${http.connectTimeout}&quot;)
    private Integer httpConnectTimeout;

    @Value(&quot;${http.connectionRequestTimeout}&quot;)
    private Integer httpConnectionRequestTimeout;

    @Value(&quot;${http.socketTimeout}&quot;)
    private Integer httpSocketTimeout;

    @Autowired
    private PoolingHttpClientConnectionManager manager;

    @Bean
    public PoolingHttpClientConnectionManager poolingHttpClientConnectionManager() {
        PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();
        // 最大连接数
        poolingHttpClientConnectionManager.setMaxTotal(httpMaxTotal);
        // 每个主机的最大并发数
        poolingHttpClientConnectionManager.setDefaultMaxPerRoute(httpDefaultMaxPerRoute);
        return poolingHttpClientConnectionManager;
    }

    @Bean   // 定期清理无效连接
    public IdleConnectionEvictor idleConnectionEvictor() {
        return new IdleConnectionEvictor(manager, 1L, TimeUnit.HOURS);
    }

    @Bean   // 定义HttpClient对象 注意该对象需要设置scope=&quot;prototype&quot;:多例对象
    @Scope(&quot;prototype&quot;)
    public CloseableHttpClient closeableHttpClient() {
        return HttpClients.custom().setConnectionManager(this.manager).build();
    }

    @Bean   // 请求配置
    public RequestConfig requestConfig() {
        return RequestConfig.custom().setConnectTimeout(httpConnectTimeout) // 创建连接的最长时间
                .setConnectionRequestTimeout(httpConnectionRequestTimeout) // 从连接池中获取到连接的最长时间
                .setSocketTimeout(httpSocketTimeout) // 数据传输的最长时间
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整合-redis&quot;&gt;整合 Redis&lt;/h3&gt;
&lt;p&gt;SpringBoot官方其实提供了spring-boot-starter-redis pom 帮助我们快速开发，但我们也可以自定义配置，这样可以更方便地掌控。&lt;br/&gt;Redis 系列教程 : &lt;a href=&quot;http://www.cnblogs.com/itdragon/category/1122427.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/category/1122427.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在src/main/resources 目录下创建 redis.properties 配置文件&lt;br/&gt;设置Redis主机的ip地址和端口号，和存入Redis数据库中的key以及存活时间。这里为了方便测试，存活时间设置的比较小。这里的配置是单例Redis。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;redis.node.host=192.168.225.131
redis.node.port=6379

REDIS_USER_SESSION_KEY=REDIS_USER_SESSION
SSO_SESSION_EXPIRE=30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在src/main/java/com/itdragon/config 目录下创建 RedisSpringConfig.java 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.config;

import java.util.ArrayList;
import java.util.List;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.ShardedJedisPool;

@Configuration
@PropertySource(value = &quot;classpath:redis.properties&quot;)
public class RedisSpringConfig {

    @Value(&quot;${redis.maxTotal}&quot;)
    private Integer redisMaxTotal;

    @Value(&quot;${redis.node.host}&quot;)
    private String redisNodeHost;

    @Value(&quot;${redis.node.port}&quot;)
    private Integer redisNodePort;

    private JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(redisMaxTotal);
        return jedisPoolConfig;
    }
    
    @Bean 
    public JedisPool getJedisPool(){    // 省略第一个参数则是采用 Protocol.DEFAULT_DATABASE
        JedisPool jedisPool = new JedisPool(jedisPoolConfig(), redisNodeHost, redisNodePort);
        return jedisPool;
    }

    @Bean
    public ShardedJedisPool shardedJedisPool() {
        List&amp;lt;JedisShardInfo&amp;gt; jedisShardInfos = new ArrayList&amp;lt;JedisShardInfo&amp;gt;();
        jedisShardInfos.add(new JedisShardInfo(redisNodeHost, redisNodePort));
        return new ShardedJedisPool(jedisPoolConfig(), jedisShardInfos);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;service-层&quot;&gt;Service 层&lt;/h3&gt;
&lt;p&gt;在src/main/java/com/itdragon/service 目录下创建 UserService.java 文件，它负责三件事情&lt;br/&gt;第一件事件：验证用户信息是否正确，并将登录成功的用户信息保存到Redis数据库中。&lt;br/&gt;第二件事件：负责判断用户令牌是否过期，若没有则刷新令牌存活时间。&lt;br/&gt;第三件事件：负责从Redis数据库中删除用户信息。&lt;br/&gt;这里用到了一些工具类，不影响学习，可以从源码中直接获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.service;

import java.util.UUID;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import com.itdragon.pojo.ItdragonResult;
import com.itdragon.pojo.User;
import com.itdragon.repository.JedisClient;
import com.itdragon.repository.UserRepository;
import com.itdragon.utils.CookieUtils;
import com.itdragon.utils.ItdragonUtils;
import com.itdragon.utils.JsonUtils;

@Service
@Transactional
@PropertySource(value = &quot;classpath:redis.properties&quot;)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private JedisClient jedisClient;
    
    @Value(&quot;${REDIS_USER_SESSION_KEY}&quot;)
    private String REDIS_USER_SESSION_KEY;
    
    @Value(&quot;${SSO_SESSION_EXPIRE}&quot;)
    private Integer SSO_SESSION_EXPIRE;
    
    public ItdragonResult userLogin(String account, String password,
            HttpServletRequest request, HttpServletResponse response) {
        // 判断账号密码是否正确
        User user = userRepository.findByAccount(account);
        if (!ItdragonUtils.decryptPassword(user, password)) {
            return ItdragonResult.build(400, &quot;账号名或密码错误&quot;);
        }
        // 生成token
        String token = UUID.randomUUID().toString();
        // 清空密码和盐避免泄漏
        String userPassword = user.getPassword();
        String userSalt = user.getSalt();
        user.setPassword(null);
        user.setSalt(null);
        // 把用户信息写入 redis
        jedisClient.set(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, JsonUtils.objectToJson(user));
        // user 已经是持久化对象，被保存在session缓存当中，若user又重新修改属性值，那么在提交事务时，此时 hibernate对象就会拿当前这个user对象和保存在session缓存中的user对象进行比较，如果两个对象相同，则不会发送update语句，否则会发出update语句。
        user.setPassword(userPassword);
        user.setSalt(userSalt);
        // 设置 session 的过期时间
        jedisClient.expire(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, SSO_SESSION_EXPIRE);
        // 添加写 cookie 的逻辑，cookie 的有效期是关闭浏览器就失效。
        CookieUtils.setCookie(request, response, &quot;USER_TOKEN&quot;, token);
        // 返回token
        return ItdragonResult.ok(token);
    }
    
    public void logout(String token) {
        jedisClient.del(REDIS_USER_SESSION_KEY + &quot;:&quot; + token);
    }

    public ItdragonResult queryUserByToken(String token) {
        // 根据token从redis中查询用户信息
        String json = jedisClient.get(REDIS_USER_SESSION_KEY + &quot;:&quot; + token);
        // 判断是否为空
        if (StringUtils.isEmpty(json)) {
            return ItdragonResult.build(400, &quot;此session已经过期，请重新登录&quot;);
        }
        // 更新过期时间
        jedisClient.expire(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, SSO_SESSION_EXPIRE);
        // 返回用户信息
        return ItdragonResult.ok(JsonUtils.jsonToPojo(json, User.class));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;controller-层&quot;&gt;Controller 层&lt;/h2&gt;
&lt;p&gt;负责跳转登录页面跳转&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class PageController {

    @RequestMapping(&quot;/login&quot;)
    public String showLogin(String redirect, Model model) {
        model.addAttribute(&quot;redirect&quot;, redirect);
        return &quot;login&quot;;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;负责用户的登录，退出，获取令牌的操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import com.itdragon.pojo.ItdragonResult;
import com.itdragon.service.UserService;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @RequestMapping(value=&quot;/login&quot;, method=RequestMethod.POST)
    @ResponseBody
    public ItdragonResult userLogin(String username, String password,
            HttpServletRequest request, HttpServletResponse response) {
        try {
            ItdragonResult result = userService.userLogin(username, password, request, response);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return ItdragonResult.build(500, &quot;&quot;);
        }
    }
    
    @RequestMapping(value=&quot;/logout/{token}&quot;)
    public String logout(@PathVariable String token) {
        userService.logout(token); // 思路是从Redis中删除key，实际情况请和业务逻辑结合
        return &quot;index&quot;;
    }
    
    @RequestMapping(&quot;/token/{token}&quot;)
    @ResponseBody
    public Object getUserByToken(@PathVariable String token) {
        ItdragonResult result = null;
        try {
            result = userService.queryUserByToken(token);
        } catch (Exception e) {
            e.printStackTrace();
            result = ItdragonResult.build(500, &quot;&quot;);
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;视图层&quot;&gt;视图层&lt;/h2&gt;
&lt;p&gt;一个简单的登录页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width, user-scalable=no&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,Chrome=1&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; /&amp;gt;
        &amp;lt;title&amp;gt;欢迎登录&amp;lt;/title&amp;gt;
        &amp;lt;link type=&quot;image/x-icon&quot; href=&quot;images/favicon.ico&quot; rel=&quot;shortcut icon&quot;&amp;gt;
        &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/main.css&quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
            &amp;lt;div class=&quot;container&quot;&amp;gt;
                &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
                &amp;lt;form method=&quot;post&quot; onsubmit=&quot;return false;&quot; class=&quot;form&quot;&amp;gt;
                    &amp;lt;input type=&quot;text&quot; value=&quot;itdragon&quot; name=&quot;username&quot; placeholder=&quot;Account&quot;/&amp;gt;
                    &amp;lt;input type=&quot;password&quot; value=&quot;123456789&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;/&amp;gt;
                    &amp;lt;button type=&quot;button&quot; id=&quot;login-button&quot;&amp;gt;Login&amp;lt;/button&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul class=&quot;bg-bubbles&quot;&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery-1.10.1.min.js&quot; &amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            var redirectUrl = &quot;${redirect}&quot;; // 浏览器中返回的URL
            function doLogin() {
                $.post(&quot;/user/login&quot;, $(&quot;.form&quot;).serialize(),function(data){
                    if (data.status == 200) {
                        if (redirectUrl == &quot;&quot;) {
                            location.href = &quot;http://localhost:8082&quot;;
                        } else {
                            location.href = redirectUrl;
                        }
                    } else {
                        alert(&quot;登录失败，原因是：&quot; + data.msg);
                    }
                });
            }
            $(function(){
                $(&quot;#login-button&quot;).click(function(){
                    doLogin();
                });
            });
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;httpclient-基础语法&quot;&gt;HttpClient 基础语法&lt;/h2&gt;
&lt;p&gt;这里封装了get，post请求的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.utils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

public class HttpClientUtil {
    
    public static String doGet(String url) {                            // 无参数get请求
        return doGet(url, null);
    }

    public static String doGet(String url, Map&amp;lt;String, String&amp;gt; param) { // 带参数get请求
        CloseableHttpClient httpClient = HttpClients.createDefault();   // 创建一个默认可关闭的Httpclient 对象
        String resultMsg = &quot;&quot;;                                          // 设置返回值
        CloseableHttpResponse response = null;                          // 定义HttpResponse 对象
        try {
            URIBuilder builder = new URIBuilder(url);                   // 创建URI,可以设置host，设置参数等
            if (param != null) {
                for (String key : param.keySet()) {
                    builder.addParameter(key, param.get(key));
                }
            }
            URI uri = builder.build();
            HttpGet httpGet = new HttpGet(uri);                         // 创建http GET请求
            response = httpClient.execute(httpGet);                     // 执行请求
            if (response.getStatusLine().getStatusCode() == 200) {      // 判断返回状态为200则给返回值赋值
                resultMsg = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {                                                     // 不要忘记关闭
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultMsg;
    }
    
    public static String doPost(String url) {                           // 无参数post请求
        return doPost(url, null);
    }

    public static String doPost(String url, Map&amp;lt;String, String&amp;gt; param) {// 带参数post请求
        CloseableHttpClient httpClient = HttpClients.createDefault();   // 创建一个默认可关闭的Httpclient 对象
        CloseableHttpResponse response = null;
        String resultMsg = &quot;&quot;;
        try {
            HttpPost httpPost = new HttpPost(url);                      // 创建Http Post请求
            if (param != null) {                                        // 创建参数列表
                List&amp;lt;NameValuePair&amp;gt; paramList = new ArrayList&amp;lt;NameValuePair&amp;gt;();
                for (String key : param.keySet()) {
                    paramList.add(new BasicNameValuePair(key, param.get(key)));
                }
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);// 模拟表单
                httpPost.setEntity(entity);
            }
            response = httpClient.execute(httpPost);                    // 执行http请求
            if (response.getStatusLine().getStatusCode() == 200) {
                resultMsg = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultMsg;
    }

    public static String doPostJson(String url, String json) {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;
        try {
            HttpPost httpPost = new HttpPost(url);
            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            response = httpClient.execute(httpPost);
            if (response.getStatusLine().getStatusCode() == 200) {
                resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultString;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-自定义拦截器&quot;&gt;Spring 自定义拦截器&lt;/h2&gt;
&lt;p&gt;这里是另外一个项目 itdragon-service-test-sso 中的代码，&lt;br/&gt;首先在src/main/resources/spring/springmvc.xml 中配置拦截器，设置那些请求需要拦截&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!-- 拦截器配置 --&amp;gt;
    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path=&quot;/github/**&quot;/&amp;gt;
            &amp;lt;bean class=&quot;com.itdragon.interceptors.UserLoginHandlerInterceptor&quot;/&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 src/main/java/com/itdragon/interceptors 目录下创建 UserLoginHandlerInterceptor.java 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.interceptors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import com.itdragon.pojo.User;
import com.itdragon.service.UserService;
import com.itdragon.utils.CookieUtils;

public class UserLoginHandlerInterceptor implements HandlerInterceptor {

    public static final String COOKIE_NAME = &quot;USER_TOKEN&quot;;

    @Autowired
    private UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        String token = CookieUtils.getCookieValue(request, COOKIE_NAME);
        User user = this.userService.getUserByToken(token);
        if (StringUtils.isEmpty(token) || null == user) {
            // 跳转到登录页面，把用户请求的url作为参数传递给登录页面。
            response.sendRedirect(&quot;http://localhost:8081/login?redirect=&quot; + request.getRequestURL());
            // 返回false
            return false;
        }
        // 把用户信息放入Request
        request.setAttribute(&quot;user&quot;, user);
        // 返回值决定handler是否执行。true：执行，false：不执行。
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
            Exception ex) throws Exception {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可能存在的问题&quot;&gt;可能存在的问题&lt;/h2&gt;
&lt;h4 id=&quot;springdata-自动更新问题&quot;&gt;SpringData 自动更新问题&lt;/h4&gt;
&lt;p&gt;SpringData 是基于Hibernate的。当User 已经是持久化对象，被保存在session缓存当中。若User又重新修改属性值，在提交事务时，此时hibernate对象就会拿当前这个User对象和保存在session缓存中的User对象进行比较，如果两个对象相同，则不会发送update语句，否则，会发出update语句。&lt;br/&gt;笔者采用比较傻的方法，就是在提交事务之前把数据还原。各位如果有更好的办法请告知，谢谢！&lt;br/&gt;参考博客：&lt;a href=&quot;http://www.cnblogs.com/xiaoluo501395377/p/3380270.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xiaoluo501395377/p/3380270.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;检查用户信息是否保存&quot;&gt;检查用户信息是否保存&lt;/h4&gt;
&lt;p&gt;登录成功后，进入Redis客户端查看用户信息是否保存成功。同时为了方便测试，也可以删除这个key。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# ./redis-cli -h 192.168.225.131 -p 6379
192.168.225.131:6379&amp;gt; 
192.168.225.131:6379&amp;gt; keys *
1) &quot;REDIS_USER_SESSION:1d869ac0-3d22-4e22-bca0-37c8dfade9ad&quot;
192.168.225.131:6379&amp;gt; get REDIS_USER_SESSION:1d869ac0-3d22-4e22-bca0-37c8dfade9ad
&quot;{\&quot;id\&quot;:3,\&quot;account\&quot;:\&quot;itdragon\&quot;,\&quot;userName\&quot;:\&quot;ITDragonGit\&quot;,\&quot;plainPassword\&quot;:null,\&quot;password\&quot;:null,\&quot;salt\&quot;:null,\&quot;iphone\&quot;:\&quot;12349857999\&quot;,\&quot;email\&quot;:\&quot;itdragon@git.com\&quot;,\&quot;platform\&quot;:\&quot;github\&quot;,\&quot;createdDate\&quot;:\&quot;2017-12-22 21:11:19\&quot;,\&quot;updatedDate\&quot;:\&quot;2017-12-22 21:11:19\&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 单点登录系统通过将用户信息放在Redis数据库中实现共享Session效果。&lt;br/&gt;2 Java 配置方式使用四个注解 @Configuration @Bean @PropertySource @Value 。&lt;br/&gt;3 Spring 拦截器的设置。&lt;br/&gt;4 HttpClient 的使用&lt;br/&gt;5 祝大家圣诞节快乐&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SSO&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SSO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，基于SpringBoot的单点登录系统就结束了，有什么不对的地方请指出。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 14:51:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8094722.html</dc:identifier>
</item>
<item>
<title>Spring之AOP一 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8093965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8093965.html</guid>
<description>&lt;p&gt;面向切片式编程不仅在Java中存在，在其他语言也是存在，例如asp.net的管道模型中，可以利用aop来进行自定义一些操作，比如权限认证、日志等。今天主要是引入AOP，具体它涉及到的专有名词先不做解释。&lt;/p&gt;
&lt;p&gt;一、横切纵切&lt;/p&gt;
&lt;p&gt;首先要知道什么是横切什么是纵切(吐槽大会的观众们这也是知识点)，下面的两张图是从网上找的，是讨论刨妇产是横切好还是纵切好的问题，知道什么是横切什么是纵切之后，我们也可以用莲藕来做比喻，横切切出来是圆的，纵切就不是了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223164732725-1684546396.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;242&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223164754256-809294908.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AOP&lt;/p&gt;
&lt;p&gt;对于一些系统特别时生产环境的问题有些是在UAT或者ST环境是发现不了的，但又不可能用真时的正式环境来进行测试，我们做项目一般都会增加日志输出，这样未来可以通过日志来定位发现问题，那就需要在每个方法中增加日志信息，并需要进行捕获异常，如果按照一般的做法那就需要在每个方法中增加日志信息，并在方法中增加try catch来进行捕获日常，这样就会很麻烦，哪天我又不想增加日志信息、捕获异常了那还需要修改代码，而且影响的范围也是特别的大，这样就体现不了低耦合的特点。那该如何是好呢？于是乎AOP来了。&lt;span&gt;AOP技术利用一种称为“横切”的技术，解剖封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，这样就能减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。&lt;/span&gt;红字部分基本把AOP的作用解释清楚了，它会将多个类的公共行为封装到一个可重用模块，然后将这个模糊注入里面，这里有个切的过程，不是内部操作，内部操作那还是复用了，是外部来进行操作。&lt;/p&gt;
&lt;p&gt;三、代码中实现AOP&lt;/p&gt;
&lt;p&gt; 还是在上面博客代码的基础上，新建了一个ServiceImplA类，它实现了IService接口，我想实现这样一个功能，就是想在调用service方法前后增加日志打印或为service方法增加try catch,那该怎么做呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IService {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; service(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceImplA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  IService{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(String name) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;ServiceImplA name&quot;+&lt;span&gt;name);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;1.在每处调用的地方增加日志和try catch&lt;/p&gt;
&lt;p&gt;这种也是一种方法，但缺点是很明显的，就是每处都要更改，量也会很大，显然不可取。这里是每个点都要加，一个方法可能被调用多处，那就要写多次。&lt;/p&gt;
&lt;p&gt;2.代理模式&lt;/p&gt;
&lt;p&gt;代理模式又分为动态代理模式和静态代理模式。&lt;/p&gt;
&lt;p&gt;(1)静态代理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态代理关键是在代理对象和目标对象实现共同的接口，并且代理对象持有目标对象的引用。&lt;/span&gt;这里我创建了类ProxyServiceA，它实现IService接口，同时将实现IService接口的对象作为一个属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  IService{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxyServiceA(IService service) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.service =&lt;span&gt; service;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IService service;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; service(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;log start&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            service.service(name);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        System.out.println(&lt;/span&gt;&quot;log end&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面的代码确实能为实现IService接口的对象增加调用前后的方法，并且增加了try catch。但是问题又来了。项目中接口可不止一个，可能会有很多，而且每个接口中的方法也会有好多，如果这样一个一个的增加不也是个问题。to be or not to be,that is a question.虽然比第一种方式，这种只需在每个方法中设置一次。&lt;/p&gt;
&lt;p&gt;(2)动态代理&lt;/p&gt;
&lt;p&gt;静态代理虽然也能解决上面增加日志和try catch来捕获异常，但是还是很麻烦，每个方法都要设置，于是动态代理来解决这个问题了。&lt;span&gt;动态代理实现主要是实现InvocationHandler，并且将目标对象注入到代理对象中，利用反射机制来执行目标对象的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynaProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object target;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object bind(Object object){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; object;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.target.getClass().getClassLoader(), &lt;span&gt;this&lt;/span&gt;.target.getClass().getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;log start&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
             result &lt;/span&gt;= method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target, args);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        System.out.println(&lt;/span&gt;&quot;log end&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
           IService service = (IService) &lt;span&gt;new&lt;/span&gt; DynaProxyServiceA().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceImplA());
           service.service(&lt;/span&gt;&quot;cuiyw&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223204308256-1637185633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; (3)2的升华&lt;/p&gt;
&lt;p&gt;上面通过动态代理可以实现在方法前后打印日志以及捕获异常，但是打印日志也可能有几种日志啊，现在是之间输出到操作台，那可能会是输入到文件或数据库，那肿么办呢？这里打印日志的操作我们也可以进一步的抽象，还是先创建一个接口ILog,然后创建一个类ConsoleLog实现ILog这个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILog {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; end(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConsoleLog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ILog{


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&lt;span&gt;new&lt;/span&gt; Date()+&quot; method name:&quot;+method.getName() + &quot; start...&quot;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; end(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&lt;span&gt;new&lt;/span&gt; Date()+&quot; method name:&quot;+ method.getName() + &quot; end...&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后将打印对象也在动态代理中抽象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynaProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object proxy;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object bind(Object object,Object proxy){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; object;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.proxy=&lt;span&gt;proxy;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.target.getClass().getClassLoader(), &lt;span&gt;this&lt;/span&gt;.target.getClass().getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的实例&lt;/span&gt;
        Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Object&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxy.getClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的Start方法&lt;/span&gt;
        Method start =clazz.getDeclaredMethod(&quot;start&quot;,&lt;span&gt;new&lt;/span&gt; Class[]{Method.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射执行start方法&lt;/span&gt;
        start.invoke(&lt;span&gt;this&lt;/span&gt;.proxy, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{method});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行要处理对象的原本方法&lt;/span&gt;
        result=method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target, args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的end方法&lt;/span&gt;
        Method end = clazz.getDeclaredMethod(&quot;end&quot;, &lt;span&gt;new&lt;/span&gt; Class[]{Method.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射执行end方法&lt;/span&gt;
        end.invoke(&lt;span&gt;this&lt;/span&gt;.proxy, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{method});
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
           IService service = (IService) &lt;span&gt;new&lt;/span&gt; DynaProxyServiceA().bind(&lt;span&gt;new&lt;/span&gt; ServiceImplA(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConsoleLog());
           service.service(&lt;/span&gt;&quot;cuiyw&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223213041725-1531272419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是把start、end都在动态代理中执行了，其实我们可以判断哪个方法有被实现，然后再进行执行。&lt;/p&gt;
&lt;p&gt;四、总结感悟&lt;/p&gt;
&lt;p&gt;上面标题是代码中实现AOP,虽并未提到AOP但是，如果把上面的能理解明白了，那AOP就很好理解了，也不用理解什么切点、连接点等这些名字就能用。&lt;/p&gt;
&lt;p&gt;最后聊几句大家可能都会遇到的问题，上周项目组开会说项目组有重组的可能，哎，感觉公司还真是够冷漠无情的，有利用价值就利用，没利用价值就被干掉，不管年龄大小，自身本来就没安全感，遇到这事还真是觉得对未来更加恐惧，害怕以后也会遇到这样的情况，这也让我更加下定决心要尽快把java学好。留给中国队的时间不多了。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8093965.html</dc:identifier>
</item>
<item>
<title>开发一个博客园系统 - JeffD</title>
<link>http://www.cnblogs.com/Jeffding/p/8035312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jeffding/p/8035312.html</guid>
<description>&lt;p&gt;　　最近在学django框架，准备用django写一个博客园的系统，并且在写的过程中也遇到一些问题，实践出真知，对django开发web应用方面也有了进一步的了解。很多操作实现都是以我所认知的技术完成的，可能存在不合理的地方（毕竟实现的方法多种多样），基本完成后会将源码上传到git，也欢迎各位大神指正。&lt;/p&gt;
&lt;p&gt;　　首先，要写未登录主站（index）。这里需要注意文章的分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1165242/201712/1165242-20171213200537816-1713022453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　文章的分类切换，网站本身有定义的文章类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
   type_choices =&lt;span&gt; [
        (&lt;/span&gt;1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OpenStack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;4, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GoLang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要实现主页的分类（分类标签样式要突出）需要使用一个前端与后端都有的id来显示分类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; request.method==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        type_id &lt;/span&gt;= int(kwargs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;if&lt;/span&gt; kwargs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;else&lt;/span&gt;&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;后台都是get传参&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; type_id:
            article_list &lt;/span&gt;= models.Article.objects.filter(article_type_id=type_id).extra(select={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strftime('%%Y-%%m',create_time)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            article_list &lt;/span&gt;= models.Article.objects.all().extra(select={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strftime('%%Y-%%m',create_time)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
        type_choice_list &lt;/span&gt;= models.Article.type_choices&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分类的&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(type_choice_list)#[(1, 'Python'), (2, 'Linux'), (3, 'OpenStack'), (4, 'GoLang')]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后台代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;if&lt;/span&gt; type_id %&lt;span&gt;}
                        &lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;全部&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                    {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
                        &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;全部&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                    {&lt;/span&gt;% endif %&lt;span&gt;}

                    {&lt;/span&gt;% &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; type_choice_list %&lt;span&gt;}
                        {&lt;/span&gt;% &lt;span&gt;if&lt;/span&gt; item.0 == type_id %&lt;span&gt;}
                            &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/all/{{ item.0 }}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ item.1 }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                        {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
                            &lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/all/{{ item.0 }}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ item.1 }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                        {&lt;/span&gt;% endif %&lt;span&gt;}
                    {&lt;/span&gt;% endfor %}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;前端代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　登陆与注册页面&lt;/p&gt;
&lt;p&gt;　　登陆与注册的验证使用form表单功能完成，除此之外我们还需要有一个图片验证码用于认证。&lt;/p&gt;
&lt;p&gt; 　　在前端设置一个图片，图片src属性指向后端（获取图片时向后端发生get请求方式，后端返回的），验证码图片由后端生成图片在上面显示，点击更换我们使用每次点击在src属性后面加一个？，这样url改变了前端向后台发送一个get请求，那么就会获得一个新的验证码图片了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
 &amp;lt;img style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 120px;height: 30px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/check_code/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点击更换&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

        $(function(){
            change_img();
        });
        function change_img() {&lt;/span&gt;//&lt;span&gt;get方式在url上加？刷新图片
            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#change_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
                $(this)[0].src&lt;/span&gt;=$(this)[0].src+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            })
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;前端代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57.5&quot;&gt;&lt;img id=&quot;code_img_closed_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image,ImageDraw,ImageFont,ImageFilter
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; rd_check_code(width=120, height=30, char_length=4, font_file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kumo.ttf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, font_size=28&lt;span&gt;):
    code &lt;/span&gt;=&lt;span&gt; []
    img &lt;/span&gt;= Image.new(mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, size=(width, height), color=(255, 255, 255&lt;span&gt;))
    draw &lt;/span&gt;= ImageDraw.Draw(img, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; rndChar():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        生成随机字母   
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; chr(random.randint(65, 90&lt;span&gt;))
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; rndColor():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        生成随机颜色
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255&lt;span&gt;))
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写文字&lt;/span&gt;
    font =&lt;span&gt; ImageFont.truetype(font_file, font_size)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(char_length):
        char &lt;/span&gt;=&lt;span&gt; rndChar()
        code.append(char)
        h &lt;/span&gt;= random.randint(0, 4&lt;span&gt;)
        draw.text([i &lt;/span&gt;* width / char_length, h], char, font=font, fill=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写干扰点&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(40&lt;span&gt;):
        draw.point([random.randint(0, width), random.randint(0, height)], fill&lt;/span&gt;=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写干扰圆圈&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(40&lt;span&gt;):
        draw.point([random.randint(0, width), random.randint(0, height)], fill&lt;/span&gt;=&lt;span&gt;rndColor())
        x &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
        draw.arc((x, y, x &lt;/span&gt;+ 4, y + 4), 0, 90, fill=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 画干扰线&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        x1 &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y1 &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
        x2 &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y2 &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
 
        draw.line((x1, y1, x2, y2), fill&lt;/span&gt;=&lt;span&gt;rndColor())
 
    img &lt;/span&gt;=&lt;span&gt; img.filter(ImageFilter.EDGE_ENHANCE_MORE)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img,&lt;span&gt;''&lt;/span&gt;.join(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;PIL生成随机码模块&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; check_code(request):
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; io &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BytesIO
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.random_check_code &lt;span&gt;import&lt;/span&gt;&lt;span&gt; rd_check_code
    img,code &lt;/span&gt;=&lt;span&gt; rd_check_code()
    stream &lt;/span&gt;= BytesIO()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开辟一个内存空间，类似于文件句柄&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(stream)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;io空间，&amp;lt;_io.BytesIO object at 0x06D6EAE0&amp;gt;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(img)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;pillow生成的图片对象&lt;/span&gt;
    img.save(stream,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(stream)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stream.getvalue())&lt;span&gt;#&lt;/span&gt;&lt;span&gt;bytes类型的图片信息，返回前端生成图片&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(img)
    request.session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = code&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将生成的随机字符串存到session用于验证&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse(stream.getvalue())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后端返回随机码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　登录后将session信息写入浏览器cookie，可以完成两周免登陆效果。注销我使用的时Ajax，后台需要清理session。这个过程中要注意，Ajax需要向后台发送自己的csrf码，否则后端默认是伪造的跨站请求，不给予服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; $(function () {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.take_off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function () {
            {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                        $(&quot;.take_off&quot;).click(function () {#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;            $.ajaxSetup({#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                data:{csrfmiddlewaretoken:'{{ csrf_token }}'}#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;            });#}&lt;/span&gt;
&lt;span&gt;                $.ajax({
                url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;data:{ 'csrftoken':{{ csrf_token}} },#}&lt;/span&gt;
                data:{csrfmiddlewaretoken:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{ csrf_token }}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                dataType:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                success:function(arg){
                    console.log(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arg.status){
                        location.href&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    }}
            })
            });
       });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Ajax注销&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　注册也有一个地方需要注意，就是图片上传的问题，我使用的是硬解码的方式存放图片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
            with open(os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/imgs/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).name), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file:
                all &lt;/span&gt;= obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).chunks()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拿到整个文件&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; trunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all:
                    file.write(trunk)
                file.close()
            obj.cleaned_data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/imgs/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).name)
            models.UserInfo.objects.create(&lt;/span&gt;**obj.cleaned_data)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;直接在后端进行存储&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这种方法还是比较笨重的解决方法，在创建数据库的时候有一个upload_to字段可以直接指定文件存放路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
avatar = models.ImageField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,upload_to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;static/imgs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;创建数据表直接指定&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　不过这两种方法都不够灵活，不能防止图片名重复的问题，这里有一篇博客对存储路径进行优化的方式。这已经解决了很多一部分命名问题了。http://blog.csdn.net/alxandral_brother/article/details/53415551。&lt;/p&gt;
&lt;p&gt;　　用Ajax完成图片预览功能&lt;/p&gt;
&lt;p&gt;　　首先文件上传的丑陋的接口我们是没有办法修改的（点击上传那个），所以我们使用默认图片遮住这个文件框。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-sm-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: absolute;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/imgs/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    {{ obj.avatar }}&lt;/span&gt;&amp;lt;span&amp;gt;{{ obj.errors.avatar.0 }}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来是关于上传预览的部分，最早我们使用Ajax把前端获取的图片发给后端，后端接收后保存再发送回前端显示预览，但是这样做会导致用户上传了图片但是没有注册成功，那么后端保存的图片信息就是垃圾数据，那么我们必须要进行定期的数据清理工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            {{ obj.avatar }}
        &lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            bindAvartar1();
        });

        function bindAvartar1() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                &lt;/span&gt;//$(this)[0]           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jquery变成DOM对象&lt;/span&gt;
                //$(this)[0].files     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象&lt;/span&gt;
                //$(this)[0].files[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象的某个对象&lt;/span&gt;
                var obj =&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;ajax 发送后台获取头像路径
                &lt;/span&gt;//&lt;span&gt;img src 重新定义新的路径

                var formdata &lt;/span&gt;= new FormData();  //&lt;span&gt;创建一个对象
                formdata.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,obj);
                var xhr &lt;/span&gt;=&lt;span&gt; new XMLHttpRequest();
                xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/register/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                xhr.send(formdata);

                xhr.onreadystatechange &lt;/span&gt;=&lt;span&gt; function () {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState ==4&lt;span&gt;){
                        var file_path &lt;/span&gt;=&lt;span&gt; xhr.responseText;
                        console.log(file_path);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; file_path)
                    }
                };

            })
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Ajax上传预览&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; register(request):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.POST)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.FILES)
        file_obj &lt;/span&gt;= request.FILES.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(file_obj)
        file_path &lt;/span&gt;= os.path.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, file_obj.name)
        with open(file_path, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; chunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_obj.chunks():
                f.write(chunk)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(file_path)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后端保存图片&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　当然，我们还可以使用本地预览的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            {{ obj.avatar }}
        &lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            bindAvartar2();
        });

      

        function bindAvartar2() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;将文件对象上传到浏览器
                &lt;/span&gt;//&lt;span&gt;IE10 以下不支持
                var v &lt;/span&gt;=&lt;span&gt; window.URL.createObjectURL(obj);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v);

                &lt;/span&gt;//&lt;span&gt;不会自动释放内存
                &lt;/span&gt;//&lt;span&gt;当加载完图片后,释放内存
                document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).onload=&lt;span&gt; function () {
                    window.URL.revokeObjectURL(v);
                };
            })
        }





        function bindAvartar3() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                var reader &lt;/span&gt;=&lt;span&gt; new FileReader();
                reader.onload &lt;/span&gt;=&lt;span&gt; function (e) {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,this.result);
                };
                reader.readAsDataURL(obj)
            })
        }

    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;本地上传预览的两种方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　因为用户的浏览器版本限制，我们可以采用多重手段给不同的用户使用预览功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function(){
           bindAvatar();
        });

        function bindAvatar(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.URL.createObjectURL){
                bindAvatar2();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.FileReader){
                bindAvatar3()
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                bindAvatar1();
            }
        }



        function bindAvatar1() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                &lt;/span&gt;//$(this)[0]           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jquery变成DOM对象&lt;/span&gt;
                //$(this)[0].files     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象&lt;/span&gt;
                //$(this)[0].files[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象的某个对象&lt;/span&gt;
                var obj =&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;ajax 发送后台获取头像路径
                &lt;/span&gt;//&lt;span&gt;img src 重新定义新的路径

                var formdata &lt;/span&gt;= new FormData();  //&lt;span&gt;创建一个对象
                formdata.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,obj);
                var xhr &lt;/span&gt;=&lt;span&gt; new XMLHttpRequest();
                xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/register/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                xhr.send(formdata);

                xhr.onreadystatechange &lt;/span&gt;=&lt;span&gt; function () {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState ==4&lt;span&gt;){
                        var file_path &lt;/span&gt;=&lt;span&gt; xhr.responseText;
{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                        console.log(file_path);#}&lt;/span&gt;
                        $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; file_path)
                    }
                };
            })
        }


        function bindAvatar2() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;将文件对象上传到浏览器
                &lt;/span&gt;//&lt;span&gt;IE10 以下不支持


                &lt;/span&gt;//&lt;span&gt;不会自动释放内存
                &lt;/span&gt;//&lt;span&gt;当加载完图片后,释放内存

                document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).onload=&lt;span&gt; function () {
                    window.URL.revokeObjectURL(v);
                };

                var v &lt;/span&gt;=&lt;span&gt; window.URL.createObjectURL(obj);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v);
            })
        }





        function bindAvatar3() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                var reader &lt;/span&gt;=&lt;span&gt; new FileReader();
                reader.onload &lt;/span&gt;=&lt;span&gt; function (e) {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,this.result);
                };
                reader.readAsDataURL(obj)
            })
        }



    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;一步到位，大家都能用&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　主页部分，主页部分的主要操作就是各项分类，你可以将标签，随笔和时间分开写，其实我一开始也是这么做的，但实际上重复代码有很多，这些按分类展现的页面，唯一的不同就是根据不同类型分类的文章也不同。根据这一点，我们可以将分类写到一个视图函数里面，这样代码更为精简。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^(?P&amp;lt;site&amp;gt;\w+)/(?P&amp;lt;key&amp;gt;((tag)|(date)|(category)))/(?P&amp;lt;val&amp;gt;\w+-*\w*)/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, views.filter)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而分类的过程中主要涉及的就是ORM的操作，并且也没有十分难的数据表操作。&lt;/p&gt;
&lt;p&gt;　　文章页&lt;/p&gt;
&lt;p&gt;　　文章页的部分主要是点赞与评论部分，先说一下评论部分，评论可以做成缩进的多级评论，但是需要将数据库获得的数据进行数据结构改造，快速索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
    msg_list =&lt;span&gt; [
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;写的太好了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你说得对&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;顶楼上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你眼瞎吗&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:5,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我看是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:6,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;鸡毛&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:7,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你是没呀&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:5&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:8,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;惺惺惜惺惺想寻&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3&lt;span&gt;},
    ]
    msg_list_dict &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; msg_list:
        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每一行加一个空列表child，存放子数据&lt;/span&gt;
        msg_list_dict[item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]] = item&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每个行加一个索引的序列改造成[1;{},2:{}]&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; #### msg_list_dict用于查找,msg_list&lt;/span&gt;
    result =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; msg_list:
        pid &lt;/span&gt;= item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果有父id&lt;/span&gt;
            msg_list_dict[pid][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].append(item)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加到刚才的child列表中&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            result.append(item)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列表里都是第一级的评论&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ########################### 打印 ###################&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; utils.comment &lt;span&gt;import&lt;/span&gt;&lt;span&gt; comment_tree
    comment_str &lt;/span&gt;= comment_tree(result)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义把所有的评论一级一级递归的拨开，解析成HTML格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;多级评论&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; comment_tree(comment_list):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    :param result: [ {id,:child:[xxx]},{}]
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    comment_str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='comment'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; comment_list:
        tpl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='content'&amp;gt;%s&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        comment_str &lt;/span&gt;+=&lt;span&gt; tpl
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;            child_str = comment_tree(row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            comment_str &lt;/span&gt;+=&lt;span&gt; child_str
    comment_str &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; comment_str
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;util.comment&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　个人觉得也可以写成博客园的@的方式，@的回复可跨表取到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;for&lt;/span&gt; re &lt;span&gt;in&lt;/span&gt; reply %&lt;span&gt;}
    &lt;/span&gt;&amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color: #e0e0e0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ re.comment__create_time }}&amp;amp;nbsp [发言人]{{ re.comment__user__username }}&amp;lt;/div&amp;gt;&lt;span&gt;
    {&lt;/span&gt;% &lt;span&gt;if&lt;/span&gt; re.comment__reply__user__username %&lt;span&gt;}
    &lt;/span&gt;&amp;lt;p&amp;gt;@{{ re.comment__reply__user__username }}&amp;lt;/p&amp;gt;&lt;span&gt;
        {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
        &lt;/span&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;span&gt;
    {&lt;/span&gt;% endif %&lt;span&gt;}
&lt;/span&gt;&amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 100%;border-bottom: #00b3ee 1px solid ;margin-top: 5px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;  {{ re.comment__content }} &amp;lt;/div&amp;gt;&lt;span&gt;

{&lt;/span&gt;% endfor %}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;数据可以后端跨表取&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　点赞要给赞绑定点击事件，定义1为赞，0为踩，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;updown(this,{{ content.nid }},1);//传给绑定事件触发的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        function updown(ths,nid,val){
            $.ajax({
                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/updown.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                data:{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:val,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:nid,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csrfmiddlewaretoken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{ csrf_token }}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                dataType:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                success:function(arg){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arg.status){
                        &lt;/span&gt;//&lt;span&gt; 点赞成功刷新页面
                        location.reload();
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        alert(arg.msg)
                    }
                }
            })
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;绑定事件&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　后台管理可以使用xadmin来做，当然也可以写一个后台管理，我这个后台管理暂时使用管理员管理界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1165242/201712/1165242-20171223220008475-681048939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/Jeffding/p/8093483.html&quot;&gt;xadmin使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这两天把后台搭起来再把源码上传。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>JeffD</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jeffding/p/8035312.html</dc:identifier>
</item>
<item>
<title>来腾讯云开发者实验室 学习.NET Core 2.0 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8094409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8094409.html</guid>
<description>&lt;p&gt;腾讯云开发者实验室为开发者提供了一个零门槛的在线实验平台,开发者实验室提供的能力：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;零门槛扫码即可免费领取实验机器，支持使用自有机器参与，实验完成后支持保留实验成果；&lt;/li&gt;
&lt;li&gt;在线 WEB IDE 支持 shell 命令操作，支持机器文件操作，支持文件实时编辑，结合交互式教学体验提供了良好的在线实验体验；&lt;/li&gt;
&lt;li&gt;基于云的真实标准的实验环境，确保实验的普适性；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体内容可以看视频：&lt;/p&gt;

&lt;p&gt;.NET Core 的最重要的一个特性就是跨平台，Windows 很多同学都会，学习 Linux 已经成为一个.NET 程序员的必备技能，因此我和腾讯云同事合作在腾讯云上提供了 1 个 CentOS 7.2 环境下的.net core 2.0实验教程,结合腾讯云上其他 Linux 的教程，这就是一个非常好的实现在线学习环境。&lt;/p&gt;
&lt;p&gt;腾讯云在线实验室目前有 30 个教程，具体参看 &lt;a href=&quot;https://www.qcloud.com/developer/labs/list&quot;&gt;实验列表&lt;/a&gt; 。其中有 3个实验是.NET Core 和 Mono 相关的, 具体访问 &lt;a title=&quot;https://cloud.tencent.com/developer/labs/gallery?tagId=11&quot; href=&quot;https://cloud.tencent.com/developer/labs/gallery?tagId=11&quot;&gt;https://cloud.tencent.com/developer/labs/gallery?tagId=11&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从 linux 基础开始到.net core 的入门的系列实验，动手实验的效果要比纯粹的看文章的效果要好很多&lt;/strong&gt;，这里给大家整理一下在腾讯云学习的系列实验推荐。&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10000&quot;&gt;Linux 基础入门&lt;/a&gt;：实验介绍基本的 Linux 操作和命令，如目录切换、文件操作、进程查看、端口查看、资源占用情况等等，实现从零开始操作 Linux 机器。具体可以参考我整理的一个文档 &lt;a href=&quot;https://github.com/geffzhang/opendotnet&quot;&gt;《.NET 跨平台(CentOS ) 相关文档整理》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2、 &lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10100&quot;&gt;搭建 .NET Core 开发环境&lt;/a&gt;：本实验将带您学习搭建 .NET Core 和 Jexus 组成的 .NET Core Web 开发环境。参考文章： &lt;a href=&quot;https://www.qcloud.com/community/article/563486&quot;&gt;在 CentOS 上使用 Jexus 托管运行 ZKEACMS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、 &lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10101&quot;&gt;搭建 Mono 开发环境&lt;/a&gt; ：本实验带您搭建 Mono 开发环境， 体验在 Linux 上写传统.NET 应用的环境，具体参考： &lt;a href=&quot;https://www.qcloud.com/community/article/829845&quot;&gt;Mono 新突破：CentOS 7.2 下安装 Mono 5.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、 &lt;a href=&quot;https://cloud.tencent.com/developer/labs/lab/10347&quot; target=&quot;_blank&quot;&gt;搭建.NET Core 2.0环境&lt;/a&gt;: 学习如何在CentOS 7.2 下搭建 .NET Core 2和 Jexus 组成的 .NET Core Web 开发环境&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 12:59:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8094409.html</dc:identifier>
</item>
<item>
<title>数据库设计 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8093887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8093887.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍数据库设计的相关知识&lt;/p&gt;

&lt;h3&gt;设计范式&lt;/h3&gt;
&lt;p&gt;　　数据库设计共有三大范式：&lt;/p&gt;
&lt;p&gt;　　第一范式：无重复的列&lt;/p&gt;
&lt;p&gt;　　第二范式：属性完全依赖于主键&lt;/p&gt;
&lt;p&gt;　　第三范式：属性不能依赖于主属性&lt;/p&gt;
&lt;p&gt;　　下面将分别对这三个范式进行详细介绍&lt;/p&gt;

&lt;h3&gt;第一范式&lt;/h3&gt;
&lt;p&gt;　　数据库表中的每一列都是不可分割的基本数据项，同一列中不能有多个值。具体而言，有以下两条要求&lt;/p&gt;
&lt;p&gt;　　1、每一列属性都是不可再分的，确保每一列的原子性&lt;/p&gt;
&lt;p&gt;　　2、两列的属性相近或相似或一样，尽量合并属性一样的列， 确保不产生冗余数据&lt;/p&gt;
&lt;p&gt;　　以考勤表设计为例，考勤表用来记录每天学生的考勤情况&lt;/p&gt;
&lt;p&gt;　　最简单的情况是，每一天都建立一张表。字段是每个学生的姓名，列值表示是否签到。这样，可以很方便的存储当天的考勤情况。但是，这也导致了每天都需要在数据库里新建一张考勤表。而且，这种做法违反了第一范式，这张考勤表的字段的属性含义都是一样的，都是记录学员的考勤情况。因此，这些字段是需要合并的&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223165205631-1871162147.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　更优化的设计是，第一字段是学生姓名，第二字段是0101表示`1月1日，第三字段是0102表示1月2日，以此类推。这种做法，不再需要设计那么多表，将学生的姓名列合并成了一个姓名列。但是，同样它没有遵循第一范式，1年365天， 代码除了学生姓名列外，还需要设置365个字段。而且，这些列的含义都是一样的，记录当天的考勤。因此，这些字段也是需要合并的&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223170531100-1437466428.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　下面是优化的情况，把所有的日期合并成一个日期字段，新增一个考勤状态字段，如下所示，完全遵循了第一范式，没有重复的列，且每一列都是可拆分的。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223170726521-924793622.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　总而言之，用第一范式设计数据库时，就是分解数据，并将属性相似的列合并&lt;/p&gt;

&lt;h3&gt;第二范式&lt;/h3&gt;
&lt;p&gt;　　第二范式需要遵循以下要求：&lt;/p&gt;
&lt;p&gt;　　1、一个表表必须有一个主键&lt;/p&gt;
&lt;p&gt;　　2、没有包含在主键中的列必须完全依赖于主键，而不能只 依赖于主键的一部分&lt;/p&gt;
&lt;p&gt;　　以下面购物车表为例，用户ID和商品ID构成了商品的主键，数量列依赖于用户购买商品的数量，单价和商品名称只依赖于商品ID。因此，这张表不满足第二范式&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223185750600-8272923.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　优化后，修改如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223185905068-1839455476.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;第三范式&lt;/h3&gt;
&lt;p&gt;　　非主键列必须直接依赖于主键，不能存在传递依赖。第三范式，相较于第二范式而言，强调的是直接依赖，而不能是传递依赖&lt;/p&gt;
&lt;p&gt;　　关于传递依赖，以下面的中奖信息表为例，中奖金额依赖于中奖等级，而中将等级及依赖于用户ID，这就是传递依赖&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223190402115-1302523537.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　要遵循第三范式，就要消除传递依赖&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223190441053-2024254094.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;新闻系统&lt;/h3&gt;
&lt;p&gt;　　下面尝试利用三个范式，来设计新闻系统数据库。包括以下要点：&lt;/p&gt;
&lt;p&gt;　　1、用户名、密码、是否是管理员&lt;/p&gt;
&lt;p&gt;　　2、新闻标题、新闻内容、作者、新闻时间、是否上线&lt;/p&gt;
&lt;p&gt;　　3、评论人、评论内容、评论时间、评论源&lt;/p&gt;
&lt;p&gt;　　分别对应用户表、新闻表和评论表&lt;/p&gt;
&lt;p&gt;　　一般来说，用户名长度不超过20个字符，密码长度不超过20个字符，新闻标题长度不超过30个字符，新闻内容长度不超过5000个字符，评论内容长度不超过300个字符&lt;/p&gt;
&lt;p&gt;　　用户表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223192903975-779039949.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　新闻表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223193143631-540026917.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　评论表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223193224443-1927512479.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　在设计数据库时，只需满足以上三个范式，就可以设计既合理又满足需求的数据库&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 11:36:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8093887.html</dc:identifier>
</item>
<item>
<title>支付宝当面付扫码支付功能详解 - 孤独是1态度</title>
<link>http://www.cnblogs.com/gudu1/p/8094197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gudu1/p/8094197.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言： 上篇呢主要是针对微信验证登录做了讲解，当然微信也是提供了很多的接口来供开发者进行调用，同样，微信也有支付，相信小伙伴们学习了上篇的登录之后，已经能够融汇贯通，做出微信的支付功能。那么本篇呢就讲解一下支付宝的支付功能，同样的，通过这一个例子，你就能使用支付宝其它的功能，还是那句老话，就当做是一个敲门砖吧，好了，下面就开始吧。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;本篇为原创，转载请标出处&lt;/span&gt;：&lt;a href=&quot;http://www.cnblogs.com/gudu1/p/8094197.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/gudu1/p/8094197.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　微信有测试公众号测试，那么支付宝呢？他也有，不过名字是叫做支付宝沙箱环境，地址：&lt;a href=&quot;https://sandbox.alipaydev.com/sms/receive.htm&quot; target=&quot;_blank&quot;&gt;https://sandbox.alipaydev.com/sms/receive.htm&lt;/a&gt; ，扫码登陆之后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037461/201712/1037461-20171223171239615-326288555.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; APPID，支付宝网关，以及应用网关 这些呢是固定不变的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&amp;gt;&amp;gt;&lt;/span&gt; 我们已经知道微信使用的是 SHA-1 加密，那么支付宝使用的就是RSA 和 RSA2 加密，当然了，支付宝推荐使用RSA2加密，两个的区别就是RSA2 是2048 位，RSA 是1024位，所以RSA2加密更好，我们就使用它就好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 授权回调地址就是用户扫码进行支付之后，支付宝服务器回调我们程序接口的地址，规则呢跟微信的是一样的，这里不多讲了，不明白的请看一下上篇微信验证登录的讲解 &lt;a href=&quot;http://www.cnblogs.com/gudu1/p/8087130.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/gudu1/p/8087130.html&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 接下来的就配置一下我们的密匙，使用哪个加密方式就配置哪个就好了，支付宝很周到，给我们提供了生成密匙的工具，下载位置：&lt;a href=&quot;https://docs.open.alipay.com/291/105971&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/291/105971&lt;/a&gt; ，这个也是支付宝的官方文档，具体怎么使用，里面都很详细，这里就不占篇幅了，然后生成之后，就直接 copy 进去配置就好了，很简单的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　下面还是老样子，先贴出代码，然后讲解代码中的一些点，支付宝也提供了Java 、PHP、.NET  版本的支付代码，这点是非常到位的，所以我们只是站在巨人的肩膀上，前人栽树，后人乘凉，下载地址：&lt;a href=&quot;https://docs.open.alipay.com/194/105201/&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/194/105201/&lt;/a&gt; ，下载我们都会，下载之后把代码copy 出来，需要使用哪个功能就copy 哪个，因为我这里使用的支付宝生成二维码预下单的功能，然后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Controller &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/order/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {
 @RequestMapping(&lt;/span&gt;&quot;pay.do&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ServerResponse&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; pay(HttpSession session, Long orderNo, HttpServletRequest request) {
        Integer userId &lt;/span&gt;=&lt;span&gt; ((User) session.getAttribute(Const.CURRENT_USER)).getId();
        String path &lt;/span&gt;= request.getSession().getServletContext().getRealPath(PropertiesUtil.getProperty(&quot;upload_image_path&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orderNo == &lt;span&gt;null&lt;/span&gt; || orderNo == 0L&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;支付订单不能为空&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderService.pay(userId, orderNo, path);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　&lt;span&gt;Service 的pay 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service(&quot;iOrderService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IOrderService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(OrderServiceImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支付宝当面付2.0服务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; AlipayTradeService tradeService;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数
         *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Configs.init(&lt;/span&gt;&quot;zfbinfo.properties&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 使用Configs提供的默认参数
         *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        tradeService &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlipayTradeServiceImpl.ClientBuilder().build();
    }
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 支付宝预创建支付订单，生成支付的二维码用户用户扫码支付
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; userId  用户ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; orderNo 订单号
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; path    本地上传图片地址
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Transactional
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerResponse pay(Integer userId, Long orderNo, String path) {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; mapResult =&lt;span&gt; Maps.newHashMap();
        Order order &lt;/span&gt;=&lt;span&gt; orderMapper.selectOrderByOrderNo(orderNo);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (order == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createBySuccessMessage(&quot;该订单不存在&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需保证商户系统端不能重复，建议通过数据库sequence生成，&lt;/span&gt;
        String outTradeNo =&lt;span&gt; order.getOrderNo().toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费”&lt;/span&gt;
        String subject = &quot;Happy_mmall 扫码付款&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 订单总金额，单位为元，不能超过1亿元
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】&lt;/span&gt;
        String totalAmount =&lt;span&gt; order.getPayment().toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】&lt;/span&gt;
        String undiscountableAmount = &quot;0&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID&lt;/span&gt;
        String sellerId = &quot;&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订单描述，可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;&lt;/span&gt;
        String body = &lt;span&gt;new&lt;/span&gt; StringBuffer().append(&quot;订单:&quot;).append(order.getOrderNo()).append(&quot;,共花费&quot;).append(order.getPayment()).append(&quot;元&quot;&lt;span&gt;).toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商户操作员编号，添加此参数可以为商户操作员做销售统计&lt;/span&gt;
        String operatorId = &quot;test_operator_id&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持&lt;/span&gt;
        String storeId = &quot;test_store_id&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持&lt;/span&gt;
        ExtendParams extendParams = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtendParams();
        extendParams.setSysServiceProviderId(&lt;/span&gt;&quot;2088100200300400500&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支付超时，定义为120分钟&lt;/span&gt;
        String timeoutExpress = &quot;120m&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商品明细列表，需填写购买商品详细信息，&lt;/span&gt;
        List&amp;lt;GoodsDetail&amp;gt; goodsDetailList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;GoodsDetail&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加 用户 预支付的订单中的商品&lt;/span&gt;
        List&amp;lt;OrderItem&amp;gt; orderItemList =&lt;span&gt; orderItemMapper.selectListByUserIdAndOrderNo(orderNo, userId);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (OrderItem orderItem : orderItemList) {
            GoodsDetail goods1 &lt;/span&gt;=&lt;span&gt; GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(),
                    BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(), &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Double(100&lt;span&gt;)).longValue(),
                    orderItem.getQuantity());
            goodsDetailList.add(goods1);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建扫码支付请求builder，设置请求参数&lt;/span&gt;
        AlipayTradePrecreateRequestBuilder builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlipayTradePrecreateRequestBuilder()
                .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo)
                .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)
                .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)
                .setTimeoutExpress(timeoutExpress)
                .setNotifyUrl(PropertiesUtil.getProperty(&lt;/span&gt;&quot;alipay.callback.url&quot;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置&lt;/span&gt;
&lt;span&gt;                .setGoodsDetailList(goodsDetailList);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建预支付订单对象&lt;/span&gt;
        AlipayF2FPrecreateResult result =&lt;span&gt; tradeService.tradePrecreate(builder);
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (result.getTradeStatus()) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SUCCESS:
                logger.info(&lt;/span&gt;&quot;支付宝预下单成功: )&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取响应 Response&lt;/span&gt;
                AlipayTradePrecreateResponse response =&lt;span&gt; result.getResponse();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  简单打印一下日志&lt;/span&gt;
&lt;span&gt;                dumpResponse(response);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建本地上传图片的文件夹，不存在则创建&lt;/span&gt;
                File folder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(path);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;folder.exists()) {
                    folder.setWritable(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    folder.mkdirs();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要修改为运行机器上的路径,&lt;/span&gt;
                String filePath = String.format(path + &quot;/qr-%s.png&quot;&lt;span&gt;,
                        response.getOutTradeNo());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; %s 是一种占位符，即后面的response.getOutTradeNo() ，只是生成额随机字符串，防止重名&lt;/span&gt;
                String fileName = String.format(&quot;/qr-%s.png&quot;&lt;span&gt;, response.getOutTradeNo());

                logger.info(&lt;/span&gt;&quot;filePath:&quot; +&lt;span&gt; filePath);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传到本地服务器&lt;/span&gt;
                ZxingUtils.getQRCodeImge(response.getQrCode(), 256&lt;span&gt;, filePath);
                File targetFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(path, fileName);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传图片到FTP服务器，上传FTP完毕之后，删除本地存储的图片&lt;/span&gt;
&lt;span&gt;                    FTPUtil.upload(Lists.newArrayList(targetFile));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    logger.error(&lt;/span&gt;&quot;上传二维码失败&quot;&lt;span&gt;, e);
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刚刚上传到FTP的图片地址URL&lt;/span&gt;
                String qrPathUrl =&lt;span&gt; PathUtil.getFTPImgPath(targetFile.getName());
                mapResult.put(&lt;/span&gt;&quot;qrPath&quot;&lt;span&gt;, qrPathUrl);
                mapResult.put(&lt;/span&gt;&quot;orderNo&quot;&lt;span&gt;, orderNo.toString());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(mapResult);
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FAILED:
                logger.error(&lt;/span&gt;&quot;支付宝预下单失败!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;支付宝预下单失败!!!&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; UNKNOWN:
                logger.error(&lt;/span&gt;&quot;系统异常，预下单状态未知!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;系统异常，预下单状态未知!!!&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                logger.error(&lt;/span&gt;&quot;不支持的交易状态，交易返回异常!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;不支持的交易状态，交易返回异常!!!&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 在此之前呢不要忘记添加支付宝的集成依赖jar包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 为了方便理解，代码中的每一步都添加了注释，代码比较多，但是大多数的代码都是直接copy支付宝 提供的Demo，然后根据我们自己的业务需求修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 由于篇幅问题，请注意静态代码块中的代码，会加载一个配置文件，这个配置文件支付宝同样有提供，我们只要修改一下其中的参数值，APPID、PID（商户UID）、以及加密的公钥和私钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 我们程序支付整体的思路是这样：用户确认下单后，点击支付，然后会调用我们pay.do 这个接口，然后我们的程序在向支付宝服务器发送请求之前会添加一些参数，就是商品的订单号、收款平台信息、以及购买商品需要支付的总价格，需要修改的一处是 创建AlipayTradePrecreateRequestBuilder对象的时候，把call_back的URL修改成我们自己程序的接口，然后程序就向支付宝发送消息，因为这里支付宝集成做的特别好，只需要创建一个预支付对象，把需要的参数传进去，就可以发起预支付请求，返回二维码字节流，我们把二维码进行保存，然后展示给用户，进行扫码支付，用户扫码之后，不管是支付成功或者支付失败都会回调我们的call_back中配置的URL，进行处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 接下来就是我们的 call_back ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/order/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {
    @RequestMapping(&lt;/span&gt;&quot;alipay_callback.do&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ServerResponse callBack(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AlipayApiException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出支付宝回调携带的所有参数并进行转换，数组转换为字符串&lt;/span&gt;
        Map&amp;lt;String, String[]&amp;gt; tempParams =&lt;span&gt; request.getParameterMap();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  参数存放 Map&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; requestParams =&lt;span&gt; Maps.newHashMap();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;String&amp;gt; iterator =&lt;span&gt; tempParams.keySet().iterator(); iterator.hasNext(); ) {
            String key &lt;/span&gt;=&lt;span&gt; iterator.next();
            String[] strs &lt;/span&gt;=&lt;span&gt; tempParams.get(key);
            String str &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里如果数组的长度是1，说明只有一个，直接赋值就好，如果超过一个，后面加一个逗号来隔离&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; strs.length; i++&lt;span&gt;) {
                str &lt;/span&gt;= strs.length - 1 == i ? str + strs[i] : str + strs[i] + &quot;,&quot;&lt;span&gt;;
            }
            requestParams.put(key, str);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去除sign_type&lt;/span&gt;
        requestParams.remove(&quot;sign_type&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证签名&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; result = AlipaySignature.rsaCheckV2(requestParams, Configs.getPublicKey(), &quot;utf-8&quot;&lt;span&gt;, Configs.getSignType());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;非法请求,再恶意请求我就报警找网警了&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AlipayApiException e) {
            logger.error(&lt;/span&gt;&quot;支付宝回调验证异常&quot;&lt;span&gt;, e);
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Service 方法进行处理&lt;/span&gt;
        ServerResponse serverResponse =&lt;span&gt; orderService.alipayCallBack(requestParams);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;serverResponse.isSuccess()) {
            logger.error(&lt;/span&gt;&quot;OrderController.callBack()&quot;,&quot;数据操作失败&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(Const.AlipayCallback.RESPONSE_FAILED);
        }
        logger.info(&lt;/span&gt;&quot;支付宝支付回调完成，没有异常&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(Const.AlipayCallback.RESPONSE_SUCCESS);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;这个支付宝回调URL是这样：http://smyang.s1.natapp.cc/order/alipay_callback.do，对应我们的Controller 的RequestMapping中的路由，代码中都有添加注释，还是很清晰的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;支付宝的验证签名的规则是怎样的呢？在通知返回的参数中除了sign_type和sign，其余的都是待验签的参数，详细请看 &lt;a href=&quot;https://docs.open.alipay.com/194/103296/&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/194/103296/&lt;/a&gt; ，但是这里只remove 掉了sign_type，通过查看源码发现，在支付宝集成代码中需要获取一下sign，然后它才remove 掉了sign，所以这里我们只需要remove掉sign_type就好，而且是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;在 rsaCheckV2() 方法中我们加入的参数sign_type，指定了使用哪种加密方式来验签，如果通过就确定这个支付过程是安全的，同时 Configs 这个类也是支付宝给我们提供的，很到位的吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 最后调用了Service方法进行我们的代码逻辑，比如：更新数据库中用户的支付状态，这个就是我们自己的业务需求了，在我们的业务代码中主要是通过支付宝回调参数中的 tradeStatus 这个字段来判断用户是否支付成功，具体的tradeStatus的状态，可以自行查看支付宝官方文档。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，支付宝不止这一种支付方式，另外还有好多，可以自行去查看，官方文档才是我们最好的老师。好了，到这里就先结束了，后续如果有不足的地方再另行修改。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 11:30:00 +0000</pubDate>
<dc:creator>孤独是1态度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gudu1/p/8094197.html</dc:identifier>
</item>
<item>
<title>【Win 10 应用开发】MIDI 音乐合成——音符消息篇 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8085408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8085408.html</guid>
<description>&lt;p&gt;在上一篇中，老周介绍了一些乐理知识，有了那些常识后，进行 MIDI 编程就简单得多了。尽管微软已经把 API 封装好，用起来也很简单，但是，如果你没有相应的音乐知识基础，你是无法进行 MIDI 编程的。&lt;/p&gt;
&lt;p&gt;这一篇老周将给你讲述一下如何让你的声卡播放一个音符，这会包含两条消息，而且这两条消息是很常用的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Note On：让 MIDI 设备（如果没有专业设备，那就是你的声卡）发出某个音符的声音，比如，发出中音 3 的声音。注意啊，Note on 一旦发送，设备会一直播放这个声音，要想停止播放一个音符，你就要用到下面这条消息，它们是天生的一对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Note Off：关闭某个音符，即停止播放某个音符。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;咱们先来了解三个很重要的类，跟 MIDI 设备通信相关的 API 都在 Windows.Devices.Midi 命名空间下，封装好的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、MidiInPort：用来从 MIDI 输入设备接收消息，所以它公开了一个 MessageReceived 事件，只要 MIDI 输入设备发送了消息，就会引发这个事件，这时候你可以处理这个事件，把收到的消息再传到声卡上进行播放。MIDI 输入设备一般是 MIDI 键盘，估计大部分人用不上这个类，因为一般人不会购买 MIDI 键盘。真想买个好用的，起码是 88 键的，价格还是不低的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、MidiOutPort：连接 MIDI 输出设备，可以播放 MIDI 音乐。如果没有专业的 MIDI 音响，就可以连到你的声卡上，内置外置都可以，市面上有外置的 MIDI 声卡卖，当然了，想省钱的话，你是买不到好音色的，要是你不在乎音色的话，那无所谓。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、MidiSynthesizer：这个类非常好使，它其实类似于 MidiOutPort 类，但它可以自动选择默认的设备（当然也可选择设备）。这个类是专门针对 MIDI 合成而设计的，尽管它与 MidiOutPort 相似，但侧重点不同。MidiOutPort 侧重于与 MIDI 设备的通信，而 MidiSynthesizer 类是侧重于合成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们在进行电子音乐合成的时候，只需要使用 MidiSynthesizer 类即可，它没有构造函数，可以调用 CreateAsync 静态方法来获取实例。对于普通设备而言，我们调用无参数的重载版本就行了，应用程序会默认选择声卡作为输出设备。然后，我们尽管发送 MIDI 消息就OK。当不再使用 MidiSynthesizer 实例时，应该把它 Dispose 掉，以释放资源占用。&lt;/p&gt;
&lt;p&gt;是不是很简单呢，一切都是封装好的，所以说，你只要有一定的乐理基础就可以轻松玩耍这些 API。据说，这个 MidiSynthesizer 类还包含了罗兰公司（Roland）的通用音色库。&lt;/p&gt;
&lt;p&gt;当然了，这只能是通用的 128 种乐器的声音，不包含各种演奏技巧（如揉弦、波音、颤音等）。其目的是尽可能地兼容各类声卡，包括很烂的声卡，虽然比较普通，不过嘛，音色听着还是可以的，只是少了点感觉。不过也是，电声毕竟是虚假的乐音，而不是自然音，就算是专业级别的音源，其实听着也不会太有乐感的。所以嘛，真想感受音乐之美，还是买个真实的乐器自己去演奏。老周小时候喜欢口琴和笛子，上初中的时候，学了一点电子琴、口风琴和扬琴，不过只是学了一点点而已。上高中的三年基本没碰过乐器。大学的时候，在学生会里面鬼混，所以经常可以拿乐队的吉他拨两下。&lt;/p&gt;
&lt;p&gt;后来，像洞箫、巴乌、葫芦丝、陶埙、陶笛等都学过。想学学古琴，但是买一把好琴比较贵，就没有去学了。吹奏类乐器一般比较便宜，至少像老周这种穷人还能买得起，因此老周家里放的乐器，多数是吹奏类的。击打类的有一对小铜鼓，在路边捡的。&lt;/p&gt;

&lt;p&gt;好，不扯了，咱们说正题。本篇的重点是学会两条 MIDI 消息，对，就是上面说的 Note on 和 Note off。不管是 on 还是 off，这两条音符消息的格式是一样的，都是包含三个字节。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个字节是 【状态码 + 通道编号】，这个可能你不太理解，没事，老周待会儿再解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个字节是音符，对，就是上一篇中，简谱上面的 1234567，唱出来就是 dol re mi fa sol la xi，用一个字节表示，从 0 - 127，共128 个音符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个字节是音速，值也是从 0 到 127。这个音速其实你感觉不到什么，发送到声卡上的效果就是音量。值越小声音越小，如果是 0 就等于静音了，127 时声音最大。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;好，下面逐个解释两下。&lt;/p&gt;
&lt;p&gt;首先，状态码，在前一篇中，老周简单地说了一下 MIDI 文件的结构，一个 MIDI 事件是由 delta-time 和事件主体组成。而一个事件的开头都有一个标志字节。在MIDI文件中， Note on 和 Note off 都是一个事件；而在实时通信中，可认为是一条 MIDI 消息，其实结构是一样的。&lt;/p&gt;
&lt;p&gt;不管是Note on 和 Note off ，还是其他通道消息，其第一个字节是由两部分信息组成的。我们知道，一个字节有 8 位，从右边起，1 - 4位表示通道编号，所以，MIDI 音乐有 16 个通道。为什么是 16 个通道呢，不是刚说了吗，只有 4 位二进制位表示通道编号，二进制 1111 就是 15，所以，通道的有效编号是 0 - 15，共16个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：轨道与通道不同。轨道地用于 MIDI 文件的，可以是单轨，可以是多轨，轨道只是方便存储，也方便人类查看，但 MIDI 设置并不认轨道，只认识标准的 16 个通道。故 MIDI 消息只有通道的概念。另外，还要注意，第 10 个通道（编号 9 ）是打击乐专用通道，在 GM 2 标准中，增加了一个，即第 10、11 通道可用于打击乐（编号 9、10）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第 5 到 8 位表示状态码，或者说事件标志，总之，用来标识某个指令。Note Off 的标志是 1000，换算为十六进制就是 0x8 ；Note On 的标志是 1001，换算为十六进制就是 0x9。&lt;/p&gt;
&lt;p&gt;假设，要向第四个通道发送一条 Note on 消息。第四个通道的编号是 3，换算为二进制就是 0011，Note on 的标志为 1001，所以，组合起来，第一个字节就是 1001 0011，换算为十六进制就是 0x93。再比如，要向第一个通道发送一条消息，第一通道的编号是0，即 0000，Note on 的标志是 1001，组合起来的字节就是 1001 0000，换算为十六进制就是 0x90。&lt;/p&gt;
&lt;p&gt;如果要向第二个通道发送一条 Note off 消息。第二个通道的编号是 1，即 0001，Note off 的标志为 1000，组合起来的字节就是 0x81。&lt;/p&gt;

&lt;p&gt;音符消息的第二个字节是音符，值从 0 - 127，共128个。虽然有 128 个音符，但实际上你只要记住一个值就行了—— 60，它表示的是中音 1 。128 / 12，余数为 8 ，凑不成一个 12，所以，中音 1 就位于 120 / 2 = 60 处。为什么音符是 12 个一组呢？上一篇中老周为啥要介绍“十二平均律”，就是有用的，MIDI 的音符排序是遵守十二平均律的，所以每 12 个音符构成一个“八度”。&lt;/p&gt;
&lt;p&gt;于是这一来，这里头就有十来个八度了，其实我们大多数歌曲根本用不上，很多情况下，只用到三个八度：低音区、中音区、高音区。所以，你只需要记住中音 1 的编号是 60 就好办了。你看啊，中音 1 是 60，那么，低音 1 就是 60 - 12 = 48，高音 1 就是 60 + 12 = 72，倍高音 1 就是 60 + 12*2 = 84，倍低音 1 就是 60 - 12*2 = 36。&lt;/p&gt;
&lt;p&gt;下面老周给你一张表，用以参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223171610287-1070361616.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;音符消息的第三个字节是音速，值从 0 - 127，这个所谓的音速，发送到设备后实际表现出来的效果是音量，127时音量最大，如果是0就无声了。如果我们向 MIDI 设备发送一条音速 = 0 的 Note on 消息，它的结果等同于 Note off 消息。说白了就是，音速为 0 的 note on 消息等同于 note off 消息，结果都是停止播放音符。&lt;/p&gt;

&lt;p&gt;举几个例子，如果要让通道0发出中音 1 的声音，首先，note on 的标志是 0x9，通道为0，合起来第一个字节是 0x90；第二个字节表示音符，中音1是60，即 0x3C； 第三个字节是音速，我们用最大值127，即 0x7F。所以这条 note on 消息就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x90&lt;/span&gt;  &lt;span&gt;0x3C&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要是想停止上面的音符，就发送：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x80&lt;/span&gt;  &lt;span&gt;0x3C&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 Note Off 消息是停止音符的，所以音速值可以随便，这里我还是用 127 吧。&lt;/p&gt;
&lt;p&gt;再比如，向通道14发送一条播放中音 5 的消息。Note On 的标志是 0x9，通道 14 是 1110，即 0xE；中音 5 是 67，即 0x43；音速用最大值，所以，整条消息为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x9E&lt;/span&gt;  &lt;span&gt;0x43&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;======================================================================&lt;/p&gt;
&lt;p&gt;下面咱们开始编程，先说说连接设备。不管是输入还是输出设备，我们都可以用这种方法连接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        IMidiOutPort midiOuter = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; Task&amp;lt;IMidiOutPort&amp;gt;&lt;span&gt; GetOuterPortAsync()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取设备查询字符串&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; q =&lt;span&gt; MidiOutPort.GetDeviceSelector();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找相关 MIDI 输出设备&lt;/span&gt;
            DeviceInformationCollection devs = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; DeviceInformation.FindAllAsync(q);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果连接多个 MIDI 设备，就要选一个来耍，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有连外设，那只能有一个，就是声卡兼容的合成器&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MidiOutPort.FromIdAsync(q);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后初始化一下 out port。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  midiOuter = &lt;span&gt;await&lt;/span&gt; GetOuterPortAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要的时候，记得要清理一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  midiOuter?.Dispose();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里有一个很 TNND 重要的事情，一定要注意，声明变量时，一定要声明为 IMidiOutPort 接口类型，不要声明为 MidiOutPort 类型，这样做到时候很可能你无法与设备通信，发了消息过去没声音。不要问为什么了，记住就行，这是封装 COM 组件的，COM通常都是用接口中来操作的。&lt;/p&gt;

&lt;p&gt;好的，下面正式实现我们今天的示例，为了演示，老周特意写了一首歌，意境优美，相当动听，值得收藏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223182755225-1740682976.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于这首歌热情扬溢，老周故意把节拍设置为 60，即每分钟 60 拍，正好一秒一拍。&lt;/p&gt;
&lt;p&gt;用来进行音乐合成，最好直接使用 MidiSynthesizer 类。&lt;/p&gt;
&lt;p&gt;第一步。初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        MidiSynthesizer mSynthesizer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatedTo(NavigationEventArgs e)
        {
            mSynthesizer &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MidiSynthesizer.CreateAsync();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在离开当前页面时，不再需要，释放掉，洗地。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatingFrom(NavigatingCancelEventArgs e)
        {
            mSynthesizer&lt;/span&gt;?&lt;span&gt;.Dispose();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步，定义几个变量，后面要用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TEMPO = &lt;span&gt;1000&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每秒一拍&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; CHANNEL = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通道0，本例只用一个通道&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isPlaying = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TEMPO 是节拍，咱们的曲子是 J = 60，故一秒一拍，这里表示为 1000 毫秒。CHANNEL表示我们要用到的通道，为了简单演示，我们这个示例只用第一个 MIDI 通道，编号为 0。&lt;/p&gt;
&lt;p&gt;isPlaying 防止重复播放，当正在播放时，它为 true，播放完后变为 false。&lt;/p&gt;

&lt;p&gt;第三步，组合音符，并发送到 MIDI 设备上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPlaying)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            isPlaying &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 播放音符&lt;/span&gt;
            MidiNoteOnMessage noteOn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止音符&lt;/span&gt;
            MidiNoteOffMessage noteOff = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组合音符列表&lt;/span&gt;
            List&amp;lt;Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; notes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音5 = 55，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;55&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音6 = 57，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 5 = 67，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;67&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 5 = 55，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;55&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始操作&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; tp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; notes)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启音符&lt;/span&gt;
                noteOn = &lt;span&gt;new&lt;/span&gt; MidiNoteOnMessage(CHANNEL, tp.Item1, &lt;span&gt;127&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送&lt;/span&gt;
&lt;span&gt;                mSynthesizer.SendMessage(noteOn);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延时&lt;/span&gt;
                &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.Delay(tp.Item2);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止&lt;/span&gt;
                noteOff = &lt;span&gt;new&lt;/span&gt; MidiNoteOffMessage(CHANNEL, tp.Item1, &lt;span&gt;127&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送&lt;/span&gt;
&lt;span&gt;                mSynthesizer.SendMessage(noteOff);
            }

            isPlaying &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Tuple 是元组，以前老周在其他博文中说过，就是简单地把两个值组合起来，我们这里用了两种值，byte类型的表示音符编号，int类型的表示音符要持续的时间，即时值。&lt;/p&gt;
&lt;p&gt;我先用一个 List 把所有的音符与时值组合起来，然后再通过一个循环来发送到声卡。&lt;/p&gt;
&lt;p&gt;注意，在发送完 Note On后，不能立即发 Note Off，因为那样音符会停止，你就听不到了，所以要用 Delay 方法延时一下，而延时的时间就是音符的时值。如果是一拍，就是 1000 毫秒，如果是两拍就是 2000 毫秒，如果是半拍，就是 500 毫秒……&lt;/p&gt;

&lt;p&gt;第四步，现在虽然代码已经写完了，但你是无法合成 MIDI 音乐的，因为 MIDI API 是微软为我们封装过的，咱们还需要添加一个引用。如下图，请勾选【Microsoft General MIDI DLS for Universal Windows Apps】，注意是勾上前面的对勾，不要只选中，最后点确定即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223184414303-865607344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在，运行应用，然后点击【演奏这首歌】按钮，就能听到了。&lt;/p&gt;
&lt;p&gt;你听到的是大钢琴的声音，因为这是默认音色。通用音色库可以使用 128 种乐器音色，这个老周将在下一篇中介绍。&lt;/p&gt;
&lt;p&gt;本篇示例源代码，请&lt;a href=&quot;https://files.cnblogs.com/files/tcjiaan/midiNotesSample.zip&quot; target=&quot;_blank&quot;&gt;猛点击这里下载&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 10:45:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8085408.html</dc:identifier>
</item>
<item>
<title>如何对博客进行备份和还原？（适用于博客园） - 20162330_刘伟康</title>
<link>http://www.cnblogs.com/super925/p/8093453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/super925/p/8093453.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;

&lt;h3 id=&quot;0&quot;&gt;为什么要备份博客？&lt;/h3&gt;
&lt;p&gt;　　首先希望你是一个认真对待博客的人，其次，如果你又是一个爱惜自己物品的人，或者你有强迫症（完美主义倾向），你一定不希望哪天登录博客园翻看自己的某篇博客时突然发现这种情况——自己之前写的博客怎么缺失了一半！！！另外一半呢？？？ @_@&lt;br/&gt;于是找到&lt;a href=&quot;http://www.cnblogs.com/cmt/&quot;&gt;博客园团队&lt;/a&gt;，发了一封求救信，可结果却是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223163638834-830175376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后呢？小编想说然后就没有然后了（没有备份自己只能默默重写了 Orz）。虽然发生这种情况的几率很小，但也要防患于未然，于是我们就可以选择一种保险的做法——备份（博客）。因此，从专业一点的角度上讲，&lt;strong&gt;备份工具&lt;/strong&gt; 可以保护数据免受意外的损失，而 &lt;strong&gt;备份博客&lt;/strong&gt; 就是为了应付博客中数据丢失等可能出现的意外情况。至于为什么会发生数据丢失，小编觉得仅就博客园丢失博客的数据而言，可能是当时的网络环境比较差，并且你在博客园加载某篇博客的 TextView 时（还未加载完毕）就点了保存，服务器正在缓存，还没有将你之前博客的数据加载完全，这就导致了一部分数据的丢失。&lt;br/&gt;　　在你下次翻看自己之前的博客时，就会不经意地发现：&lt;strong&gt;自己有一篇博客的 XXX内容 竟然奇迹般地消失了！？&lt;/strong&gt;点了一下刷新，没用，再点刷新，还是没用，慌乱的你想进去看个究竟于是直接点击了编辑，结果这部分内容真的就这样消失了！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（丢失博客的截图.pnp）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　小编已有1年多的园龄了，在这段时光里，小编不幸地遇到了两次博客数据丢失的“灾难”，第一次遇到的时候不知所措，完全傻了眼，现在多了些经验教训，遂借此篇博客进行总结和分享，并提醒更多博主定期做好“保养”博客的工作。如果有备份，就能“以防万一”了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223165032178-1456968867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1&quot;&gt;如何在博客园备份博客？&lt;/h3&gt;
&lt;p&gt;　　我们一般使用一些大容量存储设备定期备份系统、使用U盘等中小容量存储设备来备份一些重要数据和文件，备份博客也是如此，我们可以使用博客园自带的备份功能将自己的所有博客（包括草稿）保存为一个xml文件下载下来，然后把它保存好即可（占用空间很小）。具体步骤如下：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;首先，进入个人界面，点击你最常用的“写博”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223171705006-1945499642.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次，在写博界面中有两种备份方式，你可以点击左侧操作栏中的“博客备份”，也可以点击右上角的“备份”：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223172535115-193099359.png&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223172535115-193099359.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进入备份界面之后，根据所选择的时间进行备份，如果不进行修改，那么开始日期就默认为你发表（或保存）第一篇博客的时间，结束日期也默认为你最近发表（或保存）的一篇博客的时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223173038615-1031853352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后点击下载即可进行博客备份。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;【注意】&lt;strong&gt;备份是有时间规定的，一般在工作日的8:00之前或者18:00之后，或者周六周日才不会被限制下载，建议学生党一周定期备份一次，其他博主亦可根据自己的写博频率调整。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;如何还原备份的博客？&lt;/h3&gt;
&lt;p&gt;　　在备份了自己珍贵的博客之后，要怎么在博客内容丢失后迅速还原呢？办法很简单，之前我们保存的是一个xml文件，首先我们不用去下载一些xml文件的查看工具，除非有其他需要，我们只需要使用记事本打开即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223174306615-1223599813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223174317287-361516144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于是xml文件，所以打开后会有一些类似html的标记语言，不用管它们，直接去寻找我们需要的。之后我们便可以看到，第一篇博客（最近发表的博客或保存的草稿）的标题和正文，正文中的markdown格式内容完好无损：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223175519834-370338677.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　找到第一篇博客的末尾之后，紧接着就是下一篇博客的标题，以此类推：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223183242115-2043104607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们将需要的markdown格式正文复制下来，粘贴到对应的缺失数据的博客中去重新保存即可，这样一来，我们就放心了，是不是也同时满足了强迫症的需求呢？博主们现在就可以去备份博客了（今天周六）！这次就写到这里吧，小编学识浅薄，见闻不广，如果博主们在阅读时发现了一些错误、遗漏点或者对此篇博客有其他建议，欢迎在评论区指出。(　＾∀＾)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;参考资料&lt;/h3&gt;

&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;【附】原创作品，如需转载，请注明出处，谢谢。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
</description>
<pubDate>Sat, 23 Dec 2017 10:19:00 +0000</pubDate>
<dc:creator>20162330_刘伟康</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/super925/p/8093453.html</dc:identifier>
</item>
</channel>
</rss>