<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>逆向知识第十讲,循环在汇编中的表现形式,以及代码还原 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7869304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7869304.html</guid>
<description>&lt;h2&gt;一丶do While在汇编中的表现形式&lt;/h2&gt;
&lt;h3&gt;1.1高级代码:&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; 
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;高级代码很简单,只是一个简单的求1~100的累加&lt;/p&gt;
&lt;h3&gt;1.2 Debug版本下的汇编表现形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171120234342180-1564368098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码定式很简单&lt;/p&gt;
&lt;p&gt;ADDR&lt;/p&gt;
&lt;p&gt;　　.....do While逻辑代码块&lt;/p&gt;
&lt;p&gt;　　xxxx 条件&lt;/p&gt;
&lt;p&gt;　　JXX  Addr&lt;/p&gt;
&lt;p&gt;注意,在 do while中, 汇编代码的语义和高级代码语义是一样的.&lt;/p&gt;
&lt;p&gt;比如我们以前的if   jle的时候(也就是小于等于) 我们的if则会写成  &amp;gt; (jg)也就是反向还原,而循环地址向上增量的条件不用取反&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码还原:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　do&lt;/p&gt;
&lt;p&gt;　　　　int nVar4 = nvar4 + nvar8;&lt;/p&gt;
&lt;p&gt;　　while(nVar8 &amp;lt;= 100)  注意条件,jle就是jle&lt;/p&gt;
&lt;p&gt;还需要注意的是,地址是低地址,也就是跳转是往上跳转的&lt;/p&gt;

&lt;h3&gt;1.3 Release版本下的优化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;高级代码:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; 
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        i&lt;/span&gt;++&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;=&lt;span&gt; argc);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; argc;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Release版本下的汇编代码:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121003943086-197807152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码也是最精简的了.和Debug一样,只不过优化为寄存器使用了.效率更快.&lt;/p&gt;

&lt;h2&gt;二丶while 循环在汇编中的表达形式&lt;/h2&gt;
&lt;h3&gt;2.1高级代码:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i &amp;lt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;) 
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,nSum);
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; argc;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 Debug版本下的汇编表达形式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171120235826133-449132547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意,while循环回合if else的汇编代码类似&lt;/p&gt;
&lt;p&gt;但是又有质的不同,在if else中, else语句块,其JMP跳转的地址是往增量地址跳转的,而在while中其跳转的地址是往减量地址跳转的&lt;/p&gt;
&lt;p&gt;汇编代码定式:&lt;/p&gt;
&lt;p&gt;LowAddr&lt;/p&gt;
&lt;p&gt;　　　　jxxx  HighAddr&lt;/p&gt;
&lt;p&gt;　　　　....... while语句块代码&lt;/p&gt;
&lt;p&gt;　　　　JMP  LowAddr&lt;/p&gt;
&lt;p&gt;HighAddr&lt;/p&gt;
&lt;p&gt;可以看出,while循环有两个跳转&lt;/p&gt;
&lt;p&gt;上下界的分别&lt;/p&gt;
&lt;p&gt;jg  highaddr  找到while循环的下界&lt;/p&gt;
&lt;p&gt;jmp  lowaddr 找到while循环的上界&lt;/p&gt;
&lt;p&gt;注意,这里的定式我并没有写条件,因为条件只要会影响标志位即可,有可能不是cmp,反正能影响标志位的即可.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码还原:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　while(nvar8 &amp;lt;= 100)  (语义相反,只有do while的语义按正常还原 jg(高于),相反则是小于等于)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　printf(&quot;%d&quot;,nvar4);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　nvar4 = nvar4 + nvar8;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS: 在第一个跳转之前的所有代码,都作为while循环中的条件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三丶for循环在汇编中的表达形式&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;3.1高级代码:&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;;i++&lt;span&gt;) 
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,nSum);
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; argc;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3.2Debug下的汇编表现形式&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121001656399-966962830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; for循环因为有了 步长的概念,所以Debug下的代码可能有点难看懂&lt;/p&gt;
&lt;p&gt;说下代码定式把&lt;/p&gt;
&lt;p&gt;　　JMP  forCMPaddr  跳转到代码比较&lt;/p&gt;
&lt;p&gt;FOR_STEMAddr&lt;/p&gt;
&lt;p&gt;　　　　for_Step　　　 其代码是步长代码 (i++ j++)&lt;/p&gt;
&lt;p&gt;forCMPaddr&lt;/p&gt;
&lt;p&gt;　　for_cmp　　   代码比较&lt;/p&gt;
&lt;p&gt;　　jxxx  forEndAddr  和while循环类似,跳转到结尾,条件不成立则退出,看此跳转则找到for循环的下界&lt;/p&gt;
&lt;p&gt;　　.....循环体&lt;/p&gt;
&lt;p&gt;　  JMP FOR_STEMADDR 执行完循环体之后,执行步长代码.&lt;/p&gt;
&lt;p&gt;FOR_ENDADDR&lt;/p&gt;
&lt;p&gt;修改为代码定式模样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121002231336-89180358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 代码还原:&lt;/p&gt;
&lt;p&gt;第一步: JMP FOR_CMP 所以找到for循环的比较代码位置&lt;/p&gt;
&lt;p&gt;第二步: 找到jxx For_end 找到for循环的下界.则当前位置是代码的上界&lt;/p&gt;
&lt;p&gt;第三步: jmp FOR_STEP 找到for循环的步长部分&lt;/p&gt;
&lt;p&gt;for(nVar8 = 0; nVar8 &amp;lt; 100; nVar8++)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;　　printf(&quot;%d&quot;,nVar4);&lt;/p&gt;
&lt;p&gt;　　nVar4 = nVar4 +nVar8;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;还原for的时候,主要是找到 比较部分,代码步长部分.以及循环体部分.&lt;/p&gt;


&lt;p&gt;上面版本都是Debug版本下的表达形式,但是Release版本下则会优化&lt;/p&gt;
&lt;p&gt;主要从几方面来讲解&lt;/p&gt;
&lt;p&gt;1.减少跳转的优化方式&lt;/p&gt;
&lt;p&gt;2.常量传播的优化方式&lt;/p&gt;
&lt;p&gt;3.代码外提的优化方式&lt;/p&gt;
&lt;p&gt;4.强度削弱的优化方式&lt;/p&gt;

&lt;h2&gt;一丶While在汇编中的Release的优化&lt;/h2&gt;
&lt;p&gt;因为dowhile是最优化的方式了,所以没有更好的优化方式了&lt;/p&gt;
&lt;h3&gt;1.1 while循环下的减少跳转的优化方式&lt;/h3&gt;
&lt;p&gt; 首先说下为什么减少跳转.&lt;/p&gt;
&lt;p&gt;我们知道,do while就一个跳转,而while在Debug版本下是两个跳转,for循环在Debug版本下是3个跳转&lt;/p&gt;
&lt;p&gt;那么如果减少了跳转,那么则会大大的增加效率.&lt;/p&gt;
&lt;h4&gt;1.1.2高级代码:&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i &amp;lt;=&lt;span&gt; argc) 
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        i&lt;/span&gt;++&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; argc;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.1.3 Release版本下的代码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121004332946-1242113768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个汇编代码,我们发现jl的时候,是和if相似的.&lt;/p&gt;
&lt;p&gt;而 jle的时候,地址是减量跳转,则是do while的条件&lt;/p&gt;
&lt;p&gt;那么此时我们可能会还原成 if里面包含do while&lt;/p&gt;
&lt;p&gt;但其实,也是这样还原的.这样是为了减少跳转&lt;/p&gt;
&lt;p&gt;说下为什么减少跳转&lt;/p&gt;
&lt;p&gt;1.首先判断,如果不成立,则不执行循环语句块&lt;/p&gt;
&lt;p&gt;2.当第一个条件成立,则循环语句块,此时我知道你的条件是成立的,所以我只需要变为do while去循环即可.&lt;/p&gt;
&lt;p&gt;这样就减少跳转了,比如我们的while循环20000次,那么跳转就要 *2,那么此时变成if 包含do while的时候&lt;/p&gt;
&lt;p&gt;那么此时跳转就是 200001次,大大的优化了效率&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还原代码:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(argc &amp;gt;= 0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　do&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　ecx = ecx + eax;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　eax ++;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　while(eax &amp;lt;= argc )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;识别此类的循环要注意&lt;/p&gt;
&lt;p&gt;1.首先if中的条件和 do while中的条件有相关性&lt;/p&gt;
&lt;p&gt;2.注意如果是dowhile那么其地址跳转是往减量跳转.&lt;/p&gt;
&lt;p&gt;当然如果你喜欢还原为while那么也是可以了&lt;/p&gt;
&lt;p&gt;while (eax &amp;lt;= argc)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;　　ecx = ecx + eax;&lt;/p&gt;
&lt;p&gt;　　eax ++;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;第一种还原方式,如果条件有相关性,则还原出的汇编代码是和这个的二进制代码是一摸一样的.2.&lt;/p&gt;
&lt;h3&gt; 1.2 常量传播下的优化方式&lt;/h3&gt;
&lt;p&gt;在常量传播下,则直接变成了do while了.&lt;/p&gt;
&lt;p&gt;看下高级代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i &amp;lt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        i&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常量传播后,则i变成了常量.所以直接变成do while即可.&lt;/p&gt;
&lt;p&gt;Release汇编&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121010743540-324636729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1.3代码外提优化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;高级代码:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i &amp;lt; argc /&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        i&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 argc/7并没有在循环体中使用所以可以单独提取出来.&lt;/p&gt;
&lt;p&gt;int temp = argc / 7;&lt;/p&gt;
&lt;p&gt;while(i &amp;lt; temp)...&lt;/p&gt;
&lt;p&gt;Release版本下的汇编代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121011840618-1353059698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面则是代码外提的情况,此时还原代码也可以还原为 if 包含do while的形式&lt;/p&gt;
&lt;p&gt;PS: 代码外提不支持函数&lt;/p&gt;
&lt;p&gt;比如 &lt;/p&gt;
&lt;p&gt;　　for(i = 0; i &amp;lt; strlen(&quot;hello&quot;);i++) ... 其中 strlen是函数,所以不会代码外提&lt;/p&gt;
&lt;h2&gt;二丶减少跳转优化(For循环)&lt;/h2&gt;
&lt;p&gt;for循环在Debug版本下有三层跳转.那么减少跳转之后,则和上方while一样,也变为if包含 do While了.&lt;/p&gt;
&lt;p&gt;PS: 注意,在常量传播下,所有的循环都变成了do while类型去执行循环了&lt;/p&gt;
&lt;p&gt;PS: 注意,代码外提的情况下,所有循环都变成 if 加 do while的形式,代码放到外面执行了.&lt;/p&gt;
&lt;h3&gt;2.1高级代码:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; argc; i++&lt;span&gt;)
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        i&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Release版本下的汇编&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121011123336-1738734473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其也变成了if 包含do while循环的形式&lt;/p&gt;
&lt;p&gt;还原代码同上&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;循环中有continue和break&lt;/p&gt;
&lt;p&gt;其中continue是跳过当前循环进行下一次循环.&lt;/p&gt;
&lt;p&gt;break是跳出循环体&lt;/p&gt;
&lt;p&gt;所以我们知道了,break会跳出循环.而continue不会跳出循环.\&lt;/p&gt;
&lt;h2&gt;一丶观看For循环的Debug版本.和Releas版本,观察continue和break的区别.&lt;/h2&gt;
&lt;h3&gt;1.1高级代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;int&lt;/span&gt; nSum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; argc ;i++&lt;span&gt;)
    {
        nSum &lt;/span&gt;= nSum +&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        i&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2Debug汇编break和Continue的表达形式.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121014617868-548355855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;break执行会跳出循环体,而continue则会跳转到补偿代码执行&lt;/p&gt;
&lt;h3&gt;1.3Release版本下的汇编&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171121014912086-117204872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以看出,break会跳出循环,而continue则不会跳出循环&lt;/p&gt;

&lt;h2&gt;1. do while总结&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Debug版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.do while有一次跳转,其中跳转的代码是往减量地址跳转(低地址)&lt;/p&gt;
&lt;p&gt;　　2.还原心得,因为其地址往减量跳转,所以汇编语义与高级语言语义一样,正常代码还原&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Release版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.常量传播下,直接就是do while了,和Debug版本下一样,一次跳转,还原方式正常跳转&lt;/p&gt;

&lt;h2&gt; 2. While循环总结&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Debug版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.有两次跳转,代码特别像 if else,但是又有质的不同,其中第一次跳转其地址是往增量跳转,第二次跳转其地址是往减量地址跳转(if else则都是往增量地址跳转)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.还原心得,第一次跳转之前的代码都作为while循环中的条件,其条件是反向还原,语义相反.第一次跳转可以找到while的下界,其当前位置则是while的上界.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Release版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.常量传播的优化方式下,其代码会变成do while执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.代码外提的情况下,其代码会变成if 包含 do while执行,其中代码的条件外提.注意,函数不可以作为代码外提&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.还原心得: 如果是 if包含do while的形式,则判断两个条件是否有相关性.如果有相关性则可以还原成while或者自己喜好的 if +do while的形式.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.第一次跳转是相反语义,第二次跳转是正常语义.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.for循环总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　Debug版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  1.for循环因为有步长的问题,所以多一次跳转. 其中 第一步跳转到 条件位置处,第二此跳转则判断条件是否成立,不成立则退出,此时找到for的下界,当前位置可以当做if的上界.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　   条件成立之后代码继续执行,则此时又来了一次跳转,此跳转跳转到步长执行代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 Release版本下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.常量传播方式下 代码变为do while执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.代码外提情况下,代码变成了 if + do while的形式&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 17:50:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7869304.html</dc:identifier>
</item>
<item>
<title>分布式网络文件系统--MooseFS - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/7869152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/7869152.html</guid>
<description>&lt;h2&gt; &lt;strong&gt;一.介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;1.简介  &lt;/h3&gt;
&lt;p&gt;MooseFS是一个具备&lt;span&gt;冗余容错功能的分布式网络文件系统&lt;/span&gt;，它将数据分别存放在多个物理服务器或单独磁盘或分区上，确保一份数据有多个备份副本。对于访问的客户端或者用户来说，整个分布式网络文件系统集群看起来就像一个资源一样。从其对文件操作的情况看，MooseFS就相当于一个类UNIX文件系统:。&lt;/p&gt;
&lt;p&gt;       1、mfs是一个分层的目录树结构&lt;/p&gt;
&lt;p&gt;       2、存储支持POSIX标准的文件属性（权限，最后访问和修改时间）&lt;/p&gt;
&lt;p&gt;       3、支持特殊的文件，如：块设备，字符设备，管道和套接字，链接文件（符号链接和硬链接）&lt;/p&gt;
&lt;p&gt;       4、支持基于IP地址和密码的方式访问文件系统&lt;/p&gt;
&lt;h3&gt;2.应用场景&lt;/h3&gt;
&lt;p&gt;      谈及MooseFS的应用场景，其实就是去谈分布式文件系统的应用场景。&lt;/p&gt;
&lt;p&gt;      1、大规模高并发的数据存储及访问（小文件、大文件），TFS适合小文件（&amp;lt;1M）&lt;/p&gt;
&lt;p&gt;      2、大规模的数据处理，如日志分析&lt;/p&gt;
&lt;h2&gt;二.组成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201711/1024482-20171121012047211-320078465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1.管理服务器 Master Server&lt;/h3&gt;
&lt;p&gt;   管理服务器 Master Server 负责所有数据存储服务器的数据存储管理，响应客户端文件的读写请求，收回文件空间以及恢复文件，多存储节点之间的文件复制。&lt;/p&gt;
&lt;h3&gt;2.备份服务器Metalogger Server&lt;/h3&gt;
&lt;p&gt;   元数据日志服务器 Metalogger Server，对 Master Server  服务器的变化日志文件进行备份，changelog_ml.*.mfs 是备份文件的类型，当 Master Server 出现故障时替换其继续工作，避免 Master Server 的单点故障导致分布式文件系统的不能正常运行。&lt;/p&gt;
&lt;h3&gt;3.数据存储服务器 Chunk Server&lt;/h3&gt;
&lt;p&gt;    数据存储服务器chunkserver，服从 Master Server 的安排，定期向 Master Server 发送自己的状态信息，除此之外，还能向客户提供数据存储空间，能够向客户传输数据。&lt;/p&gt;
&lt;h3&gt;4.客户端 Client&lt;/h3&gt;
&lt;p&gt;    通过 FUSE 内核接口挂载到数据存储服务器上，在客户端看来使用数据存储服务器上的文件系统和使用本地Unix文件系统是一样的。&lt;/p&gt;
&lt;h2&gt;三.MooseFS原理&lt;/h2&gt;
&lt;h3&gt;1.MooseFS读取文件流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201711/1024482-20171120162523711-1641280511.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.MooseFS写文件流程&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201711/1024482-20171121013153227-1798626402.png&quot; alt=&quot;&quot; width=&quot;1304&quot; height=&quot;767&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 17:10:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/7869152.html</dc:identifier>
</item>
<item>
<title>【小技巧解决大问题】使用 frp 突破阿里云主机无弹性公网 IP 不能用作 Web 服务器的限制 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7869040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7869040.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-a30db2029194ed76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;order.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年 8 月份左右，打折价买了一个阿里云主机，比平常便宜了 2000 多块。买了之后，本想作为一个博客网站的，毕竟国内的服务器访问肯定快一些。满心欢喜的下单之后，却发现 http 服务，外网怎么也无法访问。各种搜，最终在文档中，终于看见：必须要买弹性公网 IP，并且绑定到阿里云主机上，才可以用作web服务器。而且要求，阿里云主机必须是未绑定过 IP 的。不过很不幸，我当时下单时，已经勾选了使用公网IP。本来想着解绑然后重新绑定下，应该就可以了。然而，已经绑定过公网IP的，是不允许再改绑弹性公网IP的。欲哭无泪，这个服务器，也就闲置了几个月。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-184c46ba975a33a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;config.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近接触了些内网穿透的知识，我突然想到，是不是借助内网穿透，也可以把我的阿里云主机给暴露出来？毕竟内网穿透，使用的是 Linux 一些基础知识，算不上很极客的技术，应该是具有通用性的。经验证，竟然真的可行！ 特记录下来，献给有同样遭遇的有缘人。&lt;/p&gt;
&lt;h2 id=&quot;使用-revel-搭建一个简单的-web-服务器&quot;&gt;使用 revel 搭建一个简单的 Web 服务器&lt;/h2&gt;
&lt;p&gt;需要先搭建一个 Web 服务器，以供测试用。如果你选择其他方式搭建 web 服务器，可直接跳过这一节。&lt;/p&gt;
&lt;h3 id=&quot;下载最新版本-go&quot;&gt;下载最新版本 go&lt;/h3&gt;
&lt;p&gt;可以在 &lt;a href=&quot;https://golang.org/doc/install&quot;&gt;Go 下载页&lt;/a&gt;，查看最新的稳定版本，来替换 go1.9.2.linux-amd64.tar.gz ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wget https://redirector.gvt1.com/edgedl/go/go1.9.2.linux-amd64.tar.gz 
tar -C /usr/local -xzf go1.9.2.linux-amd64.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果已经安装过 Go,可能需要先移除：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;apt remove golang-go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ~/.profile 中，添加：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export PATH=$PATH:/usr/local/go/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ~/.bash_profile 中，添加：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export GOPATH=$HOME/go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;$HOME/go 表示你想用作 $GOPATH 的文件夹。&lt;/p&gt;
&lt;p&gt;设置完后，最好重启下 shell 终端，以使信息生效。&lt;/p&gt;
&lt;h3 id=&quot;直接从-github-下载-golang.orgxsys-和-golang.orgxnet-源码&quot;&gt;直接从 github 下载 golang.org/x/sys 和 golang.org/x/net 源码&lt;/h3&gt;
&lt;p&gt;golang.org下的包，直接安装，在无法科学上网时，有极大概率会失败。作为一种替代手段，我们可以直接从 github 下载对应的源码到 $GOPATH 对应路径。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 创建包存储路径
mkdir $GOPATH/src/golang.org/x

#安装git
apt install git

#下载 revel 依赖的包源码。
git clone https://github.com/golang/net $GOPATH/src/golang.org/x/net
git clone https://github.com/golang/sys $GOPATH/src/golang.org/x/sys

# 安装 revel
go get -u github.com/revel/cmd/revel

# revel 命令，需要在 $GOPATH 中执行
cd $GOPATH/src

# 创建并运行一个web应用
revel new hello-go-web
revel run hello-go-web&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-25d0dfe1683fa8d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;web.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;frp-配置&quot;&gt;frp 配置&lt;/h2&gt;
&lt;p&gt;有关 frp 配置的细节，请参考 &lt;a href=&quot;http://www.cnblogs.com/ios122/p/7833647.html&quot;&gt;借助 frp 随时随地访问自己的树莓派&lt;/a&gt;。此处只贴出关键配置文件。&lt;/p&gt;
&lt;h3 id=&quot;在公网能访问的服务器上配置-frps-服务器端&quot;&gt;在公网能访问的服务器上配置 frps 服务器端&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[common]
bind_port = 7000
vhost_http_port =80
dashboard_port = dashboard_port_number
dashboard_user = dashboard_user_name
dashboard_pwd = dashboard_pwd_value
privilege_token = privilege_token_value
subdomain_host = example.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： &lt;strong&gt;example.com&lt;/strong&gt; 要换为自己的域名。&lt;/p&gt;
&lt;h3 id=&quot;域名泛解析&quot;&gt;域名泛解析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-03fb1d29725448c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dns.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将泛域名 *.example.com 解析到 frps 所在服务器的 IP 地址。这样，你不需要频繁修改 DNS 配置了。此处我们是打算把某个子域名解析到我们的阿里云主机上。如果你想直接把根域名解析到服务器上，参考：&lt;a href=&quot;https://github.com/fatedier/frp/blob/master/README_zh.md#%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%86%85%E7%BD%91%E7%9A%84-web-%E6%9C%8D%E5%8A%A1&quot;&gt;通过自定义域名访问部署于内网的 web 服务&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;在只能内网访问的阿里云主机上配置-fprc-客户端&quot;&gt;在只能内网访问的阿里云主机上配置 fprc 客户端&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[common]
server_addr = your_server_IP
server_port = 7000
privilege_token = privilege_token_value
login_fail_exit = false

[ssh-aliyun]
type = tcp
local_IP = 127.0.0.1
local_port = 22
remote_port = remote_port_number
use_encryption = true
use_compression = true

[web-show]
type = http
local_port = 9000
subdomain = show&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：9000 表示web服务器的本地端口，请根据需要替换；show,表示子域名，配置成功后，可以通过 show.example.com 访问自己的 web 网页了。&lt;/p&gt;
&lt;h2 id=&quot;使用-systemd-实现自动启动-revel&quot;&gt;使用 Systemd 实现自动启动 revel&lt;/h2&gt;
&lt;p&gt;使用 Systemd 实现自动启动 frp，可以直接看 &lt;a href=&quot;http://blog.csdn.net/sinat_30800357/article/details/78532956&quot;&gt;借助 frp 随时随地访问自己的树莓派&lt;/a&gt; 相关部分，不再赘述。此处着重说下 revel 自启动的配置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;
# 编写 frp service 文件，以 centos7 为例,适用于 debian
mkdir /usr/lib/systemd/system/
vim /usr/lib/systemd/system/revel-hello-go-web.service

# 内容如下

变更内容:
[Unit]
DescrIPtion=/revel-hello-go-web
After=network.target

[Service]
Environment=PATH=$PATH:/usr/local/go/bin
Environment=GOPATH=/root/go
TimeoutStartSec=30
ExecStart=/root/go/bin/revel run hello-go-web
ExecStop=/bin/kill $MAINPID
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target

# 启动 revel-hello-go-web 并设置开机启动
systemctl enable revel-hello-go-web
systemctl start revel-hello-go-web
systemctl status revel-hello-go-web

# 部分服务器上,可能需要加 .service 后缀来操作,即:
systemctl enable revel-hello-go-web.service
systemctl start revel-hello-go-web.service
systemctl status revel-hello-go-web.service

# 重新加载: 
systemctl daemon-reload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/root/go 要替换为自己电脑 $GOPATH 的真实路径。&lt;/li&gt;
&lt;li&gt;此处的 sytemd 的配置中, Environment 环境变量,必须设置,否则报错&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Mon, 20 Nov 2017 16:53:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7869040.html</dc:identifier>
</item>
<item>
<title>Struts2初探 - 文刀山豆几</title>
<link>http://www.cnblogs.com/shandouji1121/p/7868931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shandouji1121/p/7868931.html</guid>
<description>&lt;p&gt;　　我记得美妙的瞬间；在我的面前出现了你，有如昙花一现的幻影&lt;/p&gt;
&lt;p&gt;　　今天写一篇Struts2框架的，在很久很久以前，Struts2可谓是称霸江湖，纵然现在有后起之秀，但Struts2依然可以成为老牌的主流框架，充当servlet,而且现在很多的招聘需求依然要求你会用Struts2，并且有的面试官会问你它和SpringMvc的区别，今天先把代码展示出来，对应的理论知识在&lt;span&gt;初探—续编&lt;span&gt;里面在详细表述。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;目录结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1167832/201711/1167832-20171121000306930-1360058320.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;HelloWorld.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Action;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloWorld &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String execute() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;执行ACtion&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Struts.xml 配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
&lt;span&gt; 4&lt;/span&gt;     &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;struts&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;default&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;action name=&quot;HelloWorld&quot; &lt;span&gt;class&lt;/span&gt;=&quot;Action.HelloWorld&quot;&amp;gt;
&lt;span&gt; 8&lt;/span&gt;             &amp;lt;result name=&quot;success&quot;&amp;gt;/index.jsp&amp;lt;/result&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;/action&amp;gt; 
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;
&lt;span&gt;11&lt;/span&gt; &amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Web.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
&lt;span&gt; 4&lt;/span&gt;     &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;struts&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;default&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;action name=&quot;HelloWorld&quot; &lt;span&gt;class&lt;/span&gt;=&quot;Action.HelloWorld&quot;&amp;gt;
&lt;span&gt; 8&lt;/span&gt;             &amp;lt;result name=&quot;success&quot;&amp;gt;/index.jsp&amp;lt;/result&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;/action&amp;gt; 
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;
&lt;span&gt;11&lt;/span&gt; &amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jsp 展示页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1167832/201711/1167832-20171121000132196-148816534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 后续还有Struts2的很多文章，敬请期待！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 16:04:00 +0000</pubDate>
<dc:creator>文刀山豆几</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shandouji1121/p/7868931.html</dc:identifier>
</item>
<item>
<title>OpenCV探索之路（二十七）：皮肤检测技术 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/7868877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/7868877.html</guid>
<description>&lt;p&gt;好久没写博客了，因为最近都忙着赶项目和打比赛==| 好吧，今天我打算写一篇关于使用opencv做皮肤检测的技术总结。那首先列一些现在主流的皮肤检测的方法都有哪些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RGB color space&lt;/li&gt;
&lt;li&gt;Ycrcb之cr分量+otsu阈值化&lt;/li&gt;
&lt;li&gt;YCrCb中133&amp;lt;=Cr&amp;lt;=173 77&amp;lt;=Cb&amp;lt;=127&lt;/li&gt;
&lt;li&gt;HSV中 7&amp;lt;H&amp;lt;20 28&amp;lt;S&amp;lt;256 50&amp;lt;V&amp;lt;256&lt;/li&gt;
&lt;li&gt;基于椭圆皮肤模型的皮肤检测&lt;/li&gt;
&lt;li&gt;opencv自带肤色检测类AdaptiveSkinDetector&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那我们今天就来一一实现它吧！&lt;/p&gt;
&lt;h2 id=&quot;方法一基于rgb的皮肤检测&quot;&gt;方法一：基于RGB的皮肤检测&lt;/h2&gt;
&lt;p&gt;根据RGB颜色模型找出定义好的肤色范围内的像素点，范围外的像素点设为黑色。&lt;/p&gt;
&lt;p&gt;查阅资料后可以知道，前人做了大量研究，肤色在RGB模型下的范围基本满足以下约束：&lt;/p&gt;
&lt;p&gt;在均匀光照下应满足以下判别式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R&amp;gt;95 AND G&amp;gt;40 B&amp;gt;20 AND MAX(R,G,B)-MIN(R,G,B)&amp;gt;15 AND ABS(R-G)&amp;gt;15 AND R&amp;gt;G AND R&amp;gt;B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在侧光拍摄环境下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R&amp;gt;220 AND G&amp;gt;210 AND B&amp;gt;170 AND ABS(R-G)&amp;lt;=15 AND R&amp;gt;B AND G&amp;gt;B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然判别式已经确定了，所以按照判别式写程序就很简单了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*基于RGB范围的皮肤检测*/
Mat RGB_detect(Mat&amp;amp; img)
{
    /*
        R&amp;gt;95 AND G&amp;gt;40 B&amp;gt;20 AND MAX(R,G,B)-MIN(R,G,B)&amp;gt;15 AND ABS(R-G)&amp;gt;15 AND R&amp;gt;G AND R&amp;gt;B
            OR
        R&amp;gt;220 AND G&amp;gt;210 AND B&amp;gt;170 AND ABS(R-G)&amp;lt;=15 AND R&amp;gt;B AND G&amp;gt;B
    */
    Mat detect = img.clone();
    detect.setTo(0);
    if (img.empty() || img.channels() != 3)
    {
        return detect;
    }

    for (int i = 0; i &amp;lt; img.rows; i++)
    {
        for (int j = 0; j &amp;lt; img.cols; j++)
        {
            uchar *p_detect = detect.ptr&amp;lt;uchar&amp;gt;(i, j);
            uchar *p_img = img.ptr&amp;lt;uchar&amp;gt;(i, j);
            if ((p_img[2] &amp;gt; 95 &amp;amp;&amp;amp; p_img[1]&amp;gt;40 &amp;amp;&amp;amp; p_img[0] &amp;gt; 20 &amp;amp;&amp;amp;
                (MAX(p_img[0], MAX(p_img[1], p_img[2])) - MIN(p_img[0], MIN(p_img[1], p_img[2])) &amp;gt; 15) &amp;amp;&amp;amp;
                abs(p_img[2] - p_img[1]) &amp;gt; 15 &amp;amp;&amp;amp; p_img[2] &amp;gt; p_img[1] &amp;amp;&amp;amp; p_img[1] &amp;gt; p_img[0]) ||
                (p_img[2] &amp;gt; 200 &amp;amp;&amp;amp; p_img[1] &amp;gt; 210 &amp;amp;&amp;amp; p_img[0] &amp;gt; 170 &amp;amp;&amp;amp; abs(p_img[2] - p_img[1]) &amp;lt;= 15 &amp;amp;&amp;amp;
                p_img[2] &amp;gt; p_img[0] &amp;amp;&amp;amp;  p_img[1] &amp;gt; p_img[0]))
            {
                p_detect[0] = p_img[0];
                p_detect[1] = p_img[1];
                p_detect[2] = p_img[2];
            }

         
        }

    }
    return detect;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120233942118-982022546.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从检测结果可以看出，皮肤的检测效果并不好，首先皮肤检测的完整性并不高，一些稍微光线不好的区域也没法检测出皮肤来。第二，这种基于RBG范围来判定皮肤的算法太受光线的影响了，鲁棒性确实不好。&lt;/p&gt;
&lt;h2 id=&quot;方法二基于椭圆皮肤模型的皮肤检测&quot;&gt;方法二：基于椭圆皮肤模型的皮肤检测&lt;/h2&gt;
&lt;p&gt;经过前人学者大量的皮肤统计信息可以知道，如果将皮肤信息映射到YCrCb空间，则在CrCb二维空间中这些皮肤像素点近似成一个椭圆分布。因此如果我们得到了一个CrCb的椭圆，下次来一个坐标(Cr, Cb)我们只需判断它是否在椭圆内（包括边界），如果是，则可以判断其为皮肤，否则就是非皮肤像素点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*基于椭圆皮肤模型的皮肤检测*/
Mat ellipse_detect(Mat&amp;amp; src)
{
    Mat img = src.clone();
    Mat skinCrCbHist = Mat::zeros(Size(256, 256), CV_8UC1);
    //利用opencv自带的椭圆生成函数先生成一个肤色椭圆模型
    ellipse(skinCrCbHist, Point(113, 155.6), Size(23.4, 15.2), 43.0, 0.0, 360.0, Scalar(255, 255, 255), -1);
    Mat ycrcb_image;
    Mat output_mask = Mat::zeros(img.size(), CV_8UC1);
    cvtColor(img, ycrcb_image, CV_BGR2YCrCb); //首先转换成到YCrCb空间
    for (int i = 0; i &amp;lt; img.cols; i++)   //利用椭圆皮肤模型进行皮肤检测
        for (int j = 0; j &amp;lt; img.rows; j++) 
        {
            Vec3b ycrcb = ycrcb_image.at&amp;lt;Vec3b&amp;gt;(j, i);
            if (skinCrCbHist.at&amp;lt;uchar&amp;gt;(ycrcb[1], ycrcb[2]) &amp;gt; 0)   //如果该落在皮肤模型椭圆区域内，该点就是皮肤像素点
                output_mask.at&amp;lt;uchar&amp;gt;(j, i) = 255;
        }

    Mat detect;
    img.copyTo(detect,output_mask);  //返回肤色图
    return detect;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120233959774-87672850.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种基于肤色椭圆模型的算法的皮肤检测较上面算法在效果上有着较大的提升，基本上改检测的皮肤都检测到了，对光线的抗干扰能力也是比较强的，检测出来的图像都比较干净，背景杂质较少。&lt;/p&gt;
&lt;h2 id=&quot;法三ycrcb颜色空间cr分量otsu法阈值分割&quot;&gt;法三：YCrCb颜色空间Cr分量+Otsu法阈值分割&lt;/h2&gt;
&lt;p&gt;这里先简单介绍YCrCb颜色空间。&lt;br/&gt;YCrCb即YUV，其中“Y”表示明亮度（Luminance或Luma），也就是灰阶值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。“亮度”是透过RGB输入信号来建立的，方法是将RGB信号的特定部分叠加到一起。“色度”则定义了颜色的两个方面─色调与饱和度，分别用Cr和Cb来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。&lt;/p&gt;
&lt;p&gt;该方法的原理也很简单：&lt;/p&gt;
&lt;p&gt;a.将RGB图像转换到YCrCb颜色空间，提取Cr分量图像&lt;/p&gt;
&lt;p&gt;b.对Cr做自二值化阈值分割处理（Otsu法）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*YCrCb颜色空间Cr分量+Otsu法*/
Mat YCrCb_Otsu_detect(Mat&amp;amp; src)
{
    Mat ycrcb_image;
    cvtColor(src, ycrcb_image, CV_BGR2YCrCb); //首先转换成到YCrCb空间
    Mat detect;
    vector&amp;lt;Mat&amp;gt; channels;
    split(ycrcb_image, channels);
    Mat output_mask = channels[1];
    threshold(output_mask, output_mask, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
    src.copyTo(detect, output_mask);
    return detect;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120234013946-198828174.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;法四基于ycrcb颜色空间crcb范围筛选法&quot;&gt;法四：基于YCrCb颜色空间Cr,Cb范围筛选法&lt;/h2&gt;
&lt;p&gt;这个方法跟法一其实大同小异，只是颜色空间不同而已。据资料显示，正常黄种人的Cr分量大约在133至173之间，Cb分量大约在77至127之间。大家可以根据自己项目需求放大或缩小这两个分量的范围，会有不同的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*YCrCb颜色空间Cr,Cb范围筛选法*/
Mat YCrCb_detect(Mat &amp;amp; src)
{
    Mat ycrcb_image;
    int Cr = 1;
    int Cb = 2;
    cvtColor(src, ycrcb_image, CV_BGR2YCrCb); //首先转换成到YCrCb空间
    Mat output_mask = Mat::zeros(src.size(), CV_8UC1);
    for (int i = 0; i &amp;lt; src.rows; i++)
    {
        for (int j = 0; j &amp;lt; src.cols; j++)
        {
            uchar *p_mask = output_mask.ptr&amp;lt;uchar&amp;gt;(i, j);
            uchar *p_src = ycrcb_image.ptr&amp;lt;uchar&amp;gt;(i, j);
            if (p_src[Cr] &amp;gt;= 133 &amp;amp;&amp;amp; p_src[Cr] &amp;lt;= 173 &amp;amp;&amp;amp; p_src[Cb] &amp;gt;= 77 &amp;amp;&amp;amp; p_src[Cb] &amp;lt;= 127)
            {
                p_mask[0] = 255;
            }
        }
    }
    Mat detect;
    src.copyTo(detect, output_mask);;
    return detect;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120234028649-1241212737.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;法五hsv颜色空间h范围筛选法&quot;&gt;法五：HSV颜色空间H范围筛选法&lt;/h2&gt;
&lt;p&gt;同样地，也是在不同的颜色空间下采取相应的颜色范围将皮肤分割出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*HSV颜色空间H范围筛选法*/
Mat HSV_detector(Mat&amp;amp; src)
{
    Mat hsv_image;
    int h = 0;
    int s = 1;
    int v = 2;
    cvtColor(src, hsv_image, CV_BGR2HSV); //首先转换成到YCrCb空间
    Mat output_mask = Mat::zeros(src.size(), CV_8UC1);
    for (int i = 0; i &amp;lt; src.rows; i++)
    {
        for (int j = 0; j &amp;lt; src.cols; j++)
        {
            uchar *p_mask = output_mask.ptr&amp;lt;uchar&amp;gt;(i, j);
            uchar *p_src = hsv_image.ptr&amp;lt;uchar&amp;gt;(i, j);
            if (p_src[h] &amp;gt;= 0 &amp;amp;&amp;amp; p_src[h] &amp;lt;= 20 &amp;amp;&amp;amp; p_src[s] &amp;gt;=48 &amp;amp;&amp;amp; p_src[v] &amp;gt;=50)
            {
                p_mask[0] = 255;
            }
        }
    }
    Mat detect;
    src.copyTo(detect, output_mask);;
    return detect;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120234042305-567562683.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;法六opencv自带肤色检测类adaptiveskindetector&quot;&gt;法六：opencv自带肤色检测类AdaptiveSkinDetector&lt;/h2&gt;
&lt;p&gt;opencv提供了下面这个好用的皮肤检测函数：&lt;/p&gt;
&lt;p&gt;CvAdaptiveSkinDetector(int samplingDivider = 1, int morphingMethod = MORPHING_METHOD_NONE);&lt;/p&gt;
&lt;p&gt;这个函数的第二个参数表示皮肤检测过程时所采用的图形学操作方式，其取值有3种可能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果为MORPHING_METHOD_ERODE，则表示只进行一次腐蚀操作；&lt;/li&gt;
&lt;li&gt;如果为MORPHING_METHOD_ERODE_ERODE，则表示连续进行2次腐蚀操作；&lt;/li&gt;
&lt;li&gt;如果为MORPHING_METHOD_ERODE_DILATE，则表示先进行一次腐蚀操作，后进行一次膨胀操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/*opencv自带肤色检测类AdaptiveSkinDetector*/
Mat AdaptiveSkinDetector_detect(Mat&amp;amp; src)
{
    IplImage *frame;
    frame = &amp;amp;IplImage(src);  //Mat -&amp;gt; IplImage
    CvAdaptiveSkinDetector filter(1, CvAdaptiveSkinDetector::MORPHING_METHOD_ERODE_DILATE);

    IplImage *maskImg = cvCreateImage(cvSize(src.cols, src.rows), IPL_DEPTH_8U, 1);
    IplImage *skinImg = cvCreateImage(cvSize(src.cols, src.rows), IPL_DEPTH_8U, 3);
    cvZero(skinImg);
    filter.process(frame, maskImg);    // process the frame
    cvCopy(frame, skinImg, maskImg);
    Mat tmp(skinImg);  //IplImage -&amp;gt; Mat
    Mat detect = tmp.clone();
    cvReleaseImage(&amp;amp;skinImg);
    cvReleaseImage(&amp;amp;maskImg);
    return detect;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171120234056680-639032421.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从效果图看来，背景多了很多白色的杂质，单从直观效果来看，貌似还不如我上面写的几个算法，难道跟场景有关系？当然，opencv自带的这个api在皮肤检测上确实相当不错的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天花了将近7个小时才撸了这篇文章出来==！这篇文章对各大主流的皮肤检测算法做了个总结和实现。其实说白了，每个算法的思想都是大同小异的，都是根据总结出来的一些经验，设定皮肤颜色的范围，再将其过滤出来，不同的只是过滤的过程在不同的颜色空间下进行而已。我们可以根据自己的应用场景，适当地修改这些范围，以获得满意的结果。可以改善的方向就是，我们可以用合适的滤波器或者形态学处理一些噪声，来使得提取出来的皮肤更为干净。&lt;/p&gt;
&lt;p&gt;完整代码可以访问&lt;a href=&quot;https://github.com/AstarLight/skin-detector&quot;&gt;我的github&lt;/a&gt;来获取~&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:45:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/7868877.html</dc:identifier>
</item>
<item>
<title>深度学习正在吞噬软件 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7868803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7868803.html</guid>
<description>&lt;blockquote readability=&quot;2.3125&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;原文作者： &lt;a href=&quot;https://petewarden.com/author/petewarden/&quot; title=&quot;View all posts by Pete Warden&quot;&gt;Pete Warden&lt;/a&gt;&lt;br/&gt;原文地址：&lt;a href=&quot;https://petewarden.com/2017/11/13/deep-learning-is-eating-software/&quot;&gt;Deep Learning is Eating Software&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-9c235f5b91ffbe52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Photo by John Watson&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几个星期前，当我和Andrej Karpathy一起喝酒的时候，我们讨论了我们认为机器学习在未来几年内的发展方向。Andrej抛出了“软件2.0”这个词，我立刻就嫉妒了，因为它抓住了我每天在数百个项目中看到的过程。我一直保持沉默，直到得到他的博客，但现在我也想扩展我的想法。&lt;/p&gt;
&lt;p&gt;模式是现有的软件项目使用明确的编程逻辑进行数据处理，负责维护的团队发现他们可以用深度学习的解决方案取代它。 我只能指出我们已经公开的字母表中的例子，比如&lt;a href=&quot;https://www.wired.com/2016/02/ai-is-changing-the-technology-behind-google-searches/&quot;&gt;upgrading search ranking&lt;/a&gt;，&lt;a href=&quot;https://deepmind.com/blog/deepmind-ai-reduces-google-data-centre-cooling-bill-40/&quot;&gt;data center energy usage&lt;/a&gt;， &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Neural_Machine_Translation&quot;&gt;language translation&lt;/a&gt;以及&lt;a href=&quot;https://deepmind.com/blog/alphago-zero-learning-scratch/&quot;&gt;solving Go&lt;/a&gt;，但这些在内部并不罕见。 我所看到的是，几乎所有具有重大逻辑的数据处理系统都可以通过应用现代机器学习来显着改善。&lt;/p&gt;
&lt;p&gt;如果用这些术语来说，这听起来可能不那么戏剧化，但是这对我们如何构建软件是一个根本性的改变。 开发人员不必编写和维护错综复杂，层次分明的逻辑关系，而必须成为&lt;a href=&quot;https://petewarden.com/2014/06/06/how-i-teach-computers-to-think/&quot;&gt;教师&lt;/a&gt;，培训数据的管理者和结果分析师。 这与我在学校所教授的编程有很大的不同，但让我最兴奋的是，一旦工具发展起来，它应该比传统的编码更容易获得。&lt;/p&gt;
&lt;p&gt;这个过程的本质是提供大量的输入示例，以及对输出的期望。这并不需要与传统编程相同的技术技能，但它确实需要对问题领域有深入的了解。这意味着，软件的用户将能够在构建它的过程中扮演更直接的角色。从本质上讲，用户正在编写自己的用户故事，并将其输入到机器中以构建他们想要的内容。&lt;/p&gt;
&lt;p&gt;Andrej在他的文章中重点关注了音频和语音识别等领域，但实际上我认为这会对更多领域产生影响。 经典的“&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf&quot;&gt;机器学习：技术债务的高利息信用卡&lt;/a&gt;”标识了一个非常常见的模式，即机器学习系统嵌入到深层软件中。 我所看到的是，通过用深度学习模式替换整个堆栈，问题越来越得到解决！ 以类比为切入点，这就像将所有债务合并为一笔较低的单笔贷款。 单一模型比一组深度互联的模块更容易改进，维护变得更容易。 对于许多大型系统来说，没有人可以声称自己实际上在做什么，所以在调试或控制方面并没有真正的损失。&lt;/p&gt;
&lt;p&gt;我知道这听起来更像是对深度学习的宣传，如果我没有看到每天发生的过程，我也很难接受，但这是真实的。比尔·盖茨(Bill Gates)曾说过：“大多数人高估了自己一年所能做的事情，却低估了他们十年后能做的事情”，这就是我对传统软件的替代态度。随着知识在开发者社区中传播，将会有很长一段时间的增长，但在10年里，我预测大多数软件作业都不会涉及编程。正如Andrej所记忆的那样，“(深度学习)比你更好!”&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:22:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7868803.html</dc:identifier>
</item>
<item>
<title>SpringMVC处理ajax请求的跨域问题和注意事项 - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/7868785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/7868785.html</guid>
<description>&lt;p&gt; .首先要知道ajax请求的核心是JavaScrip对象和XmlHttpRequest，而浏览器请求的核心是浏览器&lt;/p&gt;
&lt;p&gt;ajax请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120222754696-96052272.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120222743821-2021215167.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景一：使用ajax获取session中的user（跨域）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230048305-1380764596.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;195&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230056868-941601761.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，ajax每次访问服务器时都没有携带cookie，所以服务器每次都会分配一个新的session对象，所以ajax默认请求是直接获取不了session中的数据的。因此，如果我们想要通过ajax获取当前浏览器的session，我们必须保证每次发送请求都要携带cookie以确保获取的事统一个session。&lt;/p&gt;
&lt;p&gt;解决方法：step1.服务器设置接收ajax发送的cookie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HandlerInterceptorAdapter&lt;br/&gt;//跨域设置&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CrossInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HandlerInterceptorAdapter {
　　
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;,&quot;http://localhost:8080&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Methods&quot;,&quot;*&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Max-Age&quot;,&quot;100&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许客户端发送cookies true表示接收，false不接受 默认为false？&lt;/span&gt;
        response.addHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.preHandle(request, response, handler);
    } 

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2 。设置ajax请求携带cookie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    $.ajax({
        url: url&lt;/span&gt;+'/checkout.action'&lt;span&gt;,
        type: &lt;/span&gt;'GET'&lt;span&gt;,
        dataType: &lt;/span&gt;''&lt;span&gt;,
        data: {verifyCode: VerificationCodeInput.value},
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加跨域&lt;/span&gt;
       async: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
        xhrFields: {  
            withCredentials: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
        },  
        crossDomain: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
            console.log(data);
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注： &lt;span&gt;xhrFields: { withCredentials: &lt;span&gt;true &lt;span&gt;}, crossDomain: &lt;span&gt;true&lt;span&gt;, 一定要加上！！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230940446-1221298777.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;215&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230948993-1668735608.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样就可以愉快的玩耍了！　　　　&lt;/p&gt;

&lt;p&gt;场景二：当用户需要校验session是否登陆（没有登陆跳转到登陆页面）&lt;/p&gt;
&lt;p&gt;基于场景一，已经解决了回话问题但是在使用SpringMVC中&lt;/p&gt;
&lt;p&gt;　　　　    request.getRequestDispatcher(xxxx.html&quot;).forward(request, response);&lt;br/&gt;    　　　　response.sendRedirect(&quot;http://www.baidu.com&quot;);&lt;/p&gt;
&lt;p&gt;　会报错。因为当服务器转发或者重定向时返回的是一个页面，因为只有浏览器才能解析显示页面，而ajax的对象却不能，所以会报错错。&lt;/p&gt;

&lt;p&gt;　解决办法：因为ajax请求对象不能解析显示页面，所以不能直接转发或重定向，这时我们需要绕过服务器，直接使用浏览器跳转页面，但是对于session过期（用户没有登陆）我们要给浏览器一个反馈，我们可以给浏览器一个大于等于600的错误码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   　　 String requestType = request.getHeader(&quot;X-Requested-With&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requestType != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &quot;XMLHttpRequest&quot;&lt;span&gt;.equalsIgnoreCase(requestType.trim())) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是ajax请求就设置一个自定义响应头&lt;/span&gt;
            response.setHeader(&quot;sessionStatus&quot;, &quot;timeout&quot;&lt;span&gt;);&lt;br/&gt;　　　　　　　&lt;span&gt; &lt;span&gt;/&lt;span&gt;/设置错误码以及错误码提示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            response.sendError(&lt;/span&gt;666, &quot;session timeout&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 同时要对ajax设置全局options　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajaxSetup({
  type:&lt;/span&gt;'post'&lt;span&gt;,
  complete:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(xhr, ts){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;XMLHttpRequest, textStatus&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; sessionStatus = xhr.getResponseHeader('sessionstatus'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sessionStatus == 'timeout'&lt;span&gt;) {
          alert(&lt;/span&gt;'用户没有登陆，请登录！'&lt;span&gt;);
          window.top.location.href &lt;/span&gt;= 'Login.html'&lt;span&gt;;
      }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样就可以通过浏览器进行页面跳转了！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:17:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiangchn/p/7868785.html</dc:identifier>
</item>
<item>
<title>设计模式-原型模式(06) - 秋夜雨巷</title>
<link>http://www.cnblogs.com/aeolian/p/7853477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aeolian/p/7853477.html</guid>
<description>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;　　原型（Prototype Pattern）是一个简单的设计模式。原型模式的英文原话是：Specify the kind of objects to create using a prototypical instance，and create new objects by copying this prototype.意思是：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。&lt;/p&gt;
&lt;p&gt;　　原型模式有三种角色：&lt;/p&gt;
&lt;p&gt;　　1.客户（Client）角色：该角色提出创建对象的请求。&lt;br/&gt;　　2.抽象原型（Prototype）：该角色是一个抽象角色，通常由一个java接口或抽象类实现，给出所有的具体原型类所需要的接口。&lt;br/&gt;　　3.具体原型（Concrete Prototype）角色：该角色是被复制的对象，必须实现抽象原型接口。&lt;/p&gt;
&lt;p&gt;java中内置了克隆机制。object类具有一个clone（）方法，能够实现对对象的克隆，是一个类支持克隆只需要两步：&lt;/p&gt;
&lt;p&gt;　　1.实现Cloneable接口。&lt;br/&gt;　　2.覆盖Object的clone（）方法，完成对象的克隆操作，通常只需要调用Object的clone()方法即可。为了使外部能够调用此类的clone（）方法，可以将访问修饰符改为public。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象原型角色(Prototype)
 * 给出具体原型类复制所需要的接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Prototype {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆方法&lt;/span&gt;
&lt;span&gt;    Prototype clone();
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 具体原型工厂类
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcretePrototype &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Prototype {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Prototype clone() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Prototype)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; operation(Prototype example) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到example&lt;/span&gt;
        Prototype prototype =&lt;span&gt; example.clone();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;原型模式的优点&lt;/h2&gt;
&lt;p&gt;　　1.性能优良：原型模式是对内存中二进制流的拷贝，要比直接new一个对象性能好，特别是当一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。&lt;/p&gt;
&lt;p&gt;　　2.逃避构造函数的约束。这既是优点也是缺点，直接在内存中拷贝对象，构造函数是不会执行的，因此减少了约束，不过这一点需要在实际应用时进行权衡考虑。&lt;/p&gt;
&lt;h2&gt;原型模式的使用场景&lt;/h2&gt;
&lt;p&gt;　　1.资源优化场景，类初始化时需要消化非常多的资源，这个资源包括数据、硬件资源等。&lt;/p&gt;
&lt;p&gt;　　2.性能和安全要求的场景，如果通过new产生一个对象需要非常繁琐的数据准备和访问权限，则可以使用原型模式。&lt;/p&gt;
&lt;p&gt;　　3.一个对象多个修改者的场景，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值，可以考虑使用原型模式拷贝多个对象供调用者使用。&lt;/p&gt;
&lt;p&gt;在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现。原型模式通过clone（）方法创建一个对象，然后由工厂方法提供给调用者。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 实现clone接口,实现了clone方法,是实现克隆的关键
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mail &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收件人&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String receiver;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件标题&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String subject;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;称谓&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String appellation;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String contxt;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾部&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String tail;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mail(String subject,String contxt) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subject =&lt;span&gt; subject;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contxt =&lt;span&gt; contxt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mail clone() {
        Mail mail &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            mail&lt;/span&gt;=(Mail) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
            System.out.println(&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.toString());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;super指的是被调用的那个对象&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mail;
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 调用
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendMailDemo {
    Map students &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedHashMap();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个原型mail&lt;/span&gt;
        Mail mail = &lt;span&gt;new&lt;/span&gt; Mail(&quot;邮件标题&quot;, &quot;邮件内容&quot;&lt;span&gt;);
        mail.setTail(&lt;/span&gt;&quot;2017-11-20&quot;&lt;span&gt;);
        SendMailDemo sendMailDemo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendMailDemo();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有学生&lt;/span&gt;
        Map students=&lt;span&gt;sendMailDemo.getStudent();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object name : students.keySet()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆邮件&lt;/span&gt;
            Mail cloneMail =&lt;span&gt; mail.clone();
            cloneMail.setAppellation(name.toString());
            cloneMail.setReceiver(students.get(name).toString());
            sendMailDemo.sendMail(cloneMail);
        }
        
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map getStudent(){
        students.put(&lt;/span&gt;&quot;studentone&quot;, &quot;1@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studenttwo&quot;, &quot;2@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentthree&quot;, &quot;3@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentfour&quot;, &quot;4@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentfive&quot;, &quot;5@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentsix&quot;, &quot;6@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentseven&quot;, &quot;7@foxmail.com&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; students;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMail(Mail mail){
        System.out.println(&lt;/span&gt;&quot;标题:&quot;+mail.getSubject()+&quot;\t收件人邮箱:&quot;+mail.getReceiver()+&quot;\t正文:&quot;+mail.getAppellation()+mail.getContxt()+&quot;\t...已发送&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AutKevin/JAVA/tree/master/DesignPatterns/PrototypePattern&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 15:14:00 +0000</pubDate>
<dc:creator>秋夜雨巷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aeolian/p/7853477.html</dc:identifier>
</item>
<item>
<title>使用AspectCore动态代理 - Lemon丶</title>
<link>http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近越来越多的同学关注到&lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot;&gt;AspectCore&lt;/a&gt;，并且提出不少中肯的建议，其中最多的提议是希望能够看到更多的关于AspectCore使用方式的文章和Demo。那么在这篇文章里，我们就来聊聊AspectCore核心之一的动态代理。&lt;/p&gt;
&lt;h3 id=&quot;动态代理&quot;&gt;动态代理&lt;/h3&gt;
&lt;p&gt;在.NET平台中，静态织入和动态代理是实现AOP的两种方式。其中静态织入在编译时通过在MSBiuld执行自定义的Build Task来拦截编译过程，在生成的程序集里插入自己的IL。而动态代理则是在运行时通过Emit技术生成动态程序集和动态代理类型从而对目标方法进行拦截。不管那种方式，都需要对MSIL有足够的理解，如果读者想要学习MSIL相关的技术，我在这里推荐&lt;a href=&quot;https://book.douban.com/subject/4037255/&quot;&gt;《NET探秘MSIL权威指南》&lt;/a&gt;一书。&lt;br/&gt;AspectCore使用了动态代理作为AOP的实现，而不使用理论上性能更优的静态织入实现，是由于个人觉得动态代理方式可以做到更好的IoC进行集成并且能够在切面中获取更多的运行时元数据信息，并且在经过不断优化后，AspectCore动态代理的性能已经不落后静态织入的实现方式。&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;在之前的文章里，只是简单的介绍了AspectCore，导致了很多同学不知道如何在项目里使用AspectCore(&lt;code&gt;^~^,求轻拍~&lt;/code&gt;)。下面就来讲一下如何在IoC环境和非IoC环境里使用AspectCore的AOP。&lt;br/&gt;首先通过nuget获取AspectCore：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Core&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore中动态代理api在&lt;code&gt;AspectCore.DynamicProxy&lt;/code&gt;命名空间中，所以我们需要先引入命名空间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using AspectCore.DynamicProxy;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在非IoC环境中，只使用AOP的话，AspectCore提供了&lt;code&gt;ProxyGeneratorBuilder&lt;/code&gt;作为代理生成器创建的入口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ProxyGeneratorBuilder proxyGeneratorBuilder = new ProxyGeneratorBuilder();
IProxyGenerator proxyGenerator = proxyGeneratorBuilder.Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IProxyGenerator&lt;/code&gt;提供了&lt;code&gt;CreateClassProxy&lt;/code&gt;方法创建class代理和&lt;code&gt;CreateInterfaceProxy&lt;/code&gt;方法创建interface代理,创建的代理类被定义在命名为&lt;code&gt;AspectCore.DynamicProxy.Generator&lt;/code&gt;的动态程序集中，并且代理类使用&lt;code&gt;AspectCore.DynamicGenerated&lt;/code&gt;命名空间。&lt;br/&gt;我们先来定义一个简单的拦截器，接着定义一个interface和它的简单实现，并创建interface的代理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        ProxyGeneratorBuilder proxyGeneratorBuilder = new ProxyGeneratorBuilder();
        IProxyGenerator proxyGenerator = proxyGeneratorBuilder.Build();
        SampleInterface sampleInterface = proxyGenerator.CreateInterfaceProxy&amp;lt;SampleInterface&amp;gt;();
        Console.WriteLine(sampleInterface);
        sampleInterface.Foo();
        Console.ReadKey();
    }
}

public class SampleInterceptor : AbstractInterceptorAttribute
{
    public override Task Invoke(AspectContext context, AspectDelegate next)
    {
        Console.WriteLine(&quot;call interceptor&quot;);
        return context.Invoke(next);
    }
}

public class SampleClass : SampleInterface
{
    public virtual void Foo() { }
}

[SampleInterceptor]
public interface SampleInterface
{
    void Foo();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleInterface1
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，IProxyGenerator提供了若干重载的扩展方法来创建已有类或接口实例的代理，可在&lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/core/src/AspectCore.Core/DynamicProxy/Extensions/ProxyGeneratorExtensions.cs&quot;&gt;ProxyGeneratorExtensions&lt;/a&gt;中找到并使用它们。&lt;/p&gt;
&lt;h3 id=&quot;在ioc中使用aspectcore.dynamicproxy&quot;&gt;在IoC中使用AspectCore.DynamicProxy&lt;/h3&gt;
&lt;p&gt;AspectCore在设计之初就考虑AOP和IoC的集成使用，并提供AOP抽象接口以兼容不同IoC，目前已实现和AspectCore.DynamicProxy集成的IoC框架有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AspectCore.Injector(AspectCore Framework的内置IoC)&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.DependencyInjection(Asp.Net Core的内置DI框架)&lt;/li&gt;
&lt;li&gt;Autofac&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们分别看一下在三个IoC中如何使用AspectCore.DynamicProxy。&lt;/p&gt;
&lt;h4 id=&quot;aspectcore.injector&quot;&gt;AspectCore.Injector&lt;/h4&gt;
&lt;p&gt;AspectCore.Injector中内置了对AspectCore.DynamicProxy的支持，所以我们可以直接使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IServiceContainer serviceContainer = new ServiceContainer();
serviceContainer.AddType&amp;lt;SampleInterface, SampleClass&amp;gt;();
IServiceResolver serviceResolver = serviceContainer.Build();
SampleInterface sampleInterface = serviceResolver.Resolve&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;microsoft.extensions.dependencyinjection&quot;&gt;Microsoft.Extensions.DependencyInjection&lt;/h4&gt;
&lt;p&gt;AspectCore提供&lt;code&gt;AspectCore.Extensions.DependencyInjection&lt;/code&gt;包集成Microsoft.Extensions.DependencyInjection和AspectCore.DynamicProxy。&lt;br/&gt;通过nuget获取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Extensions.DependencyInjection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore提供了针对IServiceCollection的扩展方法&lt;code&gt;AddDynamicProxy&lt;/code&gt;注册动态代理的接口和相关拦截器配置，并需要使用&lt;code&gt;BuildAspectCoreServiceProvider&lt;/code&gt;创建被DynamicProxy接管的ServiceProvider：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IServiceCollection services = new ServiceCollection();
services.AddTransient&amp;lt;SampleInterface, SampleClass&amp;gt;();

services.AddDynamicProxy();
IServiceProvider serviceProvider = services.BuildAspectCoreServiceProvider();

SampleInterface sampleInterface = serviceProvider.GetService&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;autofac&quot;&gt;Autofac&lt;/h4&gt;
&lt;p&gt;AspectCore提供&lt;code&gt;AspectCore.Extensions.Autofac&lt;/code&gt;包集成Autofac和AspectCore.DynamicProxy。&lt;br/&gt;通过nuget获取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Extensions.Autofac&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore提供了针对ContainerBuilder的扩展方法&lt;code&gt;RegisterDynamicProxy&lt;/code&gt;注册动态代理的接口和相关拦截器配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ContainerBuilder builder = new ContainerBuilder();
builder.RegisterType&amp;lt;SampleClass&amp;gt;().As&amp;lt;SampleInterface&amp;gt;();

builder.RegisterDynamicProxy();

var container = builder.Build();
SampleInterface sampleInterface = container.Resolve&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;有问题反馈&quot;&gt;有问题反馈&lt;/h3&gt;
&lt;p&gt;如果您有任何问题，请提交 &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/issues/new&quot;&gt;Issue&lt;/a&gt; 给我们。&lt;br/&gt;Github : &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework&lt;/a&gt;&lt;br/&gt;AspectCore QQ群: 306531723&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:13:00 +0000</pubDate>
<dc:creator>Lemon丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</dc:identifier>
</item>
<item>
<title>从零一起学Spring Boot之LayIM项目长成记（五）websocket - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/7828743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/7828743.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　距离上一篇已经比较久的时间了，项目也是开了个头。并且，由于网上的关于Spring Boot的websocket讲解也比较多。于是我采用了另外的一个通讯框架 &lt;strong&gt;t-io&lt;/strong&gt; 来实现LayIM中的通讯功能。本篇会着重介绍我在研究与开发过程中踩过的坑和比较花费的时间的部分。&lt;/p&gt;
&lt;h2&gt;WebSocket&lt;/h2&gt;
&lt;p&gt;　　在研究 &lt;strong&gt;t-io&lt;/strong&gt; 的时候，我已经写过关于t-io框架的一些简单例子分析以及框架中关于 websocket 中的编解码代码分析等，有兴趣的同学可以先看一下。因为 在LayIM项目中我会是用到 Showcase Demo 中的设计思路。&lt;/p&gt;
&lt;p&gt;　　&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/panzi/p/7814062.html&quot;&gt;通讯框架 t-io 学习——给初学者的Demo：ShowCase设计分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/panzi/p/7823118.html&quot;&gt;通讯框架 t-io 学习——websocket 部分源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果你潜心想学到这些东西的话，本人还是建议静下心来看看。为什么不用Spring Boot 封装好的websocket呢？因为它封装的太完备，许多业务不能定制。而通过t-io框架自己开发websocket端，就比较灵活了。甚至可以打造专门为LayIM定制的websocket服务，在讲解我的开发之路之前，也向大家推荐更完备的解决方案 &lt;strong&gt;tio-im&lt;/strong&gt;，当然，我也是借鉴该源代码的设计思路。不过它的实现更加强大，由于我的水平有限，我只能照猫画虎，胡乱写了一通。不过也还是能用的。&lt;/p&gt;
&lt;p&gt;　　tio-im 地址：&lt;a href=&quot;https://gitee.com/xchao/tio-im&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xchao/tio-im&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;项目实战&lt;/h2&gt;
&lt;p&gt;　　前几篇已经实现了LayIM主要界面的数据加载功能。接下来就是最核心的部分，通讯。实现思路很多，这里呢我使用了 基于 t-io 通讯框架的 websocket。在进入详细代码之前，我们先分析LayIM中用到的一些功能点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;登录功能  &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单聊功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;群聊功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他自定义消息提醒功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等等。。。。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;登录的目的是过滤非法请求，如果有一个非法用户请求websocket服务，直接返回403或者401即可。&lt;/p&gt;
&lt;p&gt;　　单聊，群聊这个就不用解释了&lt;/p&gt;
&lt;p&gt;　　其他自定义消息提醒，比如：时时加好友消息，广播消息，审核消息等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t-io&lt;/strong&gt; 中的对外发送消息接口在 &lt;strong&gt;Aio.java&lt;/strong&gt; 中实现。（下文中只列取部分接口，以及在LayIM项目中用到的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定用户&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bindUser(ChannelContext channelContext, String userid)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给用户 &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean sendToUser(GroupContext groupContext, String userid, Packet packet)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送到群组&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendToGroup(GroupContext groupContext, String group, Packet packet) 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给所有人&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendToAll(GroupContext groupContext, Packet packet)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送到指定channel &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Boolean send(ChannelContext channelContext, Packet packet) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　开工之前呢，我们还要开发消息的编解码类（框架中已经实现），消息监听事件的处理，由于对于LayIM我们有基于业务的定制开发，所以会改一部分源代码。那我这里呢就把框架中部分源码粘贴到项目中，然后进行代码修改。不过像比如：握手流程，升级Websocket连接，解析byte[] 这些功能我们就没必要自己去做了，想要学习的话，可以看着源代码自己去研究。好，我们进入代码部分。&lt;/p&gt;
&lt;h2&gt;代码剖析&lt;/h2&gt;
&lt;p&gt;　　首先实现  &lt;strong&gt;IWsMsgHandler&lt;/strong&gt;接口。这个接口定义在 &lt;span class=&quot;kn&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;strong&gt;org&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;tio&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;websocket&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;handler&lt;/strong&gt;  包中，代码如下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWsMsgHandler {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * 对httpResponse参数进行补充并返回，如果返回null表示不想和对方建立连接，框架会断开连接，如果返回非null，框架会把这个对象发送给对方
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponse handshake(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onBytes(WsRequest wsRequest, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onClose(WsRequest wsRequest, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onText(WsRequest wsRequest, String text, ChannelContext channelContext) throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一般我们会在公开的这些接口实现中做些事情，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object onText(WsRequest wsRequest, String s, ChannelContext channelContext) throws Exception {
        logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到text消息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)；
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息业务处理逻辑&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息发送成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不过既然这次我们可以自己写websocket内部的业务逻辑，所以，这些接口我们就不在处理主要业务逻辑。那么主要业务逻辑在哪里处理呢？ 我把他放在了 decode 方法之后。可能，大伙看到这里有些晕，下面我画一张图来从大局上介绍一个消息的发送处理流程。这里我以单聊发送消息举例。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120151819180-789901606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先是，客户端连接服务器。先走握手流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　if&lt;/span&gt; (!&lt;span&gt;wsSessionContext.isHandshaked()) {
            HttpRequest request &lt;/span&gt;=&lt;span&gt; HttpRequestDecoder.decode(buffer, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
　　　　　　　//升级到websokcet协议
            HttpResponse httpResponse &lt;/span&gt;=&lt;span&gt; Protocol.updateToWebSocket(request, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (httpResponse == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AioDecodeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http协议升级到websocket协议失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            wsSessionContext.setHandshakeRequestPacket(request);
            wsSessionContext.setHandshakeResponsePacket(httpResponse);

            WsRequest wsRequestPacket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WsRequest();
            wsRequestPacket.setHandShake(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wsRequestPacket;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
　　　　　　　WsSessionContext wsSessionContext =&lt;span&gt; (WsSessionContext) channelContext.getAttribute();
            HttpRequest request &lt;/span&gt;=&lt;span&gt; wsSessionContext.getHandshakeRequestPacket();
            HttpResponse httpResponse &lt;/span&gt;=&lt;span&gt; wsSessionContext.getHandshakeResponsePacket();&lt;br/&gt;　　　　　　　//这里通过handshake接口实现的返回值，判断是否同意握手
            HttpResponse r &lt;/span&gt;=&lt;span&gt; wsMsgHandler.handshake(request, httpResponse, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                Aio.remove(channelContext, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;业务层不同意握手&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上文第二段代码中的 wsMsgHandler.handshake 方法，这里一般直接返回默认的 httpReponse即可，代表（框架层）握手成功。但是我们可以在接口中自定义一些业务逻辑，比如用户判断之类的逻辑，然后决定是否同意握手流程。&lt;/p&gt;
&lt;p&gt;　　这里有一个小细节需要注意，无论是握手还是业务登录请求，成功之后，都需要将用户绑定到当前的上下文（channelContext）中。调用 &lt;strong&gt;Aio.bindUser&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;p&gt;　　下图为简版的聊天发送消息流程：客户端A 发送消息到客户端B。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120154200102-1151133974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正如上文中所说，编解码我们不用过多的关心，那么我们需要关注的部分就是业务处理了。设计思路呢也很容易想到，首先，我们有不同的消息类型。这个消息类型由客户端决定。如果传入了错误的消息类型，就抛出异常或者返回未知消息处理即可。消息处理类结构设计如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120155419680-31103644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是不是很简单，一个通用业务处理入口，将消息转化为友好的类实体，然后在具体的消息处理器中处理业务逻辑即可。&lt;/p&gt;
&lt;p&gt;　　LayimAbsMsgProcessor 核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 这里采用showcase中的设计思路（反序列化消息之后，由具体的消息处理器处理）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WsResponse process(WsRequest layimPacket, ChannelContext channelContext) throws Exception {
        Class&lt;/span&gt;&amp;lt;T&amp;gt; clazz =&lt;span&gt; getBodyClass();
        T body &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (layimPacket.getBody() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取json格式的数据　&lt;/span&gt;
            String json =&lt;span&gt; ByteUtil.toText(layimPacket.getBody());
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串转化为具体类型的对象&lt;/span&gt;
            body =&lt;span&gt; Json.toBean(json, clazz);
        }
　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过具体处理类处理消息对象&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; process(layimPacket, body, channelContext);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;abstract&lt;/span&gt; WsResponse process(WsRequest layimPacket,T body,ChannelContext channelContext) throws  Exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ClientToClientMsgProcessor 核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WsResponse process(WsRequest layimPacket, ChatRequestBody body, ChannelContext channelContext) throws Exception {
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;requestBody 转化为接收端的消息类型&lt;/span&gt;
        ClientToClientMsgBody msgBody =&lt;span&gt; BodyConvert.getInstance().convertToMsgBody(body,channelContext);
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息包装，返回WsResponse&lt;/span&gt;
        WsResponse response =&lt;span&gt; BodyConvert.getInstance().convertToTextResponse(msgBody);
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到对方的channelContext&lt;/span&gt;
        ChannelContext toChannelContext =&lt;span&gt; Aio.getChannelContextByUserid(channelContext.getGroupContext(),body.getToId());
        &lt;/span&gt;&lt;span&gt;//发送给对方&lt;/span&gt;
&lt;span&gt;        Aio.send(toChannelContext,response);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对接spring boot&lt;/h2&gt;
&lt;p&gt;　　那么如何启动websocket服务呢，一般框架中都是绑定好的。这里呢，我们特殊处理一下，刚开始我是手动调用start方法，后来研究了一下spring boot starter。下面简单介绍一下starter的用法。&lt;/p&gt;
&lt;p&gt;　　首先建立一个配置类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layim.websocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LayimServerProperties {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LayimServerProperties(){
        port &lt;/span&gt;= &lt;span&gt;8081&lt;/span&gt;&lt;span&gt;;
        heartBeatTimeout &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ip &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getter  setter&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heartBeatTimeout;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ip;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二部，新建一个 AutoConfig类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableConfigurationProperties(LayimServerProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LayimWebsocketServerAutoConfig {

    @Autowired
    LayimServerProperties properties;

    @Bean
    LayimWebsocketStarter layimWebsocketStarter() throws Exception{
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化配置信息&lt;/span&gt;
        LayimServerConfig config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LayimServerConfig(properties.getPort());
        config.setBindIp(properties.getIp());
        config.setHeartBeatTimeout(properties.getHeartBeatTimeout());

        LayimWebsocketStarter layimWebsocketStarter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LayimWebsocketStarter(config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务&lt;/span&gt;
&lt;span&gt;        layimWebsocketStarter.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; layimWebsocketStarter;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第三步，在resources文件夹下，新建META-INF文件夹，在新建一个spring.factories文件，文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
org.springframework.boot.autoconfigure.EnableAutoConfiguration= com.fyp.layim.im.server.LayimWebsocketServerAutoConfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　OK，到这里我们配置一下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223315368-270528247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后启动程序。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223412602-931294591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　   启动成功！&lt;/p&gt;
&lt;h2&gt;项目演示&lt;/h2&gt;
&lt;p&gt;　　啰啰嗦嗦的讲了这么多，还是给大家看一下演示。&lt;/p&gt;
&lt;p&gt;　　用户 1，2 链接服务器。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223926149-369053253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户2给用户1发送消息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120224041993-2070878173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看上面的只是演示消息能够顺利发送，下面的日志打印图可以看出来服务器的处理流程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120230906555-431992049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　到此为止我们已经可以实现通讯了，但是这些还不够还有更多的业务去处理。不过没关系，通讯实现了，后边的就不难了。其实更多的是细节的把握，比如用户退群，用户下线，统计用户在线个数等。&lt;/p&gt;
&lt;p&gt;　　下期预告：从零一起学Spring Boot之LayIM项目长成记（五）用户登录验证和单聊群聊的实现&lt;/p&gt;
&lt;p&gt;　　GitHub：&lt;a href=&quot;https://github.com/fanpan26/SpringBootLayIM&quot; target=&quot;_blank&quot;&gt;https://github.com/fanpan26/SpringBootLayIM&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:10:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panzi/p/7828743.html</dc:identifier>
</item>
</channel>
</rss>