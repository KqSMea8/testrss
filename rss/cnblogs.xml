<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IP地址转换函数——inet_pton  inet_ntop inet_aton inet_addr inet_ntoa - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</guid>
<description>&lt;h3 id=&quot;inet_pton&quot;&gt;inet_pton&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_pton&lt;/strong&gt; - 将 IPv4 和 IPv6 地址从点分十进制转换为二进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;arpa/inet.h&amp;gt;
    int inet_pton(int af, const char *src, void *dst);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    该函数将字符串&lt;code&gt;src&lt;/code&gt;转换为&lt;code&gt;af&lt;/code&gt;地址类型协议簇的网络地址，并存储到&lt;code&gt;dst&lt;/code&gt;中。对于&lt;code&gt;af&lt;/code&gt;参数，必须为&lt;code&gt;AF_INET&lt;/code&gt;或&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RETURN VALUE&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inept_pton&lt;/code&gt;转换成功则返回1,对于指定的地址类型协议簇，如果不是一个有效的网络地址，将转换失败，返回 0,如果指定的地址类型协议簇不合法，将返回-1并，并且&lt;code&gt;errno&lt;/code&gt;设置为&lt;code&gt;EAFNOSUPPORT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTES&lt;/strong&gt;&lt;br/&gt;    不同于&lt;code&gt;inept_aton&lt;/code&gt;和&lt;code&gt;inept——addr&lt;/code&gt;，&lt;code&gt;inept_pton&lt;/code&gt;支持 IPv6 地址。另一方面，&lt;code&gt;inet_pton&lt;/code&gt;仅支持点分十进制表示的 IPv4 地址，而&lt;code&gt;inet_aton&lt;/code&gt;和&lt;code&gt;inept_addr&lt;/code&gt;接受更通用的数字和点表示法（十六进制和八进制数字格式，以及格式不需要显式写入所有四个字节）。&lt;/p&gt;
&lt;h3 id=&quot;inet_ntop&quot;&gt;inet_ntop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_ntop&lt;/strong&gt; - 将 IPv4 和 IPv6 地址从二进制转换为点分十进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;arpa/inet.h&amp;gt;
    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    该函数将地址类型协议簇为&lt;code&gt;af&lt;/code&gt;的网络地址&lt;code&gt;src&lt;/code&gt;转换为字符串，并将其存储到&lt;code&gt;dst&lt;/code&gt;中，其中&lt;code&gt;dst&lt;/code&gt;不能是空指针。调用者在参数&lt;code&gt;size&lt;/code&gt;中指定可使用的缓冲字节数。&lt;br/&gt;    &lt;code&gt;inet_ntop&lt;/code&gt;拓展自&lt;code&gt;inet_ntoa&lt;/code&gt;来支持多种地址类型协议簇，&lt;code&gt;inet_ntoa&lt;/code&gt;现在已经被弃用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RETURN VALUE&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inet_ntop&lt;/code&gt;执行成功，返回一个指向&lt;code&gt;dst&lt;/code&gt;的非空指针，如果执行失败，将返回&lt;code&gt;NULL&lt;/code&gt;，并且&lt;code&gt;errno&lt;/code&gt;设置为相应的错误类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ERRORS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EAFNOSUPPORT&lt;br/&gt;&lt;code&gt;af&lt;/code&gt;并不是一个合法的地址类型协议簇&lt;/li&gt;
&lt;li&gt;ENOSPC&lt;br/&gt;要转换的字符串地址&lt;code&gt;src&lt;/code&gt;其字节大小超过了给定的缓冲字节大小&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;example&quot;&gt;EXAMPLE&lt;/h3&gt;
&lt;p&gt;    以下是关于&lt;code&gt;inet_pton&lt;/code&gt;和&lt;code&gt;inet_ntop&lt;/code&gt;函数使用的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[])
{
   unsigned char buf[sizeof(struct in6_addr)];
   int domain, s;
   char str[INET6_ADDRSTRLEN];

   if (argc != 3) {
       fprintf(stderr, &quot;Usage: %s {i4|i6|&amp;lt;num&amp;gt;} string\n&quot;, argv[0]);
       exit(EXIT_FAILURE);
   }

   domain = (strcmp(argv[1], &quot;i4&quot;) == 0) ? AF_INET :
            (strcmp(argv[1], &quot;i6&quot;) == 0) ? AF_INET6 : atoi(argv[1]);

   s = inet_pton(domain, argv[2], buf);
   if (s &amp;lt;= 0) {
       if (s == 0)
           fprintf(stderr, &quot;Not in presentation format&quot;);
       else
           perror(&quot;inet_pton&quot;);
       exit(EXIT_FAILURE);
   }

   if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {
       perror(&quot;inet_ntop&quot;);
       exit(EXIT_FAILURE);
   }

   printf(&quot;%s\n&quot;, str);

   exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;inet_aton-inet_addr-inet_ntoa&quot;&gt;inet_aton inet_addr inet_ntoa&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_aton&lt;/strong&gt;, &lt;strong&gt;inet_addr&lt;/strong&gt;, &lt;strong&gt;inet_ntoa&lt;/strong&gt; - 网络地址操作例程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;sys/socket.h&amp;gt;
    #include &amp;lt;netinet/in.h&amp;gt;
    #include &amp;lt;arpa/inet.h&amp;gt;
    
    typedef uint32_t in_addr_t;
    struct in_addr{
        in_addr_t s_addr;
    };

    int inet_aton(const char *cp, struct in_addr *inp);
    in_addr_t inet_addr(const char *cp);
    char *inet_ntoa(struct in_addr in);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inet_aton&lt;/code&gt;函数将网络主机地址&lt;code&gt;cp&lt;/code&gt;从 IPv4 的数字点表示形式转换为二进制形式（以网络字节顺序）并且把它保存在&lt;code&gt;inp&lt;/code&gt;指针。如果地址是合法的，那么&lt;code&gt;inet_aton&lt;/code&gt;函数返回非0值，反之返回0值。&lt;code&gt;cp&lt;/code&gt;中提供的地址可以要有以下几种格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;u&gt;a.b.c.d&lt;/u&gt; 四个数字部分中的每一个指定地址的一个字节，字节按从左到右的顺序分配以产生二进制地址。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;a.b.c&lt;/u&gt; a和b指定二进制地址的前两个字节,c被解释为16位值,它定义二进制地址的最右边两个字节。此表示法适用于指定（过时的）B类网络地址。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;a.b&lt;/u&gt; a指定二进制地址的第一个字节,b被解释为24位值,它定义了二进制地址的最右边三个字节。此表示法适用于指定（过时的）A类网络地址。&lt;/li&gt;
&lt;li&gt;a a被解释为32位值,直接存储到二进制地址中而不进行任何字节重新排列。&lt;br/&gt;    在所有上述形式中，虚线标示的地址格式可以用十进制，八进制（带前导0）或十六进制指定（前导0X）。任何这些形式的地址统称为IPV4数字和点符号。使用正好四个十进制数称为 IPv4 点分十进制表示法。&lt;br/&gt;    如果提供的字符串地址被成功转换，&lt;code&gt;inet_aton&lt;/code&gt;函数返回1,如果提供的字符串地址不合法，返回0（此时&lt;code&gt;errno&lt;/code&gt;不会被设置为错误）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;code&gt;inet_addr&lt;/code&gt;函数将网络主机地址&lt;code&gt;cp&lt;/code&gt;从 IPv4 的数字点表示形式转换为以网络字节顺序的二进制形式。如果输入不合法，&lt;code&gt;INADDR_NONE&lt;/code&gt;（通常为-1）被返回。这个函数存在一个问题，因为-1是一个合法的地址（255.255.255.255）。可以使用&lt;code&gt;inet_aton&lt;/code&gt;函数、&lt;code&gt;inet_pton&lt;/code&gt;函数或者&lt;code&gt;getaddrinfo&lt;/code&gt;函数来代替使用它，这些函数提供了一种更清晰的方式来指示错误返回。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;inet_ntoa&lt;/code&gt;函数将网络主机地址&lt;code&gt;in&lt;/code&gt;转换为点分十格式的 IPv4 地址。该字符串在静态分配的缓冲区中返回，后续调用将覆盖该缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTES&lt;/strong&gt;&lt;br/&gt;    在 x86 架构中，主机字节顺序首先是最低有效字节（小端），而在因特网上使用的网络字节顺序是最高有效字节（大端）。&lt;/p&gt;
&lt;h3 id=&quot;example-1&quot;&gt;EXAMPLE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[])
{
   unsigned char buf[sizeof(struct in6_addr)];
   int domain, s;
   char str[INET6_ADDRSTRLEN];

   if (argc != 3) {
       fprintf(stderr, &quot;Usage: %s {i4|i6|&amp;lt;num&amp;gt;} string\n&quot;, argv[0]);
       exit(EXIT_FAILURE);
   }

   domain = (strcmp(argv[1], &quot;i4&quot;) == 0) ? AF_INET :
            (strcmp(argv[1], &quot;i6&quot;) == 0) ? AF_INET6 : atoi(argv[1]);

   s = inet_pton(domain, argv[2], buf);
   if (s &amp;lt;= 0) {
       if (s == 0)
           fprintf(stderr, &quot;Not in presentation format&quot;);
       else
           perror(&quot;inet_pton&quot;);
       exit(EXIT_FAILURE);
   }

   if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {
       perror(&quot;inet_ntop&quot;);
       exit(EXIT_FAILURE);
   }

   printf(&quot;%s\n&quot;, str);

   exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 15:48:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</dc:identifier>
</item>
<item>
<title>Spring IOC - KristinLee</title>
<link>http://www.cnblogs.com/Hangtutu/p/9386045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hangtutu/p/9386045.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring框架为什么如此流行?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原来Spring框架解决了一个很关键的问题，它可以把对象之间的依赖关系转为用配置文件来管理，也就是它的依赖注入机制。IOC容器用来管理这些Bean，管理Bean的关系以及生命周期，然而这与之前将应用程序主动new对象不同，Spring实现使用IOC容器创建对象，对象的获取方式反转了，所以IOC容器也称为控制反转。面对繁琐的依赖关系，我们不用一个一个去new对象，直接使用IOC创建好的对象，这也正是IOC的方便之处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring 核心组件&lt;/strong&gt;：Bean Context，Core&lt;/p&gt;
&lt;h3&gt;Bean&lt;/h3&gt;
&lt;p&gt;Bean组件在org.springframework.beans包下，这个包下所有的类解决了Bean的定义，创建以及解析。&lt;/p&gt;
&lt;p&gt;1.Bean的定义：主要有BeanDefinition描述，也可以说Spring中的Bean就是BeanDefinition的实例。Spring成功解析一个&amp;lt;bean/&amp;gt;节点后,在Spring的内部它就被转化为BeanDefinition对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729161501106-1256063888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.Bean的创建：.Spring Bean的创建是典型的工厂设计模式，顶级接口是BeanFactory&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729161241664-442415063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.Bean的解析：Bean的解析主要是对配置文件的解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729161811389-63361313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Context&lt;/h3&gt;
&lt;p&gt;context组件在org.framework.context包下,主要就是Bean关系的集合。给Spring提供了一个运行时环境用于存储对象的状态。ApplicationContext是顶级的父类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729162754651-363366018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ApplicationContext继承了BeanFactory说明了Spring容器运行的主要对象是Bean&lt;/p&gt;
&lt;p&gt;ApplicationContext实现了ResourceLoader接口说明ApplicationContext可以访问到外部资源。&lt;/p&gt;
&lt;h3&gt;Core&lt;/h3&gt;
&lt;p&gt;core组件就是发现，建立和维护每个Bean之间关系所需要的一系列工具。core组件其中一个重要的组成部分就是定义了资源的访问方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729164414531-284448054.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;IOC的工作原理&lt;/h2&gt;
&lt;p&gt;下面我们看看IOC是怎样工作的呢？&lt;/p&gt;
&lt;h3&gt;先来一个小demo&lt;/h3&gt;
&lt;p&gt;MessageService.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface MessageService {
    String getMessage();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MessageServiceImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MessageServiceImpl implements MessageService {
    public String getMessage() {
        return &quot;hello world&quot;;
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&amp;gt;
    &amp;lt;bean id=&quot;messageService&quot; class=&quot;com.kristin.spring.ioc.MessageServiceImpl&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TestMessage.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestMessage {
    public static void main(String[] args) {
        // 用我们的配置文件来启动一个 ApplicationContext
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);

        System.out.println(&quot;context 启动成功&quot;);

        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式
        MessageService messageService = context.getBean(MessageService.class);
        // 这句将输出: hello world
        System.out.println(messageService.getMessage());
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729165142346-90613934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;IOC运行分析　　&lt;/h3&gt;
&lt;p&gt;从上面代码可以发现，IOC的入口就是ClassPathXmlApplicationContext的构造方法,下面我们看看源码是怎样写的&lt;/p&gt;
&lt;p&gt;ClassPathXmlApplicationContext.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
        this(new String[] {configLocation}, true, null);
}

public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
        throws BeansException {

    super(parent);
    setConfigLocations(configLocations);    //根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)
    if (refresh) {
        refresh();  //这里是核心代码
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们看一下refresh()&lt;/p&gt;
&lt;p&gt;ClassPathXmlApplicationContext.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
public void refresh() throws BeansException, IllegalStateException {
    //这里加锁,防止多个线程同时refresh()时出现问题
    synchronized (this.startupShutdownMonitor) {
        // 为刷新准备新的context,记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符
        prepareRefresh();

        // 刷新所有BeanFactory的子容器
        // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，
        // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，
        // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&amp;gt; beanDefinition 的 map)
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 准备BeanFactory,设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean
        prepareBeanFactory(beanFactory);

        try {
            // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化
            // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事
            postProcessBeanFactory(beanFactory);

            // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法
            invokeBeanFactoryPostProcessors(beanFactory);

            // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别
            // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
            // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化
            registerBeanPostProcessors(beanFactory);

            // 初始化message source
            initMessageSource();

            // 初始化 event multicaster
            initApplicationEventMulticaster();

            // 刷新由子类实现的方法
            onRefresh();

            // 注册事件监听器，监听器需要实现 ApplicationListener 接口。
            registerListeners();

            // 初始化所有的 singleton beans
            finishBeanFactoryInitialization(beanFactory);

            // 最后，广播事件，ApplicationContext 初始化完成
            finishRefresh();
        }

        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn(&quot;Exception encountered during context initialization - &quot; +
                        &quot;cancelling refresh attempt: &quot; + ex);
            }

            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();

            // Reset 'active' flag.
            cancelRefresh(ex);

            // Propagate exception to caller.
            throw ex;
        }

        finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
        }
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;refresh函数主要包含了以下几个步骤:&lt;/p&gt;
&lt;p&gt;1.构建BeanFactory,以便于产生所需的&quot;演员&quot;&lt;/p&gt;
&lt;p&gt;2.注册可能感兴趣的事件&lt;/p&gt;
&lt;p&gt;3.创建Bean实例对象&lt;/p&gt;
&lt;p&gt;4.触发被监听的事件&lt;/p&gt;

&lt;p&gt;创建BeanFactory的时序图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201807/1173593-20180729172930883-1676461872.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 继续看一看refresh()函数中调用的函数吧&lt;/p&gt;
&lt;p&gt;AbstractApplicationContext.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protected void prepareRefresh() {
    // 记录启动时间,将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型
    this.startupDate = System.currentTimeMillis();
    this.closed.set(false);
    this.active.set(true);

    if (logger.isInfoEnabled()) {
        logger.info(&quot;Refreshing &quot; + this);
    }

    // Initialize any placeholder property sources in the context environment
    initPropertySources();

    // 校验 xml 配置文件
    getEnvironment().validateRequiredProperties();

    // Allow for the collection of early ApplicationEvents,
    // to be published once the multicaster is available...
    this.earlyApplicationEvents = new LinkedHashSet&amp;lt;ApplicationEvent&amp;gt;();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AbstractApplicationContext.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等
    refreshBeanFactory();
    // 返回刚刚创建的 BeanFactory
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
    }
    return beanFactory;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AbstractRefreshableApplicationContext.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
protected final void refreshBeanFactory() throws BeansException {
    // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory
    // 注意，应用中BeanFactory本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前ApplicationContext是否有BeanFactory
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 初始化一个 DefaultListableBeanFactory
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        // 用于 BeanFactory 的序列化
        beanFactory.setSerializationId(getId());
        // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用
        customizeBeanFactory(beanFactory);
        // 加载 Bean 到 BeanFactory 中,这个方法很重要
        loadBeanDefinitions(beanFactory);   
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时已经获得了BeanFactory&lt;/p&gt;
&lt;p&gt;后面会陆续更新,暂时先整理到这里...&lt;/p&gt;


&lt;p&gt;对了,以上文章整理自&lt;/p&gt;
&lt;p&gt;https://javadoop.com/post/spring-ioc&lt;/p&gt;
&lt;p&gt;《深入分析Java Web技术内幕》&lt;/p&gt;
&lt;p&gt;感谢两位大神的文章及书籍　&lt;/p&gt;

</description>
<pubDate>Sun, 29 Jul 2018 15:45:00 +0000</pubDate>
<dc:creator>KristinLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hangtutu/p/9386045.html</dc:identifier>
</item>
<item>
<title>函数式编程之-模式匹配(Pattern matching) - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9388259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9388259.html</guid>
<description>&lt;p&gt;模式匹配在F#是非常普遍的，用来对某个值进行分支匹配或流程控制。&lt;/p&gt;
&lt;h2 id=&quot;模式匹配的基本用法&quot;&gt;模式匹配的基本用法&lt;/h2&gt;
&lt;p&gt;模式匹配通过match...with表达式来完成，一个完整的模式表达式长下面的样子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;match [something] with 
| pattern1 -&amp;gt; expression1
| pattern2 -&amp;gt; expression2
| pattern3 -&amp;gt; expression3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你第一次使用模式匹配，你可以认为他就是命令式语言中的switch...case或者说是if...else if...else。只不过模式匹配的能力要比switch...case强大的多。&lt;br/&gt;考虑下面的例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 1 with 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot;  
    | _ -&amp;gt; &quot;z&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，x此时的值是&quot;a&quot;，因为第一个匹配分支就匹配正确了。在这个表达式里第三个匹配分支有点特殊:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;| _ -&amp;gt; &quot;z&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通配符&lt;code&gt;_&lt;/code&gt;在这里起到了default的作用，上面的所有分支如果都匹配失败，则最终会匹配的这个分支。&lt;br/&gt;&lt;strong&gt;1.分支是有顺序的&lt;/strong&gt;&lt;br/&gt;但是这三个分支的顺序是可以随便改的，也就意味着我们可以把通配符分支放到第一个位置：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt; let x = 
    match 1 with 
    | _ -&amp;gt; &quot;z&quot; 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，第一个匹配分支会胜出，同时编译器也会给出一个警告:其他的分支从来都不会被用到。&lt;br/&gt;这说明在模式匹配中，分支的顺序是非常重要的，应该把更加具体的匹配分支放在前面，包含通配符的分支应该放在最后面。&lt;br/&gt;&lt;strong&gt;2.模式匹配是一个表达式&lt;/strong&gt;&lt;br/&gt;模式匹配是一个表达式，所有的分支都应该返回同样的类型，考虑下面的例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 1 with 
    | 1 -&amp;gt; 42
    | 2 -&amp;gt; true  // error wrong type
    | _ -&amp;gt; &quot;hello&quot; // error wrong type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同的分支应该返回想通类型的值。&lt;br/&gt;&lt;strong&gt;3.至少有一个分支能被匹配到&lt;/strong&gt;&lt;br/&gt;考虑下面的例子:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 42 with 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于两个分支都没有匹配到，编译器将会给出警告，你至少要写一个能够匹配到的分支，例如为其添加通配符分支。&lt;br/&gt;你可以通过添加通配符分支让编译器不在发出警告，但是在实际实践中，你应该尽可能的添加可能存在的分支，例如你在对一个&lt;code&gt;选择类型&lt;/code&gt;做模式匹配：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;type Choices = A | B | C
let x = 
    match A with 
    | A -&amp;gt; &quot;a&quot;
    | B -&amp;gt; &quot;b&quot;
    | C -&amp;gt; &quot;c&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果后来某一天你在Choices类型里添加了一个新的选项&lt;code&gt;D&lt;/code&gt;，编译器就会对之前的对Choices的模式匹配发出警告，提示你添加新的分支。试想如果你之前加了通配符,编译器就会吞掉这个警告，进而产生bug。&lt;/p&gt;
&lt;h2 id=&quot;匹配元组tuple&quot;&gt;匹配元组(Tuple)&lt;/h2&gt;
&lt;p&gt;模式匹配几乎可以匹配F#所有的类型，例如元组:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (1,x) -&amp;gt; printfn &quot;x=%A&quot; x
    | (_,x) -&amp;gt; printfn &quot;other x=%A&quot; x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然第一个分支会被匹配到。&lt;br/&gt;你可以把多个模式写在同一个分支上，当多个模式是&lt;code&gt;或&lt;/code&gt;的关系时用&lt;code&gt;|&lt;/code&gt;隔开：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;type Choices = A | B | C | D
let x = 
    match A with 
    | A | B | C -&amp;gt; &quot;a or b or c&quot;
    | D -&amp;gt; &quot;d&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当多个模式是&lt;code&gt;与&lt;/code&gt;的关系时用&lt;code&gt;&amp;amp;&lt;/code&gt;隔开:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (2,x) &amp;amp; (_,1) -&amp;gt; printfn &quot;x=%A&quot; x &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;匹配list&quot;&gt;匹配list&lt;/h2&gt;
&lt;p&gt;匹配list只有三种模式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[x;y;z]用来显示匹配list中的元素&lt;/li&gt;
&lt;li&gt;head::tail head会匹配到第一个元素，其他的元素会匹配到tail，这个模式常用来对list做递归&lt;/li&gt;
&lt;li&gt;[] 会匹配到空的list&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let rec loopAndPrint aList = 
    match aList with 
    | [] -&amp;gt; 
        printfn &quot;empty&quot; 
    | x::xs -&amp;gt; 
        printfn &quot;element=%A,&quot; x
        loopAndPrint xs 

loopAndPrint [1..5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当[]模式被匹配到，说明list已经为空，可以作为递归的终止条件；&lt;br/&gt;x::xs模式会将第一个元素匹配到x中，剩余的元素被匹配到xs，然后xs又被当做参数做下一次递归&lt;/p&gt;
&lt;h2 id=&quot;匹配recoard-type和descriminated-union-type...&quot;&gt;匹配Recoard type和Descriminated Union type...&lt;/h2&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;//record type
type Person = {First:string; Last:string}
let person = {First=&quot;john&quot;; Last=&quot;doe&quot;}
match person with 
| {First=&quot;john&quot;}  -&amp;gt; printfn &quot;Matched John&quot; 
| _  -&amp;gt; printfn &quot;Not John&quot; 

//union type
type IntOrBool= I of int | B of bool
let intOrBool = I 42
match intOrBool with 
| I i  -&amp;gt; printfn &quot;Int=%i&quot; i
| B b  -&amp;gt; printfn &quot;Bool=%b&quot; b&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.as关键字&lt;/strong&gt;&lt;br/&gt;你可以把模式用as关键字指向另一个名称：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (x,y) as t -&amp;gt; 
        printfn &quot;x=%A and y=%A&quot; x y
        printfn &quot;The whole tuple is %A&quot; t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.匹配子类&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;:?&lt;/code&gt;用来匹配类型，例如第一个分支用来匹配int类型:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let detectType v =
    match box v with
        | :? int -&amp;gt; printfn &quot;this is an int&quot;
        | _ -&amp;gt; printfn &quot;something else&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匹配类型并不是一种好的实践，正如你在OO语言里编写if type ==...一样。&lt;br/&gt;&lt;strong&gt;when条件&lt;/strong&gt;&lt;br/&gt;有时候你需要对匹配完成的值做一些条件判断：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let elementsAreEqual aTuple = 
    match aTuple with 
    | (x,y) -&amp;gt; 
        if (x=y) then printfn &quot;both parts are the same&quot; 
        else printfn &quot;both parts are different&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况可以通过在模式中添加&lt;code&gt;when&lt;/code&gt;条件来做到：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let elementsAreEqual aTuple = 
    match aTuple with 
    | (x,y) when x=y -&amp;gt; 
        printfn &quot;both parts are the same&quot; 
    | _ -&amp;gt;
        printfn &quot;both parts are different&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;active-pattern&quot;&gt;Active pattern&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt;语句尽管可以给模式添加一些条件，但是当语句过于复杂的时候可以考虑某个分支的模式定义为一个方法：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;open System.Text.RegularExpressions

// create an active pattern to match an email address
let (|EmailAddress|_|) input =
   let m = Regex.Match(input,@&quot;.+@.+&quot;) 
   if (m.Success) then Some input else None  

// use the active pattern in the match  
let classifyString aString = 
    match aString with 
    | EmailAddress x -&amp;gt; 
        printfn &quot;%s is an email&quot; x
        
    // otherwise leave alone
    | _ -&amp;gt; 
        printfn &quot;%s is something else&quot; aString

//test
classifyString &quot;alice@example.com&quot;
classifyString &quot;google.com&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9388259.html</dc:identifier>
</item>
<item>
<title>Git自学笔记 - MOYA相见恨晚</title>
<link>http://www.cnblogs.com/qubo520/p/9388244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qubo520/p/9388244.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Git与SVN的区别有哪些？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;① Git是分布式的，SVN不是。这是Git和其它非分布式版本控制系统（如：SVN，CVS等）最核心的区别。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② Git把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn、.cvs等的文件夹里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;③ Git分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;④ Git没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;⑤ Git的内容完整性要优于SVN：Git的内容存储使用的是SHA-1哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;如何安装、配置Git（以Windows操作系统为例）？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;安装步骤可以上网参考其他教程，安装完成之后打开Git Bash，若弹出一个类似命令窗口的东西，则说明Git安装成功。安装完成后，还需要设置用户信息(即配置个人用户名称和电子邮件地址)，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git config --global user.name &quot;example&quot;&lt;br/&gt;&lt;span&gt;$ git config --global user.email example@126.com&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：① 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② git config --global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名称和电子邮件地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;几个基础命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;要查看安装Git的版本信息，可以使用 git --version命令，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git --version&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;要查看已有的配置信息，可以使用 git config --list 命令，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git config --list&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;要查看当前所在目录，可以使用pwd命令，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ pwd&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;创建版本库&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;首先使用cd命令进入目标文件夹，如进入D:\Development Tools\Git的命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ cd d:&lt;br/&gt;&lt;span&gt;$ cd development&quot; &quot;tools&lt;br/&gt;&lt;span&gt;$ cd git&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：由于Development和Tools之间有空格，所以要用&quot; &quot;来表示空格。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通过命令git init把某个目录变成Git可以管理的仓库，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ mkdir test_repository // 在当前目录下创建test_repository目录&lt;br/&gt;&lt;span&gt;$ cd test_repository&lt;br/&gt;&lt;span&gt;$ git init // 使用当前目录（即test_repository）作为Git仓库。或者使用指定目录（即test_repository）作为Git仓库，命令为：$ git init test_repository。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：此时test_repository目录下就多一个.git的目录，这个目录是Git来跟踪管理版本的，千万不要改目录里的文件，否则会破坏Git仓库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;从现在开始，除非另有说明，否则我们将默认您在Git仓库根目录下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;添加、提交文件到版本库&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;【添加新文件】我们有一个仓库，但什么也没有，可以使用add命令把文件添加到暂存区中去 ，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git add filename&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可以使用add... 继续添加任务文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果需要提交目录A下的所有内容，可以这样做：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git add -A&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;【提交版本】现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。为此，我们将它们提交到仓库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git commit -m &quot;文件初始提交&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果您不使用-m，会出现编辑器来让你写自己的注释信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git commit -a -m &quot;第一次修改提交&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。千万注意，-a不会造成新文件被提交，只能修改。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可以通过git status命令查看是否还有文件未提交，例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git status&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;理解工作区与暂存区的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;工作区：就是在电脑上看到的目录，比如目录下test_repository里的文件(.git隐藏目录版本库除外)或以后需要新建的目录\文件等都属于工作区范畴。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;版本库(Repository)：工作区有一个隐藏目录.git，这个不属于工作区而是版本库。版本库里存了很多东西，最重要的就是stage(暂存区)，还有Git为我们自动创建的第一个分支master以及指向master的一个指针HEAD。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前面说过使用Git提交文件到版本库只需两步：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第一步：使用git add把文件添加进去，实际上就是把文件添加到暂存区。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;查看历史、回退版本&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;假如要看readme.txt文件中改了什么内容，可以使用如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git diff readme.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;假如想查看历史记录，可以使用命令 git log命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git log&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：git log命令显示从最近到最远的日志。如果嫌上面的方法显示的信息太多，可以使用命令 git log --pretty=oneline命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git log --pretty=oneline&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;假如想使用版本回退操作，如：把当前的版本回退到上一个版本，可以使用2种命令，第一种是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git reset  --hard HEAD^ &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果要回退到上上个版本，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git reset  --hard HEAD^^&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;……以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，此时就可以使用下面的命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git reset  --hard HEAD~100&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;若回退之后又想退回到最新版本，可通过版本号回退，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git reset --hard 版本号 &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果已经关掉过一次命令行或者并不知道最新内容的版本号，可以通过如下命令获取版本号：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git reflog&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;找到版本号之后就可以通过$ git reset --hard 版本号 退回到最新版本了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;撤销修改操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通过cat命令查看某个文件中的详细内容，例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ cat readme.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在未提交之前，若发现添加的文件内容有误，得马上恢复到以前的版本，可以有如下几种方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第一：如果知道应该删掉哪些内容，直接手动更改文件然后add到暂存区，最后commit即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第二：可以直接恢复到上一个版本，使用 git reset --hard HEAD^命令即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果不想使用上面2种方法，也可以直接使用撤销命令。首先，在做撤销之前，可以先用git status查看下当前的状态。此时Git会告诉你，git checkout -- file可以丢弃工作区的修改，如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git checkout -- readme.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;git checkout --readme.tx命令的意思：把readme.txt文件在工作区做的修改全部撤销，此时有2种情况，如下：① readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② readme.txt已经放入暂存区，接着又作了修改，撤销修改就回到添加暂存区后的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对于第②种情况，可以做试验看看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：git checkout -- readme.txt命令中的“ -- ”，如果没有“ -- ”的话该命令就变成创建分支了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;删除文件操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;一般情况下，可以直接在工作区的文件目录中把文件删掉或使用rm命令（$ git rm readme.txt），如果想彻底从版本库中删掉此文件可以再执行commit命令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在没有执行commit命令之前，如果想在版本库中恢复此文件，可以使用如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git checkout  -- readme.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;远程仓库的使用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在此之前，需要先注册GitHub账号，由于本地的Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要设置一下：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;① 创建SSH Key。在用户主目录下（一般是C:\Users\Administrator）看是否有.ssh目录，如果有，再看这个目录下是否有id_rsa和id_rsa.pub两个文件，如果有就直接跳过。如果没有的话，打开命令行，输入命令：ssh-keygen -t rsa –C &lt;span&gt;&lt;a href=&quot;mailto:example@126.com&quot;&gt;example@126.com&lt;/a&gt;&lt;span&gt;”即可。注意：id_rsa是私钥，不能泄露给别人，id_rsa.pub是公钥，可以放心告诉任何人。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② 登录GitHub，打开”settings”中的SSH Keys页面，然后点击“Add SSH Key”，填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容，点击Add Key即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;假如我们已经在本地创建了一个Git仓库，又想在GitHub创建一个Git仓库，并且希望这两个仓库进行远程同步，这样GitHub的仓库既可以作为备份，又可以让其他人通过该仓库来协作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;首先，登录GitHub上，然后在右上角找到“Create a new repository”创建一个新的仓库。在Repository name填入test_repository，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。目前，GitHub上的这个test_repository仓库是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在，我们根据GitHub的提示，在本地的test_repository仓库下运行命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git remote add origin https://github.com/example/test_repository.git&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;再使用git push命令把本地Git仓库里的内容推送到远程Git仓库，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git push -u origin master&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;由于远程Git仓库还是空的，所以第一次推送master分支时加上了–u参数，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;此后，只要本地作了提交，就可以通过如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git push origin master&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;就能把本地master分支的最新修改推送到GitHub上了，现在就拥有真正的分布式版本库了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;如何从远程库克隆&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果想把远程Git仓库克隆到本地来，使用如下命令即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git clone https://github.com/example/test_repository1.git&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;创建、切换、合并分支&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在版本回退中我们已经知道：每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。现在创建一个dev分支并切换到dev分支上：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git checkout -b dev&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：git checkout命令加上–b参数表示创建并切换，相当于如下2条命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git branch dev // 创建新的分支，名称为dev&lt;br/&gt;&lt;span&gt;$ git checkout dev // 切换到指定分支(此处为dev)上&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;使用git branch命令查看分支时会列出所有分支，但当前分支前面会多一个*，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;$ git branch&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;此外，还可以把dev分支上的内容合并到分支master上，在master分支上使用命令 git merge dev即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt; $ git merge dev&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：git merge命令用于合并指定分支到当前分支上，合并后再查看readme.txt内容，它就和dev分支最新提交的是完全一样的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;合并完成后，接着就可以删除dev分支了，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git branch -d dev
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;创建、切换、合并分支命令总结&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
查看分支：$ git branch
创建分支：$ git branch name
切换分支：$ git checkout name
创建+切换分支：$ git checkout –b name
合并某分支到当前分支：$ git merge name
删除分支：$ git branch –d name
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;如何解决冲突&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;先新建一个新分支test，在readme.txt中添加一行内容“第三次：test分支”，然后提交，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout -b test
$ cat readme.txt // 添加内容前
$ cat readme.txt // 添加内容后
$ git add readme.txt
$ git commit -m &quot;使用test分支&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;同样，切换到master分支上，也在readme.txt中内容“第三次：使用master分支”，然后提交，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout master
$ cat readme.txt // 添加内容前
$ cat readme.txt // 添加内容后
$ git add readme.txt
$ git commit -m &quot;使用master分支&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接下来在master分支上合并test分支，命令如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git merge test // 产生冲突
$ git status // 查看状态
$ cat readme.txt // 查看readme.txt文件中的冲突内容
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：Git用&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;、=======、&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;标记出不同分支的内容。其中&amp;lt;&amp;lt;&amp;lt;HEAD是指主分支修改的内容，&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;test是指test分支上修改的内容。此时可以修改下readme.txt内容后保存：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ cat readme.txt // 查看readme.txt文件中的内容，修改成和master分支上的内容一样
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在执行添加、提交命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git add readme.txt
$ git commit -m &quot;解决冲突&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果想查看分支合并的情况，需要使用命令git log，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git log
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;分支管理策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通常，合并分支时git一般使用”Fast forward”模式，在这种模式下，删除分支后会丢掉分支信息，现在使用带参数–no-ff来禁用”Fast forward”模式。试验如下：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;① 创建一个dev分支：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout -b dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② 修改readme.txt内容&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;③ 添加到暂存区：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git add readme.txt
$ git commit -m &quot;提交&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;④ 切换回主分支(master)：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout master
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;⑤ 合并dev分支(使用命令git merge –no-ff -m “注释” dev)：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;⑥ 查看历史记录：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git log --graph --pretty=oneline --abbrev-commit
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;分支策略：首先master主分支应该是非常稳定的，用来发布新版本，一般情况下不允许在上面干活，一般情况下在新建的dev分支上干活，干完后，比如上要发布或dev分支代码稳定后才可以合并到主分支master上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;bug分支&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在开发中会经常碰到bug，有了bug就需要修复。在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后再合并分支，最后将临时的分支删除掉。假如在开发中遇到一个404的bug就可以创建一个404分支来修复它，但是当前的dev分支上的工作还没有提交。并不是我不想提交，而是工作进行到一半还无法提交，比如这个分支bug要2天完成，但是404的bug需要5个小时内完成。怎么办？Git提供了一个stash功能，可以把当前工作现场”隐藏起来”，等以后恢复现场后继续工作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git stash
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在可以通过创建issue-404分支来修复bug。首先要确定在那个分支上修复bug，比如现在是在主分支master上修复的，就要在master分支上创建一个临时分支：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout -b issue-404
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;修复完成后切换到master分支上，并完成合并，最后删除issue-404分支：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout master
$ git merge --no-ff -m &quot;修复404bug&quot; isuue-404
$ git branch -d issue-404
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在又可以回到dev分支上干活了：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;工作区是干净的，此时可以使用命令git stash list来查看：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git stash list
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;工作现场还在，Git把stash内容存在某个地方了，需要恢复一下，可以使用如下2个方法：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;① 使用git stash apply，恢复后stash内容并不删除，需要使用git stash drop命令来删除：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git stash drop
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② 使用git stash pop，恢复的同时把stash内容也删除了：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git stash pop
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;多人协作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;① 查看远程库的信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git remote
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;② 查看远程库的详细信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git remote –v
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;推送分支&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;推送分支就是把该分支上所有本地文件提交到远程库中，推送时要指定本地分支，这样Git就会把该分支推送到远程库对应的远程分支上，如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git push origin master
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;假设现在GitHub上readme.txt内容为：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第一次：12345678910&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;而本地readme.txt内容为：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第一次：12345678910&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;第二次：147258369&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在想把本地更新的readme.txt推送到远程库中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git add readme.txt
$ git commit -m &quot;推送分支&quot;
$ git push origin master
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果现在要推送到其他分支(如：dev分支)上：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git push origin dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;一般情况下，那些分支要推送呢？master分支是主分支，因此要时刻与远程同步。一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;抓取分支&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;多人协作时，大家都会往master分支上推送自己的修改。现在另一个目录下克隆，新建一个目录名字叫test_repository2。首先要把dev分支推送到远程去：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git push origin dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接着进入test_repository2目录，克隆远程库到本地来：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git clone https://github.com/example/test_repository.git
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接下来要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，使用命令创建本地dev分支：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git checkout –b dev origin/dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git push origin dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;注意：不同的人修改了同一文件相同地方后推送会失败，因为推送的有冲突，解决办法很简单，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突后再推送。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;根据提示先指定本地dev分支与远程origin/dev分支的链接：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git branch --set-upstream dev origin/dev
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;然后再执行：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ git pull
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果合并有冲突，就需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，先提交，再push。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;因此，多人协作工作模式一般是这样的：&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;首先，用git push origin branch-name推送自己的修改。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果推送失败，则因为远程分支比你本地更新早，需要先用git pull合并。&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;附：Git基本常用命令&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ mkdir XX：创建一个空目录，XX指目录名
$ pwd：显示当前目录的路径
$ git init：把当前的目录变成可以管理的git仓库，生成隐藏.git文件
$ git add XX：把xx文件添加到暂存区去
$ git commit –m “XX”：提交文件 –m 后面的是注释
$ git status：查看仓库状态
$ git diff  XX：查看XX文件修改了那些内容
$ git log：查看历史记录
$ git reset --hard HEAD^(或$ git reset --hard HEAD~)：回退到上一个版本
$ git reset –hard HEAD~100：回退到100个版本
$ cat XX：查看XX文件内容
$ git reflog：查看历史记录的版本号id
$ git checkout -- XX：把XX文件在工作区的修改全部撤销
$ git rm XX：删除XX文件
$ git remote add origin https://github.com/example/test_git：关联一个远程库
$ git push –u(第一次要用-u，以后不需要) origin master：把当前master分支推送到远程库
$ git clone https://github.com/example/test_git：从远程库中克隆
$ git checkout –b dev：创建dev分支，并切换到dev分支上
$ git branch：查看当前所有的分支
$ git checkout master：切换回master分支
$ git merge dev：在当前的分支上合并dev分支
$ git branch –d dev：删除dev分支
$ git branch name：创建分支
$ git stash：把当前的工作隐藏起来 等以后恢复现场后继续工作
$ git stash list：查看所有被隐藏的文件列表
$ git stash apply：恢复被隐藏的文件，但是内容不删除
$ git stash drop：删除文件
$ git stash pop：恢复文件的同时 也删除文件
$ git remote：查看远程库的信息
$ git remote –v：查看远程库的详细信息
$ git push origin master：Git会把master分支推送到远程库对应的远程分支上
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;问：Git Bash中如何cd进入带空格的目录？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;答：如要进入名为java tools文件夹，只需：cd java&quot; &quot;tools即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;问：Git Gui图形化工具中文显示乱码的解决方案？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;答：在操作系统的宿主目录（通常是C:\Users\Administrator）下有一个 .gitconfig 文件，在文件最后追加&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
[gui]
    encoding = utf-8
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;问：使用Git命令如何删除本地仓库？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
$ ls -a // 查看内部文件
$ rm -rf .git // 强删.git
$ ls -a // 查看内部文件
$ cd .. // 回退
$ rm -rf test_repository // 强删文件夹
&lt;/pre&gt;

</description>
<pubDate>Sun, 29 Jul 2018 15:35:00 +0000</pubDate>
<dc:creator>MOYA相见恨晚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qubo520/p/9388244.html</dc:identifier>
</item>
<item>
<title>Python全栈工程师（Python3 所有基础内容都在这了  0-0） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9388030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9388030.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;


&lt;p&gt;&lt;span&gt;Python一个月的基础语法 基本就到这咯&lt;/span&gt;    接下来是数据库了&lt;/p&gt;
&lt;p&gt;东西太多了  简单的整理一下&lt;/p&gt;
&lt;p&gt;大多数是关键字 部分单词  没有分类整理  按照顺序整理的&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;statements&lt;/span&gt; 　　　　　　　　语句&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;print&lt;/span&gt; 　　　　　　　　　 　 输出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;quit()&lt;/span&gt; 　　　　　　　　　　 退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exit()&lt;/span&gt; 　　　　　　　　　　 退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ctrl + d　&lt;/span&gt;　　　　　　　 　  (输入文件结束符)结束输入并退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;int&lt;/span&gt; 　　　　　　　　　　 　 整型数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;float&lt;/span&gt; 　　　　　　　　　 　  浮点型数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;complex&lt;/span&gt; 　　　　　　　   　 复数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bool&lt;/span&gt; 　　　　　　　　  　　 布尔&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;True&lt;/span&gt; 　　　　　　　　 　  　 真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;False&lt;/span&gt; 　　　　　　　　　      假&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;str&lt;/span&gt; 　　　　　　　　　  　   字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;list　　　　　　　　　　　 &lt;/span&gt; 列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;None&lt;/span&gt; 　　　　　　　　　    空值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;expression&lt;/span&gt; 　　　　　　　  表达式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;del&lt;/span&gt; 　　　　　　　　　　     删除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;help（）&lt;/span&gt; 　　　　　　　　   帮助&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;is&lt;/span&gt; 　　　　　　 　　　　　　 是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not is&lt;/span&gt; 　　　　　　　　　　 不是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;id( )　　　　&lt;/span&gt; 　　　　　        查询内存地址&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-5~256&lt;/span&gt;                                   小整数池&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;refrence count&lt;/span&gt; 　　　　　     引用计数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;abs&lt;/span&gt; 　　　　　　　　　　      取绝对值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;round&lt;/span&gt; 　　　　　　　　 　    vc 四舍五入&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pow&lt;/span&gt; 　　　　　　　　　    　 幂运算&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;input   　　　　　　　　　　&lt;/span&gt; 输入  &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sep&lt;/span&gt; 　　　　　　　　      　    两值之间分隔符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;end&lt;/span&gt; 　　　　　　　　　　　   结束（内容）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;if&lt;/span&gt; 　　　　　　　　　　　　   如果&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;elif&lt;/span&gt; 　　　　　　　　　　　　 否则如果&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;else&lt;/span&gt; 　　　　　　　　　　　   否则&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pass&lt;/span&gt; 　　　　　　　　　　　 过&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not&lt;/span&gt; 　　　　　　　　　　　　 布尔 非&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;and&lt;/span&gt; 　　　　　　　　　　　   布尔 与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;or&lt;/span&gt; 　　　　　　　　　　　　 布尔 或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;man ascii&lt;/span&gt; 　　　　　　　　   终端查询命令&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ascii&lt;/span&gt; 　　　　　　　　　　　  编码表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode&lt;/span&gt; 　　　　　　　　      统一编码表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode16&lt;/span&gt; 　　　　　　　 　 16位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode32&lt;/span&gt; 　　　　　　　　   32位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;len(x)&lt;/span&gt; 　　　　　　　　　　　  返回个数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;raw&lt;/span&gt; 　　　　　　　　　　　　 原始字符串（r&quot;hello&quot;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;in&lt;/span&gt; 　　　　　　　　　　 　　　 是否出现过&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not in&lt;/span&gt; 　　　　　　　　　　     没有出现&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;index&lt;/span&gt; 　　　　　　　　　　　 索引（[ ]）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;slice&lt;/span&gt; 　　　　　　　　　　　　 切片（[ : : ]）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bin( )&lt;/span&gt; 　　　　　　　　　　　    整数转二进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;oct( )&lt;/span&gt; 　　　　　　　　　　　    整数转八进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;hex( )&lt;/span&gt; 　　　　　　　　　　　   整数转十六进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;max( )&lt;/span&gt; 　　　　　　　　　　     求最大值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;min( )&lt;/span&gt; 　　　　　　　　　　     最小值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ord( )&lt;/span&gt; 　　　　　　　　　　       字符对应（转）数字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;chr( )&lt;/span&gt; 　　　　　　　　  　　    数字对应（转）字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;while&lt;/span&gt; 　　　　　　　　　　　  循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;for&lt;/span&gt; 　　　　　　　　　　　　   循环（遍历）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;break&lt;/span&gt; 　　　　　　　　　　　  跳出循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;list&lt;/span&gt; 　　　　　　　　　　　　   列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;tuple&lt;/span&gt; 　　　　　　　　　　　　 元组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;dict&lt;/span&gt; 　　　　　　　　　　　　  字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;range&lt;/span&gt; 　　　　　　　　　　　   整数序列生成器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;step&lt;/span&gt; 　　　　　　　　　　　　   步长&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;continue&lt;/span&gt; 　　　　　　　　　　   跳过循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;iterable&lt;/span&gt; 　　　　　　　　　　    可迭代对象&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sum( )&lt;/span&gt; 　　　　　　　　　　  　 求和&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;any( )&lt;/span&gt; 　　　　　　　　　　  　 一个为真则为真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;all( )&lt;/span&gt; 　　　　　　　　　　　　 所有真为真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;s.split(sep)&lt;/span&gt; 　　　　　　　　   sep：分隔符（分隔字符串返回列表）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;'#'.join( )&lt;/span&gt; 　　　　　　　　　　 [1, 2, 3] 返回 “1#2#3”&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;copy（shallow copy）&lt;/span&gt; 　　　　 潜拷贝&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;deepcopy&lt;/span&gt; 　　　　　　　　        深拷贝&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;reversed&lt;/span&gt; 　　　　　　　　         顺序翻转&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sorted（）&lt;/span&gt; 　　　　　　　　      排序序列&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;key&lt;/span&gt; 　　　　　　　　　　　　    键&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;value&lt;/span&gt; 　　　　　　　　　　　　 值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;set　　　　　　　　　　　　　&lt;/span&gt; 集合&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;frozenset&lt;/span&gt; 　　　　　　　　        固定集合&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;byte&lt;/span&gt; 　　　　　　　                    字节（0~255）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bytes（）&lt;/span&gt; 　　　　　　　　        字节串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bytearray（）&lt;/span&gt; 　　　　　　　　 字节数组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;def（function）&lt;/span&gt; 　　　　　　　 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;return&lt;/span&gt; 　　　　　　　　　　　  返回&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;args&lt;/span&gt; 　　　　　　　　　　　　 参数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;args=None&lt;/span&gt; 　　　　　　　　     缺省参数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;*args&lt;/span&gt; 　　　　　　　　　　　  元组传参&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;**kwargs&lt;/span&gt; 　　　　　　　　　　 字典传参&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;local variable&lt;/span&gt; 　　　　　　　　 局部变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;global variable&lt;/span&gt; 　　　　　　    全局变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;globals( )&lt;/span&gt; 　　　　　　　　　　 返回全局变量字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;locals( )&lt;/span&gt; 　　　　　　　　　　 返回局部变量字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Local(function) 　&lt;/span&gt;　 　　　　　     L 　　　　　　　　  局部（作用域）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Enclosing function locals 　　&lt;/span&gt;      E 　　　　　　　　  外部嵌套&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Global(module)&lt;/span&gt; 　　　　　　　　  G 　　　　　　　　 全局（模块）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Builtin(Python) 　&lt;/span&gt;　　　　　　   　B 　　　　　　　　 内建&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;global&lt;/span&gt; 　　　　　　　　　　    声明全局变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;nonlocal&lt;/span&gt; 　　　　　　　　      声明外部嵌套&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;lambda&lt;/span&gt; 　　　　　　　　　　 匿名函数（表达式）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;eval( )&lt;/span&gt; 　　　　　　　　　　   字符串当表达式执行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exec( )&lt;/span&gt; 　　　　　　　　　　  字符串当程序执行&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;High Order Function 　　　　&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;高阶函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;map（）&lt;/span&gt; 　　　　　　　　 　（函数， iterable）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;filter（）&lt;/span&gt; 　　　　 　　　 　 （函数， iterable）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sorted（）　　　　　　　 　&lt;/span&gt; (iterable, key=函数, reverse=False)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;recursion&lt;/span&gt; 　　　　　　　 　  递归&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;closure&lt;/span&gt; 　　　　　　　　   　 闭包&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Module&lt;/span&gt; 　　　　　　　　　   模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;builtins&lt;/span&gt; 　　　　　　　　 　  内建模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;import Module&lt;/span&gt; 　　　　　　 导入模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;from Module import *&lt;/span&gt; 　　    导入&lt;/strong&gt;模块内属性&lt;br/&gt;&lt;strong&gt;&lt;span&gt;dir（）&lt;/span&gt; 　　　　　　　　        返回所有属性列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;math&lt;/span&gt; 　　　　　　　　　　    数学模块（内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;time&lt;/span&gt; 　　　　　　　　　　　  时间模块 (内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;random&lt;/span&gt; 　　　　　　　　　　 随机模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sys 系统&lt;/span&gt;　　　　　　　　　　模块（内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@ Function&lt;/span&gt; 　　　　　　        装饰器函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pip3 installtensorflow&lt;/span&gt; 　　　  模块安装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sys.path&lt;/span&gt; 　　　　　　　　       路径列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__doc__ 　　　　　　　　     &lt;/span&gt; 文档字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__file__&lt;/span&gt; 　　　　　　　　　　 路径名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__name__&lt;/span&gt; 　　　　　　　　   模块自身名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__all__ 　　　　　　　　   　&lt;/span&gt; 可导出属的列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;package 　　　　　　　　    &lt;/span&gt; 包&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;_name&lt;/span&gt; 　　　　　　    　　     隐藏属性name&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__init__.py&lt;/span&gt; 　　　　　　　　   声明包文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try-except&lt;/span&gt; 　　　　　　　　    接受处理异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try-finally&lt;/span&gt; 　　　　　　　　    执行必要语句&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try&lt;/span&gt; 　　　　　　　　　　 　　 异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;as&lt;/span&gt; 　　　　　　　　　　　　  改名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;except&lt;/span&gt; 　　　　　　　　　　   截取异常类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;else&lt;/span&gt; 　　　　　　　　　　　　 正常结束&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;finally&lt;/span&gt; 　　　　　　　　　　   强制执行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;raise&lt;/span&gt; 　　　　　　　　　　　 发送错误&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;assert&lt;/span&gt; 　　　　　　　　　　  限制条件发送错&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Iterator&lt;/span&gt; 　　　　　　　　        迭代器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;iter（）&lt;/span&gt; 　　　　　　　　　　 可迭代对象生成迭代器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;next（）&lt;/span&gt; 　　　　　　　　　   迭代器内顺序取值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Generator&lt;/span&gt; 　　　　　　　　 生成器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;yield&lt;/span&gt; 　　　　　　　　　　   函数内表达式（生成器函数）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;(x for x in range() if )　　　　&lt;/span&gt;生成器表达式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;zip( )&lt;/span&gt; 　　　　　　　　　 　  两个或以上可迭代生成元组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;enumerate( )&lt;/span&gt; 　　　　　　　  生成带索引对象 可定义开始下标&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;File&lt;/span&gt; 　　　　　　　　　　     文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;open（）&lt;/span&gt; 　　　　　　　　    打开文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;File.close( )&lt;/span&gt; 　　　　　　　　 关闭文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gb2312&lt;/span&gt; 　　　　　　　　　　 6763汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gbk&lt;/span&gt; 　　　　　　　　　　     国标21003汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gb18030&lt;/span&gt; 　　　　　　　　    27533汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;UTF-8&lt;/span&gt; 　　　　　　　　　　 Unicode&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ASCII&lt;/span&gt; 　　　　　　　　　　 256字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Ojbect-Oriented Programing&lt;/span&gt; 面向对象&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　封装&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　多态&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　继承&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　多继承 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt; 　　　　　　　　　　      类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;method&lt;/span&gt; 　　　　　　　　　　  实例&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;attribute&lt;/span&gt; 　　　　　　　　　　 实例属性（变量）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__init__（）&lt;/span&gt; 　　　　　　　　  初始化方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__del__（）&lt;/span&gt; 　　　　　　　　   析构方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__dict__&lt;/span&gt; 　　　　　　　　　　  自身变量的字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__class__&lt;/span&gt; 　　　　　　　　      实例的类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;type(obj)&lt;/span&gt; 　　　　　　　　　　 返回类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;isinstance（）&lt;/span&gt; 　　　　　　　  判断是否为某个类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;self&lt;/span&gt; 　　　　　　　　　　　 　 类方法必有的参数（自己）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;object&lt;/span&gt; 　　　　　　　　　　    对象（类）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;instance&lt;/span&gt; 　　　　　　　　　　 实例&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@classmethod&lt;/span&gt; 　　　　　　　 装饰为类的方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@staticmethod&lt;/span&gt; 　　　　　　　 静态方法（类内普通函数）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;inheritance 　　　　　　　　    &lt;/span&gt; 继承（单继承）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;multiple inheritance　&lt;/span&gt;　　　　  多继承&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;derived 　　　　　　　　　　　&lt;/span&gt; 派生&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;base class&lt;/span&gt; 　　　　　　　　　　 基类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;super class&lt;/span&gt; 　　　　　　　 　    超类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;father class&lt;/span&gt; 　　　　　　　 　    父类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;derived class&lt;/span&gt; 　　　　　　         派生类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;child class&lt;/span&gt; 　　　　　　　　　　 子类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;override&lt;/span&gt; 　　　　　　　　　　 覆盖&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;super（）&lt;/span&gt; 　　　　　　　　       调用父类覆盖方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;enclosure&lt;/span&gt; 　　　　　　　　      封装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__name&lt;/span&gt; 　　　　　　　　　　  私有属性name&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;polymorphic&lt;/span&gt; 　　　　　　　　 多态（静态/动态）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__mro__&lt;/span&gt; 　　　　　　　　　　 类的方法查找顺序列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;repr(obj)&lt;/span&gt; 　　　　　　　　　　 返回表达式字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;str(obj)&lt;/span&gt; 　　　　　　　　　　 返回字符串&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;内建函数重写&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__repr__ 　　　　　　　　　　对象装字符串（&lt;span&gt;表达式字符串&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__str__ 　　　　　　　　　　  函数重写（&lt;span&gt;字符串&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__abs__ 　　　　　　　　　　 &lt;span&gt;绝对值&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__len__ 　　　　　　　　　　&lt;span&gt; 序列长度  &lt;/span&gt; &lt;span&gt;必须&lt;/span&gt;返回&lt;span&gt;整数&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__reversed__ 　　　　　　      &lt;span&gt;排序&lt;/span&gt; &lt;span&gt;必须&lt;/span&gt;返回&lt;span&gt;可迭代对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__round__ 　　　　　　           &lt;span&gt;四舍五入&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;数值转换函数重写&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__complex__ 　　　　　　    &lt;span&gt;复数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__int__ 　　　　　　　　       &lt;span&gt;整数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__float__　　　　　　            &lt;span&gt;浮点数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__bool__ 　　　　　　　　    &lt;span&gt;布尔&lt;/span&gt; 函数（&lt;span&gt;特殊&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__next__ 　　　　　　　　    &lt;span&gt;迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;getattr&lt;/span&gt;（obj, &quot;name&quot;[default]） 　　　　　　 返回name 属性 （name为字符串）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;hasattr&lt;/span&gt;（obj, &quot;name&quot;） 　　　　　　　　　   判断有没有name属性&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;setattr&lt;/span&gt;（obj, &quot;name&quot;, value） 　　　　　　    name赋值为value&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;delattr&lt;/span&gt;（obj, &quot;name&quot;） 　　　　　　　　        删除name属性&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;with&lt;/span&gt; 　　　　　　　　　　     异常发时自动管理 环境管理器 &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__enter__&lt;/span&gt; 　　　　　　　　 with开始自动调用&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__exit__&lt;/span&gt; 　　　　　　　　    with调用 判断是否异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__exit__(self, exc_type, exc_val, exc_tb)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_type&lt;/span&gt; 　　　　　　　　  错误类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_val&lt;/span&gt;　　　　　　　　     错误值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_tb&lt;/span&gt; 　　　　　　　　      追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法名　　　　　　　　　　　　　 运算符和表达式 　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__add__(self, rhs)　　　　　　　　  self + rhs 　　　　　    加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__sub__(self, rhs) 　　　　　 　　    self - rhs 　　　　　　 减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__mul__(self, rhs) 　　　　　　　    self * rhs 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__truediv__(self, rhs) 　　　　　 　 self / rhs 　　　　　　  除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__floordiv__(self, rhs) 　　　　　　 self // rhs 　　　　　　 地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__mod__(self, rhs) 　　　　　　       self % rhs 　　　　       取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__pow__(self, rhs) 　　　　　　      self ** rhs 　　　　　　  幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rhs(right hand side) &lt;span&gt;右手边&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反向算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　　　 运算符和表达式 　　　   说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__radd__(self, lhs)　　　　　　　  　 lhs + self 　　　　　　 加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rsub__(self, lhs)　　　　　　　  　 lhs - self 　　　　　　  减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rmul__(self, lhs) 　　　　　　　 　 lhs * self 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rtruediv__(self,　　　　　　　　 　lhs) lhs / self 　　　 　  除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rfloordiv__(self, lhs)　　　　　  　 lhs // self 　　　　　　  地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rmod__(self, lhs) 　　　　　　　　 lhs % self 　　　　　　取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rpow__(self, lhs) 　　　　　　　　 lhs ** self 　　　　　　 幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lhs(left hand side) &lt;span&gt;右手边&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;复合赋值算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　　 运算符和表达式 　　　  　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__iadd__(self, lhs) 　　　　　　 　　 lhs += self 　　　　　　 加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__isub__(self, lhs) 　　　　　　　 　 lhs -= self 　　　　　 　 减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__imul__(self, lhs)　　　　　　　 　  lhs *= self 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__itruediv__(self, lhs)　　　　　　    lhs /= self 　　　　         除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ifloordiv__(self, lhs) 　　　　 　　 lhs //= self 　　  　　      地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__imod__(self, lhs) 　　　　　　  　  lhs %= self 　　　　　  取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ipow__(self, lhs)　　　　　　　　 lhs **= self 　　　　　　 幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优先调用x.__iadd__(y)没有时  (id 不变)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;调用x = x.__add__(y)再不没有&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;TypeError异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复合赋值算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　 运算符和表达式 　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__lt__(self, rhs) 　　　　　　　　    self &amp;lt; rhs 　　　　　　   小于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__le__(self, rhs) 　　　　　　　  　 self &amp;lt;= rhs 　　　　　　 小于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__gt__(self, rhs) 　　　　　　　 　 self &amp;gt; rhs 　　　　　　　大于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ge__(self, rhs) 　　　　　　　　 self &amp;gt;= rhs 　　　　　　  大于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__eq__(self, rhs) 　　　　　　　　 self == rhs 　　　　　　  等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ne__(self, rhs) 　　　　　　　　 self != rhs 　　　　　　   不等于&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　 运算符和表达式 　　　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__invert__(self)　　　　　　　　 ~ self 　　　　　　　　       取反(一元运算符)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__and__(self, rhs) 　　　　　 　  self &amp;amp; rhs 　　　　　　　    位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__or__(self, rhs) 　　　　　　      self | rhs 　　　　　　　　  位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__xor__(self, rhs) 　　　　　   　 self ^ rhs 　　　　　　　　位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__lshift__(self, rhs) 　　　　　　 self &amp;lt;&amp;lt; rhs 　　　　　　　  左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rshift__(self, rhs)　　　　　　 self &amp;gt;&amp;gt; rhs 　　　　　　　   右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反向位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　  运算符和表达式 　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rand__(self, lhs) 　　　　　　  lhs &amp;amp; self 　　　　　　　　 位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ror__(self, lhs) 　　　　　　　lhs | self 　　　　　　　　   位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rxor__(self, lhs)　　　　　　   lhs ^ self 　　　　　　　　  位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rlshift__(self, lhs)　　　　　    lhs &amp;lt;&amp;lt; self 　　　　　　      左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rrshift__(self, lhs) 　　　　     lhs &amp;gt;&amp;gt; self 　　　　　　　    右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复合赋值位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名　　　　　　　　　　      运算符和表达式 　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__iand__(self, rhs)　　　　　　  self &amp;amp;= rhs　　　　　　  位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ior__(self, rhs) 　　　　　　    self |= rhs 　　　　　　   位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ixor__(self, rhs) 　　　　　　 self ^= rhs 　　　　　　  位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ilshift__(self, rhs)　　　　　   self &amp;lt;&amp;lt;= rhs 　　　　　    左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__irshift__(self, rhs) 　　　　　 self &amp;gt;&amp;gt;= rhs 　　　　　　 右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一元运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　 运算符和表达式 　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__invert__(self) 　　　　　    　 ~ self 　　　　　　           取反(一元运算符)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__pos__(self) 　　　　　　　　 + self 　　　　　　　  　  正号&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__neg__(self) 　　　　　　        - self 　　　　　　　 　     负号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;in / not in 运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__contains__&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;索引和切片运算符的重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;　　方法名 　　　　　　　　　　 运算符和表达式 　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__getitem__(self, i) 　　　　　 　 x = self[i] 　　　　   索引/切片取值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__setitem__(self, i, val) 　　　  　self[i] = val 　　　　索引/切片赋值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__delitem__(self, i) 　　　　　　 del self[i] 　　　　    删除索引/切片&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;slice(start=None, stop=None, step=None)&lt;/span&gt;等同于&lt;span&gt;[ : :]&lt;/span&gt; 切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;字符串　　　　　　 （str） 　　　　    是不可变序列　　　　　　　　　　 “”&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;列表 　　　　　　　 [list] 　　　　　   是可变的序列 　　　　　　　　　　 [ ]      　　　　　　    (索引、切片、索引切片赋值)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;元组　　　　　　     (tuple) 　　　　　是不可变的序列 　　　　　　　　　 ( )    　　　　　　     （索引、切片 不可变 不能赋值）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字典 　　　　　　　{dict} 　　　　　  是可变无序的容器 　　　　　　　　 { } 　　　　 　　　　  (键索引，键赋值 没有创建 有则修改)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;集合 　　　　　　    {set} 　　　　      是可变的容器 　　　　　　　　　　 { } 　　　　　　 　　 （元素无法重复、索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;固定集合 　　　　　{frozenset} 　　   不可变  无序 唯一元素的集合　  　   { }　  　　　　　　　（索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字节串　　　　　　 “bytes” 　　　　 是不可变的字节序列 　　　　　　　 “ ” 　　　　     　  　（索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字节数组 　　　　   （bytearray） 　   是 可变的字节序列 　 　　　　　　（） 　　　　      　    （索引 切片 赋值）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推导式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;L&lt;/span&gt;= [表达式 for 变量 in 可迭代对象 if 真值表达式]&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;D&lt;/span&gt; = {键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S&lt;/span&gt; = {表达式 for 变量 in 可迭代对象 [if 真值表达式]}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;匿名函数表达式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;lambda x, y: x + y&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;生成器表达式&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;(表达式 for 变量 in 可迭代对象 [if 真值表达式 ])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;运算符：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;+ 　　　　　　   加&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;- 　　　　　　   减&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;* 　　　　　　   乘&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;/　　　　　　    除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;** 　　　　  　  幂&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;// 　　　　 　　 地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;% 　　　　　　 取余&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;is 　　　　 　　  是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;is not 　　　　  不是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;ni　　　　　　  在 &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;not in 　　　　  不在&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;= 　　　　　　 赋值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt; 　　　　　　 大于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt;= 　　　　　　 大于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt; 　　　　　　 小于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt;= 　　　　　　小于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;== 　　　　　　 等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;!= 　　　　　　 不等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;amp; 　　　　　　 交集（集合）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;| 　　　　　　 并集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;- 　　　　　　 补集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;^ 　　　　　　 对称补集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt; 　　　　　　 超集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt; 　　　　　　 子集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;== 　　　　　　 等&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;!= 　　　　　　 不等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;转义符:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;\' 　　　　　　　　　　 单引号(')&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\&quot; 　　　　　　　　　　 双引号(&quot;)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\\ 　　　　　　　　　　 一个反斜杠&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\n 　　　　　　　　　　 换行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\r 　　　　　　　　　　 返回光标至行首&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\t 　　　　　　　　　　 水平制表符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\v 　　　　　　　　　　 垂直制表符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\f 　　　　　　　　　　 换页&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\b 　　　　　　　　　  倒退&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\0 　　　　　　　　　　　 空字符，字符值为零&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\xXX 　　　　　　　　 　　 XX为两位十六进制表示的字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\uXXXX 　　　　　　　  　 XXXX为四个十六进制表示的Unicode16字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\UXXXXXXXX 　　　　　　 8个十六进制表示的Unicode32字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;格式化字符串中的占位符和类型码:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;%s 　　　　　　　　 字符串,使用str(obj)转为字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%r 　　　　　　　　 字符串，使用repr(obj) 转为字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%c 　　　　　　　　 整数转为字符串，使用chr(i) 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%d 　　　　　　　　 十进制整数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%o 　　　　　　　　 八进制整数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%x 　　　　　　　　 十六进制整数(字符a-f小写)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%X 　　　　　　　　 十六进制整数(字符A-F大写)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%e 　　　　　　　　 指数型浮点数(e小写) 如 2.9e+10&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%E 　　　　　　　　 指数型浮点数(E大写) 如 2.9E+10&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%f,%F 　　　　　　 浮点十进制形式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%g,%G 　　　　　　 进制进形式浮点或指数浮点自动转换&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%% 　　　　　　　　 等同于一个%字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;占位符和类型码之间的格式语法:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;% [- + 0 宽度.精度] 类型码&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt; 　　　　   左对齐(默认是右对齐)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;+&lt;/span&gt; 　　　　 显示正号&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt; 　　　　 左侧空白位置补零&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;宽度&lt;/span&gt;: 整个数据输出的宽度&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;精度&lt;/span&gt;: 保留小数点后多少位,默认6位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%10d&quot; % 123 　　　　    # ' 123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%+10d&quot; % 123 　　　　 # ' +123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%-10d&quot; % 123 　　　 　 # '123 '&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%10s&quot; % &quot;ABC&quot; 　　      # ' ABC'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%05d&quot; % 123 　　　　  # '00123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%f&quot; % 3.1416926535897932  　　　     　# '3.141593'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%7.2f&quot; % 3.1416926535897932 　　　　 # ' 3.14'&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;


&lt;h2 id=&quot;python3-method&quot;&gt;Python3 中常用&lt;span&gt;字符串方法&lt;/span&gt;(method)&lt;/h2&gt;
&lt;h3 id=&quot;_1&quot;&gt;字符串的方法调用语法:&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
对象.方法名(方法传参)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;_2&quot;&gt;字符串的属性读用法示例:&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&quot;abc&quot;.isalpha()  # 语法是对的
123.isalpha()    # 语法是错的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下假设字符串变量名为S&lt;/p&gt;
&lt;h3 id=&quot;_3&quot;&gt;常用字符串方法&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;31&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isdigit()&lt;/td&gt;
&lt;td&gt;判断字符串中的字符是否全为数字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isalpha()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.islower()&lt;/td&gt;
&lt;td&gt;判断字符串所有字符是否全为小写英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isupper()&lt;/td&gt;
&lt;td&gt;判断字符串所有字符是否全为大写英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isspace()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为空白字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.center(width[,fill])&lt;/td&gt;
&lt;td&gt;将原字符串居中，左右默认填充空格 width：所居中字符串的长度 fill：默认填充空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.count(sub[, start[,end]])&lt;/td&gt;
&lt;td&gt;获取一个字符串中子串的个数 sub：所要获取的字符串 start：起始位置 end：结束位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.find(sub[, start[,end]])&lt;/td&gt;
&lt;td&gt;获取字符串中子串sub的索引,失败返回-1 start：起始位置 end：结束位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.strip()&lt;/td&gt;
&lt;td&gt;返回去掉左右空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.lstrip()&lt;/td&gt;
&lt;td&gt;返回去掉左侧空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.rstrip()&lt;/td&gt;
&lt;td&gt;返回去掉右侧空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.upper()&lt;/td&gt;
&lt;td&gt;生成将英文转换为大写的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.lower()&lt;/td&gt;
&lt;td&gt;生成将英文转换为小写的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;S.replace(old, new[, count])&lt;/td&gt;
&lt;td&gt;将原字符串的old用new代替，生成一个新的字符串 count：更换的次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;S.startswith(prefix[, start[, end]])&lt;/td&gt;
&lt;td&gt;返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False,&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.endswith(suffix[, start[, end]])&lt;/td&gt;
&lt;td&gt;返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;以下是不常用的&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.title()&lt;/td&gt;
&lt;td&gt;生成每个英文单词的首字母大写字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isnumeric()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为数字字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;python3method&quot;&gt;&lt;span&gt;Python3中常用的&lt;span&gt;列表方法&lt;/span&gt;（method)&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;见:help(list)&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;L.index(v [, begin[, end]])&lt;/td&gt;
&lt;td&gt;返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.insert(index, obj)&lt;/td&gt;
&lt;td&gt;将某个元素插放到列表中指定的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.count(x)&lt;/td&gt;
&lt;td&gt;返回列表中元素的个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.remove(x)&lt;/td&gt;
&lt;td&gt;从列表中删除第一次出现在列表中的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.copy()&lt;/td&gt;
&lt;td&gt;复制此列表（只复制一层，不会复制深层对象)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.append(x)&lt;/td&gt;
&lt;td&gt;向列表中追加单个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.extend(lst)&lt;/td&gt;
&lt;td&gt;向列表追加另一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;L.clear()&lt;/td&gt;
&lt;td&gt;清空列表,等同于 L[:] = []&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.sort(reverse=False)&lt;/td&gt;
&lt;td&gt;将列表中的元素进行排序，默认顺序按值的小到大的顺序排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.reverse()&lt;/td&gt;
&lt;td&gt;列表的反转，用来改变原列表的先后顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;L.pop([index])&lt;/td&gt;
&lt;td&gt;删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h4 id=&quot;_1&quot;&gt;&lt;span&gt;字典的方法&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;D代表字典对象&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;D.clear()&lt;/td&gt;
&lt;td&gt;清空字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.pop(key)&lt;/td&gt;
&lt;td&gt;移除键，同时返回此键所对应的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;D.copy()&lt;/td&gt;
&lt;td&gt;返回字典D的副本,只复制一层(浅拷贝)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.update(D2)&lt;/td&gt;
&lt;td&gt;将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;D.get(key, default)&lt;/td&gt;
&lt;td&gt;返回键key所对应的值,如果没有此键，则返回default&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.keys()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_keys 集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.values()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_values 值对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.items()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_items 对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h5 id=&quot;python3&quot;&gt;&lt;span&gt;Python3&lt;/span&gt; &lt;span&gt;集合的方法&lt;/span&gt;&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.add(e)&lt;/td&gt;
&lt;td&gt;在集合中添加一个新的元素e；如果元素已经存在，则不添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.remove(e)&lt;/td&gt;
&lt;td&gt;从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.discard(e)&lt;/td&gt;
&lt;td&gt;从集合S中移除一个元素e,在元素e不存在时什么都不做;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.clear()&lt;/td&gt;
&lt;td&gt;清空集合内的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.copy()&lt;/td&gt;
&lt;td&gt;将集合进行一次浅拷贝&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.pop()&lt;/td&gt;
&lt;td&gt;从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.update(s2)&lt;/td&gt;
&lt;td&gt;用 S与s2得到的全集更新变量S&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.difference(s2)&lt;/td&gt;
&lt;td&gt;用S - s2 运算，返回存在于在S中，但不在s2中的所有元素的集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.difference_update(s2)&lt;/td&gt;
&lt;td&gt;等同于 S = S - s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.intersection(s2)&lt;/td&gt;
&lt;td&gt;等同于 S &amp;amp; s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.intersection_update(s2)&lt;/td&gt;
&lt;td&gt;等同于S = S &amp;amp; s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.isdisjoint(s2)&lt;/td&gt;
&lt;td&gt;如果S与s2交集为空返回True,非空则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.issubset(s2)&lt;/td&gt;
&lt;td&gt;如果S与s2交集为非空返回True,空则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.issuperset(...)&lt;/td&gt;
&lt;td&gt;如果S为s2的子集返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;S.symmetric_difference(s2)&lt;/td&gt;
&lt;td&gt;返回对称补集,等同于 S ^ s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;S.symmetric_difference_update(s2)&lt;/td&gt;
&lt;td&gt;用 S 与 s2 的对称补集更新 S&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.union(s2)&lt;/td&gt;
&lt;td&gt;生成 S 与 s2的全集&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;python_1&quot;&gt;Python&lt;span&gt;运算符优先级&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(), [], {key: value}, {}&lt;/td&gt;
&lt;td&gt;元组表达式、列表表达式、字典表达式、集合表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;x[index], x[index:index],&lt;br/&gt;x(arguments...), x.attribute&lt;/td&gt;
&lt;td&gt;索引，切片，&lt;br/&gt;函数调用，属性引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数 (最高优先级)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;~, +, -&lt;/td&gt;
&lt;td&gt;按位翻转, 正号,负号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*, /, %, //&lt;/td&gt;
&lt;td&gt;乘，除，取模和地板除&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+, -&lt;/td&gt;
&lt;td&gt;加法, 减法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;右移, 左移运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;位与(AND)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;位异或(XOR)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;位或(OR)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;&amp;lt;=, &amp;lt;, &amp;gt;, &amp;gt;=, ==, !=,&lt;br/&gt;is, is not, in, not in&lt;/td&gt;
&lt;td&gt;比较,身份测试,成员资格测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;布尔非&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;布尔与&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;布尔或&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;if - else&lt;/td&gt;
&lt;td&gt;条件表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lambda&lt;/td&gt;
&lt;td&gt;lambda表达式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;_1&quot;&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;mode&quot;&gt;mode 模式字符的含义&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'r'&lt;/td&gt;
&lt;td&gt;以只读方式打开(默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;'w'&lt;/td&gt;
&lt;td&gt;以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;'x'&lt;/td&gt;
&lt;td&gt;创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生&quot;FileExistsError&quot;错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'a'&lt;/td&gt;
&lt;td&gt;以只写文件打开一个文件，如果有原文件则追加到文件末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'b'&lt;/td&gt;
&lt;td&gt;用二进制模式打开&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'t'&lt;/td&gt;
&lt;td&gt;文本文件模式打开 (默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'+'&lt;/td&gt;
&lt;td&gt;为更新内容打开一个磁盘文件 (可读可写)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;缺省模式是 'rt'&lt;/li&gt;
&lt;li&gt;'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零&lt;/li&gt;
&lt;li&gt;'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容&lt;/li&gt;
&lt;li&gt;'r+' 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;python_1&quot;&gt;python &lt;span&gt;文件常用方法&lt;/span&gt;:&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.close()&lt;/td&gt;
&lt;td&gt;关闭文件(关闭后文件不能再读写会发生ValueError错误)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.readline()&lt;/td&gt;
&lt;td&gt;读取一行数据, 如果到达文件尾则返回空行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;F.readlines(max_chars=-1)&lt;/td&gt;
&lt;td&gt;返回每行字符串的列表,max_chars为最大字符(或字节)数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.writelines(lines)&lt;/td&gt;
&lt;td&gt;将字符串的列表或字符串的列表中的内容写入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二进制文件操作方法&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.read(size=-1)&lt;/td&gt;
&lt;td&gt;从一个文件流中最多读取size个字符(文本文件)或字节(二进制文件),如果不给出参数，则默认读取文件中全部的内容并返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.write(text)&lt;/td&gt;
&lt;td&gt;写一个字符串到文件流中，返回写入的字符数(文本文件)或字节数(二进制文件)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.tell()&lt;/td&gt;
&lt;td&gt;返回当前文件流读写指针的绝对位置(字节为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seek(offset, whence=0)&lt;/td&gt;
&lt;td&gt;改变数据流读写指针的位置，返回新的绝对位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.flush()&lt;/td&gt;
&lt;td&gt;把写入文件对象的缓存内容写入到磁盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.readable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可读,可读返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.writable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可写,可写返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seekable()&lt;/td&gt;
&lt;td&gt;返回这个文件对象是否支持随机定位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.truncate(pos = None)&lt;/td&gt;
&lt;td&gt;剪掉 自pos位置之后的数据，返回新的文件长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;time&quot;&gt;&lt;span&gt;时间模块 time&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;此模块提供了时间相关的函数，且一直可用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;时间简介&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;公元纪年是从公元 0000年1月1日0时开始的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;计算机元年是从1970年1月1日0时开始的,此时时间为0,之后每过一秒时间+1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的.&lt;br/&gt;UTC 时间不会因时区问题而产生错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_2&quot;&gt;时间元组&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;时间元组是一个9个整型元素组成的,这九个元素自前至后依次为:
&lt;ul&gt;&lt;li&gt;四位的年(如: 1993)&lt;/li&gt;
&lt;li&gt;月 (1-12)&lt;/li&gt;
&lt;li&gt;日 (1-31)&lt;/li&gt;
&lt;li&gt;时 (0-23)&lt;/li&gt;
&lt;li&gt;分 (0-59)&lt;/li&gt;
&lt;li&gt;秒 (0-59)&lt;/li&gt;
&lt;li&gt;星期几 (0-6, 周一是 0)&lt;/li&gt;
&lt;li&gt;元旦开始日 (1-366)&lt;/li&gt;
&lt;li&gt;夏令时修正时间 (-1, 0 or 1).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;如果年份值小于100,则会自动转换为加上1900后的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;time_1&quot;&gt;模块名: time&lt;/h4&gt;
&lt;h4 id=&quot;_3&quot;&gt;时间模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
import time
# 或
from time import xxx
# 或
from time import *
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.altzone&lt;/td&gt;
&lt;td&gt;夏令时时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;time.daylight&lt;/td&gt;
&lt;td&gt;夏令时校正时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.timezone&lt;/td&gt;
&lt;td&gt;本地区时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;time.tzname&lt;/td&gt;
&lt;td&gt;时区名字的元组， 第一个名字为未经夏令时修正的时区名,&lt;br/&gt;第一个名字为经夏令时修正后的时区名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注： CST为中国标准时间(China Standard Time UTC+8:00)&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.time()&lt;/td&gt;
&lt;td&gt;返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.sleep(secs)&lt;/td&gt;
&lt;td&gt;让程序按给定秒数的浮点数睡眠一段时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.gmtime([secs])&lt;/td&gt;
&lt;td&gt;用给定秒数转换为用UTC表达的时间元组&lt;br/&gt;(缺省返回当前时间元组)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.asctime([tuple])&lt;/td&gt;
&lt;td&gt;将时间元组转换为日期时间字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.mktime(tuple)&lt;/td&gt;
&lt;td&gt;将本地日期时间元组转换为新纪元秒数时间(UTC为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.localtime([secs])&lt;/td&gt;
&lt;td&gt;将UTC秒数时间转换为日期元组（以本地时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;math&quot;&gt;&lt;span&gt;数学模块 math&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;模块名: math&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;linux下为内建模块&lt;/li&gt;
&lt;li&gt;Mac OS下为标准库模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;数学模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
import math
# 或
from math import *
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;math.e&lt;/td&gt;
&lt;td&gt;自然对数的底e&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.pi&lt;/td&gt;
&lt;td&gt;圆周率pi&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.ceil(x)&lt;/td&gt;
&lt;td&gt;对x向上取整，比如x=1.2，返回2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.floor(x)&lt;/td&gt;
&lt;td&gt;对x向下取整，比如x=1.2，返回1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.sqrt(x)&lt;/td&gt;
&lt;td&gt;返回x的平方根&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.factorial(x)&lt;/td&gt;
&lt;td&gt;求x的阶乘&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;math.log(x[, base])&lt;/td&gt;
&lt;td&gt;返回以base为底x的对数, 如果不给出base,则以自然对数e为底&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.log10(x)&lt;/td&gt;
&lt;td&gt;求以10为底x的对数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.pow(x, y)&lt;/td&gt;
&lt;td&gt;返回 x**y (x的y次方)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.fabs(x)&lt;/td&gt;
&lt;td&gt;返回浮点数x的绝对值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;角度和弧度degrees互换&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.degree(x)&lt;/td&gt;
&lt;td&gt;将弧度x转换为角度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.radians(x)&lt;/td&gt;
&lt;td&gt;将角度x转换为弧度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;三角函数&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.sin(x)&lt;/td&gt;
&lt;td&gt;返回x的正弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.cos(x)&lt;/td&gt;
&lt;td&gt;返回x的余弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.tan(x)&lt;/td&gt;
&lt;td&gt;返回x的正切(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.asin(x)&lt;/td&gt;
&lt;td&gt;返回x的反正弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.acos(x)&lt;/td&gt;
&lt;td&gt;返回x的反余弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.atan(x)&lt;/td&gt;
&lt;td&gt;返回x的反正切(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h3 id=&quot;random&quot;&gt;&lt;span&gt;随机模块 random&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;_1&quot;&gt;说明：&lt;/h4&gt;
&lt;h5 id=&quot;random_1&quot;&gt;random模块是用于模拟或生成随机输出的模块.&lt;/h5&gt;
&lt;p&gt;import random as R&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;R.random()&lt;/td&gt;
&lt;td&gt;返回一个[0, 1) 之间的随机实数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;R.uniform(a,b)&lt;/td&gt;
&lt;td&gt;返回[a,b) 区间内的随机实数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;R.randrange([start,] stop[, step])&lt;/td&gt;
&lt;td&gt;返回range(start,stop,step)中的随机数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.choice(seq)&lt;/td&gt;
&lt;td&gt;从序列中返回随意元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.shuffle(seq[, random])&lt;/td&gt;
&lt;td&gt;随机指定序列的顺序(乱序序列）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.sample(seq,n)&lt;/td&gt;
&lt;td&gt;从序列中选择n个随机且不重复的元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;sys&quot;&gt;&lt;span&gt;系统模块 sys&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;运行时系统相关的信息&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;sys_1&quot;&gt;sys模块的属性&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.path&lt;/td&gt;
&lt;td&gt;模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 ''&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sys.modules&lt;/td&gt;
&lt;td&gt;已加载模块的字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sys.version&lt;/td&gt;
&lt;td&gt;版本信息字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.version_info&lt;/td&gt;
&lt;td&gt;版本信息的命名元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.platform&lt;/td&gt;
&lt;td&gt;操作系统平台名称信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.argv&lt;/td&gt;
&lt;td&gt;命令行参数 argv[0] 代表当前脚本程序路径名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.copyright&lt;/td&gt;
&lt;td&gt;获得Python版权相关的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.builtin_module_names&lt;/td&gt;
&lt;td&gt;获得Python内建模块的名称（字符串元组）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;sys_2&quot;&gt;sys模块的函数&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.exit([arg])&lt;/td&gt;
&lt;td&gt;退出程序，正常退出时sys.exit(0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.getrecursionlimit()&lt;/td&gt;
&lt;td&gt;得到递归嵌套层次限制（栈的深度）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.setrecursionlimit(n)&lt;/td&gt;
&lt;td&gt;得到和修改递归嵌套层次限制（栈的深度）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　　内建函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;_1&quot;&gt;数值对象的构造(创建)函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;float(obj)&lt;/td&gt;
&lt;td&gt;用字符串或数字转换为浮点数, 如果不给出参数，则返回0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int(x, base=10)&lt;br/&gt;int(x=0)&lt;/td&gt;
&lt;td&gt;用数字或字符串转换为整数,如果不给出参数，则返回0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;complex(r=0.0, i=0.0)&lt;/td&gt;
&lt;td&gt;用数字创建一个复数(实部为r,虚部为i)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bool(x)&lt;/td&gt;
&lt;td&gt;用x创建一个布尔值(True/False)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_2&quot;&gt;预置(内建)的数值型函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;abs(x)&lt;/td&gt;
&lt;td&gt;取x的绝对值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;round(number[, ndigits])&lt;/td&gt;
&lt;td&gt;对数值进行四舍五入, ndigits是小数向右取整的位数, 负数表示向左取整&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pow(x, y, z=None)&lt;/td&gt;
&lt;td&gt;相当于x ** y 或 x**y % z&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;help&quot;&gt;help() 查看函数帮助：&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
help函数
&amp;gt;&amp;gt;&amp;gt; help(abs)  # 查看abs函数的帮助
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_3&quot;&gt;基本输入输出&lt;/h2&gt;
&lt;h3 id=&quot;input&quot;&gt;基本输入 input&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;input('提示字符串')&lt;/td&gt;
&lt;td&gt;返回输入的字符串(仅Python3,'提示字符串' 可以是空)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;print&quot;&gt;基本输出函数 print&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)&lt;/td&gt;
&lt;td&gt;将一系列的值以字符串形式输出到&lt;br/&gt;标准输出设备上,默认为终端.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;_4&quot;&gt;参数选项&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
选项的关键字参数为:
sep:   两个值之间的分隔符，默认为一个空格' '
end:   输出完毕后在流末尾自动追加一个字符串,默认为换行符'\n'
file:  流对象，默认为sys.stdout.
flush: 是否立即将流进行输出
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_5&quot;&gt;字符串编码转换函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ord(c)&lt;/td&gt;
&lt;td&gt;返回一个字符的Unicode值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;chr(i)&lt;/td&gt;
&lt;td&gt;返回i这个值所对应的 字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_6&quot;&gt;整数转换为字符串函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hex(i)&lt;/td&gt;
&lt;td&gt;将整数转换为十六进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;oct(i)&lt;/td&gt;
&lt;td&gt;将整数转换为八进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bin(i)&lt;/td&gt;
&lt;td&gt;将整数转换为二进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_7&quot;&gt;字符串构造函数&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot;&gt;
&lt;pre&gt;
&quot;123&quot; + 1  # 不合法
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj='')&lt;/td&gt;
&lt;td&gt;将对象转换为字符串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;range&quot;&gt;range()函数&lt;/h4&gt;
&lt;h5 id=&quot;_8&quot;&gt;格式:&lt;/h5&gt;
&lt;p&gt;(见:help(range))&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;range(stop)&lt;/td&gt;
&lt;td&gt;从零开始，每次生成一个整数后加1操作，直到stop为止（不包含stop)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;range(start,stop[,step])&lt;/td&gt;
&lt;td&gt;从start开始，每次生成一个整数后移动step，直到stop为止（不包含stop，且step可以是负整数)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;list&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　列表的构造(创建)函数list&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list()&lt;/td&gt;
&lt;td&gt;# 生成一个空的列表 等同于 []&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;# 用可迭代对象创建一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;python3&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　Python3中常用的序列函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;td&gt;len(seq)&lt;/td&gt;
&lt;td&gt;返回序列的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max(x)&lt;/td&gt;
&lt;td&gt;返回序列的最大值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;min(x)&lt;/td&gt;
&lt;td&gt;返回序列的最小值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;------以上是以前学的---------&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sum(x)&lt;/td&gt;
&lt;td&gt;返回序列中所有元素的和(元素必须是数值类型)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;any(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中其中一个值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;all(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中所有值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reversed(seq)&lt;/td&gt;
&lt;td&gt;返回原序列反向顺序的可迭代对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;sorted(iterable, reverse=False)&lt;/td&gt;
&lt;td&gt;返回已排序对象的&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj)&lt;/td&gt;
&lt;td&gt;将对象obj序列化为一个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;tuple&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　元组的构造(创建)函数tuple&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple()&lt;/td&gt;
&lt;td&gt;生成一个空的元组，等同于 ()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_9&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　序列相关函数总结&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;len(seq)&lt;/td&gt;
&lt;td&gt;返回序列的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max(x)&lt;/td&gt;
&lt;td&gt;返回序列的最大值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;min(x)&lt;/td&gt;
&lt;td&gt;返回序列的最小值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sum(x)&lt;/td&gt;
&lt;td&gt;返回序列中所有元素的和&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;any(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中其中一个值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;all(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中所有值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj)&lt;/td&gt;
&lt;td&gt;将对象obj序列化为一个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reversed(seq)&lt;/td&gt;
&lt;td&gt;返回反向顺序的可迭代对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;sorted(iterable, key=None, reverse=False)&lt;/td&gt;
&lt;td&gt;返回已排序的列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;dictdict&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　dict的构造(创建)函数dict&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict()&lt;/td&gt;
&lt;td&gt;# 生成一个空的字典 等同于 {}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象初始化一个字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict(**kwargs)&lt;/td&gt;
&lt;td&gt;关键字传参形式生成一个字典&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;set&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　集合构造(创建)函数 set&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;创建一个空的集合对象(不能用{}来创建空集合)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象创建一个新的集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;frozenset&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　固定集合构造(创建)函数 frozenset&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;frozenset()&lt;/td&gt;
&lt;td&gt;创建一个空的固定集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;frozenset(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象创建一个新的固定集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;globals-locals&quot;&gt;　　　　　　　　　　　　　　　　　　　　globals() / locals() 函数&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;globals()&lt;/td&gt;
&lt;td&gt;返回当前全局作用域内变量的字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;locals()&lt;/td&gt;
&lt;td&gt;返回当前局部作用域内变量的字典&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;eval-exec&quot;&gt;　　　　　　　　　　　　　　　　　　　　　eval(), exec() 函数&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;eval(source, globals=None, locals=None)&lt;/td&gt;
&lt;td&gt;把一个字符串source当成一个表达式来执行，返回表达式执行后的结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;exec(source, globals=None, locals=None)&lt;/td&gt;
&lt;td&gt;把一个字符串source当成程序来执行．&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;high-order-function&quot;&gt;　　　　　　　　　　　　　　　　　　高阶函数 High Order Function&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;map(func, *iterables)&lt;/td&gt;
&lt;td&gt;用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,&lt;br/&gt;当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;filter(function, iterable)&lt;/td&gt;
&lt;td&gt;筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象&lt;br/&gt;将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，&lt;br/&gt;返回False则将此数据丢弃，返回True，则保留此数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;sorted(iterable, key=None, reverse=False)&lt;/td&gt;
&lt;td&gt;将原可迭代对象的数据进行排序，生成排序后的列表iterable 可迭代对象&lt;br/&gt;key 函数是用来提供一个值,这个值将作为排序的依据reverse 标志用来设&lt;br/&gt;置是否降序排序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;dir&quot;&gt;dir函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dir([对象])&lt;/td&gt;
&lt;td&gt;返回一个字符串列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;dir_1&quot;&gt;dir函数作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果没有参数调用，则返回当前作用域内的所有变量的列表&lt;/li&gt;
&lt;li&gt;如果给定一个对象作为参数，则返回这个对象的所有变量的列表
&lt;ul&gt;&lt;li&gt;对于一个模块,返回这个模块的全部变量&lt;/li&gt;
&lt;li&gt;对于一个类对象，返回类对象的所有变量，并递归的基类对象的所有变量&lt;/li&gt;
&lt;li&gt;对于其它对象返回所有变量、类变量和基类变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;iternext&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　迭代器函数iter和next&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;iter(iterable)&lt;/td&gt;
&lt;td&gt;从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;next(iterator)&lt;/td&gt;
&lt;td&gt;从迭代器iterator中获取一下个记录，如果无法获取一下条记录，则触发 StopIteration 异常&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_10&quot;&gt;迭代工具函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;迭代工具函数的作用是生成一个个性化可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;zip(iter1 [,iter2 [...]])&lt;/td&gt;
&lt;td&gt;返回一个zip对象, 此对象用于生成一个元组，此元组的个数由最小的可迭代对象决定&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;enumerate(iterable[, start])&lt;/td&gt;
&lt;td&gt;生成带索引的枚举对象，返回的迭代类型为索引-值对(index-value)对,默认索引从零开始，也可以用start指定&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;bytes&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　字节串的构造函数bytes&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytes()&lt;/td&gt;
&lt;td&gt;# 生成一个空的字节串 等同于 b''&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;bytes(整型可迭代对象)&lt;/td&gt;
&lt;td&gt;# 用可迭代对象初始化一个字节串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytes(整数n)&lt;/td&gt;
&lt;td&gt;生成n个值为0的字节串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;bytes(字符串, encoding='utf-8')&lt;/td&gt;
&lt;td&gt;用字符串的转换编码生成一个字节串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;bytearray&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　字节数组的生成函数 bytearray&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;bytearray()&lt;/td&gt;
&lt;td&gt;创建空的字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytearray(整数)&lt;/td&gt;
&lt;td&gt;用可迭代对象初始化一个字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;bytearray(整型可迭代对象)&lt;/td&gt;
&lt;td&gt;生成n个值为0的字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;bytearray(字符串, encoding='utf-8')&lt;/td&gt;
&lt;td&gt;用字符串的转换编码生成一个字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_11&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　文件的打开函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;open(file, mode='rt')&lt;/td&gt;
&lt;td&gt;用于打开一个文件，返回此文件流对象. &lt;br/&gt;如果打开文件失败，则会触发OSError 错误! &lt;br/&gt;如果要打开的文件不存在，则会触发FileNotFoundError 错误!&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_12&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　用于类的函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;isinstance(obj, class_or_tuple)&lt;/td&gt;
&lt;td&gt;返回这个对象obj 是否是 某个类的对象,或者某些类&lt;br/&gt;中的一个类的对象,如果是返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type(obj)&lt;/td&gt;
&lt;td&gt;返回对象的类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;super&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　super函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;super(cls, obj)&lt;/td&gt;
&lt;td&gt;返回绑定超类的实例(要求obj必须为cls类型的实例)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;super()&lt;/td&gt;
&lt;td&gt;返回绑定超类的实例,等同于:super(&lt;strong&gt;class&lt;/strong&gt;, 实例方法的第一个参数)，必须用在方法内调用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_13&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　用于类的函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;issubclass(cls, class_or_tuple)&lt;/td&gt;
&lt;td&gt;判断一个类是否继承自其它的类,如果此类cls是class 或 tuple中的一个派生子类则返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;_14&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　对象的属性管理函数&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;getattr(obj, name[, default])&lt;/td&gt;
&lt;td&gt;从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给&lt;br/&gt;出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;hasattr(obj, name)&lt;/td&gt;
&lt;td&gt;用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;setattr(obj, name, value)&lt;/td&gt;
&lt;td&gt;给对象obj的名为name的属性设置相应的值value, set(x, 'y', v) 等同于 x.y = v&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;delattr(obj, name)&lt;/td&gt;
&lt;td&gt;删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h4 id=&quot;python_1&quot;&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　Python全部的错误类型&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;错误类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;26.5&quot;&gt;&lt;tr&gt;&lt;td&gt;以下内容必讲&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ZeroDivisionError&lt;/td&gt;
&lt;td&gt;除(或取模)零 (所有数据类型)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ValueError&lt;/td&gt;
&lt;td&gt;传入无效的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AssertionError&lt;/td&gt;
&lt;td&gt;断言语句失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;StopIteration&lt;/td&gt;
&lt;td&gt;迭代器没有更多的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IndexError&lt;/td&gt;
&lt;td&gt;序列中没有此索引(index)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IndentationError&lt;/td&gt;
&lt;td&gt;缩进错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OSError&lt;/td&gt;
&lt;td&gt;输入/输出操作失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ImportError&lt;/td&gt;
&lt;td&gt;导入模块/对象失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NameError&lt;/td&gt;
&lt;td&gt;未声明/初始化对象 (没有属性)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AttributeError&lt;/td&gt;
&lt;td&gt;对象没有这个属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;GeneratorExit&lt;/td&gt;
&lt;td&gt;生成器(generator)发生异常来通知退出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TypeError&lt;/td&gt;
&lt;td&gt;对类型无效的操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;KeyboardInterrupt&lt;/td&gt;
&lt;td&gt;用户中断执行(通常是输入^C)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OverflowError&lt;/td&gt;
&lt;td&gt;数值运算超出最大限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FloatingPointError&lt;/td&gt;
&lt;td&gt;浮点计算错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BaseException&lt;/td&gt;
&lt;td&gt;所有异常的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SystemExit&lt;/td&gt;
&lt;td&gt;解释器请求退出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;常规错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;StandardError&lt;/td&gt;
&lt;td&gt;所有的内建标准异常的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ArithmeticError&lt;/td&gt;
&lt;td&gt;所有数值计算错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;EOFError&lt;/td&gt;
&lt;td&gt;没有内建输入,到达EOF 标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EnvironmentError&lt;/td&gt;
&lt;td&gt;操作系统错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WindowsError&lt;/td&gt;
&lt;td&gt;系统调用失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LookupError&lt;/td&gt;
&lt;td&gt;无效数据查询的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;KeyError&lt;/td&gt;
&lt;td&gt;映射中没有这个键&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MemoryError&lt;/td&gt;
&lt;td&gt;内存溢出错误(对于Python 解释器不是致命的)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UnboundLocalError&lt;/td&gt;
&lt;td&gt;访问未初始化的本地变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ReferenceError&lt;/td&gt;
&lt;td&gt;弱引用(Weak reference)试图访问已经垃圾回收了的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RuntimeError&lt;/td&gt;
&lt;td&gt;一般的运行时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NotImplementedError&lt;/td&gt;
&lt;td&gt;尚未实现的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SyntaxError Python&lt;/td&gt;
&lt;td&gt;语法错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TabError&lt;/td&gt;
&lt;td&gt;Tab 和空格混用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SystemError&lt;/td&gt;
&lt;td&gt;一般的解释器系统错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeError&lt;/td&gt;
&lt;td&gt;Unicode 相关的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UnicodeDecodeError&lt;/td&gt;
&lt;td&gt;Unicode 解码时的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeEncodeError&lt;/td&gt;
&lt;td&gt;Unicode 编码时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeTranslateError&lt;/td&gt;
&lt;td&gt;Unicode 转换时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;以下为警告类型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;警告的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DeprecationWarning&lt;/td&gt;
&lt;td&gt;关于被弃用的特征的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FutureWarning&lt;/td&gt;
&lt;td&gt;关于构造将来语义会有改变的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OverflowWarning&lt;/td&gt;
&lt;td&gt;旧的关于自动提升为长整型(long)的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;PendingDeprecationWarning&lt;/td&gt;
&lt;td&gt;关于特性将会被废弃的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RuntimeWarning&lt;/td&gt;
&lt;td&gt;可疑的运行时行为(runtime behavior)的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SyntaxWarning&lt;/td&gt;
&lt;td&gt;可疑的语法的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UserWarning&lt;/td&gt;
&lt;td&gt;用户代码生成的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;详见：help(&lt;strong&gt;builtins&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Sun, 29 Jul 2018 14:28:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9388030.html</dc:identifier>
</item>
<item>
<title>灵活使用Win+R快捷键提高工作效率 - 凉L</title>
<link>http://www.cnblogs.com/-lyl/p/RunAnything.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-lyl/p/RunAnything.html</guid>
<description>&lt;p&gt;大家平时一定都使用过Win+R运行快捷键，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729181317333-616537123.png&quot; alt=&quot;&quot; width=&quot;370&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在运行里可以快捷的打开一些系统软件，比如说输入mstsc是打开远程连接，输入explorer是打开文件管理器，输入regedit是打开注册表编辑器。&lt;/p&gt;
&lt;p&gt;输入最好的编程语言官网会。。。。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729220520957-290945628.gif&quot; alt=&quot;&quot; width=&quot;741&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 那么问题来了，这么方便好用的一个快捷键如果只能打开系统软件岂不是太浪费了吗。&lt;/p&gt;
&lt;p&gt;接下来就是怎么调教下让它功能更加强大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先说下运行打开软件的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你在运行里面输入名字之后，运行会找到环境变量中的Path系统变量，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729211325173-270982768.png&quot; alt=&quot;&quot; width=&quot;839&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去Path中配置的目录中去寻找是否有这个软件或者快捷方式。&lt;/p&gt;
&lt;p&gt;如果有的话就打开，没有的话就提示找不到。&lt;/p&gt;
&lt;p&gt;知道了它的运行方式，接下来就好办了。&lt;/p&gt;
&lt;p&gt;咱们可以&lt;strong&gt;新建一个文件夹，在里面放上常用软件的快捷方式，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后将此文件夹配置到Path环境变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先在合适的地方新建一个文件夹&lt;/strong&gt;，名字可以随意起，quickstart或者ksqd都可以。下文会用ksqd文件夹代替。建议不要建在C盘，如果后期要增加新的快捷方式的话会提示管理员权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建好ksqd文件夹之后，在文件夹上面点右键=&amp;gt;创建快捷方式，然后给快捷方式起个名字，&lt;strong&gt;尽量简短&lt;/strong&gt;，将快捷方式放到ksqd文件夹，这么做的意义就是，如果以后要修改快捷方式，可以通过运行直接打开ksqd文件夹，非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729212327141-756738116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接下来把常用软件的快捷方式都放到ksqd文件夹中&lt;/strong&gt;。命名方式依旧是尽量简短，不然如果要输入一大串字符才能打开软件，那还不如直接去桌面找速度快。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关于浏览器的快捷方式：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览器的快捷方式中可以设置默认打开的网址，具体设置方法是：&lt;/p&gt;
&lt;p&gt;在目标框中最后的单引号后面，加上你要打开的网址，比如www.cnblogs.com/-lyl/，当你在运行中打开此快捷方式时，它就会直接打开你设置的主页。&lt;/p&gt;
&lt;p&gt;这样可以给经常去的网站都设置成快捷方式。特别是在内网开发中特别方便，不用再输入各种IP地址。&lt;/p&gt;
&lt;p&gt;有些&lt;strong&gt;流氓软件&lt;/strong&gt;也会采取这种方式&lt;strong&gt;锁定主页，&lt;/strong&gt;如果你的主页修改没有效果，看下快捷方式是不是有问题吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729213002198-535116153.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;737&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将需要的快捷方式添加完成之后，配置环境变量&lt;/strong&gt;。这部分Java开发的同学想必很熟悉了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体步骤是，打开我的电脑=&amp;gt;属性=&amp;gt;环境变量，在系统变量里面找到Path变量。在最后面把ksqd文件夹的路径填进去。比如我的快捷方式是保存在D:\Program\QuickStart文件夹里，我的配置如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729214413487-961304230.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;604&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来就是测试了，Win+R打开运行窗口，输入ksqd文件夹中的快捷方式，看看是不是有什么神奇的事情发生呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注1：&lt;/strong&gt;如果要添加新的快捷方式，还记得之前我们已经将ksqd文件夹的快捷方式放到ksqd文件夹中了，只需要Win+R输入ksqd文件夹的快捷方式就可以打开ksqd文件夹，将要添加的快捷方式放到ksqd文件夹中即可，不需要再修改系统变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注2：&lt;/strong&gt;如果程序名字出现重复，则按照环境变量中的顺序优先打开靠前文件夹中的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注3：&lt;/strong&gt;win 7系统的Path系统变量打开后是这个界面，与Win10不同，鼠标直接划到最后输入分号加ksqd文件夹路径即可，比如;D:\Program\QuickStart&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729215016379-1348926395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以上就是去全部内容了，第一次使用博客，希望能给大家带来些帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729221304887-1970998467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 29 Jul 2018 14:18:00 +0000</pubDate>
<dc:creator>凉L</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-lyl/p/RunAnything.html</dc:identifier>
</item>
<item>
<title>【JDK源码分析】同步工具Exchanger，它的内部实现原理你看懂了吗？ - 还是搬砖踏实</title>
<link>http://www.cnblogs.com/d-homme/p/9387948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d-homme/p/9387948.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-3&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Exchanger应该算并发包中工具使用相对少的，因为它主要用于线程之间交换数据，它的用法比较简单在不同线程之间使用exchange方法交换数据，但是内部实现比较巧妙，使用了unsafe的CAS原子操作、自旋来解决冲突问题，下面我们通过源码一探究竟。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-4&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;先看看源码注释中关于核心算法的介绍&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;37.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (slot is empty) { 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot为空时，将item 设置到Node 中                   &lt;/span&gt;
&lt;span&gt;                place item in a Node;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (can CAS slot from empty to node) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当将node通过CAS交换到slot中时，挂起线程等待被唤醒&lt;/span&gt;
                    wait &lt;span&gt;for&lt;/span&gt;&lt;span&gt; release;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被唤醒后返回node中匹配到的item&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; matching item in node;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (can CAS slot from node to empty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; release
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将slot设置为空
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取node中的item，将需要交换的数据设置到匹配的item&lt;/span&gt;
&lt;span&gt;                get the item in node;
                set matching item in node;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒等待的线程&lt;/span&gt;
&lt;span&gt;                release waiting thread;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry on CAS failure&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如有2条线程A和B，A线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程B进来，读取A设置的数据，然后设置线程B需要交换的数据，然后唤醒A线程，原理就是这么简单。当时当多个线程之间进行交换数据时就会出现问题，所以Exchanger加入了slot数组。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;exchanger-属性及构造器&quot;&gt;Exchanger 属性及构造器&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-7&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于左移Node数组下标，从而得出数据在内存中的偏移量来获取数据，避免伪共享&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ASHIFT = 7&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; note数组最大下标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MMASK = 0xff&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于递增bound,每次加一个SEQ&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SEQ = MMASK + 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CPU核心数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NCPU =&lt;span&gt; Runtime.getRuntime().availableProcessors();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前数组最大的下标（多处理器情况下）&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FULL = (NCPU &amp;gt;= (MMASK &amp;lt;&amp;lt; 1)) ? MMASK : NCPU &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋次数，CPU核心为1个时，自旋被禁用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SPINS = 1 &amp;lt;&amp;lt; 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空对象，用于当线程exchange方法中参数为null时传递给其他线程的对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object NULL_ITEM = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于超时时传递的对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object TIMED_OUT = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Participant 继承了ThreadLocal，也就是说该对象用于获取每条线程中存放的值&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Participant participant;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个线程交换&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node[] arena;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于2个线程交换&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node slot;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该值主要用于与&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bound; 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过unsafe用于CAS操作&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; sun.misc.Unsafe U;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; BOUND;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; SLOT;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; MATCH;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; BLOCKER;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ABASE;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            U &lt;/span&gt;=&lt;span&gt; sun.misc.Unsafe.getUnsafe();
            Class&lt;/span&gt;&amp;lt;?&amp;gt; ek = Exchanger.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; nk = Node.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; ak = Node[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; tk = Thread.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bound属性在Exchanger对象中的偏移地址&lt;/span&gt;
            BOUND =&lt;span&gt; U.objectFieldOffset
                (ek.getDeclaredField(&lt;/span&gt;&quot;bound&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot属性在Exchanger对象中的偏移地址   &lt;/span&gt;
            SLOT =&lt;span&gt; U.objectFieldOffset
                (ek.getDeclaredField(&lt;/span&gt;&quot;slot&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot属性在Node对象中的偏移地址&lt;/span&gt;
            MATCH =&lt;span&gt; U.objectFieldOffset
                (nk.getDeclaredField(&lt;/span&gt;&quot;match&quot;&lt;span&gt;));
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; parkBlocker属性在Thread对象中的偏移地址&lt;/span&gt;
            BLOCKER =&lt;span&gt; U.objectFieldOffset
                (tk.getDeclaredField(&lt;/span&gt;&quot;parkBlocker&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Node[]数组中每个元素的大小，这里是4&lt;/span&gt;
            s =&lt;span&gt; U.arrayIndexScale(ak);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ABASE absorbs padding in front of element 0
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Node[]数组中第一个元素的偏移地址 + 128&lt;/span&gt;
            ABASE = U.arrayBaseOffset(ak) + (1 &amp;lt;&amp;lt;&lt;span&gt; ASHIFT);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(e);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s &amp;amp; (s-1)) != 0 || s &amp;gt; (1 &amp;lt;&amp;lt;&lt;span&gt; ASHIFT))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是为了保证 Node数组中的元素不会争用一个缓存行&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Unsupported array scale&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;构造器及内部类&quot;&gt;构造器及内部类&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-9&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exchanger() {
        participant &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Participant();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部类，用于记录每个线程的状态&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Participant &lt;span&gt;extends&lt;/span&gt; ThreadLocal&amp;lt;Node&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node initialValue() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(); }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 包含需要交换的数据等信息
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Contended为 JDK8 新增的注解，用于避免伪共享，提高程序性能&lt;/span&gt;
    @sun.misc.Contended &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; arana数组中的下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上一次记录的bound            &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bound;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cas操作失败的次数            &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; collides; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于自旋的伪随机数         &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pseudo-random for spins
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程需要交换的数据&lt;/span&gt;
        Object item;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This thread's current item
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配线程交换的数据&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; Object match;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Item provided by releasing thread
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录当前挂起的线程&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; Thread parked; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set to this thread when parked, else null&lt;/span&gt;
    }     
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;方法exchange&quot;&gt;方法exchange&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-11&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;53.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换数据，参数X为本线程提供给其它线程的数据&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; V exchange(V x) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Object v;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当参数为null时需要将item设置为空的对象&lt;/span&gt;
        Object item = (x == &lt;span&gt;null&lt;/span&gt;) ? NULL_ITEM : x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; translate null args
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意到这里的这个表达式是整个方法的核心&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((arena != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
             (v &lt;/span&gt;= slotExchange(item, &lt;span&gt;false&lt;/span&gt;, 0L)) == &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt;
            ((Thread.interrupted() &lt;/span&gt;|| &lt;span&gt;//&lt;/span&gt;&lt;span&gt; disambiguates null return&lt;/span&gt;
              (v = arenaExchange(item, &lt;span&gt;false&lt;/span&gt;, 0L)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (v == NULL_ITEM) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : (V)v;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看if里的条件表达式，得知： &lt;br/&gt;&lt;span&gt;&lt;code&gt;只有当arena为null时，才会执行slotExchange方法；&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;code&gt;当arena不为null或者(arena为null且slotExchange方法返回null)时，此时线程未中断，才会执行arenaExchange方法;&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;code&gt;线程中断时，就会直接抛出线程中断异常。&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;下面我们来看slotExchange方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed 为true表示设置了超时时间，ns为&amp;gt;0的值，反之没有设置超时时间&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object slotExchange(Object item, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ns) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程node对象&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         Node p =&lt;span&gt; participant.get();
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t.isInterrupted()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve interrupt status so caller can recheck
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程中断返回null&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Node q;;) {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将slot值赋给q&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((q = slot) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过CAS将slot设置成null&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS操作成功后，将slot中的item赋值给对象v，以便返回。
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里也是就读取之前线程要交换的数据&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;                     Object v =&lt;span&gt; q.item;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程需要交给的数据设置在q中的match&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;                     q.match =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取被挂起的线程&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;                     Thread w =&lt;span&gt; q.parked;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (w != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程不为null，唤醒它&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;                        U.unpark(w);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回其他线程给的V&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS 操作失败，表示有其它线程竞争，在此线程之前将数据已取走
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create arena on contention, but continue until slot null&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (NCPU &amp;gt; 1 &amp;amp;&amp;amp; bound == 0 &amp;amp;&amp;amp;
&lt;span&gt; 33&lt;/span&gt;                     U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, 0&lt;span&gt;, SEQ))
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CPU为多核心
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bound == 0 表示arena数组未初始化过，CAS操作bound将其增加SEQ
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化arena数组&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;                     arena = &lt;span&gt;new&lt;/span&gt; Node[(FULL + 2) &amp;lt;&amp;lt;&lt;span&gt; ASHIFT];
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上面分析过，只有当arena才会执行slotExchange方法的
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以表示刚好已有其它线程加入进来将arena初始化&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (arena != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就需要去执行arenaExchange&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; caller must reroute to arenaExchange&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里表示当前线程是以第一个线程进来交换数据
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要交换的数据先存放在当前线程变量p中&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;                 p.item =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要交换的数据通过CAS设置到交换区slot&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, p))
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换成功后跳出自旋&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;                 p.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待其它线程交换数据然后唤醒当前线程
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; await release&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; p.hash;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; end = timed ? System.nanoTime() + ns : 0L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋次数&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; spins = (NCPU &amp;gt; 1) ? SPINS : 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        Object v;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((v = p.match) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的逻辑主要是自旋等待，直到spins递减到0为止&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (spins &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 h ^= h &amp;lt;&amp;lt; 1; h ^= h &amp;gt;&amp;gt;&amp;gt; 3; h ^= h &amp;lt;&amp;lt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (h == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     h = SPINS | (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)t.getId();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (h &amp;lt; 0 &amp;amp;&amp;amp; (--spins &amp;amp; ((SPINS &amp;gt;&amp;gt;&amp;gt; 1) - 1)) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                    Thread.yield();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot 和 p本应该是相等，除非其它线程执行了第16行代码中的CAS操作将slot置为null，
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还未来得及设置match的值，此时只需要自旋等待第21行代码被其它线程执行，
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样p.match才会不为null跳出循环&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (slot !=&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 spins =&lt;span&gt; SPINS;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处表示未设置超时或者时间未超时&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp; arena == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt; 83&lt;/span&gt;                      (!timed || (ns = end - System.nanoTime()) &amp;gt; 0L&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t被当前对象阻塞&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;                 U.putObject(t, BLOCKER, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给p挂机线程的值赋值&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;                 p.parked =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (slot ==&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;                     U.park(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, ns);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程被唤醒，将被挂起的线程设置为null&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                 p.parked = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t未被任何对象阻塞&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;                 U.putObject(t, BLOCKER, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是以上条件时（可能是arena已不为null或者超时）&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, p, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arena不为null则v为null,其它为超时则v为超市对象TIMED_OUT，并且跳出循环&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;                 v = timed &amp;amp;&amp;amp; ns &amp;lt;= 0L &amp;amp;&amp;amp; !t.isInterrupted() ? TIMED_OUT : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取走match值，并将p中的match置为null&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         U.putOrderedObject(p, MATCH, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置item为null&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;         p.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         p.hash =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回交换值&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;52.5&quot;&gt;
&lt;p&gt;再来看arenaExchange方法，此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed 为true表示设置了超时时间，ns为&amp;gt;0的值，反之没有设置超时时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object arenaExchange(Object item, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ns) {
        Node[] a &lt;/span&gt;=&lt;span&gt; arena;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程中的存放的node&lt;/span&gt;
        Node p =&lt;span&gt; participant.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index初始值0&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = p.index;;) {                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; access slot at i
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历，如果在数组中找到数据则直接交换并唤醒线程，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如未找到则将需要交换给其它线程的数据放置于数组中&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; b, m, c; &lt;span&gt;long&lt;/span&gt; j;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j is raw array offset
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; q实际为arena数组偏移(i + 1) *  128个地址位上的node&lt;/span&gt;
            Node q = (Node)U.getObjectVolatile(a, j = (i &amp;lt;&amp;lt; ASHIFT) +&lt;span&gt; ABASE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果q不为null，并且CAS操作成功，将下标j的元素置为null&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; U.compareAndSwapObject(a, j, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程&lt;/span&gt;
                Object v = q.item;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; release&lt;/span&gt;
                q.match =&lt;span&gt; item;
                Thread w &lt;/span&gt;=&lt;span&gt; q.parked;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (w != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    U.unpark(w);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; q 为null 并且 i 未超过数组边界&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i &amp;lt;= (m = (b = bound) &amp;amp; MMASK) &amp;amp;&amp;amp; q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要给其它线程的item赋予给p中的item&lt;/span&gt;
                p.item = item;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; offer&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(a, j, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, p)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换成功&lt;/span&gt;
                    &lt;span&gt;long&lt;/span&gt; end = (timed &amp;amp;&amp;amp; m == 0) ? System.nanoTime() + ns : 0L&lt;span&gt;;
                    Thread t &lt;/span&gt;= Thread.currentThread(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; h = p.hash, spins =&lt;span&gt; SPINS;;) {
                        Object v &lt;/span&gt;=&lt;span&gt; p.match;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其它线程设置的需要交换的数据match不为null
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将match设置null,item设置为null&lt;/span&gt;
                            U.putOrderedObject(p, MATCH, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                            p.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear for next use&lt;/span&gt;
                            p.hash =&lt;span&gt; h;
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (spins &amp;gt; 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减自旋次数&lt;/span&gt;
                            h ^= h &amp;lt;&amp;lt; 1; h ^= h &amp;gt;&amp;gt;&amp;gt; 3; h ^= h &amp;lt;&amp;lt; 10; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; xorshift&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (h == 0)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialize hash&lt;/span&gt;
                                h = SPINS | (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)t.getId();
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (h &amp;lt; 0 &amp;amp;&amp;amp;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; approx 50% true&lt;/span&gt;
                                     (--spins &amp;amp; ((SPINS &amp;gt;&amp;gt;&amp;gt; 1) - 1)) == 0&lt;span&gt;)
                                Thread.yield();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; two yields per wait&lt;/span&gt;
&lt;span&gt;                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) !=&lt;span&gt; p)
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和slotExchange方法中的类似，arena数组中的数据已被CAS设置
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; match值还未设置，让其再自旋会等待match被设置&lt;/span&gt;
                            spins = SPINS;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; releaser hasn't set match yet&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp; m == 0 &amp;amp;&amp;amp;&lt;span&gt;
                                 (&lt;/span&gt;!timed ||&lt;span&gt;
                                  (ns &lt;/span&gt;= end - System.nanoTime()) &amp;gt; 0L&lt;span&gt;)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t被当前对象阻塞&lt;/span&gt;
                            U.putObject(t, BLOCKER, &lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; emulate LockSupport
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程t赋值&lt;/span&gt;
                            p.parked = t;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; minimize window&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) ==&lt;span&gt; p)
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组中对象还相等，表示线程还未被唤醒，唤醒线程&lt;/span&gt;
                                U.park(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, ns);
                            p.parked &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t未被任何对象阻塞&lt;/span&gt;
                            U.putObject(t, BLOCKER, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) == p &amp;amp;&amp;amp;&lt;span&gt;
                                 U.compareAndSwapObject(a, j, p, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里给bound增加加一个SEQ&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (m != 0)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; try to shrink&lt;/span&gt;
                                U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, b, b + SEQ - 1&lt;span&gt;);
                            p.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            p.hash &lt;/span&gt;=&lt;span&gt; h;
                            i &lt;/span&gt;= p.index &amp;gt;&amp;gt;&amp;gt;= 1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; descend&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timed &amp;amp;&amp;amp; m == 0 &amp;amp;&amp;amp; ns &amp;lt;= 0L&lt;span&gt;)
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TIMED_OUT;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; expired; restart&lt;/span&gt;
&lt;span&gt;                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换失败，表示有其它线程更改了arena数组中下标i的元素&lt;/span&gt;
                    p.item = &lt;span&gt;null&lt;/span&gt;;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear offer&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时表示下标不在bound &amp;amp; MMASK或q不为null但CAS操作失败
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要更新bound变化后的值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p.bound != b) {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; stale; reset&lt;/span&gt;
                    p.bound =&lt;span&gt; b;
                    p.collides &lt;/span&gt;= 0&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向遍历&lt;/span&gt;
                    i = (i != m || m == 0) ? m : m - 1&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((c = p.collides) &amp;lt; m || m == FULL ||
                         !U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, b, b + SEQ + 1&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录CAS失败的次数&lt;/span&gt;
                    p.collides = c + 1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
                    i = (i == 0) ? m : i - 1;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cyclically traverse&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时表示bound值增加了SEQ+1&lt;/span&gt;
                    i = m + 1;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; grow
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下标&lt;/span&gt;
                p.index =&lt;span&gt; i;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-1093&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32.01246882793&quot;&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;读到这里是不是还是感觉有很多疑问？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先看为什么&lt;code&gt;ASHIFT&lt;/code&gt;设置成7，这是为了尽量避免slot数组中不同的元素在同一个缓存行上，&lt;code&gt;&amp;lt;&amp;lt; ASHIFT&lt;/code&gt; 左移7位，表示至少移动了128地址位，而我们主流的缓存行大小一般为32字节到256字节，所以128个地址位基本覆盖到了常见的处理器平台。arena数组中元素的分布如图，它们之间间隔128个整数倍地址位，也就是说最小相差128个地址位。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180729212029513?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmdWNraW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;arena数组&quot;/&gt;&lt;/li&gt;
&lt;li&gt;为什么Node类用&lt;code&gt;@sun.misc.Contended&lt;/code&gt;注解呢？该注解是jdk8新增的注解，是为了解决之前手动填充数据的问题。填充数据也是为了避免arena数组中的不同的元素共享同一个缓存行，导致多线程修改数据时性能受到影响。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;1.5714285714286&quot;&gt;
&lt;p&gt;参考： &lt;br/&gt;&lt;a href=&quot;http://ifeve.com/falsesharing/&quot;&gt;伪共享(False Sharing)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 29 Jul 2018 14:17:00 +0000</pubDate>
<dc:creator>还是搬砖踏实</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/d-homme/p/9387948.html</dc:identifier>
</item>
<item>
<title>Mybatis缓存（1）--------系统缓存及简单配置介绍 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9387941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9387941.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;9.9392033542977&quot;&gt;
&lt;p&gt;Mybatis的缓存主要有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统缓存，也就是我们一级缓存与二级缓存；&lt;/li&gt;
&lt;li&gt;自定义的缓存，比如Redis、Enhance等，需要额外的单独配置与实现，具体日后主要学习介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里主要记录系统缓存的一些简单概念， 并没有涉及原理。其中会涉及Mybatis的相关配置以及生命周期等。&lt;/p&gt;
&lt;p&gt;主要参考资料：《深入浅出Mybatis基础原理与实战》，&lt;a title=&quot;Mybatis配置&quot; href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot; target=&quot;_blank&quot;&gt;http://www.mybatis.org/mybatis-3/zh/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;h2&gt;1、Mybatis简单配置介绍&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;本文介绍的是基于XML的配置，并不是关于注解的Mybatis配置。当然复杂SQL情况下都建议使用XML配置。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;　　（1）配置步骤&lt;/h3&gt;
&lt;p&gt;　　这里记录的只是Myabtis的简单配置，并没有证整合Spring等框架，所以相对简单。我开始学的时候也是反复记不住，不知道为什么要这么配置，这么配置的作用是什么。之后经过研读《深入浅出Mybatis基础原理与实战》（我这里只有PDF电子版本，有需要的朋友可以评论或者私信我），总结并画图让我对整个配置过程有了全新的认识。&lt;/p&gt;
&lt;p&gt;　　简单来说，Mybatis的配置主要分为以下几步（整合Spring之后有些就不需要了，但是一开始学习不介绍直接整合Spring）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;编写POJO即JavaBean，最终的目的是将数据库中的查询结果映射到JavaBean上；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置与POJO对应的Mapper接口：里面有各种方法，对应mapper.xml中的查询语句；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置与POJO对应的XML映射：编写缓存，SQL查询等；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置mybatis-config.xml主要的Mybatis配置文件：配置数据源、扫描mapper.xml等。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　注意：以上的配置并没有严格的前后顺序；&lt;/p&gt;
&lt;h3&gt;　　（2）配置流程图&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180729204649421-1202779896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　（3）配置总结&lt;/h3&gt;
&lt;p&gt;　　可以这么总结Mybatis或者帮助理解Mybatis的配置，我总结了以下三点提供参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一切&lt;span&gt;Mybatis配置都是为了创建SqlSession进行SQL查询&lt;/span&gt;；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;归根结底程序代码中我们&lt;span&gt;屏蔽了各种配置映射，只显式调用使用Mapper接口&lt;/span&gt;，那么接口实现类的获得是通过SqlSession.getMapper()获得；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;那么mapper接口实现类的获得是通过&lt;span&gt;mybatis-config.xml-&amp;gt;SqlSessionFactoryBuilder-&amp;gt;SqlSessionFacotry-&amp;gt;SqlSession-&amp;gt;mapper;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 2、Mybatis生命周期　&lt;/h2&gt;
&lt;p&gt;　　正确理解SqlSessionFactory、&lt;span&gt;SqlSessionFactoryBuilder&lt;/span&gt;、&lt;span&gt;SqlSession&lt;/span&gt;和&lt;span&gt;Mapper&lt;/span&gt;的生命周期对于优化&lt;span&gt;Mybatis&lt;/span&gt;尤为重要，这样可以使&lt;span&gt;Mybatis&lt;/span&gt;高效正确完成；同为重要时Mybatis的生命周期对于理解Myabtis缓存的配置也尤为重要，我这里只做简单的文字介绍（其实也好理解）：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）&lt;span&gt;SqlSessionFactoryBuilder&lt;/span&gt;：作用就是创建一个构建器，一旦&lt;span&gt;创建了SqlSessionFactory，它的任务就算完成了&lt;/span&gt;，可以回收。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（2）&lt;span&gt;SqlSessionFactory&lt;/span&gt;：作用是创建&lt;span&gt;SqlSession&lt;/span&gt;，而&lt;span&gt;&lt;span&gt;SqlSession&lt;/span&gt;相当于&lt;span&gt;JDBC&lt;/span&gt;的一个&lt;span&gt;Connection&lt;/span&gt;对象&lt;/span&gt;，每次应用程序需要访问数据库，我们就要通过&lt;span&gt;SqlSessionFactory&lt;/span&gt;创建一个&lt;span&gt;SqlSession&lt;/span&gt;，所以&lt;span&gt;SqlSessionFactory在整&lt;span&gt;Mybatis&lt;/span&gt;整个生命周期中&lt;/span&gt;（每个数据库对应一个SqlSessionFactory，是单例产生的）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（3）&lt;span&gt;SqlSession&lt;/span&gt;：生命周期是存在于请求数据库处理事务的过程中，是一个线程不安全的对象（在多线程的情况下，需要特别注意），&lt;span&gt;即存活于一个应用的请求和申请&lt;/span&gt;，可以执行多条SQL保证事务的一致性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（4）&lt;span&gt;Mapper&lt;/span&gt;：是一个接口，并没有实现类它的作用是发送SQL，返回我们需要的结果，或者发送&lt;span&gt;SQL&lt;/span&gt;修改数据库表，所以&lt;span&gt;它存活于一个SqlSession内，是一个方法级别的东西。当&lt;span&gt;SqlSession&lt;/span&gt;销毁的时候，&lt;span&gt;Mapper&lt;/span&gt;也会销毁。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 3、Myabtis缓存介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（1）&lt;strong&gt;系统缓存：包括一级缓存与二级缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　一级缓存：默认情况下Myabtis对于同一个SqlSession开启一级缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在&lt;span&gt;默认没有配置的情况下，只会开启一级缓存&lt;/span&gt;（只针对同一个SqlSession而言）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在&lt;span&gt;参数与SQL完全一样的情况下并且不声明刷新缓存没超时的&lt;/span&gt;，使用同一个SqlSession对象调用同一个Mapper方法时（SqlSession对象生命周期为方法级别），&lt;span&gt;SqlSession只会取出当前缓存数据，不会再到数据库中进行查询&lt;/span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果不同的SqlSession，即使同一个Mapper也会进行到数据库中进行不同的查询，即&lt;span&gt;不同的SqlSession一级缓存是无效的&lt;/span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　二级缓存：这里可以结合&lt;span&gt;SqlSessionFactory等的生命周期能加深理解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不同的SqlSession是隔离的，为了解决这个问题，我们可以在&lt;span&gt;SqlSessionFactory层面上设置二级缓存提供各个对象SqlSession；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;二级缓存默认是不开启的，需要进行配置，Mybatis要求返回的POJO必须是可序列化的，即&lt;span&gt;POJO实现Serializable接口&lt;/span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　缓存的配置只需要在XML配置&amp;lt;cache/&amp;gt;即可，或者指定算法，刷新时间间隔，缓存状态，大小等&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;eviction&lt;/span&gt;&lt;span&gt;=&quot;LRU&quot;&lt;/span&gt;&lt;span&gt; readOnly&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; flushInterval&lt;/span&gt;&lt;span&gt;=&quot;100000&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;1024&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　A. 映射语句文件中所有select语句将会被缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　B. 映射语句文件中所有insert、update和delete语句会被刷新缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　C. 缓存使用默认的LRU最近最少使用算法回收；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　D. 根据时间表，缓存不会任何时间顺序刷新；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　E. 缓存会存储列表集合或对象的1024个引用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　F. 缓存被视为可read/write的缓存，意味着是不可以被共享的，而可以被安全地修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）自定义缓存：结合Redis等主流缓存配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以使用比如现在比较火的Redis缓存，需要实现&lt;span&gt;Myabtis&lt;/span&gt;为我们提供的接口&lt;span&gt;org.apache.ibatis.cache.Cache&lt;/span&gt;。虽然现在主流Mybatis用的都是自定义缓存，但是这里先不过多介绍，我一步一步来学习记录！&lt;/p&gt;
&lt;h2&gt;4、Mybatis系统缓存代码实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180729220421296-924374311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;user表要与User对应，Mybatis会根据驼峰命名进行自动映射，即user表中id字段映射为User POJO中的id。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; mybatis;
&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt; changed
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Zhangsan &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Lisi     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（1）User.java: POJO&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * POJO:User
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;（2）UserMapper.xml:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.lijian.dao.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.lijian.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用POJO映射结果集 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findByUserId&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      select * from user where id = #{id}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用resultMap映射结果集 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findByUserName&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select * from user where name = #{name}      
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（3）UserMapper.java:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserMapper {
    User findByUserId(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
    User findByUserName(String name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（4）mybatis-config.xml:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mybatis-config.xml常用的配置及顺序：
        (properties?,
        settings?,
        typeAliases?,
        typeHandlers?,
        objectFactory?,
        objectWrapperFactory?,
        reflectorFactory?,
        plugins?,
        environments?,
        databaseIdProvider?,
        mappers?)
     &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;　　　&amp;lt;!--&lt;/span&gt;&lt;span&gt; jdbc数据库属性配置文件db.properties &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;db.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;logImpl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;LOG4J&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAlias &lt;/span&gt;&lt;span&gt;alias&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.lijian.model.User&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; default 默认数数据源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; environments配置：可以注册多个数据源DataSource，每个数据源分为两部分：一个是数据源的配置，另外一个是数据库事务配置。 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; dataSource 1&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 关闭自动提交 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;autoCommit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; POOLED连接池数据库 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.driver}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.url}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.username}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.password}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 可以通过包名导入映射器 ：但mapper interface与mapper.xml必须在同一个包下&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;package name=&quot;com.lijian.mapper&quot;/&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 文件路径引入 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;com/lijian/mapper/UserMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（5）SqlSessionFactoryUtils:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 创建SqlSession
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
 * 创建顺序：mybatis-config.xml-&amp;gt;SqlSessionFactoryBuilder-&amp;gt;SqlSessionFactory(Singleton)-&amp;gt;SqlSession
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.logging.log4j.LogManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.logging.log4j.Logger;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlSessionFactoryUtils {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LogManager.getLogger(SqlSessionFactoryUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized lock&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class CLASS_LOCK = SqlSessionFactoryUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SqlSessionFactory sqlSessionFactory = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private constructors&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactoryUtils(){};
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 因为一个数据库对应一个SqlSessionFactory，所有采用单例模式生成SqlSessionFactory
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; SqlSessionFactory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SqlSessionFactory initSqlSessionFactory() {
        String config &lt;/span&gt;= &quot;mybatis-config.xml&quot;&lt;span&gt;;
        InputStream inputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(config);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            logger.info(&lt;/span&gt;&quot;SqlSessionFactoryUtils&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (CLASS_LOCK) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlSessionFactory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                sqlSessionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
            }
            
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlSessionFactory;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * openSession进行SQL查询
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; SqlSession
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SqlSession openSession() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlSessionFactory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            initSqlSessionFactory();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlSessionFactory.openSession();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（6）MybatisMain.java:&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lijian.dao.UserMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lijian.utils.SqlSessionFactoryUtils;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MybatisMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SqlSession sqlSession &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        SqlSession sqlSession2 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得SqlSession&lt;/span&gt;
            sqlSession =&lt;span&gt; SqlSessionFactoryUtils.openSession();
            sqlSession2 &lt;/span&gt;=&lt;span&gt; SqlSessionFactoryUtils.openSession();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得Mapper:动态代理生成UserMapper实现类&lt;/span&gt;
            UserMapper userMapper = sqlSession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认一级缓存：相同SELECT与param，只查询一次&lt;/span&gt;
            System.out.println(&quot;=======================默认使用系统一级缓存=======================&quot;&lt;span&gt;);
            userMapper.findByUserId(&lt;/span&gt;1&lt;span&gt;);
            userMapper.findByUserId(&lt;/span&gt;1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二级缓存commit才会有效&lt;/span&gt;
&lt;span&gt;            sqlSession.commit();
            System.out.println(&lt;/span&gt;&quot;=======================重新创建SqlSession=======================&quot;&lt;span&gt;);
            sqlSession2 &lt;/span&gt;=&lt;span&gt; SqlSessionFactoryUtils.openSession();
            UserMapper userMapper2 &lt;/span&gt;= sqlSession2.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            userMapper2.findByUserId(&lt;/span&gt;1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二级缓存commit才会有效&lt;/span&gt;
&lt;span&gt;            sqlSession2.commit();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            System.err.println(e.getMessage());
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlSession != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sqlSession生命周期是随着SQL查询而结束的&lt;/span&gt;
&lt;span&gt;                sqlSession.close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sqlSession2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                sqlSession2.close();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意UserMapper.xml当前是没有开启二级缓存的，故默认为一级缓存，如何得到证实呢？在MybatisMain中，我们创建了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sqlSession：开启两个一模一样的SELECT SQL查询，即&lt;span&gt;userMapper.findByUserId(&lt;/span&gt;1&lt;span&gt;)，那么如果一级缓存有效且开启的话，&lt;span&gt;只会进行一次查询，之后有一次SQL语句日志输出；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;sqlSession2：开启与sqlSession中一模一样的SELECT查询，如果二级缓存没有开启，一级缓存默认开启的话，是会进行查询的，&lt;span&gt;会有一次SQL语句日志输出。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
=======================默认使用系统一级缓存=======================&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:41][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt;  Preparing: &lt;span&gt;select * from user where id = ?&lt;/span&gt;&lt;span&gt; 
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:41][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
[TRACE][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==&lt;span&gt;    Columns: id, name
[TRACE][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==        Row: 1&lt;span&gt;, Zhangsan
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==      Total: 1
=======================重新创建SqlSession=======================&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt;  Preparing: &lt;span&gt;select * from user where id = ?&lt;/span&gt;&lt;span&gt; 
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
[TRACE][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==&lt;span&gt;    Columns: id, name
[TRACE][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==        Row: 1&lt;span&gt;, Zhangsan
[DEBUG][main][&lt;/span&gt;2018-07-29 21:45:42][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==      Total: 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来我们开启二级缓存：在不同SqlSession中所有相同的SELECT语句将会被缓存，&lt;span&gt;只会有一次SQL语句日志输出，并且会有Cache Hit Ratio缓存命中率&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.lijian.dao.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 开启二级缓存 ：针对SqlSessionFactory，同时POJO必须实现Serializable接口
      （1）所有select会被缓存
      （2）insert、update、delete会刷新缓存
      （3）默认使用LRU
      （4）缓存是可read/write，不是共享的是可以被安全地修改
  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;eviction&lt;/span&gt;&lt;span&gt;=&quot;LRU&quot;&lt;/span&gt;&lt;span&gt; readOnly&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; flushInterval&lt;/span&gt;&lt;span&gt;=&quot;100000&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;1024&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.lijian.model.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用POJO映射结果集 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findByUserId&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      select * from user where id = #{id}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用resultMap映射结果集 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findByUserName&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select * from user where name = #{name}      
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
=======================默认使用系统一级缓存=======================&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:26][org.apache.ibatis.cache.decorators.LoggingCache] - &lt;span&gt;Cache Hit Ratio [com.lijian.dao.UserMapper]: 0.0&lt;/span&gt;&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt;  Preparing: &lt;span&gt;select * from user where id = ?&lt;/span&gt;&lt;span&gt; 
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
[TRACE][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==&lt;span&gt;    Columns: id, name
[TRACE][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==        Row: 1&lt;span&gt;, Zhangsan
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.logging.jdbc.BaseJdbcLogger] - &amp;lt;==      Total: 1&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.cache.decorators.LoggingCache] - &lt;span&gt;Cache Hit Ratio [com.lijian.dao.UserMapper]: 0.0&lt;/span&gt;
=======================重新创建SqlSession=======================&lt;span&gt;
[DEBUG][main][&lt;/span&gt;2018-07-29 21:49:27][org.apache.ibatis.cache.decorators.LoggingCache] - &lt;span&gt;Cache Hit Ratio [com.lijian.dao.UserMapper]: 0.3333333333333333&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）作为新手很大可能在配置过程中会遇到很多坑（我就是其中之一），比如Mybatis的日志配置。这里可以主要参考：&lt;a title=&quot;Mybatis配置&quot; href=&quot;http://www.mybatis.org/mybatis-3/zh/configuration.html&quot; target=&quot;_blank&quot;&gt;http://www.mybatis.org/mybatis-3/zh/configuration.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（2）mybatis的相关配置文件（没有myabtis-config.xml）可以使用eclipse中的插件生成（具体网上有很多教程），但还要进行适当修改！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 14:07:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9387941.html</dc:identifier>
</item>
<item>
<title>auto类型-现代C++新特性 - 禾田守望者</title>
<link>http://www.cnblogs.com/Stephen-Qin/p/9387891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Stephen-Qin/p/9387891.html</guid>
<description>&lt;h2 id=&quot;auto类型&quot;&gt;auto类型&lt;/h2&gt;
&lt;p&gt;C++11中引入的auto主要用于类型推导。auto在C++98中“存储类型指示符”的语义，由于使用极少且多余，该语义从C++11开始被删除。&lt;/p&gt;
&lt;p&gt;auto类型推导用于从初始化表达式中推断出变量的数据类型，通过此方法可以有效简化代码：&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//简化前的代码

for (std::vector&amp;lt;std::string&amp;gt;::iterator i = vs.begin(); i != vs.end(); i++)
{
    //code
}


//简化后的代码

for (auto i = vs.begin(); i != vs.end(); i++)
{
    //code
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，auto能够自动推导出vs.begin()的类型，从而避免了冗长的类型说明。这个用法是我们大力推荐的。&lt;/p&gt;

&lt;p&gt;当auto用于模板定义中，其“自适应”性会得到更充分的体现。&lt;/p&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;

template&amp;lt;typename T1, typename T2&amp;gt;
double Sum(T1 &amp;amp; t1, T2 &amp;amp; t2)  //从c++14起，也可以支持函数返回值类型设为auto，这种用法多用于编写库的开发人员。
{
    auto s = t1 + t2;   //s的类型会在模板实例化时被推导出来
    return s;
}

int main()
{
    int a = 3;
    long b = 5;
    float c = 1.0f, d = 2.3f;

    auto e = Sum&amp;lt;int, long&amp;gt;(a, b);      //s的类型被推导为long
    auto f = Sum&amp;lt;float, float&amp;gt;(c, d);   //s的类型被推导为float
    std::cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; &quot;  &quot; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
    
    return 0;
}

//编译选项：g++ -std=c++11  auto1.cpp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，由于类型T1、T2要在模板实例化时才能确定，所以在Sum中将变量s的类型声明为auto。&lt;/p&gt;

&lt;p&gt;auto可以与指针和引用结合起来使用，使用效果符合我们的想象。如下例所示：&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;typeinfo&amp;gt;

int main()
{
    int x = 0;
    int *y = &amp;amp;x;

    auto &amp;amp;b = x;            //int&amp;amp;
    auto c = y;             //int*
    auto *d = y;            //int*
    auto e = b;             //int

    return 0;
}

//编译选项：g++ -std=c++11  auto2.cpp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本例中，对于c、d两个变量而言，声明其为auto*或auto并没有区别。&lt;/p&gt;
&lt;p&gt;而如果要使得auto声明的变量是另一个变量的引用，则必须使用auto&amp;amp;，如本例中的变量b。而本例中e没有带&amp;amp;，则被推导成int类型。正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。&lt;/p&gt;

&lt;p&gt;其次，auto与const和volatile之间也存在着一些相互关系。const和volatile代表了变量的两种不同的属性：易失和常量。在c++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。&lt;/p&gt;
&lt;p&gt;在深入介绍auto和cv限定符连用之前，先介绍下C++11中的顶层const和底层const。顶层const（top-level const）表示指针本身是一个常量，而底层const（low-level const）表示指针所指的对象是一个常量。&lt;/p&gt;
&lt;p&gt;更一般的，顶层const可以表示任意的对象是常量，这一点对于任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
int *const p1 = &amp;amp;i;         //顶层const
const int ci = 42;          //顶层const
const int *p2 = &amp;amp;ci;        //底层const
const int *const p3 = p2;   //右边的const是顶层const，左边的const是底层const
const int &amp;amp;r = ci;          //用于声明引用的const都是底层const&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，volatile与const的用法相似。&lt;/p&gt;

&lt;p&gt;鉴于cv限制符的特殊性，C++11标准规定auto可以与cv限制符一起使用。在连用时，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值时一个指向常量的指针时：&lt;/p&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 0;
const int ci = i, &amp;amp;cr = ci;
auto b = ci;    //b：int（ci的顶层const特性被忽略掉了）
auto c = cr;    //c：int（cr是ci的别名，ci本身是顶层const）
auto d = &amp;amp;i;    //d：int *（整数的地址就是指向整数的指针）
auto e = &amp;amp;ci;   //e：const int *（对常量对象取地址是一种底层const）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果希望推断出auto类型是一个顶层const，需要明确指出：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const auto f = ci; //ci的推演类型是int，f是const int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理volatile与auto连用的用法和const一致。&lt;/p&gt;

&lt;p&gt;auto在使用上的限制：以下四种情况特点基本类似，人为观察很容易能够推导出auto所在位置应有的类型，但现有标准还不支持这样的方式。&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;vector&amp;gt;
using namespace std;

void fun(auto x = 1)        //1:auto函数形参，无法通过编译
{}

struct str
{
    auto var = 10;          //2:auto非静态成员变量，无法通过编译
};

int main()
{
    char x[3];
    auto y = x;
    auto z[3] = x;          //3：auto数组，无法通过编译

    vector&amp;lt;auto&amp;gt; v = { 1 }; //4.auto模板参数（实例化时，）无法通过编译
    return 0;
}

//编译选项：g++ -std=c++11  auto3.cpp&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 13:58:00 +0000</pubDate>
<dc:creator>禾田守望者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Stephen-Qin/p/9387891.html</dc:identifier>
</item>
<item>
<title>seajs的原理以及基本使用 - 一步一步向上爬</title>
<link>http://www.cnblogs.com/z937741304/p/9387812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z937741304/p/9387812.html</guid>
<description>&lt;h3&gt;seajs模块化开发&lt;/h3&gt;
&lt;p&gt;　　模块化开发，把整个文件分割成一个一个小文件。&lt;/p&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;　　使用方法特别简单，首先在官网中下载sea.js，然后在页面中引入。&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.路径&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2.回调 (在js文件里定义的module.exports里定义的)&lt;/span&gt;
seajs.use('./js/part1.js',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dom) {
    console.log(dom);
    let a &lt;/span&gt;= dom('#box'&lt;span&gt;);
    console.log(a);
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;part1.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.在js文件里互相引用模块&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2.暂时不用管&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 3.导出(告诉别的文件可以使用我的xxx东西)&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require,exports,module) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是定义模块的地方&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(dom) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.querySelector(dom);
    }
    module.exports &lt;/span&gt;=&lt;span&gt; fn;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;有一些需要注意的地方&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require,exports,module){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的require就把他当成一个关键字就可以了，不要去改变他&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外这一种判断使用哪个模块的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;条件 这种情况就不推荐使用下面这种方式了，下面的会把两种都编译还是什么的，推荐使用require.async&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require,exports,module){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(a){
        require(&lt;/span&gt;'hello'&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        require(&lt;/span&gt;'word'&lt;span&gt;);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;require.async&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。&lt;span&gt;&lt;code&gt;callback&lt;/code&gt; &lt;span&gt;参数可选。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步加载一个模块，在加载完成时，执行回调&lt;/span&gt;
  require.async('./b', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(b) {
    b.doSomething();
  });
    
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步加载多个模块，在加载完成时，执行回调&lt;/span&gt;
  require.async(['./c', './d'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(c, d) {
    c.doSomething();
    d.doSomething();
  });
});
注意：require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;exports&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;exports&lt;/code&gt; &lt;span&gt;是一个对象，用来向外提供模块接口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports) {
​
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对外提供 foo 属性&lt;/span&gt;
  exports.foo = 'bar'&lt;span&gt;;
​
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对外提供 doSomething 方法&lt;/span&gt;
  exports.doSomething = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {};
​
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;除了给 &lt;span&gt;&lt;code&gt;exports&lt;/code&gt; &lt;span&gt;对象增加成员，还可以使用 &lt;span&gt;&lt;code&gt;return&lt;/code&gt; &lt;span&gt;直接向外提供接口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require) {
​
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 return 直接提供接口&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    foo: &lt;/span&gt;'bar'&lt;span&gt;,
    doSomething: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {}
  };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果 &lt;span&gt;&lt;code&gt;return&lt;/code&gt; &lt;span&gt;语句是模块中的唯一代码，还可简化为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;define({
  foo: &lt;/span&gt;'bar'&lt;span&gt;,
  doSomething: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上面这种格式特别适合定义 JSONP 模块。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;特别注意&lt;/strong&gt;&lt;span&gt;：下面这种写法是错误的！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误用法！！!&lt;/span&gt;
  exports =&lt;span&gt; {
    foo: &lt;/span&gt;'bar'&lt;span&gt;,
    doSomething: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {}
  };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;正确的写法是用 &lt;span&gt;&lt;code&gt;return&lt;/code&gt; &lt;span&gt;或者给 &lt;span&gt;&lt;code&gt;module.exports&lt;/code&gt; &lt;span&gt;赋值：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确写法&lt;/span&gt;
  module.exports =&lt;span&gt; {
    foo: &lt;/span&gt;'bar'&lt;span&gt;,
    doSomething: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {}
  };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;code&gt;exports&lt;/code&gt; &lt;span&gt;仅仅是 &lt;span&gt;&lt;code&gt;module.exports&lt;/code&gt; &lt;span&gt;的一个引用。在 &lt;span&gt;&lt;code&gt;factory&lt;/code&gt; &lt;span&gt;内部给 &lt;span&gt;&lt;code&gt;exports&lt;/code&gt; &lt;span&gt;重新赋值时，并不会改变 &lt;span&gt;&lt;code&gt;module.exports&lt;/code&gt; &lt;span&gt;的值。因此给 &lt;span&gt;&lt;code&gt;exports&lt;/code&gt; &lt;span&gt;赋值是无效的，不能用来更改模块接口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模拟他的原理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　步骤如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;​ 　　1.html文件： seajs.use(1,2)执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　2.插件： 模块插件 创建一个script标签 通过script把模块引入进来&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　 3.插件： 定义一个全局函数define，用来获取模块里面所写的代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　4.模块：模块文件里 执行defined（传入一个函数）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​　　5.插件： seajs.use插件 执行上一步的函数 并且传入三个参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　6.再执行模块里传入的参数过程中，改变了module&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 　　7.插件：插件里：执行回调函数，插件的第二个参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;　　​ 8.插件：删除掉上面加入的script标签&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;sea.js&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let seajs = {};&lt;br/&gt;seajs.use = function&lt;/span&gt;&lt;span&gt; seajs(url,cb) {
    let oScript &lt;/span&gt;= document.createElement('script'&lt;span&gt;);
    let s &lt;/span&gt;= document.getElementsByTagName('script')[0&lt;span&gt;];
    oScript.src &lt;/span&gt;=&lt;span&gt; url;
    s.parentNode.insertBefore(oScript,s);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;function fn(dom) {
        return document.querySelector(dom);
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    let require,
        exports,
        module &lt;/span&gt;=&lt;span&gt; {};
    window.define &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (fn) {
        fn(require,exports,module);
        cb(module.exports);
        s.parentNode.removeChild(oScript);
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
seajs('./a.js',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fn){
   let a &lt;/span&gt;=&lt;span&gt; fn('#box');
   console.log(a);      
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require,exports,module) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是定义模块的地方&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(dom) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.querySelector(dom);
    }
    module.exports &lt;/span&gt;=&lt;span&gt; fn;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码就是模拟了一下加载模块的原理，其实就是自己新建了一个script标签，将那个引入的模块添加到了当前页面当中，和JSONP差不多的原理，模块中的define函数自己执行，将里面的函数传递到sea.js插件中，然后再去做处理，sea.js将模块中的module.exports = 的东西提取出来，回调函数传递给index中，接受到了这个模块中的module.exports。&lt;/p&gt;
&lt;p&gt;　　其实我写的不是很清楚了，哈哈，可以用自己的方式去实现一下，我在这里写的这篇主要是对这两天学的一些东西做一下总结。&lt;/p&gt;
&lt;p&gt;　　当然，如果你能从中收获一些我会非常高兴的，如果看到这里感觉什么都没用可以去官网去查看，上面讲的非常清楚。&lt;a href=&quot;https://www.zhangxinxu.com/sp/seajs/#intro&quot; target=&quot;_blank&quot;&gt;sea.js官网&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 13:44:00 +0000</pubDate>
<dc:creator>一步一步向上爬</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z937741304/p/9387812.html</dc:identifier>
</item>
</channel>
</rss>