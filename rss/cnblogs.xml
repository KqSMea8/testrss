<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot系列——如何集成Log4j2 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</guid>
<description>&lt;p&gt;上篇《Spring Boot系列——日志配置》介绍了Spring Boot如何进行日志配置，日志系统用的是Spring Boot默认的LogBack。&lt;/p&gt;
&lt;p&gt;事实上，除了使用默认的LogBack，Spring Boot还可以使用Log4j、Log42等作为自己的日志系统。今天就那Log4j2来举例，说明Spring Boot是如何集成其他日志系统的。&lt;/p&gt;
&lt;h3 id=&quot;添加jar包依赖&quot;&gt;添加jar包依赖&lt;/h3&gt;
&lt;p&gt;上篇提到过，Spring Boot默认使用LogBack，但是我们没有看到显示依赖的jar包，其实是因为所在的jar包&lt;code&gt;spring-boot-starter-logging&lt;/code&gt;都是作为&lt;code&gt;spring-boot-starter-web&lt;/code&gt;或者&lt;code&gt;spring-boot-starter&lt;/code&gt;依赖的一部分。&lt;/p&gt;
&lt;p&gt;如果这里要使用Log4j2，需要从&lt;code&gt;spring-boot-starter-web&lt;/code&gt;中去掉&lt;code&gt;spring-boot-starter-logging&lt;/code&gt;依赖，同时显示声明使用Log4j2的依赖jar包，具体如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里顺便插一句，上面的依赖中，我们看到并没有声明版本，这是因为我在项目的父级pom文件中引入了dependencyManagement。&lt;/p&gt;
&lt;p&gt;大致说下，我们常见的dependency标签是用来引入需要依赖的jar用的。而dependencyManagement并不能起到同样的作用，它的作用可以用来声明版本规范。当在父级pom声明某个版本的依赖时，如果子pom所在项目并没有用到的话，是不会依赖这个声明的jar包的，需要在子pom主动添加依赖才生效，这个父级pom中的dependencyManagement是用来做统一版本的。&lt;/p&gt;
&lt;p&gt;具体看rome项目中的父级pom文件配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.jackie&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rome&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;rome&amp;lt;/name&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;springboot&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;wowjava&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;lombok.version&amp;gt;1.16.18&amp;lt;/lombok.version&amp;gt;
        &amp;lt;spring.boot.version&amp;gt;2.0.4.RELEASE&amp;lt;/spring.boot.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
                &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里放在denpendencyManagement中的denpendency都声明了版本，这样当子pom在继承这个父pom的时候，比如这里的&lt;code&gt;spring-boot-starter-log4j2&lt;/code&gt;就可以继承父pom中声明的&lt;code&gt;2.0.4.RELEASE&lt;/code&gt;，不需要再写version标签。这样做是方便项目的版本统一。&lt;/p&gt;
&lt;h3 id=&quot;添加配置文件log4j2.xml&quot;&gt;添加配置文件log4j2.xml&lt;/h3&gt;
&lt;p&gt;在resources目录下新建一个log4j2.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;configuration&amp;gt;
    &amp;lt;Appenders&amp;gt;
        &amp;lt;Console name=&quot;CONSOLE&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt;
            &amp;lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;[%-5p] %d %c - %m%n&quot; /&amp;gt;
        &amp;lt;/Console&amp;gt;

        &amp;lt;File name=&quot;File&quot; fileName=&quot;/Users/jackie/workspace/rome/springboot.log&quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&quot;%m%n&quot; /&amp;gt;
        &amp;lt;/File&amp;gt;
    &amp;lt;/Appenders&amp;gt;

    &amp;lt;Loggers&amp;gt;
        &amp;lt;root level=&quot;info&quot;&amp;gt;
            &amp;lt;AppenderRef ref=&quot;CONSOLE&quot; /&amp;gt;
            &amp;lt;AppenderRef ref=&quot;File&quot; /&amp;gt;
        &amp;lt;/root&amp;gt;
    &amp;lt;/Loggers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这里的xml标签和上篇介绍的差不多，都是定义了日志输出源以及日志格式的定义等，不在赘述。&lt;/p&gt;
&lt;p&gt;但是这样还不够，Spring Boot并不知道log4j2.xml是干嘛的，需要通过在application.properties文件中显示声明才行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
logging.config= classpath:log4j2.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行SpringBootDemoApplication&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232924693-1582485512.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果我们注释掉application.properties中的&lt;code&gt;logging.config= classpath:log4j2.xml&lt;/code&gt;，运行SpringBootDemoApplication&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232939863-1929913745.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出没有建立关联，所以log4j2.xml的配置也没有生效，此时Spring Boot的启动日志没有打印到控制台上。&lt;/p&gt;
&lt;p&gt;注意，这里有个“潜规则”。如果想在application.properties中注释掉和配置文件的关系前提下仍然能读取到配置文件的信息，可以这样做&lt;/p&gt;
&lt;p&gt;将log4j2.xml重命名为log4j2-spring.xml，这样运行SpringBootDemoApplication也是可以正常按照配置打印日志信息的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232950896-1258933773.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义日志配置&quot;&gt;自定义日志配置&lt;/h3&gt;
&lt;p&gt;根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Logback： logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Log4j： log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Log4j2： log4j2-spring.xml, log4j2.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JDK (Java Util Logging)： logging.properties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OK，Spring Boot有关日志配置的介绍就到此为止了，有问题下方留言一起讨论。&lt;/p&gt;
&lt;h3 id=&quot;项目代码地址&quot;&gt;项目代码地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DMinerJackie/rome&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请记住这个地址，后面可能很多文章的项目代码都会集中到这个项目。&lt;/p&gt;
&lt;p&gt;取名rome（罗马），源于谚语&lt;strong&gt;Rome was not built in one day&lt;/strong&gt;。翻译成中文就是我个人很喜欢的“不积跬步无以至千里，不积小流无以成江海”。&lt;/p&gt;
&lt;p&gt;没有哪一次commit能一步到位建成罗马，但是都是让现实越来越靠近梦想！&lt;/p&gt;
&lt;p&gt;项目的目录划分采用《没做过大项目，但我会建大项目》介绍的“大项目”结构，在每个module中都会有README.md，其主要记录了网上一些较好的参考资料以及在项目module主题遇到的问题，方便后续翻阅。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:32:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>除了上篇的Spring Boot内置的LogBack日志系统，Spring Boot又是如何集成其他日志系统的，比如Log4j2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</dc:identifier>
</item>
<item>
<title>springboot源码学习笔记之进入之前发生了啥 - 千里授渔</title>
<link>http://www.cnblogs.com/qlsy/p/9607550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qlsy/p/9607550.html</guid>
<description>&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;人称:&lt;/td&gt;
&lt;td&gt;露哥&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;QQ:&lt;/td&gt;
&lt;td&gt;408365330&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N01.编程就是验证学习的最好方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N02.为了挣钱所以编程，为了挣大钱所以写好代码，为了写好代码所以学习&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N03.好好学习天天编程&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;
&lt;p&gt;虽然用springboot也有一段时间,但是之前也没怎么关注过springboot项目打包过程中发生了什么，启动过程细节是什么！&lt;br/&gt;直到最近在搞公司的私有化大平台时需要了解更多的本质上的东西才细细品味了一下springboot的源码，从起源开始……&lt;/p&gt;
&lt;h2 id=&quot;springboot-程序长啥样身材和脸蛋&quot;&gt;springboot 程序长啥样（身材和脸蛋）？&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableAutoConfiguration
public class EgojitApplication {
    public static void main(String[] args) {
        SpringApplication.run(EgojitApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我第一眼看到特别亲切，这就是一个main程序啊；然后再看一眼，好像比普通的main上面多了两个注解,总以为两眼就了解她，和普通的main也没什么不同么啊，其实只是了解了身材和脸蛋；需要三回眸免得错过什么精彩内容；然后我使用 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 进行打包；生成一个jar包；既然要深入了解她的“品质”啊，那就得由内而外；unzip 这个美丽的jar吧；&lt;/p&gt;
&lt;h2 id=&quot;springboot的jar包内在品质&quot;&gt;springboot的jar包内在（品质）&lt;/h2&gt;
&lt;h3 id=&quot;名词说明&quot;&gt;名词说明&lt;/h3&gt;
&lt;p&gt;我们这里把由 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; maven插件打包的jar包称为“胖jar”或者“聚合jar”（不仅仅只有这一种打包胖jar的方式，我们约定胖jar就是spring-boot-maven-plugin插件打包的jar包，我喜欢约定）,把maven-jar-plugin 默认打包出来的jar包称为“瘦jar”或者“散jar”&lt;/p&gt;
&lt;h3 id=&quot;n01-有内涵&quot;&gt;N01 有内涵&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907231906317-889177525.png&quot; alt=&quot;springboot的jar包 BOOT-INF&quot;/&gt;&lt;br/&gt;unzip后发现这个和普通的main程序jar包完全不同啊，包含BOOT-INF，META-INF,org三个目录；然后可以看见BOOT-INF/classes才是真正的classpath,而传统的jar包直接解压后就是classpath&lt;/p&gt;
&lt;h3 id=&quot;n02-有特色&quot;&gt;N02 有特色&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907231952979-865934314.png&quot; alt=&quot;springboot的jar包 MAINFEST.MF&quot;/&gt;&lt;br/&gt;META-INF目录中我重点关注MANIFEST.INF文件，我看到了我不敢相信的一幕，她和普通main区别大大的，她可不是表面上看到的那样，入口main在JarLauncher中（记住它后面我们分析spring-boot-loader源码从它入手）；所以我推翻我之前的认知springboot的xxxApplicaion中的main不是普通的main。它只是一个被xxxApplicion调用的普通方法而已；和普通的MANIFEST.INF不同它还有一个Start-Class，不要怀疑这个就是我们写的xxxApplicaion; Spring-Boot-Classes指出了springboot的特殊class目录；Spring-Boot-Lib配置第三方依赖包目录&lt;/p&gt;
&lt;h3 id=&quot;n03-超仙&quot;&gt;N03 超仙&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907232018946-1867373201.png&quot; alt=&quot;springboot的jar包&quot;/&gt;&lt;/p&gt;
&lt;p&gt;org目录有点神奇，出现了超自然现象啊，我的项目绝对没有org.springframework.boot包啊。它从哪里来的？我怀疑人生的打开项目依赖找了一遍，我确定它是超自然现象，好仙，不是我等凡人容易理解的；我想到既然我没干什么，那就绝对是打包干的，谁打包？？？？？&lt;br/&gt;&lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 对！就是它，被我逮到了；它把项目打包成我们看到的目录结构，同时把spring-boot-loader jar包中的class拷贝到项目中了；&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-loader-分析&quot;&gt;spring-boot-loader 分析&lt;/h2&gt;
&lt;p&gt;以下是JarLauncher执行流程分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907232040887-629525085.png&quot; alt=&quot;JarLauncher执行流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过源码分析流程可以知道spring-boot-load模块通过自定义jar包结构自定义类加载器优雅的实现了嵌套jar资源的加载，通过打包时候重新设置启动类和组织jar结构，通过运行时设置自定义加载器来实现嵌套jar资源加载；&lt;br/&gt;知道这些我们可以实现自己的JarLauncher实现Archive动态指定实现插件化；既然spring-boot-loader能指定lib以及class目录，那么我们也可以实现自己的JarLauncher合并更多的lib目录，实现外部扩展lib，再结合spring boot中的spring.factries的原理扫描注入代码；公司的私有化平台中的应用托管就是我在研究spring-boot-loader这种原理结合spring boot中的spring.factries的机制基础上实现的；改造了原来基于java的jagent方式。这种方案解决了很多问题；其中第三方springboot应用日志采集，性能监控，健康检查等等都可以基于这个机制去实现（了解这个原理多么重要）；更多的就涉密了……。哈哈……&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:25:00 +0000</pubDate>
<dc:creator>千里授渔</dc:creator>
<og:description>spring-boot-loader原理解析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qlsy/p/9607550.html</dc:identifier>
</item>
<item>
<title>Spring系列(二) Bean装配 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9607524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9607524.html</guid>
<description>&lt;p&gt;创建应用对象之间协作关系的行为称为装配(wiring), 这也是DI的本质.&lt;/p&gt;
&lt;h2 id=&quot;spring中装配bean的方式&quot;&gt;Spring中装配Bean的方式&lt;/h2&gt;
&lt;p&gt;Spring提供了三种装配Bean的方式.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;隐式的Bean发现机制和自动装配&lt;/li&gt;
&lt;li&gt;Java Config&lt;/li&gt;
&lt;li&gt;Xml Config&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring可以任意选择三种方式其中的一种或多种组合. 但建议尽量使用自动装配方式以避免产生繁杂的xml配置文件及java代码, 其次是使用类型安全的Java Config, 如果都满足不了需求则最后再考虑xml config.&lt;/p&gt;
&lt;h2 id=&quot;自动配置&quot;&gt;自动配置&lt;/h2&gt;
&lt;p&gt;借助于下面两个方面Spring可以实现自动化Bean配置.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;组件扫描(component scanning): 自动发现上下文种创建的bean&lt;/li&gt;
&lt;li&gt;自动专配(autowiring) 自动创建对象间依赖&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一. 组件扫描:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt; 注解标记的java类会作为组件类. 带参的&lt;code&gt;@Component(&quot;beanid&quot;)&lt;/code&gt;, 参数为bean的名称, 默认为首字母小写的类名. &lt;code&gt;@Component&lt;/code&gt; 等同 &lt;code&gt;@Named&lt;/code&gt; 注解;&lt;br/&gt;对应xml配置节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt; 用来启动组件扫描, 默认的扫描范围是该注解标记的类所在的包. 带参的 &lt;code&gt;@ComponentScan(basePackages={&quot;basePackage1&quot;,&quot;basePackage2&quot;})&lt;/code&gt; 可以指定扫描的包范围 ; 带参的 &lt;code&gt;@ComponentScan(basePackageClasses={ClassNameA.class,InterfaceB.class})&lt;/code&gt;这些类或接口所在的包将作为扫描的基础包范围, 相比指定字符串的基础包, 这种方式提供了类型安全性(重构友好的);&lt;br/&gt;对应的xml配置节点是&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二. 自动装配&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@AutoWired&lt;/code&gt; 提供了自动装配能力. 构造器注入和setter注入均可以使用该注解, 事实上它可以在任何方法上发挥作用.&lt;code&gt;@AutoWired(required=false)&lt;/code&gt; 设置为false在没有匹配到bean时不会抛出异常. &lt;code&gt;@AutoWired&lt;/code&gt;等同于&lt;code&gt;@Inject&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-config&quot;&gt;Java Config&lt;/h2&gt;
&lt;p&gt;对于无法使用&lt;code&gt;@Conmponent&lt;/code&gt;和&lt;code&gt;@Autowired&lt;/code&gt;注解的, 比如第三方类库的组件, 可以使用java config的方式装配. 同时, javaconfig也是java代码, 他们不应该包含任何业务代码, 实际上两者应该完全分开,所以一般会将java config代码放在单独的包中.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt; 注解标识类是一个配置类.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Bean&lt;/code&gt; 注解的方法声明为返回bean. &lt;code&gt;@Bean(name='methodname')&lt;/code&gt; 参数标识bean的id名称, 默认为方法名称.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public A getA(){
    return new A();
}

@Bean
public B getB(){
    return new B(getA());
}

@Bean
public C getC(){
    return new C(getA());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码中构建组件B,C使用的构造器注入了A的bean&lt;code&gt;getA()&lt;/code&gt;, 在一般的java程序中B,C的Bean会分别持有A的不同实例, 但Spring中不是这样, 所有&lt;code&gt;getA()&lt;/code&gt;会被拦截, 并返回同一个bean. 默认情况下Spring的bean都是单例的.&lt;/p&gt;
&lt;p&gt;可以使用更为简单的方式创建B,C的bean, 代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public B getB(){
    return new B(A a); // 也可以使用setter方式, 或者任何其他方式创建bean
}

@Bean
public C getC(){
    return new C(A a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Import({ClassnameA.class,ClassnameB.class})&lt;/code&gt; 对于不同位置的bean, javaconfig可以使用此注解导入其他配置类.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;xml-config&quot;&gt;XML Config&lt;/h2&gt;
&lt;p&gt;XML是Spring最原始的装配方式, 熟悉Xml config对了解历史项目, 以及渐进重构到java config或自动配置都是有帮助的.&lt;/p&gt;
&lt;p&gt;xml配置构造器(setter)注入的方式有两种, 两种方式各有利弊:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;c-命名控制 或 p-命名空间 特点是简洁, 但不能注入集合; 使用时需要引入XSD.&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;配置文件的顶部需要声明多个XSD.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bean class=&quot;com.xlx.c02.MyClass&quot;&amp;gt;&lt;/code&gt; 声明了一个bean, 默认id为com.xlx.c02.MyClass#0, 可以使用属性id为bean指定名称&lt;code&gt;&amp;lt;bean id=&quot;myclass&quot; class=&quot;com.xlx.c02.MyClass&quot;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 用来配置构造器注入的参数, 引用其他bean时使用&lt;code&gt;&amp;lt;constructor-arg ref=&quot;otherBeanId&quot;&amp;gt;&lt;/code&gt;, 等同c-命名空间的属性&lt;code&gt;c:otherBean-ref='otherBeanId'&lt;/code&gt;, 或者参数数字索引&lt;code&gt;c:_0-ref='otherBeanId'&lt;/code&gt;(单参数可以省略数字); 也可以注入字面量值&lt;code&gt;&amp;lt;constructor-arg value=&quot;this is value&quot;&amp;gt;&lt;/code&gt; 等同c-命名空间的属性&lt;code&gt;c:_name='jery'&lt;/code&gt;,或 &lt;code&gt;c:_0='jery'&lt;/code&gt;(单参数可省略数字)&lt;/li&gt;
&lt;li&gt;装配集合&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;constuctor-arg&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/constuctor-arg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置属性: &lt;code&gt;&amp;lt;property name=&quot;propertyName&quot; ref=&quot;beanId&quot;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;p:propertyName-ref=&quot;beanId&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;util 命名空间的功能可以简化一些字面量属性设置, 同样,需要首先声明XSD.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--定义集合--&amp;gt;
&amp;lt;util:list id=&quot;trackList&quot;&amp;gt;
    &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
&amp;lt;/util:list&amp;gt;

&amp;lt;!--p-命名的方式引用集合--&amp;gt;
p:tracks-ref=&quot;trackList&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;混合配置&quot;&gt;混合配置&lt;/h2&gt;
&lt;p&gt;一. Java Config引用其他&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Import&lt;/code&gt; 可以导入java配置类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ImportResource&lt;/code&gt; 可以导入xml配置, 如&lt;code&gt;@ImportResource(&quot;classpath:my-config.xml&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二. XML Config 引用其他&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;import resource='my-config.xml'&amp;gt;&lt;/code&gt; 引用其他xml配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 引用java config&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管如何引用, 创建一个根配置会使配置更具层次, 更易于阅读管理.&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>创建应用对象之间协作关系的行为称为装配(wiring), 这也是DI的本质. Spring中装配Bean的方式 Spring提供了三种装配Bean的方式. 1. 隐式的Bean发现机制和自动装配 2.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9607524.html</dc:identifier>
</item>
<item>
<title>关于 MongoDB 与 SQL Server 通过本身自带工具实现数据快速迁移 及 注意事项 的探究 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9607515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9607515.html</guid>
<description>&lt;h2&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;随着业务的发展、需求的变化，促使我们追求使用不同类型的数据库，充分发挥其各自特性。如果决定采用新类型的数据库，就需要将既有的数据迁移到新的数据库中。在这类需求中，将SQL Server中的数据导入到MongoDB 中显得尤为突出。&lt;/p&gt;
&lt;p&gt;面对这种需求，大家优先想到的就是百度查找第三方工具，可惜截止目前，还没有一款公认比较满意的数据迁移工具。百度不到，大家可能就要回头自己开发了。如此，更是花费不少人力物力和宝贵的精力。甚至，由于没有理想的迁移工具，导致项目优化一再延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实，你原本不必如此！因为，还有一个工具，并且性能还傲视群雄。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那就是充分挖掘数据库自身的导出导入功能。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;原理&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;MongoDB数据库 可以通过mongoexport/mongoimport命令进行数据的导出导入，并且支持文件CSV格式；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server 数据库 一样可以进行导出导入【“任务”—&amp;gt;导出数据/导入数据】，其数据一样可以保存到CSV文件中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么，我们是不是可以借助 CSV文件，在这两种数据库间进行数据迁移呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;答案是肯定的！答案是肯定的！答案是肯定的！&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此外，数据直接导出导入，性要比其它工具快一个数量级。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;即：&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过SQL Server 和 MongoDB 本身自带的 导入导出功能 ，可以实现数据的快速迁移&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt; 将SQL Server中的数据导入到MongoDB中&lt;/h2&gt;

&lt;p&gt;step 1 选择指定数据库，进行【导出数据】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222401689-1812385615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 2  选择导出的数据源信息&lt;/p&gt;
&lt;p&gt;因在SQL Server 服务器上执行，服务器名称可选择本地（. 即可），身份认证可以使用Window身份验证（如SQL Server 禁用了此window登入方式，那么就要使用SQL Server 身份验证），然后，选择数据库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222604064-1387060112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 3 选择导出目标（此为&lt;strong&gt;关键步骤&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;目标一定要选择 &lt;strong&gt;&lt;span&gt;【平面文件目标】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222717864-1798420642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为 导出文件命名 选择 【浏览】，在打开的 界面上 选择导出文件类型&lt;strong&gt;&lt;span&gt;【CSV 文件（*.csv）】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222811714-1456177146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，文件命名为SQLToMongoDB01&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222837927-875625145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 【下一步】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222908380-1786291049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 4  指定表复制 或 查询&lt;/p&gt;
&lt;p&gt;可以指定从数据源复制一个或多个表和视图，还是通过 T_SQL 语句从数据源中复制查询结（可以指定选择列 或对列二次加工后的数据）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222952794-1124494023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 5  配置平面文件目标&lt;/p&gt;
&lt;p&gt;在这一步选择要导出的表或视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223025832-2037098857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想对 field 字段 进行修改，可以选择 &lt;span&gt;&lt;strong&gt;【编辑映射】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对想要修改的列命进行重命名，例如 将SQL Server 中的 AreaCode 命名 而在MongoDB中命名为 AreaCodeMongoDB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223129574-2059987106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后 点击 【下一步】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223720517-691737529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 6 保存并运行包&lt;/p&gt;
&lt;p&gt;直接点击 【下一步】&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223820486-55251772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 7 完成该向导&lt;/p&gt;
&lt;p&gt;直接点击 【完成】&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223831006-779156624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据导出成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223857617-308251871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导出数据&lt;strong&gt;&lt;span&gt;773838&lt;/span&gt;&lt;/strong&gt; 笔数据。&lt;/p&gt;

&lt;p&gt;Step 8 将产生的文件Copy至 MongoDB 服务器上&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;Step 9 在mongoDB 服务器上 执行 mongoimport 命令， 将从 SQL Server 导出的csv 数据导入到MongoDB中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令 为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoimport --file /data/mongodb_back/SQLToMongoDB01.csv  -h 172.X.X.XXX --port 端口  --type csv --headerline -u 用户名 -p '密码' -d testdba0906 --authenticationDatabase 认证数据库 -c SQLToMongoDB01&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224028349-32781890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行成功，导入数据 &lt;strong&gt;&lt;span&gt;773838&lt;/span&gt;&lt;/strong&gt; 个文档。并且可以看到很快，不到15S。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;span&gt;此部分 测试验证OK！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;将 MongoDB中的数据导入的SQL Server 中&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;Step 1 使用 mongoexport 将MongoDB数据库中的数据导出&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;/data/mongodb/mongobin344/bin/mongoexport   -h 172.X.X.X --port 端口  --type csv  -u 用户名 -p '密码' -d testdba0906 --authenticationDatabase 认证数据库  -c SQLToMongoDB01  -f 字段1,字段2,字段3,字段4,字段5 -o  /data/mongodb_back/MongoDBToSQL.csv &lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;Step 2  将从MongoDB中导出的CSV 文件上传到 SQL Server 服务器上。&lt;/p&gt;

&lt;p&gt;Step 3 将CSV 文件导入到SQL Server中&lt;/p&gt;
&lt;p&gt;（此过程，不是本文章的重点，所以不再详细说明，只指出关键步骤。）&lt;/p&gt;
&lt;p&gt;选择数据源，请选择&lt;span&gt;&lt;strong&gt;【平面文件源】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224356790-1223906565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择源表和源视图 【可以通过编辑映射，修改列名，修改字段类型，修改字段长度】&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224423186-1400844074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224439610-1705770013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 4  数据导出成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224524368-247168520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查数据量和源表数据一致。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此部分 测试验证OK！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;注意1&lt;/strong&gt;&lt;/em&gt;： 因为 mongoimport 导入的文件默认是json 格式，所以csv 文件，一定要在命令中指明 --type csv&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则，就无法识别文件中的数据。报错信息：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Failed: error processing document #1: invalid character 'X' looking for beginning of value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224741579-1170801006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（X代表文件中的第一个字符）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 2&lt;/strong&gt;&lt;/em&gt; ：  mongoimport 导入的csv文件，一定要执行 –headerline 参数，指明不导入第一行。csv格式的文件第一行为列名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则 ，提示一定要指明字段属性，报错信息：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;error validating settings: must specify --fields, --fieldFile or --headerline to import this file type&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;注意 3&lt;/em&gt;&lt;/strong&gt; ：CSV 文件的列数据中不可以包含“” （中文双引号）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则，当导入此行数据时，提示错误信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Failed: read error on entry #XXXX: line XXXX, column 110: bare &quot; in non-quoted-field&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907225134045-1506637258.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 4&lt;/strong&gt;&lt;/em&gt;： 如果数据中含有中文，需检查导入后是否变成了乱码。&lt;/p&gt;
&lt;p&gt;为防止乱码，需要将csv文档改成utf-8的编码方式即可。例如使用edit with notepad ++ 编辑器打开文件，另存为utf-8就可以了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 5&lt;/strong&gt;&lt;/em&gt;：MongoDB导出CSV格式一定要通过 –f 参数 指明字段名，负责报错：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Failed: CSV mode requires a field list。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 6&lt;/strong&gt;&lt;/em&gt;：MongoDB DB 数据模式自由，并且文档可以内嵌，所以将MongoDB中的数据导入到SQL Server 比较困难，特别是含有中文语句时。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 7&lt;/strong&gt;&lt;/em&gt; : SQL Server 导出数据时，字段数据中不可以包含nchar(9)、nchar(32)、nchar(160) 等特殊字符，否则，在导出数据生成csv文件时报错。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>背景介绍 随着业务的发展、需求的变化，促使我们追求使用不同类型的数据库，充分发挥其各自特性。如果决定采用新类型的数据库，就需要将既有的数据迁移到新的数据库中。在这类需求中，将SQL Server中的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9607515.html</dc:identifier>
</item>
<item>
<title>面向对象 - cherry小樱桃</title>
<link>http://www.cnblogs.com/surewing/p/9607455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surewing/p/9607455.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 面向对象&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;面向对象：&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;类：&lt;/h2&gt;
&lt;p&gt;任何事物归为一类，就是一系列相似特征与技能的结合体；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;强调：站在不同的角度得到的分类是不一样的；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;对象和类&quot;&gt;对象和类：&lt;/h3&gt;
&lt;p&gt;在现实世界中：先有对象，后有总结出来的类&lt;br/&gt;在程序中：先有类，然后调用类来产生对象；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;类就相当于模版，然后才造对象；&lt;br/&gt;例如：&lt;br/&gt;王二丫：&lt;br/&gt;特征:&lt;br/&gt;--------学校：&lt;br/&gt;--------名字：&lt;br/&gt;--------性别：&lt;br/&gt;--------年龄：&lt;br/&gt;技能：&lt;br/&gt;--------吃饭：&lt;br/&gt;--------学习：&lt;br/&gt;--------睡觉：&lt;br/&gt;李三：&lt;br/&gt;特征：&lt;br/&gt;--------学校：&lt;br/&gt;--------名字：&lt;br/&gt;--------性别：&lt;br/&gt;--------年龄：&lt;br/&gt;技能：&lt;br/&gt;--------吃饭：&lt;br/&gt;--------学习：&lt;br/&gt;--------睡觉：&lt;br/&gt;相似的特征：&lt;br/&gt;学习，吃饭，睡觉&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;so:先定义类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#先定义类
class Student:
    schoole='home'
    #功能---用方法表示
    def learn(self):
        print('learn')
    def sleep(self):
        print('sleep')
    def eat(self):
        print('eat')
#产生对象，最终程序的运行就是对象调用的；
stu1=Student()#实例化对象
stu2=Student()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用类&quot;&gt;如何使用类：&lt;/h2&gt;
&lt;p&gt;类和函数的区别，类在定义的时候，就会就会被执行，但是函数只有在调用的时候，才会被执行；&lt;/p&gt;
&lt;p&gt;在内存里面，执行类的时候，会有一个名称空间来存放类的名称空间；&lt;br/&gt;查看类的名称空间:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(Student.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类是一系列对象相似的特证与技能的集合：特征在程序中用：变量表示，技能用函数表示：类的内部无非就是变量的定义与函数的定义，但是python不限制，写其他的代码在类里面；&lt;/p&gt;
&lt;p&gt;类的用法：无非就是一些名字，技能，针对这些东西，进行增删改查，就是通过类的名称空间来进行这些操作：如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    schoole='home'
    #功能---用方法表示
    def learn(self):
        print('learn')
    def sleep(self):
        print('sleep')
    def eat(self):
        print('eat')
print(Student.__dict__['school'])
print(Student.__dict__['eat'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何使用对象&quot;&gt;如何使用对象：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/bxw3j21i0tmn8t1u3tz3u0zu/image.png&quot; alt=&quot;image.png-57.6kB&quot;/&gt;&lt;br/&gt;如上图的代码：&lt;br/&gt;stu1,就是一个实例化的对象，这个对象有个两个功能，学习，吃饭，属相是同一个学校；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;但是特殊的对象怎么办？就是有些对象有个性化的设置：&lt;br/&gt;__init__用来为对象定义对象独有的特征；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class luffStudent:
    school='luffcity'
    def __init__(self,name,age,sex):
        self.Name=name
        self.Age=age
        self.Sex=sex
    def learn(self):
        print('is learning')
    def eat(self):
        print('is sleeping')
stu1=LuffyStudent()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上述代码执行：&lt;br/&gt;结果会报错:&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/ljq4ddwv3x4k76u3e9xvxcez/image.png&quot; alt=&quot;image.png-22.8kB&quot;/&gt;&lt;br/&gt;这里用户会很懵逼：明明我们只是创建了一个类而已，并没有调用__init__方法，以上错误说明，是python自己调用，就是在你实例化的时候，就会调用这个方法，&lt;/p&gt;
&lt;p&gt;针对上述的代码：我们进行修改为：&lt;br/&gt;stu1=LuffyStudent('wang','nv','45')&lt;/p&gt;
&lt;p&gt;在次执行上述代码，不会报错了；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;现在有__init__方法的时候，在实例化的时候：&lt;br/&gt;1.先产生一个对象，&lt;br/&gt;2.触发__init__会返回类的函数属性，里面有几个参数传几个参数，其实self就是LuffyStudent()空对象而已；然后self就是这个空对象，他会当做第一个参数传给__init__,&lt;br/&gt;3.然后传：'wang','nv','45'&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;访问属性：&lt;br/&gt;print(stu1.Name)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;同样我们可以对属性进行增删改查：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/n6ysiks8q9zxpphvqjhtu24k/image.png&quot; alt=&quot;image.png-49.5kB&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 14:46:00 +0000</pubDate>
<dc:creator>cherry小樱桃</dc:creator>
<og:description>面向对象 标签（空格分隔）： 面向对象 面向对象： 类： 任何事物归为一类，就是一系列相似特征与技能的结合体； 强调：站在不同的角度得到的分类是不一样的； 对象和类： 在现实世界中：先有对象，后有总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surewing/p/9607455.html</dc:identifier>
</item>
<item>
<title>OpenCV 使用 findContours 函数 Note1: 利用各个轮廓的相互阶层（hierarchy）关系 - MsPark</title>
<link>http://www.cnblogs.com/SarahPaulson/p/9607410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SarahPaulson/p/9607410.html</guid>
<description>&lt;p&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;​&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212510288-410097084.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;194&quot;/&gt;输入图像&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Detect_Object(Mat img)
{
    Mat gray, binaryIMG;
    Mat correct_IMG;

    cvtColor(img, gray, CV_BGR2GRAY);
    Canny(gray, binaryIMG, &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;, &lt;span&gt;180&lt;/span&gt;&lt;span&gt;);
    blur(binaryIMG, binaryIMG, Size(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find contours&lt;/span&gt;
    vector&amp;lt;vector&amp;lt;Point&amp;gt; &amp;gt;&lt;span&gt; contours;
    vector&lt;/span&gt;&amp;lt;Vec4i&amp;gt;&lt;span&gt; hierarchy;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; TargetArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    findContours(binaryIMG, contours, hierarchy, RETR_TREE, CV_CHAIN_APPROX_NONE, Point(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先上代码， 上述函数是寻找一个图像内的所有轮廓。&lt;/p&gt;
&lt;p&gt;执行后，利用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
drawContours(img, contours, i, Scalar(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;, Point());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个函数，会画出所有图像内的轮廓。&lt;/p&gt;
&lt;p&gt;执行上述代码后，我的代码上显示 contour.size() ,即轮廓个数是34个。 这个轮廓个数不是绝对的， 结果由你对canny()选取的阈值， blur() mask的大小选取都有影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212752710-1274643595.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Canny 和 Blurring 算法结果图像。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212923569-1595166025.png&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色显示的是 FindContours函数所检测到的轮廓。&lt;/p&gt;

&lt;p&gt;你或许会觉得，最终显示的结果像一幅捕捉边缘的图像，即Edge Map。也会不解，有了Canny，何须多此一举在寻找轮廓。&lt;/p&gt;
&lt;p&gt;接下来我就要介绍本章的主角轮廓 Hierarchy的阶层关系。&lt;/p&gt;
&lt;p&gt;先看一段修改后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;3&lt;/span&gt;] == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());
            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码中，多了一段条件语句，语句里写了 &lt;/p&gt;
&lt;pre&gt;
hierarchy[i][3] == -1
&lt;/pre&gt;
&lt;p&gt;首先，我们确认一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907213906487-1446149151.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次的结果里，只检测出了最外围轮廓。很明显&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
hierarchy[i][3] == -1 起了决定性的作用。 &lt;p&gt;我们先看看OpenCV官方文件是怎么写的。
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;OpenCV represents it as an array of four values : &lt;strong&gt;[Next, Previous, First_Child, Parent].   (&lt;a href=&quot;https://docs.opencv.org/3.4.0/d9/d8b/tutorial_py_contours_hierarchy.html&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt; me: https://docs.opencv.org/3.4.0/d9/d8b/tutorial_py_contours_hierarchy.html)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
hierarchy[i][3] == -1， 这里的hierarchy[i]指的是第i个轮廓的阶层关系。而hierarchy[i][0],hierarchy[i][1],hierarchy[i][2],hierarchy[i][3]分别指的是Next, Previous, First_child, Parent。&lt;p&gt;我们设定的hierarchy[i][3]== -1 的意思就是 “轮廓没有父母”， 即“这个轮廓没有上层阶级的轮廓”。&lt;/p&gt;&lt;p&gt;同理， hierarchy[i][2]== -1 的意思就是 “此轮廓没有第一个孩子”，即“此轮廓没有下层阶级的轮廓”。&lt;/p&gt;&lt;p&gt;至于，hierarchy[][0],hierarchy[][1] 指的是此轮廓的后一个轮廓，和前一个轮廓。他们都是同一个阶级的轮廓。这个前后顺序可能是很随意的，至今还没找到规律。所以还没有到怎么利用他们。&lt;/p&gt;&lt;p&gt;所以，
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
hierarchy[i][3]== -1 条件下的结果， 是选中了没有父母的轮廓，即他的外围没有包围他的轮廓。&lt;p&gt;再看看
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
hierarchy[i][2]== -1 条件下的结果：
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907220205470-570318093.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;

&lt;pre readability=&quot;24&quot;&gt;
和预想的一样，它只标出了没有“孩子”的轮廓，即此轮廓内没有更小的轮廓。&lt;p&gt;对了，我要强调一下，这个例子里我在使用FindContours函数的时候，我用了&lt;strong&gt;RETR_TREE&lt;/strong&gt; 模式。这个模式是“万能的”，把图像内各轮廓的亲属关系都联系上了。简而言之，你能知道一个轮廓的”爷爷奶奶“，”孙子孙女“。甚至更深的祖辈关系。 &lt;/p&gt;&lt;p&gt;opencv 提供了各种模式，RETR_LIST, RETR_EXTERNAL等。 上面的官方文件有详细说明。&lt;br/&gt;RETR_LIST 就是这个图像的轮廓只可能是两个阶层的其中之一，要么你就是爹， 要么你就是儿子。本章只讲RETR_TREE。&lt;/p&gt;&lt;p&gt;这时候你可能还没领会到Hierarchy的魅力。 他不会马上帮你挑出你最想要的信息，但是他确实个帮你排除“杂质”帮手。&lt;/p&gt;&lt;p&gt;例如， 我们这次测试的Heliport图像， 很明显这个图像里的“H”是叫无人机去识别， 并且在其中心降落的。 那我们怎么去识别他呢？ 如果不用Deep Learning。&lt;/p&gt;&lt;p&gt;我们可以在这个图像里找没有孩子的轮廓，但没有孩子的轮廓候补也很多。怎么办？ &lt;br/&gt;很简单， 选取轮廓面积最大的，或者大于一定面积以上的，其实方法真的很多。只要你多加一个条件语句。&lt;/p&gt;&lt;p&gt;简单的看下代码：
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;2&lt;/span&gt;] == -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; contourArea(contours[i]) &amp;gt; &lt;span&gt;9800&lt;/span&gt;&lt;span&gt;)
            {
                drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());

            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;我加了一段 面积大于 9800 像素的条件。结果就找到了 “H”。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907222304853-814899664.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你问我怎么算的9800？ 估算的， 但是我想说的不是面积这部分，利用面积也只是方法之一。 想要更精确确定的方法有很多。比如是高和宽的比例。&lt;/p&gt;
&lt;p&gt;今天主要是为了介绍hierarchy的魅力，其实利用好真的能排除很多没用的信息。hierarchy 只是OpenCV Contours 这部分的魅力之一， 仔细翻阅官方文件你会发现，opencv 这部分还真的准备了很多宝贝。&lt;/p&gt;





&lt;p&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;&lt;span data-cke-copybin-end=&quot;1&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 14:29:00 +0000</pubDate>
<dc:creator>MsPark</dc:creator>
<og:description>​输入图像 先上代码， 上述函数是寻找一个图像内的所有轮廓。 执行后，利用 这个函数，会画出所有图像内的轮廓。 执行上述代码后，我的代码上显示 contour.size() ,即轮廓个数是34个。 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SarahPaulson/p/9607410.html</dc:identifier>
</item>
<item>
<title>python并发编程(并发与并行，同步和异步，阻塞与非阻塞） - zhangyafei</title>
<link>http://www.cnblogs.com/zhangyafei/p/9606765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyafei/p/9606765.html</guid>
<description>
&lt;p&gt;　　最近在学python的网络编程，学会了socket通信，并利用socket实现了一个具有用户验证功能，可以上传下载文件、可以实现命令行功能，创建和删除文件夹，可以实现的断点续传等功能的FTP服务器。但在这当中，发现一些概念区分起来很难，比如并发和并行，同步和异步，阻塞和非阻塞，但是这些概念却很重要。因此在此把它总结下来。&lt;/p&gt;
&lt;p&gt;　　1.并发 &amp;amp; 并行&lt;/p&gt;
&lt;p&gt;　　并发：在&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192&quot; target=&quot;_blank&quot; data-lemmaid=&quot;192&quot;&gt;操作系统&lt;/a&gt;中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842&quot; target=&quot;_blank&quot; data-lemmaid=&quot;128842&quot;&gt;处理机&lt;/a&gt;上运行，但任一个时刻点上只有一个程序在处理机上运行。简言之，是指系统具有处理多个任务的能力。&lt;/p&gt;
&lt;p&gt;　　并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。简言之，是指系统具有同时处理多个任务的能力。&lt;/p&gt;
&lt;p&gt;　　下面我们来两个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_aa745bd4-d033-42f6-aa1a-b61652d8010c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa745bd4-d033-42f6-aa1a-b61652d8010c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa745bd4-d033-42f6-aa1a-b61652d8010c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; threading &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线程&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; music():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin to listen music {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stop to listen music {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; game():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin to play game {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))
    time.sleep(&lt;/span&gt;5&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stop to play game {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    music()
    game()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ending.....&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907185647612-373999301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;music的时间为3秒，game的时间为5秒，如果按照我们正常的执行，直接执行函数，那么将按顺序顺序执行，整个过程8秒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_64c1b95e-393c-4bfa-acd3-2ce11c8b6eac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_64c1b95e-393c-4bfa-acd3-2ce11c8b6eac&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_64c1b95e-393c-4bfa-acd3-2ce11c8b6eac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; threading &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线程&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; music():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin to listen music {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stop to listen music {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; game():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin to play game {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))
    time.sleep(&lt;/span&gt;5&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stop to play game {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(time.ctime()))


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t1 &lt;/span&gt;= threading.Thread(target=music) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个线程对象t1 子线程&lt;/span&gt;
    t2 = threading.Thread(target=game) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个线程对象t2 子线程&lt;/span&gt;
&lt;span&gt;
    t1.start()
    t2.start()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; t1.join() #等待子线程执行完 t1不执行完，谁也不准往下走&lt;/span&gt;
&lt;span&gt;    t2.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ending.......&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(time.ctime())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907185120785-1261695809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在这个例子中，我们开了两个线程，将music和game两个函数分别通过线程执行，运行结果显示两个线程同时开始，由于听音乐时间3秒，玩游戏时间5秒，所以整个过程完成时间为5秒。我们发现，通过开启多个线程，原本8秒的时间缩短为5秒，原本顺序执行现在是不是看起来好像是并行执行的？看起来好像是这样，听音乐的同时在玩游戏，整个过程的时间随最长的任务时间变化。但真的是这样吗？那么下面我来提出一个GIL锁的概念。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;GIL(全局解释器锁）：无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_4551c3af-caf6-40c0-a7e3-5a053bbb0003&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4551c3af-caf6-40c0-a7e3-5a053bbb0003&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4551c3af-caf6-40c0-a7e3-5a053bbb0003&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add():
    sum &lt;/span&gt;=&lt;span&gt; 0
    i &lt;/span&gt;= 1
    &lt;span&gt;while&lt;/span&gt; i&amp;lt;=1000000&lt;span&gt;:
        sum &lt;/span&gt;+=&lt;span&gt; i
        i &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,sum)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mul():
    sum2 &lt;/span&gt;= 1&lt;span&gt;
    i &lt;/span&gt;= 1
    &lt;span&gt;while&lt;/span&gt; i&amp;lt;=100000&lt;span&gt;:
        sum2 &lt;/span&gt;= sum2 *&lt;span&gt; i
        i &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,sum2)


start &lt;/span&gt;=&lt;span&gt; time.time()

add()
mul() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;串行比多线程还快&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cost time %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(time.time()-start))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907190648935-1432787589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_51882fd5-f96e-41cf-99ec-007551835a82&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_51882fd5-f96e-41cf-99ec-007551835a82&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_51882fd5-f96e-41cf-99ec-007551835a82&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add():
    sum &lt;/span&gt;=&lt;span&gt; 0
    i &lt;/span&gt;= 1
    &lt;span&gt;while&lt;/span&gt; i&amp;lt;=1000000&lt;span&gt;:
        sum &lt;/span&gt;+=&lt;span&gt; i
        i &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,sum)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mul():
    sum2 &lt;/span&gt;= 1&lt;span&gt;
    i &lt;/span&gt;= 1
    &lt;span&gt;while&lt;/span&gt; i&amp;lt;=100000&lt;span&gt;:
        sum2 &lt;/span&gt;= sum2 *&lt;span&gt; i
        i &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,sum2)


start &lt;/span&gt;=&lt;span&gt; time.time()
t1 &lt;/span&gt;= Thread(target=&lt;span&gt;add)
t2 &lt;/span&gt;= Thread(target=&lt;span&gt;mul)

l &lt;/span&gt;=&lt;span&gt; []
l.append(t1)
l.append(t2)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l:
   t.start()

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l:
    t.join()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cost time %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(time.time()-start))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907190746966-1746241927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　哎吆，这是怎么回事，串行执行比多线程还快？不符合常理呀。是不是颠覆了你的人生观，这个就和GIL锁有关，同一时刻，系统只允许一个线程执行，那么，就是说，本质上我们之前理解的多线程的并行是不存在的，那么之前的例子为什么时间确实缩短了呢？这里有涉及到一个任务的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;--任务： 1.IO密集型（会有cpu空闲的时间）  注：sleep等同于IO操作， socket通信也是IO  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;        2.计算密集型&lt;br/&gt;　　而之前那个例子恰好是IO密集型的例子，后面这个由于涉及到了加法和乘法，属于计算密集型操作，那么，就产生了一个结论，多线程对于IO密集型任务有作用，&lt;br/&gt;而计算密集型任务不推荐使用多线程。&lt;br/&gt;　　而其中我们还可以得到一个结论：由于GIL锁，多线程不可能真正实现并行，所谓的并行也只是宏观上并行微观上并发，本质上是由于遇到io操作不断的cpu切换&lt;br/&gt;所造成并行的现象。由于cpu切换速度极快，所以看起来就像是在同时执行。&lt;br/&gt;　　--问题：没有利用多核的优势&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    --这就造成了多线程不能同时执行，并且增加了切换的开销，串行的效率可能更高。&lt;br/&gt;2.同步 &amp;amp; 异步&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;同步：当进程执行IO(等待外部数据）的时候，-----等。同步（例如打电话的时候必须等）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;异步：当进程执行IO(等待外部数据）的时候，-----不等，去执行其他任务，一直等到数据接收成功，再回来处理。异步（例如发短信）&lt;br/&gt;当我们去爬取一个网页的时候，要爬取多个网站，有些人可能会发起多个请求，然后通过函数顺序调用。执行顺序也是先调用先执行。效率非常低。&lt;br/&gt;下面我们看一下异步的一个例子：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;&lt;img id=&quot;code_img_closed_e1a737db-eaac-4a85-8778-c289ed87303e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1a737db-eaac-4a85-8778-c289ed87303e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1a737db-eaac-4a85-8778-c289ed87303e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; select

&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
########http请求本质，IO阻塞########
sk = socket.socket()
#1.连接
sk.connect(('www.baidu.com',80,)) #阻塞
print('连接成功了')
#2.连接成功后发送消息
sk.send(b&quot;GET / HTTP/1.0\r\nHost: baidu.com\r\n\r\n&quot;)

#3.等待服务端响应
data = sk.recv(8096)#阻塞
print(data) #\r\n\r\n区分响应头和影响体

#关闭连接
sk.close()
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
########http请求本质，IO非阻塞########
sk = socket.socket()
sk.setblocking(False)
#1.连接
try:
    sk.connect(('www.baidu.com',80,)) #非阻塞，但会报错
    print('连接成功了')
except BlockingIOError as e:
    print(e)

#2.连接成功后发送消息
sk.send(b&quot;GET / HTTP/1.0\r\nHost: baidu.com\r\n\r\n&quot;)

#3.等待服务端响应
data = sk.recv(8096)#阻塞
print(data) #\r\n\r\n区分响应头和影响体

#关闭连接
sk.close()
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpRequest:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,sk,host,callback):
        self.socket &lt;/span&gt;=&lt;span&gt; sk
        self.host &lt;/span&gt;=&lt;span&gt; host
        self.callback &lt;/span&gt;=&lt;span&gt; callback

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fileno(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.socket.fileno()


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpResponse:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,recv_data):
        self.recv_data &lt;/span&gt;=&lt;span&gt; recv_data
        self.header_dict &lt;/span&gt;=&lt;span&gt; {}
        self.body &lt;/span&gt;=&lt;span&gt; None

        self.initialize()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; initialize(self):
        headers, body &lt;/span&gt;= self.recv_data.split(b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r\n\r\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1&lt;span&gt;)
        self.body &lt;/span&gt;=&lt;span&gt; body
        header_list &lt;/span&gt;= headers.split(b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; h &lt;span&gt;in&lt;/span&gt;&lt;span&gt; header_list:
            h_str &lt;/span&gt;= str(h,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            v &lt;/span&gt;= h_str.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(v) == 2&lt;span&gt;:
                self.header_dict[v[0]] &lt;/span&gt;= v[1&lt;span&gt;]


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncRequest:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.conn &lt;/span&gt;=&lt;span&gt; []
        self.connection &lt;/span&gt;= [] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于检测是否已经连接成功&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_request(self,host,callback):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            sk &lt;/span&gt;=&lt;span&gt; socket.socket()
            sk.setblocking(0)
            sk.connect((host,&lt;/span&gt;80&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; BlockingIOError as e:
            &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
        request &lt;/span&gt;=&lt;span&gt; HttpRequest(sk,host,callback)
        self.conn.append(request)
        self.connection.append(request)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            rlist,wlist,elist &lt;/span&gt;= select.select(self.conn,self.connection,self.conn,0.05&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; wlist:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(w.host,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;连接成功...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只要能循环到，表示socket和服务器端已经连接成功&lt;/span&gt;
                tpl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET / HTTP/1.0\r\nHost:%s\r\n\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  %&lt;span&gt;(w.host,)
                w.socket.send(bytes(tpl,encoding&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
                self.connection.remove(w)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; r &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rlist:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; r,是HttpRequest&lt;/span&gt;
                recv_data =&lt;span&gt; bytes()
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                        chunck &lt;/span&gt;= r.socket.recv(8096&lt;span&gt;)
                        recv_data &lt;/span&gt;+=&lt;span&gt; chunck
                    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
                response &lt;/span&gt;=&lt;span&gt; HttpResponse(recv_data)
                r.callback(response)
                r.socket.close()
                self.conn.remove(r)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(self.conn) ==&lt;span&gt; 0:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(response):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;保存到文件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,response.header_dict)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2(response):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;保存到数据库&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, response.header_dict)


url_list &lt;/span&gt;=&lt;span&gt; [
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.youku.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callback&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: f1},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v.qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callback&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: f2},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.cnblogs.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callback&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: f2},
]

req &lt;/span&gt;=&lt;span&gt; AsyncRequest()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_list:
    req.add_request(item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callback&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

req.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907194715434-1383627968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到，三个请求发送顺序与返回顺序，并不一样，这样就体现了异步请求。即我同时将请求发送出去，哪个先回来我先处理哪个。&lt;/p&gt;
&lt;p&gt;　　即我们可以理解为：我打电话的时候只允许和一个人通信，和这个人通信结束之后才允许和另一个人开始。这就是同步。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　我们发短信的时候发完可以不去等待，去处理其他事情，当他回复之后我们再去处理，这样就大大解放了我们的时间。这就是异步。&lt;/p&gt;
&lt;p&gt;　　体现在网页请求上面就是我请求一个网页时候等待他回复，否则不接收其它请求，这就是同步。另一种就是我发送请求之后不去等待他是否回复，而去处理其它请求，当处理完其他请求之后，某个请求说，我的回复了，然后程序转而去处理他的回复数据。这就是异步请求。所以，异步可以充分cpu的效率。&lt;/p&gt;

&lt;p&gt;　　3.阻塞 &amp;amp; 非阻塞&lt;/p&gt;
&lt;pre&gt;
　　调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。&lt;br/&gt;下面我们通过socket实现一个命令行功能来感受一下。&lt;br/&gt;　　
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_0bdbdfea-2871-48f6-85c6-1d1f43bd9ece&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bdbdfea-2871-48f6-85c6-1d1f43bd9ece&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bdbdfea-2871-48f6-85c6-1d1f43bd9ece&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务端&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; subprocess
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; struct

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 8000&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;
backlog &lt;/span&gt;= 5&lt;span&gt;

tcp_server &lt;/span&gt;=&lt;span&gt; socket(AF_INET, SOCK_STREAM)
tcp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,&lt;/span&gt;1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;就是它，在bind前加&lt;/span&gt;
&lt;span&gt;tcp_server.bind(ip_port)
tcp_server.listen(backlog)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    conn, addr &lt;/span&gt;=&lt;span&gt; tcp_server.accept()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;新的客户端链接：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, addr)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            cmd &lt;/span&gt;=&lt;span&gt; conn.recv(buffer_size)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;收到客户端命令:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, cmd.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行命令cmd，得到命令的结果cmd_res&lt;/span&gt;
            res = subprocess.Popen(cmd.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),shell=&lt;span&gt;True,
                                   stderr&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,
                                   stdout&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,
                                   stdin&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,
                                   )
            err &lt;/span&gt;=&lt;span&gt; res.stderr.read()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; err:
                cmd_res &lt;/span&gt;=&lt;span&gt; err
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                cmd_res &lt;/span&gt;=&lt;span&gt; res.stdout.read()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; cmd_res:
                cmd_res &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解决粘包&lt;/span&gt;
            length =&lt;span&gt; len(cmd_res)
            data_length &lt;/span&gt;= struct.pack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,length)
            conn.send(data_length)
            conn.send(cmd_res)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    conn.close()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8000&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;
backlog &lt;/span&gt;= 5&lt;span&gt;

tcp_client &lt;/span&gt;=&lt;span&gt; socket(AF_INET,SOCK_STREAM)
tcp_client.connect(ip_port)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    cmd &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; cmd:
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; cmd == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    tcp_client.send(cmd.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解决粘包&lt;/span&gt;
    length = tcp_client.recv(4&lt;span&gt;)
    length &lt;/span&gt;= struct.unpack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,length)[0]

    recv_size &lt;/span&gt;=&lt;span&gt; 0
    recv_msg &lt;/span&gt;= b&lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; recv_size &amp;lt;&lt;span&gt; length:
        recv_msg &lt;/span&gt;+=&lt;span&gt; tcp_client.recv(buffer_size)
        recv_size &lt;/span&gt;=&lt;span&gt; len(recv_msg)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(recv_msg.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907205811984-1319154944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启了服务器和一个客户端之后，我们在客户端输入一些命令，然后正确显示，功能实现。这是在我再打开一个客户端，输入命令，发现服务器迟迟没有响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907210109452-1742060025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就是当一个客户端在请求的时候，当这个客户端没有结束的时候，服务器不会去处理其他客户端的请求。这时候就阻塞了。&lt;/p&gt;
&lt;p&gt;如何让服务器同时处理多个客户端请求呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_b95bd508-3883-4ec8-9785-032aa7093a07&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b95bd508-3883-4ec8-9785-032aa7093a07&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b95bd508-3883-4ec8-9785-032aa7093a07&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务端&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socketserver


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Myserver(socketserver.BaseRequestHandler):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;socketserver内置的通信方法&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conn is:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,self.request)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;conn&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;addr is:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,self.client_address)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;addr&lt;/span&gt;

        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息&lt;/span&gt;
                data = self.request.recv(1024&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; data:&lt;span&gt;break&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;收到的客户端消息是:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),self.client_address)

                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息&lt;/span&gt;
&lt;span&gt;                self.request.sendall(data.upper())
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    s &lt;/span&gt;= socketserver.ThreadingTCPServer((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8000), Myserver)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通信循环&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; s = socketserver.ForkingTCPServer(('127.0.0.1',8000), Myserver)  #通信循环&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s.server_address)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s.RequestHandlerClass)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Myserver)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s.socket)
    s.serve_forever()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8000&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;
backlog &lt;/span&gt;= 5&lt;span&gt;

tcp_client &lt;/span&gt;=&lt;span&gt; socket(AF_INET,SOCK_STREAM)
tcp_client.connect(ip_port)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; msg == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

    tcp_client.send(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    data &lt;/span&gt;=&lt;span&gt; tcp_client.recv(buffer_size)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

tcp_client.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907212328999-965443681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1476293/201809/1476293-20180907212344154-358473140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这段代码通过socketserver模块实现了socket的并发。这个过程中，当一个客户端在向服务器请求的时候，另一个客户端也可以正常请求。服务器在处理一个客户端请求的时候，另一个请求没有被阻塞。&lt;/p&gt;
&lt;p&gt;　　这里面其实涉及到的知识点还很多，这里只是凭我的记忆简单总结了一下，以后会补充更多。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 13:31:00 +0000</pubDate>
<dc:creator>zhangyafei</dc:creator>
<og:description>最近在学python的网络编程，学会了socket通信，并利用socket实现了一个具有用户验证功能，可以上传下载文件、可以实现命令行功能，创建和删除文件夹，可以实现的断点续传等功能的FTP服务器。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyafei/p/9606765.html</dc:identifier>
</item>
<item>
<title>设计模式之策略模式 - 程序员luis</title>
<link>http://www.cnblogs.com/liuyi6/p/9606980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyi6/p/9606980.html</guid>
<description>&lt;p&gt;最近在读《Head First设计模式》一书，为加强记忆及便于日后查阅，在博客将自己的学习过程进行记录。谨以本篇策略模式作为设计模式系列的开篇章，并在后续过程中不断丰富自己的博客内容，欢迎各位进行浏览。&lt;/p&gt;

&lt;p&gt;现有一游戏SimDuck，游戏采用OO技术开发，其中会出现各种各样的鸭子，可以一边游泳一边呱呱叫。现在要对游戏内容进行丰富，使得鸭子能够飞起来。&lt;/p&gt;

&lt;h2 id=&quot;思路1继承&quot;&gt;思路1：继承&lt;/h2&gt;
&lt;p&gt;在Duck父方法中加入fly()方法，简单快捷的实现鸭子的飞行&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147448/201809/1147448-20180907205049150-2109527223.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存在问题：&lt;br/&gt;若加入塑料橡皮鸭，木头诱饵鸭，继承Duck类之后，会出现橡皮鸭、诱饵鸭飞行的闹剧，因而在父类中加入fly()方法的思路不可行。&lt;/p&gt;
&lt;h2 id=&quot;思路2改进继承&quot;&gt;思路2：改进继承&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147448/201809/1147448-20180907205116950-1680066140.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flyable与Quackable虽然解决了一些问题，但却造成代码无法复用，若有上百个鸭子类，每个都要修改飞行类，这简直就是一个噩梦。因而，我们要考虑其他的实现思路.&lt;/p&gt;
&lt;h2 id=&quot;思路3策略模式实现&quot;&gt;思路3：策略模式实现&lt;/h2&gt;
&lt;p&gt;接下来我们就用策略模式的方式实现SimDuck的需求。&lt;br/&gt;由上面分析可知，鸭子的quack()行为有“呱呱”、“吱吱”...... fly()行为有能自己飞的、不能飞的、依靠外力飞的...... 因而选择将这些不同的部分拿出来，建一组新类代表每个行为。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147448/201809/1147448-20180907205146076-1501775814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在设计这些行为类的过程中，我们想要鸭子的行为可以动态的改变，并得到指定行为的鸭子实例。因而我们选择使用接口的方式构建鸭子行为，类图如下所示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147448/201809/1147448-20180907205208745-744768845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的设计，可以让飞行与和呱呱叫的动作被其他对象复用，同时可以在新增行为的过程中，不会影响到既有的行为类，这样就有了继承的“复用”好处，却又没有继承带来的麻烦。&lt;br/&gt;整合鸭子的行为&lt;br/&gt;在Duck类中“加入两个实力变量”，分别为flyBehavior和quackBehavior,声明为接口类型，每个鸭子对象都会动态的设置变量以在运行时引用正确的行为类型。&lt;br/&gt;Dack类代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Duck {
    QuackBehavior quackBehavior;
    FlyBehavior flyBehavior;

    public abstract void display();
    public void performFly(){
        flyBehavior.fly();
    }
     public void performQuack(){
        quackBehavior.quack;
    }
    
    public void setFlyBehavior(FlyBehavior fb){
        flyBehavior = fb;
    }
    public void setQuackBehavior(QuackBehavior qb){
        quackBehavior = qb;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fly算法族的代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface flyBehavior{
    public void fly();
}

public class FlyWithWings implents flyBehavior{
    public void fly(){
        System.out.println(&quot;I'm flying&quot;);
    }
}

public class FlyNoWay implents flyBehavior{
    public void fly(){
        System.out.println(&quot;I can't fly&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;quack算法族的代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface quackBehavior{
    public void quack();
}
public class Quack implents quackBehavior{
    public void quack(){
        System.out.println(&quot;Quack&quot;);
    }
}
public class MuteQuack implents quackBehavior{
    public void quack(){
        System.out.println(&quot;...silence...&quot;);
    }
}
public class Squeak implents quackBehavior{
    public void quack(){
        System.out.println(&quot;Squeak&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们编辑一下测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MiniDuckSimulator{
    public static void main(String[] args){
        Duck mallard = new MallardDuck();
        mallard.proformQuack();
        mallard.profpormFly();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态行为设定&quot;&gt;动态行为设定&lt;/h2&gt;
&lt;p&gt;现在加入模型鸭，其通过火箭实现飞行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ModelDuck extends Duck{
    public ModelDuck(){
        quackBehavior = new Quack;
        flyBehavior = new FlyNoWay();
    }
    public void display(){
        System.out.printin(&quot;I;m a model duck&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建FlyBehavior类型FlyRocketPowered&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FlyRocketPowered implements FlyBehavior{
    public void fly(){
        System.out.println(&quot;Im fly with rocket!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改测试类使得模型鸭具有火箭动力&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MiniDuckSimulator{
    public static void main(String[] args){
        Duck mallard = new MallardDuck();
        mallard.proformQuack();
        mallard.profpormFly();

        Duck model = new DuckModel();
        model.proformFly();
        model.setFlyBehavior(new FlyRocketPowered());
        model.performFly();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经完成了鸭子模拟器的设计，我们看一下整体的类结构，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147448/201809/1147448-20180907205248430-1654607832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略模式定义了算法族，各个算法族分别封装起来，每个算法族内的类可以相互替换，使得算法的变化独立于算法使用者。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的过程中，我们发现前两种思路存在缺点，而走在我们前面的优秀程序员们就针对这些缺点总结了相应的软件设计原则：&lt;/p&gt;
&lt;h2 id=&quot;设计原则一分开变化与不变化&quot;&gt;设计原则一：分开变化与不变化&lt;/h2&gt;
&lt;p&gt;即，找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。这个原则几乎是每个设计模式背后的精神所在，所有的模式都提供了一套方法让系统中的某部分改变不会影响其它部分。将会变化的部分封装起来，以后可以轻易的针对此部分进行改动或扩充，不影响其他部分。在SimDuck设计过程中我们将变化的fly与quack独立出来，使得整个系统变得更有弹性。&lt;/p&gt;
&lt;h2 id=&quot;设计原则之二针对接口编程而不是针对实现编程&quot;&gt;设计原则之二：针对接口编程而不是针对实现编程&lt;/h2&gt;
&lt;p&gt;在SimDuck原有的设计中，行为来自Duck父类的具体实现，或由子类继承接口后自行实现。这两种做法都是依赖于实现编程。在策略模式实现中我们将行为写在实现FlyBehavior和QuackBehavior的类中。&lt;br/&gt;针对接口编程的关键在于多态，利用多态，程序员可以实现针对超类型编程，执行时根据实际状况执行真正的行为。“针对超类型编程”可以更加准确的说为变量的声明类型应为超类型，通常为一个抽象类或接口，故只要具体实现次超类型的类所产生的对象，都可以指定给这个变量。即声明类时可以不用理会以后执行的真正的对象类型。&lt;/p&gt;
&lt;h2 id=&quot;设计原则之三多用组合少用继承&quot;&gt;设计原则之三：多用组合，少用继承&lt;/h2&gt;
&lt;p&gt;使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为，只要组合的对象符合正确的额接口标准即可。&lt;/p&gt;

&lt;h2 id=&quot;使用方式&quot;&gt;使用方式&lt;/h2&gt;
&lt;p&gt;一个系统有许多类，区分它们的只是他们直接的行为，在这种情况下，定义算法族,把它们封装成实现同一个接口的类, 使它们可相互替换。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。&lt;br/&gt;2、一个系统需要动态地在几种算法中选择一种。&lt;br/&gt;3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。&lt;/p&gt;
&lt;h2 id=&quot;策略模式的优缺点&quot;&gt;策略模式的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;策略模式的优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;算法可以自由的切换，通过实现抽象策略，通过封装角色对其封装，保证对外提供“可自由切换”的策略。&lt;/li&gt;
&lt;li&gt;避免使用多重条件判断，如果有多重策略，那么每个策略只需实现自己的方法，至于采用何种策略，可以通过其他模块决定。&lt;/li&gt;
&lt;li&gt;扩展性良好，可以在现有的系统中任意的加入新的策略，只需继承IStrategy接口，符合OCP原则。&lt;br/&gt;&lt;strong&gt;策略模式缺点&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;策略类数量增多，每个策略都是一个类，复用的可能性很小，类数量增多&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;所有的策略都需要对外暴露，上层模块必须知道有哪些策略，然后才能知道采用哪种策略，可以通过使用工厂方法模式、代理模式和享元模式修正。&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要参考自《Head First设计模式》一书&lt;br/&gt;另参考文章：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/wolf-sun/p/3534573.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/wolf-sun/p/3534573.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.runoob.com/design-pattern/strategy-pattern.html&quot; class=&quot;uri&quot;&gt;http://www.runoob.com/design-pattern/strategy-pattern.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhanglei93/p/6081019.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhanglei93/p/6081019.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 12:53:00 +0000</pubDate>
<dc:creator>程序员luis</dc:creator>
<og:description>前言 最近在读《Head First设计模式》一书，为加强记忆及便于日后查阅，在博客将自己的学习过程进行记录。谨以本篇策略模式作为设计模式系列的开篇章，并在后续过程中不断丰富自己的博客内容，欢迎各位进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyi6/p/9606980.html</dc:identifier>
</item>
<item>
<title>在Vue 中使用Typescript - stone-lyl</title>
<link>http://www.cnblogs.com/stone-lyl/p/9606917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stone-lyl/p/9606917.html</guid>
<description>&lt;h2 id=&quot;什么是typescript&quot;&gt;什么是typescript&lt;/h2&gt;
&lt;p&gt;typescript 为 javaScript的超集，这意味着它支持所有都JavaScript都语法。它很像JavaScript都强类型版本，除此之外，它还有一些扩展的语法，如interface/module等。&lt;br/&gt;typescript 在编译期会去掉类型和特有语法，生成纯粹的JavaScript。&lt;/p&gt;
&lt;p&gt;Typescript 5年内的热度随时间变化的趋势，整体呈现一个上升的趋势。也说明ts越来越️受大家的关注了。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/uc5rb6yzcbj7oxhy2xngrniw/image.png&quot; alt=&quot;google 趋势&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装typescript&quot;&gt;安装typescript&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install -g typescript
tsc greeter.ts&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;举个栗子&quot;&gt;举个栗子&lt;/h2&gt;
&lt;p&gt;左右对比可以看出typescript 在编译期会去掉类型和特有语法，生成纯粹的JavaScript。&lt;br/&gt;greeter.ts&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;
}

let user = { firstName: &quot;Jane&quot;, lastName: &quot;User&quot; };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;greeter.js&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function greeter(person) {
    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;
}
var user = { firstName: &quot;Jane&quot;, lastName: &quot;User&quot; };&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为什么需要使用它&quot;&gt;为什么需要使用它？&lt;/h2&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;静态类型检查&lt;/li&gt;
&lt;li&gt;IDE 智能提示&lt;/li&gt;
&lt;li&gt;代码重构&lt;/li&gt;
&lt;li&gt;可读性&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;静态类型检查&quot;&gt;1. 静态类型检查&lt;/h3&gt;
&lt;p&gt;静态类型检查首要优点就是能尽早的发现逻辑错误，而不是上线之后才发现。&lt;br/&gt;1.1 类型分析&lt;br/&gt;传参过程字段错误，或类型错误使用。（进行参数标注后，在编码过程中即可检查出错误。)&lt;br/&gt;1.2 类型推断：函数的返回值可通过ts类型推断得出.这一步骤是 在编译时进行&lt;br/&gt;在编译时进行类型分析&lt;/p&gt;
&lt;p&gt;example：&lt;br/&gt;eg1: 我在使用ts写vue-router 的 动态路径参数时就发现了一个问题, 动态路径参数 以冒号开头 path: '/user/:id',我们会误认为id为一个number,如果使用ts你将得到提示 我们应该传入一个string类型的id. 传入一个number类型的id可能并不会出错,js会对它进行隐式类型转换,但是传入一个string会使它更安全和规范.&lt;/p&gt;
&lt;p&gt;eg2: 个人使用后的效果&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person): string {
    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;
}

let user = { firstName: 1223, lastname: &quot;User&quot; };

greeter(user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/krgdk24drxkdbf2fu5mw6khj/image.png&quot; alt=&quot;greeter error&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;智能补全&quot;&gt;2.智能补全&lt;/h3&gt;
&lt;p&gt;在编写代码时ide就会提示函数签名.&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;interface Person {
    firstName: string;
    lastName: string;
}
/**
 * 问候语句
 * @param {Person} person
 * @returns {string}
 */
function greeter(person: Person): string {
    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;
}

/**
 * hello word!
 *
 * @param {string} word
 * @returns {string}
 */
function Hello(word: string): string {
    return &quot;hello,&quot; + word;
}

export { greeter, Hello };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接将这个ts文件引入到其他ts文件中，不仅补全了所有的参数类型，还告诉你需要填入一个参数，并且你只有填入一个Person类型的对象才不会报错。(智能补全和参数校验）&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/9ap8ogxxal6s7qs5hxeouzee/image.png&quot; alt=&quot;greeter 函数&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在重构上&quot;&gt;3.在重构上&lt;/h3&gt;
&lt;p&gt;动态一时爽,重构火葬场.&lt;br/&gt;typescript 在重构上的优势，我们主要从三方面说明。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;重命名符号，可将一切引用的地方都进行修改。&lt;br/&gt;在vs code 中如果我们想修改函数、变量或者类的名称,我们可以使用重命名符号的功能,在当前项目中正确的修改所有的引用.这个既可以在ts中使用,也可以在js中使用，而它的底层实现都是依靠ts 的语法分析器实现的。&lt;/li&gt;
&lt;li&gt;自动更新引用路径（vs code）。&lt;br/&gt;在重构的过程中，我们可能需要移动文件的路径，这往往会导致其他地方的import失效，这时候vs code提供了自动更新引用路径的功能。它的底层实现也是依靠ts 的语法分析器实现的。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;校验函数签名。&lt;br/&gt;有时候我们会重构类或函数的签名，如果有引用到的地方忘记修改，除了运行时候能发现，其他时候往往难以察觉，且 ESLint 也只能是排查简单的问题，所以出了BUG会非常麻烦。 而 TypeScript 不一样，在编码时就能及时的发现哪里错了，哪里应该改动但没有修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[函数签名 MDN][5]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;可读性&quot;&gt;4. 可读性&lt;/h3&gt;
&lt;p&gt;可读性上，TypeScript 明显占优，查看开源代码时，如果注释不是很完善，往往会看的云里雾里，而 TypeScript 在同等条件下，至少有个类型，能让自己更容易明白代码的参数、返回值和意图。&lt;/p&gt;
&lt;h2 id=&quot;tsvue初探&quot;&gt;TS+Vue初探&lt;/h2&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;在正式开发之前，我们需要了解一些基本的配置。&lt;br/&gt;1.tsconfig.json 是 ts 项目的编译选项配置文件. 在 ts 项目中如果你不添加这份文件，ts 会使用默认的配置. 扫描二维码获取配置项目。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/jx28yg3z2c6kggzmmpb89afy/image.png&quot; alt=&quot;tsconfig.json 配置&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ts-loader：Webpack 的TypeScript 加载器，就是为了让 webpack 编译 .ts .tsx文件。&lt;/li&gt;
&lt;li&gt;TSLint：.ts .tsx文件的代码风格检查工具。（作用类似于ESLint）&lt;/li&gt;
&lt;li&gt;vue-shim.d.ts：由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，放在项目根目录下，例如 src/vue-shim.d.ts。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/ulit0btsv0smx78ttluygjq9/image.png&quot; alt=&quot;vue-shim.ts&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;在vue里面写ts的方式&quot;&gt;在Vue里面写TS的方式&lt;/h3&gt;
&lt;p&gt;图中内容应写在script中的lang=&quot;ts&quot; 。&lt;br/&gt;上图：使用 Vue.extend的基础用法。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/p6ijpj7tixc3yda0ux92eify/image.png&quot; alt=&quot;vue.extend&quot;/&gt;&lt;br/&gt;下图：基于类的Vue组件&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/gjxdq0yaly4t7dmm9jmbbrhv/image.png&quot; alt=&quot;vue 组件&quot;/&gt;&lt;br/&gt;通过对比我们发现，上面的编码方式更接近我们平时JS的写法，但是我们并不能感受到ts的类型检查和类型推断。&lt;br/&gt;下面张图的写法更有助于我们得到ts的类型检查。这需要我们引入 vue-class-component ，虽然template中还是不能得到补全，但是script 中的内容得到了更好的补全。 下面我们了解一下vue-class-component的作用。&lt;/p&gt;
&lt;h3 id=&quot;vue-class-component-vue-property-decorator&quot;&gt;vue-class-component &amp;amp; vue-property-decorator&lt;/h3&gt;
&lt;p&gt;vue-class-component 强化 Vue 组件，使用装饰器语法使 Vue 组件更好的跟TS结合使用。&lt;br/&gt;vue-property-decorator在 vue-class-component 的基础上增加了更多与 Vue 相关的装饰器，使Vue组件更好的跟TS结合使用。&lt;/p&gt;
&lt;p&gt;这两者都是离不开装饰器的，（decorator）装饰器已在ES提案中。Decorator是装饰器模式的实践。装饰器模式呢，它是继承关系的一个替代方案。动态地给对象添加额外的职责。在不改变接口的前提下，增强类的性能。下面我们以 钢铁侠 为例讲解如何使用 ES7 的 decorator。&lt;/p&gt;
&lt;p&gt;以钢铁侠为例，钢铁侠本质是一个人，只是“装饰”了很多武器方才变得那么 NB，不过再怎么装饰他还是一个人，它本质是没有被改变的。所以，装饰器没有改变其继承关系，但也同样能够为它添加很多厉害的技能。简单的说，装饰器是在不修改一个类的继承关系的前提下，为一个类修改或添加成员。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/ezvpvqmlexd1y6qs86ayprmr/image.png&quot; alt=&quot;superman&quot;/&gt;&lt;br/&gt;装饰器主要接收的三个参数：&lt;br/&gt;target 要在其上定义属性的对象。&lt;br/&gt;key 要定义或修改的属性的名称。&lt;br/&gt;descriptor 将被定义或修改的属性描述符。&lt;br/&gt;下面我们通过代码中我们为一个人添加了飞行的功能：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/kub8lkexr4gzdkb813n77ped/image.png&quot; alt=&quot;decoractor&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;typescript-vs-javascript&quot;&gt;typescript VS JavaScript&lt;/h3&gt;
&lt;p&gt;了解了上面的基础知识，现在我将同一段代码分别使用js 和 ts来书写，现在我们来对比他们之间的差别。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/yc8wozq2monkmkig8wezb8jx/image.png&quot; alt=&quot;js vs ts&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Props (Properties)&lt;br/&gt;使用js，我们有很多中方式来定义组件的 Props，但是大多都掺杂了 Vue 的私有特征，与 ES 格格不入，例如左边的代码，明明我们是把这个对象的 prop 属性定义成为了一个包含两个 string 元素的对象，但是我们却可以直接通过这个对象来访问 &quot;name&quot; 字段，这很明显是不符合 ES 语义的。&lt;br/&gt;再来看看右边的 TS 选手，通过 Prop 装饰器把指定的字段标记为了 Prop，既保留了 ES 语法的语义，而且还能与 Vue 完美的配合，更棒的是，我们可以在编码的过程中享受 TS 对 Prop 字段的静态类型检查。&lt;/li&gt;
&lt;li&gt;Method 和 data&lt;br/&gt;再来看看 Method，JS 中定义 method 还是有我们上面提到的那个不符合 ES 语义的毛病。而在 TS 中，method 不需要额外的装饰器——实例方法就会自动成为 Vue 组件的 method。类似的还有 data ，使用 TS 的语法，实例字段即可自动成为 Vue 组件的 data。&lt;/li&gt;
&lt;li&gt;Computed&lt;br/&gt;在传统的使用 JS 编写的 Vue 代码中，如果要定义计算属性，我们需要在 computed 属性中定义相应的函数。而这在 ES 中其实早就已经有了对应语义的语法——getter，所以在使用了 vue-class-component 的 vue 组件中，我们可以直接使用 getter 来定义计算属性，不管是在语法上还是在语义上，相比普通的 JS 都略胜一筹&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结：我们使用vue-class-component让vue组件的定义更加符合ES语义，使得TS能够更好的进行语法分析，并基于此进行类型检查。&lt;/p&gt;
&lt;h2 id=&quot;业务场景中使用ts-vue&quot;&gt;业务场景中使用TS + Vue&lt;/h2&gt;
&lt;h3 id=&quot;在vue项目中定义data和props&quot;&gt;1. 在Vue项目中定义data和props&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/q1shwpvbw79e6rc940usnc93/image.png&quot; alt=&quot;vue-property-decorator&quot;/&gt; 这样的写法，让我产生了两个疑惑。&lt;br/&gt;1.1 为什么使用 的写法&lt;br/&gt;@Prop(Number!:) propA!: number&lt;br/&gt;而不是&lt;br/&gt;@Prop(Number) propA: number&lt;br/&gt;1.2 为什么Prop需要前后写两次类型？&lt;/p&gt;
&lt;p&gt;自我自答环节：&lt;br/&gt;答1.1：因为我们定一个Phone这个类，没有对phone、condition这些字段通过constructor进行初始化，所以需要在属性上使用 显式赋值断言来帮助类型系统识别类型，这样能够让属性会被间接地初始化。&lt;br/&gt;答1.2：前面括号里面的类型标注是Vue提供的类型检查。冒号后面的是为TS提供的类型标注。&lt;/p&gt;
&lt;h3 id=&quot;编写一个函数&quot;&gt;2. 编写一个函数&lt;/h3&gt;
&lt;p&gt;这里我们将使用到js的接口，它经常用于定义复杂的参数类型和返回值类型。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/8lp1pkxodx3zirxpzcrdxju3/image.png&quot; alt=&quot;interface&quot;/&gt;&lt;br/&gt;上面的例子，我们需要为opts这个参数定义类型，方便后面编码时的使用，这时我们就需要编写一个接口来对它进行类型定义。这个接口里面包括三个必须属性和一个可选属性。必须属性在对象初始化的时候必须赋值，但是有时候某个对象中的属性可以被忽略的，不一定会被需要。我们可以将它设置为可选项。&lt;/p&gt;
&lt;p&gt;随着业务的发展，一些参数的字段会变的越来越多，越来越复杂。可能你想有没有什么一劳永逸的方法，让接口更加简单，甚至让它自动的适应业务的变化。于是我想出了这样的代码：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/8dju7mjvdt4zv1y6rusjoyuk/image.png&quot; alt=&quot;type interface&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码： 定义了一个键为string，他的值为number或string类型的接口，并且该接口的所有字段都是可选的，你甚至可以传入一个空对象。所以我们可以使用上面的接口可以代替下面的接口,但是反之不行.&lt;/p&gt;
&lt;p&gt;然而我们不应该去绕开这些检查，因为这样ts就不会为你检查使用接口的对象应该存在那些属性或者方法了。使用ts的意义就被大大减弱了。&lt;/p&gt;
&lt;h3 id=&quot;编写第三方依赖&quot;&gt;3. 编写第三方依赖&lt;/h3&gt;
&lt;p&gt;在日常的开发过程中，我们经常会遇到将第三方依赖引入到 TS 项目中没有类型检查的问题，这往往是因为这些项目没有提供类型定义文件。这个时候，我们可以手动为这些第三方库编写类型定义文件，类型定义文件在编译后会被完全忽略，所以并不会对现有代码产生影响。以上面这个较为复杂的函数为例，它的作用是将传入的所有的参数的所有字段合并到一个新的对象中并返回，尽管他的功能比较简单，但是为它编写类型定义还是需要一些 TS 的技巧。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/9rlmvxhv09c7fh06zdboqc97/image.png&quot; alt=&quot;assgin&quot;/&gt;1. 外部模块声明： 首先我们需要创建一个拓展名为 .d.ts 的文件，并在其中声明一个模块，声明的模块名称需要跟我们在其他文件中引入的路径相同。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/89l0osdz82sdhvpqd25jp8hr/image.png&quot; alt=&quot;外部模块声明&quot;/&gt; 2. 类型参数——泛型：首先让我们考虑最简单的情况，当传入一个参数的时候，extend 函数应该返回与参数类型相同的对象，但是我们在编写函数的时候并不知道用户会传入何种类型的参数，所以我们可以定义一个类型参数 T1，这时，extend 就被称为泛型函数，T1 也被称做泛型参数。在上面的例子中，extend 函数接受一个类型为 T1 参数并返回一个类型为 T1 的值，T1 需要用户手动传入，还好 TS 足够聪明，在绝大多数情况下，TS 可以根据参数类型来自动推断类型参数，免去了我们输入类型参数的繁琐步骤。只接受一个参数的 extend 函数并没有很复杂，我们可以继续考虑一些更复杂的情况。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/a9kx30chcxrfq4o343590ndl/image.png&quot; alt=&quot;繁星&quot;/&gt;&lt;br/&gt;这次让我们定义一个接受三个参数的 extend 函数，同时它也接受三个泛型参数，而它返回值类型呢，则是 T1, T2, T3 的交叉类型。交叉类型让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，相当于对这些类型的成员求并集。 例如， T1 &amp;amp; T2 &amp;amp; T3 这个类型的对象同时拥有了这三种类型的成员。在这里，交叉类型就满足了我们对 extend 函数返回值类型的要求。值得注意的是，实际的 extend 函数可以接受不定个数的参数，也就是说，我们为它编写的类型定义也需要同时兼容接受不定个数参数的情况，这就需要 TS 提供的函数重载功能。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/cl5z2t4sbj9i96blfdx2ofrm/image.png&quot; alt=&quot;泛型&quot;/&gt;3. 重载：在大多数静态类型编程语言中，编译器允许存在参数类型、个数不同的多个同名函数，这个特性被称为函数重载。TS 支持函数重载的特性，所以我们可以定义多个接受不同数量参数的 extend 方法，在用户调用时，TS 会自动的在这些同名函数中选择正确的重载定义。有了函数重载的帮助，我们可以在使用 extend 的大多数场景下享受到类型检查的好处，只有在参数个数超过4个的时候，TS 才无法推断出返回值类型。需要注意的是在 JS 中，运行时并不提供函数重载的能力，我们无法定义多个同名函数，即使他们接受的参数数量并不相同，为了实现函数重载的效果，开发人员需要手动在单个函数中对参数的类型、数量做出判断。&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Jacqueline/vtrrdi5h5bwixhl5ql5ezhq9/image.png&quot; alt=&quot;重载&quot;/&gt;&lt;br/&gt;到这里我们的第三方声明就完成了，即使一个简单函数的第三方声明，我们也运用了很多ts的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;个人感受&quot;&gt;个人感受&lt;/h2&gt;
&lt;p&gt;前面我们讲解了，使用在vue中使用ts能带给我们的种种便利，现在就我个人感受而言，说一下美中不足的地方。&lt;br/&gt;1.即使使用了ts，template 部分仍没有静态类型检查和IDE智能提示，但官方成员表示在以后的 Vue 单文件中会提供这项功能。&lt;br/&gt;2.将  Vue 单文件组件引入 TS  文件中，无法正确的提示其文件位置。&lt;br/&gt;3.Vue  周边工具，比如  Vuex，它对ts的支持薄弱，大量的功能难以直接迁移到ts中，并且没有好的官方支持的方案。&lt;br/&gt;4.毫无疑问，使用 TS 进行开发，相比于 JS ，我们需要花费更多的时间和精力。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 12:37:00 +0000</pubDate>
<dc:creator>stone-lyl</dc:creator>
<og:description>Vue 中使用 typescript 什么是typescript typescript 为 javaScript的超集，这意味着它支持所有都JavaScript都语法。它很像JavaScript都强类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stone-lyl/p/9606917.html</dc:identifier>
</item>
<item>
<title>论文笔记：CNN经典结构1（AlexNet，ZFNet，OverFeat，VGG，GoogleNet，ResNet） - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/9606901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/9606901.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;论文笔记：CNN经典结构1（AlexNet，ZFNet，OverFeat，VGG，GoogleNet，ResNet） - PilgrimHui - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;主要介绍了几个经典CNN网络，包括ImageNet比赛从2012到2015的几个冠军网络，AlexNet，ZFNet，OverFeat，VGG，GoogleNetv1-v4，ResNetv1-v2&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=giTNza-Of-PEt5UsELhFQAR7G6-bfaSa4oolcq7i9-o1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife.css?v=g4Oce5UBaUn_FUwadcT09ICEg5NkULQGtUpNhTtrI8U1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife-mobile.css?v=Xay8b9tTSw814nBzbOgvS6rrbcxrobMhvHJHdZAO9vI1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/liaohuiqiang/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/liaohuiqiang/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/liaohuiqiang/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;h3 id=&quot;alexnet&quot;&gt;AlexNet&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2012冠军，展现出了深度CNN在图像任务上的惊人表现，掀起CNN研究的热潮，是如今深度学习和AI迅猛发展的重要原因。ImageNet比赛为一直研究神经网络的Hinton提供了施展平台，AlexNet就是由hinton和他的两位学生发表的，在AlexNet之前，深度学习已经沉寂了很久。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下图所示，8层网络，参数大约有60 million，使用了relu函数，头两个全连接层使用了0.5的dropout。使用了LRN和重叠的池化，现在LRN都不用了，一般用BN作Normalization。当时使用了多GPU训练。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预处理&lt;/strong&gt;：先down-sample成最短边为256的图像，然后剪出中间的256x256图像，再减均值做归一化（over training set）。 &lt;strong&gt;训练时&lt;/strong&gt;，做数据增强，对每张图像，随机提取出227x227以及水平镜像版本的图像。除了数据增强，还使用了PCA对RGB像素降维的方式来缓和过拟合问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测&lt;/strong&gt;：对每张图像提取出5张（四个角落以及中间）以及水平镜像版本，总共10张，平均10个预测作为最终预测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超参数&lt;/strong&gt;：SGD，学习率0.01，batch size是128，momentum为0.9，weight decay为0.0005（论文有个权重更新公式），每当validation error不再下降时，学习率除以10。权重初始化用（0，0.01）的高斯分布，二四五卷积层和全连接层的bias初始化为1（给relu提供正值利于加速前期训练），其余bias初始化为0。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201711/1160281-20171124090206484-877449439.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;zfnet&quot;&gt;ZFNet&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2013分类任务的冠军，使用反卷积对CNN的中间特征图进行可视化分析，通过分析特征行为找到提升模型的办法，微调Alexnet提升了表现。ZFNet的Z和F指的是Zeiler和Fergus，曾是hinton的学生，后在纽约大学读博的Zeiler，联手纽约大学研究神经网络的Fergus提出了ZFNet。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冠军？&lt;/strong&gt;：严格意义上来说当时分类冠军是Clarifai，但是我们通常讨论的ILSVRC2013冠军（winner）指的是ZFNet。ZF中的Zeiler是Clarifai的创建者和CEO，ZFNet较AlexNet的提升幅度比较大，而Clarifai表现只比ZFNet高一点点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下图所示，和AlexNet一样，头两个全连接层后面加0.5的dropout。相比于AlexNet，主要区别是使用了更小的卷积核和步长，11x11的卷积核变成7x7的卷积核，stride从4变成了2。另外，通过可视化发现第一层的卷积核影响大，于是对第一层的卷积核做了规范化，如果RMS（Root Mean Square）超过0.1，就把卷积核的均方根normalize为固定0.1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其它数据集&lt;/strong&gt;：ZFNet还在Caltech-101，Caltech-256，Pascal AOC-2012上做了迁移学习的实验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预处理和超参数&lt;/strong&gt;：和AlexNet基本一致。权重初始化不同，权重初始化为0.01，bias初始化为0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更多&lt;/strong&gt;：具体内容我在另一篇&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9356753.html&quot;&gt;论文笔记：可视化CNN&lt;/a&gt;中有所提及。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200007680-685219468.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;overfeat&quot;&gt;OverFeat&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2013定位任务的冠军，用一个CNN集成了分类，定位和检测三个任务，提出了多尺度的方法。OverFeat是由Yann Lecun团队提出，Lecun提出的LeNet可以说是CNN的开端，提出来并没有火起来，因为当时机器性能不高而且SVM也能达到类似的效果甚至超过。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：相比于AlexNet，不再使用LRN；使用非重叠的池化；使用更小的步长，大的步长可以提高速度但是损害了精度。和AlexNet一样，头两个全连接层后面加0.5的dropout。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预处理和超参数&lt;/strong&gt;：和AlexNet基本一致。权重初始化不同，全部用（0，0.01）的高斯分布初始化。momentum为0.6，学习率为0.005。在（30，50，60，70，80）epoch学习率减半（decreased a factor by 0.5）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测&lt;/strong&gt;：在测试阶段，不再使用AlexNet的10 views法（4 corners and center, with horizontal flip），探索了多尺度来进行平均预测的方法，直接从原图rescale成多个尺度的图像输入网络进行多尺度预测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多尺度（和全卷积）&lt;/strong&gt;：如下图所示，把全连接层改成全卷积（5x5卷积），在网络最后配合全局最大池化，可以输入多尺度的图像，举例来说，输入14x14的图像，最后得到的是1x1个分类特征，输入16x16的图像最后会得到2x2个分类特征，但是通过全局最大池化就可以转为1x1个分类特征，对于多尺度输入，输出是一致的。而且从下图中的蓝色色块可以看出，在16x16上卷积可以看作用14x14的窗口在上面滑动2步的4次卷积结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更多&lt;/strong&gt;：具体内容我在另一篇&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9348276.html&quot;&gt;论文笔记：OverFeat&lt;/a&gt;中有所提及。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201807/1160281-20180721220438599-1957099965.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vgg&quot;&gt;VGG&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2014定位任务的冠军（Winner），分类任务的亚军（runner-up）。该网络的特点在于结构规整，通过反复堆叠3x3的卷积，卷积核数量逐渐加倍来加深网络，后续的很多CNN结构都采用了这种3x3卷积思想，这是一个很大的影响。ZFNet和OverFeat都使用了更小的卷积核，更小的步长来提升AlexNet的表现，相比之下，VGG则是探索CNN的深度，通过固定其它参数，然后稳定地叠加深度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;如下图所示，VGG-16，16层，参数大约有138 million。实验发现LRN的加入没有提升反而更差，舍弃使用。实验发现1x1效果更差，于是没有使用，1x1卷积在Network in Network（颜水成）中提出推广，是很重要的思想，在GoogleNet和ResNet都有用到。&lt;/li&gt;
&lt;li&gt;使用小卷积核3x3可以捕捉左右上下的信息，而且利于堆叠深度（保证参数不要过大）。步长为1。same卷积。&lt;/li&gt;
&lt;li&gt;两个3x3卷积可以和5x5卷积达到一样的感受野。三个3x3卷积可以和7x7卷积达到一样的感受野。使用三个3x3的好处在于使用了3个非线性变换，同时后减小了参数，假设输入输出通道数一样，那么有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 3(3^2C^2)=27C^2 &amp;lt; 7^2C^2 = 49C^2 \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;和AlexNet一样，头两个全连接层后面加0.5的dropout。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;超参数&lt;/strong&gt;：和AlexNet基本一致。batch size是256。初始化也是用（0，0.01）的高斯分布，只不过VGG先训练一个浅层的网络，然后把浅层网络的部分参数来初始化深层网络部分参数，其它参数还是用高斯分布。值得注意的是论文提交后VGG发现使用glorot的初始化方法可以不用预训练。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预处理&lt;/strong&gt;：和AlexNet不同，在下采样的时候不是变成256，变成一个S，S有两种方法来设定。第一个方法是固定的S（single-scale），固定为256或384。为了加速384的网络，用256预训练的模型进行权重初始化。另外学习率调小为0.001。第二个方法从[256, 512]中随机采样S（multi-scale，注意这里的是multi-scale training，和overfeat中的multi-scale test含义不一样），这可以看成用尺寸抖动（scale jittering）对训练集进行增强。为了加速，使用384预训练的模型进行权重初始化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测&lt;/strong&gt;：采用了AlexNet的10 views法（VGG论文中把它称作multi-crop评估）和overfeat的多尺度预测方法（VGG论文中把它称作dense评估）相结合。在OverFeat已经提到了multi-crop是有缺点的，存在冗余的卷积计算，所以使用了dense评估，但是Inceptionv1的论文中提到multi-crop使用大量crops能提高准确率因为它的采样更精细。而VGG认为实作上准确率的提升不足以弥补速度，但是为了参考起见，还是跑了multi-scrop的方法。在实验中，两者结合优于multi-crop优于dense，好那么一点点，差别不大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成&lt;/strong&gt;：实验的最后融合了多个模型（集成），最好的模型是融合了VGG-16和VGG-19，训练使用multi-scale training，测试使用multi-crop和dense评估相结合。在AlexNet，ZFNet和OverFeat最后的实验都会使用集成，最好的模型一般都是集成的结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定位&lt;/strong&gt;：VGG的定位任务的模型是在OverFeat的基础上做了一些修改。对于bounding box的预测有两种，SCR（single-class regression）是所有类共享一个框，这时最后输出是4维向量。PCR（per-class regression）是每个类一个框，这样最后输出就是4x1000，其中1000表示1000类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泛化&lt;/strong&gt;：和ZFNet一样，VGG也做了迁移学习，用ILSVRC的数据预训练，然后迁移到其它数据集VOC-2007，VOC-2012，Caltech-101，Caltech-256。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201711/1160281-20171124090234406-155051052.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;googlenetinceptionv1&quot;&gt;GoogleNet（Inceptionv1）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2014分类任务的冠军。该网络设计了Inception块代替人工来选择卷积类型，然后堆叠Inception块（增加深度）形成Inception网络。去除了全连接层（占据了网络的大部分参数），使用了全局均值池化（思想来自Network in Network），大大减小了参数量。这两个思想在GoogleNet后面的一些论文中都有体现，一个是Inception块的自动选择网络结构（Google后面发表了一些自动选择网络超参，网络优化器，网络激活函数的论文），另一个是减小模型参数和计算资源（Google的mobileNet，类似工作还有face++的shuffleNet）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下图所示为Inception块。网络总共有22层，图太大，这里就给个表格。可以看到虽然把全连接替换成了全局均值池化（这后面还是使用了0.4的dropout），但是网络图中最后还是有一个全连接层，这是为了便于把网络fine tune到其它数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：为了提升模型表现，典型的办法是增大模型（增加深度或宽度），但是这样会带来过大的参数，然后导致计算资源增大而且需要的数据更多（而高质量数据往往是昂贵的），所以要考虑降低参数。Inceptionv1虽然有22层的参数却只有5 million，是同期VGG16（138 million）的1/27，是AlexNet（60 million）的1/12而准确率却远胜AlexNet。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1x1卷积好处&lt;/strong&gt;：减小了参数，允许增加深度； 可以降维，构建瓶颈层来减小计算成本，Inception块中就是通过在3x3和5x5后面加入1x1来减小计算；增强了网络的表达能力（可以根据自己的意愿，或压缩或增加或保持通道数）。还有配合全局均值池化来代替全连接层，这个就是为了能大大减小模型的参数。1x1的思想也来自Network in Network。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超参数和预处理&lt;/strong&gt;：因为比赛的过程做了很多变动，包括采样方法和各种超参，所以很难定义一个有效的指导去训练这个网络。只给出了几个超参数，固定学习率，每8epoch下降4%，momentum是0.9。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测&lt;/strong&gt;：先下降样出256，288，320和352大小，分别从左中右三个方位裁（如果是人画像则从上中下三个方位裁），然后从4 corners和center剪出224x224再加上把正方形缩放到224，以及它们的水平镜像。这样就可以得到4x3x6x2也就是144个crops，最后对crops取平均。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成&lt;/strong&gt;：和之前的网络一样，最后也使用了集成，训练了7个版本的网络进行集成，使用Polyak averaging进行平均，7个网络使用一样的初始化和学习率设置，不同之处在于数据采样的方法和顺序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标检测&lt;/strong&gt;：Inceptionv1的目标检测使用了类似R-CNN的方法来完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助输出&lt;/strong&gt;：Inceptionv1中有两个辅助输出，说是因为太深的网络的梯度回传能力有限（梯度消失），于是在中间层接另两条分支来利用中间层的特征，可以增加梯度回传，还有附加的正则化作用。然后在v3的论文中又提到说利用中间层特征的想法可能是错的，因为去掉低层的辅助（第一个辅助输出）对最终结果并没有什么影响，但是还是强调了辅助输出的正则化效果，因为在辅助输出中加入BN和dropout可以提升主输出表现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201711/1160281-20171124151010078-1933005968.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200119341-1914878683.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;googlenetinceptionv2&quot;&gt;GoogleNet（Inceptionv2）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：学习VGG，使用两个3x3卷积代替5x5的大卷积（保持感受野的同时又可以减小参数量），还使用了众所周知的BN。值得注意的是Inception-BN在v4的论文中把这个网络被称为v2，而在v3的论文中有另外一个v2（v3的一个低配版）。这两篇论文中提到的v2不是同一个v2，通常说的v2指的是这个Inception-BN。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下图所示，主要改变有，用两个3x3代替5x5，28x28的Inception块从2个变成了3个，pooling时有些是avg有些是max，在Incetpion块之间不再有额外的max-pool而是直接把卷积和池化的stride设置为2。BN被用在每一个输入层后面（先BN再激活）。batch size为32。网络使用DistBelief（Tensorflow前身）训练&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其它变动&lt;/strong&gt;： 增大学习率并加快学习率衰减（适用BN后的数据），移除dropout并减小L2权重衰减（BN有一定的正则效果），去除LRN（发现用了BN后不需要LRN了），更彻底对训练样本进行shuffle，减小数据增强时对数据的光学畸变（因为BN训练更快，每个样本被训练次数变少，模型需要注重更真实的样本）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成&lt;/strong&gt;：最好的结果当然还是要集成了（之前的BN笔记中没有提及）。集成了6个网络，都是基于BNx30，6个版本分别在卷积层增加初始化权重；使用dropout 5%；使用dropout 10%；在Inceptionv1适用dropout 40%；不使用卷积；先激活再BN。集成方式还有multi-crop的使用和Inceptionv1一样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更多&lt;/strong&gt;：关于BN（包括我在上一条提到的BNx30）我在另一篇论文&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9250469.html&quot;&gt;论文笔记：BN&lt;/a&gt;中有所提及，这篇论文也是讲述Inception-BN的论文&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200056784-115226972.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;googlenetinceptionv3&quot;&gt;GoogleNet（Inceptionv3）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：通过一系列的卷积分解和正则化手段来提升模型。这篇论文称为v3论文，里面有一个低配版v3称为v2，这里的v2只是v3这篇论文的v2，这一节提到的v2都是指这个v2。平常说的v2指的是BN那篇论文的v2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：使用tensorflow训练，学习率为0.045，以0.94的指数率每两轮衰减一次。梯度裁剪阈值为2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v2网络结构&lt;/strong&gt;：共42层，网络图就不放了，主要改动有如下。图有点多，这里就不放图了，各个改动模块图可以参考后面v4的结构图。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;修改部分Inception块，使5x5分解成2个3x3卷积（可参考下面v4的InceptionA）。&lt;/li&gt;
&lt;li&gt;修改部分Inception块，分解成非对称卷积（把nxn分解成1xn和nx1卷积，这里n=7。注意原始结构并没有7x7卷积）（可参考下面v4的InceptionB）。&lt;/li&gt;
&lt;li&gt;修改部分Inception块，扩大卷积核数量（汇聚的分支数量）（可参考下面v4的InceptionC）&lt;/li&gt;
&lt;li&gt;修改部分Inception块，减小特征图大小（使用并行的stride为2的卷积和池化）（可参考下面v4的Reduction）&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;v3网络结构&lt;/strong&gt;：在以上基础上，加入如下改动&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;用RMSProp训练，decay为0.9，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;为1.0&lt;/li&gt;
&lt;li&gt;使用Label smoothing进行模型正则&lt;/li&gt;
&lt;li&gt;开头第一层7x7分解成3个3x3卷积&lt;/li&gt;
&lt;li&gt;加入带BN的辅助分类器&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;googlenetinceptionv4inception-resnet&quot;&gt;GoogleNet（Inceptionv4，Inception-ResNet）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：基于v3的基础，引入残差结构，提出了Inception-ResNet-v1和Inception-ResNet-v2。同时修改了Inception提出了Inceptionv4，发现Inceptionv4能达到Incetpion-ResNet-v2类似的结果，认为残差结构对于训练深度网络不是必须的（之前看过一篇分形网络的论文也提出了”残差块并不是训练深度网络的必要组件”的观点，我在&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9218445.html&quot;&gt;论文笔记：分形网络&lt;/a&gt;有所提及）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v4网络结构&lt;/strong&gt;：如下第一个图是v4。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inception-ResNet&lt;/strong&gt;：探索了多种Inception-ResNet，论文只阐述了两个。其中Inceptin-ResNet-v1和Inceptinv3计算代价差不多，Inceptin-ResNet-v2和Inceptionv4计算代价差不多，然而实作上Inceptionv4慢很多可能是因为层数太多。在带有ResNet的Inception中，还有一个和纯Inception的不同点是只在传统层上使用BN，不在BN层上使用，这样可以减小计算从而堆叠更多Inceptin块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inception-ResNet-v2结构&lt;/strong&gt;：如下第二个图是Inception-ResNet-v2（输出的shape是Inception-ResNet-v1的）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：tensorflow，RMSProp，decay为0.9，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;为1.0，学习率为0.045，以0.94的指数率每两轮衰减一次。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200134678-337474579.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200151496-793846978.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;resnet&quot;&gt;ResNet&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：ILSVRC2015冠军（分类，检测，定位），由MSRA的何铠明等人提出，通过使用残差块训练了152层的网络，降低了错误率。解决了退化问题（plain网络随着网络加深，错误率升高），而使用残差后，随着网络加深，错误率还是能下降。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络加深&lt;/strong&gt;：对于网络加深，会出现梯度消失或梯度爆炸，这个问题可以通过正则初始化（何凯明初始化等等）和BN来解决。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退化问题&lt;/strong&gt;：然而深层网络到了一定深度，准确率趋近饱和，而且继续加深的话会降低准确率，这称为退化问题（degradation），而且这个问题并不是过拟合导致的（过拟合在训练集应该更好），也不是梯度消失造成的（论文检查了梯度）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;残差块&lt;/strong&gt;：为了解决退化问题，提出了残差学习，如下图所示为残差块，假设本来是要学习H(x)，加了一条恒等映射之后我们要学习的就是F(x) = H(x) - x，（假设）学习F(x)会比学习H(x)更容易，最极端的情况就是假设我们要学习的映射是x，那么让F(x)为0，比学习到H(x)为恒等映射要容易。这种做法的motivation是，如果增加的层能被构建成恒等映射层，那么一个更深的网络的准确率至少不会低于浅层网络。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;残差块的相加&lt;/strong&gt;：当残差块的输入和输出不是相同维度时，有两种方法来保证维度一致，一个是补0，另一个是乘以W矩阵做映射（使用1x1卷积）。在这两种方法实行时，残差块会使用stride为2的卷积。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：预处理时像VGG一样随机采样[256, 480]的scale，然后像AlexNet一样crop出224x224的图像以及水平翻转，然后做mean substracted。预测时候使用AlexNet的10-crop测试法，最好的结果是跟从VGG中的全卷积后的multi-scale评估，scale为{224, 256, 384, 480, 640}。在每个卷积的激活前使用BN，不使用dropout。何凯明初始化。SGD，batch size为256，学习率从0.1开始每次错误率平缓时就除以10，模型训练了60万个iteration，权重衰减为0.0001，momentum为0.9。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Identity和projection&lt;/strong&gt;：对于残差块的相加，有三种配置，A配置是捷径用identity，同时需要增加维度时补0。B配置是捷径用identity，但是增加维度时使用映射。C配置是捷径和增加维度都使用映射。表现是C&amp;gt;B&amp;gt;A，但是三者差异不大，实作上不会使用C，因为C增加了参数和计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：论文阐述了ResNet-18-34-50-101-152。其中ResNet-18/34使用配置A，ResNet-50/101/152使用配置B，此外使用了bottleneck结构，如下第一个图的右图所示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其它实验&lt;/strong&gt;：除了在ImageNet上，还在CIFAR-10上做了实验。还在Pascal和MS COCO上做了目标检测的实验。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200228255-969637706.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;resnetv2&quot;&gt;ResNetv2&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;贡献&lt;/strong&gt;：在v1的基础上做了修改，提升了表现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析&lt;/strong&gt;：ResNetv1的公式如下，论文分析了h函数和f函数的选取，即shortcut路径的函数选取，以及addition后的操作选取。在ResNetv1中，h函数为恒等映射，f函数为relu函数，如下图(a)所示。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[y_l = h(x_l) + F(x_l, W_l), \\ x_{l+1} = f(y_l) \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;h函数的选取&lt;/strong&gt;：论文分析了h函数选取为恒等映射，做常数scale，异或，1x1卷积，dropout时的表现，发现恒等映射的表现最好，主要是通过实验来分析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;f函数的选取&lt;/strong&gt;：由于h函数使用恒等映射表现最好，下图的分析中h函数都使用的&lt;strong&gt;恒等映射&lt;/strong&gt;。下图(a)表示f函数为Relu，这是ResNetv1的做法。下图(b)表示f函数为BN+Relu。下图(c)表示f函数为恒等映射（Relu放到addition前）。下图d表示f函数为恒等映射，但是把最后一个Relu放在下一个残差块的F-path中。下图e和图d类似，只不过把BN也放在addition后的下一个残差块的F-path，ResNetv2使用的就是图e的结构，通过实验发现这个结构表现最好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;f和h函数都为恒等映射&lt;/strong&gt;：ResNetv2采取图e的结构，此时f和h函数都为恒等映射，那么上式可以写成下式，可以看到这样的式子有几个特点，首先，不管L和l差多少层，&lt;span class=&quot;math inline&quot;&gt;\(x_L\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(x_l\)&lt;/span&gt;总是相差一个残差函数；其次，普通网络输入和输出的关系是很多个Wx相乘（忽略激活和BN的话），而这里是各个残差函数相加；另外，从求导式看，1+后面那一项不会总是为-1（对一个mini-batch的样本来说），所以梯度很难为0。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_{l+1} = x_l + F(x_l, W_l), \\ x_L = x_l + \sum_{i=l}^{L-1}{F(x_i, W_i)}, \\ \frac{\partial \varepsilon }{\partial x_l} = \frac{\partial \varepsilon }{\partial x_L}\frac{\partial x_L }{\partial x_l}=\frac{\partial \varepsilon }{\partial x_L}(1+\frac{\partial x_L }{\partial x_l}\sum_{i=l}^{L-1}{F(x_i, W_i)})\]&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：和ResNetv1基本一致。对于CIFAR的实验前400个iteration用0.01（warming up），之后恢复0.1，尽管观察到这对于残差块没有必要。对于ImageNet实验，学习率为0.1（no warming up），在30轮和60轮除以10。在ResNet的开头第一个残差块和最后一个残差块是特殊case，第一个残差块的激活会放在后面的“单独卷积”之后和分成两路之前，最后一个残差块的激活放在它的addition之后。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201809/1160281-20180907200245189-889919810.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;AlexNet（2012 NIPS）：&lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf&quot;&gt;ImageNet Classification with Deep Convolutional Neural Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ZFNet（2014 ECCV）：&lt;a href=&quot;https://arxiv.org/pdf/1311.2901v3&quot;&gt;Visualizing and Understanding Convolutional Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OverFeat（2014 ICLR）：&lt;a href=&quot;https://arxiv.org/pdf/1312.6229v4&quot;&gt;OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;VGG（2015 ICLR）：&lt;a href=&quot;https://arxiv.org/pdf/1409.1556v6&quot;&gt;Very Deep Convolutional Networks for Large-Scale Image Recognition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inception-V1（2015 CVPR）：&lt;a href=&quot;https://arxiv.org/pdf/1409.4842v1&quot;&gt;Going Deeper with Convolutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inception-V2（2015 ICML）：&lt;a href=&quot;https://arxiv.org/pdf/1502.03167v3&quot;&gt;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inception-V3（2016 CVPR）：&lt;a href=&quot;https://arxiv.org/pdf/1512.00567v3.pdf&quot;&gt;Rethinking the Inception Architecture for Computer Vision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inception-V4（2016 ICLR）：&lt;a href=&quot;https://arxiv.org/pdf/1602.07261v2&quot;&gt;Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ResNetv1（2016 CVPR）：&lt;a href=&quot;https://arxiv.org/pdf/1512.03385v1&quot;&gt;Deep Residual Learning for Image Recognition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ResNetv2（2016 ECCV）：&lt;a href=&quot;https://arxiv.org/pdf/1603.05027v3&quot;&gt;Identity Mappings in Deep Residual Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-09-07 20:35&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/&quot;&gt;PilgrimHui&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9606901&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/liaohuiqiang/p/9606901.html#&quot; onclick=&quot;AddToWz(9606901);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Fri, 07 Sep 2018 12:35:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>主要介绍了几个经典CNN网络，包括ImageNet比赛从2012到2015的几个冠军网络，AlexNet，ZFNet，OverFeat，VGG，GoogleNetv1-v4，ResNetv1-v2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/9606901.html</dc:identifier>
</item>
</channel>
</rss>