<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>25.Linux-Nor Flash驱动(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7737174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7737174.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.nor硬件&lt;/strong&gt;&lt;strong&gt;介绍:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026114858598-3172038.png&quot; alt=&quot;&quot; width=&quot;427&quot; height=&quot;495&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从原理图中我们能看到NOR FLASH有地址线，有数据线，它和我们的SDRAM接口相似,能直接读取数据，但是不能像SDRAM直接写入数据,需要有命令才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1其中我们2440&lt;/strong&gt;&lt;strong&gt;的地址线共有27&lt;/strong&gt;&lt;strong&gt;根(LADDR0~26),&lt;/strong&gt;&lt;strong&gt;为什么是27&lt;/strong&gt;&lt;strong&gt;根?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为2440共有7个bank内存块,每个bank=128MB=(2^27)B,所以共有27根数据线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2为什么Nor Flash&lt;/strong&gt;&lt;strong&gt;的地址线A0&lt;/strong&gt;&lt;strong&gt;是接在2440&lt;/strong&gt;&lt;strong&gt;的LADDR1&lt;/strong&gt;&lt;strong&gt;上?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为Nor Flash的数据共有16位,也就是每个地址保存了2B数据,而我们的2440每个地址是保存的1B数据,比如:当2440访问0X00地址时,就会读取到Nor Flash上0地址的16位数据,然后2440的内存控制器会根据0x00来找到低8位字节,并返回给CPU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3 nand&lt;/strong&gt;&lt;strong&gt;和nor&lt;/strong&gt;&lt;strong&gt;区别:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nor flash在价格上比nand贵,且容量很小 ,擦除和写数据都慢,好处在于接口简单,稳定,无位反转,坏块,常用于保存关键数据,而nand flash常用于保存大容量数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在2440中是通过硬件开关来设置OM0为Nand启动还是Nor启动,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026114919301-844616439.png&quot; alt=&quot;&quot; width=&quot;259&quot; height=&quot;231&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OM0具体参数如下所示,其中2440的OM1引脚默认接地&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026114931457-1706692227.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;134&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于nand启动:nand flash的开始4KB会自动地被加载到2440内置的SRAM缓存器中,就可以直接读写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于nor启动:2440访问的内存就是nor flash,可以直接写,但是不能直接读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.nor flash&lt;/strong&gt;&lt;strong&gt;命令如下所示(&lt;/strong&gt;&lt;strong&gt;参考MX29LV800BBTC.pdf)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026114947879-1031052108.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;389&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 其中word是针对16位nand,byte针对8位nand&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 比如,当我们要program(往0x20地址写入0xff数据)时&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要以下几步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往nor地址0x555写入0xAA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往nor地址0x2AA写入0x55&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往nor地址0x555写入0xA0                //进入program模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往nor地址0x20(PA)写入0xff(PD)          //往0x20写入0xff&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(接下来就会一直是program模式,执行reset模式便可以退出)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2该NOR&lt;/strong&gt;&lt;strong&gt;有两种规范, jedec, cfi(common flash interface) &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;jedec&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是和nandflash的一样,通过读ID来匹配linux内核中drivers/mtd/chips/jedec_probe.c里的jedec_table[]数组,来确定norflash的各个参数(名称、容量、位宽等),如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115011238-821278845.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;195&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;cfi&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是将这些参数保存在cfi模式下指定地址中, 往nor的0x55地址写入0x98,即可进入cfi模式,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cfi模式部分命令如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115024019-2107808987.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;212&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们在cfi模式下,比如:读取nor地址0x27处的数据,便能读到nor的容量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,之所以地址*2,是因为nor&lt;strong&gt;地址线A0&lt;/strong&gt;&lt;strong&gt;接在我们2440&lt;/strong&gt;&lt;strong&gt;的A1&lt;/strong&gt;&lt;strong&gt;上&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115041301-572082904.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;70&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读到0X15,0x15=21,如下图,刚好对应我们原理图的21根nor地址线,所以容量为2^21=2MB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115053582-124634152.png&quot; alt=&quot;&quot; width=&quot;191&quot; height=&quot;359&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3为什么上图的A20引脚没有接？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于2440来讲,因为此时的A0~A19的容量刚好为2MB,与cfi模式下读取的数据一致,所以没有接A20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.接下来便来分析如何写norflash&lt;/strong&gt;&lt;strong&gt;驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 先来回忆下之前的nandflsh驱动:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nandflsh驱动会放在内核的mtd设备中,而mtd设备知道如何通过命令/地址/数据来操作nandflash,所以我们之前的nandflash驱动只实现了硬件相关的操作(构造mtd_info,nand_chip结构体、启动nand控制器等)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样地,norflash驱动也是放在内核的mtd设备中,mtd设备也知道对nor如何来读写擦除,只是不知道norflash的位宽(数据线个数),基地址等,所以我们的norflash驱动同样要实现硬件相关的操作,供给mtd设备调用&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2参考内核自带的nor驱动:drivers/mtd/maps/physmap.c&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入它的init函数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115118223-1413280447.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;201&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现注册了两个platform平台设备驱动,进入physmap_flash结构体中:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115131160-1207814540.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;214&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现3个未定义的变量:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONFIG_MTD_PHYSMAP_BANKWIDTH: nandflash的字节位宽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONFIG_MTD_PHYSMAP_START:nandflash的物理基地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONFIG_MTD_PHYSMAP_LEN: nandflash的容量长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这3个变量是通过linux的menuconfig菜单配置出来的,若自己填入值,就不需要用menuconfig菜单配置了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3接下来我们就来配置内核,&lt;/strong&gt;&lt;strong&gt;然后挂载这个内核自带的norflash&lt;/strong&gt;&lt;strong&gt;驱动实验一番&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4 首先make menuconfig,配置上面3个变量,然后设为模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-&amp;gt; Device Drivers                &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; -&amp;gt; Memory Technology Device (MTD) support  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; -&amp;gt; Mapping drivers for chip access                   //进入映射驱动&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;M&amp;gt; CFI Flash device in physical memory map          //将支持cfi的norflash设置为模块&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;   (0x0) Physical start address of flash mapping  // 设置物理基地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;   (0x1000000) Physical length of flash mapping  // 设置容量长度,必须大于等于自身nor的2MB&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;   (2)   Bank width in octets (NEW)         　　        // 设置字节位宽,因为nor为16位,所以等于2&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.5 make modules 编译模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,可以看到physmap.c编译成.ko模块了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115212644-1706797429.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;60&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.6 然后放在nfs目录下,启动开发板&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,insmod后打印了一串信息:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115224566-494391403.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;96&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,可以看到创建了2个mtd0字符设备,一个mtd0块设备:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115236941-1479851081.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;59&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.接下来我们便分析physmap.c,&lt;/strong&gt;&lt;strong&gt;如何写出norflash&lt;/strong&gt;&lt;strong&gt;驱动的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中physmap.c的probe函数如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; physmap_flash_info {
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mtd_info             *mtd;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现对flash的读写擦除等操作&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; map_info            map;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放硬件相关的结构体&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; resource             *&lt;span&gt;res;
#ifdef CONFIG_MTD_PARTITIONS
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;                 nr_parts;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mtd_partition      *&lt;span&gt;parts;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *rom_probe_types[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cfi_probe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jedec_probe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;map_rom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NULL };    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;芯片名称&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;... ...
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; physmap_flash_probe(&lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;dev)
{
       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;probe_type;
       ... ...
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1. 分配结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       info &lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; physmap_flash_info), GFP_KERNEL);

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.设置map_info 结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
　　　　info&lt;/span&gt;-&amp;gt;map.name = dev-&amp;gt;dev.bus_id;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;norflash的名字&lt;/span&gt;&lt;span&gt;
       info&lt;/span&gt;-&amp;gt;map.phys = dev-&amp;gt;resource-&amp;gt;start;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;物理基地址&lt;/span&gt;&lt;span&gt;
       info&lt;/span&gt;-&amp;gt;map.size = dev-&amp;gt;resource-&amp;gt;end - dev-&amp;gt;resource-&amp;gt;start + &lt;span&gt;1&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量长度&lt;/span&gt;&lt;span&gt;
       info&lt;/span&gt;-&amp;gt;map.bankwidth = physmap_data-&amp;gt;width;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字节位宽&lt;/span&gt;&lt;span&gt;
       info&lt;/span&gt;-&amp;gt;map.virt = ioremap(info-&amp;gt;map.phys, info-&amp;gt;map.size);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;
       simple_map_init(&lt;/span&gt;&amp;amp;info-&amp;gt;map);                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单初始化map_info的其它成员&lt;/span&gt;
&lt;span&gt;
       probe_type &lt;/span&gt;=&lt;span&gt; rom_probe_types;
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3. 设置mtd_info 结构体 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;通过probe_type指向的名称来识别芯片,当do_map_probe()函数返回NULL表示没找到&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;当找到对应的芯片mtd_info结构体,便返回给当前的info-&amp;gt;mtd &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;for&lt;/span&gt; (; info-&amp;gt;mtd == NULL &amp;amp;&amp;amp; *probe_type != NULL; probe_type++&lt;span&gt;)       
       info&lt;/span&gt;-&amp;gt;mtd = do_map_probe(*probe_type, &amp;amp;info-&amp;gt;map); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过do_map_probe ()来识别芯片&lt;/span&gt;
   

       &lt;span&gt;if&lt;/span&gt; (info-&amp;gt;mtd == NULL) {             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终还是没找到芯片,便注销之前注册的东西并退出&lt;/span&gt;&lt;span&gt;
              dev_err(&lt;/span&gt;&amp;amp;dev-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;map_probe failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
              err &lt;/span&gt;= -&lt;span&gt;ENXIO;
              &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_out;
       }

       info&lt;/span&gt;-&amp;gt;mtd-&amp;gt;owner =&lt;span&gt; THIS_MODULE;        

 

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.添加mtd设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

       add_mtd_device(info&lt;/span&gt;-&amp;gt;&lt;span&gt;mtd);              

       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

 

err_out:

       physmap_flash_remove(dev);                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数用来注销之前注册的东西&lt;/span&gt;

       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;通过上面的代码和注释分析到,和我们上一节的nandflash驱动相似,这里是设置map_info 结构体和mtd_info结构体来完成的,当我们要对norflash分区就要使用add_mtd_partitions()才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中当*probe_type==“cfi_probe”时:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就会通过do_map_probe(&quot;cfi_probe&quot;, &amp;amp;info-&amp;gt;map)来识别芯片.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终会进入drivers/mtd/chips/cfi_probe.c中的cfi_probe_chip()函数来进入cfi模式,读取芯片信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当*probe_type==&quot;jedec_probe&quot;时:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终会进入drivers/mtd/chips/jedec_probe.c中的jedec_probe_chip ()函数来使用读ID命令,通过ID来匹配jedec_table[]数组.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以注册一个块设备驱动,&lt;/strong&gt;&lt;strong&gt;需要以下步骤:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1. 分配mtd_info结构体和map_info结构体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2. 设置map_info 结构体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3. 设置mtd_info 结构体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4. 使用add_mtd_partitions()或者add_mtd_device()来创建MTD字符/块 设备&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.接下来我们来参考physmap.c&lt;/strong&gt;&lt;strong&gt;来自己写norflah&lt;/strong&gt;&lt;strong&gt;驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
#include &amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/slab.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/device.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/platform_device.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/mtd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/map.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/partitions.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/io.h&amp;gt;

 
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_info        *&lt;span&gt;mynor_mtd_info;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; map_info         *&lt;span&gt;mynor_map_info;


&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_partition mynor_partitions[] =&lt;span&gt; {
       [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .size   &lt;/span&gt;= &lt;span&gt;0x00040000&lt;/span&gt;&lt;span&gt;,
        .offset     &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
       },
       [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
        .size   &lt;/span&gt;=&lt;span&gt; MTDPART_SIZ_FULL,
       }
};
 
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *mynor_probe_types[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cfi_probe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jedec_probe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,NULL};


&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mynor_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1. 分配map_info 结构体和mtd_info结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    mynor_mtd_info&lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mtd_info), GFP_KERNEL);
    mynor_map_info&lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; map_info), GFP_KERNEL);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2. 设置map_info 结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    mynor_map_info&lt;/span&gt;-&amp;gt;name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my_nor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    mynor_map_info&lt;/span&gt;-&amp;gt;phys=&lt;span&gt;0x0&lt;/span&gt;;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;物理地址&lt;/span&gt;&lt;span&gt;
    mynor_map_info&lt;/span&gt;-&amp;gt;size=&lt;span&gt;0x1000000&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=16M,长度必须大于等于norflash的2M容量&lt;/span&gt;&lt;span&gt;
    mynor_map_info&lt;/span&gt;-&amp;gt;bankwidth=&lt;span&gt;2&lt;/span&gt;;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;16位宽&lt;/span&gt;&lt;span&gt;
    mynor_map_info&lt;/span&gt;-&amp;gt;virt = ioremap(&lt;span&gt;0x0&lt;/span&gt;, mynor_map_info-&amp;gt;size);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟地址&lt;/span&gt;&lt;span&gt;
    simple_map_init(mynor_map_info);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3. 设置mtd_info 结构体&lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;&lt;/span&gt;　　 mynor_mtd_info = do_map_probe(&quot;cfi_probe&quot;, mynor_map_info);&lt;br/&gt;　　　if (!mynor_mtd_info)&lt;br/&gt;　　{&lt;br/&gt;　mynor_mtd_info = do_map_probe(&quot;jedec_probe&quot;, mynor_map_info);&lt;br/&gt;　}
&lt;/pre&gt;
&lt;p&gt;　　　　if (!mynor_mtd_info)&lt;br/&gt;　　　　{&lt;br/&gt;　　　　printk(&quot;not available norflash !!!\r\n&quot;);&lt;br/&gt;　　　　goto err_out;&lt;br/&gt;　　　　}&lt;br/&gt;　　　　mynor_mtd_info-&amp;gt;owner=THIS_MODULE;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4. 使用add_mtd_partitions()或者add_mtd_device()来创建MTD字符/块 设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       add_mtd_partitions(mynor_mtd_info,mynor_partitions,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

       
err_out:
       iounmap(mynor_map_info&lt;/span&gt;-&amp;gt;virt);                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消虚拟地址映射&lt;/span&gt;&lt;span&gt;
       kfree(mynor_map_info);
       kfree(mynor_mtd_info);      
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; mynor_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    del_mtd_partitions(mynor_mtd_info);                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卸载分区&lt;/span&gt;&lt;span&gt;
    iounmap(mynor_map_info&lt;/span&gt;-&amp;gt;virt);                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消虚拟地址映射&lt;/span&gt;&lt;span&gt;
    kfree(mynor_map_info);
    kfree(mynor_mtd_info);       
}

module_init(mynor_init);
module_exit(mynor_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.挂载驱动试验(&lt;/strong&gt;&lt;strong&gt;一定要在nor&lt;/strong&gt;&lt;strong&gt;启动下挂载才行)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;insmod挂载驱动后,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115256457-1682316236.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;124&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到创建了两个分区“bootloader”,“root”,如下图所示,可以看到创建了2对mtd字符/块设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171026115312769-189433083.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;102&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.1 接下来便来对root分区(mtd1)来试验(使用flash之前最好擦除一次)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
./flash_eraseall -j /dev/mtd1                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用flash_eraseal来擦除root分区(mtd1)&lt;/span&gt;
&lt;span&gt;
mount &lt;/span&gt;-t jffs2 /dev/mtdblock1 /mnt/                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用mount挂载文件系统, -t:文件系统类型(type)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;接下来就可以在/mnt目录下来任意读写文件了,最终会保存在flash的mtdblock1块设备中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(PS:可以参考内核自带的mtdram.c,里面是使用内存来模拟flash, 里面通过memcopy()等来实现对内存读写擦除)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 07:44:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7737174.html</dc:identifier>
</item>
<item>
<title>装饰模式 - DebugLife</title>
<link>http://www.cnblogs.com/zanpen2000/p/7737046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zanpen2000/p/7737046.html</guid>
<description>&lt;h3 id=&quot;故事&quot;&gt;故事&lt;/h3&gt;
&lt;h4 id=&quot;程序员小明的两任女友&quot;&gt;程序员小明的两任女友&lt;/h4&gt;
&lt;p&gt;现在越来越多的妹子愿意找IT男当男朋友，因为不知道是哪个挨(qin)千(ge)刀(ge)的透露了IT男钱多话少死的早的秘密。&lt;/p&gt;
&lt;p&gt;但是问题很快就来了，有女朋友之前的IT男的钱包长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E6%B2%A1%E6%9C%89%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9A%84%E9%92%B1%E5%8C%85.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了女朋友的IT男的钱包长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E6%9C%89%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9A%84%E9%92%B1%E5%8C%85.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;早上，小明的女盆友如花一大早就打扮的花枝招展的拉着小明去逛街，走到金饰品店，看上了一个手链，左戴右试爱不释手，时不时还可怜兮兮的看一眼小明，看得小明心惊肉跳的，心想这月已经吃了俩礼拜的泡面了，我这可(bai)爱(jia)的女盆友怎么一点都不知道心疼我。&lt;/p&gt;
&lt;p&gt;泡面就泡面吧，大不了就换窝头咸菜，虽然心疼，但为了博得美人一笑，小明还是帅气的掏出了信用卡。女朋友则兴高采烈的立马就戴上了手链，神采飞扬！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E5%A6%82%E8%8A%B1.jpg&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个过程可以用UML类图画一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E5%B0%8F%E6%98%8E%E5%92%8C%E5%A6%82%E8%8A%B1.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图中，“女朋友”被设计成接口，是考虑到这个女朋友太可(bai)爱(jia)，为了能不一直吃泡面，有可能会换另外一个实现（换女友），咳咳....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E8%BF%98%E6%9C%89%E8%BF%99%E7%A7%8D%E6%93%8D%E4%BD%9C.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过了一段时间，小明实在没钱给女朋友买首饰了，如花很快又找到了另一个IT男，和小明分手了，好在一直暗恋小明的似玉及时向小明&lt;span&gt;勇敢告白&lt;/span&gt;，这才让小明从失恋的阴影中走出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E5%B0%8F%E6%98%8E%E8%A2%AB%E5%A3%81%E5%92%9A.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下现在的类图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E5%B0%8F%E6%98%8E%E5%92%8C%E5%A6%82%E8%8A%B1%E4%BC%BC%E7%8E%89.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小明的新女友似玉温柔体贴，喜欢看书、吃麻辣烫，很懂事，小明心想这次终于找到了真命天女了！&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 女朋友接口
    /// &amp;lt;/summary&amp;gt;
    public interface IGirlFriend
    {
        string Description { get; set; }
        void Dating();
    }

    /// &amp;lt;summary&amp;gt;
    /// 如花
    /// &amp;lt;/summary&amp;gt;
    public class RuHua : IGirlFriend
    {
        public string Description { get; set; } = &quot;我是如花&quot;;

        public void Dating()
        {
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 似玉
    /// &amp;lt;/summary&amp;gt;
    public class SiYu : IGirlFriend
    {
        public string Description { get; set; } = &quot;我是似玉&quot;;

        public void Dating()
        {
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 约会装饰器
    /// &amp;lt;/summary&amp;gt;
    public class Decorator : IGirlFriend
    {
        public IGirlFriend GirlFriend { get; private set; }
        public string Description { get; set; }

        public Decorator(IGirlFriend girl)
        {
            this.GirlFriend = girl;
        }

        public virtual void Dating()
        {
            Console.Write(this.GirlFriend.Description);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 约会之逛街
    /// &amp;lt;/summary&amp;gt;
    public class Shopping : Decorator
    {
        public Shopping(IGirlFriend girlFriend):base(girlFriend)
        {
        }

        public override void Dating()
        {
            base.Dating();
            this.WalkAndShopping();
        }

        public void WalkAndShopping()
        {
            Console.WriteLine(&quot;我在和小明逛街&quot;);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 约会之吃饭
    /// &amp;lt;/summary&amp;gt;
    public class Eatting : Decorator
    {
        public Eatting(IGirlFriend girlFriend) : base(girlFriend)
        {
        }

        public override void Dating()
        {
            base.Dating();
            this.EatSomething();
        }

        public void EatSomething()
        {
            Console.WriteLine(&quot;我在和小明吃饭&quot;);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 小明真心喜欢似玉，决定带她去看电影
    /// &amp;lt;/summary&amp;gt;
    public class Film : Decorator
    {
        public Film(IGirlFriend girl) : base(girl)
        {
        }

        public override void Dating()
        {
            base.Dating();
            this.WatchMovie();
            this.MoCha();
        }

        public void WatchMovie()
        {
            Console.Write(&quot;我在和小明看电影&quot;);
        }

        public void MoCha()
        {
            Console.WriteLine(&quot;，我在和小明喝摩卡&quot;);
        }
    }


    /// &amp;lt;summary&amp;gt;
    /// 场景模拟
    /// &amp;lt;/summary&amp;gt;
    class Program
    {
        static void Main(string[] args)
        {
            //女友如花
            IGirlFriend ruHua = new RuHua(); 
            IGirlFriend ruHuaShopping = new Shopping(ruHua);
            ruHuaShopping.Dating();

            IGirlFriend ruHuaEatting = new Eatting(ruHua);
            ruHuaEatting.Dating();

            Console.WriteLine(&quot;----&quot;);

            //女友似玉
            IGirlFriend siYu = new SiYu();
            IGirlFriend siYuFilm = new Film(siYu);
            siYuFilm.Dating();

            Console.ReadKey();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;我是如花我在和小明逛街
我是如花我在和小明吃饭
&lt;span class=&quot;kw&quot;&gt;----&lt;/span&gt;
我是似玉我在和小明看电影，我在和小明喝摩卡&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;咳咳，（敲黑板）这就是我们今天要说的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F&quot;&gt;装饰模式/修饰模式&lt;/a&gt;了&lt;/p&gt;
&lt;p&gt;先看一下定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6.6705882352941&quot;&gt;
&lt;p&gt;修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;解读&quot;&gt;解读：&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;动态的给一个对象添加一些额外的职责&lt;/span&gt;，就增加功能来说，装饰模式比增加子类更加灵活。在不改变接口的前提下，增强所考虑的的类的性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;使用场景&quot;&gt;使用场景：&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;需要扩展一个类的功能，或给一个类增加附加责任；&lt;/li&gt;
&lt;li&gt;需要动态的给一个对象增加功能，这些功能可以再动态的撤销；&lt;/li&gt;
&lt;li&gt;需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使得继承变得不现实。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E6%A0%87%E5%87%86%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8FUML.png&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;组成&quot;&gt;组成&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;抽象构件(Component）角色： 给出一个抽象接口，以规范准备接收附加责任的对象；&lt;/li&gt;
&lt;li&gt;具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类；&lt;/li&gt;
&lt;li&gt;装饰角色(Decorator): 持有一个构件对象（Component）的实例，并定义一个与抽象构件接口一致的接口；&lt;/li&gt;
&lt;li&gt;具体装饰角色(ConcreteDecorator): 负责给构件对象“贴上”附加的责任。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;了解了装饰模式的基本概念，我们以网络游戏中的Buff为例进行练习。&lt;/p&gt;
&lt;h4 id=&quot;buff王者荣耀和魔兽世界&quot;&gt;Buff：王者荣耀和魔兽世界&lt;/h4&gt;
&lt;p&gt;玩过王者荣耀或者魔兽世界等网络游戏的同学都知道Buff是什么，王者荣耀中的红蓝buff，魔兽世界中骑士的智慧（增加魔法值上限），法师的法强（增加法术强度），战士的怒吼（增加力量或生命值上限），等等。&lt;br/&gt;这些“Buff”，持续的时间短则几秒，长则几分钟甚至几小时，有的则更是持续到角色死亡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E7%8E%8B%E8%80%85%E8%93%9DBuff.jpg&quot; alt=&quot;Alt Text&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8Cbuff.jpg&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Buff接口
/// &amp;lt;/summary&amp;gt;
public interface IHeroBuff
{
    void AddBuff();
}

/// &amp;lt;summary&amp;gt;
/// 王者农药
/// &amp;lt;/summary&amp;gt;
public class KingOfGlory : IHeroBuff
{
    public void AddBuff()
    {
        Console.WriteLine(&quot;王者荣耀加Buff&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 魔兽世界
/// &amp;lt;/summary&amp;gt;
public class Wow : IHeroBuff
{
    public void AddBuff()
    {
        Console.WriteLine(&quot;魔兽世界加Buff&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 装饰器
/// &amp;lt;/summary&amp;gt;
public abstract class GameDecorator : IHeroBuff
{
    public IHeroBuff GameBuff { get; set; }

    public GameDecorator(IHeroBuff gf)
    {
        this.GameBuff = gf;
    }

    public abstract void AddBuff();
}

/// &amp;lt;summary&amp;gt;
/// 吃红
/// &amp;lt;/summary&amp;gt;
public class RedBuff : GameDecorator
{
    public RedBuff(IHeroBuff buff) : base(buff) { }

    public override void AddBuff()
    {
        this.GameBuff.AddBuff();
        this.AddRedBuff();
        this.FirstBlood();
    }

    private void AddRedBuff()
    {
        Console.WriteLine(&quot;都让开我吃红了&quot;);
    }

    public void FirstBlood()
    {
        Console.WriteLine(&quot;顺便拿个一血&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 吃蓝
/// &amp;lt;/summary&amp;gt;
public class BlueBuff : GameDecorator
{
    public BlueBuff(IHeroBuff buff) : base(buff) { }

    public override void AddBuff()
    {
        this.GameBuff.AddBuff();
        this.BeCarefor();
        this.AddBlueBuff();
    }

    private void AddBlueBuff()
    {
        Console.WriteLine(&quot;那个，不好意思，我补个蓝&quot;);
    }

    public void BeCarefor()
    {
        Console.WriteLine(&quot;猥琐点小心被拿一血&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 战士团队Buff：生命咆哮
/// &amp;lt;/summary&amp;gt;
public class CommandingShout : GameDecorator
{
    public CommandingShout(IHeroBuff buff):base(buff)
    {

    }

    public override void AddBuff()
    {
        this.GameBuff.AddBuff();
        this.AddBlood();
    }

    public void AddBlood()
    {
        Console.WriteLine(&quot;战士团队Buff: 生命值上限增加10%&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 小德Buff：野性呼唤（爪子)
/// &amp;lt;/summary&amp;gt;
public class MarkOfTheWild : GameDecorator
{
    public MarkOfTheWild(IHeroBuff gf) : base(gf)
    {
    }

    public override void AddBuff()
    {
        this.GameBuff.AddBuff();
        this.AddSomeBuff();
    }

    public void AddSomeBuff()
    {
        Console.WriteLine(&quot;小德Buff: 没玩过不知道有啥增益效果的小德Buff&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 骑士Buff：王者祝福
/// &amp;lt;/summary&amp;gt;
public class BlessingOfKings : GameDecorator
{
    public BlessingOfKings(IHeroBuff gf) : base(gf)
    {
    }

    public override void AddBuff()
    {
        this.GameBuff.AddBuff();
        this.AddBloodAndFight();
    }

    public void AddBloodAndFight()
    {
        Console.WriteLine(&quot;骑士Buff: 攻击力和生命值上限增加10%&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 场景模拟
/// &amp;lt;/summary&amp;gt;
class Program
{
    static void Main(string[] args)
    {
        // 王者
        IHeroBuff hero = new KingOfGlory(); //定义英雄
        IHeroBuff redBuff = new RedBuff(hero); //吃红
        IHeroBuff blueBuff = new BlueBuff(redBuff); //吃蓝
        blueBuff.AddBuff();

        Console.WriteLine(&quot;...........&quot;);

        // 魔兽世界
        IHeroBuff wowHero = new Wow(); //定义英雄
        IHeroBuff commandingShout = new CommandingShout(wowHero); //战士buff
        IHeroBuff markOfTheWild = new MarkOfTheWild(commandingShout); //小德buff
        IHeroBuff blessingOfKings = new BlessingOfKings(markOfTheWild); //骑士buff
        blessingOfKings.AddBuff();

        Console.ReadKey();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;王者荣耀加&lt;span class=&quot;kw&quot;&gt;Buff&lt;/span&gt;
都让开我吃红了
顺便拿个一血
猥琐点小心被拿一血
那个，不好意思，我补个蓝
&lt;span class=&quot;kw&quot;&gt;...........&lt;/span&gt;
魔兽世界加&lt;span class=&quot;kw&quot;&gt;Buff&lt;/span&gt;
战士团队&lt;span class=&quot;kw&quot;&gt;Buff&lt;/span&gt;: 生命值上限增加10%
小德&lt;span class=&quot;kw&quot;&gt;Buff&lt;/span&gt;: 没玩过不知道有啥增益效果的小德Buff
骑士&lt;span class=&quot;kw&quot;&gt;Buff&lt;/span&gt;: 攻击力和生命值上限增加10%&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;总结一下装饰模式的优缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承关系更多的灵活性；&lt;/li&gt;
&lt;li&gt;通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。&lt;/li&gt;
&lt;li&gt;使用装饰模式可能会产生比继承关系更多的对象，使得查错困难。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;装饰模式分透明和半透明方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量；&lt;/li&gt;
&lt;li&gt;半透明的方式则意味着需要根据实际需求声明一个ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator中才有的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论是哪种方式，出发点都是“不改变原有接口”。&lt;/p&gt;
&lt;p&gt;所以，实际开发过程中，&lt;span&gt;无需纠结其透明方式，只要能够降低系统设计的复杂度，满足设计需要即可。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;据传，设计模式是药，没有病是不需要吃药的。不知道这句话该怎么理解，路过的高人可以指点一二。&lt;/p&gt;
&lt;p&gt;好了，继续回去写Bug了，下周再聊！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zanpen2000/notes/raw/master/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pics/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B8%89%E4%B8%AA%E9%94%99.jpg&quot; alt=&quot;Alt Text&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 07:28:00 +0000</pubDate>
<dc:creator>DebugLife</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zanpen2000/p/7737046.html</dc:identifier>
</item>
<item>
<title>react-native绑定优酷SDK-附效果图和源码 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/7736577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/7736577.html</guid>
<description>&lt;p&gt;&lt;span&gt;ReactN&lt;/span&gt;&lt;span&gt;ative绑定优酷SDK需要用到两部分知识：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;优酷本身的sdk绑定；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RN与原生界面的交互；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;效果：&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/172074/201710/172074-20171026142303101-1899447331.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RN版本：0.49.3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码更新日期：2017.10.26&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下文也根据绑定需要分为两部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一、优酷sdk绑定； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二、RN与原生页面的交互；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.优酷云平台创建应用，获取到client_id和client_secret；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　申请地址：&lt;a href=&quot;http://cloud.youku.com/app&quot; target=&quot;_blank&quot;&gt;http://cloud.youku.com/app&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如图：&lt;img src=&quot;http://images2017.cnblogs.com/blog/172074/201710/172074-20171026142737648-2081270908.jpg&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;163&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.引入sdk：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在目录app/libs加入优酷sdk：mma_sdk.jar、utdid4all-1.1.5.5.jar、YoukuPlayerOpenSDK-release.aar，sdk下载地址：&lt;a href=&quot;http://cloud.youku.com/down/play&quot; target=&quot;_blank&quot;&gt;http://cloud.youku.com/down/play&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在目录app/build.gradle里面添加下面两段配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
android {
    // ... 之前本身配置，下面为添加的配置
    //添加libs目录配置
    repositories {
        flatDir {
            dirs 'libs'
        }
    }
    sourceSets {
        main {
            jniLibs.srcDirs = ['libs'];
        }
    }

}

dependencies {
    // ... 之前本身配置，下面为添加的配置
    //公共库
    compile 'com.alibaba:fastjson:1.1.56.android'
    compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.5'
    //sdk
    compile(name: 'YoukuPlayerOpenSDK-release', ext: 'aar')
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.在MainApplication.java初始化优酷播放代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import com.youku.cloud.player.YoukuPlayerConfig;  

  //请在这里输入你的应用的clientId，clientSecret
  public static final String CLIENT_ID_WITH_AD = &quot;e7e4d0ee1591b0bf&quot;;
  public static final String CLIENT_SECRET_WITH_AD = &quot;1fbf633f8a55fa1bfabf95729d8e259a&quot;;

@Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    YoukuPlayerConfig.setClientIdAndSecret(CLIENT_ID_WITH_AD,CLIENT_SECRET_WITH_AD);
    YoukuPlayerConfig.onInitial(this);
    YoukuPlayerConfig.setLog(false);
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.新建Activity和后置类；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页面代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&lt;span&gt;
    xmlns:app&lt;/span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;span&gt;
    xmlns:tools&lt;/span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;span&gt;
    android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:layout_height&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    tools:context&lt;/span&gt;=&quot;com.gangguwang.yewugo.YKPlayerActivity&quot;&lt;span&gt;
    android:orientation&lt;/span&gt;=&quot;vertical&quot;&amp;gt;

    &amp;lt;&lt;span&gt;com.youku.cloud.player.YoukuPlayerView
        android:id&lt;/span&gt;=&quot;@+id/baseview&quot;&lt;span&gt;
        android:layout_width&lt;/span&gt;=&quot;fill_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:layout_alignParentTop&lt;/span&gt;=&quot;true&quot; &amp;gt;
    &amp;lt;/com.youku.cloud.player.YoukuPlayerView&amp;gt;
    
&amp;lt;/LinearLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;后置类代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gangguwang.yewugo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v7.app.AppCompatActivity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.Log;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.player.YoukuPlayerConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.player.YoukuPlayerView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.utils.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.module.PlayerErrorInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.player.PlayerListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.player.VideoDefinition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.cloud.utils.ValidateUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.youku.download.DownInfo;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NativeActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; YoukuPlayerView youkuPlayerView;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String vid=&quot;XMzA1NzYwMTQxNg==&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String password=&quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; local = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_native);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Intent mIntent=getIntent();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if(mIntent!=null) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Toast.makeText(this,&quot;请求参数：&quot;+mIntent.getStringExtra(&quot;params&quot;),Toast.LENGTH_SHORT).show();;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Button btn_two=(Button)this.findViewById(R.id.btn_two);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_two.setVisibility(View.GONE); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏按钮
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; btn_two.setOnClickListener(new View.OnClickListener() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     @Override
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     public void onClick(View v) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         Intent mIntent=new Intent(NativeActivity.this,MainActivity.class);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         mIntent.putExtra(&quot;data&quot;,&quot;你是123...&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         NativeActivity.this.startActivity(mIntent);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         NativeActivity.this.finish();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; });&lt;/span&gt;
        youkuPlayerView =&lt;span&gt; (YoukuPlayerView)findViewById(R.id.baseview);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化播放器&lt;/span&gt;
        youkuPlayerView.attachActivity(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        youkuPlayerView.setPreferVideoDefinition(VideoDefinition.VIDEO_HD);
        youkuPlayerView.setPlayerListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyPlayerListener());
        youkuPlayerView.setShowFullBtn(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        autoplayvideo();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; autoplayvideo() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (local) {
            youkuPlayerView.playLocalVideo(vid);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TextUtils.isEmpty(password)) {
                youkuPlayerView.playYoukuVideo(vid);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                youkuPlayerView.playYoukuPrivateVideo(vid, password);
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPause() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onPause();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须重写的onPause()&lt;/span&gt;
&lt;span&gt;        youkuPlayerView.onPause();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResume() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onResume();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须重写的onResume()&lt;/span&gt;
&lt;span&gt;        youkuPlayerView.onResume();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDestroy();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须重写的onDestroy()&lt;/span&gt;
&lt;span&gt;        youkuPlayerView.onDestroy();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加播放器的监听器&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyPlayerListener &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; PlayerListener {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onComplete() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onComplete();
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onError(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code, PlayerErrorInfo info) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;txt1.setText(info.getDesc());&lt;/span&gt;
&lt;span&gt;        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnCurrentPositionChanged(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; msec) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.OnCurrentPositionChanged(msec);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onVideoNeedPassword(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onVideoNeedPassword(code);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onVideoSizeChanged(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onVideoSizeChanged(width, height);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.配置AndroidManifest.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5.1：给你的播放器Activity加上监听屏幕旋转的语句&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;activity android:name=&quot;.NativeActivity&quot;&lt;span&gt; 
    android:configChanges&lt;/span&gt;=&quot;orientation|keyboard|keyboardHidden|screenSize|screenLayout|uiMode&quot;&lt;span&gt;
    android:exported&lt;/span&gt;=&quot;true&quot;&lt;span&gt;
    android:launchMode&lt;/span&gt;=&quot;singleTask&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;5.2：添加权限&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_MULTICAST_STATE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.INTERACT_ACROSS_USERS_FULL&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此，优酷播放的sdk已经配置完毕。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使用NativeModules模块互交，本章分为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.RN调用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.创建中间交互类IntentModule.java、IntentReactPackage.java;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.使用反射和Intent进行通知原生界面；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.RN调用代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;Button
    onPress&lt;/span&gt;={() =&amp;gt;&lt;span&gt; {
        NativeModules.IntentModule.startActivityFromJS(&lt;/span&gt;'你的包名.NativeActivity', '参数'&lt;span&gt;);
    }}
    title&lt;/span&gt;=&quot;  播 放  &quot;&lt;span&gt;
    color&lt;/span&gt;=&quot;#841584&quot;
/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.创建中间交互类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a).注册原生模块类 IntentReactPackage.java 代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.gangguwang.yewugo;

import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.JavaScriptModule;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;


public class IntentReactPackage implements ReactPackage {
    @Override
    public List&lt;/span&gt;&amp;lt;NativeModule&amp;gt;&lt;span&gt; createNativeModules(ReactApplicationContext reactContext) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Arrays.&amp;lt;NativeModule&amp;gt;&lt;span&gt;asList(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IntentModule(reactContext)
        );
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @Override&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; public List&amp;lt;Class&amp;lt;? extends JavaScriptModule&amp;gt;&amp;gt; createJSModules() {&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     return Collections.emptyList();&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;
    @Override
    public List&lt;/span&gt;&amp;lt;ViewManager&amp;gt;&lt;span&gt; createViewManagers(ReactApplicationContext reactContext) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码解读：固定的api固定的方法必须重写createNativeModules和createViewManagers方法，只是把另一个交互类IntentModule注册到createNativeModules里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b).创建你的RN交互暴露方法类 IntentModule.java，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gangguwang.yewugo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.facebook.react.bridge.Callback;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.facebook.react.bridge.JSApplicationIllegalArgumentException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.facebook.react.bridge.ReactApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.facebook.react.bridge.ReactContextBaseJavaModule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.facebook.react.bridge.ReactMethod;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IntentModule  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ReactContextBaseJavaModule {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IntentModule(ReactApplicationContext reactContext) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(reactContext);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;IntentModule&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Activtiy跳转到JS页面，传输数据
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; successBack
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorBack
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ReactMethod
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dataToJS(Callback successBack, Callback errorBack){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Activity currentActivity &lt;/span&gt;=&lt;span&gt; getCurrentActivity();
            String result &lt;/span&gt;= currentActivity.getIntent().getStringExtra(&quot;data&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (TextUtils.isEmpty(result)){
                result &lt;/span&gt;= &quot;没有数据&quot;&lt;span&gt;;
            }
            successBack.invoke(result);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            errorBack.invoke(e.getMessage());
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从JS页面跳转到原生activity   同时也可以从JS传递相关数据到原生
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; params
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ReactMethod
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startActivityFromJS(String className, String params){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Activity currentActivity &lt;/span&gt;=&lt;span&gt; getCurrentActivity();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;!=&lt;span&gt;currentActivity){
                Class toActivity &lt;/span&gt;=&lt;span&gt; Class.forName(className);
                Intent intent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(currentActivity,toActivity);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&lt;/span&gt;
                intent.putExtra(&quot;params&quot;&lt;span&gt;, params);
                currentActivity.startActivity(intent);
            }

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JSApplicationIllegalArgumentException(&quot;不能打开Activity : &quot;+&lt;span&gt;e.getMessage());
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从JS页面跳转到Activity界面，并且等待从Activity返回的数据给JS
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; className
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; params
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestCode
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; successBack
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorBack
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ReactMethod
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startActivityFromJSGetResult(String className, String params, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; requestCode, Callback successBack, Callback errorBack){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Activity currentActivity &lt;/span&gt;=&lt;span&gt; getCurrentActivity();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(currentActivity != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                Class toActivity &lt;/span&gt;=&lt;span&gt; Class.forName(className);
                Intent intent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(currentActivity,toActivity);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);&lt;/span&gt;
                intent.putExtra(&quot;params&quot;&lt;span&gt;, params);
                currentActivity.startActivityForResult(intent,requestCode);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行回调数据
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; successBack.invoke(MainActivity.mQueue.take());&lt;/span&gt;
&lt;span&gt;            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            errorBack.invoke(e.getMessage());
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /**
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  * 必须添加反射注解不然会报错
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  * 这个方法就是ReactNative将要调用的方法，会通过此类名字调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  * @param msg
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  */
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @ReactMethod
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; public void callNativeMethod(String msg) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;startActivityForResult(myIntent, 1);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;c).在MainApplication.java里面设置交互类IntentReactPackage&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;ReactPackage&amp;gt;&lt;span&gt; getPackages() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Arrays.&amp;lt;ReactPackage&amp;gt;&lt;span&gt;asList(
      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainReactPackage(),
      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IntentReactPackage()
  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.使用反射和Intent进行通知原生界面；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在IntentModule已经体现了，核心代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Activity currentActivity =&lt;span&gt; getCurrentActivity();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;!=&lt;span&gt;currentActivity){
    Class toActivity &lt;/span&gt;=&lt;span&gt; Class.forName(className);
    Intent intent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(currentActivity,toActivity);
    intent.putExtra(&lt;/span&gt;&quot;params&quot;&lt;span&gt;, params);
    currentActivity.startActivity(intent);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此为止已经全部大功告成！源码地址：&lt;a href=&quot;https://github.com/vipstone/react-native-youku&quot; target=&quot;_blank&quot;&gt;https://github.com/vipstone/react-native-youku&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 07:08:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/7736577.html</dc:identifier>
</item>
<item>
<title>Appium python自动化测试系列之滑动函数封装实战(八) - Mushishi_xu</title>
<link>http://www.cnblogs.com/Mushishi_xu/p/7736820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mushishi_xu/p/7736820.html</guid>
<description>&lt;h3&gt;8.1 什么是函数的封装&lt;/h3&gt;
&lt;p&gt;教科书上函数的封装太官方，我们这里暂且将函数的封装就是为了偷懒把一些有共性的功能或者一些经常用的功能以及模块放在一起，方便我们以后再其他地方调用。这个只是个人的理解所以大家懂就行，不要出去就这么说。&lt;/p&gt;
&lt;h3&gt;8.2 如何封装函数&lt;/h3&gt;
&lt;h4&gt;8.2.1 函数封装技巧&lt;/h4&gt;
&lt;p&gt;当我们面对一个功能或者一个模块时我们需要把一些有共性的东西找出来，然后封装成函数，只要记住只要我们用的东西可能用的次数超过一次时我们就给他封装起来，我们不管别人怎么看，我们只要自己干着顺手就行。&lt;/p&gt;
&lt;h4&gt;8.2.2 函数封装实战&lt;/h4&gt;
&lt;p&gt;我们通过下面的代码来讲解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#coding=UTF-8 
    def getSize(self):
    x = self.driver.get_window_size()['width']
    y = self.driver.get_window_size()['height']
    return (x,y)
     
     
  #向左滑动
  def swipeLeft(self,t):
    l=self.getSize()
    x1=int(l[0]*0.9)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.1)
    self.driver.swipe(x1,y1,x2,y1,t)
             
  #向右滑动
  def swipeRight(self,t):
    l=self.getSize()
    x1=int(l[0]*0.25)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.75)
    self.driver.swipe(x1,y1,x2,y1,t)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码是我们之前滑动查找的代码，我们通过代码能够看见我把获取屏幕大小、上、下、左、右滑动的操作都封装成了代码，为什么要这么做呢？一个简单的例子，如果我获取屏幕不进行封装，那么我在往上滑动的时候是不是也要进行去写一次，其他地方也要写一次，那么这样是不是很麻烦呢？而且最简单的就是那样我的代码的可读性也更差。现在知道我们为什么要封装了吗？&lt;/p&gt;
&lt;p&gt;如果你还不是很能够理解，那么你回去把我们的滑动查找的代码多看几遍，如果你不对函数进行封装，那你怎么去实现这个功能？&lt;/p&gt;
&lt;p&gt;看到这里的小伙吧给大家留一个思考以及线下的作业题目，如果将你的启动配置封装一下，让他的实用性更佳高。&lt;/p&gt;
&lt;h3&gt;8.3 构造函数的使用&lt;/h3&gt;
&lt;h4&gt;8.3.1 编码中构造函数的样子&lt;/h4&gt;
&lt;p&gt;有的人在开始学习时不明白构造函数到底是什么，而且经常听说构造函数，构造函数，到底这个构造函数在哪里。学习过java的小伙伴都知道构造函数的函数名和类名时一模一样的，那么在python里呢？他们到底是怎么工作的呢？&lt;/p&gt;
&lt;p&gt;首先下面会写一些伪代码，所以不要拿去运行。&lt;/p&gt;
&lt;p&gt;第一在我们写类的时候是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#下面定义一个类
class person:
  def get_age(self):
    return age
  def get_name(self):
    return name
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然上面的类你会报错，但是我们只需要知道思想，首先我们定义了一个类，然后里面有方法，然后方法给我们返回了一些值，然后我们要使用这个类的方法时是不是需要先去实例化一个对象出来？现在我们只是有类，但是没对象，没有具体的张三还是李四。所以我们需要怎么做嗯？是不是就有了下面的代码：&lt;/p&gt;
&lt;p&gt;zhangsan=person()，然后如果要用张三的年龄是不是就变成了zhangsan.get_age()，但是这里问题来了，我返回了age，但是我是不知道你zhangsan具体有多少岁的啊，你没有告诉我。对吧？那么我是不是需要先告诉这个person？在创造他的时候就说，zhangsan你有3岁，名字叫做张三，对吧。那是不是也就是说我在zhangsan=person() 这个实例化时就需要传入名字和年龄？是不是就变成了zhangsan=person(‘张三’，‘3’)，既然我们实例化时传入了两个参数，但是在我们的person类里面有这两个参数的地方吗？或者说有获取他的地方吗？没有！在我们python里面实例化时默认调用的是无参的构造函数，那么这里我们需要把他变成有参数的构造函数，那么就变成了下面这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#类
class person:
  def __init__(self,age,name):
    self.age = age
    self.name = name
  def get_age(self):
    return self.age
  def get_name(self):
    return self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看出区别了吗？在我们类下面多了一个函数__init__，这就是我们python的构造函数，在你实例化这个类时会自动调用这个方法，所以我们实例化类时传入了两个参数也就在这里传入了两个参数，同样的我们这里也就获取了两个值，因为我们调用get_age的时候这个全局的age已经在我们实例化时获取到了，所以这里直接调用就获取到了。现在知道构造函数的作用了么？实战吧！&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 06:55:00 +0000</pubDate>
<dc:creator>Mushishi_xu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mushishi_xu/p/7736820.html</dc:identifier>
</item>
<item>
<title>Android 自定义View实现QQ运动积分抽奖转盘 - sphere</title>
<link>http://www.cnblogs.com/sphere/p/7736807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sphere/p/7736807.html</guid>
<description>&lt;p&gt;　　因为偶尔关注QQ运动， 看到QQ运动的积分抽奖界面比较有意思，所以就尝试用自定义View实现了下，原本想通过开发者选项查看下界面的一些信息，后来发现积分抽奖界面是在WebView中展示的，应该是在H5页面中用js代码实现的，暂时不去管它了。&lt;/p&gt;
&lt;p&gt;　　这里的自定义View针对的是继承自View的情况，你可以将Canvas想象为画板， Paint为画笔，自定义View的过程和在画板上用画笔作画其实类似，想象在画板上作画的过程，你要画一个多大图形（对应View的测量 onMeasure方法），你要画什么样的图形，比如圆形方形等等（对应View的onDraw方法），在掌握了View的一些基础概念（位置参数、触摸事件、滑动），测量模式、事件分发机制、绘制流程等知识后，自定义View的时候就不觉得复杂了。&lt;/p&gt;
&lt;p&gt;　　不管是多么复杂的View，其内部基本都可以拆分至一个个小单元，比如如下的QQ运动积分抽奖画面，（QQ --&amp;gt; 动态 --&amp;gt; 运动 --&amp;gt; 我 --&amp;gt; 积分）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/651797/201710/651797-20171026141918086-645733456.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 这里我们只关注抽奖的转盘，因为是截图没有动画效果，具体可以在自己的手机上查看下。这个抽奖的界面看似复杂，其实可以分为几个部分&lt;/p&gt;
&lt;p&gt;　　1. 最外层圆环，其中有小圆圈闪动&lt;/p&gt;
&lt;p&gt;　　2, 内部圆角矩形&lt;/p&gt;
&lt;p&gt;　　3.  内部圆角卡片（包含一个图片或说明文字）&lt;/p&gt;

&lt;p&gt;  　第一步我们要继承View类， 如果需要自定义属性则应该实现带三个参数的构造方法，这里将自定义View命名为 LotteryView&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public LotteryView(Context context) {
        this(context&lt;/span&gt;, null)&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    }

    public LotteryView(Context context&lt;/span&gt;,&lt;span&gt; AttributeSet attrs) {
        this(context&lt;/span&gt;, attrs, 0)&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    }

    public LotteryView(Context context&lt;/span&gt;, AttributeSet attrs,&lt;span&gt; int defStyleAttr) {
        super(context&lt;/span&gt;, attrs, defStyleAttr)&lt;span&gt;;
&lt;/span&gt;        init(context, attrs)&lt;span&gt;;
&lt;/span&gt;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在init方法中可以做一些初始化的操作，比如需要用的颜色值，画笔Paint， 宽高信息等，如果有自定义属性，也可以在init方法中处理。&lt;/p&gt;
&lt;p&gt;　　接着可以设定View的宽高信息，这里我们将View设置为正方形&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;super.onMeasure(widthMeasureSpec, heightMeasureSpec);&lt;/span&gt;
&lt;span&gt;        setMeasuredDimension(mSelfTotalWidth, mSelfTotalWidth);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用setMeasureDimension方法，宽高都设置为 mSelfTotalWidth。这里我们宽高是限定的值，所以不需要的处理不同测量模式的情况，如果是其他自定义View要支持wrap_content属性，需要在onMeasure方法中自行处理&lt;/p&gt;
&lt;p&gt;　　第一步 ：绘制外层带圆角的圆环&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 外层带圆角矩形圆环 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drawOuterRoundCircle(Canvas canvas) {
        canvas.save();
        canvas.clipRect(
                mOuterCircleWidth &lt;/span&gt;+&lt;span&gt; getPaddingLeft(),
                mOuterCircleWidth &lt;/span&gt;+&lt;span&gt; getPaddingTop(),
                mSelfTotalWidth &lt;/span&gt;- mOuterCircleWidth -&lt;span&gt; getPaddingRight(),
                mSelfTotalWidth &lt;/span&gt;- mOuterCircleWidth -&lt;span&gt; getPaddingBottom(),
                Region.Op.DIFFERENCE);

        canvas.drawRoundRect(
                getPaddingLeft(),
                getPaddingTop(),
                mSelfTotalWidth &lt;/span&gt;-&lt;span&gt; getPaddingRight(),
                mSelfTotalWidth &lt;/span&gt;-&lt;span&gt; getPaddingBottom(),
                &lt;/span&gt;18, 18&lt;span&gt;, mOuterCirclePaint);
        canvas.restore();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　绘制外层圆环中的小圆圈&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bfd3310f-cbe0-40ca-a549-1729c14515c7')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_bfd3310f-cbe0-40ca-a549-1729c14515c7&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bfd3310f-cbe0-40ca-a549-1729c14515c7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bfd3310f-cbe0-40ca-a549-1729c14515c7',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bfd3310f-cbe0-40ca-a549-1729c14515c7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drawOuterDecorateSmallCircle(Canvas canvas) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = mInvalidateCircleCount % 2&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x = 0, y = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sideSize = mSelfTotalWidth - mOuterCircleWidth * 2 - getPaddingLeft() - getPaddingRight(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除去最外边圆环后的边长&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            mSmallCirclePaint.setColor(i &lt;/span&gt;% 2 == result ?&lt;span&gt; mSmallCircleYellowColor : mSmallCircleBlueColor);
            x &lt;/span&gt;= mOuterCircleWidth + (sideSize - mSmallCircleRadius * 2 * 9) / 9 * i + mSmallCircleRadius * 2 * i +&lt;span&gt; getPaddingLeft();
            y &lt;/span&gt;= (mOuterCircleWidth - mSmallCircleRadius * 2) / 2 + mSmallCircleRadius +&lt;span&gt; getPaddingTop();
            canvas.drawCircle(x, y, mSmallCircleRadius, mSmallCirclePaint);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            mSmallCirclePaint.setColor(i &lt;/span&gt;% 2 == result ?&lt;span&gt; mSmallCircleYellowColor : mSmallCircleBlueColor);
            x &lt;/span&gt;= mOuterCircleWidth + (sideSize - mSmallCircleRadius * 2 * 9) / 9 * i + mSmallCircleRadius * 2 * i +&lt;span&gt; getPaddingLeft();
            y &lt;/span&gt;= mSelfTotalWidth - mOuterCircleWidth + (mOuterCircleWidth - mSmallCircleRadius * 2) / 2 + mSmallCircleRadius -&lt;span&gt; getPaddingBottom();
            canvas.drawCircle(x, y, mSmallCircleRadius, mSmallCirclePaint);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 9; i++&lt;span&gt;) {
            mSmallCirclePaint.setColor(i &lt;/span&gt;% 2 == (result == 0 ? 1 : 0) ?&lt;span&gt; mSmallCircleYellowColor : mSmallCircleBlueColor);
            x &lt;/span&gt;= mOuterCircleWidth / 2 +&lt;span&gt; getPaddingLeft();
            y &lt;/span&gt;=  mOuterCircleWidth*2 + (sideSize - mSmallCircleRadius * 2 * 9) / 9 * i + mSmallCircleRadius * 2 * i +&lt;span&gt; getPaddingTop();
            canvas.drawCircle(x, y, mSmallCircleRadius, mSmallCirclePaint);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 9; i++&lt;span&gt;) {
            mSmallCirclePaint.setColor(i &lt;/span&gt;% 2 == result ?&lt;span&gt; mSmallCircleYellowColor : mSmallCircleBlueColor);
            x &lt;/span&gt;= mSelfTotalWidth - mOuterCircleWidth / 2 -&lt;span&gt; getPaddingRight();
            y &lt;/span&gt;=  mOuterCircleWidth*2 + (sideSize - mSmallCircleRadius * 2 * 9) / 9 * i + mSmallCircleRadius * 2 * i +&lt;span&gt; getPaddingTop();
            canvas.drawCircle(x, y, mSmallCircleRadius, mSmallCirclePaint);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　第二步：绘制内部的圆角矩形，即卡片所在区域的背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drawInnerBackground(Canvas canvas) {
        canvas.drawRect(mOuterCircleWidth &lt;/span&gt;+ getPaddingLeft(), mOuterCircleWidth +&lt;span&gt; getPaddingTop(),
                mSelfTotalWidth &lt;/span&gt;- mOuterCircleWidth -&lt;span&gt; getPaddingRight(),
                mSelfTotalWidth &lt;/span&gt;- mOuterCircleWidth -&lt;span&gt; getPaddingBottom(), mInnerPaint);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第三步： 绘制内部小卡片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drawInnerCards(Canvas canvas) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; left = 0, top = 0, right = 0, bottom = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; spaceNum = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 9 ; i++&lt;span&gt;) {
            spaceNum &lt;/span&gt;= i % 3 + 1&lt;span&gt;;
            left &lt;/span&gt;= mOuterCircleWidth + mInnerCardWidth * (i%3) + mInnerCardSpace * spaceNum +&lt;span&gt; getPaddingLeft();
            top &lt;/span&gt;= mOuterCircleWidth + mInnerCardWidth * (i/3) +mInnerCardSpace * (i/3 + 1) +&lt;span&gt; getPaddingTop();
            right &lt;/span&gt;= left +&lt;span&gt; mInnerCardWidth;
            bottom &lt;/span&gt;= top +&lt;span&gt; mInnerCardWidth;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;mHadInitial) {
                mCardPositionInfoList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Pair(&lt;span&gt;new&lt;/span&gt; Pair(left, right), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pair(top, bottom)));
            }
            drawInnerRoundCard(canvas, left, top, right, bottom, i);
        }
        mHadInitial &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　全部绘制完成后，在onTouchEvent中处理点击事件即可，如何判定我们点击的是抽奖的区域，这里使用对比位置信息的方法，&lt;/p&gt;
&lt;p&gt;　　如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getTouchPositionInCardList(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mCardPositionInfoList != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Pair&amp;lt;Pair&amp;lt;Integer, Integer&amp;gt;,Pair&amp;lt;Integer, Integer&amp;gt;&amp;gt;&lt;span&gt; pair : mCardPositionInfoList) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x &amp;gt; pair.first.first &amp;amp;&amp;amp; x &amp;lt; pair.first.second &amp;amp;&amp;amp; y &amp;gt; pair.second.first &amp;amp;&amp;amp; y &amp;lt;&lt;span&gt; pair.second.second) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                }
                index&lt;/span&gt;++&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将每一个小卡片的坐标信息（left，top， right， bottom）信息，保存在 ArrayList&amp;lt;Pair&amp;lt;Pair&amp;lt;Integer, Integer&amp;gt;,Pair&amp;lt;Integer, Integer&amp;gt;&amp;gt;&amp;gt;  mCardPosttionInfoList 中， 当点击VIew时获取到点击的x y 坐标和&lt;/p&gt;
&lt;p&gt;list中保存的坐标信息做对比，如果index == 5 ，则说明点击的是抽奖所在的小卡片区域。&lt;/p&gt;

&lt;p&gt;　　代码托管在：&lt;a href=&quot;https://github.com/aquarius520/LotteryView&quot; target=&quot;_blank&quot;&gt; &lt;span&gt;https://github.com/aquarius520/LotteryView&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;/span&gt; 欢迎star fork&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 06:52:00 +0000</pubDate>
<dc:creator>sphere</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sphere/p/7736807.html</dc:identifier>
</item>
<item>
<title>R学习笔记 第二篇：矩阵、数组和列表 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5048622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5048622.html</guid>
<description>&lt;p&gt;向量是一维的，只有长度（行），没有其他维度。R中存在更高维度的对象，他们是矩阵，数据框，数组。这些对象的下标都是使用中括号[]，第一个维度是row，第二个维度是column，依次类推，[row,column,,,]。数组是二维或多维（三维或多于三维），二维数组叫做矩阵。数组元素的类型是相同的，每个维度的元素数量是相同的。数据框是二维对象，每个数据列的数据类型是相同的，不同数据列的数据类型可以不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，数组（array）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;R使用arrary函数创建数组，该函数至少需要两个向量参数：数组的元素值（data）向量，和维度（dim）向量，第三个参数是可选的维度名（dimnames）向量。数据（data）参数是数组的所有元素值向量，维度参数（dim）指定各个维度的元素数量，维度名（dimnames）参数是可选的，指定各个维度的名称。&lt;/p&gt;
&lt;p&gt;数组的维度是有顺序的，维度参数(dim)的第一个维度是row，第二个维度是column，第三个维度是high，以此类推，数组是按照维度的顺序把数据（data）参数的数据填充到数组中。&lt;/p&gt;
&lt;p&gt;严格来说，数组（或矩阵）的长度和维度是固定的，因此不能增加或删除行或列，但可以通过为数组（或矩阵）重新赋值来实现行或列的增加或删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，创建数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：data=c(1:12),dim=c(2:3:2)，这说明，数组共有：第一维是2行，第二维是3列，第三维是2项（item），参数dimnames为三个维度的row，column和itme命名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt; three_d_array=&lt;span&gt;array(
&lt;/span&gt;+     data=c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+     dim=c(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+     dimnames=&lt;span&gt;list(
&lt;/span&gt;+         c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+         c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+         c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;+&lt;span&gt;         )
&lt;/span&gt;+&lt;span&gt;     )&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印的结果如下，其中“ , , h1”，表示第三维的第一个item，数组按照(1,1,1),(2,1,1),(1,2,1),,的顺序填充元素值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;, , h1
   c1 c2 c3
r1  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
r2  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;&lt;span&gt;

, , h2
   c1 c2 c3
r1  &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
r2  &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，数组的维度和长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数dim返回数组的各个维度的长度，输出的顺序是维度的顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; dim(three_d_array)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特别地，函数nrow，ncol，用于返回数组的第一个维度，第二个维度的长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; nrow(three_d_array)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;2&lt;/span&gt;
&amp;gt;&lt;span&gt; ncol(three_d_array)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数length，用于返回数组的长度，是数组的各个维度的乘积：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; length(three_d_array)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二，&lt;strong&gt;矩阵（matrix）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;矩阵是二维数组的特列，本质上是二维数组。使用matrix创建矩阵，必须传递的参数是数据（data）向量，行数（nrow）或列数（ncol），可选的参数是dimnames参数和byrow参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;byrow&lt;/strong&gt;参数的默认值是FALSE，表示按照列填充矩阵，这意味着，R首先填充第一列的所有行，再填充第二列的所有行，以此类推：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt; a_matrix=&lt;span&gt;matrix(
&lt;/span&gt;+     data=c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+     nrow=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+     byrow=&lt;span&gt;FALSE,
&lt;/span&gt;+     dimnames =&lt;span&gt; list(
&lt;/span&gt;+         c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+         c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;+&lt;span&gt;     )
&lt;/span&gt;+ )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回的结果如下，矩阵使用data参数，先填充位置(1,1)，再填充位置(2,1)，以此类推：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; a_matrix
   c1 c2 c3
r1  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
r2  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;矩阵只有两个维度，行（row）和列（column），可以使用nrow，ncol，dim函数获得矩阵各个维度的长度，可以使用length函数获得矩阵的长度，即矩阵的元素总数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，索引数组和矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;R使用中括号[]表示索引，有四种指定索引的方法（正整数，负整数，逻辑值和元素的名称）。在不同的维度上用不同的方式指定索引下标，是有效的，每个维度的下标使用逗号分割。如果相应的维度上，下标为空，那么表示该维度的所有元素。&lt;/p&gt;
&lt;p&gt;例如，索引数组，包含所有的行（row），第一个维度的下标是空；选择第二个维度的第1，2列，第二个维度的下标是向量c(1:2)；选择第三维度的第一项（item），第三个维度的下标是1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt; three_d_array[,&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
   c1 c2
r1  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
r2  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四，列表（list）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列表的各个item的数据类型可以不同，列表没有维度，只有元素，或项（item）。列表由list函数创建，每个参数使用逗号分割，用于指定列表的内容，列表中的元素数量不限，类型不限。不严格地说，列表是一个向量，不过，列表的元素类型可以不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，创建列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，创建列表，列表共有三个item，第一个item是整数向量，第二个item是字符向量，第三个item是矩阵。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list=&lt;span&gt;list(
&lt;/span&gt;+     c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+&lt;span&gt;     month.abb,
&lt;/span&gt;+     matrix(c(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;2&lt;/span&gt;,-&lt;span&gt;3&lt;/span&gt;,-&lt;span&gt;4&lt;/span&gt;),nrow=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;+ )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印列表，列表的第一个item，使用两个嵌套的中括号[[1]]表示，这是索引列表的一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; a_list
[[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

[[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]]
 [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]]
     [,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] [,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,]   -&lt;span&gt;1&lt;/span&gt;   -&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,]   -&lt;span&gt;2&lt;/span&gt;   -&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，列表的命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用函数names(list)为列表的每个item命名，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt; names(a_list)=c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;third&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以在创建列表时，为每个item命名，item的name是变量名，不需要加引号：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list=&lt;span&gt;list(
&lt;/span&gt;+     first=c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;+     second=&lt;span&gt;month.abb,
&lt;/span&gt;+     third=matrix(c(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;2&lt;/span&gt;,-&lt;span&gt;3&lt;/span&gt;,-&lt;span&gt;4&lt;/span&gt;),nrow=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;+ )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印已命名的列表，每个item的名称前面都有 $ 符号，这是索引列表的一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; a_list
$first
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

$second
 [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

$third
     [,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] [,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,]   -&lt;span&gt;1&lt;/span&gt;   -&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,]   -&lt;span&gt;2&lt;/span&gt;   -&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，列表的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列表没有维度，可以使用length获取列表的长度，列表的长度是列表的item的数量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; length(a_list)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4，索引列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用中括号索引列表的元素，下标有四种表示方法：正整数，负整数，元素名称或逻辑索引，例如，a_list[1:2], a_list[-3], a_list[c('first','second')], a_list[c(TURE,TRUE,FALSE)] 这四种方法返回的结果相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list[&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
$first
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

$second
 [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些索引操作的结果是&lt;strong&gt;另一个列表&lt;/strong&gt;，这意味着，使用单个中括号，返回的是一个&lt;strong&gt;新的列表&lt;/strong&gt;，要访问列表元素的内容，有两种方式：使用&lt;strong&gt;嵌套的中括号（传入正整数，代表列表项的下标，或传入字符串，代表列表项的名称），或指定元素的名称&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，通过嵌套的中括号和下标，获取列表的第一个项目（item）的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list[[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，通过指定元素的名称作为下标，获取列表的第一个项目（item）的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; a_list$first
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在访问列表的元素之后，可以通过中括号访问列表项的元素值，例如，列表的第一个项目是向量，通过中括号和下标，能够访问向量的第一个元素的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list$first[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;
&amp;gt; a_list[[&lt;span&gt;1&lt;/span&gt;]][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果以错误的正整数索引访问列表元素的内容，R会抛出下标越界的错误，而使用错误的列表项（item）的名称，R会返回NULL值，不会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list[[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]]
Error &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; a_list[[&lt;span&gt;4&lt;/span&gt;]] : subscript &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of bounds
&lt;/span&gt;&amp;gt;&lt;span&gt; a_list$forth
NULL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五，NULL值和NA值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NULL是个特殊值，表示未知值，NA表示缺失值，NULL和NA之间最大的区别是：NA是一个标量值，长度为1，而NULL不会占用任何空间，长度为零：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; length(NA)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;
&amp;gt;&lt;span&gt; length(NULL)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用is.null函数验证NULL值，使用is.na函数验证NA值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; &lt;span&gt;is&lt;/span&gt;.&lt;span&gt;null&lt;/span&gt;&lt;span&gt;(NULL)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] TRUE
&lt;/span&gt;&amp;gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(NA)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] TRUE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六，列表项的追加、删除和更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列表创建之后，可以向列表中追加元素，也可以删除现有的列表元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，删除列表元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NULL能够用于删除列表中的元素，把列表项设置为NULL，则会删除该列表项，在该列表项之后的元素，其索引都要减少1：&lt;/p&gt;
&lt;p&gt;例如，把第一个列表项删除，原第二个列表项的索引变成1，原第三个列表的索引变成2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
a_list[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;NULL
&lt;/span&gt;&amp;gt;&lt;span&gt; a_list
$second
 [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

$third
     [,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] [,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,]   -&lt;span&gt;1&lt;/span&gt;   -&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,]   -&lt;span&gt;2&lt;/span&gt;   -&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，追加列表元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项列表中追加新的列表项，可以使用嵌套的中括号（在列表末尾追加未命名的列表项），或直接使用新的列表项的名称（在列表末尾追加已命名的列表项）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list[[&lt;span&gt;3&lt;/span&gt;]]=c(&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt; a_list$fifth=c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&lt;span&gt; a_list
$second
 [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

$third
     [,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] [,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,]   -&lt;span&gt;1&lt;/span&gt;   -&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,]   -&lt;span&gt;2&lt;/span&gt;   -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

[[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

$fifth
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，列表项的更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更新列表项，这可以通过直接访问列表项，把列表项赋值为新的变量的值来实现，例如，把列表的第三个列表项修改为list变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; a_list[[&lt;span&gt;3&lt;/span&gt;]]=list(&lt;span&gt;'L&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'L&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt; a_list[[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]]
[[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;L&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]]
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;L&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/aba70025b7a2&quot; target=&quot;_blank&quot;&gt;R--列表&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 06:17:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5048622.html</dc:identifier>
</item>
<item>
<title>abapGit简介与教程 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/7735421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/7735421.html</guid>
<description>
&lt;p&gt;你是ABAP开发者？你用&lt;a href=&quot;http://www.abapgit.org/&quot; target=&quot;_blank&quot;&gt;abapGit&lt;/a&gt;吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994049/201710/994049-20171026100652019-1507260930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个问题，读者也许会想，什么是abapGit？就让我们从这个问题开始。简单地说，abapGit是一个以ABAP写成为ABAP服务的Git客户端。&lt;/p&gt;
&lt;p&gt;有的读者可能依然感到困惑：什么是Git呢？这可能已经超出了本文的话题范围，请移步Google进行了解..&lt;/p&gt;
&lt;p&gt;那么让我假设你在搜索之后已经返回了本文。Git是当代开发者的工具的基础部分，在我看来，在2017年的现在忽略它是不现实的。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: abapGit简介——很简单&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/7735421.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/7735421.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文标题：&lt;a href=&quot;https://blogs.sap.com/2017/06/21/abapgit-so-easy/&quot; target=&quot;_blank&quot;&gt;abapGit – so easy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;回到主题，abapGit是一个开源项目，它由&lt;a href=&quot;https://people.sap.com/lars.hvam&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Lars Hvam&lt;/a&gt;发起，基于MIT许可证。&lt;/p&gt;
&lt;p&gt;在本文撰写时，abapGit项目已经有30位贡献者，过去5个月中有超过500次commit，可见它是一个活跃而有生气的项目。也许看完本文后，你也会希望成为其中的一名贡献者，让项目变得更加壮大和优秀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994049/201710/994049-20171026102104488-1777323027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;abapGit的设计目标之一是它应当“小型化”。这对很多人有着重要意义。其中之一即是，它会是迄今为止最易于安装的ABAP项目！没有传输，没有多个步骤，没有预安装，没有文件上传，没有补丁，不需要加载项。只要简单的将代码复制粘贴到你的ABAP开发系统系统里，然后激活它。&lt;/p&gt;
&lt;p&gt;就像这样（视频来自youtube..）：&lt;/p&gt;
&lt;p&gt;安装完成后，你想做的第一件事大概就是连接GitHub，以保持你的abapGit代码是最新的。耶——这是个惊人的想法不是吗？我们可以在在自己喜欢的任何时间拉取abapGit项目的最近版本。Kapow! Take that CTS!（？？） abapGit也有后台模式，所以你可以自动地完成更新任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994049/201710/994049-20171026113924113-1321828755.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你很可能希望为你的仓库使用Github。GitHub是当前最流行的Git托管平台，它免费，并且其中还包含某些极好的ABAP开源项目，比如&lt;a href=&quot;https://github.com/ivanfemia/abap2xlsx&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;abap2xlxs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;abapGit需要使用TLS与GitHub连接。这意味着我们必须在ABAP系统中通过事务STRUST安装某些些根证书。&lt;a href=&quot;http://larshp.github.io/abapGit/guide-install.html&quot; target=&quot;_blank&quot;&gt;abapGit安装文档&lt;/a&gt;可以告诉你如何获取并安装这些证书。也有一个&lt;a href=&quot;http://larshp.github.io/abapGit/other-test-ssl.html&quot; target=&quot;_blank&quot;&gt;简单的测试程序&lt;/a&gt;帮助你确保连接Github成功。&lt;/p&gt;
&lt;p&gt;如果你想要将abapGit连接到其它Git服务器，它们可能也会强制你使用TLS，因此你需要安装其它根证书，具体的根证书取决于他们的CA。&lt;/p&gt;
&lt;p&gt;所以现在已经搞定了，让我们看看我们怎样连接到GitHub上面的abapGit仓库，以保持自己安装的abapGit是最新的。有一个向导可以帮助你。&lt;/p&gt;
&lt;p&gt;当abapGit第一次运行的时候，它会给你一个abapGit教程页。你也可以通过菜单Help-&amp;gt;Tutorial来找到它。点击“install abapGit repo&quot;链接来启动连接过程。会出现提示，要求你确认安装到$ABAPGIT包中。abapGit连接Git仓库（repo）和ABAP包（package）。因此我们需要将abapGit本身存储在一个本地包中——在本例里面是$ABAPGIT。还会出现提示询问你是否要覆盖刚刚创建的ZABAPGIT程序，选择“OK&quot;。激活所有abapGit组件，就可以完成了。视频：&lt;/p&gt;

&lt;p&gt;为完成这篇文章，让我举个能让你理解abapGit是如何改变ABAP开发者的工作的例子，带你经过一个简单的场景。我们需要以clone一个到ABAP包里作为开始。我会使用到我最近的一段有关构建Gateway Service的示例代码，代码在这里：&lt;a href=&quot;https://github.com/grahamrobbo/teched16_example&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/grahamrobbo/teched16_example&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;视频如下：&lt;/p&gt;
&lt;p&gt;看看它有多简单，几个点击就可以从GitHub拉取所有的ABAP代码到一个我在abapGit界面中创建的包里，并且激活了所有的的东西。Kapow!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994049/201710/994049-20171026134624051-1505707095.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在注意，我想我的代码需要点重构了，我决定删掉接口ZIF_GW_METHODS，因为我忘记这个东西在哪里能用到。我因此丢掉了重要的代码，程序遭到了破坏，而我无法激活任何东西。Arrrggghhhh...我想我只能登陆生产系统，复制粘贴旧版的代码，然后从头开始——假设我还能记住自己做过的修改的话。&lt;/p&gt;
&lt;p&gt;或者——我可以只是刷新我的包为上次commit到GitHub repo的状态。并且因为我“commit early and commit often”，我并没有因此丢掉我的工作进展。视频：&lt;/p&gt;
&lt;p&gt;Kapow!&lt;/p&gt;
&lt;p&gt;这只是将Git引入到ABAP开发者工具中的好处之一。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.sap.com/2017/06/22/saplink-thankyou/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Thankyou SAPlink&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 06:06:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/7735421.html</dc:identifier>
</item>
<item>
<title>读书笔记之《深入理解Java虚拟机》不完全学习总结 - Qcer</title>
<link>http://www.cnblogs.com/qcblog/p/7704788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcblog/p/7704788.html</guid>
<description>&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以称作不完全总结，因为我其实没有完完全全地看完此书，但是涵盖了大部分重要章节；同时以下总结是我自己认为很重要知识，细枝末节处难免遗漏，还请详细参考原著。&lt;/p&gt;
&lt;p&gt;转载请注明原文出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 读书笔记之《深入理解Java虚拟机》不完全学习总结&quot; href=&quot;http://www.cnblogs.com/qcblog/p/7704788.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qcblog/p/7704788.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、java内存区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1、运行时数据区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/653357/201710/653357-20171022224319631-562353112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序计数器是线程隔离的内存空间，并且是规范中唯一一个没有规定OutOfMemoryError的区域。&lt;/p&gt;
&lt;p&gt;虚拟机栈也是是线程隔离的区域，方法的调用以栈帧为单位，在虚拟机栈中入栈和出栈。栈帧主要用于存储局部变量表、操作栈、动态链接和方法出口等信息。这块区域有可能会发生StackOverflowError或者OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;本地方法栈主要为native方法服务。&lt;/p&gt;
&lt;p&gt;堆内存算是java中比较重要的数据区，是线程共享的数据区。几乎所有的对象和数组都要在堆中进行内存分配，堆也是垃圾收集器管理的主要区域。如果对堆更加细致的划分，还可划分为新生代和老年代，新生代还可划分为一个Eden空间和两个Survivor空间（Form Survivor和To Survivor）。堆可以允许物理内存空间不连续，但是逻辑上是连续的内存空间。&lt;/p&gt;
&lt;p&gt;方法区（也称作非堆）也是线程共享的，用来存储被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;方法区中有一个非常重要的子区域：运行时常量池，用来存储编译生成的字面量和符号引用，直接体现为class字节码文件中的constant_pool数据项。&lt;/p&gt;
&lt;p&gt;一个更加具体的例子，如下定义了一个最简单的几乎为空的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Empty {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 10&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用javap -verbose解析字节码文件，截取Constant pool段的信息，这其实就是常量池的静态文件展现形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/653357/201710/653357-20171022230433865-1852749190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面会看到常量池中总共24项（从1开始计数），其中有一些很熟悉的字面量和符号引用：java/lang/Object，[Ljava/lang/String;:String类型的数组描述符，I:整型描述符，&amp;lt;clinit&amp;gt;:类初始化方法，&amp;lt;init&amp;gt;:构造器，this，main，Code:属性表的Code属性，方法体的代码编译后存档在该属性下面，等等，这些都将会在字节码文件的其他数据项中被引用到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2、对象访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对象访问的两种方式：使用句柄和使用直接指针。&lt;/p&gt;
&lt;p&gt;Sun HotSpot使用直接指针的方式访问对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3、几个重要的内存参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；&lt;br/&gt;-Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；&lt;br/&gt;-Xmn Java Heap Young区大小，不熟悉最好保留默认值；&lt;br/&gt;-Xss 每个线程的Stack大小，不熟悉最好保留默认值；&lt;/p&gt;
&lt;p&gt;-XX:PermSize：JVM初始分配的非堆内存&lt;br/&gt;-XX:MaxPermSize：JVM最大允许分配的非堆内存，按需分配&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、自动内存管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;java的自动内存管理实际上包含了两方面的内容：给对象分配内存和回收分配给对象的内存（垃圾收集）。&lt;/p&gt;
&lt;p&gt;垃圾收集和内存自动分配并非源自java，实际上Lisp是第一门使用该技术的语言。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1、垃圾收集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.1、对象存活的判定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;判断对象时否存活的算法通常有两种：引用计数算法和根搜索算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给每个对象设置一个引用计数器，每当有一个地方引用该对象时，计数器的值就加1，当引用失效时，计数器的值就减1，当计数器的值为0时，代表该对象不再被使用应该被回收掉。&lt;/p&gt;
&lt;p&gt;这种算法实现简单，通常情况下判断效率也是很高的，但是不能判断循环引用的情况。例如对象A的成员变量引用了对象B，同时对象B的成员变量又引用了对象A，A和B对象相互构成循环引用，虽然A和B对象的引用计数器不为0，但他们有可能已经是无用的对象，此时引用计数器算法在这种情况下的判定存在盲区，算法是失效的。java虚拟机也没有采用这种算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根搜索算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过一系列称为“GC Root”对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Root之间没有任何引用链相连时（从图论角度就是GC Root到该对象不可达），则该对象不可用应该被回收。&lt;/p&gt;
&lt;p&gt;那么哪些对象可以被用来作为GC Root呢？如下几种可以用来充当GC Root对象：&lt;/p&gt;
&lt;p&gt;1）虚拟机栈（本地变量表）中引用的对象；&lt;/p&gt;
&lt;p&gt;2）方法区中的静态变量引用的对象；&lt;/p&gt;
&lt;p&gt;3）方法区中常量引用的对象；&lt;/p&gt;
&lt;p&gt;4）本地方法栈（native方法）中引用的对象。&lt;/p&gt;
&lt;p&gt;引用扩充：&lt;/p&gt;
&lt;p&gt;JDK1.2后将引用的概念扩充，形成了强引用、软引用、弱引用、虚引用四种不同的引用，引用强度依次减弱。&lt;/p&gt;
&lt;p&gt;值得注意的是：&lt;/p&gt;
&lt;p&gt;一个对象真正死亡实际上需要经历至少两次标记，在经历根搜索算法后发现该对象没有与GC Root相连，此时发生第一次标记，然后会进行一个“是否需要执行finalize()”的判定，如果被判定为需要执行finalize()方法，稍后由虚拟机调用finalize()，此时会被第二次标记。&lt;/p&gt;
&lt;p&gt;对象的finalize()方法只能被系统自动调用一次，finalize()也是对象逃离死亡的最后一次机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.2、垃圾收集算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要的垃圾收集算法有四个：标记-清除算法、复制算法、标记-整理算法、分代回收算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记-清除算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标记-清除算法是比较基础的收集算法，分为标记和清除两个阶段，但是有两个主要的缺点：效率不高，容易产生内存碎片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复制算法可以解决效率的问题，基本的思想是让内存容量的一半用来相互充当“备胎”，当其中一半用完，就将存活的对象直接复制到另一半空间中，把原来的那一半空间全部清空，再次充当“备胎”作用。这种机制同时不用考虑内存碎片的影响。&lt;/p&gt;
&lt;p&gt;但是事情还不止于此。&lt;/p&gt;
&lt;p&gt;实际上，实际的情况是按照8:1:1来划分，8指Eden空间，两个1指相同大小的Survivor空间（From Survivor和To Survivor），每次使用Eden空间和其中一块Survivor空间，当进行垃圾回收时，将正在使用的Eden和Survivor空间中存活的对象复制到另外一块空闲的Survivor空间，同时清空掉刚才使用的Eden和Survivor空间，当然这里还有内存担保的机制。基于这种“复制”对象的机制，不难看出，当对象的成活率比较低的时候，这种算法的成本很小，效果很好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记-整理算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标记-整理算法主要是针对对象成活率较高，只有少数对象被回收的情况，这种情况没有必要进行全部对象的移动，只需要释放少数被回收对象的空间，同时对剩余对象进行空间调整以至于不会出现严重的内存碎片的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分代回收算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分代回收算法将根据对象存活周期的长短，将堆分为新生代和老年代，并采用不同的算法。&lt;/p&gt;
&lt;p&gt;新生代指对象存活期短的区域，垃圾收集会有大量对象被回收，适合采用复制收集算法；老年代指对象存活期长的区域，垃圾收集会有大量对象存活，适合采用标记-整理算法。&lt;/p&gt;
&lt;p&gt;Minnor GC和Full GC的不同：&lt;/p&gt;
&lt;p&gt;新生代GC（Minnor GC）：发生在新生代的垃圾收集动作，对象存活期短，Minnor GC非常频繁，速度也比较快。&lt;/p&gt;
&lt;p&gt;老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，对象存活期长，Major GC比Minnor GC慢很多（10倍以上）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2、内存分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内存分配分配的原则：&lt;/p&gt;
&lt;p&gt;1、对象优先在Eden空间分配。&lt;/p&gt;
&lt;p&gt;2、大对象直接进入老年代（连续内存空间的对象，典型的长字符串或者数组）。&lt;/p&gt;
&lt;p&gt;3、长期存活的对象将进入老年代。&lt;/p&gt;
&lt;p&gt;对象在Survivor空间没熬过依次Minnor GC，其对象年龄计数器（Age）加1，累计增加到默认值15时，晋升到老年代。&lt;/p&gt;
&lt;p&gt; 4、但实际上，只要在Survivor空间中相同年龄的所有对象的总和大于Survivor空间的一般，则年龄大于等于该年龄的对象就会进入老年代，无需等到年龄的一个阈值。&lt;/p&gt;
&lt;p&gt; 内存担保的作用在于新生代垃圾收集收效甚微，有大量的对象存活，此时另外一个充当“备胎”的Survivor空间容纳不下，则会将容纳不下的对象直接进入老年代。但是这里还有一个问题要思考：此时老年代是否能够容纳得下这里从新生代过来的对象呢？（注意：在没有对新生代进行Minnor GC之前，无从知道究竟有多少对象会存活）&lt;/p&gt;
&lt;p&gt;如果容纳不下，那么还得对老年代进行一次Full GC腾出空间呢。所以这里只能取一个之前每一次回收晋升到老年代的对象容量的平均值作为一个经验值，来和老年代此时剩余的空间做比较，以此来判断是否需要做Full GC。但即使是这样，在概率的意义下任然不可避免担保失败的情况发生。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、class文件结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;class文件以字节为单位，以类似C语言的结构体的伪结构来组织数据，这种伪结构只有两种数据类型：&lt;/p&gt;
&lt;p&gt;1）无符号数（u1,u2,u4,u8，属于数据基本数据类型）&lt;/p&gt;
&lt;p&gt;2）表（属于复合数据类型）&lt;/p&gt;
&lt;p&gt;基本数据数据类型组合形成表，表与表之间可嵌套，可形成多维表，实际上可以将整个class文件看成一张表，而这张表中层层嵌套了其他不同的表。&lt;/p&gt;
&lt;p&gt;class总体来看由如下内容组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/653357/201710/653357-20171022153718849-1138954224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分的内容虽然枯燥，阅读需要静心和耐心，但是当我们需要用javap去解析class文件的字节码指令探索语言更深一层的原理时，这部分知识无疑是必须的。&lt;/p&gt;
&lt;p&gt;其中我认为最重要的就是方法表和常量池，常量池之所以重要是因为它是class文件中与其他数据项（主要是字段表、方法表和属性表）关联、交互最多的数据类型。方法表（包含其中的属性表）之所以重要是因为在分析字节码文件时通常更加关注java源文件中的方法体被编译后字节码展现，这部分更准确的说是在方法表的内嵌属性表的“Code”属性中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常量池：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常量池其实算是class文件中比较复杂的数据项，因为常量池可以存放11项不同的常量，而这11项不同的常量实际上又是复合数据类型（表结构数据，以_info结尾），它们都有各自的结构（实际上它们的结构都比较相似）。总结来说，常量池本身是一张表，表中的每一项也是一张表，因此可以认为常量池是二维表结构。&lt;/p&gt;
&lt;p&gt;需要总结几点：&lt;/p&gt;
&lt;p&gt;1、常量池从1开始计数，第0项有特殊的意义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Constant pool:
#&lt;/span&gt;1 = Class #2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; com/demo/TestDispatch&lt;/span&gt;
#2 = Utf8 com/demo/TestDispatch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、常量池主要存放字面量（Literal）和符号引用（Symolic References）。&lt;/p&gt;
&lt;p&gt;符号引用主要包括：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;1）类和接口的全限定名（&lt;span class=&quot;fontstyle1&quot;&gt;Fully Qualified Name&lt;span class=&quot;fontstyle0&quot;&gt;）&lt;br/&gt;2）字段的名称和描述符（&lt;span class=&quot;fontstyle1&quot;&gt;Descriptor&lt;span class=&quot;fontstyle0&quot;&gt;）&lt;br/&gt;3）方法的名称和描述符&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;字段表：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;字段表（field_info）中有三个概念需要注意：“全限定名”、“简单名称”和“描述符”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;全限定名好理解，简单名称就是去掉类型和参数修饰的方法或者字段名称。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;而描述符就比较复杂一点，主要需要注意8中基本数据类型的描述符（B,C,D,F,I,J,S,Z），void的描述符（V），对象类型描述符（L），数组类型描述符（[）以及方法的描述符（先描述参数列表，放在()中，后描述返回值类型），这些是看懂字节码文件的前提。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;对于属性表（attribute_info），重点关注的就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Code属性，涉及到方法体的字节码部分，LineNumberTable，LocalVariableTable两个属性还好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;4、类加载过程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;类的生命周期中有7个阶段：加载、验证、准备、解析、初始化、使用、卸载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;虚拟机规范中没有规定类加载的时机，但是规定了对类的主动引用的4种场景，这四种场景下，类要求被初始化：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令（注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：&lt;/p&gt;
&lt;p&gt;• 使用new关键字实例化对象的时候；&lt;br/&gt;• 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；&lt;br/&gt;• 调用一个类的静态方法的时候。&lt;/p&gt;
&lt;p&gt;2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。&lt;br/&gt;3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;br/&gt;4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。&lt;/p&gt;
&lt;p&gt;其余的场景称为被动引用，不会对类进行初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1、类加载的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载阶段的工作主要包括：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；&lt;br/&gt;2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；&lt;br/&gt;3) 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证阶段主要的工作包括&lt;/strong&gt;：文件格式验证、元数据验证、字节码验证和符号引用验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备阶段：&lt;/strong&gt;该阶段需要特别注意，该阶段为类变量分配内存并赋零值（此零值指各种具体类型的默认初始值），类变量在这个阶段第一次被赋值。同时，final修饰的类变量直接赋予程序设定的值而不是零值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析阶段的工作&lt;/strong&gt;：将常量池中的符号引用替换为直接引用。&lt;/p&gt;
&lt;p&gt;为什么会存在这样一个解析过程呢？&lt;/p&gt;
&lt;p&gt;因为由java源文件编译成字节码过程的不涉及通常意义下的“编译”过程中链接，因此编译后的字节码文件的常量池中符号引用与虚拟机的内存布局还没有发生映射关联，引用的目标不一定加载到了内存中，但是字节码指令的运行必须要与有这样的关联，也就需要这样一个转换过程。&lt;/p&gt;
&lt;p&gt;解析主要针对类或者接口（都为Class），字段（Fieldref）、类方法（Methodref）和接口方法四类符号引用进行解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化阶段是类加载的最后一个阶段，该阶段是真正按照程序代码的意图为类变量设定初始值（即开始真正执行代码赋初值，也即执行构造器&amp;lt;clinit&amp;gt;）。&lt;/p&gt;
&lt;p&gt;该阶段应该特别关注&amp;lt;clint&amp;gt;的生成原理（收集类变量和静态语句块的过程）以及与类构造器（&amp;lt;init&amp;gt;构造器）的区别。&lt;/p&gt;
&lt;p&gt;在通过javap解析字节码文件中可能不会真正看到&amp;lt;clint&amp;gt;构造器的调用，但实际上在任何一个class文件的常量池中（当然需要定义类成员或者静态代码块）都是可以找到&amp;lt;clint&amp;gt;和&amp;lt;init&amp;gt;的符号引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2、类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同于源代码中，在虚拟机有加载器的存在，此时由加载器实例和类的权限定名共同来唯一确定一个类。&lt;/p&gt;
&lt;p&gt;从是否独立于虚拟机的角度：加载器可分为启动加载器（是虚拟机的一部分）和其他加载器（独立于虚拟机之外）。&lt;/p&gt;
&lt;p&gt;更细的来划分，有三类加载器：&lt;/p&gt;
&lt;p&gt;1）启动类加载器（BootstrapLoader）：是用本地代码实现的类装入器，它负责将 &amp;lt;Java_Runtime_Home&amp;gt;/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。&lt;br/&gt;2）扩展类加载器（ExtClassLoader）：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&amp;lt; Java_Runtime_Home &amp;gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。&lt;br/&gt;3）系统类加载器或者应用类类加载器（AppClassLoader）：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。&lt;/p&gt;
&lt;p&gt;他们之间存在父子关系，从代码的角度来讲，其父子关系是从parent实例属性来体现的。&lt;/p&gt;
&lt;p&gt;在抽象类java.lang.ClassLoader源码中明确定义了一个parent实例属性，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; ClassLoader parent;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Launcher$ExtClassLoader和Launcher$AppClassLoader均继承了URLClassLoader，URLClassLoader又继承了&lt;span class=&quot;typeNameLabel&quot;&gt;SecureClassLoader，而SecureClassLoader是&lt;/span&gt;ClassLoader的直接实现子类。&lt;/p&gt;
&lt;p&gt;从抽象类java.lang.ClassLoader的loadClass(String name, boolean resolve)方法源码可以很容易的窥探到双亲委派模型的运作过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, check if the class has already been loaded&lt;/span&gt;
                Class c =&lt;span&gt; findLoadedClass(name);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {//如果该类未被加载
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {//其父加载器不为BootstrapLoader
                        　　c &lt;/span&gt;= parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    　　} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {//其父加载器为BootstrapLoader
                        　　c &lt;/span&gt;=&lt;span&gt; findBootstrapClass0(name);
                    　　}
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {//父加载均无法加载，才由自己加载
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If still not found, then invoke findClass in order
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to find the class.&lt;/span&gt;
                        c =&lt;span&gt; findClass(name);
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resolve) {
                    resolveClass(c);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; c;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;双亲委派模型的一个直接的好处就是保证了java类型体系中确定的层次关系。更具体的讲，例如Object.class字节码文件存在于&amp;lt;Java_Home&amp;gt;/lib/的rt.jar包中，那么遵循双亲委派的父加载器优先的原则，每次加载Object这个类的都可以确定必是由BootstrapLoader加载，一方面，其他地方的Object.class不会被BootstrapLoader加载到，另一方面，正常情况下另外两个类加载器也没有机会加载这个Object.class，从而保证基础类库加载的状态确定性，保证了在其基础上开发的java程序运行的稳定性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、执行引擎&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1、方法调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：java的编译过程不涉及通常意义下的编译阶段的链接；方法的调用不同于方法的执行，方法调用的目的在于确定某一方法的某个具体版本。&lt;/p&gt;
&lt;p&gt;java虚拟机提供了四条方法调用的指令：&lt;/p&gt;
&lt;p&gt;1、invokestatic：调用静态方法&lt;/p&gt;
&lt;p&gt;2、invokespecial：调用构造器方法&amp;lt;init&amp;gt;，私有方法和父类方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      20: invokespecial #49                 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、invokevirtual：调用所有的虚方法&lt;/p&gt;
&lt;p&gt;4、invokeinterface：调用接口方法，会在运行时在确定一实现此接口的对象。&lt;/p&gt;
&lt;p&gt;能被invokestatic和invokespecial指令调用的方法（类方法、构造器、私有方法和父类方法）以及final修饰的方法都称为非虚方法，其他的方法都成为虚方法。&lt;/p&gt;
&lt;p&gt;非虚方法都能在类加载的解析阶段完成方法的版本确定工作，符号引用也会被解析成直接引用，这个过程的方法调用称为解析调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.2、静态分派和动态分派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析调用一定是一个静态的过程，而分派调用可能是静态的也可能是动态的，还可以从另一个角度分为单分派和多分派。两两可组合形成静态单分派、静态多分派，动态单分派和动态多分派四种情形。&lt;/p&gt;
&lt;p&gt;静态分派调用典型应用就是方法的重载。&lt;/p&gt;
&lt;p&gt;由于java中子类的实例可以复制给父类的变量，因此就有可能存在一个变量的静态类型和实际类型不一致的情况。&lt;/p&gt;
&lt;p&gt;例如（当然这里的前提是Man extends Human）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Human humanA = new Man();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;humanA的静态类型是Human，而实际类型是Man。&lt;/p&gt;
&lt;p&gt;依赖静态类型来确定方法执行版本分派动作称为静态分派。静态分派发生在编译阶段，编译器正是根据参数的静态类型而不是实际类型来确定方法的具体版本，这一点可以通过对查看编译后的字节码的方法调用指令得到验证。&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.demo;
public class&lt;span&gt; TestDispatch {
    static abstract class&lt;span&gt; Human{}
    static class Man extends&lt;span&gt; Human{}
    static class Woman extends&lt;span&gt; Human{}
    public void&lt;span&gt; say(Human huamn){
        System.out.println(&quot;human say&quot;&lt;span&gt;);
    }
    public void&lt;span&gt; say(Man man){
        System.out.println(&quot;man say&quot;&lt;span&gt;);
    }
    public void&lt;span&gt; say(Woman man){
        System.out.println(&quot;woman say&quot;&lt;span&gt;);
    }
    public static void&lt;span&gt; main(String[] args) {
        // TODO Auto-generated method stub
        Human humanA = new&lt;span&gt; Man();
        Human humanB = new&lt;span&gt; Woman(); 
        TestDispatch td = new&lt;span&gt; TestDispatch();
        td.say(humanA);
        td.say(humanB);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;截选如上测试代码的main方法部分的字节码指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public static void&lt;span&gt; main(java.lang.String[]);
  Code:
     0: new           #43                 // class com/demo/TestDispatch$Man
     3&lt;span&gt;: dup
     4: invokespecial #45                 // Method com/demo/TestDispatch$Man.&quot;&amp;lt;init&amp;gt;&quot;:()V
     7&lt;span&gt;: astore_1
     8: new           #46                 // class com/demo/TestDispatch$Woman
    11&lt;span&gt;: dup
    12: invokespecial #48                 // Method com/demo/TestDispatch$Woman.&quot;&amp;lt;init&amp;gt;&quot;:()V
    15&lt;span&gt;: astore_2
    16: new           #1                  // class com/demo/TestDispatch
    19&lt;span&gt;: dup
    20: invokespecial #49                 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
    23&lt;span&gt;: astore_3
    24&lt;span&gt;: aload_3
    25&lt;span&gt;: aload_1
    26: invokevirtual #50                 // Method say:(Lcom/demo/TestDispatch$Human;)V
    29&lt;span&gt;: aload_3
    30&lt;span&gt;: aload_2
    31: invokevirtual #50                 // Method say:(Lcom/demo/TestDispatch$Human;)V
    34: return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，第26行和第31行，invokevirtual指令调用参数都是常量池的第50项常量，注释表明该常量实际上是TestDispatch$Human.say(Human human)的符号引用.&lt;/p&gt;
&lt;p&gt;动态分派则揭示了方法重写（或者覆盖）的本质。&lt;/p&gt;
&lt;p&gt;invokevirtual指令运行时解析过程（多态查找过程）：&lt;/p&gt;
&lt;p&gt;1、找到操作数栈顶的第一个元素指向的对象的实际类型，记作C；&lt;/p&gt;
&lt;p&gt;2、如果类型C中找到与常量中描述符合简单名称相符合的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过结束；不通过则返回java.IllegalAccessError异常；&lt;/p&gt;
&lt;p&gt;3、否则，按照继承关系从下往上依次对C的各个父类进行第2步搜索和验证；&lt;/p&gt;
&lt;p&gt;4、如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。&lt;/p&gt;
&lt;p&gt;Java虚拟机的指令是基于栈的指令，但是某些指令还会带参数（如invokevirtual，invokespecial 等），与基于寄存器的指令集相比，基于栈的指令集更方便移植，但是执行速度稍慢，同时指令数量会更加多一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;语法糖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;java的中常用的语法糖主要是泛型，变长参数，自动拆装箱，循环遍历（foreach）等等。&lt;/p&gt;
&lt;p&gt;因此java的泛型与C#的泛型原理实际上有本质的区别，java的泛型只存在于源代码中，经过编译之后，泛型信息会被擦除，在字节码中被转换成原生类型，ArrayList&amp;lt;Integer&amp;gt;和ArrayList&amp;lt;String&amp;gt;编译后被转换成同一种类型ArrayList，因此java的泛型是语法糖，是一种伪泛型。&lt;/p&gt;
&lt;p&gt;注意：泛型不一定都是语法糖实现，如C#的泛型就是直接有CLR支持的。&lt;/p&gt;
&lt;p&gt;但是泛型擦除也带了一些比较奇怪的现象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test(ArrayList&amp;lt;String&amp;gt;&lt;span&gt; list1){
        System.out.println(&lt;/span&gt;&quot;list1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; test(ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt; list2){
        System.out.println(&lt;/span&gt;&quot;list2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1.0f&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上两个同名的方法可以正常编译和执行。&lt;/p&gt;
&lt;p&gt;关于自动拆、装箱，foreach遍历和可变长参数的语法糖，以下是一个很经典例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSSugar {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:list){
            sum &lt;/span&gt;+=&lt;span&gt; i;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;以上代码等价于如下的基础语法结构的代码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;Integer&amp;gt; list = Arrays.asList(new Integer[]{//可变长参数经过解语法糖，实际上是数组
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Integer.valueOf(1),//自动装箱实际上是调用了valueOf()方法
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Integer.valueOf(2),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Integer.valueOf(3),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Integer.valueOf(4),});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int sum = 0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        for(Iterator localIterator = list.iterator();localIterator.hasNext();){//foreach遍历经过解语法糖实际上是调用Iterator接口
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            int i = (Integer)localIterator.next();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            sum += i;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;        System.out.println(sum);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完结~~~&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 05:27:00 +0000</pubDate>
<dc:creator>Qcer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcblog/p/7704788.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（13）——工具函数包说明（四） - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/7687691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/7687691.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/evn python&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; check_string(text, pattern):
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    检查字符串是否符合指定规则
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    :param pattern: 正式表达式，如：'^[a-zA-Z]+$'
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    :return: 含有指定字符时返回真，否则为假
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;     match =&lt;span&gt; re.search(pattern, text)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; match:
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_email(text):
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    验证字符串是否是email
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    :return: 符合返回True，不符合返回False
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; check_string(text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[^\._-][\w\.-]+@(?:[A-Za-z0-9]+\.)+[A-Za-z]+$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_phone(text):
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    验证字符串是否是固定电话
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    :return: 符合返回True，不符合返回False
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; check_string(text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\(?0\d{2,3}[) -]?\d{7,8}$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_mobile(text):
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    验证字符串是否是手机号码
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    :return: 符合返回True，不符合返回False
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; check_string(text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^1[3578]\d{9}$|^147\d{8}$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_letters(text):
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    验证字符串是否全是字母
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    :return: 符合返回True，不符合返回False
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; check_string(text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^[a-zA-Z]+$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_idcard(text):
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    验证字符串是否是身份证号码
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    :param text: 需要检查的字符串
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    :return: 格式正确返回True，错误返回False
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;     ic =&lt;span&gt; IdentityCard()
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ic.check(text.upper())
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; filter_str(text, filter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\||&amp;lt;|&amp;gt;|&amp;amp;|%|~|\^|;|\'&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    滤掉字符串
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    :param text: 需要过滤的字符串
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    :param filter: 过滤内容（正则表达式）
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    :return: 去除特殊字符后的字符串
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; text:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; re.subn(filter, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, text)[0]
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; filter_tags(htmlstr):
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    过滤HTML中的标签
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    :param htmlstr: 要过滤的内容
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;     re_cdata=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//&amp;lt;!\[CDATA\[[^&amp;gt;]*//\]\]&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,re.I) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;匹配CDATA&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     re_script=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;\s*script[^&amp;gt;]*&amp;gt;[^&amp;lt;]*&amp;lt;\s*/\s*script\s*&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,re.I)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Script&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     re_style=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;\s*style[^&amp;gt;]*&amp;gt;[^&amp;lt;]*&amp;lt;\s*/\s*style\s*&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,re.I)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     re_br=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br\s*?/?&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;处理换行&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     re_h=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/?\w+[^&amp;gt;]*&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;HTML标签&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     re_comment=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;!--[^&amp;gt;]*--&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;HTML注释&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;     s=re_cdata.sub(&lt;span&gt;''&lt;/span&gt;,htmlstr)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉CDATA&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;     s=re_script.sub(&lt;span&gt;''&lt;/span&gt;,s) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉SCRIPT&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;     s=re_style.sub(&lt;span&gt;''&lt;/span&gt;,s)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉style&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     s=re_br.sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,s)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将br转换为换行&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     s=re_h.sub(&lt;span&gt;''&lt;/span&gt;,s) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉HTML 标签&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;     s=re_comment.sub(&lt;span&gt;''&lt;/span&gt;,s)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉HTML注释&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去掉多余的空行&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;     blank_line=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     s=blank_line.sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,s)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     s=replaceCharEntity(s)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;替换实体&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; replaceCharEntity(htmlstr):
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    替换常用HTML字符
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    :param htmlstr: 要替换的字符
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;     CHAR_ENTITIES={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nbsp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     re_charEntity=re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#?(?P&amp;lt;name&amp;gt;\w+);&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     sz=&lt;span&gt;re_charEntity.search(htmlstr)
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; sz:
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         entity=sz.group()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;entity全称，如&amp;amp;gt;&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;         key=sz.group(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去除&amp;amp;;后entity,如&amp;amp;gt;为gt&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             htmlstr=re_charEntity.sub(CHAR_ENTITIES[key],htmlstr,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             sz=&lt;span&gt;re_charEntity.search(htmlstr)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyError:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以空串代替&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;             htmlstr=re_charEntity.sub(&lt;span&gt;''&lt;/span&gt;,htmlstr,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             sz=&lt;span&gt;re_charEntity.search(htmlstr)
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; htmlstr
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; string(text, is_return_null=&lt;span&gt;False):
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;    sql字符串拼接专用函数
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;    会在字符串两边添加'单撇号，用于生成数据库sql语句
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    :param text: 需要添加'的字符串
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;    :param is_return_null: 是否返回null，是的话在字符串为空时返回null，否则返回''
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; text &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; text != &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(text) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; is_return_null:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; cut_str(text, length):
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;    将字符串截取指定长度
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    :param text: 需要进行截取的字符串
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    :param length: 字符串保留的长度
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; text &lt;span&gt;or&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; isinstance(text, str):
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     tem = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         tem = text.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; tem &lt;span&gt;or&lt;/span&gt; tem == &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             tem =&lt;span&gt; text[0:length]
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             tem =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tem[0:length]
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IdentityCard:
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;身份证号码验证类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         self.&lt;span&gt;__Wi&lt;/span&gt; = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         self.&lt;span&gt;__Ti&lt;/span&gt; = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calculate(self, code):
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;计算校验位&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;         sum =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(17&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             sum += int(code[i]) * self.&lt;span&gt;__Wi&lt;/span&gt;&lt;span&gt;[i]
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__Ti&lt;/span&gt;[sum % 11&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; check(self, code):
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;检查输入的号码是否正确&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (len(code) != 18&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.calculate(code) != code[17&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;</description>
<pubDate>Thu, 26 Oct 2017 05:07:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/7687691.html</dc:identifier>
</item>
<item>
<title>三个月教你从零入门深度学习 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/7735611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/7735611.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;不用理会标题，纯粹标题党，但是有干货！昨天看到某位&quot;大牛&quot;写了篇文章，上了首页推荐，叫做&quot;&lt;a href=&quot;http://www.cnblogs.com/legendxian/&quot; target=&quot;_blank&quot;&gt;跟着弦哥学人工智能&lt;/a&gt;&quot;，看到标题还挺惊喜，毕竟在博客园这个以.net文章为主的技术论坛居然还有大佬愿意写AI方面的文章，于是点击去仔细看了看，发现文风浮夸，恩，没关系，有干货就行，结果翻到最后也没发现啥干货，看到了参考书目，挺有意思的。放个图在这：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201710/853467-20171026103759348-1385507103.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　当时看到这个参考书目挺迷的，数学类从高中数学推荐到数学专业学生看的数学分析，计算机算法类一上来就推荐大块头的《算法导论》和理论性偏强的《数据挖掘：概念与技术》，认为这样入门的人来说并不合适。看书应当是有阶梯型的，不能一口吃成个大胖子，基于不想&quot;大牛&quot;误人子弟，于是我给出了如下建议：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201710/853467-20171026104501629-1506012886.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;132&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我的回复很平和，也给出了一些对新手比较友好的建议，并且有6个人支持我，想想算了，然而，今天，在首页中又看到了这位&quot;大牛&quot;在博文骂我是喷子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201710/853467-20171026105147488-1343303777.png&quot; alt=&quot;&quot; width=&quot;745&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这我就不赞同而且不能忍了。对于任何人，不管你是大牛还是小白，我的原则都是，你可以反驳我的建议，有理有据就行，如果我错了，那就改，没有错，那就互相讨论，交流一下，气场合说不定还能成为个朋友呢。但是对于别人真诚的建议您回以&quot;喷子&quot;是一个有教养的人的表现吗？仗着自己是&quot;大牛&quot;,这样没有素质的怼不觉得脸红吗？并且，我之所以给出这个建议，有&lt;strong&gt;&lt;span&gt;以下三点&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　1.&lt;span&gt;作为一个数学系的学生，学了四年数学，对于你胡乱给的参考书目非常的不赞同&lt;/span&gt;。一没有阶梯式，对新手不友好，您的标题和写这个系列的目的大概都是准备给小白看的，那么请问，一个小白需要看数学分析原理？？学习人工智能有必要需要看普林斯顿微积分原理？？以鄙人浅薄的认识来说，数学分析与高等数学最大的区别是同一个定理，高数只要求会用即可，数学分析本着严谨性，一定会给出证明。然而对于大多数人工智能里所需要的数学，您在工作中需要证明这个定理的正确性和完备性？？等你证出来恐怕项目早就结了。您回复我说这只是参考书目不是推荐书目，但是下面的评论大多数是看到书单就决定放弃。您把这些书放出来，就对看您文章的人有一定的引导性，我认为您这是在误人子弟。二是我通过您参考的数目粗略的推导您自己可能都没有对整个人工智能的数学有个框架式的梳理，不然不会有如此不负责任的推荐。但是出于对您的尊重，我并没有质疑您的能力，仅仅在评论里对于新手适合的数学书目给了一个简短的推荐。&lt;/p&gt;
&lt;p&gt;　　2.&lt;span&gt;作为一个从事机器学习这一行两年多的程序媛，看到您推荐的计算机系列也认为非常的不靠谱&lt;/span&gt;。您推荐的这些书，我大部分都看过。尤其不推荐新手看的就是《算法导论》和《数据挖掘：概念与技术》，这两本书又厚又重，虽然内容全面讲的也不错，但是等你看完都不知道猴年马月了。新手需要的是什么？是上手！其次，《Python核心编程》您真的看完了吗？这本书并不是给Python新人读的，非常厚，而且有一定的难度，对于新手非常不友好。而且如果只是想做AI，那这本书的很多地方都不需要用到，web开发，Django框架对于我们AI工程师来说真的是必须的吗？不是。小白对于一本书没有重点和非重点的区分，花了大量的时间学了不需要的只是，真是得不偿失。给出引导性，针对性的推荐才是负责任的推荐。&lt;/p&gt;
&lt;p&gt;　　3.&lt;span&gt;对于深度学习方面书籍的推荐我就不吐槽了。槽点太多，无力吐槽&lt;/span&gt;。省点力气后面推荐真正适合不同阶段的新手阅读的书籍好了。&lt;/p&gt;
&lt;p&gt;　　总结：&lt;span&gt;这位大牛，我认为您可能在.net方面积累非常深，做的很好，吸引了一大波粉丝，这点我很佩服您&lt;/span&gt;。然而对于深度学习这一块您可能并不是很了解。&lt;span&gt;对于一个您并不是很了解的领域，在这里毫不谦虚，对于别人的建议充耳不闻，还很得意的骂人“喷子”，恐怕您还是要多谦虚一点，多学习学习&lt;/span&gt;。从从业年龄来看，我是您的后辈，但从从事深度学习这个领域来看，您可能还是个新人，您说呢?并且到目前为止，您发了两篇文章在首页，都没有任何干货，希望您赶紧拿干货来打我的脸^_^&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;下面，开始输出干货。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AI处于目前的风口，于是很多人想要浑水摸鱼，都来分一杯羹，然而可能很多人连AI是什么都不知道。AI，深度学习，机器学习，数据挖掘，数据分析这几点的联系和区别也搞不清楚。于是滋生了很多培训班，收着不菲的费用，教教demo，调调参，教你一个月速成深度学习工程师，赚的盆满钵满。这种行业风气我们应该摒弃！我认为，&lt;span&gt;&lt;strong&gt;目前市面上的任何AI培训都不值得参加&lt;/strong&gt;&lt;/span&gt;！别撒钱给别人了，难道不会心痛吗？ - -然而，当大家自学的时候，又不知道从何学起。下了一堆资料，跑了一堆demo，报了一堆cousera，调调参，看看模型结果不错，就以为入了门，抱歉，不好意思，我说话比较直接，可能你连门都没入。我认为，深度学习这块，有几个层次：（自己胡乱起的名字，忽略吧  - -）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;demo侠---&amp;gt;调参侠---&amp;gt;懂原理侠---&amp;gt;懂原理+能改模型细节侠---&amp;gt;超大数据操控侠---&amp;gt;模型/框架架构师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;      &lt;span&gt;&lt;strong&gt;&lt;span&gt;demo侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：下载了目前所有流行的框架，对不同框里的例子都跑一跑，看看结果，觉得不错就行了，进而觉得，嘛，深度学习也不过如此嘛，没有多难啊。这种人，我在面试的时候遇到了不少，很多学生或者刚转行的上来就是讲一个demo，手写数字识别，cifar10数据的图像分类等等，然而你问他这个手写数字识别的具体过程如何实现的？现在效果是不是目前做好的，可以再优化一下吗？为什么激活函数要选这个，可以选别的吗？CNN的原理能简单讲讲吗？懵逼了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;调参侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：此类人可能不局限于跑了几个demo，对于模型里的参数也做了一些调整，不管调的好不好，先试了再说，每个都试一下，学习率调大了准确率下降了，那就调小一点，那个参数不知道啥意思，随便改一下值测一下准确率吧。这是大多数初级深度学习工程师的现状。当然，并不是这样不好，对于demo侠来说，已经进步了不少了，起码有思考。然而如果你问，你调整的这个参数为什么会对模型的准确率带来这些影响，这个参数调大调小对结果又会有哪些影响，就又是一问三不知了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;懂原理侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：抱歉我起了个这么蠢的名字。但是，进阶到这一步，已经可以算是入门了，可以找一份能养活自己的工作了。CNN，RNN，LSTM信手拈来，原理讲的溜的飞起，对于不同的参数对模型的影响也是说的有理有据，然而，如果你要问，你可以手动写一个CNN吗？不用调包，实现一个最基础的网络结构即可，又gg了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;懂原理+能改模型细节侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：如果你到了这一步，恭喜你，入门了。对于任何一个做机器学习/深度学习的人来说，只懂原理是远远不够的，因为公司不是招你来做研究员的，来了就要干活，干活就要落地。既然要落地，那就对于每一个你熟悉的，常见的模型能够自己手动写代码运行出来，这样对于公司的一些业务，可以对模型进行适当的调整和改动，来适应不同的业务场景。这也是大多数一二线公司的工程师们的现状。然而，对于模型的整体架构能力，超大数据的分布式运行能力，方案设计可能还有所欠缺，本人也一直在这个阶段不停努力，希望能够更进一步。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;超大数据操控侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：到这一阶段，基本上开始考虑超大数据的分布式运行方案，对整体架构有一个宏观的了解，对不同的框架也能指点一二。海量数据的分布式运行如何避免网络通信的延迟，如何更高效更迅速的训练都有一定经验。这类人，一般就是我这种虾米的领导了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;模型/框架架构师&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：前面说了一堆都是对现有的框架/模型处理的经验，这个阶段的大侠，哦，不对，是大师可以独立设计开发一套新框架/算法来应对现有的业务场景，或者解决一直未解决的历史遗留问题。没啥好说了，膜拜！&lt;/p&gt;
&lt;p&gt;　　说了这么多，希望大家对自己找个清洗准确的定位，这样才能针对性的学习。下面基于我个人的经验对不同阶段的学习者做一些推荐：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;demo侠+调参侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：这两个放在一起说，毕竟五十步笑百步，谁也没有比谁强多少。当然也不要妄自菲薄，大家都是从这个阶段过来的。这个阶段编程不好的就好好练编程，原理不懂的就好好看书理解原理。动手做是第一位，然后不断改一些模型的参数，看效果变化，再看背后的数学推导，理解原因，这样比先看一大堆数学公式的推导，把自己绕的晕晕乎乎在开始写代码要好得多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;　&lt;strong&gt;&lt;span&gt;　推荐书目&lt;/span&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　数学类&lt;/span&gt;：
&lt;ul&gt;&lt;li&gt;高等数学（同济第七版）：没错我说的就是考研的那本参考书，真心不错，难易适中，配合相应的视频或者国外的一些基础课程的视频看，高数理解极限，导数，微分，积分就差不多了&lt;/li&gt;
&lt;li&gt;高等数学（北大第三版）：线性代数的书我看的不多，原来上学的时候学的是高等数学，不过不要紧，看前五章就行了。配合相应的视频，掌握矩阵，行列式相关知识即可。&lt;/li&gt;
&lt;li&gt;概率论：这个没有特别推荐的，因为学的并是不很好，所以不做推荐误人子弟。大家不管看什么书，只要掌握关键知识就行了。不能到时候问个贝叶斯你都不知道咋推吧 = =！&lt;/li&gt;
&lt;li&gt;信息论：忘记是哪个出版社了的，很薄的一本，讲的非常不错。里面关于信息的度量，熵的理解，马尔科夫过程都讲的不错（现在公司里没有，我回去找找再补上来）。掌握这个只是，那么对于你理解交叉熵，相对熵这一大堆名字看起来差不多但是又容易弄混的东东还是不错的。起码你知道了为啥很多机器学习算法喜欢用交叉熵来做cost function~&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编程类&lt;/span&gt;：
&lt;ul&gt;&lt;li&gt;笨方法学Python（Learn Python the Hard Way）这本书对于完全没有接触过Python，或者说完全没有接触过编程的人来说非常适合。虽然很多人说Python这么简单，一天/周/月就学会了，但是每个人的基础是不一样的，所以不要认为自己一天没学会就很认为自己很蠢，你应该想这样说的人很坏！不管怎么样，这是一本真正的从零开始学Python的书&lt;/li&gt;
&lt;li&gt;利用Python进行数据分析：这本书是Python的pandas这个包的详细说明版。学习这个可以掌握一些pandas的基本命令。然而这不是重点，因为pandas出来大量数据实在太慢了，还可能会崩溃（不知道现在有没有改善 - -！）重点是，通过学习这本书，对数据的操作有点感觉，熟悉基本的数据操作流程，里面所有的操作都可以用原生python来替代，不需要用到pandas这个包。找感觉，非常重要。&lt;/li&gt;
&lt;li&gt;Python参考手册：这本书只是作为一个工具书，当你遇到不会的时候翻翻书，巩固一下（当然，事实可能是直接去google了），此类书不用全部从头到尾刷完，查漏补缺即可（电子书就行）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法类&lt;/span&gt;：
&lt;ul&gt;&lt;li&gt;Deep Learning with Python：别看这又是一本英文书，但其实非常简单易读。我之前在工作一年的时候写了篇总结（&lt;a href=&quot;http://www.cnblogs.com/charlotte77/p/5381681.html&quot; target=&quot;_blank&quot;&gt;【原】数据分析/数据挖掘/机器学习必读书目&lt;/a&gt;），也推荐了这本书。这本书其实主要是一个demo例子的集合，用keras写的，没有什么深度，主要是消除你对深度学习的畏难情绪，可以开始上手做，对整体能够做的事做一些宏观的展现。可以说，这本书是demo侠的最爱啦！&lt;/li&gt;
&lt;li&gt;Deep Learning：中文有翻译版的出来了，不过我其实不太想放在这里，因为这本书其实很偏理论。有些章节讲的是真不错，有些地方你完了又会觉得，这是啥？这玩意有啥用？会把新手绕来绕去的。大家就先买一本镇场子，有不懂的翻翻看，看不懂的就google，直接看论文，看别人总结的不错的博客，等等。总之只要你能把不懂的弄懂就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;懂原理侠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：很不错，你的经验值已经提升了不少了。然而还不能开始打怪，毕竟没有那个怪物可以直接被喷死的。你缺少工具。那么这个阶段，就需要多多加强编程能力。先找一个框架下下来，阅读源码，什么？你说你不会阅读源码，没关系，网上一大堆阅读源码的经验。当然，这些经验的基础无一例外都是：多读多写。在此基础上再找trick。下好框架的源码后，改动一些代码在运行，debug一下，再不断的找原因，看看每个api是怎么写的，自己试着写一写。多谢多练，死磕coding三十年，你一定会有收获的。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;懂原理+能改模型细节侠&lt;/span&gt;：&lt;/strong&gt;&lt;span&gt;看论文看论文看论文！读源码读源码读源码！这里的读源码不仅仅局限于读一个框架的源码了，可以多看看其他优秀的框架，对于同一个层，同一个功能的实现机制，多比较多思考多总结多写。时间长了，肯定会有收获的。看论文是为了直接获得原作者的思想，避免了从博客解读论文里获得二手思想，毕竟每个人的理解都不一样，而且也不一定对，自己先看一遍，再看看别的理解，多和大牛讨论，思路就开阔了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;超大数据操控侠&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;这个阶段我也还在摸索，给不了太多建议，只能给出目前总结的一点点经验：尽量扩大数据，看如何更快更好的处理。更快--采用分布式机制应该如何训练？模型并行还是数据并行？多机多卡之间如何减少机器之间的网络延迟和IO时间等等都是要思考的问题。更好--如何保证在提升速度的同时尽量减少精度的损失？如何改动可以提高模型的准确率、mAP等，也都是值得思考的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;模型/框架架构师&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：抱歉，我不懂，不写了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　其实大家从我上面的推荐来看，打好基础是非常重要的，后续都是不断的多读优秀的论文/框架，多比较/实践和debug，就能一点点进步。打基础的阶段一定不能浮躁。扎扎实实把基础打好，后面会少走很多弯路。不要跟风盲目崇拜，经典永远不会过时，自己多看书/视频/优秀的博客，比无脑跟风要强得多。最后，我之所以今天这么生气，是因为这个行业目前太浮躁了，很多人太浮夸，误人子弟，有人说真话还被人骂喷子，真是气死我了！大家一定要擦亮双眼，多靠自己多努力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　不好意思强行鸡汤了一波。本来去年打算写一个机器学习系列，但是因为工作和身体的原因写了三篇就没有更了。今年上半年做了一个大项目又累得要死，下半年才刚刚缓口气，所以之前欠的后续一定会继续更。为了不让大家盲目崇拜，&lt;strong&gt;&lt;span&gt;我决定写一个深度学习系列，每周固定一篇，大概三个月完结。教小白如何入门&lt;/span&gt;&lt;span&gt;。&lt;span&gt;并且完！全！免！费！不用关注任何公众号！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;不是简单的写写网上都有的demo和调参。拒绝demo侠从我做起！有不懂的欢迎大家在我的文章下留言，我看到了会尽量回复的。这个系列主要会采取PaddlaPaddle这个深度学习框架，同时会对比keras，tensorflow和mxnet这三个框架的优劣（因为我只用过这四个，写tensorflow的人太多了，paddlepaddle我目前用的还不错，就决定从这个入手），所有代码会放在&lt;span&gt;&lt;a href=&quot;https://github.com/huxiaoman7/PaddlePaddle_code&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;github&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;上（链接：https://github.com/huxiaoman7/PaddlePaddle_code），欢迎大家提issue和star。目前只写了第一篇（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/charlotte77/p/7712856.html&quot;&gt;【深度学习系列】PaddlePaddle之手写数字识别&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;），后面会有更深入的讲解和代码。目前做了个简单的大纲，大家如果有感兴趣的方向可以给我留言，我会参考加进去的~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201710/853467-20171026130127269-2006674515.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;316&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　最后一句，低调做人，好好学习，大家下期再会^_^!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 05:07:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/7735611.html</dc:identifier>
</item>
</channel>
</rss>