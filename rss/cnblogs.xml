<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>struts2流程及源码分析 - Autom_liu</title>
<link>http://www.cnblogs.com/autom/p/10010214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/autom/p/10010214.html</guid>
<description>&lt;h2 id=&quot;struts-架构图&quot;&gt;struts 架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21289/WEBRESOURCEece083a85543cc5f31bb90d300082fb4&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析这个架构图，我们可以从4个部分，也就struts访问的4个阶段的流程来分析&lt;/p&gt;
&lt;p&gt;这4个阶段包括：Action映射、Action转发、Action执行、结果返回&lt;/p&gt;
&lt;p&gt;首先是Action映射阶段&lt;/p&gt;
&lt;p&gt;当请求到来的时候，首先是struts的核心过滤器接收到请求，然后通过ActionMapper进行映射&lt;/p&gt;
&lt;p&gt;我们以下图struts配置为例，查看一下struts在处理这个请求阶段的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21339/WEBRESOURCEe9f401582aab142a0d693be0141bf121&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;StrutsPrepareAndExecuteFilter&lt;/code&gt;源码中，它本质是一个过滤器，核心的代码在&lt;code&gt;doFilter&lt;/code&gt;部分，我们把这部分代码copy过来如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        try {
            if (excludedPatterns != null &amp;amp;&amp;amp; prepare.isUrlExcluded(request, excludedPatterns)) {
                chain.doFilter(request, response);
            } else {
                prepare.setEncodingAndLocale(request, response);
                prepare.createActionContext(request, response);
                prepare.assignDispatcherToThread();
                request = prepare.wrapRequest(request);
                ActionMapping mapping = prepare.findActionMapping(request, response, true);
                if (mapping == null) {
                    boolean handled = execute.executeStaticResourceRequest(request, response);
                    if (!handled) {
                        chain.doFilter(request, response);
                    }
                } else {
                    execute.executeAction(request, response, mapping);
                }
            }
        } finally {
            prepare.cleanupRequest(request);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断是否需要struts处理&quot;&gt;判断是否需要struts处理&lt;/h3&gt;
&lt;p&gt;当请求过来的时候，首先判断是否应该由struts处理这个请求，如果不是那就应该放行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21350/WEBRESOURCE6a01c478e0836d255ea9c6c77c713a99&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这个请求肯定是要经过struts处理的，所以应该走else部分：&lt;/p&gt;
&lt;h3 id=&quot;创建数据中心actioncontext&quot;&gt;创建数据中心ActionContext&lt;/h3&gt;
&lt;p&gt;接下来需要关注的是这行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;prepare.createActionContext(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是干什么呢？从名字上看，就是在创建一个ActionContext数据中心&lt;/p&gt;
&lt;p&gt;还记得吗？这个就是那个包含原生servlet 11个域对象还有值栈的一个大容器（本质上就是map）&lt;/p&gt;
&lt;p&gt;可以进去看下这部分的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Creates the action context and initializes the thread local
 */
public ActionContext createActionContext(HttpServletRequest request, HttpServletResponse response) {
    ActionContext ctx;
    Integer counter = 1;
    Integer oldCounter = (Integer) request.getAttribute(CLEANUP_RECURSION_COUNTER);
    if (oldCounter != null) {
        counter = oldCounter + 1;
    }
    
    ActionContext oldContext = ActionContext.getContext();
    if (oldContext != null) {
        // detected existing context, so we are probably in a forward
        ctx = new ActionContext(new HashMap&amp;lt;String, Object&amp;gt;(oldContext.getContextMap()));
    } else {
        ValueStack stack = dispatcher.getContainer().getInstance(ValueStackFactory.class).createValueStack();
        stack.getContext().putAll(dispatcher.createContextMap(request, response, null));
        ctx = new ActionContext(stack.getContext());
    }
    request.setAttribute(CLEANUP_RECURSION_COUNTER, counter);
    ActionContext.setContext(ctx);
    return ctx;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化阶段，关键在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21365/WEBRESOURCEf167d35cd9aff9f0547c672989b82e36&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三行代码，简单来看，第一步就是创建值栈，第二步就是往Context中准备一些数据&lt;/p&gt;
&lt;p&gt;最后看第三步，可以看到ActionContext这个数据中心实际上就是ValueStack的Context&lt;/p&gt;
&lt;h3 id=&quot;增强包装request对象&quot;&gt;增强包装request对象&lt;/h3&gt;
&lt;p&gt;接下来关注的是91行的这句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21375/WEBRESOURCE65a04b50a30a15efdc40a4223053c3f5&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在还没运行阶段，这个request还是原生的&lt;code&gt;org.apache.catalina.connector.RequestFacade&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21377/WEBRESOURCE145c1e6b20f936ed0d5c205094d441d3&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完后就变成了&lt;code&gt;org.apache.struts2.dispatcher.StrutsRequestWrapper&lt;/code&gt;类型了，这个就是由struts包装的request对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21382/WEBRESOURCEd5715734693e3ca84fe4d03fb41b3670&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那struts包装是做了哪些事情呢，可以勘测一下&lt;code&gt;StrutsRequestWrapper&lt;/code&gt;源码&lt;/p&gt;
&lt;p&gt;其实它就包装（增强）了一个方法&lt;code&gt;getAttribute&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看下这部分的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Gets the object, looking in the value stack if not found
 *
 * @param key The attribute key
 */
public Object getAttribute(String key) {
    if (key == null) {
        throw new NullPointerException(&quot;You must specify a key value&quot;);
    }

    if (disableRequestAttributeValueStackLookup || key.startsWith(&quot;javax.servlet&quot;)) {
        // don't bother with the standard javax.servlet attributes, we can short-circuit this
        // see WW-953 and the forums post linked in that issue for more info
        return super.getAttribute(key);
    }

    ActionContext ctx = ActionContext.getContext();
    Object attribute = super.getAttribute(key);

    if (ctx != null &amp;amp;&amp;amp; attribute == null) {
        boolean alreadyIn = isTrue((Boolean) ctx.get(REQUEST_WRAPPER_GET_ATTRIBUTE));

        // note: we don't let # come through or else a request for
        // #attr.foo or #request.foo could cause an endless loop
        if (!alreadyIn &amp;amp;&amp;amp; !key.contains(&quot;#&quot;)) {
            try {
                // If not found, then try the ValueStack
                ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.TRUE);
                ValueStack stack = ctx.getValueStack();
                if (stack != null) {
                    attribute = stack.findValue(key);
                }
            } finally {
                ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.FALSE);
            }
        }
    }
    return attribute;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容很长，但简单来说就是注释上的那么一句话：&lt;/p&gt;
&lt;p&gt;Gets the object, looking in the value stack if not found&lt;/p&gt;
&lt;p&gt;翻译过来那就是：这个方法会先从原生request域中去找，如果找不到的话，就会往值栈中去找&lt;/p&gt;
&lt;p&gt;前面说过ValueStack包含两个部分，一个是ROOT栈部分，一个是context部分（从源码上来看，这个部分就是ActionContext）。&lt;/p&gt;
&lt;p&gt;那么拆解开来看，我们可以得到以下结论：&lt;/p&gt;
&lt;p&gt;当我们在struts中调用原生的request.getAttribute()方法时：struts会帮我们从以下几个域中依次寻找属性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原生request域&lt;/li&gt;
&lt;li&gt;ValueStack的栈部分&lt;/li&gt;
&lt;li&gt;ValueStack的context部分（ActionContext）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看一下源码当中这个过程的体现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21410/WEBRESOURCEd327d5fdaedbc5a352c5e0dd35c607dd&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显这一步就是从request域中去找，如果找不到就往下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21413/WEBRESOURCE957bb7b280144c435d82d854edcdfdd0&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的那段注释告诉我们，使用request来寻找ActionContext内容是不需要和OGNL表达式一样带#来访问的，并且也不允许（否则会陷入死循环）&lt;/p&gt;
&lt;p&gt;简单来说，原生的怎么写就怎么写，不需要管里边的具体实现&lt;/p&gt;
&lt;h3 id=&quot;actionmapping&quot;&gt;ActionMapping&lt;/h3&gt;
&lt;p&gt;最后它要做的操作就是把请求转换为ActionMapping对象，好方便接下来后期处理，&lt;/p&gt;
&lt;p&gt;这个过程简单来说就是把我们访问的url地址&lt;/p&gt;
&lt;p&gt;http://localhost/strutsLearn/customer/list&lt;/p&gt;
&lt;p&gt;解析成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActionMapping{name='list', namespace='/customer', method='null', extension='null', params=null, result=null}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式的对象&lt;/p&gt;
&lt;p&gt;上面的形式是可以解析出来的情况，但是我们知道每一次请求也肯定有很多静态资源文件，这些都是struts解析不了的，这时候mapping得到的结果就为&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21433/WEBRESOURCE3b3a46d7a807637536b73d73444351eb&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，也就是我们第一阶段所要完成的任务了，就是通过ActionMapper工具获取ActionMapping对象。&lt;/p&gt;
&lt;p&gt;那么再往下，就是把ActionMapping交给下一个阶段往下执行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;execute.executeAction(request, response, mapping);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;核心代理转发阶段创建actionproxy&quot;&gt;核心代理转发阶段——创建ActionProxy&lt;/h3&gt;
&lt;p&gt;这个方法只是一个中间方法，它再具体调用下一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dispatcher.serviceAction(request, response, mapping);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，关键部分是try catch语句中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    UtilTimerStack.push(timerKey);
    String namespace = mapping.getNamespace();
    String name = mapping.getName();
    String method = mapping.getMethod();

    ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
            namespace, name, method, extraContext, true, false);

    request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());

    // if the ActionMapping says to go straight to a result, do it!
    if (mapping.getResult() != null) {
        Result result = mapping.getResult();
        result.execute(proxy.getInvocation());
    } else {
        proxy.execute();
    }

    // If there was a previous value stack then set it back onto the request
    if (!nullStack) {
        request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);
    }
} catch (ConfigurationException e) {
    logConfigurationException(request, e);
    sendError(request, response, HttpServletResponse.SC_NOT_FOUND, e);
} catch (Exception e) {
    if (handleException || devMode) {
        sendError(request, response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e);
    } else {
        throw new ServletException(e);
    }
} finally {
    UtilTimerStack.pop(timerKey);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是提取ActionMapping中的各种信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21447/WEBRESOURCEf86c2fe8559090941121bd0c3d293a45&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是创建ActionProxy对象了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(
namespace, name, method, extraContext, true, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里如果深入去看proxy创建过程，其实就包含了根据actionMapping的信息去寻找配置文件struts.xml配置项的过程。这里就不再展开了。&lt;/p&gt;
&lt;p&gt;可以看下ActionProxy大概长啥样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21454/WEBRESOURCE9b7ba7d0b40cd1449f9657674ae2bd02&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么创建出来后就需要分派给人去执行了，但是执行分两种情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21458/WEBRESOURCEaf828ec35310a68bd247402f939cd2d7&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种其实都一样，我们这里是第一次初始访问，没有结果返回，因此直接进入的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy.execute();&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String execute() throws Exception {
    ActionContext previous = ActionContext.getContext();
    ActionContext.setContext(invocation.getInvocationContext());
    try {
// This is for the new API:
//            return RequestContextImpl.callInContext(invocation, new Callable&amp;lt;String&amp;gt;() {
//                public String call() throws Exception {
//                    return invocation.invoke();
//                }
//            });

        return invocation.invoke();
    } finally {
        if (cleanupContext)
            ActionContext.setContext(previous);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里，即将进入的就是 invoke 方法了！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;return invocation.invoke();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action执行阶段拦截器执行&quot;&gt;Action执行阶段——拦截器执行&lt;/h3&gt;
&lt;p&gt;调用这个方法，也就意味着进入第三阶段——Aciton执行阶段了&lt;/p&gt;
&lt;p&gt;在这个阶段，我们知道它即将进入执行N多个拦截器，我们进入看看它里面的关键代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (interceptors.hasNext()) {
    final InterceptorMapping interceptor = interceptors.next();
    String interceptorMsg = &quot;interceptor: &quot; + interceptor.getName();
    UtilTimerStack.push(interceptorMsg);
    try {
        resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);
    }
    finally {
        UtilTimerStack.pop(interceptorMsg);
    }
} else {
    resultCode = invokeActionOnly();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中interceptors被定义成拦截器容器的迭代器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected Iterator&amp;lt;InterceptorMapping&amp;gt; interceptors;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个拦截器容器就是Proxy阶段传过来的&lt;/p&gt;
&lt;p&gt;这其中一行代码第一眼看上去确实让人奇怪：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (interceptors.hasNext())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常对迭代器的循环应该是while这里为什么变成if 呢&lt;/p&gt;
&lt;p&gt;先不管，继续往下看：&lt;/p&gt;
&lt;p&gt;首先是获取拦截器容器中的拦截器和拦截器名称：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final InterceptorMapping interceptor = interceptors.next();
String interceptorMsg = &quot;interceptor: &quot; + interceptor.getName();
UtilTimerStack.push(interceptorMsg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个拦截器的类型是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21497/WEBRESOURCEa782d0aff0f61f2e434eff718325bf7f&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Exception拦截器&lt;/p&gt;
&lt;p&gt;和struts-default配置拦截器栈的第一个拦截器是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21501/WEBRESOURCE9424f1c6a4107f9cd83efcb121572855&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，看似真的是要遍历&lt;/p&gt;
&lt;p&gt;接下来断定肯定去执行这个拦截器里的内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取到具体的拦截器，调用拦截器的intercept方法，注意到的是这里把this作为参数穿进去了。&lt;/p&gt;
&lt;p&gt;我们看看这里面做了什么&lt;/p&gt;
&lt;p&gt;结果一进来就做了这么一件事情：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;result = invocation.invoke();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候就得出结论了：&lt;/p&gt;
&lt;p&gt;invocation的invoke方法调用interceptor的intercept方法&lt;br/&gt;接着反过来interceptor的intercept方法又调回invocation的invoke方法&lt;/p&gt;
&lt;p&gt;这不就形成了另一种形式的递归吗？&lt;/p&gt;
&lt;p&gt;所以接下来又回到invocation的invoke方法执行&lt;/p&gt;
&lt;p&gt;那个迭代器的结束条件if&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (interceptors.hasNext())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就没什么奇怪了。&lt;/p&gt;
&lt;p&gt;但是为什么要这么设计递归了，普通的遍历不是挺好的吗？接着往下看。&lt;/p&gt;
&lt;p&gt;执行完一轮后，再看拦截器的名字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21516/WEBRESOURCE5a3ff81b97bb828d621384fcb05072df&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是Exception的下一个拦截器alias&lt;/p&gt;
&lt;p&gt;这个拦截器的invoke方法进行了比较多的复杂处理，但是不管结果如何，最终都会调用：&lt;/p&gt;
&lt;p&gt;return invocation.invoke();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override public String intercept(ActionInvocation invocation) throws Exception {
    ....... 此处省略n行代码
    return invocation.invoke();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，这下明白了这么设计的用意何在了吧。&lt;/p&gt;
&lt;p&gt;每个拦截器的invoke方法执行的方式不一样，通过这种间接递归的方式就能把所有不同功能的器件全部执行一遍了。&lt;/p&gt;
&lt;p&gt;看完后，不得不说，这种设计的精妙之处啊&lt;/p&gt;
&lt;h3 id=&quot;action执行&quot;&gt;Action执行&lt;/h3&gt;
&lt;p&gt;拦截器执行完成后接下来就到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resultCode = invokeActionOnly();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只执行Action了&lt;/p&gt;
&lt;p&gt;接下来可以推测，它就是去找到我们自己写的Action中的类去执行去了。&lt;/p&gt;
&lt;p&gt;跳出这个过程，我们可以看到resultCode返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/21538/WEBRESOURCEda6bd6a8fddb6db6ba693c3b43e052a6&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么可以猜想，接下来就会拿着这个结果根据我们定义的配置文件处理去，也就是进入我们所说的第四阶段了&lt;/p&gt;
&lt;p&gt;接下来就会去执行结果处理函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// now execute the result, if we're supposed to
if (proxy.getExecuteResult()) {
    executeResult();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里先告一段落，关于后续的结果处理函数后期再补充吧&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 15:26:00 +0000</pubDate>
<dc:creator>Autom_liu</dc:creator>
<og:description>struts 架构图 分析这个架构图，我们可以从4个部分，也就struts访问的4个阶段的流程来分析 这4个阶段包括：Action映射、Action转发、Action执行、结果返回 首先是Action</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/autom/p/10010214.html</dc:identifier>
</item>
<item>
<title>python异常处理 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-exception.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-exception.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;异常的概念&quot;&gt;1. 异常的概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;程序在运行时，如果 &lt;code&gt;Python 解释器&lt;/code&gt; &lt;strong&gt;遇到&lt;/strong&gt; 到一个错误，&lt;strong&gt;会停止程序的执行，并且提示一些错误信息&lt;/strong&gt;，这就是 &lt;strong&gt;异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序停止执行并且提示错误信息&lt;/strong&gt; 这个动作，我们通常称之为：&lt;strong&gt;抛出(raise)异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序开发时，很难将 &lt;strong&gt;所有的特殊情况&lt;/strong&gt; 都处理的面面俱到，通过 &lt;strong&gt;异常捕获&lt;/strong&gt; 可以针对突发事件做集中的处理，从而保证程序的 &lt;strong&gt;稳定性和健壮性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;捕获异常&quot;&gt;2. 捕获异常&lt;/h2&gt;
&lt;h3 id=&quot;简单的捕获异常语法&quot;&gt;2.1 简单的捕获异常语法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在程序开发中，如果 &lt;strong&gt;对某些代码的执行不能确定是否正确&lt;/strong&gt;，可以增加 &lt;code&gt;try(尝试)&lt;/code&gt; 来 &lt;strong&gt;捕获异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;捕获异常最简单的语法格式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    尝试执行的代码
except:
    出现错误的处理&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;try&lt;/code&gt; &lt;strong&gt;尝试&lt;/strong&gt;，下方编写要尝试代码，不确定是否能够正常执行的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;except&lt;/code&gt; &lt;strong&gt;如果不是&lt;/strong&gt;，下方编写尝试失败的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;简单异常捕获演练-要求用户输入整数&quot;&gt;简单异常捕获演练 —— 要求用户输入整数&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    int(input(&quot;请输入一个整数：&quot;))
except:
    print(&quot;请输入的不是一个整数&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;错误类型捕获&quot;&gt;2.2 错误类型捕获&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在程序执行时，可能会遇到 &lt;strong&gt;不同类型的异常&lt;/strong&gt;，并且需要 &lt;strong&gt;针对不同类型的异常，做出不同的响应&lt;/strong&gt;，这个时候，就需要捕获错误类型了&lt;/li&gt;
&lt;li&gt;语法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except (错误类型2, 错误类型3):
    # 针对错误类型2 和 3，对应的代码处理
    pass
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;Python&lt;/code&gt; 解释器 &lt;strong&gt;抛出异常&lt;/strong&gt; 时，&lt;strong&gt;最后一行错误信息的第一个单词，就是错误类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;异常类型捕获演练-要求用户输入整数&quot;&gt;异常类型捕获演练 —— 要求用户输入整数&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提示用户输入一个整数&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;8&lt;/code&gt; 除以用户输入的整数并且输出&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    num = int(input(&quot;请输入一个整数：&quot;))

    result = 8 / num
except ValueError:
    print(&quot;请输入正确的整数&quot;)
except ZeroDivisionError:
    print(&quot;除0错误&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;捕获未知错误&quot;&gt;捕获未知错误&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在开发时，&lt;strong&gt;要预判到所有可能出现的错误&lt;/strong&gt;，还是有一定难度的&lt;/li&gt;
&lt;li&gt;如果希望程序 &lt;strong&gt;无论出现任何错误&lt;/strong&gt;，都不会因为 &lt;code&gt;Python&lt;/code&gt; 解释器 &lt;strong&gt;抛出异常而被终止&lt;/strong&gt;，可以再增加一个 &lt;code&gt;except&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;except Exception as result:
    print(&quot;未知错误 %s&quot; % result)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常捕获完整语法&quot;&gt;2.3 异常捕获完整语法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except 错误类型2:
    # 针对错误类型2，对应的代码处理
    pass
except (错误类型3, 错误类型4):
    # 针对错误类型3 和 4，对应的代码处理
    pass
except Exception as result:
    # 打印错误信息
    print(result)
else:
    # 没有异常才会执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    print(&quot;无论是否有异常，都会执行的代码&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;else&lt;/code&gt; 只有在没有异常时才会执行的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finally&lt;/code&gt; 无论是否有异常，都会执行的代码&lt;/li&gt;
&lt;li&gt;之前一个演练的 &lt;strong&gt;完整捕获异常&lt;/strong&gt; 的代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    num = int(input(&quot;输入一个整数：&quot;))

    result = 8 / num

    print(result)
except ValueError:
    print(&quot;输入正确的整数&quot;)
except ZeroDivisionError:
    print(&quot;除0错误&quot;)
except Exception as result:

    print(&quot;未知错误 %s &quot; % result)

else:
    print(&quot;正常执行&quot;)
finally:
    print(&quot;总是会执行的代码&quot;)

print(&quot;-&quot; * 40)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异常的传递&quot;&gt;3. 异常的传递&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义函数 &lt;code&gt;demo1()&lt;/code&gt; &lt;strong&gt;提示用户输入一个整数并且返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;demo2()&lt;/code&gt; 调用 &lt;code&gt;demo1()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在主程序中调用 &lt;code&gt;demo2()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def demo1():
    return int(input(&quot;请输入一个整数:&quot;))


def demo2():
    return demo1()


try:
    print(demo2())
except ValueError:
    print(&quot;输入正确的整数&quot;)
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;抛出raise异常&quot;&gt;4. 抛出raise异常&lt;/h2&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;4.1 应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在开发中，除了 &lt;strong&gt;代码执行出错&lt;/strong&gt; &lt;code&gt;Python&lt;/code&gt; 解释器会 &lt;strong&gt;抛出&lt;/strong&gt; 异常之外&lt;/li&gt;
&lt;li&gt;还可以根据 &lt;strong&gt;应用程序&lt;/strong&gt; &lt;strong&gt;特有的业务需求&lt;/strong&gt; &lt;strong&gt;主动抛出异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提示用户 &lt;strong&gt;输入密码&lt;/strong&gt;，如果 &lt;strong&gt;长度少于 8&lt;/strong&gt;，抛出 &lt;strong&gt;异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前函数 &lt;strong&gt;只负责&lt;/strong&gt; 提示用户输入密码，如果 &lt;strong&gt;密码长度不正确，需要其他的函数进行额外处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因此可以 &lt;strong&gt;抛出异常&lt;/strong&gt;，由其他需要处理的函数 &lt;strong&gt;捕获异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;抛出异常&quot;&gt;4.2 抛出异常&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Python&lt;/code&gt; 中提供了一个 &lt;code&gt;Exception&lt;/code&gt; &lt;strong&gt;异常类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在开发时，如果满足 &lt;strong&gt;特定业务需求时&lt;/strong&gt;，希望 &lt;strong&gt;抛出异常&lt;/strong&gt;，可以：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;创建&lt;/strong&gt; 一个 &lt;code&gt;Exception&lt;/code&gt; 的 &lt;strong&gt;对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;raise&lt;/code&gt; &lt;strong&gt;关键字&lt;/strong&gt; 抛出 &lt;strong&gt;异常对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义 &lt;code&gt;input_password&lt;/code&gt; 函数，提示用户输入密码&lt;/li&gt;
&lt;li&gt;如果用户输入长度 &amp;lt; 8，抛出异常&lt;/li&gt;
&lt;li&gt;如果用户输入长度 &amp;gt;=8，返回输入的密码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def input_password():

    pwd = input(&quot;输入密码：&quot;)

    if len(pwd) &amp;gt;= 8:
        return pwd

    ex = Exception(&quot;密码长度不够&quot;)
    raise ex


try:
    print(input_password())
except Exception as result:
    print(result)
    &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 23 Nov 2018 14:59:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 异常的概念 程序在运行时，如果 遇到 到一个错误， 会停止程序的执行，并且提示一些错误信息 ，这就是 异常 程序停止执行并且提示错误信息 这个动作，我们通常称之为： 抛出(raise</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-exception.html</dc:identifier>
</item>
<item>
<title>Android Handler消息机制源码解析 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10010121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10010121.html</guid>
<description>&lt;p&gt;好记性不如烂笔头，今天来分析一下Handler的源码实现&lt;/p&gt;
&lt;p&gt;Handler机制是Android系统的基础，是多线程之间切换的基础。下面我们分析一下Handler的源码实现。&lt;/p&gt;
&lt;p&gt;Handler消息机制有4个类合作完成，分别是&lt;code&gt;Handler,MessageQueue,Looper,Message&lt;/code&gt;&lt;br/&gt;Handler : 获取消息，发送消息，以及处理消息的类&lt;br/&gt;MessageQueue:消息队列，先进先出&lt;br/&gt;Looper : 消息的循环和分发&lt;br/&gt;Message : 消息实体类，分发消息和处理消息的就是这个类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要工作原理就是：&lt;/strong&gt;&lt;br/&gt;Looper 类里面有一个无限循环，不停的从MessageQueue队列中取出消息，然后把消息分发给Handler进行处理&lt;/p&gt;
&lt;p&gt;先看看在子线程中发消息，去在主线程中更新，我们就在主线程中打印一句话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;br/&gt;在MainActivity中有一个属性uiHandler，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Handler uiHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if(msg.what == 100){
                Log.d(&quot;TAG&quot;,&quot;我是线程1 msg.what=&quot; + msg.what + &quot; msg.obj=&quot; + msg.obj.toString());
            }else if(msg.what == 200){
                Log.d(&quot;TAG&quot;,&quot;我是线程2 msg.what=&quot; + msg.what + &quot; msg.obj=&quot; + msg.obj.toString());
            }
        }
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个Handler实例，重写了handleMessage方法。根据message中what的标识来区别不同线程发来的数据并打印&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;br/&gt;在按钮的点击事件中开2个线程，分别在每个线程中使用 uiHandler获取消息，并发送消息。如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        findViewById(R.id.tv_hello).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //线程1
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //1 获取消息
                        Message message = uiHandler.obtainMessage();
                        message.what = 100;
                        message.obj = &quot;hello,world&quot;;
                        
                        //2 分发消息
                        uiHandler.sendMessage(message);
                    }
                }).start();

                //线程2
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        //1 获取消息
                        Message message = uiHandler.obtainMessage();
                        message.what = 200;
                        message.obj = &quot;hello,android&quot;;
                        
                        //2 分发消息
                        uiHandler.sendMessage(message);
                    }
                }).start();
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用很简单，两步就完成了从子线程把数据发送到主线程并在主线程中处理&lt;br/&gt;我们来先分析Handler的源码&lt;/p&gt;
&lt;h2 id=&quot;handler-的源码分析&quot;&gt;Handler 的源码分析&lt;/h2&gt;
&lt;p&gt;Handler的构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public Handler() {
        this(null, false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了第两个参数的构造函数，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Handler(Callback callback, boolean async) {
        //FIND_POTENTIAL_LEAKS 为 false, 不走这块
        if (FIND_POTENTIAL_LEAKS) {
            final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                    (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是下面几句：&lt;br/&gt;mLooper = Looper.myLooper(); 调用Looper的静态方法获取一个Looper&lt;br/&gt;如果 mLooper == null ，就会抛出异常&lt;br/&gt;Can't create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;;&lt;br/&gt;说明我们的线程中如果没有一个looper的话，直接 new Handler() 是会抛出这个异常的。必须首先调用 Looper.prepare()，这个等下讲Looper的源码时就会清楚了。&lt;/p&gt;
&lt;p&gt;接下来，把 mLooper中的 mQueue赋值给Handler中的 mQueue,callback是传出来的值，为null&lt;br/&gt;这样我们的Handler里面就保存了一个Looper变量，一个MessageQueue消息队列.&lt;/p&gt;
&lt;p&gt;接下来就是 &lt;code&gt;Message message = uiHandler.obtainMessage();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;obtainMessage()的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public final Message obtainMessage()
    {
        //注意传的是一个 this, 其实就是 Handler本身
        return Message.obtain(this);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又调用了Message.obtain(this);方法，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Message obtain(Handler h) {
        //1 调用obtain()获取一个Message实例m
        Message m = obtain();
        
        //2 关键的这句，把 h 赋值给了消息的 target，这个target肯定也是Handler了
        m.target = h;

        //3 返回 m
        return m;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，获取的消息里面就保存了 Handler 的实例。&lt;br/&gt;我们随便看一下 obtain() 方法是如何获取消息的。如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static Message obtain() {
        //sPoolSync同步对象用的
        synchronized (sPoolSync) {
            //sPool是Message类型，静态变量
            if (sPool != null) {
                //就是个单链表，把表头返回，sPool再指向下一个
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        
        //如果sPool为空，则直接 new 一个
        return new Message();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;obtain()获取消息就是个享元设计模式，享元设计模式用大白话说就是：&lt;br/&gt;&lt;strong&gt;池中有，就从池中返回一个，如果没有，则新创建一个，放入池中，并返回。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这种模式可以节省过多的创建对象。复用空闲的对象，节省内存。&lt;/p&gt;
&lt;p&gt;最后一句发送消息&lt;code&gt;uiHandler.sendMessage(message);&lt;/code&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sendMessageDelayed(msg, 0) 源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &amp;lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又调用了sendMessageAtTime() 源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        // Handler中的mQueue，就是前面从Looper.get
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用enqueueMessage()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        //注意这句，如果我们发送的消息不是 uiHandler.obtainMessage()获取的，而是直接 new Message()的，这个时候target为null
        //在这里，又把this 给重新赋值给了target了，保证不管怎么获取的Message,里面的target一定是发送消息的Handler实例
        msg.target = this;
        
        // mAsynchronous默认为false,不会走这个
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用&lt;code&gt;queue.enqueueMessage(msg, uptimeMillis)&lt;/code&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &amp;lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &amp;lt; p.when) {
                        break;
                    }
                    if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enqueue单词的英文意思就是 排队，入队的意思。所以enqueueMessage()就是把消息进入插入单链表中，上面的源码可以看出，主要是按照时间的顺序把msg插入到由单链表中的第一个位置中，接下来我们就需要从消息队列中取出msg并分了处理了。这时候就调用Looper.loop()方法了。&lt;/p&gt;
&lt;p&gt;Looper.loop()的源码我简化了一下，把主要的流程留下，方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;


        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }
        
            msg.target.dispatchMessage(msg);
           

            msg.recycleUnchecked();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，loop()方法就是在无限循环中不停的从queue中拿出下一个消息&lt;br/&gt;然后调用 msg.target.dispatchMessage(msg) , 上文我们分析过，Message的target保存的就是发送的Handler实例，这我们的这个demo中，就是uiHandler对象。&lt;/p&gt;
&lt;p&gt;说白了就是不停的从消息队列中拿出一个消息，然后发分给Handler的dispatchMessage()方法处理。&lt;/p&gt;
&lt;p&gt;Handler的dispatchMessage()方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，一个消息分发给dispatchMessage()之后&lt;br/&gt;1 首先看看消息的callback是否为null，如果不为null，就交给消息的handleCallback()方法处理，如果为null&lt;/p&gt;
&lt;p&gt;2 再看看Handler自己的mCallback是否为null，如果不为null，就交给mCallback.handleMessage(msg)进行处理，并且如果返回true,消息就不往下分发了，如果返回false&lt;/p&gt;
&lt;p&gt;3 就交给Handler的handleMessage()方法进行处理。&lt;/p&gt;
&lt;p&gt;有三层拦截，注意，有好多插件化在拦截替换activity的时候，就是通过反射，把自己实例的Handler实例赋值通过hook赋值给了ActivityThread相关的变量中，并且mCallback不为空，返回了false，这样不影响系统正常的流程，也能达到拦截的目的。说多了。&lt;/p&gt;
&lt;p&gt;前面分析了handler处理消息的机制，也提到了Looper类的作用，下面我们看看Looper的源码分析&lt;/p&gt;
&lt;h2 id=&quot;looper源码分析&quot;&gt;Looper源码分析&lt;/h2&gt;
&lt;p&gt;我们知道，APP进程的也就是我们应用的入口是ActivityThread.main()函数。&lt;br/&gt;对这块不熟悉的需要自己私下补课了。&lt;/p&gt;
&lt;p&gt;ActivityThread.main()的源码同样经过简化，如下：&lt;/p&gt;
&lt;p&gt;文件位于 &lt;em&gt;/frameworks/base/core/java/android/app/ActivityThread.java&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    //1 创建一个looper
    Looper.prepareMainLooper();
        
    //2 创建一个ActivityThread实例并调用attach()方法
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

    //3 消息循环
    Looper.loop();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，主线程中第一句就是创建一个looper，并调用了Looper.loop()进行消息循环，因为线程只有有了一个looper，才能消息循环，才能不停的从消息队列中取出消息，分发消息，并处理消息。没有消息的时候就阻塞在那，等待消息的到来并处理，这样的我们的app就是通过这种消息驱动的方式运行起来了。&lt;/p&gt;
&lt;p&gt;我们来看下 &lt;code&gt;Looper.prepareMainLooper()&lt;/code&gt; 的源码，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一句，调用了prepare(false)&lt;br/&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static void prepare(boolean quitAllowed) {
        //1 查看当前线程中是否有looper存在，有就抛个异常
        //这表明，一个线程只能有一个looper存在 
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        
        //2 创建一个Looper并存放在sThreadLocal中
        sThreadLocal.set(new Looper(quitAllowed));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sThreadLocal的定义如下&lt;br/&gt;&lt;code&gt;static final ThreadLocal&amp;lt;Looper&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;Looper&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是一个静态的变量。整个APP进程中只有一个sThreadLocal，sThreadLocal是线程独有的，每个线程都调用sThreadLocal保存，关于sThreadLocal的原理，其实就是类似HashMap（当然和HashMap是有区别的），也是key,value保存数据，只不过key就是sThreadLocal本身 ，但是映射的数组却是每个线程中独有的，这样就保证了sThreadLocal保存的数据每个线程独有一份，关于ThreadLocal的源码分析，后面几章会讲。&lt;/p&gt;
&lt;p&gt;既然Looper和线程有关，那么我们来看下Looper类的定义，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
  * Class used to run a message loop for a thread.  Threads by default do
  * not have a message loop associated with them; to create one, call
  * {@link #prepare} in the thread that is to run the loop, and then
  * {@link #loop} to have it process messages until the loop is stopped.
  *
  * &amp;lt;p&amp;gt;Most interaction with a message loop is through the
  * {@link Handler} class.
  *
  * &amp;lt;p&amp;gt;This is a typical example of the implementation of a Looper thread,
  * using the separation of {@link #prepare} and {@link #loop} to create an
  * initial Handler to communicate with the Looper.
  *
  * &amp;lt;pre&amp;gt;
  *  class LooperThread extends Thread {
  *      public Handler mHandler;
  *
  *      public void run() {
  *          Looper.prepare();
  *
  *          mHandler = new Handler() {
  *              public void handleMessage(Message msg) {
  *                  // process incoming messages here
  *              }
  *          };
  *
  *          Looper.loop();
  *      }
  *  }&amp;lt;/pre&amp;gt;
  */
public final class Looper {
    .......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看上面的注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  * &amp;lt;pre&amp;gt;
  *  class LooperThread extends Thread {
  *      public Handler mHandler;
  *
  *      public void run() {
  *          Looper.prepare();
  *
  *          mHandler = new Handler() {
  *              public void handleMessage(Message msg) {
  *                  // process incoming messages here
  *              }
  *          };
  *
  *          Looper.loop();
  *      }
  *  }&amp;lt;/pre&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是经典的Looper的用法 ，可以在一个线程中开始处调用 Looper.prepare();&lt;br/&gt;然后在最后调用 Looper.loop();进行消息循环，可以把其它线程中的Handler实传进来，这样，一个Looper线程就有了，可以很方便的切换线程了。&lt;br/&gt;下章节我们来自己设计一个Looper线程，做一些后台任务。&lt;/p&gt;
&lt;p&gt;Handler的消息机制源码就分析到这了&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 14:54:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>好记性不如烂笔头，今天来分析一下Handler的源码实现 Handler机制是Android系统的基础，是多线程之间切换的基础。下面我们分析一下Handler的源码实现。 Handler消息机制有4个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10010121.html</dc:identifier>
</item>
<item>
<title>maven生命周期和插件详解 - yuanrw</title>
<link>http://www.cnblogs.com/yuanrw/p/9979875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanrw/p/9979875.html</guid>
<description>&lt;p&gt;    生命周期和插件是Maven的两个核心概念，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。Maven的生命周期是抽象的，其实际行为都由插件来完成。Maven的生命周期是为了对所有的构建过程进行抽象和统一。&lt;/p&gt;
&lt;p&gt;    Maven拥有三套相互独立的生命周期，分别为clean、default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，site目的是建立项目站点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;clean&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1. pre-clean 执行一些清理前需要完成的工作。&lt;/p&gt;
&lt;p&gt;2. clean 清理上一次构建生成的文件。&lt;/p&gt;
&lt;p&gt;3. post-clean 执行一些清理后需要完成的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt; 包含的操作很多，以下列出主要的：&lt;/p&gt;
&lt;p&gt;process-sources 处理项目主资源文件。一般来说，是对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。&lt;/p&gt;
&lt;p&gt;compile 编译项目的主代码。一般来说，是编译src/main/java目录下的Java文件至项目输出的主classpath目录中。&lt;/p&gt;
&lt;p&gt;process-test-sources 处理项目测试资源文件 src/main/resources。&lt;/p&gt;
&lt;p&gt;test-compile 编译项目的测试代码。src/test/java。&lt;/p&gt;
&lt;p&gt;test 使用单元测试框架运行测试，测试代码不会被打包或部署。&lt;/p&gt;
&lt;p&gt;package 接受编译好的代码，打包成可发布的格式，如jar。&lt;/p&gt;
&lt;p&gt;install 将包安装到Maven本地仓库，供本地其他Maven项目使用。&lt;/p&gt;
&lt;p&gt;deploy 将最终的包复制到远程仓库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;site&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pre-site&lt;/p&gt;
&lt;p&gt;site 生成项目站点文档。&lt;/p&gt;
&lt;p&gt;post-site &lt;/p&gt;
&lt;p&gt;site-deploy 将生成的项目站点发布到服务器上。&lt;/p&gt;

&lt;h2&gt;插件目标（Plugin Goal）：&lt;/h2&gt;
&lt;p&gt;    一个插件往往能够完成多个任务。例如maven-dependency-plugin，它能够基于项目依赖做很多事情，例如分析项目依赖，帮助找出所有已解析的依赖等等，每个功能就是一个插件目标。用法是 &amp;lt;插件前缀:目标&amp;gt;。例如maven-dependency-plugin有十多个目标，最常用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mvn dependency:analyze

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果：&lt;/span&gt;
&lt;span&gt;[WARNING] Used undeclared dependencies found:
[WARNING]    org.springframework:spring&lt;/span&gt;-web:jar:5.0.4&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-autoconfigure:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework:spring&lt;/span&gt;-tx:jar:5.0.4&lt;span&gt;.RELEASE:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING] Unused declared dependencies found:
[WARNING]    com.alibaba:fastjson:jar:&lt;/span&gt;1.2.31&lt;span&gt;:compile
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-starter-test:jar:2.0.0&lt;span&gt;.RELEASE:test
[WARNING]    org.springframework.boot:spring&lt;/span&gt;-boot-starter-web:jar:2.0.0&lt;span&gt;.RELEASE:compile
[WARNING]    org.mybatis.spring.boot:mybatis&lt;/span&gt;-spring-boot-starter:jar:1.3.0&lt;span&gt;:compile
[WARNING]    com.google.guava:guava:jar:&lt;/span&gt;23.0:compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Unused declared dependencies found即声明了没使用的依赖，通过这个插件，就能看到项目依赖的情况。如果是因为继承了父pom文件而导致无用依赖太多，那么可以使用dependencyManagement管理。&lt;/span&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;插件绑定：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    Maven的生命周期与插件相互绑定，用以完成实际的构建任务。例如项目编译这一任务，它对应了default生命周期的compile阶段，而maven-compile-plugin这一插件的compile目标能完成该任务。因此，将它们绑定，就能实现编译的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123205349025-382347111.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;230&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　Maven在核心为一些主要的生命周期阶段绑定了很多插件的目标，当用户通过命令行调用生命周期阶段的时候，对于的插件目标就会执行相应的任务。例如clean绑定mavevn-clean-plugin:clean。&lt;/p&gt;
&lt;p&gt;　　而default生命周期，由于项目的打包类型会影响构建的具体过程，因此，default生命周期的阶段与插件的目标绑定关系由项目打包类型所决定，通过POM中的packaging元素定义。最常用的打包类型是jar。以下是基于jar，default生命周期的内置插件绑定关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123210029376-582675833.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;default生命周期还有很多其他阶段，默认它们没有绑定任何插件，因此也没有实际行为。&lt;/p&gt;

&lt;h2&gt;自定义绑定：&lt;/h2&gt;
&lt;p&gt;　　除了内置绑定以外，用户还能够自己选择将某个插件目标绑定到生命周期的某个阶段上。例如一个常用的插件 Maven Archetype Plugin，用户通过这个插件可以生成一个Maven项目的骨架，也可以从一个现成的项目中生成模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201811/1500605-20181123212123241-923585218.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常的用法是使用 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn archetype:create-from-project&lt;/span&gt; 指令生成模板。如果我正在编写一个模板项目，我希望在打包的时候自动生成模板，那么我可以把这个目标绑定到default的package生命周期上，如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;/plugins&amp;gt;
　　&amp;lt;plugin&amp;gt;
　　　　&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
　　　　&amp;lt;artifactId&amp;gt;maven-archetype-plugin&amp;lt;/artifactId&amp;gt;
　　　　&amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
　　　　　　&amp;lt;executions&amp;gt;
　　　　　　　　&amp;lt;execution&amp;gt;
　　　　　　　　　　&amp;lt;id&amp;gt;create-archetype&amp;lt;/id&amp;gt;
　　　　　　　　　　&amp;lt;phase&amp;gt;&lt;span&gt;package&lt;/span&gt;&amp;lt;/phase&amp;gt;
　　　　　　　　　　&amp;lt;goals&amp;gt;
　　　　　　　　　　　　&amp;lt;goal&amp;gt;create-from-project&amp;lt;/goal&amp;gt;
　　　　　　　　　　&amp;lt;/goals&amp;gt;
　　　　　　　　&amp;lt;/execution&amp;gt;
　　　　　&amp;lt;/executions&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在POM的build元素下的plugins子元素中声明插件的使用，除了配置插件的坐标声明外，还有插件的执行配置，executeions下每个execution子元素可以用来配置执行一个任务。我们配置了一个id为create-archetype的任务，通过phrase配置，将其绑定到package生命周期阶段上，再通过goals配置指定要执行的插件目标。&lt;/p&gt;
&lt;p&gt;执行 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn clean &lt;span&gt;package&lt;/span&gt;&lt;/span&gt; 就能看到有以下输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......以上省略......&lt;/span&gt;
&lt;span&gt;
[INFO] &lt;/span&gt;--- maven-jar-plugin:3.0.2:jar (&lt;span&gt;default&lt;/span&gt;-jar) @ demo ---&lt;span&gt;
[INFO] Building jar: &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/demo-1.0-&lt;span&gt;SNAPSHOT.jar
[INFO] 
[INFO] &lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; maven-archetype-plugin:3.0.1:create-from-project (create-archetype) &amp;gt; generate-sources @ demo &amp;gt;&amp;gt;&amp;gt;&lt;span&gt;
[INFO] 
[INFO] &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt; maven-archetype-plugin:3.0.1:create-from-project (create-archetype) &amp;lt; generate-sources @ demo &amp;lt;&amp;lt;&amp;lt;&lt;span&gt;
[INFO] 
[INFO] 
[INFO] &lt;/span&gt;--- maven-archetype-plugin:3.0.1:create-from-project (create-archetype) @ demo ---&lt;span&gt;
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; groupId: com.yrw
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; artifactId: demo
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; version: 1.0-&lt;span&gt;SNAPSHOT
[INFO] Setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt;: com.yrw.test
[INFO] Scanning &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; projects...
[INFO] 
[INFO] &lt;/span&gt;-----------------------&amp;lt; com.yrw:demo-archetype &amp;gt;-----------------------&lt;span&gt;
[INFO] Building demo&lt;/span&gt;-archetype 1.0-&lt;span&gt;SNAPSHOT
[INFO] &lt;/span&gt;--------------------------[ maven-archetype ]---------------------------&lt;span&gt;
[INFO] 
[INFO] &lt;/span&gt;--- maven-resources-plugin:3.1.0:resources (&lt;span&gt;default&lt;/span&gt;-resources) @ demo-archetype ---&lt;span&gt;
[WARNING] Using platform encoding (UTF&lt;/span&gt;-8 actually) to copy filtered resources, i.e. build is platform dependent!&lt;span&gt;
[INFO] Copying &lt;/span&gt;84&lt;span&gt; resources
[INFO] 
[INFO] &lt;/span&gt;--- maven-resources-plugin:3.1.0:testResources (&lt;span&gt;default&lt;/span&gt;-testResources) @ demo-archetype ---&lt;span&gt;
[WARNING] Using platform encoding (UTF&lt;/span&gt;-8 actually) to copy filtered resources, i.e. build is platform dependent!&lt;span&gt;
[INFO] Copying &lt;/span&gt;2&lt;span&gt; resources
[INFO] 
[INFO] &lt;/span&gt;--- maven-archetype-plugin:3.0.1:jar (&lt;span&gt;default&lt;/span&gt;-jar) @ demo-archetype ---&lt;span&gt;
[INFO] Building archetype jar: &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/generated-sources/archetype/target/demo-archetype-1.0-&lt;span&gt;SNAPSHOT
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] BUILD SUCCESS
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Total time: &lt;/span&gt;1.110&lt;span&gt; s
[INFO] Finished at: &lt;/span&gt;2018-11-23T22:12:15+08:00&lt;span&gt;
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Archetype project created in &lt;/span&gt;/Users/yrw/Desktop/github/demo/target/generated-sources/&lt;span&gt;archetype
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] BUILD SUCCESS
[INFO] &lt;/span&gt;------------------------------------------------------------------------&lt;span&gt;
[INFO] Total time: &lt;/span&gt;5.689&lt;span&gt; s
[INFO] Finished at: &lt;/span&gt;2018-11-23T22:12:15+08:00&lt;span&gt;
[INFO] &lt;/span&gt;------------------------------------------------------------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在打包的时候执行了archetype:create-from-project，进入/target/generated-sources/archetype目录，就能看到生成的模板了。&lt;/p&gt;

&lt;h2&gt;命令行配置插件：&lt;/h2&gt;
&lt;p&gt;    插件目标支持命令行配置，可以通过-D参数，并伴随一个参数=参数值的形式，来配置插件目标的参数。例如命令 &lt;span class=&quot;cnblogs_code&quot;&gt;mvn install -Dmaven.test.skip=&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; ，就会跳过执行测试。&lt;/p&gt;

&lt;h2&gt;在pom中配置全局插件：&lt;/h2&gt;
&lt;p&gt;　　并不是所有的插件参数都适合从命令行配置，有些参数的值从项目发布都不会改变，对于这种情况，可以在pom文件中一次性配置。例如需要配置maven-compiler-plugin编译java1.8.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　&amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.8.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;8&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;8&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;plugins&amp;gt;
　　&amp;lt;build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，不管绑定到compile阶段的maven-compiler-plugin:compile任务，还是绑定到test-compiler阶段的maven-compiler-plugin:testCompiler任务，就都能够使用该配置，基于1.8版本进行编译。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>yuanrw</dc:creator>
<og:description>生命周期和插件是Maven的两个核心概念，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。Maven的生命周期是抽象的，其实际行为都由插件来完成。M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanrw/p/9979875.html</dc:identifier>
</item>
<item>
<title>Jenkins持续集成介绍及插件安装版本更新演示（一）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10001180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10001180.html</guid>
<description>
&lt;h2&gt;Jenkins介绍&lt;/h2&gt;

&lt;p&gt;&lt;span&gt; Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jenkins功能包括:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、持续的软件版本发布/测试项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、监控外部调用执行的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                             --摘自360百科&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. jenkins就是基于Java开发的一种持续集成的工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 可以将运维用到的各个脚本整合起来，并且可以通过页面方式集中管理，而且可以也可以实现和gitlab、github交互，也可以实现自动编译、部署程序&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;持续集成&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建(包括编译，发布，自动化测试)来验证，从而尽早地发现集成错误。&lt;/p&gt;

&lt;p&gt;持续集成&lt;/p&gt;
&lt;p&gt;持续集成：Continuous Intergration （&lt;span&gt;CI&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;持续交付：Continuous Delivery（&lt;span&gt;CD&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;持续部署：Continuous Deployment（&lt;span&gt;CD&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;持续集成流程&lt;/p&gt;
&lt;p&gt;1. 提交（&lt;span&gt;git&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;2. 测试&lt;/p&gt;
&lt;p&gt;3. 构建（&lt;span&gt;jenkins&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;4. 测试&lt;/p&gt;
&lt;p&gt;5. 部署（&lt;span&gt;ansible&lt;/span&gt;，&lt;span&gt;shell&lt;/span&gt;，&lt;span&gt;puppet&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;6. 回滚（&lt;span&gt;ansible&lt;/span&gt;）&lt;/p&gt;

&lt;h2&gt;Jenkins的安装&lt;/h2&gt;

&lt;p&gt; jenkins是基于java开发的所以需要安装java环境&lt;/p&gt;
&lt;p&gt;jenkins提供了一个友好的web界面操控，安装完成之后我们可以在web端进行管理&lt;/p&gt;
&lt;p&gt;大家可以在如下的网站下载所需要的jenkins版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172037850-1341422281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步：关闭防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：安装java环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install java -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：上传安装包及解压安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ls |&lt;span&gt; grep jenkins
jenkins&lt;/span&gt;-&lt;span&gt;2.138&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1.1&lt;/span&gt;.noarch.rpm&lt;br/&gt;[root@ken ~]# rpm -ivh jenkins-2.138.3-1.1.noarch.rpm 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：启动jenkins&lt;/p&gt;
&lt;p&gt;jenkins默认监听的是8080端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart jenkins
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;50&lt;/span&gt;          :::&lt;span&gt;8080&lt;/span&gt;                    :::*                  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第五步：浏览器访问&lt;/p&gt;
&lt;p&gt;可以看到如下的界面&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：安装jenkins会卡在安装界面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;原因：当前主机尝试连接jenkins官方站点，但是无法连接上&lt;/span&gt;&lt;br/&gt;&lt;span&gt;解决：断开当前主机的网络连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122165915110-760146147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第六步：linux中找到上述密码并复制进上述框中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cat /&lt;span&gt;var&lt;/span&gt;/lib/jenkins/secrets/&lt;span&gt;initialAdminPassword
f10ee04f771042638d1c152355efc8c8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上面这个密码输入上述框中点击继续即可&lt;/p&gt;
&lt;p&gt;选择跳过插件安装即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170233417-1178710907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在如下界面创建用户和密码，点击保存并完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170345578-598226152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现如下界面直接点保存并完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170457187-167233026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 点下下面出现的开始使用Jenkins&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170520403-347497511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到如下界面即表示安装配置完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122170613010-1640694024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Jenkins获取插件并安装&lt;/h2&gt;

&lt;p&gt; 第一步：查看插件信息&lt;/p&gt;
&lt;p&gt;点击系统管理&amp;gt;插件管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172632401-1810903991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击插件管理&lt;/p&gt;
&lt;p&gt;可以看到已安装处为空&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122172719346-1857954528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载插件之前可以在系统管理&amp;gt;关于jenkins查看自己的jenkins版本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173319581-1804217609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：下载插件&lt;/p&gt;
&lt;p&gt;访问如下网站，选择你的jenkins版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173505457-250990269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择latest&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122173554048-1933904849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择你需要安装的插件即可&lt;/p&gt;
&lt;p&gt;插件都是以hpi结尾的&lt;/p&gt;

&lt;p&gt;第三步：把下载的插件传入到你的linux系统中&lt;/p&gt;
&lt;p&gt;需要把插件传到jenkins的插件目录中即下面的目录下&lt;/p&gt;
&lt;p&gt;这里我准备了一个插件安装包 plugins-2.138.3.tar.gz &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ls /&lt;span&gt;var&lt;/span&gt;/lib/jenkins/plugins/
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;[root@ken ~]# tar xf plugins-2.138.3.tar.gz&lt;br/&gt;[root@ken ~]# cp plugins/* /var/lib/jenkins/plugins/ -a&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;第四步：重启jenkins&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart jenkins
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第五步：浏览器端查看&lt;/p&gt;
&lt;p&gt;需要刷新一下浏览器，可能还需要你重新输入账号和密码&lt;/p&gt;
&lt;p&gt;可以看到在已安装里面已经有很多的插件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122174939713-1045191078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Jenkins版本更新&lt;/h2&gt;

&lt;p&gt;第一步：下载安装更新的软件包&lt;/p&gt;
&lt;p&gt;还是访问这个网站&lt;/p&gt;
&lt;p&gt;选择你需要升级到的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182136155-201983760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择latest&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182238437-1713053188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择war结尾的包下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181122182303266-1023001692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：把选本的war包删掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken plugins]# rpm -ql jenkins |&lt;span&gt; grep war
&lt;/span&gt;/usr/lib/jenkins/jenkins.war
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：替换成你下载的包&lt;/p&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;p&gt;第四步：重启jenkins即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart jenkins
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 23 Nov 2018 14:19:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>Jenkins介绍 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins功能包括:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10001180.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（一） 向量 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</guid>
<description>&lt;p&gt;　　计算机程序主要运行在内存中，而内存在逻辑上可以被看做是连续的地址。为了充分利用这一特性，在主流的编程语言中都存在一种底层的被称为&lt;strong&gt;数组(Array)&lt;/strong&gt;的数据结构与之对应。在使用数组时需要事先声明&lt;strong&gt;固定的大小&lt;/strong&gt;以便程序在运行时为其开辟内存空间；数组通过下标值计算出地址偏移量来对内部元素进行访问。&lt;/p&gt;
&lt;p&gt;　　可以看到，原始的数组很基础，所以运行效率非常的高。但同时也存在着严重的问题：&lt;/p&gt;
&lt;p&gt;　　1.由于数组的大小需要在创建时被固定下来，但大多数程序在编写时无法很好的预测到可能的数据量大小，因而也就无法在创建时设置合适的数组大小，过大则&lt;strong&gt;浪费内存空间&lt;/strong&gt;；过小则会出现&lt;strong&gt;上溢&lt;/strong&gt;，需要编程人员进行特别的处理。&lt;/p&gt;
&lt;p&gt;　　2.访问数组时，很容易出现数组下标越界的情况。由于数组的访问是非常频繁的，因而在追求性能的语言中(如&lt;strong&gt;C语言&lt;/strong&gt;)，编译器都没有对数组下标越界进行额外的检查，当程序出现了意外的数组下标越界时，依然允许程序访问和修改数组外部的内存地址，这很容易造成古怪的，难以复现的bug。(&lt;strong&gt;Java&lt;/strong&gt;，&lt;strong&gt;python&lt;/strong&gt;等较为高级的语言为了安全起见，即使舍弃掉一定的性能也要对数组下标越界进行检查)。&lt;/p&gt;
&lt;p&gt;　　针对上述问题，我们需要对原始的数组进行一定程度的封装，在不改变基本使用方式的前提下，使其在运行过程中能够针对所存储的数据量大小自适应的&lt;strong&gt;扩容；&lt;/strong&gt;对数组下标的越界访问进行检查，同时提供一系列的常用接口供用户使用。&lt;/p&gt;
&lt;p&gt;　　而这个基于数组封装之后的数据结构，我们一般称之为&quot;&lt;strong&gt;向量(vector)&lt;/strong&gt;&quot;或者&quot;&lt;strong&gt;顺序表(sequence list)&lt;/strong&gt;&quot;。&lt;/p&gt;

&lt;p&gt;　　由于是使用java作为实现的语言，因此在设计上参考了jdk自带的向量数据结构：&lt;strong&gt;java.util.ArrayList&lt;/strong&gt;类。&lt;/p&gt;
&lt;h3&gt;　　1.size()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;int size();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：返回当前列表中元素的个数。&lt;/p&gt;
&lt;h3&gt;　　2.isEmpty()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean isEmpty();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：如果当前列表中元素个数为0，返回&lt;strong&gt;true&lt;/strong&gt;；否则，返回&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;　　3.indexOf()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;int indexOf(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：判断元素&quot;e&quot;是否存在于列表中&lt;/p&gt;
&lt;h3&gt;　　4.contains()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean contains(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述: 判断元素&quot;e&quot;是否存在于列表中&lt;/p&gt;
&lt;h3&gt;　　5.add()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean add(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：在列表的最后插入元素&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;　　　　&lt;/em&gt;接口定义：&lt;strong&gt;void add(int index,E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：在列表的下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处插入元素&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;　　6.remove()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean remove(E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述：从列表中找到并且移除&lt;strong&gt;&quot;&lt;/strong&gt;e&quot;对象，找到并且成功移除返回&lt;strong&gt;true&lt;/strong&gt;；否则返回&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　　　接口定义：&lt;strong&gt;E remove(int index);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：移除列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素，返回被移除的元素。&lt;/p&gt;
&lt;h3&gt;　　7.set()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E set(int index,E e);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：将列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素替代为&lt;strong&gt;&quot;e&quot;&lt;/strong&gt;,返回被替代的元素。&lt;/p&gt;
&lt;h3&gt;　　8.get()&lt;/h3&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E get(int index);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：返回列表中下标为&lt;strong&gt;&quot;index&quot;&lt;/strong&gt;位置处的元素。&lt;/p&gt;

&lt;h2&gt;3.1 向量属性&lt;/h2&gt;
&lt;p&gt;　　向量作为数组的进一步封装，内部持有着一个数组，首先我们有以下属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList &amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; List &amp;lt;E&amp;gt;&lt;span&gt;{&lt;br/&gt;&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部封装的数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] elements;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 线性表默认的容量大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 16&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩容翻倍的基数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; EXPAND_BASE = 1.5&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组的实际大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前线性表的实际大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=================================================构造方法======================================================&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认的无参构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
        size &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小为默认&lt;/span&gt;
        elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[DEFAULT_CAPACITY];
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置内部数组初始大小的构造方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity 内部数组初始大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ArrayList(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
        size &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小&lt;/span&gt;
        elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[capacity];
    }
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 较为简单的 &lt;strong&gt;size()，isEmpty()，indexOf()，contains()&lt;/strong&gt;方法实现：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size == 0)&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前参数是否为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;::::参数不为null
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从前到后依次比对&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前item是否 equals 参数e&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e.equals(elements[i])){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::匹配成功，立即返回当前下标&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::参数为null
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从前到后依次比对&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前item是否为null&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.elements[i] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为null，立即返回当前下标&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历列表未找到相等的元素，返回特殊值&quot;-1&quot;代表未找到&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::复用indexOf方法,如果返回-1代表不存在;反之，则代表存在&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (indexOf(e) != -1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;indexOf、contains方法——时间复杂度：　　&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　可以看到&lt;strong&gt;indexOf&lt;/strong&gt;方法的内部是通过一次循环遍历来查询的。&lt;/p&gt;
&lt;p&gt;　　因此&lt;strong&gt;indexOf&lt;/strong&gt;方法、&lt;strong&gt;contains&lt;/strong&gt;方法的&lt;strong&gt;渐进时间复杂度&lt;/strong&gt;都是&lt;strong&gt;O(n)&lt;/strong&gt;，这个查询效率比未来要介绍的&lt;strong&gt;哈希表&lt;/strong&gt;的查询时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;有明显差距&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3.3.增删改查接口实现：&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.3.1 下标越界检查&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;部分增删改查接口会通过下标来进行操作，必须对访问数组的下标进行校验。&lt;/p&gt;
&lt;h4&gt;下标越界检查&lt;strong&gt;方法实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入时,下标越界检查
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 下标值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheckForAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果下标小于0或者大于size的值，抛出异常
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::注意：插入时，允许插入向量的末尾，因此(index == size)是合法的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(index &amp;gt; &lt;span&gt;this&lt;/span&gt;.size || index &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;index error  index=&quot; + index + &quot; size=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) ;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 下标越界检查
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 下标值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheck(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果下标小于0或者大于等于size的值，抛出异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(index &amp;gt;= &lt;span&gt;this&lt;/span&gt;.size || index &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;index error  index=&quot; + index + &quot; size=&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) ;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.3.2 插入方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入新数据前进行扩容检查&lt;/span&gt;
&lt;span&gt;        expandCheck();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;;::在末尾插入元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.size] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自增&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入时，数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheckForAdd(index);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入新数据前进行扩容检查&lt;/span&gt;
&lt;span&gt;        expandCheck();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::插入位置下标之后的元素整体向后移动一位(防止数据被覆盖，并且保证数据在数组中的下标顺序)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;this&lt;/span&gt;.size; i&amp;gt;index; i--&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] = &lt;span&gt;this&lt;/span&gt;.elements[i-1&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::在index下标位置处插入元素&quot;e&quot;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[index] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自增&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;插入方法——时间复杂度:&lt;/h4&gt;
&lt;p&gt;　　可以看到，向量的插入操作会导致插入位置之后的数据整体向后平移一位。&lt;/p&gt;
&lt;p&gt;　　在这里，使用了for循环将数据一个一个的进行复制。事实上，由于数组中下标连续的数据段在内存中也是连续成片的(&lt;strong&gt;逻辑意义上的&lt;/strong&gt;)，因此操作系统可以通过批量复制内存的方法来优化这种&quot;&lt;strong&gt;数组中一片连续数据复制&lt;/strong&gt;&quot;的操作。java在jdk中自带的向量实现中采用了&lt;strong&gt;native&lt;/strong&gt;的&lt;strong&gt;System.arraycopy()&lt;/strong&gt;方法来实现这个优化操作。&lt;/p&gt;
&lt;p&gt;　　在我的向量实现中，有多处这种&quot;数组中一片连续数据复制&quot;的操作，为了增强代码的可理解性，都使用了for循环这种较低效率的实现方式，希望能够理解。&lt;/p&gt;
&lt;p&gt;　　虽然&lt;strong&gt;System.arraycopy&lt;/strong&gt;能够优化这一操作的效率，但是在渐进的意义上，&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;插入操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;动态扩容：&lt;/h4&gt;
&lt;p&gt;　　前面我们提到，向量相比数组的一大&lt;strong&gt;改进&lt;/strong&gt;就是向量能够在数据新增时根据存储的数据量进行&lt;strong&gt;动态的扩容&lt;/strong&gt;，而不需要人工的干预。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;向量扩容方法的实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组扩容检查
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; expandCheck(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前元素个数 = 当前内部数组容量&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.size == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::需要扩容

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存之前内部数组的引用&lt;/span&gt;
            Object[] tempArray = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前内部数组扩充 一定的倍数&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.capacity = (&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;this&lt;/span&gt;.capacity *&lt;span&gt; EXPAND_BASE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组指向扩充了容量的新数组&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.elements = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了代码的可读性，使用for循环实现新老数组的copy操作
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;tempArray.length; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] =&lt;span&gt; tempArray[i];
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;动态扩容——时间复杂度：&lt;/h4&gt;
&lt;p&gt;　　动态扩容的操作由于需要进行内部数组的整体copy，&lt;strong&gt;其时间复杂度是O(n)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;但是站在全局的角度，动态扩容只会在插入操作导致空间不足时&lt;strong&gt;偶尔&lt;/strong&gt;的被触发，所以&lt;strong&gt;整体来看，动态扩容的时间复杂度为O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.3.3 删除方法实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存将要被移除的元素&lt;/span&gt;
        E willBeRemoved = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将删除下标位置之后的数据整体前移一位
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 比起for循环，System.arraycopy基于native的内存批量复制在内部数组数据量较大时具有更高的执行效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=index+1; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i-1] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于数据整体前移了一位，释放列表末尾的失效引用，增加GC效率&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[(&lt;span&gt;this&lt;/span&gt;.size - 1)] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自减&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回被删除的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; willBeRemoved;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;删除方法——时间复杂度:&lt;/h4&gt;
&lt;p&gt;　　向量的删除操作会导致被删除位置之后的数据整体前移一位。&lt;/p&gt;
&lt;p&gt;　　和插入操作类似，&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;删除操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;3.3.4 修改/查询方法实现：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存之前index下标处元素的引用&lt;/span&gt;
        E oldValue = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将index下标元素设置为参数&quot;e&quot;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[index] =&lt;span&gt; e;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回被替换掉的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::数组下标越界检查&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回对应下标的元素&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[index];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;修改/查询方法——时间复杂度：&lt;/h4&gt;
&lt;p&gt;　　可以看到，向量的修改和查询操作都直接通过下标访问内部数组。&lt;/p&gt;
&lt;p&gt;　　通过下标访问数组内部元素只需要计算偏移量即可直接访问对应数据，因此&lt;strong&gt;向量&lt;/strong&gt;&lt;strong&gt;修改/查询操作&lt;/strong&gt;的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;3.4 向量其它接口：&lt;/h2&gt;
&lt;h3&gt;3.4.1 clear方法&lt;/h3&gt;
&lt;p&gt;　　clear方法用于清空向量内的元素，初始化向量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历列表，释放内部元素引用，增加GC效率&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[i] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将size重置为0&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size = 0&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4.2 trimToSize方法&lt;/h3&gt;
&lt;p&gt;　　前面提到，向量在空间不足时会自动的进行扩容。自动增长的特性非常方便，但是也带来了一个问题：向量会在新增元素时扩容，但出于效率的考量，删除元素却不会自动的收缩。举个例子：一个很大的向量执行&lt;strong&gt;clear&lt;/strong&gt;时，虽然内部元素的引用被销毁，但是内部数组&lt;strong&gt;elements&lt;/strong&gt;依然占用了很多不必要的内存空间。&lt;/p&gt;
&lt;p&gt;　　因此，向量提供了&lt;strong&gt;trimToSize&lt;/strong&gt;方法，允许用户在必要的时候手动的使向量&lt;strong&gt;收缩&lt;/strong&gt;，以增加空间效率。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收缩内部数组，使得&quot;内部数组的大小&quot;和&quot;向量逻辑大小&quot;相匹配，提高空间利用率
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; trimToSize(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前向量逻辑长度 小于 内部数组的大小&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.size &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::创建一个和当前向量逻辑大小相等的新数组&lt;/span&gt;
            Object[] newElements = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前旧内部数组的数据复制到新数组中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::Tips: 这里使用Arrays.copy方法进行复制,效率更高&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt; newElements.length; i++&lt;span&gt;){
                newElements[i] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::用新数组替换掉之前的老内部数组&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.elements =&lt;span&gt; newElements;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置当前容量&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.capacity = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4.3 toString方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空列表&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::列表起始使用&quot;[&quot;&lt;/span&gt;
        StringBuilder s = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;[&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从第一个到倒数第二个元素之间&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;size-1; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::使用&quot;, &quot;进行分割&lt;/span&gt;
            s.append(elements[i]).append(&quot;,&quot;).append(&quot; &quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::最后一个元素使用&quot;]&quot;结尾&lt;/span&gt;
        s.append(elements[size - 1]).append(&quot;]&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.toString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在我们使用数据结构容器时，会遇见以下问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 需要理解内部设计才能遍历容器中数据。&lt;/strong&gt;如果说基于数组的&lt;strong&gt;向量&lt;/strong&gt;还可以较&lt;strong&gt;轻松&lt;/strong&gt;的通过循环下标来进行遍历，那么更加复杂的数据结构例如&lt;strong&gt;哈希表&lt;/strong&gt;、&lt;strong&gt;平衡二叉树&lt;/strong&gt;等在遍历时将变得更加&lt;strong&gt;困难&lt;/strong&gt;。同时在业务代码中如果存储数据的容器类型一旦被改变(&lt;strong&gt;向量---&amp;gt;链表&lt;/strong&gt;)  ，意味着大量代码的推倒重写。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. 缺少对容器遍历行为的抽象，导致重复代码的出现&lt;/strong&gt;。这一问题必须在实现了多个数据结构容器之后才会体现出来。例如，上面提到的向量的toString方法中，如果将遍历内部数组的行为抽象出来，则可以使得多种不同的类型的数据结构容器复用同一个&lt;strong&gt;toString&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;　　为此java在设计数据结构容器架构时，抽象出了&lt;strong&gt;Iterator&lt;/strong&gt;接口，用于整合容器遍历的行为，并要求所有的容器都必须提供&lt;strong&gt;对应的Iterator接口&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Iterator接口设计：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;1. hasNext()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;boolean hasNext();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述：当前迭代器 是否存在下一个元素。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. next()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;E next();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;接口描述：获得迭代器 迭代的下一个元素。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3. remove()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口定义：&lt;strong&gt;void remove();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　接口描述:  移除迭代器指针当前指向的元素&lt;/p&gt;
&lt;p&gt;　　个人认为迭代器之所以加上了remove接口，是因为很多时候迭代的操作都伴随着删除容器内部元素的需求。由于删除元素会导致内部数据结构的变化，导致无法简单的完成遍历，需要使用者熟悉容器内部实现原理，小心谨慎的实现遍历代码。&lt;/p&gt;
&lt;p&gt;　　而&lt;strong&gt;Iterator&lt;/strong&gt;接口的出现，将这一问题带来的复杂度交给了容器的设计者，降低了用户使用数据结构容器的难度。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;向量Iterator实现：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向量 迭代器内部类
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 迭代器下一个元素 指针下标
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextIndex = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 迭代器当前元素 指针下标
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; currentIndex = -1&lt;span&gt;;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果&quot;下一个元素指针下标&quot; 小于 &quot;当前向量长度&quot; ==&amp;gt; 说明迭代还未结束&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.nextIndex &amp;lt; ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        }

        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前元素指针下标 = 下一个元素指针下标&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex =&lt;span&gt; nextIndex;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::下一个元素指针下标自增,指向下一元素&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.nextIndex++&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回当前元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; (E)ArrayList.&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex];
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前元素&lt;/span&gt;
            ArrayList.&lt;span&gt;this&lt;/span&gt;.remove(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于删除了当前下标元素，数据段整体向前平移一位，因此nextIndex不用自增

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了防止用户在一次迭代(next调用)中多次使用remove方法，将currentIndex设置为-1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex = -1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　5.1 向量的性能&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　　　空间效率：&lt;/strong&gt;向量中空间占比最大的就是一个随着存储数据规模增大而不断增大的内部数组。而数组是十分紧凑的，因此&lt;strong&gt;向量&lt;/strong&gt;的&lt;strong&gt;空间效率&lt;/strong&gt;&lt;strong&gt;非常高&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;时间效率：&lt;/strong&gt;评估一个数据结构容器的时间效率，可以从最常用的增删改查接口来进行衡量。&lt;/p&gt;
&lt;p&gt;　　　　我们已经知道，向量的&lt;strong&gt;增加、删除&lt;/strong&gt;操作的&lt;strong&gt;时间复杂度&lt;/strong&gt;为&lt;strong&gt;O(n)，&lt;/strong&gt;效率较低；而向量的随机&lt;strong&gt;修改、查询&lt;/strong&gt;操作效率则非常高，为常数的时间复杂度&lt;strong&gt;O(1)&lt;/strong&gt;。对于&lt;strong&gt;有序向量&lt;/strong&gt;，其查找特定元素的&lt;strong&gt;时间复杂度&lt;/strong&gt;也能够被控制在&lt;strong&gt;O(logn)&lt;/strong&gt;对数时间复杂度上。&lt;/p&gt;
&lt;p&gt;　　　　因此向量在随机查询较多，而删除和增加较少的场景表现优异，但是并不适合频繁插入和删除的场景。&lt;/p&gt;
&lt;h3&gt;　　5.2 当前向量实现存在的缺陷&lt;/h3&gt;
&lt;p&gt;　　　　到这里，我们已经完成了一个最基础的向量数据结构。限于个人水平，以及为了代码尽可能的简单和易于理解，所以并没有做进一步的改进。&lt;/p&gt;
&lt;p&gt;　　　　下面是我认为当前实现版本的主要缺陷：&lt;/p&gt;
&lt;h4&gt;　　　　1.不支持并发&lt;/h4&gt;
&lt;p&gt;　　　　java是一门支持多线程的语言，因此容器也必然会在多线程并发的环境下运行。&lt;/p&gt;
&lt;p&gt;　　　　jdk的向量数据结构，&lt;strong&gt;Vector&lt;/strong&gt;主要通过对方法添加&lt;strong&gt;synchronized&lt;/strong&gt;关键字，用&lt;strong&gt;悲观锁&lt;/strong&gt;来实现线程安全，效率较低。而另一个向量的实现，&lt;strong&gt;ArrayList&lt;/strong&gt;则是采用了快速失败的，基于版本号的&lt;strong&gt;乐观锁&lt;/strong&gt;对并发提供一定的支持。&lt;/p&gt;
&lt;h4&gt;　　　　2.没有站在足够高的角度构建数据结构容器的关系&lt;/h4&gt;
&lt;p&gt;　　　　java在设计自身的数据结构容器的架构时，高屋建瓴的设计出了一个庞大复杂的集合类型关系。这使得java的数据结构容器&lt;strong&gt;API&lt;/strong&gt;接口非常的灵活，各种内部实现迥然不同的容器可以很轻松的互相转化，使用者可以无负担的切换所使用的数据结构容器。同时，这样的设计也使编写出抽象程度很高的API接口成为可能，减少了大量的重复代码。&lt;/p&gt;
&lt;h4&gt;　　　　3.接口不够丰富&lt;/h4&gt;
&lt;p&gt;　　　　限于篇幅，这里仅仅列举和介绍了主要的向量接口，还有许多常见的需求接口没有实现。其实，在理解了前面内容的基础之上，实现一些其它常用的接口也并不困难。&lt;/p&gt;
&lt;h4&gt;　　　　4.异常处理不够严谨&lt;/h4&gt;
&lt;p&gt;　　　　在当前版本的下标越界校验中，没有对容器可能产生的各种异常进行仔细的归类和设计，抛出的是最基础的&lt;strong&gt;RunTimeException，&lt;/strong&gt;这使得用户无法针对容器抛出的异常类型进行更加细致的处理。&lt;/p&gt;
&lt;h3&gt;　　5.3 &quot;自己动手实现java数据结构&quot;系列博客后续&lt;/h3&gt;
&lt;p&gt;　　这是&quot;自己动手实现java数据结构&quot;系列的第一篇博客，因此选择了相对比较简单的&quot;&lt;strong&gt;向量&lt;/strong&gt;&quot;数据结构入手。&lt;/p&gt;
&lt;p&gt;　　我的目标并不在于写出非常完善的数据结构实现，而是尝试着用&lt;strong&gt;最易于接受的方式&lt;/strong&gt;使大家&lt;strong&gt;熟悉常用的数据结构&lt;/strong&gt;。如果读者能够在阅读这篇博客之后，在理解思路，原理的基础之上，自己动手实现一个初级，原始的向量数据结构，以及在此基础上进行优化，那么这篇博客的目标就完美达成啦。&lt;/p&gt;
&lt;p&gt;　　本系列博客的代码在我的 github上：&lt;span&gt;https://github.com/1399852153/DataStructures&lt;/span&gt; ，欢迎交流 0.0。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:54:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.向量介绍 计算机程序主要运行在内存中，而内存在逻辑上可以被看做是连续的地址。为了充分利用这一特性，在主流的编程语言中都存在一种底层的被称为数组(Array)的数据结构与之对应。在使用数组时需要事先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html</dc:identifier>
</item>
<item>
<title>Linux资源分析工具杂谈(长文慎入) - SolidMango</title>
<link>http://www.cnblogs.com/pugang/p/10009896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pugang/p/10009896.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux资源分析工具杂谈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       开篇之前请大家先思考一个问题：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;       磁盘的平均I/O响应时间是1 ms，这个指标是好，还是差？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       众所周知，计算机科学是客观的，也就是说对于一个给定的问题，我们总是能给出明确的答案，比如我们网上购物买了两件100元的衣服，我们应该付款200元，但是系统给我们计算出的金额确是300元，我们可以明确的告诉商家，结果算错了。与此不同，性能却常常是主观的，甚至对性能问题的判断都可能是不准确的，比如我们刚刚提到的1ms，一定有人认为是好的，也有人认为是差的，要客观的回答这个问题，可能是一项系统性的工作，必须需要首先定义基准（基准定义本身相对复杂，内容可以写一本书，在此不做深入讨论），有了基准指标，通过比较才能得出合理的结论。表1列出了一些数值，期望可以使大家对计算机科学的一些延时有一个粗略的概念，表中以一个3.3GHZ主频的CPU一次访问寄存器为基准进行说明，比如如果我们认为计算机世界中一次寄存器访问的时间0.3纳秒是现实生活中的1秒，那么访问一次内存的相对时间就是6分钟，表1中参考数据源自互联网。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213210143-848508298.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;509&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1. 计算机科学中的延时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       软件发展到今天可谓日新月异，短短的几十年中极大的提高了人类的生产力。伴随着软件功能的发展，软件的复杂度也在几何级的增长，从经济性的角度来讲，人们总是希望投入更少的硬件资源，更少的电力，更少的时间来完成更多的生产任务，人们期望自己的每一度电，每一分钟时间都在用在有意义的生产活动中。面对复杂的软件，我们如何知道软件在做有意义的事情而不是在无意义的阻塞，或者系统的哪一部分确实存在性能瓶颈，比如内存太小，硬盘太慢，CPU太慢等等。系统性能分析可以在不同的维度进行审视，常用的维度有负载分析和资源分析，本文希望从资源分析的角度对相关的工具进行讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       中国有句古话，工欲善其事，必先利其器，人类文明进步的最重要的标志就是可以在对的时候使用对的工具。但是问题来了，什么是对的时候使用对的工具？前人对问题总结后分成了三类，第一种是理解问题，也知道如何解决问题，第二种是理解问题，但是以个人的能力无法解决问题，第三类问题是不知道问题的存在，更不知道如何解决问题。第一种问题和第二种问题我们称之为基础问题，因为我们可以通过个人能力或者团队合作解决这类问题，第三种问题未知的未知才是我们需要重点关注的问题，理论上来说，在一个成熟的软件开发周期中，不允许存在未知的未知，我们需要对系统的各个层次都有透彻的理解和深入的把握。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当今世界的三大主流操作系统Linux, Windows NT, Mac OS都提供了系统的工具集来监控，排查各类性能问题，比如Windows平台上Mark Russinovich的Sysinternals工具集，Windbg工具集，Linux 平台上的Sysstat工具集, Brendan Gregg力推的DTrace工具集。为了解决已知和未知的问题，我们首先需要对操作系统和硬件的相关指标有一个基础的认识，否则即使有了适合的工具，统计出了详尽的结果，我们仍然无法透彻的理解软件和系统发生了什么。如图1所示是性能分析大神Brendan Gregg对常用的性能分析工具进行的详尽总结。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213325906-1951116992.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1. Linux Performance Tools&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       下面我们对图1中的一些常用基础分析工具以及应用场景进行简单的分析。常用的性能分析工具包括：uptime, vmstat, mpstat, sar, ps, top, pidstat等等，这些命令的简单描述请见表2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213506920-662989955.png&quot; alt=&quot;&quot; width=&quot;657&quot; height=&quot;357&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表2. 常用性能分析工具简单描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       系统发生CPU性能问题时通常第一个使用的命令是uptime和top，uptime命令输出系统过去1分钟，5分钟和15分钟的平均负载，通过这三个数值可以粗略的分析出系统过去15分钟内负载是降低了，升高了，或者是持平，uptime运行结果如图2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213616090-1892950589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2. uptime运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       多核系统分析中接下来要使用的命令通常是mpstat，我们可以通过mpstat对CPU的每个核的使用情况都进行监控，mpstat不仅可以对每个核心的数据进行分别统计，还可以对所有核心的平均使用情况进行统计，mpstat运行结果如图3所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213700254-486566474.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;263&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3. mpstat运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当我们使用top发现某一个进程的CPU或者其他资源使用异常的时候，我们可能需要引入第三个命令pidstat，我们甚至可以将这一统计数据精确到具体的线程。Top和pidstat运行结果见图4和图5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213746744-1275884705.png&quot; alt=&quot;&quot; width=&quot;1265&quot; height=&quot;726&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4. Top运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213811347-2123799377.png&quot; alt=&quot;&quot; width=&quot;1263&quot; height=&quot;447&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5. Pidstat分线程运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当我们需要对tcp流量进行简单统计，又不愿意要引入更复杂的tcpdump网络监控的时候，sar命令是个不错的选择，当然，统计网络流量只是sar的一个功能而已，更多功能可以参考sar man page， 使用sar命令统计tcp流量运行结果如图6所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213908268-460277872.png&quot; alt=&quot;&quot; width=&quot;1268&quot; height=&quot;556&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6. sar命令统计tcp流量运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       限于篇幅的原因，此处不再一一讨论图1中的每一个命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;进阶篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;       动态追踪是一种高级调试技术可以帮助开发人员以非常低的成本快速排查和解决软件性能问题。当今世界软件面临的问题一是规模，二是复杂度。随着 BPF 追踪系统（基于时间采样）最后一个主要功能被合并至 Linux 4.9-rc1 版本的内核中，Linux内核拥有了类似DTrace的原生追踪功能。DTrace是Solaris系统中的高级追踪器，功能强大，对于长期使用 DTrace 的用户，这是一个振奋人心的消息，现在Linux系统上可以在生产环境中使用安全的、低负载的定制追踪系统，通过执行时间的柱状图和频率统计等信息，分析应用的性能以及内核。最初用于Linux的追踪项目有很多，但是这个最终被合并进Linux内核的技术从一开始就根本不是一个追踪项目：它最开始是用于伯克利包过滤器 Berkeley Packet Filter（BPF）的一个增强功能。这些补丁允许BPF重定向数据包，从而创建软件定义网络。久而久之，对事件追踪的支持就被添加进来了，使得程序追踪可用于Linux系统。BPF Compiler Collection (BCC), PLY 和 BPFTRACE都是正在开发的BPF前端，BCC架构如图7所示，下面以BCC为例对Linux动态追踪技术进行简单说明，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123213947648-393501706.png&quot; alt=&quot;&quot; width=&quot;1193&quot; height=&quot;835&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7. Linux BCC/BPF Tracing Tools&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       假设我们有这样一个场景，系统中偶尔会运行新的进程，这些新的进程可能会消耗大量系统资源，从而对我们生产上运行的环境产生干扰，但是这种进程可能运行时间极为短暂，我们怎样才能知道发生了这种情况呢？top？可能不行，时间太短了，可能top还没来得及统计，进程已经退出了。这种情况下最适合使用的工具之一就是BCC工具集中的execsnoop，图8中可以看出，每一个新启动的进程都会被记录在案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214023414-1879492529.png&quot; alt=&quot;&quot; width=&quot;1245&quot; height=&quot;492&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8. Execsnoop命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       网络程序开发中我们可能想要按照TCP连接来统计一下通信两端的吞吐量和生命周期，这个时候tcplife就派上用场了，tcplife对TCP会话的生命周期和吞吐量统计如图9所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214050846-1867111544.png&quot; alt=&quot;&quot; width=&quot;1334&quot; height=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9. Tcplife命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于一个给定的进程，我们甚至可以要求内核通过BPF统计CPU处理之外时间的内核和用户堆栈，具体使用方法和示例请见图10。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/60039/201811/60039-20181123214111639-731792182.png&quot; alt=&quot;&quot; width=&quot;1345&quot; height=&quot;1275&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10 offcputime命令运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       本文对Linux资源分析相关的基础工具、高级工具以及典型应用场景进行了简单的总结，算是抛砖引玉，希望对大家有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:45:00 +0000</pubDate>
<dc:creator>SolidMango</dc:creator>
<og:description>Linux资源分析工具杂谈 开篇之前请大家先思考一个问题： 磁盘的平均I/O响应时间是1 ms，这个指标是好，还是差？ 众所周知，计算机科学是客观的，也就是说对于一个给定的问题，我们总是能给出明确的答</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pugang/p/10009896.html</dc:identifier>
</item>
<item>
<title>基于mapreduce实现图的三角形计数 - 编程匠心者</title>
<link>http://www.cnblogs.com/brooksj/p/10009846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brooksj/p/10009846.html</guid>
<description>&lt;p&gt;源代码放在我的github上，想细致了解的可以访问：&lt;a href=&quot;https://github.com/tracy-talent/curriculum/tree/master/MapReduce/GraphTriangleCount&quot;&gt;TriangleCount on github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一实验要求&quot;&gt;一、实验要求&lt;/h2&gt;
&lt;h3 id=&quot;实验背景&quot;&gt;1.1 实验背景&lt;/h3&gt;
&lt;p&gt;        图的三角形计数问题是一个基本的图计算问题,是很多复杂网络分析(比如社交网络分析)的基础。目前图的三角形计数问题已经成为了 Spark 系统中 GraphX 图计算库所提供的一个算法级 API。本次实验任务就是要在 Hadoop 系统上实现图的三角形计数任务。&lt;/p&gt;
&lt;h3 id=&quot;实验任务&quot;&gt;1.2 实验任务&lt;/h3&gt;
&lt;p&gt;        一个社交网络可以看做是一张图(离散数学中的图)。社交网络中的人对应于图的顶点;社交网络中的人际关系对应于图中的边。在本次实验任务中,我们只考虑一种关系——用户之间的关注关系。假设“王五”在 Twitter/微博中关注了“李四”,则在社交网络图中,有一条对应的从“王五”指向“李四”的有向边。图 1 中展示了一个简单的社交网络图,人之间的关注关系通过图中的有向边标识了出来。本次的实验任务就是在给定的社交网络图中,统计图中所有三角形的数量。在统计前,需要先进行有向边到无向边的转换,依据如下逻辑转换:&lt;/p&gt;
&lt;center&gt;IF ( A→B) OR (B→A) THEN A-B&lt;/center&gt;
&lt;p&gt;        “A→B”表示从顶点 A 到顶点 B 有一条有向边。A-B 表示顶点 A 和顶点 B 之间有一条无向边。一个示例见图 1,图 1 右侧的图就是左侧的图去除边方向后对应的无向图。&lt;br/&gt;        &lt;strong&gt;请在无向图上统计三角形的个数&lt;/strong&gt;。在图 1 的例子中,一共有 3 个三角形。&lt;br/&gt;        本次实验将提供一个 &lt;a href=&quot;http://snap.stanford.edu/data/&quot;&gt;Twitter 局部关系图&lt;/a&gt;作为输入数据(给出的图是有向图),请统计该图对应的无向图中的三角形个数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/MR_triangle_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1 一个简单的社交网络示例。左侧的是一个社交网络图,右侧的图是将左侧图中的有向边转换为无向边后的无向图。&lt;/p&gt;
&lt;h3 id=&quot;输入说明&quot;&gt;1.3 输入说明&lt;/h3&gt;
&lt;p&gt;        输入数据仅一个文件。该文件由若干行组成,每一行由两个以空格分隔的整数组成:&lt;/p&gt;
&lt;center&gt;A B&lt;/center&gt;
&lt;p&gt;A,B 分别是两个顶点的 ID。这一行记录表示图中具有一条由 A 到 B 的有向边。整个图的结构由该文件唯一确定。&lt;br/&gt;下面的框中是文件部分内容的示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;87982906 17975898
17809581 35664799
524620711 270231980
247583674 230498574
348281617 255810948
159294262 230766095
14927205 5380672&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;扩展&quot;&gt;1.4 扩展&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;扩展一：挑战更大的数据集!使用 &lt;a href=&quot;http://snap.stanford.edu/data/&quot;&gt;Google+的社交关系网&lt;/a&gt;数据集作为输入数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;扩展二：考虑将逻辑转换由or改为and的三角形个数是多少，改变后的逻辑转换如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;IF ( A→B) AND (B→A) THEN A-B&lt;/center&gt;
&lt;h2 id=&quot;二实验设计与实现&quot;&gt;二、实验设计与实现&lt;/h2&gt;
&lt;h3 id=&quot;算法设计&quot;&gt;2.1 算法设计&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;step1：统计图中每一个点的度，不关心是入度还是出度，然后对统计到的所有点的度进行排序&lt;/li&gt;
&lt;li&gt;step2：将图中每一条单向边转换成双向边，对于图中a-&amp;gt;b and b-&amp;gt;a的两条边，分别转换后需要去重，在转换后的图中筛选出小度指向大度的边来建立邻接表，然后对每个点的邻接点按从小到大进行排序&lt;/li&gt;
&lt;li&gt;step3：对原图中的边进行转换，确保每条边是由数值小的点指向数值大的点并去重，然后遍历每一条边：求边的两个端点对应的邻接点集的交集大小即为包含这条边的三角形个数。对每条边对应的三角形个数进行累加即可得到全图包含的三角形个数。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;程序设计&quot;&gt;2.2 程序设计&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据算法步骤将程序设计成4个job来实现：
&lt;ol&gt;&lt;li&gt;job:OutDegreeStat用于对每个点的度进行统计，在类OutDegreeStat中实现&lt;/li&gt;
&lt;li&gt;job:SortedOutDegree用于对所有点的度进行排序，在类OutDegreeStat中实现，在job1之后运行&lt;/li&gt;
&lt;li&gt;job:EdgeConvert用于建立存储小度指向大度的边的邻接表，在类EdgeConvert中实现&lt;/li&gt;
&lt;li&gt;job:GraphTriangleCount用于遍历每条边求端点对应邻接点集的交集来对三角形进行计数，在类GraphTriangleCount中实现&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;程序实现&quot;&gt;2.3 程序实现&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;job:OutDegreeStat的实现：&lt;/p&gt;
&lt;ol readability=&quot;16.5&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;Map阶段：(vertex1: Text, vertex2: Text) -&amp;gt; (vertex1: Text, 1: IntWritable) and (vertex2: Text, 1: IntWritable)，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class OutDegreeStatMapper extends Mapper&amp;lt;Object, Text, Text, IntWritable&amp;gt; {
        private final IntWritable one = new IntWritable(1);

        @Override
        public void map(Object key, Text value, Context context)
                throws IOException, InterruptedException {
            String line = value.toString();
            StringTokenizer itr = new StringTokenizer(line);
            Text vertex1 = new Text(itr.nextToken());
            Text vertex2 = new Text(itr.nextToken());
            if (!vertex1.equals(vertex2)) {
                context.write(vertex1, one);
                context.write(vertex2, one);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;Reduce阶段：(vertex: Text, degree: Iterable&amp;lt;IntWritable&amp;gt;) -&amp;gt; (vertex: Text, degreeSum: IntWritable)，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class OutDegreeStatReducer extends Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt; {
        @Override
        public void reduce(Text key, Iterable&amp;lt;IntWritable&amp;gt; values, Context context)
                throws IOException, InterruptedException {
            int sum = 0;
            for (IntWritable val: values) {
                sum += val.get();
            }
            context.write(key, new IntWritable(sum));
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Combiner阶段：Combiner逻辑与Reduce逻辑一致，只是为了减少数据量从而减少通信开销&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;job:SortedOutDegree的实现：
&lt;ol&gt;&lt;li&gt;Map阶段：由于mapreduce的reduce阶段会按key进行排序，为了按度进行排序，只需用hadoop自带的InverseMapper类对键值对做逆映射(vertex: Text, degree: IntWritable) -&amp;gt; (degree: IntWritable, vertex: Text)即可。&lt;/li&gt;
&lt;li&gt;Reduce阶段：无需设置Reducer类，hadoop的Reduce阶段自动会对degree进行排序&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;job:EdgeConvert的实现：&lt;/p&gt;
&lt;ol readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;Map阶段：(vertex1: Text, vertex2: Text) -&amp;gt; (vertex1: Text, vertex2: Text) and (vertex2: Text, vertex1: Text)，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static class EdgeConvertMapper extends Mapper&amp;lt;Object, Text, Text, Text&amp;gt; {
        @Override
        public void map(Object key, Text value, Context context)
                throws IOException, InterruptedException {
            StringTokenizer itr = new StringTokenizer(value.toString());
            Text vertex1 = new Text(itr.nextToken());
            Text vertex2 = new Text(itr.nextToken());
            if (!vertex1.equals(vertex2)) {
                context.write(vertex1, vertex2);
                context.write(vertex2, vertex1);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;Reduce阶段：在setup函数中读取存储节点度的文件，在reduce函数中(vertex1: Text, vertex2List: iterable&amp;lt;Text&amp;gt;) -&amp;gt; (vertex1 with minimal degree: Text, vertex2 with maximal degree: Text)，==在对邻接表节点进行排序时，要重写一个String Comparator，让String按它所表示的数值大小进行比较，==实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class EdgeConvertReducer extends Reducer&amp;lt;Text, Text, Text, Text&amp;gt; {
        private Map&amp;lt;String, Integer&amp;gt; degree;
        private Map&amp;lt;String, Boolean&amp;gt; edgeExisted;
        private URI[] cacheFiles;

        @Override
        public void setup(Context context)
                throws IOException, InterruptedException {
            degree = new HashMap&amp;lt;String, Integer&amp;gt;();

            //读取存储节点度的文件
            Configuration conf = context.getConfiguration();
            cacheFiles = context.getCacheFiles();
            for (int i = 0; i &amp;lt; cacheFiles.length; i++) {
                SequenceFile.Reader reader = new SequenceFile.Reader(conf, SequenceFile.Reader.file(new Path(cacheFiles[i])));
                IntWritable key = new IntWritable();
                Text value = new Text();
                int cnt = 0;
                while (reader.next(key, value)) {
                    degree.put(value.toString(), cnt);
                    cnt++;
                }
                reader.close();
            }
        }

        @Override
        public void reduce(Text key, Iterable&amp;lt;Text&amp;gt; values, Context context)
                throws IOException, InterruptedException{
            Text vertex = new Text();
            List&amp;lt;String&amp;gt; outvertex = new ArrayList&amp;lt;String&amp;gt;();
            edgeExisted = new HashMap&amp;lt;String, Boolean&amp;gt;();  //记录已处理边以避免重复统计
            for (Text val: values) {
                if (!edgeExisted.containsKey(val.toString())) {
                    edgeExisted.put(val.toString(), true);
                    //比较边两个端点的度大小
                    if (degree.get(val.toString()) &amp;gt; degree.get(key.toString())) {
                        outvertex.add(val.toString());
                    }
                }
            }
            //对邻接节点从小到大进行排序，方便后续求交集
            Collections.sort(outvertex, new ComparatorString());
            for (String vt: outvertex) {
                vertex.set(vt);
                context.write(key, vertex);
            }
        }
    }

    //继承String比较器按它所表示的数值大小进行比较
    public static class ComparatorString implements Comparator&amp;lt;String&amp;gt; {
        public int compare(String a, String b) {
            if (a.length() &amp;gt; b.length()) {
                return 1;
            } else if (a.length() &amp;lt; b.length()){
                return -1;
            } else {
                return a.compareTo(b);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;job:GraphTriangleCount的实现：&lt;/p&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;Map阶段：以job:EdgeConvert的输出文件作为读入，该文件不包含重复边因此无需判断转换，直接按原样映射(vertex1: Text, vertex2: Text) -&amp;gt; (vertex1: Text, vertex2: Text)即可，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class GraphTriangleCountMapper extends Mapper&amp;lt;Text, Text, Text, Text&amp;gt; {
        @Override
        public void map(Text key, Text value, Context context)
                throws IOException, InterruptedException{
            context.write(key, value);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;Reduce阶段：在setup函数中读取存储小度指向大度的邻接表文件，在reduce函数中(vertex1: Text, vertex2List: Iterable&amp;lt;Text&amp;gt;) -&amp;gt; (&quot;TriangleNum&quot;: Text, triangleNum: LongWritable)，在cleanup函数中写当前这个reducer的三角形计数结果，实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class GraphTriangleCountReducer extends Reducer&amp;lt;Text, Text, Text, LongWritable&amp;gt; {
        private final static String edgePath = TriangleCountDriver.HDFS_PATH + TriangleCountDriver.EdgeConvertPath;  //邻接表文件路径
        private Map&amp;lt;String, Integer&amp;gt; vexIndex;  //存储节点的邻接表索引
        private ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; vec = new ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt;();  //存储全局邻接表
        private long triangleNum = 0;

        @Override
        public void setup(Context context)
                throws IOException, InterruptedException {
            int cnt = 0;
            String lastVertex = &quot;&quot;;
            String sv, tv;
            ArrayList&amp;lt;String&amp;gt; outVertices = new ArrayList&amp;lt;String&amp;gt;();
            vexIndex = new TreeMap&amp;lt;String, Integer&amp;gt;();
            //获取文件系统的接口
            Configuration conf = context.getConfiguration();
            FileSystem fs = FileSystem.get(conf);
            //读取小度指向大度的边邻接表
            for (FileStatus fst: fs.listStatus(new Path(edgePath))) {
                if (!fst.getPath().getName().startsWith(&quot;_&quot;)) {
                    SequenceFile.Reader reader = new SequenceFile.Reader(conf, SequenceFile.Reader.file(fst.getPath()));
                    Text key = new Text();
                    Text value = new Text();
                    while (reader.next(key, value)) {
                        sv = key.toString();
                        tv = value.toString();
                        if (!sv.equals(lastVertex)) {
                            if (cnt != 0) vec.add(outVertices);
                            vexIndex.put(sv, cnt);
                            cnt++;
                            outVertices = new ArrayList&amp;lt;String&amp;gt;();
                            outVertices.add(tv);
                        } else {
                            outVertices.add(tv);
                        }
                        lastVertex = sv;
                    }
                    reader.close();
                }
            }
            vec.add(outVertices);
        }


        @Override
        public void reduce(Text key, Iterable&amp;lt;Text&amp;gt; values, Context context)
                throws IOException, InterruptedException{
            for (Text val: values)
                if (vexIndex.containsKey(val.toString()))
                    //调用求交集函数获取包含边(key,val)的三角形个数
                    triangleNum += intersect(vec.get(vexIndex.get(key.toString())), vec.get(vexIndex.get(val.toString())));
        }

        @Override
        public void cleanup(Context context) throws IOException, InterruptedException{
            //将计数结果写入文件
            context.write(new Text(&quot;TriangleNum&quot;), new LongWritable(triangleNum));
        }

        //求有序集合的交集
        private long intersect(ArrayList&amp;lt;String&amp;gt; avex, ArrayList&amp;lt;String&amp;gt; bvex) {
            long num = 0;
            int i = 0, j = 0;
            int cv;
            while (i != avex.size() &amp;amp;&amp;amp; j != bvex.size()) {
                if (avex.get(i).length() &amp;gt; bvex.get(j).length()) {
                    cv = 1;
                } else if (avex.get(i).length() &amp;lt; bvex.get(j).length()) {
                    cv = -1;
                } else {
                    cv = avex.get(i).compareTo(bvex.get(j));
                }
                if (cv == 0) {
                    i++;
                    j++;
                    num++;
                } else if (cv &amp;gt; 0) {
                    j++;
                } else {
                    i++;
                }
            }
            return num;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;扩展2的设计与实现&quot;&gt;2.4 扩展2的设计与实现&lt;/h3&gt;
&lt;h2 id=&quot;三性能分析与优化&quot;&gt;三、性能分析与优化&lt;/h2&gt;
&lt;h3 id=&quot;性能分析&quot;&gt;3.1 性能分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;该算法的性能瓶颈在遍历每一条边然后边两个端节点对应邻接表的交集，然后对每个顶点出发的邻接表进行排序也比较耗时，算法整体的时间复杂度是O(E^1.5^)，E为边的数目&lt;/li&gt;
&lt;li&gt;目前这个1.0版本的实现鲁棒性比较好，节点编号用Text存储，所以无论节点编号多大都可以存储以及比较，输入的图可以允许重复边的出现，不会影响结果的正确性。但由于mapreduce涉及大量的排序过程，用Text存储节点也就意味着使用字符串排序，字符串之间的比较当然比整型比较开销大，从而会影响程序的整体性能。除此之外，hadoop需要对数据进行序列化之后才能在网络上传输，数据以文本文件输入导致大量的数据序列化转换也会降低程序性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;性能优化&quot;&gt;3.2 性能优化&lt;/h3&gt;
&lt;p&gt;2.0版本，在1.0的版本上进行了数据储存和表示方面的优化，相同实验环境(6个Reducer，每个Reducer2G物理内存，Reducer中的java heapsize -Xmx2048m)跑Goolge+数据能快50s左右，具体优化细节如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将离散化稀疏的节点转换成顺序化的，这样就可以用IntWritabel表示节点(前提是节点数未超过INT_MAX)而不用Text来表示节点编号，这样就可以避免字符串排序，减少map和reduce阶段的排序开销&lt;/li&gt;
&lt;li&gt;将原始Text输入文件转换成Sequence，因为hadoop传输在网络上的数据是序列化的，这样可以避免数据的序列化转换开销。但是由于数据是串行转换的，影响整体性能，但是可以在第一次运行过后存起来，以后运行直接加载sequence的数据文件即可。这一步是和第一步顺序化节点一起完成的，转换后的sequence文件存储的是顺序化的节点表示的边。&lt;/li&gt;
&lt;li&gt;在a-&amp;gt;b and b-&amp;gt;a then a-b的条件下，在获取小度指向大度的边集任务中，mapper需要将一条边的点对合并为key以在reducer中判断是否是双向边，看似只能用Text来存储了，实则这里有一个trick，在对节点顺序化之后的节点数通常不会超过INT_MAX，因此可以使用考虑将两个int型表示的节点转换成long,key存储在高32位，value存储在低32位，通过简单的位操作即可实现，这样mapper输出的key就是long而非Text，从而避免了字符串的比较排序，由于mapreduce涉及大量排序过程，因此在涉及程序的时候尽量用一些trick避免用Text表示key.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三程序运行结果及时耗&quot;&gt;三、程序运行结果及时耗&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;实验环境：CPU型号Intel(R) Xeon(R) CPU E5-2630 v2 @ 2.60GHz，双物理CPU，单CPU6核12线程，所以一共24个虚拟核，程序设置6个reducer，每个reducer配置2GB物理内存，reducer中的java heapsize配置-Xmx2048m&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;==&quot;or&quot;表示if a-&amp;gt;b or b-&amp;gt;a then a-b的情况，&quot;and&quot;表示if a-&amp;gt;b and b-&amp;gt;a then a-b的情况==&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.0版本的测试结果：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Twitter(or)&lt;/td&gt;
&lt;td&gt;13082506&lt;/td&gt;
&lt;td&gt;127s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Google+(or)&lt;/td&gt;
&lt;td&gt;1073677742&lt;/td&gt;
&lt;td&gt;278s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Twitter(and)&lt;/td&gt;
&lt;td&gt;1818304&lt;/td&gt;
&lt;td&gt;125s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Goolge+(and)&lt;/td&gt;
&lt;td&gt;27018510&lt;/td&gt;
&lt;td&gt;156s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;2.0版本的测试结果(不包含输入文件转换的时间)：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Twitter(or)&lt;/td&gt;
&lt;td&gt;13082506&lt;/td&gt;
&lt;td&gt;115s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Google+(or)&lt;/td&gt;
&lt;td&gt;1073677742&lt;/td&gt;
&lt;td&gt;230s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Twitter(and)&lt;/td&gt;
&lt;td&gt;1818304&lt;/td&gt;
&lt;td&gt;118s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Goolge+(and)&lt;/td&gt;
&lt;td&gt;27018510&lt;/td&gt;
&lt;td&gt;181s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;评估：&lt;/strong&gt;2.0版本相对1.0版本在节点数据类型上作了优化，当数据量很大的时候，or情况的性能有显著的提升，Google+数据比1.0版本快了差不多50s左右，但是and情况下2.0版本跑Google+数据性能却下降了，个人猜测可能是job:UnidirectionalEdgeConvert中的Mapper，Reducer，Partitioner，比较函数中涉及大量的位操作或者int与long之间的类型转换，这个开销比1.0版本的对字符串排序开销更大。目前没有很好的想法来避免频繁的位操作与类型转换，有idea的朋友可以给我留言~&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:32:00 +0000</pubDate>
<dc:creator>编程匠心者</dc:creator>
<og:description>源代码放在我的github上，想细致了解的可以访问：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brooksj/p/10009846.html</dc:identifier>
</item>
<item>
<title>Python使用Ctypes与C/C++ DLL文件通信过程介绍及实例分析 - alpha_panda</title>
<link>http://www.cnblogs.com/yssjun/p/9960479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yssjun/p/9960479.html</guid>
<description>&lt;p&gt;项目中可能会经常用到第三方库，主要是出于程序效率考虑和节约开发时间避免重复造轮子。无论第三方库开源与否，编程语言是否与当前项目一致，我们最终的目的是在当前编程环境中调用库中的方法并得到结果或者借助库中的模块实现某种功能。这个过程会牵涉到很多东西，本篇文章将简要的介绍一下该过程的一些问题。&lt;/p&gt;
&lt;h3&gt;1.背景&lt;/h3&gt;
&lt;p&gt;多语言混合编程可以弥补某一种编程语言在性能表现或者是功能等方面的不足。虽然所有的高级语言都会最终转换成汇编指令或者最底层的机器指令，但是语言本身之间的千差万别很难一言以蔽之，这对不同语言之间相互通信造成很大的障碍。&lt;/p&gt;
&lt;p&gt;工作中需要用python完成一项功能，但是所有现有的python库都不满足需求。最终找到了一个开源的C++库，编译得到动态库被python调用才完成工作需求。虽然整个过程耗时不多，但是期间碰到很多的问题，而且这些问题都很有思考价值。&lt;/p&gt;
&lt;p&gt;除了这篇博文外，后续还将有一到两篇文章通过具体的实例讲解一下跨语言调用。&lt;/p&gt;
&lt;h3&gt;2.问题思考&lt;/h3&gt;
&lt;p&gt;在进行具体的介绍之前，先来思考一下调用外部库或者自己实现库所牵涉的一些一般性的问题。这样或许实际中操作使用时会理解的更加深刻，遇到问题也能够逐项的排查。&lt;/p&gt;
&lt;p&gt;如果用C语言写的库调用了Linux的system call，纵使C本身是跨平台的，那么该库也不可能在Window上被使用，即便我们能拿到源码。这里有两个核心问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否开源&lt;/li&gt;
&lt;li&gt;是否跨平台&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果库的实现不依赖平台，且开源，那就意味着很大可能能在当前项目中使用。为什么是可能，因为即使库的实现语言和当前项目语言一致，也可能因为语言版本差异或者标准迭代导致不兼容。&lt;/p&gt;
&lt;p&gt; 最差的情况就是只能拿到编译后的库文件，且需在特定的平台运行。&lt;/p&gt;
&lt;p&gt;作为库的开发者，最好是能够开源且库的实现不依赖于特定的平台，这样才能最大限度的被使用。&lt;/p&gt;
&lt;p&gt;作为库的使用者，最不理想的情况是库可以在当前平台使用，但是只能拿到静态库或者动态库，且库的实现语言和当前项目语言不一致。&lt;/p&gt;
&lt;p&gt;多数情况是第三方库是跨平台的且能够拿到源代码。这样的话如果两者的实现语言一致，我们可以直接将第三方库的代码移植到当前的项目中；如果实现语言不一致，需要在当前平台上将库的源码编译出当前平台上可用的库文件，然后在当前项目中引用编译生成的库文件。&lt;/p&gt;
&lt;p&gt;本文将先简单的介绍在window平台上，使用python 2.7 自带的ctypes库引用标准的C动态库msvcrt.dll。这里可以先思考以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;python可不可以引用静态库？&lt;/li&gt;
&lt;li&gt;python中怎么拿到DLL导出的函数？&lt;/li&gt;
&lt;li&gt;python和C/C++之间的变量的类型怎样转换，如果是自定义的类型呢？&lt;/li&gt;
&lt;li&gt;怎么处理函数调用约定(calling convention，eg:__cdecl,__stdcall,__thiscall,__fastcall)可能不同的问题？&lt;/li&gt;
&lt;li&gt;如果调用DLL库的过程中出现问题，是我们调用的问题还是库本身的问题？应该怎样快速排查和定位问题？&lt;/li&gt;
&lt;li&gt;有没有什么现有的框架能够帮我们处理python中引用第三方库的问题呢？&lt;/li&gt;
&lt;li&gt;对于自定义的类型（class 和 struct）是否能在python中被引用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于函数调用约定，有必要简单的提一下：&lt;/p&gt;
&lt;p&gt;Calling Convention和具体的编程语言无关，是由编译器、连接器和操作系统平台这些因素共同决定的。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The Visual C++ compilers allow you to specify conventions for passing arguments and return values between functions and callers. Not all conventions are available on all supported platforms, and some conventions use platform-specific implementations. In most cases, keywords or compiler switches that specify an unsupported convention on a particular platform are ignored, and the platform default convention is used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是MS的官方解释。注意最后一句话，表示对于函数调用，在平台不支持的情况下，语言中指定关键字或者编译器转换均可能无效。&lt;/p&gt;
&lt;p&gt;接下的介绍中来我们将一一回答上面的问题。&lt;/p&gt;
&lt;h3&gt;2.导入C标准动态库&lt;/h3&gt;
&lt;p&gt;先来简单看一下python中如何引用C的标准动态库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ctypes, platform, time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; platform.system() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     libc = ctypes.cdll.LoadLibrary(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msvcrt.dll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;elif&lt;/span&gt; platform.system() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     libc = ctypes.cdll.LoadLibrary(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;libc.so.6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; libc
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Example 1&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; libc.printf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib c printf function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; libc.printf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ctypes.c_char_p(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib c printf function with c_char_p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; libc.printf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%ls\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ctypes.c_wchar_p(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib c printf function with c_wchar_p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; libc.printf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 12&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; libc.printf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%f\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ctypes.c_double(1.2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Example 2&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; libc.sin.restype =&lt;span&gt; ctypes.c_double
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; libc.sin(ctypes.c_double(30 * 3.14 / 180&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Example 3&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; libc.pow.restype =&lt;span&gt; ctypes.c_double
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; libc.pow(ctypes.c_double(2), ctypes.c_double(10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Example 4&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; libc.time(), time.time()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Example 5&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; libc.strcpy.restype =&lt;span&gt; ctypes.c_char_p
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; res = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; libc.strcpy(ctypes.c_char_p(res), ctypes.c_char_p(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; res
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们一一分析上面的这段代码。&lt;/p&gt;
&lt;h4&gt;2.1 加载库的方式&lt;/h4&gt;
&lt;p&gt;根据当前平台分别加载Windows和Linux上的C的标准动态库msvcrt.dll和libc.so.6。&lt;/p&gt;
&lt;p&gt; 注意这里我们使用的ctypes.cdll来load动态库，实际上ctypes中总共有以下四种方式加载动态库：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;em class=&quot;property&quot;&gt;class&lt;/em&gt; &lt;code class=&quot;descclassname&quot;&gt;ctypes.&lt;/code&gt;&lt;strong&gt;&lt;code class=&quot;descname&quot;&gt;CDLL&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode=DEFAULT_MODE&lt;/em&gt;, &lt;em&gt;handle=None&lt;/em&gt;, &lt;em&gt;use_errno=False&lt;/em&gt;, &lt;em&gt;use_last_error=False&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;em class=&quot;property&quot;&gt;class&lt;/em&gt; &lt;code class=&quot;descclassname&quot;&gt;ctypes.&lt;/code&gt;&lt;strong&gt;&lt;code class=&quot;descname&quot;&gt;OleDLL&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode=DEFAULT_MODE&lt;/em&gt;, &lt;em&gt;handle=None&lt;/em&gt;, &lt;em&gt;use_errno=False&lt;/em&gt;, &lt;em&gt;use_last_error=False&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;em class=&quot;property&quot;&gt;class&lt;/em&gt; &lt;code class=&quot;descclassname&quot;&gt;ctypes.&lt;/code&gt;&lt;strong&gt;&lt;code class=&quot;descname&quot;&gt;WinDLL&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode=DEFAULT_MODE&lt;/em&gt;, &lt;em&gt;handle=None&lt;/em&gt;, &lt;em&gt;use_errno=False&lt;/em&gt;, &lt;em&gt;use_last_error=False&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;em class=&quot;property&quot;&gt;class&lt;/em&gt; &lt;code class=&quot;descclassname&quot;&gt;ctypes.&lt;/code&gt;&lt;strong&gt;&lt;code class=&quot;descname&quot;&gt;PyDLL&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;name&lt;/em&gt;, &lt;em&gt;mode=DEFAULT_MODE&lt;/em&gt;, &lt;em&gt;handle=None&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于这几个加载动态库的方式区别细节可以参考一下官网的说明，这里仅简要说明一下。&lt;/p&gt;
&lt;p&gt; 除了PyDll用于直接调用Python C api函数之外，其他的三个主要区别在于&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用的平台；&lt;/li&gt;
&lt;li&gt;被加载动态库中函数的调用约定(calling convention)；&lt;/li&gt;
&lt;li&gt;库中函数假定的默认返回值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 也就是平台和被加载动态库中函数的调用约定决定了我们应该使用哪种方式加载动态库。&lt;/p&gt;
&lt;p&gt;本例中我们在windows平台上使用的是CDLL而不是WinDll，原因是msvcrt.dll中函数调用约定是C/C++默认的调用约定__cdecl。&lt;/p&gt;
&lt;p&gt;而WinDll虽然是可以应用于windows平台上，但是其只能加载标准函数调用约定为__stdcall的动态库。因此这里只能使用CDLL方式。&lt;/p&gt;
&lt;p&gt;可以将上面的CDLL换成WinDll看一下会不会有问题。这里应该能够对函数调用理解的更加深刻一些了，同时也回答了上面第一小节中我们提问的问题4。&lt;/p&gt;
&lt;h4&gt;2.2 跨语言类型转换&lt;/h4&gt;
&lt;p&gt; 这里主要针对第一节提出的问题3。&lt;/p&gt;
&lt;p&gt;我们是在python中调用C的函数，函数实参是python类型的变量，函数形参则是C类型的变量，显然我们将python类型的变量直接赋值给C类型的变量肯定会有问题的。&lt;/p&gt;
&lt;p&gt;因此这里需要两种语言变量类型之间有一一转换的必要。这里仅仅列出部分对应关系(由于博客园的表格显示会有问题，因此这样列出，请见谅)：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python type　　　　　　　　&lt;/strong&gt;Ctypes type　　　　　　　　　　&lt;strong&gt;C type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;int/long　　　　　　　　　　   c_int　　　　　　　　　　　　　int&lt;/p&gt;
&lt;p&gt;float　　　　　　　　　　　　 c_double　　　　　　　　　　　double&lt;/p&gt;
&lt;p&gt;string or &lt;code class=&quot;docutils literal&quot;&gt;None&lt;/code&gt;　　　　　　　　c_char_p　　　　　　　　　　　char&lt;code class=&quot;xref c c-type docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt; &lt;span class=&quot;pre&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; (NUL terminated)&lt;/p&gt;
&lt;p&gt;unicode or &lt;code class=&quot;docutils literal&quot;&gt;None&lt;/code&gt;　　　　　　　c_wchar_p　　　　　　　　　　wchar_t&lt;code class=&quot;xref c c-type docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt; &lt;span class=&quot;pre&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; (NUL terminated)&lt;/p&gt;
&lt;p&gt; 通过Ctypes type中提供类型，我们建立了一种python类型到c类型的一种转换关系。&lt;/p&gt;
&lt;p&gt;在看一下上面的例子Example 1。在调用C的函数时，我们传给C函数的实参需要经过Ctypes转换成C类型之后才能正确的调用C的函数。&lt;/p&gt;
&lt;h4&gt;2.3 设定C函数的返回类型&lt;/h4&gt;
&lt;p&gt;看一下上面的例子Example 2.&lt;/p&gt;
&lt;p&gt;libc.sin.restype = ctypes.c_double&lt;/p&gt;
&lt;p&gt;我们通过restype的方式指定了C(math 模块)函数sin的返回类型为double，对应到python即为float。显然函数的返回类型在DLL中是无法获取的。&lt;/p&gt;
&lt;p&gt;开发人员也只能从库的说明文档或者头文件中获取到函数的声明，进而指定函数返回值的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;/span&gt; sin (&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sin (&lt;span&gt;float&lt;/span&gt;&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; sin (&lt;span&gt;long&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sin (T x);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; additional overloads for integral types&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是C++11中cmath中sin函数的声明。这里几个sin函数是C++中的函数重载。&lt;/p&gt;
&lt;pre&gt;
libc.sin(ctypes.c_double(30 * 3.14 / 180&lt;span&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;由于调用之前指定了sin函数的返回类型ctypes.c_double，因此sin的调用结果在python中最终会转换为float类型。&lt;/p&gt;
&lt;h4&gt;2.4 假定的函数返回类型&lt;/h4&gt;
&lt;p&gt;由于我们在动态库中获取的函数并不知道其返回类型，因为我们只得到了函数的实现，并没有函数的声明。&lt;/p&gt;
&lt;p&gt;在没有指定库函数返回类型的情况下，&lt;code class=&quot;descclassname&quot;&gt;ctypes.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;CDLL&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;和ctyps.WinDll&lt;/code&gt;均假定函数返回类型是int，而ctypes.oleDll则假定函数返回值是Windows HRESULT。&lt;/p&gt;
&lt;p&gt;那如果函数实际的返回值不是int，便会按照int返回值处理。如果返回类型能转为int类型是可以的，如果不支持那函数调用的结果会是一个莫名其妙的数字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
time_t time (time_t* timer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  上面的例子Example 4则默认将C类型time_t转为了python 的int类型，结果是正确的。&lt;/p&gt;
&lt;p&gt;对于Example 3中我们不仅要指定函数pow的返回类型，还要转换函数的实参（这里很容易疏忽）。&lt;/p&gt;
&lt;p&gt;因此在调用动态库之前一定要看下函数声明，指定函数返回类型。&lt;/p&gt;
&lt;p&gt;到这里很容易想到可以指定函数的返回值类型，那能不能指定函数形参的类型呢？答案是肯定的，&lt;span class=&quot;fontstyle0&quot;&gt;argtypes 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
printf.argtypes = [c_char_p, c_char_p, c_int, c_double]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.5 可变string buffer&lt;/h4&gt;
&lt;p&gt; 上面的例子Exapmle 5中我们调用了C中的一个字符串拷贝函数strcpy，这里函数的返回值和被拷贝的对象均为正确的。&lt;/p&gt;
&lt;p&gt;但是这里是故意这样写的，因为这里会有一个问题。&lt;/p&gt;
&lt;p&gt;如果res = 'Hello'改为res = 'He'和res = 'HelloWorld'，那么实际上res的结果会是‘Wo’和'World\x00orld'。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
str_buf = ctypes.create_string_buffer(10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; ctypes.sizeof(str_buf)             　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; repr(str_buf.raw)                  　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'&lt;/span&gt;
str_buf.raw = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cnblogs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; repr(str_buf.raw)                  　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'Cnblogs\x00\x00\x00'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; repr(str_buf.value)                　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'Cnblogs'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以通过ctypes.create_string_buffer来指定一个字符串缓存区。&lt;/p&gt;
&lt;p&gt;使用string buffer改写Example 5:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
libc.strcpy.restype =&lt;span&gt; ctypes.c_char_p
res &lt;/span&gt;= ctypes.create_string_buffer(len(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; libc.strcpy(res, ctypes.c_char_p(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; repr(res.raw), res.value            　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'World\x00' 'World'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意上面的res的类型是c_char_Array_xxx。这里只是为了介绍string buffer，实际上不会这么用。&lt;/p&gt;
&lt;h4&gt;2.6 小节&lt;/h4&gt;
&lt;p&gt;这里简单的介绍了一下ctypes如何和动态库打交道。限于篇幅还有指针，引用类型和数组等的传递，以及自定义类型等没有介绍。但是这一小结应该能对python引用动态库过程有一个大致的认识。&lt;/p&gt;
&lt;p&gt;更加详细信息可以参考官网：&lt;a href=&quot;https://docs.python.org/2/library/ctypes.html&quot; target=&quot;_blank&quot;&gt;ctypes&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3. 自定义DLL文件导入&lt;/h3&gt;
&lt;p&gt;为了更好的理解python调用DLL的过程，有必要了解一下DLL的定义文件。&lt;/p&gt;
&lt;h4&gt;3.1 C/C++引用DLL&lt;/h4&gt;
&lt;p&gt;首先，作为对比我们看一下C/C++如何引用DLL文件的。下面的文件是 &lt;em&gt;.&lt;/em&gt;/Project2/Source2.cpp&lt;/p&gt;
&lt;p&gt;工程配置为：Conguration Properties&amp;gt;General&amp;gt;Configuration Types: &lt;strong&gt;Dynamic Library (.dll)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出路径：&lt;strong&gt;./Debug/Project2.dll&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;math.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#ifdef _MSC_VER
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DLL_EXPORT extern &quot;C&quot; __declspec( dllexport )
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DLL_EXPORT
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; __declspec(dllexport) &lt;span&gt;char&lt;/span&gt;* gl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gl_str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; DLL_EXPORT &lt;span&gt;void&lt;/span&gt; __stdcall hello_world(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s Hello world!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, gl);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; DLL_EXPORT &lt;span&gt;int&lt;/span&gt; my_add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calling my_add@int func\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DLL_EXPORT double my_add(double a, double b) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;calling my_add@double func\n&quot;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return a + b;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; DLL_EXPORT &lt;span&gt;int&lt;/span&gt; my_mod(&lt;span&gt;int&lt;/span&gt; m, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; m %&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; DLL_EXPORT &lt;span&gt;bool&lt;/span&gt; is_equal(&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fabs(a - b) &amp;lt; 1e-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; DLL_EXPORT &lt;span&gt;void&lt;/span&gt; my_swap(&lt;span&gt;int&lt;/span&gt; *p, &lt;span&gt;int&lt;/span&gt; *&lt;span&gt;q) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; tmp = *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     *p = *&lt;span&gt;q;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     *q =&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; swap_char(&lt;span&gt;char&lt;/span&gt; *p, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;q) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; tmp = *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     *p = *&lt;span&gt;q;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     *q =&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; DLL_EXPORT &lt;span&gt;void&lt;/span&gt; reverse_string(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;const&lt;/span&gt;&lt;span&gt; p) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = strlen(p) - &lt;span&gt;1&lt;/span&gt;; i &amp;lt; j; ++i, --&lt;span&gt;j)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             swap_char(p + i, p +&lt;span&gt; j);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;swap_char(&amp;amp;p[i], &amp;amp;p[j]);&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下面的文件是&lt;em&gt; .&lt;/em&gt;/Project1/Source1.cpp&lt;/p&gt;
&lt;p&gt;工程配置为：Conguration Properties&amp;gt;General&amp;gt;Configuration Types:&lt;strong&gt; Application (.exe)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出路径：&lt;strong&gt;./Debug/Project1.exe&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cstdlib&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;../Debug/Project2.lib&quot;)
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#ifdef _MSC_VER
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DLL_IMPORT extern &quot;C&quot; __declspec( dllimport )
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DLL_IMPORT
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; DLL_IMPORT &lt;span&gt;void&lt;/span&gt; __stdcall hello_world(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; DLL_IMPORT &lt;span&gt;int&lt;/span&gt; my_add(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; DLL_IMPORT &lt;span&gt;int&lt;/span&gt; my_mod(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; DLL_IMPORT &lt;span&gt;bool&lt;/span&gt; is_equal(&lt;span&gt;double&lt;/span&gt;, &lt;span&gt;double&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; DLL_IMPORT &lt;span&gt;void&lt;/span&gt; my_swap(&lt;span&gt;int&lt;/span&gt;*, &lt;span&gt;int&lt;/span&gt;*&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; DLL_IMPORT &lt;span&gt;void&lt;/span&gt; reverse_string(&lt;span&gt;char&lt;/span&gt;* &lt;span&gt;const&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; __declspec(dllimport) &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; gl;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;, b = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; s[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    hello_world();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     my_swap(&amp;amp;a, &amp;amp;&lt;span&gt;b);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    reverse_string(s);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL str gl: %s \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, gl);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL func my_add: %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, my_add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL func my_mod: %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, my_mod(&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL func my_comp: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, is_equal(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1.0001&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL func my_swap: (%d, %d)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a, b);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLL func reverse_string: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面的这个例子已经清楚的展示了C/C++如何导出和引用DLL文件。有以下几点需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上面#pragma comment(lib, &quot;../Debug/Project2.lib&quot;)中引用的是生成Project2.dll过程中产生的导出库，并非静态库。&lt;/li&gt;
&lt;li&gt;__declspec声明只在Windows平台用，若是引用静态库，则不需要__declspec声明。&lt;/li&gt;
&lt;li&gt;不管动态库还是静态库，除了用#pragma comment引用lib文件外，还可以在Conguration Properties&amp;gt;Linker&amp;gt;Input&amp;gt;Additional Dependencies中添加lib文件。&lt;/li&gt;
&lt;li&gt;上面例子中我们导出和引用均声明了extern &quot;C&quot;，表示让编译器以C的方式编译和链接文件。意味着导出的函数不支持重载，且函数调用约定为C和C++的默认调用约定__cdecl。&lt;/li&gt;
&lt;li&gt;DLL_EXPORT void __stdcall hello_world(void)指定了函数使用__stdcall的Calling Convention，该方式声明优先于编译器默认的__cdecl方式。&lt;/li&gt;
&lt;li&gt;不同的调用约定不仅会影响实际的函数调用过程，还会影响编译输出函数的命名。比如函数hello_world以__cdecl方式和__stdcall方式输出到DLL中的函数分别为hello_world和_hello_world@0。&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;3.2 python引用DLL&lt;/h4&gt;
&lt;p&gt;先使用VS自带的dumpbin工具看一下Project2.dll文件部分内容：&lt;/p&gt;
&lt;p&gt;dumpbin -exports &quot;./Debug/project2.dll&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ordinal hint RVA      name

&lt;/span&gt;1    0 00018000&lt;span&gt; ?gl@@3PADA
&lt;/span&gt;2    1 00011217&lt;span&gt; _hello_world@0
&lt;/span&gt;3    2 00011046&lt;span&gt; is_equal
&lt;/span&gt;4    3&lt;span&gt; 0001109B my_add
&lt;/span&gt;5    4&lt;span&gt; 000112D0 my_mod
&lt;/span&gt;6    5 00011005&lt;span&gt; my_swap
&lt;/span&gt;7    6 0001118B reverse_string
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 话不多说，先上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ctypes, platform, time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; platform.system() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     my_lib = ctypes.cdll.LoadLibrary(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.\Debug\Project2.dll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; my_lib = ctypes.CDLL(r'.\Debug\Project2.dll')&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;elif&lt;/span&gt; platform.system() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     my_lib = ctypes.cdll.LoadLibrary(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;libc.so.6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] __declspec(dllexport) char* gl = &quot;gl_str&quot;;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; ctypes.c_char_p.in_dll(my_lib, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?gl@@3PADA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).value　　　　&lt;span&gt;# result: gl_str
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT void __stdcall hello_world(void);&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; getattr(my_lib, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_hello_world@0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)()　　　　&lt;span&gt;# result: gl_str Hello world!
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT int my_add(int, int);&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; my_lib.my_add(1, 2&lt;span&gt;)　　　　　　　　　&lt;span&gt;# result: 3&lt;/span&gt;　　　　　　　　　　　　　　　　　
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT int my_mod(int, int);&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; my_lib.my_mod(123, 200&lt;span&gt;)　　　　&lt;span&gt;# result: 123
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT void my_swap(int*, int*); &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; a, b = 111, 222
&lt;span&gt;22&lt;/span&gt; pa, pb =&lt;span&gt; ctypes.pointer(ctypes.c_int(a)), ctypes.pointer(ctypes.c_int(b))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;my_lib.my_swap(pa, pb)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; pa.contents.value, pb.contents.value　　&lt;span&gt;# result: 222, 111
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; a, b　　　　&lt;span&gt;# result: 111, 222
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT bool is_equal(double, double);&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; my_lib.is_equal.restype =&lt;span&gt; ctypes.c_bool
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; my_lib.is_equal.argtypes =&lt;span&gt; [ctypes.c_double, ctypes.c_double]
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print my_lib.is_equal(ctypes.c_double(1.0), ctypes.c_double(1.0001))&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; my_lib.is_equal(1.0, 1.0001&lt;span&gt;)　　　　&lt;span&gt;# result: True
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; my_lib.is_equal(1.0, 1.0100&lt;span&gt;)　　　　&lt;span&gt;# result: False
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [C++] DLL_IMPORT void reverse_string(char *const);&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; ps =&lt;span&gt; ctypes.pointer(ctypes.c_char_p(s))
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; ps.contents　　　　&lt;span&gt;# result： c_char_p('123456')
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;my_lib.reverse_string(ctypes.c_char_p(s))
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; ps.contents, s　　&lt;span&gt;# result: c_char_p('654321') 654321&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面的代码加上注释和结果已经很详细的说明了python引用DLL的过程，限于篇幅，这里就不在赘述。&lt;/p&gt;
&lt;p&gt;有一点需要强调，我们使用__stdcall方式声明函数hello_world方式，并且用CDLL方式引入。导致无法直接用lib.func_name的方式访问函数hello_world。&lt;/p&gt;
&lt;p&gt;如果想要使用my_lib.hello_world的方式调用该函数，只需要使用windll的方式引入DLL，或者使用默认的__cdecl方式声明hello_world。&lt;/p&gt;
&lt;h3&gt;4 总结&lt;/h3&gt;
&lt;p&gt;先来看一下开始提问的问题，部分问题已经在文中说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.python可不可以引用静态库？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，静态库是会在链接的过程组装到可执行文件中的，静态库是C/C++代码。&lt;/p&gt;
&lt;p&gt;其次，python是一种解释性语言，非静态语言，不需要编译链接。&lt;/p&gt;
&lt;p&gt;最后，官网好像没有提供对应的对接模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.如果调用DLL库的过程中出现问题，是我们调用的问题还是库本身的问题？应该怎样快速排查和定位问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;python中怎么定位问题这个不多说。&lt;/p&gt;
&lt;p&gt;DLL中的问题可以使用VS的attach to process功能，将VS Attach 到当前运行的python程序，然后调用到DLL，加断点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.有没有什么现有的框架能够帮我们处理python中引用第三方库的问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的有ctypes，swig, cython, boost.python等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.对于自定义的类型（class 和 struct）是否能在python中被引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至少ctypes中没有相关的操作。&lt;/p&gt;
&lt;p&gt;其实也没必要，因为不仅python中没有对应的类型，而且完全可以通过将自定义的类或者结构体封装在DLL输出的函数接口中进行访问等操作。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;本文使用python自带的库ctypes介绍了如果引用动态库DLL文件，相对于其他的第三方库，这是一个相对比较低级的DLL包装库。但正是因为这样我们才能看清楚调用DLL过程的一些细节。&lt;/p&gt;
&lt;p&gt;使用ctypes过程遇到的每一个错误都可能是一个我们未知的知识点，因此建议先熟悉该库，尽可能深入的了解一下python调用动态库的过程。其他的库原理是一样的，只不过进行了更高级的封装而已。&lt;/p&gt;

</description>
<pubDate>Fri, 23 Nov 2018 13:23:00 +0000</pubDate>
<dc:creator>alpha_panda</dc:creator>
<og:description>项目中可能会经常用到第三方库，主要是出于程序效率考虑和节约开发时间避免重复造轮子。无论第三方库开源与否，编程语言是否与当前项目一致，我们最终的目的是在当前编程环境中调用库中的方法并得到结果或者借助库中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yssjun/p/9960479.html</dc:identifier>
</item>
<item>
<title>Python-字符版gif图 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/10008985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/10008985.html</guid>
<description>&lt;h3&gt;一、背景&lt;/h3&gt;
&lt;p&gt;    上一篇文章我们讲了怎么做自己的炫酷二维码，需要的移驾&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/10004080.html&quot; target=&quot;_blank&quot;&gt;Python-炫酷二维码&lt;/a&gt;，本片文章我们讲述下怎么把一张图片处理成字符版图片，就是说使用字符替代每个像素的颜色，形成一个由字符组成的图片，并且字符的颜色是由原始的图片像素颜色决定&lt;/p&gt;
&lt;h3&gt;二、准备环境&lt;/h3&gt;
&lt;p&gt;    对图片的操作我们可以使用PIL、imageio和image2gif库，处理像素我们选择使用opencv-python这个库。NumPy是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。因此我们需要安装以下几个包：PIL、imageio、numpy、cv2、images2gif&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;pip install pillow
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;pip install imageio
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;pip install numpy
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; pip install opencv-&lt;span&gt;python
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; pip install images2gif
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    以上扩展包安装时应该都可以顺利安装，但使用的时候有几个坑&lt;/p&gt;
&lt;p&gt;1、导入cv2时，如果发生找不到dll的情况，大多数的原因都是当前的python版本和opencv版本不匹配，pip安装时默认选择了最新的版本，因此我们安装时需要&lt;strong&gt;指定安装的版本pip install opencv-python==3.4.1.15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、使用images2gif这个库时，可能会出现无法导入writeGif接口的情况这个时候需要改下源码，把images2gif.py文件中的两个from 后边加上英文点号，修改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; .images2gif &lt;span&gt;import&lt;/span&gt;&lt;span&gt; readGif as readGif
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; .images2gif &lt;span&gt;import&lt;/span&gt; writeGif as writeGif
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、字符版动态图&lt;/h3&gt;
&lt;p&gt;    首先我们需要搞清楚gif是个什么玩意儿，其实gif是将多幅图像保存为一个图像文件，从而形成动画，最常见的就是通过一帧帧的动画串联起来的搞笑gif图，所以归根到底gif仍然是图片文件格式。&lt;/p&gt;
&lt;p&gt;什么？原来gif就是一帧一帧的图片，那么字符版动态图其实也就是字符版图片的连续播放，思考到这儿，我们有了如下思路：&lt;/p&gt;
&lt;p&gt;1、拿到一张gif图&lt;/p&gt;
&lt;p&gt;2、把fig图拆分成多张png图片，或者其他格式的图片&lt;/p&gt;
&lt;p&gt;3、循环遍历拆分后的图片，并处理成字符版图片&lt;/p&gt;
&lt;p&gt;4、把处理后的字符版图片在连接成一个guf文件&lt;/p&gt;
&lt;p&gt;5、保存gif文件&lt;/p&gt;
&lt;p&gt;    通过以上5个步骤，我们即可实现我们的需求，是不是很简单，下边我们分布来讲解实现过程&lt;/p&gt;
&lt;h3&gt;四、gif和png转换&lt;/h3&gt;
&lt;p&gt;1、要想获得静态图片，我们需要有一个gif图，然后把gif图拆分成多张png图片，以下是3中处理gif图片的方式&lt;/p&gt;
&lt;p&gt;方式1，使用Image&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Gif2Png():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     gif =&lt;span&gt; Image.open(gifpath)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             current =&lt;span&gt; gif.tell()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             gif.save(saveFloder + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/%d.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; current)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             gif.seek(current + 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2，使用Image&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Gif2Png_2():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         im =&lt;span&gt; Image.open(gifpath)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IOError:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cant load&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, gifpath)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         sys.exit(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     i =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     mypalette =&lt;span&gt; im.getpalette()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            im.putpalette(mypalette)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             frame = im.convert(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGBA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             new_im = Image.new(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGBA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, im.size)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;new_im.paste(im)&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            new_im.paste(frame)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             new_im.save(saveFloder + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\%d.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             i += 1
&lt;span&gt;20&lt;/span&gt;             im.seek(im.tell() + 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; EOFError:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end of sequence&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用imageio处理gif图&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Gif2Png_3():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     images =&lt;span&gt; imageio.mimread(gifpath)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把上面的每帧图片进行保存&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i, img &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(images):
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         img =&lt;span&gt; np.asarray(img)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         imageio.imwrite(saveFloder + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\%d.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % i, img)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   生成png效果如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181123183536001-1923450775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、把图片处理成gif图，以下是处理的两种方式&lt;/p&gt;
&lt;p&gt;方式1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Png2Gif():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     fileOrder = sorted([int(os.path.splitext(x)[0]) &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(savePath)])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     frames =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; order &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fileOrder:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         filename = str(order)+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         filePath = savePath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; filename
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        frames.append(imageio.imread(filePath))
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     
&lt;span&gt;9&lt;/span&gt;     imageio.mimsave(newFilePath, frames, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GIF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, duration = 0.1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Png2Gif_2():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     fileOrder = sorted([int(os.path.splitext(x)[0]) &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(savePath)])
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     filenames = []         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储所需要读取的图片名称&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; order &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fileOrder:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         filename = str(order)+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         filePath = savePath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; filename
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         filenames.append(filePath)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将使用的读取图片汇总&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;     frames =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; image_name &lt;span&gt;in&lt;/span&gt; filenames:                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 索引各自目录&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         im = Image.open(image_name)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将图片打开，本文图片读取的结果是RGBA格式，如果直接读取的RGB则不需要下面那一步&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         im = im.convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过convert将RGBA格式转化为RGB格式，以便后续处理 &lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         im = np.array(im)                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; im还不是数组格式，通过此方法将im转化为数组&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         frames.append(im)                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 批量化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     writeGif(newFilePath, frames, duration=0.1, subRectangles=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成GIF，其中durantion是延迟，这里是1ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、处理动态图片&lt;/h3&gt;
&lt;p&gt;    生成字符版gif图时，如果把拆分开来的图片先进行保存硬盘，然后在进行图片处理在合成最终gif效率会比较慢，因此我们把整个过程都放在内容中处理，即拆分开来的png图片不进行存盘，而是直接处理，然后在合成gif图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Gif2Gif(gifpath):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     A =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     images =&lt;span&gt; imageio.mimread(gifpath)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把上面的每帧图片进行保存&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; img &lt;span&gt;in&lt;/span&gt;&lt;span&gt; images:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         u, v, channels =&lt;span&gt; img.shape
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         c = img * 0 + 255
&lt;span&gt; 8&lt;/span&gt;         gray =&lt;span&gt; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, u, 6&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(0, v, 6&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 pix =&lt;span&gt; gray[i, j]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 b, g, r, a =&lt;span&gt; img[i, j]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 zifu = string[int(((len(string) - 1) * pix) / 256&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; a !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     cv2.putText(c, zifu, (j, i), cv2.FONT_HERSHEY_COMPLEX, 0.3&lt;span&gt;, (int(b), int(g), int(r), int(a)))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        A.append(c)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     oldFileName =&lt;span&gt; os.path.splitext(os.path.basename(gifpath))[0]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     newFilePath = os.getcwd() + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/{}/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(saveFloder) + oldFileName +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_new.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     imageio.mimsave(newFilePath, A, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GIF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, duration=0.1) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源代码中是支持批量生成字符版gif图，测试生成效果如下图所示，左侧是原始图，右侧是生成的效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181123183056656-1785697987.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;355&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181123183114740-1118961119.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;六、字符版动态二维码&lt;/h3&gt;
&lt;p&gt;有了普通的gif图生成动态二维码的方式，字符版gif图也就顺理成章的可以。&lt;/p&gt;
&lt;p&gt;测试生成效果如下图所示，左侧是原始图，右侧是生成的效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181123182401301-639056929.gif&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;384&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181123182345656-2012140329.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;七、源码下载&lt;/h3&gt;
&lt;p&gt;　　需要全部代码的到csdn直接下载：&lt;a href=&quot;https://download.csdn.net/download/qq_30392343/10803747&quot; target=&quot;_blank&quot;&gt;Python-字符版gif图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载声明：本站文章无特别说明，皆为原创，版权所有，转载请注明：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot; target=&quot;_blank&quot;&gt;朝十晚八&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 13:18:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>一、背景 上一篇文章我们讲了怎么做自己的炫酷二维码，需要的移驾Python-炫酷二维码，本片文章我们讲述下怎么把一张图片处理成字符版图片，就是说使用字符替代每个像素的颜色，形成一个由字符组成的图片，并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swarmbees/p/10008985.html</dc:identifier>
</item>
</channel>
</rss>