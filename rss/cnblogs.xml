<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据溢出 - 随性者也</title>
<link>http://www.cnblogs.com/zhugaopeng/p/9949890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhugaopeng/p/9949890.html</guid>
<description>&lt;p&gt;基本数据类型分两大类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整型&lt;/li&gt;
&lt;li&gt;浮点型&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;整型包括char,short,int,long,long long&lt;/li&gt;
&lt;li&gt;除此之外，整型还有无符号类型unsigned ...&lt;/li&gt;
&lt;li&gt;浮点型包括float,double,long double&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;规则：&lt;/p&gt;&lt;p&gt;short至少16位，int至少和short一样长；&lt;/p&gt;&lt;p&gt;long至少32位，至少和int一样长；&lt;/p&gt;&lt;p&gt;long long至少64位，至少和long一样长。&lt;/p&gt;&lt;p&gt;float至少4个字节；&lt;/p&gt;&lt;p&gt;double至少6个字节，并且不少于float；&lt;/p&gt;&lt;p&gt;long double至少和double一样长。&lt;/p&gt;

&lt;p&gt;不同的系统环境，数据范围有所不同；32位/64位操作系统，数据范围也有所不同。&lt;/p&gt;&lt;p&gt;可以通过代码来确定不同的范围：&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;c语言定义了一系列的宏&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;limits.h&amp;gt;

int main()
{
    printf(&quot;max integer: %d\n&quot;, INT_MAX);
    printf(&quot;min integer: %d\n&quot;, INT_MIN);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;C++ 数值极限&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;limits&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; numeric_limits&amp;lt;int&amp;gt;::max() &amp;lt;&amp;lt; endl;
    std::cout &amp;lt;&amp;lt; numeric_limits&amp;lt;int&amp;gt;::min() &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;介绍个亲身遇到的数据溢出的问题。&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据压缩后还原导致溢出&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int d = 0;
long value = d * 1000 + 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面一段代码就有发生数据溢出的可能。当变量d足够大时，再乘以1000就会溢出。结果可想而知，是一个相对小的数值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//可以这样改写，就不会出现问题
long value = (long)d * 1000 + 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;C/C++基本数据类型，每一种都有范围。在选择数据类型要注意合适的范围，否则会造成数据溢出，产生难以发现的bug。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 12 Nov 2018 15:23:00 +0000</pubDate>
<dc:creator>随性者也</dc:creator>
<og:description>基本数据类型 基本数据类型分两大类： 1. 整型 2. 浮点型 整型包括char,short,int,long,long long 除此之外，整型还有无符号类型unsigned ... 浮点型包括fl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhugaopeng/p/9949890.html</dc:identifier>
</item>
<item>
<title>SCI软件使用方法总结-定位测量篇 - ZROSE</title>
<link>http://www.cnblogs.com/sx-software-zys/p/9949865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sx-software-zys/p/9949865.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SCI软件使用方法总结-定位测量篇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、    流程图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个视觉项目的流程图的框架大体是：相机初始化、变量初始化、…、指令接受、IF条件判断、SWITCH分支、循环、结果输出；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、    算子块内部算子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定位测量：&lt;/strong&gt;载入图像、标定、确定ROI基准（通过一条直线的角度和两条直线的交点、或者一条直线和一个中心点）、找直线（圆、交点等）、找角度、找点等；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; A：标定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是确定一个像素格代表的实际尺寸是多少，以便软件处理结果的表示（方法不完整，待补充）；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：ROI模板定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般方法：（1）在划定的区域找到一条直线，用来确定模板的角度；然后用灰度匹配、blob分析、直线交点等方法，确定一个点；这样一个点和一条直线就能确定一个平面（准确来说是确定一个坐标平面，用来确定当前平面的坐标信息），然后通过坐标转换，这样就能确定样品的实际位置；最后是用ROI基准设置功能完成定位，选择相应的直线角度和灰度匹配（或者blob分析、直线交点）所确定的点即可；&lt;/p&gt;
&lt;p&gt;                 （2）如果工件来料比较规则，没有角度的变化，也可以选用一个点来做定位点，不需要角度（这种情况较少），简称&lt;strong&gt;无角度定位&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C：&lt;/strong&gt;如果是测量直线的长度以及距离，则直接在图像中找到相应的直线，然后用点（直线的中点）到直线的距离、直线到直线的距离、或者两条直线的交点到直线的距离来确定两条直线的距离（即一条线段的宽度，比如用两条长边的距离来求矩形的宽，用两条短边的距离来求矩形的长）；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：使用找直线的算子的时候，设置中使用最多的是边缘强度（对比度）和搜索线个数（选择合适的数量可以减小误差，提高精度，一般设置在100~200&lt;/strong&gt;&lt;strong&gt;）；剔除距离和剔除比例是固定的，不用改变；边缘宽度一般不超过10&lt;/strong&gt;&lt;strong&gt;（会影响精度），投影宽度也基本不用改变，使用默认的数值就好！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>ZROSE</dc:creator>
<og:description>SCI软件使用方法总结-定位测量篇 一、 流程图 一个视觉项目的流程图的框架大体是：相机初始化、变量初始化、…、指令接受、IF条件判断、SWITCH分支、循环、结果输出； 二、 算子块内部算子 定位测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sx-software-zys/p/9949865.html</dc:identifier>
</item>
<item>
<title>一篇完全了解java关键字synchronized - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/9949767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/9949767.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: synchronized解析&lt;br/&gt;tags: java 锁&lt;br/&gt;author: 辰砂&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一总体概述图&quot;&gt;一、总体概述图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225501788-42765647.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二实现原理&quot;&gt;二、实现原理&lt;/h2&gt;
&lt;h4 id=&quot;monitorenter&quot;&gt;monitorenter：&lt;br/&gt;&lt;/h4&gt;
&lt;p&gt;　　每个对象有一个monitor，即监视器，当且仅当monitor被占用时，这个monitor就被锁住了。线程执行monitorenter指令是为了尝试获取该monitor的所有权，过程为：&lt;br/&gt;　　1） 如果一个monitor的进入数为0，那么该线程直接进入monitor，并且将monitor进入数置为1，该线程成为该monitor的所有者；&lt;br/&gt;　　2） 如果该进程是已经占用该monitor，则直接进入，并且monitor进入数加1；&lt;br/&gt;　　3）如果该进程未占有该monitor，即monitor被其他线程所占有，那么该线程会被阻塞，直到该monitor的进入数变为0，此时该线程会再次尝试获取该monitor。&lt;br/&gt;　　&lt;/p&gt;
&lt;h4 id=&quot;monitorexit&quot;&gt;　monitorexit：&lt;br/&gt;&lt;/h4&gt;
&lt;p&gt;　　执行monitorexit指令的线程必须是已经拥有该monitor的线程，执行monitorexit指令后，该monitor的进入数减1，直到该monitor的进入数减为0，此时该线程不再是该monitor的所有者，其他被阻塞进入该monitor的线程可以尝试获取该monitor的所有权。&lt;br/&gt;　　这就是synchronized的实现原理。其实，wait/notify/notifyAll也是基于monitor对象实现的，这也是为什么只有在同步块中才能使用wait/notify/notifyAll方法。&lt;/p&gt;
&lt;p&gt;如果用synchronized修饰方法，会是怎样呢？我们用javap -verbose命令反编译下面的程序，其中-verbose表示输出堆栈大小、各方法的locals及args数，以及class文件的编译版本：&lt;br/&gt;我们发现在方法体内部没有monitorenter和monitorexit指令，但是注意我箭头表示的地方，有一个ACC_SYNCHRONIZED标志，JVM就是通过该标志来判断是否需要实现同步的，具体过程为：当线程执行该方法时，会先检查该方法是否标志了ACC_SYNCHRONIZED，如果标志了，线程需要先获取monitor，获取成功后才能调用方法，方法执行完后再释放monitor，在该线程调用方法期间，其他线程无法获取同一个monitor对象。其实本质上和synchronized块相同，只是同步方法是用一种隐式的方式来实现，而不是显式地通过字节码指令。&lt;/p&gt;
&lt;h2 id=&quot;三如何使用&quot;&gt;三、如何使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 同步一个代码块&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void func() {
    synchronized (this) {
        // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。&lt;/p&gt;
&lt;p&gt;对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; e1.func1());
    executorService.execute(() -&amp;gt; e1.func1());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&amp;gt; e1.func1());
    executorService.execute(() -&amp;gt; e2.func1());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 同步一个方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized void func () {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它和同步代码块一样，作用于同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 同步一个类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 同步一个静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized static void fun() {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用于整个类。&lt;/p&gt;
&lt;h2 id=&quot;四优化&quot;&gt;四、优化&lt;/h2&gt;
&lt;p&gt;这里的锁优化主要是指虚拟机对 synchronized 的优化。&lt;/p&gt;
&lt;h3 id=&quot;自旋锁&quot;&gt;1.自旋锁&lt;/h3&gt;
&lt;p&gt;互斥同步的进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。&lt;/p&gt;
&lt;p&gt;自选锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。&lt;/p&gt;
&lt;p&gt;在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。&lt;/p&gt;
&lt;h3 id=&quot;锁消除&quot;&gt;2.锁消除&lt;/h3&gt;
&lt;p&gt;锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。&lt;/p&gt;
&lt;p&gt;锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。&lt;/p&gt;
&lt;p&gt;对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会“逃逸”到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。&lt;/p&gt;
&lt;h3 id=&quot;锁粗化&quot;&gt;3.锁粗化&lt;/h3&gt;
&lt;p&gt;如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。&lt;/p&gt;
&lt;p&gt;上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。&lt;/p&gt;
&lt;h3 id=&quot;轻量级锁&quot;&gt;4.轻量级锁&lt;/h3&gt;
&lt;p&gt;JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。&lt;/p&gt;
&lt;p&gt;以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 mark word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出，应该注意的是 state 表格不是存储在对象头中的。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225524888-1002884409.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225535995-626801553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。&lt;/p&gt;
&lt;p&gt;当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225547985-1119977609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。&lt;/p&gt;
&lt;h3 id=&quot;偏向锁&quot;&gt;5.偏向锁&lt;/h3&gt;
&lt;p&gt;偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。&lt;/p&gt;
&lt;p&gt;当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。&lt;/p&gt;
&lt;p&gt;当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225559515-1190198114.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五和其他锁比较&quot;&gt;五、和其他锁比较&lt;/h2&gt;
&lt;h3 id=&quot;volatile和synchronized的区别&quot;&gt;1.volatile和synchronized的区别&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。&lt;/li&gt;
&lt;li&gt;volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的&lt;/li&gt;
&lt;li&gt;volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性&lt;/li&gt;
&lt;li&gt;volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。&lt;/li&gt;
&lt;li&gt;volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;synchronized-和-reentrantlock-比较&quot;&gt;2.synchronized 和 ReentrantLock 比较&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 锁的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等。目前来看它和 ReentrantLock 的性能基本持平了，因此性能因素不再是选择 ReentrantLock 的理由。synchronized 有更大的性能优化空间，应该优先考虑 synchronized。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ReentrantLock 多了一些高级功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 使用选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考 ：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CyC2018/CS-Notes&quot; class=&quot;uri&quot;&gt;https://github.com/CyC2018/CS-Notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网上优秀博客（自己以前笔记整理）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181112225825784-1824772415.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 14:56:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>title: synchronized解析 tags: java 锁 author: 辰砂 一、总体概述图 二、实现原理 monitorenter： 每个对象有一个monitor，即监视器，当且仅当m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/9949767.html</dc:identifier>
</item>
<item>
<title>用canvas实现红心飘飘的动画效果 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/9949401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/9949401.html</guid>
<description>&lt;p&gt;两周前，项目里需要实现一个红心飘飘的点赞效果。抓耳挠腮了老半天，看了几篇大佬的文章，终于算是摸了个七七八八。不禁长叹一声，还是菜啊。先来看一下效果:(&lt;a href=&quot;https://imgss.github.io/demo/11.11/&quot;&gt;传送门进去点一波&lt;/a&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201811/1016471-20181112222419915-1235328587.gif&quot; alt=&quot;kiss.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一bezier曲线运动轨迹&quot;&gt;一、Bezier曲线运动轨迹&lt;/h3&gt;
&lt;p&gt;其实用大白话描述一下需求就是让一个红心图片沿着贝塞尔曲线的轨迹走，然后边走边消失。核心在于得到贝塞尔曲线上的一系列点。本文不会讲解贝塞尔曲线的原理，因为大佬们已经讲过了，而且讲的比我好。参考文章如下：&lt;/p&gt;
&lt;p&gt;其中第二篇文章讲到了生成二阶和三阶贝塞尔曲线可以使用canvas自带的方法：&lt;code&gt;quadraticCurveTo&lt;/code&gt;和&lt;code&gt;bezierCurveTo&lt;/code&gt;,而高阶的则先得到曲线上一系列的点，然后顺次连接这些点来拟合高阶的贝塞尔曲线。没错，我们要的就是这一系列的点，有了这些点，就可以控制红心的轨迹了。下面是我基于作者的BezierMarker.js写的一个demo,可以直观地看出高阶贝塞尔曲线上的点：&lt;/p&gt;
&lt;p&gt;上面100个曲线上的点坐标是由下面这段代码计算得出的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;BezierMaker.prototype.bezier = function(t) { //贝塞尔公式调用
    var x = 0,
        y = 0,
        bezierCtrlNodesArr = this.bezierCtrlNodesArr,
        n = bezierCtrlNodesArr.length - 1,
        self = this
    bezierCtrlNodesArr.forEach(function(item, index) {
        if(!index) {
            x += item.x * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
            y += item.y * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
        } else {
            x += self.factorial(n) / self.factorial(index) / self.factorial(n - index) * item.x * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
            y += self.factorial(n) / self.factorial(index) / self.factorial(n - index) * item.y * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
        }
    })
    return {
        x: x,
        y: y
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法就是对贝塞尔公式的实现。以3阶贝塞尔公式为例(见下图)，它的方程需要四个控制点(P1,P2,P3,P4)和一个t值，就能计算出曲线上的某一点的坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?%7B%5Cmathbf%20%7BB%7D%7D%28t%29%3D%7B%5Cmathbf%20%7BP%7D%7D_%7B0%7D%281-t%29%5E%7B3%7D+3%7B%5Cmathbf%20%7BP%7D%7D_%7B1%7Dt%281-t%29%5E%7B2%7D+3%7B%5Cmathbf%20%7BP%7D%7D_%7B2%7Dt%5E%7B2%7D%281-t%29+%7B%5Cmathbf%20%7BP%7D%7D_%7B3%7Dt%5E%7B3%7D%7B%5Cmbox%7B%20%2C%20%7D%7Dt%5Cin%20%5B0%2C1%5D%25u3002&quot;/&gt;&lt;br/&gt;根据给定的&lt;code&gt;t&lt;/code&gt;值，结合控制点的坐标，算出相应&lt;code&gt;t&lt;/code&gt;值下的贝塞尔曲线上的点的坐标。拿下图(来自第一篇文章)来说，给定&lt;code&gt;t&lt;/code&gt;值为0.25,就可以得到B点的坐标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.mukewang.com/5a5586280001d25202400100.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当将&lt;code&gt;t&lt;/code&gt;由0递增到1时，就可以得到100个曲线上的点，进而拟合出相应的曲线。当我们拿到这一系列点时，其实问题已经解决了一大半了。&lt;/p&gt;
&lt;h3 id=&quot;二使红心飘起来&quot;&gt;二、使红心飘起来&lt;/h3&gt;
&lt;p&gt;拿到拟合点数组后，绘制轨迹就是从数组中依次拿出坐标，并将红心图片绘制到相应的坐标上。并根据当前拟合点在曲线数组中的位置，改变图片的不透明度，就可以让红心飘起来了，上一部分代码，讲解见注释：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 生成随机数
function rnd () {
  let flag = Math.random() &amp;gt; 0.5 ? 1 : -1
  return 80 * Math.random() * flag
}

class FlyHeart {
  constructor (ctx, img) {
    this.ctx = ctx;
    this.img = heart;
    // 拿到红心的运动轨迹，一系列拟合点坐标
    this.bezierArr = new BezierMaker(ctx, [
      {x: 187, y: 245},
      {x: 170 + rnd(), y: 200},
      {x: 200 + rnd() , y: 120}, 
      {x: 140 + rnd(), y: 60}], 90).bezierArr //90表示拟合点的数量，rnd使红心的轨迹有一定的随机性
  }
  draw () {
    // 依次取出轨迹的每个点
    let position = this.bezierArr.shift();
    
    // 清除上次画的
    this.clear();
    
    if (position) {
      this.ctx.save()
      // 根据当前数组长度算出透明度
      this.ctx.globalAlpha = this.bezierArr.length / 30;
      this.ctx.drawImage(this.img, position.x , position.y, 20, 20);
      this.ctx.restore();
      this.prevPosition = position;
    }
  }
  // 清除上次画的
  clear () {
    if (this.prevPosition) {
      this.ctx.clearRect(this.prevPosition.x, this.prevPosition.y, 20, 20);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是给body添加点击事件，当点击时，就新生成一个红心：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  document.body.addEventListener('click', function() {
    heartArr.push(new FlyHeart(ctx, heart));
  })
  
  let heartArr = []
  const cvs = document.getElementById('cvs')
  const ctx = cvs.getContext('2d')
  const heart = document.getElementById('heart') //图片
  
  function draw () {
    if(heartArr.length) {
      for(let heart of heartArr) {
        heart.draw();
        if(heart.bezierArr.length === 0) {
          heart.clear();
          let index = heartArr.indexOf(heart)
          heartArr.splice(index, 1)
        }
      }
    }
    requestAnimationFrame(draw)
  }
  draw()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三后记&quot;&gt;三、后记&lt;/h3&gt;
&lt;p&gt;当时看到这个需求的时候，真的是一筹莫展，看到n阶贝塞尔曲线时更是一头雾水，但是看不懂也要看，然后看着看着，看多了也就慢慢明白了。希望没浪费大家的时间，各位看官看完后有所收获（完）&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 14:54:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>两周前，项目里需要实现一个红心飘飘的点赞效果。抓耳挠腮了老半天，看了几篇大佬的文章，终于算是摸了个七七八八。不禁长叹一声，还是菜啊。先来看一下效果:(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/9949401.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用GraphQL - 第八章  在GraphQL中处理一对多关系 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9949559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9949559.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181112222346724-1486350176.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL - 目录&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;到目前为止我们一直在使用GraphQL操作单个实体。在本篇博文中，我们将使用GraphQL操作实体集合。&lt;/p&gt;
&lt;p&gt;这里我们使用的场景是处理一个顾客的所有订单，顾客和订单之间的关系是一对多。一个顾客可以有多个订单，相应的一个订单只属于一个顾客。&lt;/p&gt;
&lt;h3 id=&quot;数据库修改&quot;&gt;数据库修改&lt;/h3&gt;
&lt;p&gt;下面我们首先创建2个新的类&lt;code&gt;Customer&lt;/code&gt;和&lt;code&gt;Order&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;customer&quot;&gt;Customer&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public string BillingAddress { get; set; }
    public IEnumerable&amp;lt;Order&amp;gt; Orders { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;order&quot;&gt;Order&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Order
{
    public int OrderId { get; set; }
    public string Tag { get; set; }
    public DateTime CreatedAt { get; set; }

    public Customer Customer { get; set; }
    public int CustomerId { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改&lt;code&gt;ApplicationDbContext&lt;/code&gt;类，在&lt;code&gt;OnModelCreating&lt;/code&gt;配置一下表的主外键。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;modelBuilder.Entity&amp;lt;Customer&amp;gt;()
    .HasKey(p =&amp;gt; p.CustomerId);
modelBuilder.Entity&amp;lt;Customer&amp;gt;().HasMany(p =&amp;gt; p.Orders)
    .WithOne()
    .HasForeignKey(p =&amp;gt; p.CustomerId);

modelBuilder.Entity&amp;lt;Order&amp;gt;().HasKey(p =&amp;gt; p.OrderId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们使用如下命令创建迁移并更新数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet ef migrations add OneToManyRelationship  
dotnet ef database update &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此数据库修改完成。&lt;/p&gt;
&lt;h3 id=&quot;添加graphql代码&quot;&gt;添加GraphQL代码&lt;/h3&gt;
&lt;p&gt;下面我们需要添加GraphQL针对&lt;code&gt;Customer&lt;/code&gt;和&lt;code&gt;Order&lt;/code&gt;表的字段配置。&lt;/p&gt;
&lt;h5 id=&quot;ordertype&quot;&gt;OrderType&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class OrderType: ObjectGraphType &amp;lt;Order&amp;gt; {  
    public OrderType(IDataStore dataStore) {
        Field(o =&amp;gt; o.Tag);
        Field(o =&amp;gt; o.CreatedAt);
        Field &amp;lt;CustomerType, Customer&amp;gt; ()
            .Name(&quot;Customer&quot;)
            .ResolveAsync(ctx =&amp;gt; {
                return dataStore.GetCustomerByIdAsync(ctx.Source.CustomerId);
            });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;customertype.cs&quot;&gt;CustomerType.cs&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CustomerType: ObjectGraphType &amp;lt;Customer&amp;gt; {  
    public CustomerType(IDataStore dataStore) {
        Field(c =&amp;gt; c.Name);
        Field(c =&amp;gt; c.BillingAddress);
        Field &amp;lt;ListGraphType&amp;lt;OrderType&amp;gt; , IEnumerable&amp;lt;Order&amp;gt;&amp;gt; ()
            .Name(&quot;Orders&quot;)
            .ResolveAsync(ctx =&amp;gt; {
                return dataStore.GetOrdersByCustomerIdAsync(ctx.Source.CustomerId);
            });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了查询所有的顾客和订单，我们还需要暴露出2个新的节点。所以我们修改在&lt;code&gt;InventoryQuery&lt;/code&gt;构造函数中添加如下代码：&lt;/p&gt;
&lt;h5 id=&quot;inventoryquery&quot;&gt;InventoryQuery&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;ListGraphType&amp;lt;OrderType&amp;gt;, IEnumerable&amp;lt;Order&amp;gt;&amp;gt;()  
    .Name(&quot;Orders&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {
        return dataStore.GetOrdersAsync();
    });

Field&amp;lt;ListGraphType&amp;lt;CustomerType&amp;gt;, IEnumerable&amp;lt;Customer&amp;gt;&amp;gt;()  
    .Name(&quot;Customers&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {
        return dataStore.GetCustomersAsync();
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要在&lt;code&gt;IDataStore&lt;/code&gt;中定义6个新的方法，并在&lt;code&gt;DataStore&lt;/code&gt;中实现它们。&lt;/p&gt;
&lt;h5 id=&quot;idatastore&quot;&gt;IDataStore&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Task&amp;lt;IEnumerable&amp;lt;Order&amp;gt;&amp;gt; GetOrdersAsync();

Task&amp;lt;IEnumerable&amp;lt;Customer&amp;gt;&amp;gt; GetCustomersAsync();

Task&amp;lt;Customer&amp;gt; GetCustomerByIdAsync(int customerId);

Task&amp;lt;IEnumerable&amp;lt;Order&amp;gt;&amp;gt; GetOrdersByCustomerIdAsync(int customerId);

Task&amp;lt;Order&amp;gt; AddOrderAsync(Order order);

Task&amp;lt;Customer&amp;gt; AddCustomerAsync(Customer customer);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;datastore&quot;&gt;DataStore&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;IEnumerable&amp;lt;Order&amp;gt;&amp;gt; GetOrdersAsync()
{
    return await _context.Orders
        .AsNoTracking()
        .ToListAsync();
}

public async Task&amp;lt;IEnumerable&amp;lt;Customer&amp;gt;&amp;gt; GetCustomersAsync()
{
    return await _context.Customers
        .AsNoTracking()
        .ToListAsync();
}

public async Task&amp;lt;Customer&amp;gt; GetCustomerByIdAsync(int customerId)
{
    return await _context.Customers
        .FindAsync(customerId);
}

public async Task&amp;lt;IEnumerable&amp;lt;Order&amp;gt;&amp;gt; GetOrdersByCustomerIdAsync(int customerId)
{
    return await _context.Orders
        .Where(o =&amp;gt; o.CustomerId == customerId)
        .ToListAsync();
}

public async Task&amp;lt;Order&amp;gt; AddOrderAsync(Order order)  
{
    var addedOrder = await _context.Orders.AddAsync(order);
    await _context.SaveChangesAsync();
    return addedOrder.Entity;
}

public async Task&amp;lt;Customer&amp;gt; AddCustomerAsync(Customer customer)  
{         
    var addedCustomer = await _context.Customers.AddAsync(customer);
    await _context.SaveChangesAsync();
    return addedCustomer.Entity;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完以上代码之后，我们就需要定义添加订单和顾客的输入类型了。还记得在上一章中我们如何添加货物的么？我们添加了一个&lt;code&gt;ItemInputType&lt;/code&gt;类，定义了添加货物需要收集的字段，所以这里同理，我们也需要为订单和顾客定义对应的&lt;code&gt;InputObjectGraphType&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;orderinputtype&quot;&gt;OrderInputType&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class OrderInputType : InputObjectGraphType {  
    public OrderInputType()
    {
        Name = &quot;OrderInput&quot;;
        Field&amp;lt;NonNullGraphType&amp;lt;StringGraphType&amp;gt;&amp;gt;(&quot;tag&quot;);
        Field&amp;lt;NonNullGraphType&amp;lt;DateGraphType&amp;gt;&amp;gt;(&quot;createdAt&quot;);
        Field&amp;lt;NonNullGraphType&amp;lt;IntGraphType&amp;gt;&amp;gt;(&quot;customerId&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;customerinputtype&quot;&gt;CustomerInputType&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CustomerInputType : InputObjectGraphType {  
    public CustomerInputType()
    {
        Name = &quot;CustomerInput&quot;;
        Field&amp;lt;NonNullGraphType&amp;lt;StringGraphType&amp;gt;&amp;gt;(&quot;name&quot;);
        Field&amp;lt;NonNullGraphType&amp;lt;StringGraphType&amp;gt;&amp;gt;(&quot;billingAddress&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前添加以上代码之后，我们还需要在&lt;code&gt;Startup&lt;/code&gt;类中注册这几个新类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)  
{ 
    ....
    ....
    services.AddScoped&amp;lt;CustomerType&amp;gt;();
    services.AddScoped&amp;lt;CustomerInputType&amp;gt;();
    services.AddScoped&amp;lt;OrderType&amp;gt;();
    services.AddScoped&amp;lt;OrderInputType&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果现在启动项目，你会得到以下错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Failed to call Activator.CreateInstance. Type: chapter1.OrderType&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的问题是在&lt;code&gt;InventorySchema&lt;/code&gt;构造函数中的注入没起作用, 原因是&lt;code&gt;GraphQL&lt;/code&gt;在解决依赖的时候，只能处理一层, 这里&lt;code&gt;OrderType&lt;/code&gt;和&lt;code&gt;CustomerType&lt;/code&gt;是2层的关系。如果想解决这个问题，我们需要在&lt;code&gt;Startup&lt;/code&gt;中再注册一个依赖解决器。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddScoped&amp;lt;IDependencyResolver&amp;gt;(s =&amp;gt; 
    new FuncDependencyResolver(s.GetRequiredService));  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成之后我们还需要修改&lt;code&gt;InventorySchema&lt;/code&gt;, 在构造函数中将依赖解决器注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class InventorySchema: Schema {  
    public InventorySchema(IDependencyResolver resolver): base(resolver) {
        Query = resolver.Resolve&amp;lt;InventoryQuery&amp;gt;();
        Mutation = resolver.Resolve&amp;lt;InventoryMutation&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再次启动项目，程序不报错了。&lt;/p&gt;
&lt;h3 id=&quot;最终效果&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;下面我们首先创建一个&lt;code&gt;Customer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181112222412988-549830715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们继续创建2个&lt;code&gt;Order&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181112222419160-1458276502.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181112222423456-1834692302.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们来查询一下刚才创建的数据是否存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181112222429836-2075628975.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据读取正确，这说明我们的数据添加成功了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20VIII&quot;&gt;本文源代码： https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20VIII&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>到目前为止我们一直在使用GraphQL操作单个实体。在本篇博文中，我们将使用GraphQL操作实体集合。这里我们使用的场景是处理一个顾客的所有订单，顾客和订单之间的关系是一对多。一个顾客可以有多个订单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9949559.html</dc:identifier>
</item>
<item>
<title>架构必经之路2 - 熔断机制 - jackson0714</title>
<link>http://www.cnblogs.com/jackson0714/p/Architecture2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/Architecture2.html</guid>
<description>
&lt;div class=&quot;entrylistPostSummary&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;c_b_p_desc&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;项目中要做一个熔断机制，预防对第三方的接口调用压力太大。下面我介绍下项目中用到的熔断机制。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;1.熔断检测机制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201811/414640-20181112205608845-1010708609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）请求call到backend后，首先判断熔断开关是否打开&lt;/p&gt;
&lt;p&gt;（2）如果熔断开关已打开，则表明当前请求不能被处理&lt;/p&gt;
&lt;p&gt;（3）如果熔断开关未打开，则判断时间窗口（判断统计错误率）是否已满&lt;/p&gt;
&lt;p&gt;（4）如果时间窗口（判断统计错误率）未满，则请求桶（redis) 中的请求数加1&lt;/p&gt;
&lt;p&gt;（5）如果返回的response 有异常，则失败桶（redis) 的失败数加1，如果返回的response没有异常，则成功桶（redis) 的成功数加1&lt;/p&gt;
&lt;p&gt;（6）如果时间窗口（判断统计错误率）已满，则开始判断是否需要熔断&lt;/p&gt;
&lt;h2&gt; 2.熔断算法&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201811/414640-20181112201704354-1097363952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;充要条件：&lt;/p&gt;
&lt;p&gt;（1）请求总数 &amp;gt; 设定值X&lt;/p&gt;
&lt;p&gt;（2）失败率 &amp;gt; 设定值Y&lt;/p&gt;
&lt;p&gt;请求总数可以从请求桶redis 中获取到&lt;/p&gt;
&lt;p&gt;失败率 = 失败数 ÷ 请求数 × 100%&lt;/p&gt;
&lt;p&gt;当请求总数大于一定值，且失败率大于一定值时，则表示请求失败数太多了，需要熔断API请求&lt;/p&gt;
&lt;h2&gt;3.统计失败率的时间窗口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201811/414640-20181112201137366-1930217189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （1）每次请求，都会判断时间窗口是否已满（如5分钟），如果时间窗口已满，则重新开始计时，且清理请求数/成功数/失败数&lt;/p&gt;
&lt;p&gt; （2）第一次开始的起始时间默认为当前时间。&lt;/p&gt;
&lt;h2&gt;4.熔断持续时间&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201810/414640-20181029195005331-75025845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）如果出现问题，可以将所有请求链路熔断掉，熔断恢复时间可以假定为1分钟，可以根据不同的环境进行调整&lt;/p&gt;
&lt;p&gt;（2）熔断恢复时间没有根据环境来进行动态调整，比如网络差的时候，持续了很长时间网络都很差，这个时候，可以动态递增熔断时间&lt;/p&gt;
&lt;h2&gt;5.手动熔断&lt;/h2&gt;
&lt;p&gt;因为熔断是通过统计单位时间内的失败率来判断是否需要熔断的，而有时候我们需要快速切断请求链路，比如充值请求量太大的时候，导致很多订单都被退款，这个时候我们可以先熔断获取套餐接口，这样用户就拿不到套餐，就不能充值了。&lt;/p&gt;
&lt;h2&gt;6.总熔断检测开关&lt;/h2&gt;
&lt;p&gt;有时候我们不需要熔断检测，这个时候我们就需要一个总开关，打开总开关，则进行熔断检测，关闭总开关，则不进行熔断检测。&lt;/p&gt;
&lt;h2&gt;7.查看当前熔断的状态&lt;/h2&gt;
&lt;p&gt;我们做了熔断检测，但是需要check下是否work了，可以check下以下参数&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;div class=&quot;line&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201811/414640-20181112204243481-857589079.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;line&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;html-tag&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;line&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;8.还有哪些可以优化的？有哪些不足？以及您是否遇到熔断的坑？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;html-tag&quot;&gt;欢迎留言一起探讨熔断机制~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.030303030303&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;Jackson0714&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于微软平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 12 Nov 2018 13:03:00 +0000</pubDate>
<dc:creator>jackson0714</dc:creator>
<og:description>架构之旅1 - 扣减库存 架构之旅2 - 熔断机制 项目中要做一个熔断机制，预防对第三方的接口调用压力太大。下面我介绍下项目中用到的熔断机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/Architecture2.html</dc:identifier>
</item>
<item>
<title>Vue实现移动端页面切换效果 - wenr</title>
<link>http://www.cnblogs.com/wenruo/p/9948348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenruo/p/9948348.html</guid>
<description>&lt;p&gt;找了好多博客实现效果都……emmm……&lt;/p&gt;

&lt;p&gt;应用Vue自带的过渡 《 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/transitions.html&quot; target=&quot;_blank&quot;&gt;进入/离开 &amp;amp; 列表过渡&lt;/a&gt; 》和 嵌套路由 和 fixed定位实现&lt;/p&gt;
&lt;p&gt;其实还是挺简单的。&lt;/p&gt;
&lt;p&gt;在子页面把整个页面做绝对定位，覆盖整个屏幕，子父页面将 &lt;span class=&quot;cnblogs_code&quot;&gt;router-view&lt;/span&gt; 用 &lt;span class=&quot;cnblogs_code&quot;&gt;transition&lt;/span&gt; 套起来，并加上过渡动画就可以啦。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    * &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    html, body, #app &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .one &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .two &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; tomato&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .three &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ffe69f&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .v-enter-active, .v-leave-active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; all 0.3s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .v-enter, .v-leave-to &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; translateX(100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/foo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    const Foo &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      template: `
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;whole-page two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/foo/bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;下一层&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;第二层&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;h1&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-view&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;transition&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;      `
    }
    const Bar &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      template: `
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;whole-page three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;第三层&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;h1&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-view&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;transition&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;      `
    }
    const routes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [ 
      { path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, component: Foo, children: [ { path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, component: Bar } ] }
    ]
    const router &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({ routes })
    const app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({ router }).$mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670878/201811/670878-20181112190901826-1613579721.gif&quot; alt=&quot;&quot; width=&quot;276&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有一个问题需要注意一下，&lt;/p&gt;
&lt;p&gt;我们知道，在应用transform属性的时候，fixed定位会变成absolute。&lt;/p&gt;
&lt;p&gt;这里，页面转换的时候，就变成了相对translation定位。所以如果子页面中有绝对定位的话，移动的过程中页面会变形。&lt;/p&gt;
&lt;p&gt;简单举个栗子，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
* &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
html, body, #app &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
#app &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; padding-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.one &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.two &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; tomato&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;.v-enter-active, .v-leave-active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; all 0.3s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.v-enter, .v-leave-to &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; translateX(100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
header &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #fff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.two header &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #666&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是一个标题&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/foo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    const Foo &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      template: `
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;whole-page two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;我也是一个标题&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;header&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;第二层&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;h1&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-view&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;transition&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;      `
    }
    const routes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [ 
      { path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, component: Foo }
    ]
    const router &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({ routes })
    const app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({ router }).$mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670878/201811/670878-20181112200609960-1079017495.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;OKOK，反正就是这种bug嘛。&lt;/p&gt;
&lt;p&gt;解决办法就是，就是，尽量让页面fixed定位都是0 0 0 0，然后偏移用padding实现。&lt;/p&gt;
&lt;p&gt;大概吧……反正我是这么解决的……&lt;/p&gt;
&lt;p&gt;比如上面那个可以把CSS改成这样解决问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* &lt;/span&gt;{&lt;span&gt; padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt; margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;; }&lt;span&gt;
html, body, #app &lt;/span&gt;{&lt;span&gt; width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt; height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;; }&lt;span&gt;
#app &lt;/span&gt;{&lt;span&gt; padding-top&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;; }&lt;span&gt;
.one &lt;/span&gt;{&lt;span&gt; height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt; background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;}&lt;span&gt;
.two &lt;/span&gt;{&lt;span&gt; background-color&lt;/span&gt;:&lt;span&gt; tomato&lt;/span&gt;;&lt;span&gt; position&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;&lt;span&gt; top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt; padding-top&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt; bottom&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt; left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt; right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;; }&lt;span&gt;.v-enter-active, .v-leave-active &lt;/span&gt;{&lt;span&gt; transition&lt;/span&gt;:&lt;span&gt; all 0.3s&lt;/span&gt;; }&lt;span&gt;
.v-enter, .v-leave-to &lt;/span&gt;{&lt;span&gt; transform&lt;/span&gt;:&lt;span&gt; translateX(100%)&lt;/span&gt;; }&lt;span&gt;
header &lt;/span&gt;{&lt;span&gt; height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt; background-color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt; width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt; position&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;&lt;span&gt; top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt; color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt; line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt; text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt; z-index&lt;/span&gt;:&lt;span&gt; 100&lt;/span&gt;; }&lt;span&gt;
.two header &lt;/span&gt;{&lt;span&gt; top&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt; background-color&lt;/span&gt;:&lt;span&gt; #666&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;嗯嗯 还有一个问题，还有个滑动穿透的问题，（真开心! 这么多问题！&lt;/p&gt;
&lt;p&gt;我再举个栗子，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
* &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
html, body, #app &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.one &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; min-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.two &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; tomato&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.three &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ffe69f&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.v-enter-active, .v-leave-active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; all 0.3s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
.v-enter, .v-leave-to &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; translateX(100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/foo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一层&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    const Foo &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      template: `
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;whole-page two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;link to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-link&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;第二层&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;h1&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;router-view&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;transition&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;      `
    }
    const routes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [ 
      { path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, component: Foo }
    ]
    const router &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({ routes })
    const app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({ router }).$mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看效果，第二页的高度明明就是视窗的高度，但是它有一个滚动条，实际上那是第一个页面的滚动条。&lt;/p&gt;
&lt;p&gt;网上找了好多方法，一一试了，全部不生效。（当然很有可能是我的方法不对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670878/201811/670878-20181112202831130-1231254409.gif&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后没办法只有找最笨的方法啦，就是通过  &lt;span class=&quot;cnblogs_code&quot;&gt;v-if&lt;/span&gt;  把父页面不显示就好了。&lt;/p&gt;
&lt;p&gt;当然不能直接不显示，因为动画还没结束父元素就空白了呀！setTimeout 就好了……&lt;/p&gt;
&lt;p&gt;具体代码就不写了，这个应该很容易理解。&lt;/p&gt;

&lt;p&gt;还有什么问题，等我想起来在补充。或者还有什么没注意到的问题，欢迎路过的大佬们提出呀，反正我也解决不了。&lt;/p&gt;

</description>
<pubDate>Mon, 12 Nov 2018 12:44:00 +0000</pubDate>
<dc:creator>wenr</dc:creator>
<og:description>找了好多博客实现效果都……emmm…… 应用Vue自带的过渡 《 进入/离开 &amp; 列表过渡 》和 嵌套路由 和 fixed定位实现 其实还是挺简单的。 在子页面把整个页面做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenruo/p/9948348.html</dc:identifier>
</item>
<item>
<title>一个applicationContext 加载错误导致的阻塞解决小结 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/9948909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/9948909.html</guid>
<description>&lt;p&gt;　　问题为对接一个sso的验证模块，正确的对接姿势为，接入一个 filter, 然后接入一个 SsoListener 。&lt;/p&gt;
&lt;p&gt;　　然而在接入之后，却导致了应用无法正常启动，或者说看起来很奇怪，来看下都遇到什么样的问题，以及是如何处理的？&lt;/p&gt;
&lt;p&gt;还是 web.xml, 原本是这样的: （很简洁！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;&lt;span&gt;=&quot;3.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;display-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xx-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;display-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;forceEncoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:spring/spring-servlet.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而需要添加的 filter 如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.xxx.session.RedisSessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.xx.session.SSOHttpSessionListener&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SSOFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.xxx.auth.SSOFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SSOFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;configFileLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　另外再加几个必要的配置文件扫描！对接完成！不费事！&lt;br/&gt;　　然后，我坑哧坑哧把代码copy过来，准备 commit 搞定收工！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　结果，不出所料，server 起不来了。也不完全是启不来了，就只是启起来之后，啥也没有了。&lt;/p&gt;
&lt;p&gt;　　sso 中也没啥东西，就是拦截下 header 中的值，判定如果没有登录就的话，就直接返回到 sso 的登录页去了。&lt;/p&gt;
&lt;p&gt;　　那么，到底是哪里的问题呢？思而不得后，自然就开启了飞行模式了！&lt;/p&gt;

&lt;p&gt;下面，开启debug模式！&lt;/p&gt;
&lt;p&gt;　　本想直接 debug spring 的，结果，很明显，失败了。压根就没有进入 spring 的 ClassPathXmlApplicationContext 中，得出一个结论，spring 没有被正确的打开！&lt;/p&gt;
&lt;p&gt;　　好吧，那让我们退回一步，既然 servlet 启不来，那么，可能就是 filter 有问题了。&lt;/p&gt;
&lt;p&gt;　　不过，请稍等，filter 不是在有请求进来的时候，才会起作用吗？没道理在初始化的时候就把应用给搞死了啊！（不过其实这是有可能的）&lt;/p&gt;
&lt;p&gt;　　那么，到底问题出在了哪里？&lt;/p&gt;
&lt;p&gt;简单扫略下代码，不多，还有一个 listener 没有被引起注意，去看看吧。&lt;/p&gt;
&lt;p&gt;先了解下，web.xml 中的 listener 作用: &lt;/p&gt;
&lt;p&gt;　　listener 即 监听器，其实也是 tomcat 的一个加载节点。加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。&lt;/p&gt;
&lt;p&gt;　　其加载顺序为: listener -&amp;gt; filter -&amp;gt; servlet&lt;/p&gt;
&lt;p&gt;　　接下来，就知道， listener 先加载，既然没有到 servlet, 也排除了 filter, 那就 debug listener 呗！&lt;/p&gt;
&lt;p&gt;　　果然，debug进入无误！单步后，发现应用在某此被中断，线程找不到了，有点懵。（其实只是因为线程中被调用了线程切换而已）&lt;/p&gt;
&lt;p&gt;　　我想着，可能是某处发生了异常，而此处又没有被 try-catch, 所以也是很伤心。要是能临时打 try-catch 就好了。 &lt;/p&gt;
&lt;p&gt;其实 idea 中 是可以对没有捕获的异常进行收集的，即开启当发生异常时就捕获的功能就可以了。&lt;/p&gt;
&lt;p&gt;　　然而，这大部分情况下捕获的异常，仅仅正常的 loadClass() 异常，这在类加载模型中，是正常抛出的异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如: java.net.URLClassLoader.findClass() 抛出的异常&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
    {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; AccessController.doPrivileged(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt;() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
                        String path &lt;/span&gt;= name.replace('.', '/').concat(&quot;.class&quot;&lt;span&gt;);
                        Resource res &lt;/span&gt;= ucp.getResource(path, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defineClass(name, res);
                            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException(name, e);
                            }
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }, acc);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (java.security.PrivilegedActionException pae) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (ClassNotFoundException) pae.getException();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处抛出的异常可以被 idea 捕获&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException(name);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　由于这么多无效的异常，导致我反复换了n个姿势，总算到达正确的位置。&lt;br/&gt;　　然而当跟踪到具体的一行时，还是发生了错误。&lt;/p&gt;
&lt;p&gt;既然用单步调试无法找到错误，那么是不是在我没有单步的地方，出了问题？&lt;/p&gt;
&lt;p&gt;对了，就是 静态方法块！这个地方，是在首次调用该类的任意方法时，进行初始化的！也许这是我们的方向。&lt;/p&gt;
&lt;p&gt;最后，跟踪到了一个静态块中，发现这里被中断了！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原罪在这里&lt;/span&gt;
        CAS_EDIS_CLIENT_TEMPLATE = CasSpringContextUtils.getBean(&quot;casRedisClientTemplate&quot;, CasRedisClientTemplate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一句看起来是向 spring 的 bean工厂请求一个实例，为什么能被卡死呢？&lt;br/&gt;只有再深入一点，才能了解其情况:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt;&lt;span&gt; beanType) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getApplicationContext().getBean(name, beanType);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句看起来更像是 spring 的bean获取，不应该有问题啊！不过接下来一句会让我们明白一切:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationContext getApplicationContext() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (CasSpringContextUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (applicationContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没错,就是这里了, 这里设置了死锁，线程交出，等待1分钟超时，继续循环&lt;/span&gt;
                    CasSpringContextUtils.&lt;span&gt;class&lt;/span&gt;.wait(60000&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex) {
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; applicationContext;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很明显，这里已经导致了某种意义上的死锁。因为 web.xml 在加载到此处时，使用的是一个 main 线程，而加载到此处时，却被该处判断阻断。&lt;/p&gt;
&lt;p&gt;那么我们可能想， applicationContext 是一个 sping 管理的类，那么只要他被加载后，不可以了吗？就像下面一样:&lt;/p&gt;
&lt;p&gt;　　没错，spring 在加载到此类时，会调用一个 setApplicationContext, 此时 applicationContext 就不会null了。然后想像还是太美，原因如上:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setApplicationContext(ApplicationContext applicationContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (CasSpringContextUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            CasSpringContextUtils.applicationContext &lt;/span&gt;=&lt;span&gt; applicationContext;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 梦想总是很美好，当加载完成后，通知 wait()&lt;/span&gt;
            CasSpringContextUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.notifyAll();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok, 截止这里，我们已经找到了问题的根源。是一个被引入的jar的优雅方式阻止了你的前进。&lt;/p&gt;
&lt;p&gt;很明显，你是不可能去改动这段代码的，那么你要做的，就是想办法绕过它。&lt;/p&gt;
&lt;p&gt;　　即：在执行 getApplicationContext() 之前，把 applicationContext 处理好！&lt;/p&gt;
&lt;p&gt;如何优先加载 spring 上下文？配置一个 context-param, 再加一个 ContextLoaderListener, 即可:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &amp;lt;!-- 提前加载spring --&amp;gt;
  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:spring/applicationContext.xml&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
  &amp;lt;listener&amp;gt;
    &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
  &amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ContextLoaderListener 中，会优先加载 contextInitialized(); 从而初始化整个 spring 的生命周期！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Initialize the root web application context.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　也就是说，只要把这个配置放到新增的 filter 之前，即可实现正常情况下的加载！&lt;/p&gt;
&lt;p&gt;　　验证结果，果然如此！&lt;/p&gt;
&lt;p&gt;最后，附上一段 tomcat 加载 context 的鲁棒代码，以供参考:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_61d79de6-d021-4c31-8785-d9f66284eadb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61d79de6-d021-4c31-8785-d9f66284eadb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61d79de6-d021-4c31-8785-d9f66284eadb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Configure the set of instantiated application event listeners
     * for this Context.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; if all listeners wre
     * initialized successfully, or &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; otherwise.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; listenerStart() {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isDebugEnabled())
            log.debug(&lt;/span&gt;&quot;Configuring application event listeners&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate the required listeners&lt;/span&gt;
        String listeners[] =&lt;span&gt; findApplicationListeners();
        Object results[] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[listeners.length];
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; ok = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; results.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (getLogger().isDebugEnabled())
                getLogger().debug(&lt;/span&gt;&quot; Configuring event listener class '&quot; +&lt;span&gt;
                    listeners[i] &lt;/span&gt;+ &quot;'&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                String listener &lt;/span&gt;=&lt;span&gt; listeners[i];
                results[i] &lt;/span&gt;=&lt;span&gt; getInstanceManager().newInstance(listener);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                t &lt;/span&gt;=&lt;span&gt; ExceptionUtils.unwrapInvocationTargetException(t);
                ExceptionUtils.handleThrowable(t);
                getLogger().error(sm.getString(
                        &lt;/span&gt;&quot;standardContext.applicationListener&quot;&lt;span&gt;, listeners[i]), t);
                ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ok) {
            getLogger().error(sm.getString(&lt;/span&gt;&quot;standardContext.applicationSkipped&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sort listeners in two arrays&lt;/span&gt;
        ArrayList&amp;lt;Object&amp;gt; eventListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        ArrayList&lt;/span&gt;&amp;lt;Object&amp;gt; lifecycleListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; results.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletContextAttributeListener)
                &lt;/span&gt;|| (results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletRequestAttributeListener)
                &lt;/span&gt;|| (results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletRequestListener)
                &lt;/span&gt;|| (results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpSessionIdListener)
                &lt;/span&gt;|| (results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpSessionAttributeListener)) {
                eventListeners.add(results[i]);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletContextListener)
                &lt;/span&gt;|| (results[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpSessionListener)) {
                lifecycleListeners.add(results[i]);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Listener instances may have been added directly to this Context by
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ServletContextInitializers and other code via the pluggability APIs.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Put them these listeners after the ones defined in web.xml and/or
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; annotations then overwrite the list of instances with the new, full
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; list.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object eventListener: getApplicationEventListeners()) {
            eventListeners.add(eventListener);
        }
        setApplicationEventListeners(eventListeners.toArray());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object lifecycleListener: getApplicationLifecycleListeners()) {
            lifecycleListeners.add(lifecycleListener);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lifecycleListener &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletContextListener) {
                noPluggabilityListeners.add(lifecycleListener);
            }
        }
        setApplicationLifecycleListeners(lifecycleListeners.toArray());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send application start events&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (getLogger().isDebugEnabled())
            getLogger().debug(&lt;/span&gt;&quot;Sending application start events&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure context is not null&lt;/span&gt;
&lt;span&gt;        getServletContext();
        context.setNewServletContextListenerAllowed(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

        Object instances[] &lt;/span&gt;=&lt;span&gt; getApplicationLifecycleListeners();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instances == &lt;span&gt;null&lt;/span&gt; || instances.length == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ok;
        }

        ServletContextEvent event &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletContextEvent(getServletContext());
        ServletContextEvent tldEvent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (noPluggabilityListeners.size() &amp;gt; 0&lt;span&gt;) {
            noPluggabilityServletContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoPluggabilityServletContext(getServletContext());
            tldEvent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletContextEvent(noPluggabilityServletContext);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; instances.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(instances[i] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletContextListener))
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            ServletContextListener listener &lt;/span&gt;=&lt;span&gt;
                (ServletContextListener) instances[i];
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fireContainerEvent(&lt;/span&gt;&quot;beforeContextInitialized&quot;&lt;span&gt;, listener);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 listener.contextInitialized() 触发 listener&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (noPluggabilityListeners.contains(listener)) {
                    listener.contextInitialized(tldEvent);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    listener.contextInitialized(event);
                }
                fireContainerEvent(&lt;/span&gt;&quot;afterContextInitialized&quot;&lt;span&gt;, listener);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                fireContainerEvent(&lt;/span&gt;&quot;afterContextInitialized&quot;&lt;span&gt;, listener);
                getLogger().error
                    (sm.getString(&lt;/span&gt;&quot;standardContext.listenerStart&quot;&lt;span&gt;,
                                  instances[i].getClass().getName()), t);
                ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (ok);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Nov 2018 12:41:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>问题为对接一个sso的验证模块，正确的对接姿势为，接入一个 filter, 然后接入一个 SsoListener 。 然而在接入之后，却导致了应用无法正常启动，或者说看起来很奇怪，来看下都遇到什么样的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/9948909.html</dc:identifier>
</item>
<item>
<title>使用CompletableFuture优化你的代码执行效率 - 醉眼识朦胧</title>
<link>http://www.cnblogs.com/fingerboy/p/9948736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fingerboy/p/9948736.html</guid>
<description>&lt;p&gt;　　这篇文章详细讲解java8中CompletableFuture的特性,方法以及实例.&lt;/p&gt;
&lt;p&gt;　　在java8以前,我们使用java的多线程编程,一般是通过Runnable中的run方法来完成,这种方式,有个很明显的缺点,就是,没有返回值,这时候,大家可能会去尝试使用Callable中的call方法,然后用Future返回结果,如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ExecutorService executor &lt;/span&gt;=&lt;span&gt; Executors.newSingleThreadExecutor();
        Future&lt;/span&gt;&amp;lt;String&amp;gt; stringFuture = executor.submit(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;async thread&quot;&lt;span&gt;;
            }
        });
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;main thread&quot;&lt;span&gt;);
        System.out.println(stringFuture.get());

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过观察控制台,我们发现先打印 main thread ,一秒后打印 async thread,似乎能满足我们的需求,但仔细想我们发现一个问题,当调用future的get()方法时,当前主线程是堵塞的,这好像并不是我们想看到的,另一种获取返回结果的方式是先轮询,可以调用isDone,等完成再获取,但这也不能让我们满意.&lt;/p&gt;
&lt;p&gt;　　不管怎么看,这种用法看起来并不优雅,起码从视觉上就有些丑陋,而且某些场景无法使用,比如说,&lt;/p&gt;
&lt;p&gt;　　1.很多个异步线程执行时间可能不一致,我的主线程业务不能一直等着,这时候我可能会想要只等最快的线程执行完或者最重要的那个任务执行完,亦或者我只等1秒钟,至于没返回结果的线程我就用默认值代替.&lt;/p&gt;
&lt;p&gt;　　2.我两个异步任务之间执行独立,但是第二个依赖第一个的执行结果.&lt;/p&gt;
&lt;p&gt;　　java8的CompletableFuture,就在这混乱且不完美的多线程江湖中闪亮登场了.CompletableFuture让Future的功能和使用场景得到极大的完善和扩展,提供了函数式编程能力,使代码更加美观优雅,而且可以通过回调的方式计算处理结果,对异常处理也有了更好的处理手段.&lt;/p&gt;
&lt;p&gt;　　CompletableFuture源码中有四个静态方法用来执行异步任务:&lt;/p&gt;
&lt;h2&gt;创建任务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; &lt;strong&gt;supplyAsync&lt;/strong&gt;(Supplier&amp;lt;U&amp;gt;&lt;span&gt; supplier){..}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; &lt;strong&gt;supplyAsync&lt;/strong&gt;(Supplier&amp;lt;U&amp;gt;&lt;span&gt; supplier,Executor executor){..}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CompletableFuture&amp;lt;Void&amp;gt;&lt;span&gt;&lt;strong&gt; runAsync&lt;/strong&gt;(Runnable runnable){..}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CompletableFuture&amp;lt;Void&amp;gt;&lt;span&gt;&lt;strong&gt; runAsync&lt;/strong&gt;(Runnable runnable,
Executor executor){..} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果有多线程的基础知识,我们很容易看出,run开头的两个方法,用于执行没有返回值的任务,因为它的入参是Runnable对象,而supply开头的方法显然是执行有返回值的任务了,至于方法的入参,如果没有传入Executor对象将会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码.在实际使用中,一般我们使用自己创建的线程池对象来作为参数传入使用,这样速度会快些.&lt;/p&gt;
&lt;p&gt;　　执行异步任务的方式也很简单,只需要使用上述方法就可以了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; future =&lt;span&gt; CompletableFuture.supplyAsync(() &lt;/span&gt;-&amp;gt; {
　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....执行任务&lt;/span&gt;
　　　　&lt;span&gt;return&lt;/span&gt; &quot;hello&quot;;}, executor)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来看一下获取执行结果的几个方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;V get();
V get(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeout,Timeout unit);&lt;br/&gt;T getNow(T defaultValue);&lt;br/&gt;T join();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面两个方法是Future中的实现方式,get()会堵塞当前的线程,这就造成了一个问题,如果执行线程迟迟没有返回数据,get()会一直等待下去,因此,第二个get()方法可以设置等待的时间.&lt;/p&gt;
&lt;p&gt; 　　getNow()方法比较有意思,表示当有了返回结果时会返回结果,如果异步线程抛了异常会返回自己设置的默认值.&lt;/p&gt;
&lt;p&gt;接下来以一些场景的实例来介绍一下CompletableFuture中其他一些常用的方法.&lt;/p&gt;
&lt;h2&gt;thenAccept()&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt; &lt;strong&gt;thenAccept&lt;/strong&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt; &lt;strong&gt;thenAcceptAsync&lt;/strong&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt; &lt;strong&gt;thenAcceptAsync&lt;/strong&gt;(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; action,Executor executor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:当前任务正常完成以后执行,当前任务的执行结果可以作为下一任务的输入参数,无返回值.&lt;/p&gt;
&lt;p&gt;　　场景:执行任务A,同时异步执行任务B,待任务B正常返回之后,用B的返回值执行任务C,任务C无返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt; &quot;任务A&quot;&lt;span&gt;);
CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB = CompletableFuture.supplyAsync(() -&amp;gt; &quot;任务B&quot;&lt;span&gt;);
CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureC = futureB.thenApply(b -&amp;gt;&lt;span&gt; {
      System.out.println(&lt;/span&gt;&quot;执行任务C.&quot;&lt;span&gt;);
      System.out.println(&lt;/span&gt;&quot;参数:&quot; +&lt;span&gt; b);//参数:任务B
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;a&quot;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;thenRun(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt;&lt;span&gt; thenRun(Runnable action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt;&lt;span&gt; thenRunAsync(Runnable action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;Void&amp;gt; thenRunAsync(Runnable action,Executor executor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:对不关心上一步的计算结果，执行下一个操作&lt;/p&gt;
&lt;p&gt;　　场景:执行任务A,任务A执行完以后,执行任务B,任务B不接受任务A的返回值(不管A有没有返回值),也无返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt; &quot;任务A&quot;&lt;span&gt;);
futureA.thenRun(() &lt;/span&gt;-&amp;gt; System.out.println(&quot;执行任务B&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;thenApply(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     &lt;strong&gt;thenApply&lt;/strong&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; U&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     &lt;strong&gt;thenApplyAsync&lt;/strong&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; U&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     &lt;strong&gt;thenApplyAsync&lt;/strong&gt;(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; U&amp;gt; fn, Executor executor)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:当前任务正常完成以后执行，当前任务的执行的结果会作为下一任务的输入参数,有返回值&lt;/p&gt;
&lt;p&gt;　　场景:多个任务串联执行,下一个任务的执行依赖上一个任务的结果,每个任务都有输入和输出&lt;/p&gt;
&lt;p&gt;　　实例1:异步执行任务A,当任务A完成时使用A的返回结果resultA作为入参进行任务B的处理,可实现任意多个任务的串联执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt; &quot;hello&quot;&lt;span&gt;);

CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB = futureA.thenApply(s-&amp;gt;s + &quot; world&quot;&lt;span&gt;);

CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; future3 =&lt;span&gt; futureB.thenApply(String::toUpperCase);

System.out.println(future3.join());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码,我们当然可以先调用future.join()先得到任务A的返回值,然后再拿返回值做入参去执行任务B,而thenApply的存在就在于帮我简化了这一步,我们不必因为等待一个计算完成而一直阻塞着调用线程，而是告诉CompletableFuture你啥时候执行完就啥时候进行下一步. 就把多个任务串联起来了.&lt;/p&gt;
&lt;h2&gt;thenCombine(..)  &lt;strong&gt;thenAcceptBoth(..)  runAfterBoth(..)&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt;     thenCombine(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; U&amp;gt; other, BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;super&lt;/span&gt; U,? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt;     thenCombineAsync(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; U&amp;gt; other, BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;super&lt;/span&gt; U,? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U,V&amp;gt; CompletableFuture&amp;lt;V&amp;gt;     thenCombineAsync(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; U&amp;gt; other, BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;super&lt;/span&gt; U,? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; fn, Executor executor)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:结合两个CompletionStage的结果，进行转化后返回&lt;/p&gt;
&lt;p&gt;　　场景:需要根据商品id查询商品的当前价格,分两步,查询商品的原始价格和折扣,这两个查询相互独立,当都查出来的时候用原始价格乘折扣,算出当前价格. 使用方法:thenCombine(..)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 CompletableFuture&amp;lt;Double&amp;gt; futurePrice = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; 100d);
 CompletableFuture&lt;/span&gt;&amp;lt;Double&amp;gt; futureDiscount = CompletableFuture.supplyAsync(() -&amp;gt; 0.8&lt;span&gt;);
 CompletableFuture&lt;/span&gt;&amp;lt;Double&amp;gt; futureResult = futurePrice.thenCombine(futureDiscount, (price, discount) -&amp;gt; price *&lt;span&gt; discount);
 System.out.println(&lt;/span&gt;&quot;最终价格为:&quot; + futureResult.join()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终价格为:80.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　thenCombine(..)是结合两个任务的返回值进行转化后再返回,那如果不需要返回呢,那就需要&lt;strong&gt;thenAcceptBoth&lt;/strong&gt;(..),同理,如果连两个任务的返回值也不关心呢,那就需要runAfterBoth了,如果理解了上面三个方法,thenApply,thenAccept,thenRun,这里就不需要单独再提这两个方法了,只在这里提一下.&lt;/p&gt;
&lt;h2&gt;thenCompose(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     thenCompose(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; CompletionStage&amp;lt;U&amp;gt;&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     thenComposeAsync(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; CompletionStage&amp;lt;U&amp;gt;&amp;gt;&lt;span&gt; fn)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt;     thenComposeAsync(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T,? &lt;span&gt;extends&lt;/span&gt; CompletionStage&amp;lt;U&amp;gt;&amp;gt; fn, Executor executor)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:这个方法接收的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture&lt;/p&gt;
&lt;p&gt;　　这个方法和thenApply非常像,都是接受上一个任务的结果作为入参,执行自己的操作,然后返回.那具体有什么区别呢?&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;thenApply():它的功能相当于将CompletableFuture&amp;lt;T&amp;gt;转换成CompletableFuture&amp;lt;U&amp;gt;,改变的是同一个&lt;/strong&gt;CompletableFuture中的泛型类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　thenCompose():用来连接两个CompletableFuture，返回值是一个新的CompletableFuture&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt; &quot;hello&quot;&lt;span&gt;);

CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB = futureA.thenCompose(s -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; s + &quot;world&quot;&lt;span&gt;));

CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; future3 = futureB.thenCompose(s -&amp;gt;&lt;span&gt; CompletableFuture.supplyAsync(s::toUpperCase));

System.out.println(future3.join());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段代码实现的和上面thenApply一样的效果,在实际使用中,我并没有很清楚两个在使用上的区别,如果有大佬,跪求告知.&lt;/p&gt;
&lt;h2&gt;applyToEither(..)  acceptEither(..)  runAfterEither(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; applyToEither(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; other,Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, U&amp;gt;&lt;span&gt; fn);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; applyToEitherAsync(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; other,Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, U&amp;gt;&lt;span&gt; fn);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; applyToEitherAsync(CompletionStage&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; other,Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, U&amp;gt; fn,Executor executor);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　功能:执行两个CompletionStage的结果,那个先执行完了,就是用哪个的返回值进行下一步操作&lt;br/&gt;　　场景:假设查询商品a,有两种方式,A和B,但是A和B的执行速度不一样,我们希望哪个先返回就用那个的返回值.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;通过方式A获取商品a&quot;&lt;span&gt;;
        });
CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;通过方式B获取商品a&quot;&lt;span&gt;;
        });
CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureC = futureA.applyToEither(futureB, product -&amp;gt; &quot;结果:&quot; +&lt;span&gt; product);&lt;br/&gt;System.out.println(futureC.join()); //结果:通过方式A获取商品a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样的道理,applyToEither的兄弟方法还有acceptEither(),runAfterEither(),我想不需要我解释你也知道该怎么用了.&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; exceptionally(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;T&amp;gt; exceptionally(Function&amp;lt;Throwable, ? &lt;span&gt;extends&lt;/span&gt; T&amp;gt; fn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:当运行出现异常时,调用该方法可进行一些补偿操作,如设置默认值.&lt;/p&gt;
&lt;p&gt;　　场景:异步执行任务A获取结果,如果任务A执行过程中抛出异常,则使用默认值100返回.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 CompletableFuture&amp;lt;String&amp;gt; futureA =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + (100 / 0&lt;span&gt;))
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;futureA result:&quot; +&lt;span&gt; s)
                .exceptionally(e &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.out.println(e.getMessage()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.ArithmeticException: / by zero&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &quot;futureA result: 100&quot;&lt;span&gt;;
                });
CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + 50&lt;span&gt;)
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;futureB result:&quot; +&lt;span&gt; s)
                .exceptionally(e &lt;/span&gt;-&amp;gt; &quot;futureB result: 100&quot;&lt;span&gt;);
System.out.println(futureA.join());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureA result: 100&lt;/span&gt;
System.out.println(futureB.join());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureB result:执行结果:50&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码展示了正常流程和出现异常的情况,可以理解成catch,根据返回值可以体会下.&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; whenComplete(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;T&amp;gt; whenComplete(BiConsumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? &lt;span&gt;super&lt;/span&gt; Throwable&amp;gt;&lt;span&gt; action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;T&amp;gt; whenCompleteAsync(BiConsumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? &lt;span&gt;super&lt;/span&gt; Throwable&amp;gt;&lt;span&gt; action);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CompletionStage&amp;lt;T&amp;gt; whenCompleteAsync(BiConsumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? &lt;span&gt;super&lt;/span&gt; Throwable&amp;gt; action,Executor executor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:当CompletableFuture的计算结果完成，或者抛出异常的时候，都可以进入whenComplete方法执行,举个栗子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + (100 / 0&lt;span&gt;))
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;apply result:&quot; +&lt;span&gt; s)
                .whenComplete((s, e) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        System.out.println(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        System.out.println(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        System.out.println(e.getMessage());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.ArithmeticException: / by zero&lt;/span&gt;
&lt;span&gt;                    }
                })
                .exceptionally(e &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.out.println(&quot;ex&quot;+e.getMessage()); &lt;/span&gt;&lt;span&gt;//ex:&lt;/span&gt;java.lang.ArithmeticException: / by zero
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　　 &lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &quot;futureA result: 100&quot;&lt;span&gt;; }); &lt;br/&gt;System.out.println(futureA.join());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureA result: 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据控制台,我们可以看出执行流程是这样,supplyAsync-&amp;gt;whenComplete-&amp;gt;exceptionally,可以看出并没有进入thenApply执行,原因也显而易见,在supplyAsync中出现了异常,thenApply只有当正常返回时才会去执行.而whenComplete不管是否正常执行,还要注意一点,whenComplete是没有返回值的.&lt;/p&gt;
&lt;p&gt;　　上面代码我们使用了函数式的编程风格并且先调用whenComplete再调用exceptionally,如果我们先调用exceptionally,再调用whenComplete会发生什么呢,我们看一下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
CompletableFuture&amp;lt;String&amp;gt; futureA =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + (100 / 0&lt;span&gt;))
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;apply result:&quot; +&lt;span&gt; s)
                .exceptionally(e &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.out.println(&lt;/span&gt;&quot;ex:&quot;+e.getMessage()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ex:java.lang.ArithmeticException: / by zero&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &quot;futureA result: 100&quot;&lt;span&gt;;
                })
                .whenComplete((s, e) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        System.out.println(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureA result: 100&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        System.out.println(e.getMessage());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
&lt;span&gt;                    }
                })
                ;
System.out.println(futureA.join());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureA result: 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码先执行了exceptionally后执行whenComplete,可以发现,由于在exceptionally中对异常进行了处理,并返回了默认值,whenComplete中接收到的结果是一个正常的结果,被exceptionally美化过的结果,这一点需要留意一下.&lt;/p&gt;
&lt;h2&gt;handle(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; handle(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, Throwable, ? &lt;span&gt;extends&lt;/span&gt; U&amp;gt;&lt;span&gt; fn);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; handleAsync(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, Throwable, ? &lt;span&gt;extends&lt;/span&gt; U&amp;gt;&lt;span&gt; fn);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; handleAsync(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, Throwable, ? &lt;span&gt;extends&lt;/span&gt; U&amp;gt; fn,Executor executor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　功能:当CompletableFuture的计算结果完成，或者抛出异常的时候，可以通过handle方法对结果进行处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 CompletableFuture&amp;lt;String&amp;gt; futureA =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + (100 / 0&lt;span&gt;))
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;apply result:&quot; +&lt;span&gt; s)
                .exceptionally(e &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.out.println(&lt;/span&gt;&quot;ex:&quot; + e.getMessage()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.ArithmeticException: / by zero&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &quot;futureA result: 100&quot;&lt;span&gt;;
                })
                .handle((s, e) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        System.out.println(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;futureA result: 100&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        System.out.println(e.getMessage());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;handle result:&quot; + (s == &lt;span&gt;null&lt;/span&gt; ? &quot;500&quot;&lt;span&gt; : s);
                });
System.out.println(futureA.join());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;handle result:futureA result: 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过控制台,我们可以看出,最后打印的是handle result:futureA result: 100,执行exceptionally后对异常进行了&quot;美化&quot;,返回了默认值,那么handle得到的就是一个正常的返回,我们再试下,先调用handle再调用exceptionally的情况.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 CompletableFuture&amp;lt;String&amp;gt; futureA =&lt;span&gt; CompletableFuture.
                supplyAsync(() &lt;/span&gt;-&amp;gt; &quot;执行结果:&quot; + (100 / 0&lt;span&gt;))
                .thenApply(s &lt;/span&gt;-&amp;gt; &quot;apply result:&quot; +&lt;span&gt; s)
                .handle((s, e) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        System.out.println(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        System.out.println(e.getMessage());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.ArithmeticException: / by zero&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;handle result:&quot; + (s == &lt;span&gt;null&lt;/span&gt; ? &quot;500&quot;&lt;span&gt; : s);
                })
                .exceptionally(e &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    System.out.println(&lt;/span&gt;&quot;ex:&quot; + e.getMessage()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未执行&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &quot;futureA result: 100&quot;&lt;span&gt;;
                });
System.out.println(futureA.join());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;handle result:500&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据控制台输出,可以看到先执行handle,打印了异常信息,并对接过设置了默认值500,exceptionally并没有执行,因为它得到的是handle返回给它的值,由此我们大概推测handle和whenComplete的区别&lt;/p&gt;
&lt;p&gt;　　　1.都是对结果进行处理,handle有返回值,whenComplete没有返回值&lt;/p&gt;
&lt;p&gt;　　　2.由于1的存在,使得handle多了一个特性,可在handle里实现exceptionally的功能&lt;/p&gt;
&lt;h2&gt;allOf(..)  anyOf(..)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CompletableFuture&amp;lt;Void&amp;gt;  &lt;strong&gt;allOf&lt;/strong&gt;(CompletableFuture&amp;lt;?&amp;gt;&lt;span&gt;... cfs)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CompletableFuture&amp;lt;Object&amp;gt;  &lt;strong&gt;anyOf&lt;/strong&gt;(CompletableFuture&amp;lt;?&amp;gt;... cfs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　allOf:当所有的&lt;code&gt;CompletableFuture&lt;/code&gt;都执行完后执行计算&lt;/p&gt;
&lt;p&gt;　　anyOf:最快的那个CompletableFuture执行完之后执行计算&lt;/p&gt;
&lt;p&gt;　　场景二:查询一个商品详情,需要分别去查商品信息,卖家信息,库存信息,订单信息等,这些查询相互独立,在不同的服务上,假设每个查询都需要一到两秒钟,要求总体查询时间小于2秒.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(4&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000 + RandomUtils.nextInt(1000&lt;span&gt;));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;商品详情&quot;&lt;span&gt;;
        },executorService);

        CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureB = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000 + RandomUtils.nextInt(1000&lt;span&gt;));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;卖家信息&quot;&lt;span&gt;;
        },executorService);

        CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureC = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000 + RandomUtils.nextInt(1000&lt;span&gt;));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;库存信息&quot;&lt;span&gt;;
        },executorService);

        CompletableFuture&lt;/span&gt;&amp;lt;String&amp;gt; futureD = CompletableFuture.supplyAsync(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000 + RandomUtils.nextInt(1000&lt;span&gt;));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;订单信息&quot;&lt;span&gt;;
        },executorService);

        CompletableFuture&lt;/span&gt;&amp;lt;Void&amp;gt; allFuture =&lt;span&gt; CompletableFuture.allOf(futureA, futureB, futureC, futureD);
        allFuture.join();

        System.out.println(futureA.join() &lt;/span&gt;+ futureB.join() + futureC.join() +&lt;span&gt; futureD.join());
        System.out.println(&lt;/span&gt;&quot;总耗时:&quot; + (System.currentTimeMillis() -&lt;span&gt; start));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://colobu.com/2016/02/29/Java-CompletableFuture/#Either&quot; target=&quot;_blank&quot;&gt;https://colobu.com/2016/02/29/Java-CompletableFuture/#Either&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/qq_36597450/article/details/81232051&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/qq_36597450/article/details/81232051&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Nov 2018 12:16:00 +0000</pubDate>
<dc:creator>醉眼识朦胧</dc:creator>
<og:description>这篇文章详细讲解java8中CompletableFuture的特性,方法以及实例. 在java8以前,我们使用java的多线程编程,一般是通过Runnable中的run方法来完成,这种方式,有个很明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fingerboy/p/9948736.html</dc:identifier>
</item>
<item>
<title>“代码变更覆盖率”在后端测试中的实践 - zni.feng</title>
<link>http://www.cnblogs.com/znicy/p/9948607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/znicy/p/9948607.html</guid>
<description>&lt;p&gt;最近一直对测试覆盖率方面的内容比较感兴趣，虽然很多项目都早已经用上了Jacoco来实现测试覆盖率的统计，但是很少看到实际项目中基于覆盖率统计来指导测试的实践。这篇文章是我近期基于代码变更风险（CR）平台 （http://cr.qa.netease.com/）对猛犸大数据系统的后台调度组件Azakban的一个小版本的测试实践。&lt;/p&gt;
&lt;div readability=&quot;29.5&quot;&gt;
&lt;p&gt;个人认为，代码覆盖率应该是对一个版本测试情况的一个重要考量。不能说代码覆盖率高，就是没有风险。但是，相反，我觉得如果代码覆盖率很低，那就是客观地存在较大风险，说明我们测试的充分度不够。CR平台，其实是基于jacoco覆盖率统计的结果之上，将提测版本与基准版本（通常是上一个线上稳定版本）的代码库进行比对，统计出一个版本提测后开发变更代码的覆盖情况。另外，借助了其他开源工具（ckjm、javancss等）展示了代码中类之间的相互调用关系以及复杂度信息等等。&lt;/p&gt;

&lt;p&gt;下面是我在猛犸4.8.5版本中，借助CR平台对Azkaban相关需求的测试实践：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例子一：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 看需求和JIRA&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;40&quot;&gt;
&lt;p&gt;开发写的需求：&lt;/p&gt;
&lt;p&gt;“ 补数据优化，增强顺序性，优化实例生成数量：原来有的逻辑是Trigger每个一分钟触发一次，然后产生一个补数据实例到分发队列，分发队列每次分发前，先检查有没有正在运行的实例，如果没有就随机选择一个实例分发下去执行。如果有，重新放回队列。这个逻辑存在的问题是，会产生大量的实例在分发队列，耗费内存和CPU时间。现在做的优化是：Trigger每次触发前，先检查分发队列以及已经分发下去的实例里边是否有相关的补数据实例。如果有，则跳过这次触发。另外可以通过&lt;strong&gt;&lt;em&gt;az.backfill.concurrent.num&lt;/em&gt;&lt;/strong&gt; 指定补数据实例产生的并发度（范围1~100，缺失默认值 1）。”&lt;/p&gt;
&lt;p&gt;看着可能有点晕，我稍微将它简化一下就是：&lt;/p&gt;
&lt;p&gt;a. 补数据调度，原本可能会产生大量并发执行的实例，现在限制并发实例数只能是1。即：前一次实例执行完成后，后一次调度实例才会生成。&lt;/p&gt;
&lt;p&gt;b. 提供参数， az.backfill.concurrent.num来控制允许的并发实例数量，该参数的范围是1-100。&lt;/p&gt;
&lt;p&gt;至于JIRA，我这边就不重复添图了，大致跟需求内容差不多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 查看Gitlab：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发提交gitlab代码时与jira做了关联，点击链接可以直接跳转到gitlab：&lt;/p&gt;
&lt;p&gt;可以看到该jira影响的类有两个，分别是：GlobleAttribute.java （只添加了一行常量定义）和 TriggerManager.java&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 查看CR：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始测试该功能前，先看一眼CR的覆盖情况（CR之前执行过自动化测试用例和其他手工测试用例）：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153219f46db854-5345-441a-8def-1349d7de9025.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以看到，在表格里没有出现GlobleAttribute.java（不知是否是因为该类只添加了一行常量定义，改动太小的缘故），而TriggerManager.java类的改动部分覆盖率为63.6%。点进去再仔细看下新修改的行的覆盖情况：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018062815323440caebc7-8d2b-4bbf-934a-70710b90f397.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;p&gt;可以看到“新修改”的未覆盖部分（红色）主要是因为 if (t.getContext().containsKey(GlobleAttribute.AZ_BACKFILL_INSTANCES_NUM))判断没有命中，因为该需求引入了新的参数az.backfill.concurrent.num 指定补数据实例产生的并发度 。而该参数我们还并没有设置过。&lt;/p&gt;
&lt;p&gt;此外，下面的未覆盖部分， &lt;strong&gt;if &lt;/strong&gt;判断的后半段 flow.getScheduleType().equals(ScheduleType.BACKFILL)未命中的原因是因为我们还并没有执行过补数据的调度。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4. 执行手工测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对一个作业流设置补数据调度100次，指定补数据实例产生的并发度为5（设置参数az.backfill.concurrent.num 的值为5），验证补数据调度按照既定场景正确执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查数据库显示，补数据调度按照顺序执行， 但是实例个数始终为1。&lt;/p&gt;
&lt;p&gt;显然，该需求的基本功能生效了（从以前的并发实例数不受限，现在实例个数为1），但是并发度参数并没有生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 结果分析排查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重新执行覆盖率统计，再来看一眼CR平台的新的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153249fd93661b-f32c-43c7-88d0-d5c834b11b6d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，覆盖率有一定的提升。但是为什么并发参数设置没有生效呢？ 来看一眼服务器上的执行日志，拉到日志的最后，看到有一条频繁打印的日志：“backfill trigger 3959, .......”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153300422bee5f-42b4-428c-bcef-df20d8d86ca6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再对照一下CR平台上变更的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201806281533151bfd173f-39ed-40ed-8ecd-49253bda0d72.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，下面这部分“新修改”的代码应该打印的日志还处于“未覆盖”的状态。往上看，发现红框中圈出的代码段里打印的日志刚好就是服务器上后台的日志。看一眼判断条件： &lt;strong&gt;“&lt;/strong&gt;判断该作业流是否已经有执行实例正在执行中，且该正在执行中的作业流实例的开始时间距离现在不到10分钟 &lt;strong&gt;”&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这样就初步解释了 目前阶段为什么我们没看到“新修改”日志打印，以及实例没有生成的直接原因。即： 被之前的判断条件错误拦截了。&lt;/p&gt;
&lt;p&gt;等待10分钟，我们继续查看数据库的结果，发现并发的实例数仍为1。 再看一眼CR的覆盖情况：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153342e341f581-6510-4399-acb1-4a2569a4d5ec.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以看到，刚才未覆盖的这段日志打印，在10分钟过去后被执行了。为了确认该数据的准确性，再看一眼日志，这次我们直接搜索“Reach az.backfill.instances.num ......”这条日志：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153355a94c90af-f7e7-4a9b-9166-c2a8b4f3e87a.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以看到，日志确实出现了变化。也就是说，服务器执行的代码进入了判断： “到达了补数据实例个数的上限 isReachBackfillInstanceNum(t)” 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;然而，我们设置的上限明明是5，为什么却显示已经达到上限，而数据库里的实际并发数还是1呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再看一眼，变更代码中未覆盖的变更行：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018062815340985c42f40-33fa-434a-9344-d14d87c0db87.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以发现，在isReachBackfillInstanceNum(t)方法中，刚好找到了我们想要的内容：默认的补数据实例个数backfillInstancesNum为1，当调度t的上下文信息context中包含参数GlobalAttribute.AZ_BACKFILL_INSTANCES_NUM时，就用该对应的值赋值给backfillInstancesNum。且会对该范围进行1-100的判断。&lt;/p&gt;
&lt;p&gt;而这段代码正好没有被执行。&lt;/p&gt;
&lt;p&gt;再次进入源码查看，发现了个惊人的事情：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201806281534237c208467-97bf-4cd4-845f-8d22fec93df0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;这个AZ_BACKFILL_INSTANCES_NUM参数的实际key值，应该是az.backfill. instances.num，而开发兄弟在需求和jira中写的都是“az.backfill. concurrent.num”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时，我的心情是复杂的。此处需要省略1000字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如你所知，后续修改参数key后，重新测试，成功测试通过。通过后的覆盖率统计情况：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153440b0695382-0070-48fe-bac4-8ad88bbfee64.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;唯一没有覆盖的行，是因为设置的并发参数的值是5，在该1-100范围内，所以没有进入该判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例子二：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;p&gt;篇幅有限，再来简单介绍另外个利用CR平台完善测试的例子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将执行节点的流实例并发数量的值写进db，在节点服务启动时，优先从db中读取加载进内存。如果db中不包含，再从配置文件读取。&lt;/p&gt;
&lt;p&gt;简单测试后， 看下CR平台的覆盖情况：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180628153455e21487a9-bf87-43c6-8d54-d1fc297c1ab9.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以看到，对于基本的正常功能，我们还是覆盖到了。 但是仍有大部分语句没有覆盖，而这部分未覆盖的内容其实就是查询数据库时发生异常情况。&lt;/p&gt;
&lt;p&gt;知道未覆盖的原因，就好办了，我们只要制造数据库查询异常就可以模拟该场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行数据库语句alter table executors drop column threads_num; 将mysql中executor表的threads_num字段给删掉。然后重新启动executor。并确保executor可以正常工作。&lt;/p&gt;
&lt;p&gt;再次执行覆盖率统计，查看CR平台的结果：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201806281535092740fd70-e21d-4447-9daf-c9297f14a704.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可以看到，这下“新修改”的代码全部覆盖了。可以妥妥地在jira上标上这功能测试通过。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近看了一些业界的测试方法，发现基于覆盖率统计的白盒测试的热度正在逐渐提升，包括腾讯、去哪儿等一些公司都有基于覆盖率统计指导测试的不少实践。包括分析代码增量覆盖率，分析每条用例对覆盖率的贡献来精简测试用例集、剔除无效用例，基于执行覆盖统计将每条用例与代码模块相对应等等。所幸，我们也有CR平台，基于CR平台，我们后续可以做的事情应该还有很多。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 12 Nov 2018 11:42:00 +0000</pubDate>
<dc:creator>zni.feng</dc:creator>
<og:description>以前写的一篇旧文章，今天偶然发现被刊登在网易云6月份的博客上（https://sq.163yun.com/blog/article/170691322392797184），mark下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/znicy/p/9948607.html</dc:identifier>
</item>
</channel>
</rss>