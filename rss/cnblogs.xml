<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux的硬盘分区 - 前鹿</title>
<link>http://www.cnblogs.com/nanlu/p/9003026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanlu/p/9003026.html</guid>
<description>&lt;p&gt;    关于硬盘分区,这里先只讨论硬盘分区的方法在linux环境下,其他知识以后也会陆续说到&lt;/p&gt;
&lt;p&gt;    首先我们通过 df 命令查看一下硬盘的使用情况,在安装硬盘分区后做比较用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# df -&lt;span&gt;h
Filesystem            Size  Used Avail Use&lt;/span&gt;%&lt;span&gt; Mounted on
&lt;/span&gt;/dev/sda2              16G  &lt;span&gt;2&lt;/span&gt;.2G   13G  &lt;span&gt;15&lt;/span&gt;% /&lt;span&gt;
tmpfs                1012M  444K 1012M   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;% /dev/&lt;span&gt;shm
&lt;/span&gt;/dev/sda1             291M   29M  248M  &lt;span&gt;11&lt;/span&gt;% /&lt;span&gt;boot
&lt;/span&gt;/dev/sr1              &lt;span&gt;2&lt;/span&gt;.8G  &lt;span&gt;2&lt;/span&gt;.8G     &lt;span&gt;0&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;% /media/RHEL_6.&lt;span&gt;0&lt;/span&gt; i386 Disc &lt;span&gt;1&lt;/span&gt;
/dev/sr0               45M   45M     &lt;span&gt;0&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;% /media/CDROM
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 我们再通过fdisk命令 查看一下硬盘的分区情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# fdisk -&lt;span&gt;l

Disk &lt;/span&gt;/dev/sda: &lt;span&gt;21.5&lt;/span&gt; GB, &lt;span&gt;21474836480&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; heads, &lt;span&gt;63&lt;/span&gt; sectors/track, &lt;span&gt;2610&lt;/span&gt;&lt;span&gt; cylinders
Units &lt;/span&gt;= cylinders of &lt;span&gt;16065&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;8225280&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Disk identifier: &lt;/span&gt;&lt;span&gt;0x0008a5e5&lt;/span&gt;&lt;span&gt;

   Device Boot      Start         End      Blocks   Id  System
&lt;/span&gt;/dev/sda1   *           &lt;span&gt;1&lt;/span&gt;          &lt;span&gt;39&lt;/span&gt;      &lt;span&gt;307200&lt;/span&gt;   &lt;span&gt;83&lt;/span&gt;&lt;span&gt;  Linux
Partition &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; does not end on cylinder boundary.
&lt;/span&gt;/dev/sda2              &lt;span&gt;39&lt;/span&gt;        &lt;span&gt;2093&lt;/span&gt;    &lt;span&gt;16501760&lt;/span&gt;   &lt;span&gt;83&lt;/span&gt;&lt;span&gt;  Linux
&lt;/span&gt;/dev/sda3            &lt;span&gt;2093&lt;/span&gt;        &lt;span&gt;2611&lt;/span&gt;     &lt;span&gt;4161536&lt;/span&gt;   &lt;span&gt;82&lt;/span&gt;  Linux swap /&lt;span&gt; Solaris

Disk &lt;/span&gt;/dev/sdb: &lt;span&gt;16.1&lt;/span&gt; GB, &lt;span&gt;16106127360&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; heads, &lt;span&gt;63&lt;/span&gt; sectors/track, &lt;span&gt;1958&lt;/span&gt;&lt;span&gt; cylinders
Units &lt;/span&gt;= cylinders of &lt;span&gt;16065&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;8225280&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Disk identifier: &lt;/span&gt;&lt;span&gt;0x00000000&lt;/span&gt;&lt;span&gt;

Disk &lt;/span&gt;/dev/sdb doesn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t contain a valid partition table&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; sda&lt;/span&gt; 表示已经完成分区并在使用,&lt;span&gt;sdb&lt;/span&gt;表示尚未分区,也就是我们下边要进行的操作对象,dev表示硬盘&lt;/p&gt;
&lt;p&gt;我们使用 fdisk 命令来对 的 sdb来进行分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# fdisk /dev/&lt;span&gt;sdb
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DOS disklabel with disk identifier &lt;span&gt;0xe3b900aa&lt;/span&gt;&lt;span&gt;.
Changes will remain &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; memory only, until you decide to write them.
After that, of course, the previous content won&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t be recoverable.&lt;/span&gt;
&lt;span&gt;
Warning: invalid flag &lt;/span&gt;&lt;span&gt;0x0000&lt;/span&gt; of partition table &lt;span&gt;4&lt;/span&gt;&lt;span&gt; will be corrected by w(rite)

WARNING: DOS&lt;/span&gt;-compatible mode &lt;span&gt;is&lt;/span&gt; deprecated. It&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s strongly recommended to&lt;/span&gt;
         &lt;span&gt;switch&lt;/span&gt; off the mode (command &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) and change display units to
         sectors (command &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).

Command (m &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; help): 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 下面介绍一下 &lt;span&gt;command (m for help):&lt;/span&gt; 常用的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel 
   c   toggle the dos compatibility flag
   d   delete a partition    &lt;span&gt; /*分区完成后,如果对分区不满意可以通过此删除分区,进行重新分区*/&lt;/span&gt;
   l   list known partition types  &lt;span&gt; /*显示分区的方式*/&lt;/span&gt;
   m   print &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; menu      &lt;span&gt; /*回到这个菜单*/&lt;/span&gt;
   n   add a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; partition   &lt;span&gt;/*建立一个新的分区*/&lt;/span&gt;
   o   create a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; empty DOS partition table
   p   print the partition table &lt;span&gt; &lt;span&gt; /*显示分区列表*/&lt;/span&gt;&lt;/span&gt;
   q   quit without saving changes  &lt;span&gt; /*不保存退出*/&lt;/span&gt;
   s   create a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; empty Sun disklabel  
   t   change a partition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s system id&lt;/span&gt;
   u   change display/&lt;span&gt;entry units
   v   verify the partition table
   w   write table to disk and exit  &lt;span&gt; /*保存退出,分区完成后一定要输入w,否则一切为空,回到解放前*/&lt;/span&gt;
   x   extra functionality (experts only)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们先创建一个新的分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Command action
   e   extended &lt;span&gt; /*代表扩展分区,但扩展分区不可以直接使用,需要分为逻辑分区后方可使用,逻辑分区从5开始*/&lt;/span&gt;
   p   primary partition (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;)  &lt;span&gt; /*代表主分区,硬盘只能有四个主分区,从1-4 扩展分区也算一个主分区,主分区可以直接使用*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 先进行创建主分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
   p   primary partition (&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
p
Partition number (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;): &lt;span&gt;1     &lt;span&gt;/*表示盘符编码,1-4任意都可以,我们符合习惯从1开始*/&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
First cylinder (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;1958&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;): &lt;span&gt;1  &lt;span&gt;/*此处表示此分区的开始位置,我们假设a,a属于(1-1958) 可以直接回车,默认为1,我们同样从1开始,符合习惯*/&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
Last cylinder, &lt;/span&gt;+cylinders or +size{K,M,G} (&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;1958&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;1958&lt;/span&gt;): +5G   &lt;span&gt;/*此处表示此分区的结束位置,我们假设为b b属于 (a+1 - 1958),此硬盘大小则为 b-a  或者更加便捷直接输入我们想要的硬盘大小,前加上 &quot;+&quot; 即可*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到此处第一个主分区已经完成,我们可以通过 参数 p 来查看一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): p

Disk &lt;/span&gt;/dev/sdb: &lt;span&gt;16.1&lt;/span&gt; GB, &lt;span&gt;16106127360&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; heads, &lt;span&gt;63&lt;/span&gt; sectors/track, &lt;span&gt;1958&lt;/span&gt;&lt;span&gt; cylinders
Units &lt;/span&gt;= cylinders of &lt;span&gt;16065&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;8225280&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Disk identifier: &lt;/span&gt;&lt;span&gt;0xe3b900aa&lt;/span&gt;&lt;span&gt;

   Device Boot      Start         End      Blocks   Id  System
&lt;/span&gt;/dev/sdb1               &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;654&lt;/span&gt;     &lt;span&gt;5253223&lt;/span&gt;+  &lt;span&gt;83&lt;/span&gt;  Linux&lt;br/&gt;开始位置     结束位置    &lt;span&gt;分区大小,单位是byte,小数点向前移动,三位,可以获得大致大小&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到,第一个分区已经完成,下边我们来分一个扩展分区,同样 先通过参数 n 创建一个新的分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Command action
   e   extended 
   p   primary partition (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们要进行的扩展分区,所以我们输入 参数  e &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Command action
   e   extended
   p   primary partition (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
e
Partition number (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;): &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
First cylinder (&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;-&lt;span&gt;1958&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;655&lt;/span&gt;): &lt;span&gt;655   /*因为我们第一个分区占用了 (1- 654) ,所以此时默认从655开始 */&lt;/span&gt;&lt;span&gt;
Last cylinder, &lt;/span&gt;+cylinders or +size{K,M,G} (&lt;span&gt;655&lt;/span&gt;-&lt;span&gt;1958&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;1958&lt;/span&gt;): +6G  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时扩展分区已经分区完成,同样的我们通过 参数 p来查看一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): p

Disk &lt;/span&gt;/dev/sdb: &lt;span&gt;16.1&lt;/span&gt; GB, &lt;span&gt;16106127360&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; heads, &lt;span&gt;63&lt;/span&gt; sectors/track, &lt;span&gt;1958&lt;/span&gt;&lt;span&gt; cylinders
Units &lt;/span&gt;= cylinders of &lt;span&gt;16065&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;8225280&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Disk identifier: &lt;/span&gt;&lt;span&gt;0xe3b900aa&lt;/span&gt;&lt;span&gt;

   Device Boot      Start         End      Blocks   Id  System
&lt;/span&gt;/dev/sdb1               &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;654&lt;/span&gt;     &lt;span&gt;5253223&lt;/span&gt;+  &lt;span&gt;83&lt;/span&gt;&lt;span&gt;  Linux
&lt;/span&gt;/dev/sdb2             &lt;span&gt;655&lt;/span&gt;        &lt;span&gt;1438&lt;/span&gt;     &lt;span&gt;6297480&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt;  Extended &lt;span&gt;/*表示这是一个逻辑分区*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展分区是不能直接使用的,我们必须把扩展分区分成逻辑分区后才可以使用,同样的我们 采用参数 n 创建一个新的分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): n
Command action
   l   logical (&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; or over)&lt;span&gt; /*此时可以发现,此处有Extended 变成了 logical  因为扩展分区只能存在一个,logical表示逻辑分区*/&lt;/span&gt;
   p   primary partition (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们选择参数 l 分出逻辑分区&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;l
First cylinder (&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;-&lt;span&gt;1438&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;655&lt;/span&gt;): &lt;span&gt;655&lt;/span&gt;&lt;span&gt;
Last cylinder, &lt;/span&gt;+cylinders or +size{K,M,G} (&lt;span&gt;655&lt;/span&gt;-&lt;span&gt;1438&lt;/span&gt;, &lt;span&gt;default&lt;/span&gt; &lt;span&gt;1438&lt;/span&gt;): +&lt;span&gt;3G
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时逻辑分区已经完成 ,同样的我们使用参数 p 来查看一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): p

Disk &lt;/span&gt;/dev/sdb: &lt;span&gt;16.1&lt;/span&gt; GB, &lt;span&gt;16106127360&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; heads, &lt;span&gt;63&lt;/span&gt; sectors/track, &lt;span&gt;1958&lt;/span&gt;&lt;span&gt; cylinders
Units &lt;/span&gt;= cylinders of &lt;span&gt;16065&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;8225280&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Disk identifier: &lt;/span&gt;&lt;span&gt;0xe3b900aa&lt;/span&gt;&lt;span&gt;

   Device Boot      Start         End      Blocks   Id  System
&lt;/span&gt;/dev/sdb1               &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;654&lt;/span&gt;     &lt;span&gt;5253223&lt;/span&gt;+  &lt;span&gt;83&lt;/span&gt;&lt;span&gt;  Linux
&lt;/span&gt;/dev/sdb2             &lt;span&gt;655&lt;/span&gt;        &lt;span&gt;1438&lt;/span&gt;     &lt;span&gt;6297480&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt;&lt;span&gt;  Extended
&lt;/span&gt;/dev/sdb5             &lt;span&gt;655&lt;/span&gt;        &lt;span&gt;1047&lt;/span&gt;     &lt;span&gt;3156741&lt;/span&gt;   &lt;span&gt;83&lt;/span&gt;  Linux &lt;span&gt;/*逻辑分区从5开始,1-4只能是主分区*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是分区已经完成,最后一步,参数 w 保存退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Command (m &lt;span&gt;for&lt;/span&gt;&lt;span&gt; help): w
The partition table has been altered&lt;/span&gt;!&lt;span&gt;

Calling ioctl() to re&lt;/span&gt;-&lt;span&gt;read partition table.
Syncing disks.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;硬盘完成分区之后,并不能直接使用,需要进行格式化以及挂载才能使用&lt;/p&gt;
&lt;p&gt;格式化 我们采用 mkfs命令,简单介绍一下mkfs命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    mkfs命令用于在设备上（通常为硬盘）创建Linux文件系统。mkfs本身并不执行建立文件系统的工作，而是去调用相关的程序来执行
    mkfs (选项) (参数)
    
     mkfs：指定建立文件系统时的参数；
      &lt;/span&gt;-t&amp;lt;文件系统类型&amp;gt;&lt;span&gt;：指定要建立何种文件系统；
      &lt;/span&gt;-&lt;span&gt;v：显示版本信息与详细的使用方法；
      &lt;/span&gt;-&lt;span&gt;V：显示简要的使用方法；
      &lt;/span&gt;-&lt;span&gt;c：在制做档案系统前，检查该partition是否有坏轨

    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们来进行格式化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# mkfs -t ext4 /dev/&lt;span&gt;sdb1
mke2fs &lt;/span&gt;&lt;span&gt;1.41&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt; (&lt;span&gt;17&lt;/span&gt;-May-&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;)
Filesystem label&lt;/span&gt;=&lt;span&gt;
OS type: Linux
Block size&lt;/span&gt;=&lt;span&gt;4096&lt;/span&gt; (log=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
Fragment size&lt;/span&gt;=&lt;span&gt;4096&lt;/span&gt; (log=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
Stride&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt; blocks, Stripe width=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; blocks
&lt;/span&gt;&lt;span&gt;328656&lt;/span&gt; inodes, &lt;span&gt;1313305&lt;/span&gt;&lt;span&gt; blocks
&lt;/span&gt;&lt;span&gt;65665&lt;/span&gt; blocks (&lt;span&gt;5.00&lt;/span&gt;%) reserved &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the super user
First data block&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Maximum filesystem blocks&lt;/span&gt;=&lt;span&gt;1346371584&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;&lt;span&gt; block groups
&lt;/span&gt;&lt;span&gt;32768&lt;/span&gt; blocks per group, &lt;span&gt;32768&lt;/span&gt;&lt;span&gt; fragments per group
&lt;/span&gt;&lt;span&gt;8016&lt;/span&gt;&lt;span&gt; inodes per group
Superblock backups stored on blocks: 
    &lt;/span&gt;&lt;span&gt;32768&lt;/span&gt;, &lt;span&gt;98304&lt;/span&gt;, &lt;span&gt;163840&lt;/span&gt;, &lt;span&gt;229376&lt;/span&gt;, &lt;span&gt;294912&lt;/span&gt;, &lt;span&gt;819200&lt;/span&gt;, &lt;span&gt;884736&lt;/span&gt;&lt;span&gt;

Writing inode tables: done                            
Creating journal (&lt;/span&gt;&lt;span&gt;32768&lt;/span&gt;&lt;span&gt; blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically &lt;/span&gt;&lt;span&gt;checked&lt;/span&gt; every &lt;span&gt;27&lt;/span&gt;&lt;span&gt; mounts or
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; days, whichever comes first.  Use tune2fs -c or -i to &lt;span&gt;override&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_1a11a017-1ffb-4f54-97f7-8fc3b66ddf96&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1a11a017-1ffb-4f54-97f7-8fc3b66ddf96&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1a11a017-1ffb-4f54-97f7-8fc3b66ddf96&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# mkfs -t ext4 /dev/&lt;span&gt;sdb2
mke2fs &lt;/span&gt;&lt;span&gt;1.41&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt; (&lt;span&gt;17&lt;/span&gt;-May-&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;)
mkfs.ext4: inode_size (&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;) * inodes_count (&lt;span&gt;0&lt;/span&gt;) too big &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a
    filesystem with &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; blocks, specify higher inode_ratio (-&lt;span&gt;i)
    or lower inode count (&lt;/span&gt;-&lt;span&gt;N).

[root@bogon &lt;/span&gt;~]# mkfs -t ext4 /dev/&lt;span&gt;sdb5
mke2fs &lt;/span&gt;&lt;span&gt;1.41&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt; (&lt;span&gt;17&lt;/span&gt;-May-&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;)
Filesystem label&lt;/span&gt;=&lt;span&gt;
OS type: Linux
Block size&lt;/span&gt;=&lt;span&gt;4096&lt;/span&gt; (log=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
Fragment size&lt;/span&gt;=&lt;span&gt;4096&lt;/span&gt; (log=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
Stride&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt; blocks, Stripe width=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; blocks
&lt;/span&gt;&lt;span&gt;197600&lt;/span&gt; inodes, &lt;span&gt;789185&lt;/span&gt;&lt;span&gt; blocks
&lt;/span&gt;&lt;span&gt;39459&lt;/span&gt; blocks (&lt;span&gt;5.00&lt;/span&gt;%) reserved &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the super user
First data block&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Maximum filesystem blocks&lt;/span&gt;=&lt;span&gt;809500672&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;&lt;span&gt; block groups
&lt;/span&gt;&lt;span&gt;32768&lt;/span&gt; blocks per group, &lt;span&gt;32768&lt;/span&gt;&lt;span&gt; fragments per group
&lt;/span&gt;&lt;span&gt;7904&lt;/span&gt;&lt;span&gt; inodes per group
Superblock backups stored on blocks: 
    &lt;/span&gt;&lt;span&gt;32768&lt;/span&gt;, &lt;span&gt;98304&lt;/span&gt;, &lt;span&gt;163840&lt;/span&gt;, &lt;span&gt;229376&lt;/span&gt;, &lt;span&gt;294912&lt;/span&gt;&lt;span&gt;

Writing inode tables: done                            
Creating journal (&lt;/span&gt;&lt;span&gt;16384&lt;/span&gt;&lt;span&gt; blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically &lt;/span&gt;&lt;span&gt;checked&lt;/span&gt; every &lt;span&gt;25&lt;/span&gt;&lt;span&gt; mounts or
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; days, whichever comes first.  Use tune2fs -c or -i to &lt;span&gt;override&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;[root@bogon ~]# mkfs -t ext4 /dev/sdb2&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;格式化完成之后我们来进行硬盘的挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# mkdir /&lt;span&gt;tmp1
[root@bogon &lt;/span&gt;~]# mkdir /&lt;span&gt;tmp2
[root@bogon &lt;/span&gt;~]# mount /dev/sdb1 /&lt;span&gt;tmp1
[root@bogon &lt;/span&gt;~]# mount /dev/sdb5 /tmp2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时挂载完毕,我们来通过 df 命令来查看一下我们是否成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# df -&lt;span&gt;h
Filesystem            Size  Used Avail Use&lt;/span&gt;%&lt;span&gt; Mounted on
&lt;/span&gt;/dev/sda2              16G  &lt;span&gt;2&lt;/span&gt;.2G   13G  &lt;span&gt;15&lt;/span&gt;% /&lt;span&gt;
tmpfs                1012M  444K 1012M   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;% /dev/&lt;span&gt;shm
&lt;/span&gt;/dev/sda1             291M   29M  248M  &lt;span&gt;11&lt;/span&gt;% /&lt;span&gt;boot
&lt;/span&gt;/dev/sr1              &lt;span&gt;2&lt;/span&gt;.8G  &lt;span&gt;2&lt;/span&gt;.8G     &lt;span&gt;0&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;% /media/RHEL_6.&lt;span&gt;0&lt;/span&gt; i386 Disc &lt;span&gt;1&lt;/span&gt;
/dev/sr0               45M   45M     &lt;span&gt;0&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;% /media/&lt;span&gt;CDROM
&lt;/span&gt;&lt;span&gt;/dev/sdb1             &lt;span&gt;5&lt;/span&gt;.0G  139M  &lt;span&gt;4&lt;/span&gt;.6G   &lt;span&gt;3&lt;/span&gt;% /&lt;span&gt;tmp1
&lt;/span&gt;/dev/sdb5             &lt;span&gt;3&lt;/span&gt;.0G   69M  &lt;span&gt;2&lt;/span&gt;.8G   &lt;span&gt;3&lt;/span&gt;% /tmp2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到,我们已经完成了硬盘的分区以及格式化和挂载,但是由于linux的特殊性,若我们不把此分区写入配置文件,我们下次重启是,此分区是消失的&lt;/p&gt;
&lt;p&gt;下面我们通过vim 将其写入配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# vim /etc/&lt;span&gt;fstab


&lt;span&gt;/dev/sdb1 /part1 ext4 defaults 0 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/dev/sdb5 /part1 ext4 defaults 0 0&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
#
# &lt;/span&gt;/etc/&lt;span&gt;fstab
# Created by anaconda on Wed Mar  &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;
#
# Accessible filesystems, by reference, are maintained under &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/dev/disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
# See man pages fstab(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;), findfs(&lt;span&gt;8&lt;/span&gt;), mount(&lt;span&gt;8&lt;/span&gt;) and/or blkid(&lt;span&gt;8&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt;&lt;span&gt; more info
#
UUID&lt;/span&gt;=93de9377-f280-4fad-959e-bfc88b5ffeff /                       ext4    defaults        &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
UUID&lt;/span&gt;=d303ecd7-a97e-4dbe-a543-01b8db0362cc /boot                   ext4    defaults        &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
UUID&lt;/span&gt;=5cb80a30-6c26-47d2-b82d-cef4de688119 swap                    swap    defaults        &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
tmpfs                   &lt;/span&gt;/dev/shm                tmpfs   defaults        &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
devpts                  &lt;/span&gt;/dev/pts                devpts  gid=&lt;span&gt;5&lt;/span&gt;,mode=&lt;span&gt;620&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
sysfs                   &lt;/span&gt;/sys                    sysfs   defaults        &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
proc                    &lt;/span&gt;/proc                   proc    defaults        &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
~                                                                                               
~                                                                                               
~                                                                                               
~                                                                                               
~                                                                                               
~                                                                                               
~                                                                                               
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/fstab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;17L&lt;/span&gt;, 842C                                                        &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;           All
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时代表完成,输入wq保存退出即可&lt;/p&gt;
&lt;p&gt;到此关于硬盘分区的操作到此结束,其他方面自己学习之后会再进行分享,谢谢大家&lt;/p&gt;
&lt;p&gt;文中如有错误不足,希望大家多多包涵指正&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 07:35:00 +0000</pubDate>
<dc:creator>前鹿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanlu/p/9003026.html</dc:identifier>
</item>
<item>
<title>python正则表达式 - 雨落滴碎荷</title>
<link>http://www.cnblogs.com/yuluodisuihe/p/8650057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuluodisuihe/p/8650057.html</guid>
<description>&lt;h2&gt;一、元字符&lt;/h2&gt;
&lt;p&gt;  .  匹配任意字符（不包括换行符）&lt;br/&gt;  ^  匹配开始位置，多行模式下匹配每一行开始&lt;br/&gt;  $  匹配结果位置，多行模式下匹配每一行结尾&lt;br/&gt;  *  匹配前一个元字符0到多次&lt;br/&gt;  +  匹配前一个元字符1到多次&lt;br/&gt;  ？ 匹配前一个元字符0到1次&lt;br/&gt;  {m,n} 匹配前一个元字符m到n此&lt;br/&gt;  |  或，匹配|左右表达式任意一个&lt;br/&gt;  [] 字符集，对应位置可以是字符集中的任意一个&lt;br/&gt;  () 分组，从左到右每遇到一个编号+1&lt;br/&gt;  \d 匹配数字&lt;br/&gt;  \D 匹配非数字&lt;br/&gt;  \w 匹配字母和数字&lt;br/&gt;  \W 匹配非英文字母和数字&lt;br/&gt;  \s 匹配空白字符&lt;br/&gt; &lt;br/&gt;  特殊分组：原本分组只是从左到右编号+1，特殊分组可对分组添加别名&lt;br/&gt;  (?P&amp;lt;name&amp;gt;) 未分组添加别名name&lt;br/&gt;  (?P=name)  在使用分组别名对分组进行匹配&lt;/p&gt;

&lt;h2&gt;二、模式&lt;/h2&gt;
&lt;h3&gt;  1、忽略大小写  I&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; regex = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,re.I)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; regex.match(a) 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  2、多行模式  M&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt; sfasdf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;ghdfg
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;sgsdfg&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; regex = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^ s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,re.M)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; regex.match(a).group()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、re内置函数&lt;/h2&gt;
&lt;h3&gt;   1、compile(pattern,flags=0)    &lt;/h3&gt;
&lt;p&gt;      &lt;strong&gt;pattern：&lt;/strong&gt;用来匹配的字符串&lt;br/&gt;      &lt;strong&gt;flags：&lt;/strong&gt;定义匹配使用的模式。如re.I忽略大小写&lt;br/&gt;      &lt;strong&gt;作用：&lt;/strong&gt;编译正则表达式模式，返回一个对象模式（常用的表达式使用其编译后可提高效率）。&lt;/p&gt;
&lt;h3&gt;   2、match(parttern,string,flags=0)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;string：&lt;/strong&gt;被匹配的字符串&lt;br/&gt;     &lt;strong&gt;作用：&lt;/strong&gt;从被匹配的字符串左边第一位开始匹配，匹配成功返回match object对象，匹配失败则返回None&lt;br/&gt;     &lt;strong&gt;注：&lt;/strong&gt;该方法并非完全匹配，要想实现完全匹配的效果可在用来匹配的字符串后加'$'   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; re.match(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a,re.I)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;   3、search(parttern,string,flags=0)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;作用：&lt;/strong&gt;在string进行查找相匹配的字符串，匹配成功返回match object对象，匹配失败返回None&lt;br/&gt;     &lt;strong&gt;注：&lt;/strong&gt;1.该函数要实现match函数的功能可在匹配字符串前加'^'&lt;br/&gt;            2.该函数要实现完全匹配可在字符串前后分别加'^','$'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^ello world$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     &lt;strong&gt;注：对match object提供的方法(得到匹配成功返回的数据)&lt;/strong&gt;&lt;br/&gt;        1、group() :返回被匹配的字符串,可通过输入组号输出对应的内容&lt;br/&gt;        2、groups():以元组形式返回匹配到的所有内容&lt;br/&gt;        2、start() :返回匹配开始的位置&lt;br/&gt;        3、end()   :返回匹配结束的位置&lt;br/&gt;        4、span()  :返回一个元组（匹配开始、结束的位置）&lt;/p&gt;

&lt;h3&gt;   4、findall(pattern,string,flags=0)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;作用：&lt;/strong&gt;遍历匹配，以列表的形式返回所有能够被匹配的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;python2 Python3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; regex = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; regex.findall(a)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['2','3']  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;   5、finditer(parttern,string,flags=0)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;作用：&lt;/strong&gt;作用与findall相同，但返回的为迭代器&lt;br/&gt;       &lt;/p&gt;
&lt;h3&gt;   6、split(pattern,string[,maxsplit])&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;maxsplit:&lt;/strong&gt;最大分割数，不指定将全部分割&lt;br/&gt;     &lt;strong&gt;作用：&lt;/strong&gt;在string中匹配与pattern相同的字符，对string进行分割&lt;br/&gt;    &lt;/p&gt;
&lt;h3&gt;   7、sub(pattern,repl,string,count)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;repl：&lt;/strong&gt;需要替换的字符串&lt;br/&gt;     &lt;strong&gt;count：&lt;/strong&gt;替换个数，默认为0，即每个都替换&lt;br/&gt;     &lt;strong&gt;作用：&lt;/strong&gt;使用repl替换在string中匹配到pattern的字符，并返回被替换后的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; re.sub(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w\D+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;hello python&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;   8.subn(pattern,repl,string,count=0,flags=0)&lt;/h3&gt;
&lt;p&gt;     &lt;strong&gt;作用：&lt;/strong&gt;作用与sub类似，会返回一个元组，即替换后的字符串及替换的次数。&lt;br/&gt;    &lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 07:33:00 +0000</pubDate>
<dc:creator>雨落滴碎荷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuluodisuihe/p/8650057.html</dc:identifier>
</item>
<item>
<title>DDD实战进阶第一波(九)：开发一般业务的大健康行业直销系统（实现经销商上下文仓储与领域逻辑） - 曹剑</title>
<link>http://www.cnblogs.com/malaoko/p/9002653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/malaoko/p/9002653.html</guid>
<description>&lt;p&gt;上篇文章主要讲述了经销商上下文的需求与POCO对象，这篇文章主要讲述该界限上下文的仓储与领域逻辑的实现。&lt;/p&gt;
&lt;p&gt;关于界限上下文与EF Core数据访问上下文参考产品上下文相应的实现，这里不再累述。&lt;/p&gt;
&lt;p&gt;因为在经销商上下文中有两个聚合，一个是经销商聚合，一个是登录聚合，所以我们需要实现两个仓储接口：&lt;/p&gt;
&lt;p&gt;1.经销商仓储接口定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDealerRepository
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; CreateDealer&amp;lt;T&amp;gt;(T dealer) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, IAggregationRoot;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取上级经销商(当前代注册经销商)的层次结构&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetParentDealerLayer(Guid dealerid);
        &lt;/span&gt;&lt;span&gt;//将&lt;/span&gt;&lt;span&gt;上级经销商（代注册经销商）的子个数加一&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; AddParentSubCount(Guid?&lt;span&gt; parentdealerid);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减去父进销商的电子币（用于注册和下单时，扣减经销商的电子币）&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; SubParentEleMoney(Guid parentdealerid, &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; subelemoney);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下订单时，增加经销商的PV&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; AddDealerPV(Guid dealerid, &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; orderpv);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.登录仓储接口定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILoginRepository
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; CreateLogin&amp;lt;T&amp;gt;(T login) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, IAggregationRoot;
        Guid UserLogin(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; tel, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; password);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.具体对应的仓储实现在仓储实现的项目中自己实现，主要通过EF Core完成数据库的访问与操作。&lt;/p&gt;

&lt;p&gt;4.经销商聚合中联系人对象的领域逻辑实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contact
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Contact CreateContact(Guid dealerid,&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;string&lt;/span&gt; tel,&lt;span&gt;string&lt;/span&gt; province,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; city,
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; zero,&lt;span&gt;string&lt;/span&gt; street,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; isdefault)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DealerId =&lt;span&gt; dealerid;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ContactName =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ContactTel =&lt;span&gt; tel;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Province =&lt;span&gt; province;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.City =&lt;span&gt; city;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Zero =&lt;span&gt; zero;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Street =&lt;span&gt; street;
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (isdefault)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;this&lt;/span&gt;.IsDefault =&lt;span&gt; IsDefaultContact.默认;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;span&gt;this&lt;/span&gt;.IsDefault =&lt;span&gt; IsDefaultContact.非默认;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.经销商聚合中经销商层次结构对象的领域逻辑实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DealerTree
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IDealerRepository idealerrepository;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DealerTree(IDealerRepository idealerrepository)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idealerrepository =&lt;span&gt; idealerrepository;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DealerTree CreateDealerTree(Guid?&lt;span&gt; parentdealerid,Guid dealerid)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DealerId =&lt;span&gt; dealerid;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ParentDealerId =&lt;span&gt; parentdealerid;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Layer = parentdealerid == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt; : idealerrepository.GetParentDealerLayer(Guid.Parse(parentdealerid.ToString())) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.经销商聚合中经销商对象的领域逻辑实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dealers
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IDealerRepository idealerrepository;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dealers(IDealerRepository idealerrepository)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idealerrepository =&lt;span&gt; idealerrepository;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dealers RegisterDealer(Guid id,&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;string&lt;/span&gt; tel,&lt;span&gt;decimal&lt;/span&gt; telmoney,List&amp;lt;Contact&amp;gt;&lt;span&gt;
            contacts,Guid&lt;/span&gt;?&lt;span&gt; parentid)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; id;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Tel =&lt;span&gt; tel;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.TotalEleMoney =&lt;span&gt; telmoney;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (telmoney &amp;lt; &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CardType =&lt;span&gt; CardType.普通会员;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (telmoney &amp;gt;= &lt;span&gt;2000&lt;/span&gt; &amp;amp;&amp;amp; telmoney &amp;lt; &lt;span&gt;4000&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CardType =&lt;span&gt; CardType.银卡会员;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CardType =&lt;span&gt; CardType.金卡会员;
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.SubCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.TotalPV = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.JiangJInMoney = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Contacts =&lt;span&gt; contacts;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DealerTree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DealerTree(idealerrepository).CreateDealerTree(parentid, id);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.登录聚合中登录对象的领域逻辑实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Login
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Login CreateLogin(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; code,Guid dealerid)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机号&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.Code =&lt;span&gt; code;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认初始密码&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.Password=MD5Encrption.GetMd5Str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DealerId =&lt;span&gt; dealerid;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就完成了基本数据库的访问、操作和相关领域逻辑的实现。&lt;/p&gt;

&lt;p&gt;QQ讨论群：&lt;span lang=&quot;EN-US&quot;&gt;309287205&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;DDD实战进阶视频请关注微信公众号：&lt;img src=&quot;https://images2018.cnblogs.com/blog/56104/201805/56104-20180502113226097-1323446519.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 07 May 2018 06:46:00 +0000</pubDate>
<dc:creator>曹剑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/malaoko/p/9002653.html</dc:identifier>
</item>
<item>
<title>async/await 的基本实现和 .NET Core 2.1 中相关性能提升 - 白细胞</title>
<link>http://www.cnblogs.com/Wddpct/p/9002242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wddpct/p/9002242.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;这篇文章的开头，笔者想多说两句，不过也是为了以后再也不多嘴这样的话。&lt;/p&gt;
&lt;p&gt;在日常工作中，笔者接触得最多的开发工作仍然是在 .NET Core 平台上，当然因为团队领导的开放性和团队风格的多样性（这和 CTO 以及主管的个人能力也是分不开的），业界前沿的技术概念也都能在上手的项目中出现。所以虽然现在团队仍然处于疾速的发展中，也存在一些奇奇怪怪的事情，工作内容也算有紧有松，但是总体来说也算有苦有乐，不是十分排斥。&lt;/p&gt;
&lt;p&gt;其实这样的环境有些类似于笔者心中的“圣地” Thoughtworks 的 雏形（TW的HR快来找我啊），笔者和女朋友谈到自己最想做的工作也是技术咨询。此类技术咨询公司的开发理念基本可以用一句概括：&lt;strong&gt;遵循可扩展开发，可快速迭代，可持续部署，可的架构设计，追求目标应用场景下最优于团队的技术选型决策&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以语言之争也好，平台之争也好，落到每一个对编程和解决问题感兴趣的开发者身上，便成了最微不足道的问题。能够感受不同技术间的碰撞，领略到不同架构思想中的精妙，就已经是一件满足的事情了，等到团队需要你快速应用其他技术选型时，之前的努力也是助力。当然面向工资编程也是一种取舍，笔者思考的时候也会陷入这个怪圈，所以希望在不断的学习和实践中，能够让自己更满意吧。&lt;/p&gt;
&lt;p&gt;著名的 DRY 原则告诉我们 —— Don't repeat yourself，而笔者想更进一步的是，Deep Dive And Wide Mind，深入更多和尝试更多。&lt;/p&gt;
&lt;p&gt;奇怪的前言就此结束。&lt;/p&gt;
&lt;p&gt;作为最新的正式版本，虽然版本号只是小小的提升，但是 .NET Core 2.1 相比 .NET Core 2.0 在性能上又有了大大的提升。无论是项目构建速度，还是字符串操作，网络传输和 JIT 内联方法性能，可以这么说的是，如今的 .NET Core 已经主动为开发者带来抠到字节上的节省体验。具体的介绍还请参看 &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/&quot;&gt;Performance Improvements in .NET Core 2.1&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;而在这篇文章里，笔者要聊聊的只是关于 async/await 的一些底层原理和 .NET Core 2.1 在异步操作对象分配上的优化操作。&lt;/p&gt;
&lt;h3 id=&quot;asyncawait-实现简介&quot;&gt;async/await 实现简介&lt;/h3&gt;
&lt;p&gt;熟悉异步操作的开发者都知道，async/await 的实现基本上来说是一个骨架代码（Template method）和状态机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/647983/201805/647983-20180507134811081-178016341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从反编译器中我们可以窥见骨架方法的全貌。假设有这样一个示例程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;internal class Program
{
    private static void Main()
    {
        var result = AsyncMethods.CallMethodAsync(&quot;async/await&quot;).GetAwaiter().GetResult();

        Console.WriteLine(result);
    }
}

internal static class AsyncMethods
{
    internal static async Task&amp;lt;int&amp;gt; CallMethodAsync(string arg)
    {
        var result = await MethodAsync(arg);

        await Task.Delay(result);

        return result;
    }

    private static async Task&amp;lt;int&amp;gt; MethodAsync(string arg)
    {
        var total = arg.First() + arg.Last();

        await Task.Delay(total);

        return total;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了能更好地显示编译代码，特地将异步操作分成两个方法来实现，即组成了一条异步操作链。这种“侵入性”传递对于开发其实是更友好的，当代码中的一部分采用了异步代码，整个传递链条上便不得不采用异步这样一种正确的方式。接下来让我们看看编译器针对上述异步方法生成的骨架方法和状态机（也已经经过美化产生可读的C#代码）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[DebuggerStepThrough]
[AsyncStateMachine((typeof(CallMethodAsyncStateMachine)]
private static Task&amp;lt;int&amp;gt; CallMethodAsync(string arg)
{
    CallMethodAsyncStateMachine stateMachine = new CallMethodAsyncStateMachine {
        arg = arg,
        builder = AsyncTaskMethodBuilder&amp;lt;int&amp;gt;.Create(),
        state = -1
    };
    stateMachine.builder.Start&amp;lt;CallMethodAsyncStateMachine&amp;gt;(
    (ref stateMachine)=&amp;gt;
    {
        // 骨架方法启动第一次 MoveNext 方法
        stateMachine.MoveNext();
    });
    
    return stateMachine.builder.Task;
}

[DebuggerStepThrough]
[AsyncStateMachine((typeof(MethodAsyncStateMachine)]
private static Task&amp;lt;int&amp;gt; MethodAsync(string arg)
{
    MethodAsyncStateMachine stateMachine = new MethodAsyncStateMachine {
        arg = arg,
        builder = AsyncTaskMethodBuilder&amp;lt;int&amp;gt;.Create(),
        state = -1
    };
    
    // 恢复委托函数
    Action __moveNext = () =&amp;gt; 
    {
        stateMachine.builder.Start&amp;lt;CallMethodAsyncStateMachine&amp;gt;(ref stateMachine);
    }
    
    __moveNext();
    
    return stateMachine.builder.Task;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MethodAsync/CallMethodAsync - 骨架方法&lt;/li&gt;
&lt;li&gt;MethodAsyncStateMachine/CallMethodAsyncStateMachine - 每个 async 标记的异步操作都会产生一个骨架方法和状态机对象&lt;/li&gt;
&lt;li&gt;arg - 显然原始代码上有多少个参数，生成的代码中就会有多少个字段&lt;/li&gt;
&lt;li&gt;__moveNext - 恢复委托函数，对应状态机中的 MoveNext 方法，该委托函数会在执行过程中作为回调函数返回给对应Task的 Awaiter 从而使得 MoveNext 持续执行&lt;/li&gt;
&lt;li&gt;builder - 该结构负责连接状态机和骨架方法&lt;/li&gt;
&lt;li&gt;state - 始终从 -1 开始，方法执行时状态也是1，非负值代表一个后续操作的目标，结束时状态为 -2&lt;/li&gt;
&lt;li&gt;Task - 代表当前异步操作完成后传播的任务，其内包含正确结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到，每个由 async 关键字标记的异步操作都会产生相应的骨架方法，而状态机也会在骨架方法中创建并运行。以下是实际的状态机内部代码，让我们用实际进行包含两步异步操作的 CallMethodAsyncStateMachine 做例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[CompilerGenerated]
private sealed class CallMethodAsyncStateMachine : IAsyncStateMachine
{
    public int state;
    public string arg;  // 代表变量
    
    public AsyncTaskMethodBuilder&amp;lt;int&amp;gt; builder;
    
    // 代表 result
    private int result; 
    
    // 代表 var result = await MethodAsync(arg);
    private Task&amp;lt;int&amp;gt; firstTaskToAwait;  
    
    // 代表 await Task.Delay(result);
    private Task secondTaskToAwait; 

    private void MoveNext()
    {
        try
        {
            switch (this.state) // 初始值为-1
            {
                case -1: 
                    // 执行 await MethodAsync(arg);
                    this.firstTaskToAwait = AsyncMethods.MethodAsync(this.arg);
                    
                    // 当 firstTaskToAwait 执行完毕
                    this.result = firstTaskToAwait.Result;
                    this.state = 0;
                    
                    // 调用 this.MoveNext();
                    this.Builder.AwaitUnsafeOnCompleted(ref this.awaiter, ref this);
                case 0:
                    // 执行 Task.Delay(result)
                    this.secondTaskToAwait = Task.Delay(this.result);
                    
                    // 当 secondTaskToAwait 执行完毕
                    this.state = 1;
                    
                    // 调用 this.MoveNext();
                    this.builder.AwaitUnsafeOnCompleted(ref this.awaiter, ref this);
                case 1:
                    this.builder.SetResult(result);
                    return;
            }
        }
        catch (Exception exception)
        {
            this.state = -2;
            this.builder.SetException(exception);
            return;
        }
    }

    [DebuggerHidden]
    private void SetStateMachine(IAsyncStateMachine stateMachine)
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到一个异步方法内含有几个异步方法，状态机便会存在几种分支判断情况。根据每个分支的执行情况，再通过调用 MoveNext 方法确保所有的异步方法能够完整执行。更进一步，看似是 switch 和 case 组成的分支方法，实质上仍然是一条异步操作执行和传递的Chain。&lt;/p&gt;
&lt;p&gt;上述的 CallMethodAsync 方法也可以转化成以下 Task.ContinueWith 形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;internal static async Task&amp;lt;int&amp;gt; CallMethodAsync(string arg)
{
    var result = await (
                    await MethodAsync(arg).ContinueWith(async MethodAsyncTask =&amp;gt;
                        {
                            var methodAsyncTaskResult = await MethodAsyncTask;
                            Console.Write(methodAsyncTaskResult);
                            await Task.Delay(methodAsyncTaskResult);
                            return methodAsyncTaskResult;
                        }));

    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以这样理解的是，总体看来，编译器每次遇到 await，当前执行的方法都会将方法的剩余部分注册为回调函数（当前 await 任务完成后接下来要进行的工作，也可能包含 await 任务，仍然可以顺序嵌套），然后立即返回（return builder.Task）。 剩余的每个任务将以某种方式完成其操作（可能被调度到当前线程上作为事件运行，或者因为使用了 I/O 线程执行，或者在单独线程上继续执行，这其实并不重要），只有在前一个 await 任务标记完成的情况下，才能继续进行下一个 await 任务。有关这方面的奇思妙想，请参阅&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/magazine/hh456403&quot;&gt;《通过 Await 暂停和播放》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;net-core-2.1-性能提升&quot;&gt;.NET Core 2.1 性能提升&lt;/h3&gt;
&lt;p&gt;上节关于编译器生成的内容并不能完全涵盖 async/await 的所有实现概念，甚至只是其中的一小部分，比如笔者并没有提到可等待模式（IAwaitable）和执行上下文（ExecutionContext）的内容，前者是 async/await 实现的指导原则，后者则是实际执行异步代码，返回给调用者结果和线程同步的操控者。包括生成的状态机代码中，当第一次执行发现任务并未完成时(!awaiter.isCompleted)，任务将直接返回。&lt;/p&gt;
&lt;p&gt;主要原因便是这些内容讲起来怕是要花很大的篇幅，有兴趣的同学推荐去看《深入理解C#》和 &lt;a href=&quot;https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-3-runtime-context&quot;&gt;ExecutionContext&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;异步代码能够显著提高服务器的响应和吞吐性能。但是通过上述讲解，想必大家已经认识到为了实现异步操作，编译器要自动生成大量的骨架方法和状态机代码，应用通常也要分配更多的相关操作对象，线程调度同步也是耗时耗力，这也意味着异步操作运行性能通常要比同步代码要差（这和第一句的性能提升并不矛盾，体重更大的人可能速度降低了，但是抗击打能力也更强了）。&lt;/p&gt;
&lt;p&gt;但是框架开发者一直在为这方面的提升作者努力，最新的 .NET Core 2.1 版本中也提到了这点。原本的应用中，一个基于 async/await 操作的任务将分配以下四个对象:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回给调用方的Task&lt;br/&gt;任务实际完成时，调用方可以知道任务的返回值等信息&lt;/li&gt;
&lt;li&gt;装箱到堆上的状态机信息&lt;br/&gt;之前的代码中，我们用了&lt;code&gt;ref&lt;/code&gt;标识一开始时，状态机实际以结构的形式存储在栈上，但是不可避免的，状态机运行时，需要被装箱到堆上以保留一些运行状态&lt;/li&gt;
&lt;li&gt;传递给Awaiter的委托&lt;br/&gt;即前文的&lt;code&gt;_moveNext&lt;/code&gt;，当链中的一个 Task 完成时，该委托被传递到下一个 Awaiter 执行 MoveNext 方法。&lt;/li&gt;
&lt;li&gt;存储某些上下文（如ExecutionContext）信息的状态机执行者（&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs&quot;&gt;MoveNextRunner&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;据 &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/&quot;&gt;Performance Improvements in .NET Core 2.1&lt;/a&gt; 一文介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (int i = 0; i &amp;lt; 1000; i++)
{
    await Yield();
    async Task Yield() =&amp;gt; await Task.Yield();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前的应用将分配下图中的对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/04/AsyncMethodAllocations_Before.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在 .NET Core 2.1 中，最终的分配对象将只有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/04/AsyncMethodAllocations_After.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四个分配对象最终减少到一个，分配空间也缩减到了过去的一半。更多的实现信息可以参考 &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14178&quot;&gt;Avoid async method delegate allocation&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;本文主要介绍了 async/await 的实现和 .NET Core 2.1 中关于异步操作性能优化的相关内容。因为笔者水平一般，文章篇幅有限，不能尽善尽美地解释完整，还希望大家见谅。&lt;/p&gt;
&lt;p&gt;无论是在什么平台上，异步操作都是重要的组成部分，而笔者觉得任何开发者在会用之余，都应该更进一步地适当了解背后的故事。具体发展中，C# 借鉴了 F#中的异步实现，其他语言诸如 js 可能也借鉴了 C# 中的部分内容，当然一些基本术语，比如回调或是 feature，任何地方都是相似的，怎么都脱离不开计算机体系，这也说明了编程基础的重要性。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/magazine/hh456403&quot;&gt;通过 Await 暂停和播放&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/magazine/hh456401&quot;&gt;通过新的 Visual Studio Async CTP 更轻松地进行异步编程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 07 May 2018 05:50:00 +0000</pubDate>
<dc:creator>白细胞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wddpct/p/9002242.html</dc:identifier>
</item>
<item>
<title>提升现代web app中页面性能 - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/9002226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/9002226.html</guid>
<description>&lt;h2 id=&quot;提升现代web-app的中的页面性能&quot;&gt;提升现代web app的中的页面性能&lt;/h2&gt;
&lt;p&gt;前言，本文翻译自&lt;a href=&quot;https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0&quot; class=&quot;uri&quot;&gt;https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0&lt;/a&gt;看到之后感觉讲解的系统清晰明了，实属一篇好文。就加上自己的理解翻译了一下，聊以加深印象。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬件网络对性能的而言始终不能避开的两个物理因素&quot;&gt;硬件、网络，对性能的而言始终不能避开的两个物理因素&lt;/h3&gt;
&lt;h3 id=&quot;一-硬件如何影响性能&quot;&gt;一、 硬件如何影响性能&lt;/h3&gt;
&lt;p&gt;硬件（即处理能力）决定了计算密集型任务的表现&lt;br/&gt;浏览器必须解析、编译并执行所有的js，如下如所示：&lt;br/&gt;&lt;img src=&quot;http://xxdy.tech/img/performance/1.png&quot;/&gt;&lt;br/&gt;对于每个阶段而言，代码量的差异显然会影响其变现即影响性能，这种差异在低处理能力的机器上的体现尤为明显。&lt;br/&gt;当然其他类型的资源请求也会影响性能，相比之下js的影响是比较突出的。&lt;br/&gt;所以考虑不同用户cpu的状况，减少js怪物(即缩小js体积)是很必要的。可以从以下几方面着手：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;删除不必要js&lt;/li&gt;
&lt;li&gt;延迟加载非关键js&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;借助相关工具&lt;/p&gt;
&lt;h3 id=&quot;删除不必要js&quot;&gt;1.1 删除不必要js&lt;/h3&gt;
&lt;h4 id=&quot;只在必要的时候进行转换&quot;&gt;只在必要的时候进行转换&lt;/h4&gt;
&lt;p&gt;仅仅对需要ES5的客户端才进行转换，80%的浏览器已经支持ES2015。(结合自己实际开发情况，移动端而言确实80%+的手机已经支持ES2015，仅仅只遇到oppop，vivio这两中手机不支持。)因为转换之后的代价还是有的，如下所示:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//ES2015&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;books&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(b &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;title&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//ES5&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;books&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(b) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;b&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//体积大了一倍&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;使用压缩工具优化工具&quot;&gt;使用压缩工具/优化工具&lt;/h4&gt;
&lt;p&gt;像UglifyJS &amp;amp; Closure Compiler 之类的工具，在压缩之外还有一些优化功能。&lt;br/&gt;对大多数的js而言压缩代码中空格移除和符号修改占了95%的工作量，并非是精心的代码转换。&lt;br/&gt;压缩不应该是盲目的，应该平衡下面几点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更好的压缩比&lt;/li&gt;
&lt;li&gt;高额的计算机资源消耗&lt;/li&gt;
&lt;li&gt;前期准备&lt;/li&gt;
&lt;li&gt;可能的副作用&lt;br/&gt;压缩可能不是一味的追求体积更小，相对而言，压缩也应该权衡一下其他方面。比较常见就是代码压缩时相比于其他流程，超长的时间消耗。压缩之后可能遇到关键字的问题。&lt;br/&gt;如何解决其实应该是从本身项目出发。&lt;/li&gt;
&lt;li&gt;尽可能的优化可缓存的静态资源&lt;/li&gt;
&lt;li&gt;在压缩体积和时间之间找到一个平衡点&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用tree-shaking移除没用的代码&quot;&gt;使用tree-shaking移除没用的代码&lt;/h4&gt;
&lt;p&gt;和压缩代码的目的一致，减小资源大小，不过是从另一个层面的解决方案。像webpack，rollup都提供了该功能。&lt;br/&gt;tree-shaking会将没有被用到的exports移除&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//tool &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//used&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'1'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;b&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//app.js&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;a&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./tool'&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;function b 未被使用，最终的打包文件中b将会被删除。&lt;/p&gt;
&lt;h4 id=&quot;es2015的模块是静态的可以使用tree-shaking&quot;&gt;ES2015的模块是静态的，可以使用tree-shaking&lt;/h4&gt;
&lt;p&gt;import/export 在执行之前就被确定，并且两者只能在顶层，没有条件逻辑的情况下使用(毕竟未执行)&lt;/p&gt;
&lt;h4 id=&quot;tree-shaking的局限&quot;&gt;tree-shaking的局限&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;仅仅删除未被使用的导出&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不支持所有的代码库（仅仅ES2015）&lt;/li&gt;
&lt;li&gt;可能做不到极致&lt;br/&gt;难以确定删除是否会有副作用，这种打包器只能保留&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自我排查&quot;&gt;自我排查&lt;/h4&gt;
&lt;p&gt;工具不能做到尽善尽美，并且在执行之前确定某项问题是困难的。&lt;br/&gt;当前来说应该从代码规范和代码注释来自我完善。&lt;/p&gt;
&lt;h4 id=&quot;对于框架&quot;&gt;对于框架&lt;/h4&gt;
&lt;p&gt;如果非必须，请不要使用。大的框架至少300kb的体积。&lt;br/&gt;当然必要，请基于下面几点来选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端渲染&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;懒加载&lt;/li&gt;
&lt;li&gt;代码优化&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;延迟加载非必需js&quot;&gt;1.2 延迟加载非必需js&lt;/h3&gt;
&lt;p&gt;先看一下js不同引入方式的差别&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;阻塞渲染&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;执行时机&lt;/td&gt;
&lt;td&gt;加载完成&lt;/td&gt;
&lt;td&gt;加载完成&lt;/td&gt;
&lt;td&gt;document解析完成&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;使用代码分割和懒加载&quot;&gt;使用代码分割和懒加载&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;减少启动时需要加载的js&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;尽可能少的加载不相关的js&lt;br/&gt;传统的做法是加载Bundle js，代码分割是将代码分成不同的chunk&lt;br/&gt;这里同样有两种极端：&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;每个模块对应一个js&lt;br/&gt;不好压缩&lt;br/&gt;利于缓存&lt;br/&gt;粒度更小&lt;/li&gt;
&lt;li readability=&quot;0.85899513776337&quot;&gt;
&lt;p&gt;整个应用只对应一个js&lt;br/&gt;便于压缩&lt;br/&gt;不利于缓存&lt;br/&gt;粒度太大，即可维护性&lt;br/&gt;忽然有种中庸的感觉了，凡事皆有度，所有单一操作都不能过分苛求极致，兼顾才是合理&lt;/p&gt;
&lt;h3 id=&quot;使用其他工具&quot;&gt;1.3 使用其他工具&lt;/h3&gt;
&lt;h4 id=&quot;使用html和css&quot;&gt;使用html和css&lt;/h4&gt;
某些状况下可能需要vanilla JS(即原生js)，框架带来便利的同时不可避免的有其他的一些性能消耗。提到这里有一篇文章大家可以看一下&lt;a href=&quot;https://www.w3ctech.com/topic/1978&quot;&gt;我是怎么把我的 React 应用换成 VanillaJS 的（这是不是一个坏主意）&lt;/a&gt;&lt;br/&gt;举个例子：&lt;br/&gt;Netflix 降低了他们登录页50%的TTI（传输时间间隔）通过下面的方式：&lt;/li&gt;
&lt;li&gt;使用原生js来代替React&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当用户登录的时候加载余下的部分&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用server&quot;&gt;使用server&lt;/h4&gt;
&lt;p&gt;将代价昂贵的库放到server端,使用ssr来代替client-side-render.&lt;br/&gt;ssr可以将我们初始页面加载事件减少到原来的1/5并减少不同浏览器之间的差异。&lt;br/&gt;ssr确实首屏的优化确实很大，优点不多说。但这里提一句，不要盲目ssr，特别是初次请求响应时间较长的接口&lt;/p&gt;
&lt;h2 id=&quot;二网络的影响&quot;&gt;二、网络的影响&lt;/h2&gt;
&lt;p&gt;首先了解两个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带宽: 数据吞吐量(比特/秒)&lt;/li&gt;
&lt;li&gt;延迟: 延迟数据传输时间(ms)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于大部分市场来说，带宽是可以满足需求的(这里统计是国外的，平均26兆，国内略低一点)，平均页面大小3.5Mb。传输时间（3.5/26）0.13s。国内会差一点。&lt;br/&gt;延迟对性能影响比较明显。&lt;br/&gt;移动网络的延迟&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5G&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;lt;=4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4G&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&amp;lt;=100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3G&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;100-500&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3G&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;300-1000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;适应移动网络的限制&quot;&gt;适应移动网络的限制&lt;/h3&gt;
&lt;p&gt;应该从下面几方面来分别考虑。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少请求数量&lt;/li&gt;
&lt;li&gt;优化关键路径&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;减少请求大小&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;减少请求数量&quot;&gt;2.1 减少请求数量&lt;/h3&gt;
&lt;h4 id=&quot;新建一次连接的代价是昂贵的要重复以下过程&quot;&gt;新建一次连接的代价是昂贵的，要重复以下过程&lt;/h4&gt;
&lt;p&gt;建立连接需要1至3+响应在数据相应之前。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DNS 查询(可能)&lt;/li&gt;
&lt;li&gt;TLS 握手(可能)&lt;/li&gt;
&lt;li&gt;请求资源&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;初始状态连接不能被充分利用&quot;&gt;初始状态连接不能被充分利用&lt;/h4&gt;
&lt;p&gt;TCP slow-start限制了在初始响应里里数据被发送的数量&lt;/p&gt;
&lt;h4 id=&quot;发送更多的数据通常情况下比新建连接要划算&quot;&gt;发送更多的数据通常情况下比新建连接要划算。&lt;/h4&gt;
&lt;p&gt;请求的体积与相应时间并不是线性关系。&lt;br/&gt;两次50k的请求消耗比一次100k的大了不少。&lt;/p&gt;
&lt;h4 id=&quot;减少重定向的使用&quot;&gt;减少重定向的使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;重定向增加了服务器昂贵的循环&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;server-side 相对于client-side来说重定向优秀一点（快并且可缓存）&lt;/li&gt;
&lt;li&gt;看一下301和302的响应code&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用缓存&quot;&gt;使用缓存&lt;/h4&gt;
&lt;p&gt;理想状态下，确实资源是否最新不应该通过网络请求&lt;br/&gt;可以通过下面的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Content-addressed URLs:&lt;br/&gt;即内容与地址对应，log13234d.jpg而非log.jpg&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用max-age&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种浏览器调整为Facebook节省了60%的请求&lt;/p&gt;
&lt;h4 id=&quot;使用service-workers来增强缓存&quot;&gt;使用service workers来增强缓存&lt;/h4&gt;
&lt;p&gt;service worker可以帮组我们：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拦截网络请求&lt;/li&gt;
&lt;li&gt;访问浏览器缓存&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;代替发送网络请求来处理过期的资源&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用http2&quot;&gt;使用http2&lt;/h4&gt;
&lt;p&gt;使用HTTP2时，每个来源只需要一个连接，减少了连接创建的开销。&lt;/p&gt;
&lt;h3 id=&quot;优化关键路径&quot;&gt;2.2 优化关键路径&lt;/h3&gt;
&lt;p&gt;优化页面渲染或者加载时所需的事件以便尽可能的加快完成。&lt;/p&gt;
&lt;h4 id=&quot;浏览器优化资源请求&quot;&gt;浏览器优化资源请求&lt;/h4&gt;
&lt;p&gt;对于所有的请求，浏览器对其是有权重处理的，即分不同的优先级来加载。具体来说就是重要会阻塞渲染的优先级比较高。&lt;br/&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;http://xxdy.tech//img/performance/2.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用资源提示&quot;&gt;使用资源提示&lt;/h4&gt;
&lt;p&gt;通过以下方式，提前加载或者请求将要用到的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dns-prefresh&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;preconnect&lt;/li&gt;
&lt;li&gt;Preload（当前页面）&lt;/li&gt;
&lt;li&gt;Prefetch(下个页面)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;降低请求大小&quot;&gt;2.3 降低请求大小&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用Brotli压缩&lt;br/&gt;相对于gzip&lt;br/&gt;更好的压缩比，文件越大越明显&lt;br/&gt;更快的解压缩&lt;br/&gt;压缩速度极大提升&lt;/li&gt;
&lt;li&gt;减少js体积&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;优化图片&lt;br/&gt;23就不再多提了，方式有很多。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;对于好的资源，多读收益还是很明显的。这次翻译感觉体会又多了一些，不过由于本人才疏学浅，如有错误还望多多指正。一言概之，共同学习。&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/blog/blob/master/source/_posts/performance.md&quot;&gt;更多请移步&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 05:48:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/9002226.html</dc:identifier>
</item>
<item>
<title>CSS 弹性容器 - Number_DDD</title>
<link>http://www.cnblogs.com/number-project/p/9002175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/number-project/p/9002175.html</guid>
<description>&lt;p&gt;该文章为英文原文译文及一些自己的拙见&lt;br/&gt;墙裂推荐读原文&lt;br/&gt;浏览原文请戳这里 : &lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/#article-header-id-2&quot;&gt;CSS-STRICKS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者浏览我在Github上的Blog: &lt;a href=&quot;https://github.com/Number314225/Blog/blob/master/HTML/Flexbox_Layout/CSS_Flex.md&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt; (&lt;span&gt;虽然目前才一篇....&lt;/span&gt;)&lt;/p&gt;
&lt;h2&gt;弹性布局 (Flexbox Layout)&lt;/h2&gt;
&lt;h5&gt;什么是弹性布局&lt;/h5&gt;
&lt;p&gt;Flexbox Layout 模块旨在提供一种更为有效的方式来对容器(container)中的每一项(item)进行布置、对齐和空间分配，即使是在其尺寸未知或动态变化的情况下也能很好的发挥作用。&lt;/p&gt;
&lt;p&gt;弹性布局的主要思想是赋予容器(container)改变内部每一项的长宽来更好的适应各种尺寸的屏幕(手机、平板或是台式显示器)。一个设置了flex属性的容器(container)可以对其内部的项(item)进行扩大来更好填充可用空间，或是缩小防止溢出。&lt;/p&gt;
&lt;p&gt;重要的是，一般布局指基于垂直的块元素(block)和基于水平的行内元素(inline)，弹性布局与一般布局不同的是它与方向无关。虽然一般布局也能很好地规划页面，但它缺乏在页面或元素发生旋转、改变大小时的灵活性。&lt;/p&gt;
&lt;h5&gt;容器和内部项的属性&lt;/h5&gt;
&lt;p&gt;弹性布局实为一种模型而非一个属性，其中包含了容器的属性和容器中每一项的属性。&lt;/p&gt;
&lt;p&gt;下图阐释了弹性布局的主要思想 &lt;img src=&quot;https://raw.githubusercontent.com/Number314225/Blog/master/HTML/Flexbox_Layout/imgs/flexbox.png&quot; alt=&quot;alt&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在弹性布局中，容器内部的项(item)的布置方式基于主轴(main axis)或是交叉轴(cross axis)其中之一。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;主轴(main axis)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;主轴是内部项在布局是最主要遵循的轴，&lt;strong&gt;不一定是水平方向&lt;/strong&gt;，其方向基于属性flex-direction的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;主轴起始点(main start)&lt;/td&gt;
&lt;td&gt;在容器内布局的项从起始点开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;主轴结束点(main end)&lt;/td&gt;
&lt;td&gt;截止到结束点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主轴尺寸(main size)&lt;/td&gt;
&lt;td&gt;如图&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;交叉轴(cross axis)&lt;/td&gt;
&lt;td&gt;始终保持与主轴垂直，&lt;strong&gt;即不一定是竖直方向&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; 交叉轴起始点(cross start)&lt;/td&gt;
&lt;td&gt; 内部项在交叉轴上排列的起点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; 交叉轴结束点(cross end)&lt;/td&gt;
&lt;td&gt; 和终点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; 交叉轴尺寸(cross size)&lt;/td&gt;
&lt;td&gt; 如图&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;弹性布局的属性&lt;/h2&gt;
&lt;p&gt;弹性布局的属性分为容器的属性，和其内部每一项的属性。&lt;/p&gt;
&lt;h5&gt;容器的属性&lt;/h5&gt;
&lt;h6&gt;在想要使用弹性布局的元素上加上如下代码&lt;/h6&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.container{
    display: flex; /* 或者 inline-flex */ 
} 
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;row(默认)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在设置了&lt;code&gt;direction:ltr&lt;/code&gt;的元素上从左到右排列，在设置了&lt;code&gt;direction:rtl&lt;/code&gt;元素上从右到左排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;row-reverse&lt;/td&gt;
&lt;td&gt;在设置了&lt;code&gt;direction:ltr&lt;/code&gt;的元素上从右到左排列，在设置了&lt;code&gt;direction:rtl&lt;/code&gt;元素上从左到右排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;row&lt;/code&gt;相同，但从上到下&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;column-reverse&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;row-reverse&lt;/code&gt;相同，但从下到上&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;nowrap(默认)&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;所有项目排成一行，不换行&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;wrap&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;换行，从上向下排&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;wrap-reverse&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;换行，从下向上排&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;flex-flow&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt; 
    flex-flow&lt;/span&gt;:&lt;span&gt; &amp;lt;‘flex-direction’&amp;gt; || &amp;lt;‘flex-wrap’&amp;gt;&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;属性&lt;code&gt;flex-direction&lt;/code&gt;和&lt;code&gt;flex-wrap&lt;/code&gt;的简写整合版。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt; 
    flex-flow&lt;/span&gt;:&lt;span&gt; row-reverse wrap&lt;/span&gt;; 
}&lt;span&gt; 
.container&lt;/span&gt;{&lt;span&gt; 
    flex-direction&lt;/span&gt;:&lt;span&gt; row-reverse&lt;/span&gt;;&lt;span&gt; flex-wrap&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;; 
}&lt;span&gt; 
// 两者写法效果等同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;默认值为两者的默认值，即 row nowrap&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;justify-content&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt; 
    justify-content&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | space-between | space-around | space-evenly&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内部项在沿着主轴方向上的对齐方式和间距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Number314225/Blog/master/HTML/Flexbox_Layout/imgs/justify-content-2.png&quot; alt=&quot;alt&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;align-items&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt; 
    align-items&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | baseline | stretch&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;内部项在沿着交叉轴方向上的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Number314225/Blog/master/HTML/Flexbox_Layout/imgs/align-items.png&quot; alt=&quot;alt&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;align-content&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container &lt;/span&gt;{&lt;span&gt; 
    align-content&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | space-between | space-around | stretch&lt;/span&gt;; 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该属性定义了多行情况下，沿交叉轴方向有剩余空间时，各行空间的分配情况，就如同竖直版的&lt;code&gt;justify-content&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Number314225/Blog/master/HTML/Flexbox_Layout/imgs/align-content.png&quot; alt=&quot;alt&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;内部项的属性&lt;/h5&gt;
&lt;p&gt;To be continue....&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 05:30:00 +0000</pubDate>
<dc:creator>Number_DDD</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/number-project/p/9002175.html</dc:identifier>
</item>
<item>
<title>WSGI及gunicorn指北（二） - pygo</title>
<link>http://www.cnblogs.com/yuwhuawang/p/9002171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuwhuawang/p/9002171.html</guid>
<description>&lt;p&gt;pyg0已经大概了解了wsgi。现在他决定深入探索他们实际在生产环境里用到的web 服务器 -gunicorn。&lt;/p&gt;
&lt;p&gt;先来看看官网的介绍：Gunicorn 是一个运行在Unix上的python WSGI web 服务器。它采用Pre-Fork 的worker模型 。Gunicorn&lt;br/&gt;可以适用于多种python web 框架，实现简单，占用系用资源少，速度快。&lt;/p&gt;
&lt;p&gt;抛开那些自卖自夸的话语，我们一项一项来分析。&lt;/p&gt;
&lt;p&gt;Gunicorn 之所以只能运行在Unix系统上，是因为gunicorn使用了只有在*nix系统中才存在的模块和方法，例如fnctl，os.fork等等。&lt;/p&gt;
&lt;p&gt;而Pre-Fork的worker模型是指在gunicorn启动时，会通过Master(在gunicorn里叫做arbiter)预先生成特定数量的worker， 这些worker通过arbiter管理。&lt;/p&gt;
&lt;p&gt;当我们启动一个wsgiapp， 会初始化一个Application，在他的基类BaseApplication中有一个run方法，代码如下(节选)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseApplication(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            Arbiter(self).run()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; RuntimeError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nError: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % e, file=&lt;span&gt;sys.stderr)
            sys.stderr.flush()
            sys.exit(&lt;/span&gt;1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要是把任务交给Arbiter这个类来完成。我们看看这个Arbiter是如果启动和管理worker的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Arbiter(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Arbiter maintain the workers processes alive. It launches or
    kills them if needed. It also manages application reloading
    via SIGHUP/USR2.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;\
        Initialize the arbiter. Start listening and set pidfile if needed.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting gunicorn %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;__version__&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GUNICORN_PID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.environ:
            self.master_pid &lt;/span&gt;= int(os.environ.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GUNICORN_PID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
            self.proc_name &lt;/span&gt;= self.proc_name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            self.master_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Master.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

        self.pid &lt;/span&gt;=&lt;span&gt; os.getpid()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.cfg.pidfile &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
            pidname &lt;/span&gt;=&lt;span&gt; self.cfg.pidfile
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.master_pid !=&lt;span&gt; 0:
                pidname &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            self.pidfile &lt;/span&gt;=&lt;span&gt; Pidfile(pidname)
            self.pidfile.create(self.pid)
        self.cfg.on_starting(self)

        self.init_signals()

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.LISTENERS:
            fds &lt;/span&gt;=&lt;span&gt; None
            listen_fds &lt;/span&gt;=&lt;span&gt; systemd.listen_fds()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; listen_fds:
                self.systemd &lt;/span&gt;=&lt;span&gt; True
                fds &lt;/span&gt;=&lt;span&gt; range(systemd.SD_LISTEN_FDS_START,
                            systemd.SD_LISTEN_FDS_START &lt;/span&gt;+&lt;span&gt; listen_fds)

            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt;&lt;span&gt; self.master_pid:
                fds &lt;/span&gt;=&lt;span&gt; []
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; fd &lt;span&gt;in&lt;/span&gt; os.environ.pop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GUNICORN_FD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                    fds.append(int(fd))

            self.LISTENERS &lt;/span&gt;=&lt;span&gt; sock.create_sockets(self.cfg, self.log, fds)

        listeners_str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join([str(l) &lt;span&gt;for&lt;/span&gt; l &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.LISTENERS])
        self.log.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Arbiter booted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Listening at: %s (%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, listeners_str, self.pid)
        self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using worker: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, self.cfg.worker_class_str)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; check worker class requirements&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hasattr(self.worker_class, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;check_config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            self.worker_class.check_config(self.cfg, self.log)

        self.cfg.when_ready(self)&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main master loop.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.start()
        util._setproctitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;master [%s]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.proc_name)

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.manage_workers()

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                self.maybe_promote_master()

                sig &lt;/span&gt;= self.SIG_QUEUE.pop(0) &lt;span&gt;if&lt;/span&gt; self.SIG_QUEUE &lt;span&gt;else&lt;/span&gt;&lt;span&gt; None
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sig &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                    self.sleep()
                    self.murder_workers()
                    self.manage_workers()
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; sig &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.SIG_NAMES:
                    self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ignoring unknown signal: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sig)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;

                signame &lt;/span&gt;=&lt;span&gt; self.SIG_NAMES.get(sig)
                handler &lt;/span&gt;= getattr(self, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handle_%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; signame, None)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; handler:
                    self.log.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unhandled signal: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, signame)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
                self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Handling signal: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, signame)
                handler()
                self.wakeup()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
            self.halt()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyboardInterrupt:
            self.halt()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; HaltServer as inst:
            self.halt(reason&lt;/span&gt;=inst.reason, exit_status=&lt;span&gt;inst.exit_status)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; SystemExit:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
            self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unhandled exception in main loop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                          exc_info&lt;/span&gt;=&lt;span&gt;True)
            self.stop(False)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.pidfile &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                self.pidfile.unlink()
            sys.exit(&lt;/span&gt;-1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; manage_workers(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;\
        Maintain the number of workers by spawning or killing
        as required.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; len(self.WORKERS.keys()) &amp;lt;&lt;span&gt; self.num_workers:
            self.spawn_workers()

        workers &lt;/span&gt;=&lt;span&gt; self.WORKERS.items()
        workers &lt;/span&gt;= sorted(workers, key=&lt;span&gt;lambda&lt;/span&gt; w: w[1&lt;span&gt;].age)
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; len(workers) &amp;gt;&lt;span&gt; self.num_workers:
            (pid, _) &lt;/span&gt;=&lt;span&gt; workers.pop(0)
            self.kill_worker(pid, signal.SIGTERM)

        active_worker_count &lt;/span&gt;=&lt;span&gt; len(workers)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self._last_logged_active_worker_count !=&lt;span&gt; active_worker_count:
            self._last_logged_active_worker_count &lt;/span&gt;=&lt;span&gt; active_worker_count
            self.log.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} workers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(active_worker_count),
                           extra&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gunicorn.workers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: active_worker_count,
                                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtype&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gauge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; spawn_worker(self):
        self.worker_age &lt;/span&gt;+= 1&lt;span&gt;
        worker &lt;/span&gt;=&lt;span&gt; self.worker_class(self.worker_age, self.pid, self.LISTENERS,
                                   self.app, self.timeout &lt;/span&gt;/ 2.0&lt;span&gt;,
                                   self.cfg, self.log)
        self.cfg.pre_fork(self, worker)
        pid &lt;/span&gt;=&lt;span&gt; os.fork()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid !=&lt;span&gt; 0:
            worker.pid &lt;/span&gt;=&lt;span&gt; pid
            self.WORKERS[pid] &lt;/span&gt;=&lt;span&gt; worker
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pid

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do not inherit the temporary files of other workers&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; sibling &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.WORKERS.values():
            sibling.tmp.close()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Process Child&lt;/span&gt;
        worker.pid =&lt;span&gt; os.getpid()
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            util._setproctitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker [%s]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.proc_name)
            self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Booting worker with pid: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, worker.pid)
            self.cfg.post_fork(self, worker)
            worker.init_process()
            sys.exit(0)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; SystemExit:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AppImportError as e:
            self.log.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception while loading the application&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                           exc_info&lt;/span&gt;=&lt;span&gt;True)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % e, file=&lt;span&gt;sys.stderr)
            sys.stderr.flush()
            sys.exit(self.APP_LOAD_ERROR)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            self.log.exception(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception in worker process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; worker.booted:
                sys.exit(self.WORKER_BOOT_ERROR)
            sys.exit(&lt;/span&gt;-1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            self.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker exiting (pid: %s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, worker.pid)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                worker.tmp.close()
                self.cfg.worker_exit(self, worker)
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
                self.log.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception during worker exit:\n%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                  traceback.format_exc())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Arbiter 初始化时， 首先要读取配置，比如worker的数量，worker的模式，然后创建socket，创建worker并且进入循环管理worker信号，如果worker不响应了，就干掉创建一个新的。主进程Arbiter大概就是这么简单。&lt;/p&gt;
&lt;p&gt;在Arbiter创建worker的方法里，通过worker.init_process()进入worker的消息循环。&lt;/p&gt;
&lt;p&gt;现在再来看一下Worker进程。Gunicorn支持多种worker模式，默认的为sync，就像名字表达的一样，这是个同步阻塞的网络模型。除了sync之外，还有ggevent，gaiohttp,gthread等等。我们主要来看一下ggevent模式的worker。&lt;/p&gt;
&lt;p&gt;ggevent 模式的worker基于gevent异步协程库，支持异步I/O模式。&lt;/p&gt;
&lt;p&gt;我们来看代码（节选）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeventWorker(AsyncWorker):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        servers &lt;/span&gt;=&lt;span&gt; []
        ssl_args &lt;/span&gt;=&lt;span&gt; {}

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.cfg.is_ssl:
            ssl_args &lt;/span&gt;= dict(server_side=True, **&lt;span&gt;self.cfg.ssl_options)

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.sockets:
            s.setblocking(&lt;/span&gt;1&lt;span&gt;)
            pool &lt;/span&gt;=&lt;span&gt; Pool(self.worker_connections)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.server_class &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                environ &lt;/span&gt;=&lt;span&gt; base_environ(self.cfg)
                environ.update({
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wsgi.multithread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: True,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SERVER_SOFTWARE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: VERSION,
                })
                server &lt;/span&gt;=&lt;span&gt; self.server_class(
                    s, application&lt;/span&gt;=self.wsgi, spawn=pool, log=&lt;span&gt;self.log,
                    handler_class&lt;/span&gt;=self.wsgi_handler, environ=&lt;span&gt;environ,
                    &lt;/span&gt;**&lt;span&gt;ssl_args)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                hfun &lt;/span&gt;=&lt;span&gt; partial(self.handle, s)
                server &lt;/span&gt;= StreamServer(s, handle=hfun, spawn=pool, **&lt;span&gt;ssl_args)

            server.start()
            servers.append(server)

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; self.alive:
            self.notify()
            gevent.sleep(&lt;/span&gt;1.0&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Stop accepting requests&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; server &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(server, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; gevent 1.0&lt;/span&gt;
&lt;span&gt;                    server.close()
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(server, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; gevent &amp;lt; 1.0&lt;/span&gt;
&lt;span&gt;                    server.kill()

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Handle current requests until graceful_timeout&lt;/span&gt;
            ts =&lt;span&gt; time.time()
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; time.time() - ts &amp;lt;=&lt;span&gt; self.cfg.graceful_timeout:
                accepting &lt;/span&gt;=&lt;span&gt; 0
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; server &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; server.pool.free_count() !=&lt;span&gt; server.pool.size:
                        accepting &lt;/span&gt;+= 1

                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if no server is accepting a connection, we can exit&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; accepting:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;

                self.notify()
                gevent.sleep(&lt;/span&gt;1.0&lt;span&gt;)

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Force kill all active the handlers&lt;/span&gt;
            self.log.warning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker graceful timeout (pid:%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.pid)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; server &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers:
                server.stop(timeout&lt;/span&gt;=1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在worker启动的时候，针对每一个Ambiter 初始化的socket，创建一个server，每一个server都运行在一个gevent pool里，等待和处理连接的操作都是在server里面进行的。&lt;/p&gt;
&lt;p&gt;这里的server_class是和wsgi_handler 就是gevent的WSGIserver和WSGIHander的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeventPyWSGIWorker(GeventWorker):
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Gevent StreamServer based workers.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    server_class &lt;/span&gt;=&lt;span&gt; PyWSGIServer
    wsgi_handler &lt;/span&gt;= PyWSGIHandler
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看一下server创建的过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 server = self.server_class(s, application=self.wsgi, spawn=pool, log=&lt;span&gt;self.log,
                    handler_class&lt;/span&gt;=self.wsgi_handler, environ=&lt;span&gt;environ,
                    &lt;/span&gt;**ssl_args)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s就是Arbiter创建的socket, application 就是我们用的WSGI app（比如django，flask等框架的app）， spawn是gevent的协程池。handler_class就是gevent的wsgi_handler的子类。通过这种方式，把WSGI app交给worker来运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
while&lt;span&gt; self.alive:
    self.notify()
    gevent.sleep(1.0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里每隔一秒给Arbiter发一个通知，告诉arbiter worker还活着，避免被arbiter干掉。&lt;/p&gt;

&lt;p&gt;真正等待和处理链接走到了gevent里的WSGIServer 和WSGIhandler。我们进入gevent具体看下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseServer(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; start_accepting(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self._watcher &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; just stop watcher without creating a new one?&lt;/span&gt;
            self._watcher = self.loop.io(self.socket.fileno(), 1&lt;span&gt;)
            self._watcher.start(self._do_read)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;WSGIServer用start_accepting来接收链接， 在读到socket里的信息后，用do_handle来处理链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;def&lt;/span&gt; do_handle(self, *&lt;span&gt;args):
        spawn &lt;/span&gt;=&lt;span&gt; self._spawn
        handle &lt;/span&gt;=&lt;span&gt; self._handle
        close &lt;/span&gt;=&lt;span&gt; self.do_close

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; spawn &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                _handle_and_close_when_done(handle, close, args)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                spawn(_handle_and_close_when_done, handle, close, args)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            close(&lt;/span&gt;*&lt;span&gt;args)
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;WSGIServer实际上是对每一个链接启动一个协程。在协程中，用self._handle, 使用WSGIHandler来处理连接的请求。我们找到WSGIHandler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; WSGIHandler(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle_one_response(self):
        self.time_start &lt;/span&gt;=&lt;span&gt; time.time()
        self.status &lt;/span&gt;=&lt;span&gt; None
        self.headers_sent &lt;/span&gt;=&lt;span&gt; False

        self.result &lt;/span&gt;=&lt;span&gt; None
        self.response_use_chunked &lt;/span&gt;=&lt;span&gt; False
        self.response_length &lt;/span&gt;=&lt;span&gt; 0

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.run_application()
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                    self.wsgi_input._discard()
                &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (socket.error, IOError):
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Don't let exceptions during discarding&lt;/span&gt;
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input override any exception that may have been&lt;/span&gt;
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; raised by the application, such as our own _InvalidClientInput.&lt;/span&gt;
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; In the general case, these aren't even worth logging (see the comment&lt;/span&gt;
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; just below)&lt;/span&gt;
                    &lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; _InvalidClientInput:
            self._send_error_response_if_possible(&lt;/span&gt;400&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; socket.error as ex:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ex.args[0] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; (errno.EPIPE, errno.ECONNRESET):
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Broken pipe, connection reset by peer.&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Swallow these silently to avoid spewing&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; useless info on normal operating conditions,&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; bloating logfiles. See https://github.com/gevent/gevent/pull/377&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; and https://github.com/gevent/gevent/issues/136.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; PY3:
                    sys.exc_clear()
                self.close_connection &lt;/span&gt;=&lt;span&gt; True
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                self.handle_error(&lt;/span&gt;*&lt;span&gt;sys.exc_info())
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint:disable=bare-except&lt;/span&gt;
            self.handle_error(*&lt;span&gt;sys.exc_info())
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            self.time_finish &lt;/span&gt;=&lt;span&gt; time.time()
            self.log_request()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run_application(self):
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; self.result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.result &lt;/span&gt;=&lt;span&gt; self.application(self.environ, self.start_response)
            self.process_result()
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            close &lt;/span&gt;= getattr(self.result, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; close &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                    close()
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Discard the result. If it's a generator this can&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; free a lot of hidden resources (if we failed to iterate&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; all the way through it---the frames are automatically&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cleaned up when StopIteration is raised); but other cases&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; could still free up resources sooner than otherwise.&lt;/span&gt;
                close =&lt;span&gt; None
                self.result &lt;/span&gt;= None
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在WSGIHandler里，读取到request之后，调用handle_one_response来处理，其中run_application里，我们又看到了熟悉的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    self.result = self.application(self.environ, self.start_response)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WSGI app的标准调用。&lt;/p&gt;

&lt;p&gt;pyg0看了这么一大圈，然后自己默默地做了一个总结：Gunicorn在启动的时候，使用Arbiter来预先创建相应数量和模式的worker，所有的worker都监听同一组socket。在每个worker里，创建server来监听和处理请求。而ggevent模式的worker里，每一个链接来的时候，worker会起一个协程来处理，通过协程的方式来实现异步I/O。而具体处理请求的，是用户提供的WSGI app。&lt;/p&gt;

</description>
<pubDate>Mon, 07 May 2018 05:29:00 +0000</pubDate>
<dc:creator>pygo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuwhuawang/p/9002171.html</dc:identifier>
</item>
<item>
<title>Java中常用的数据结构类 - 薄峰</title>
<link>http://www.cnblogs.com/qbzf-Blog/p/9002137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qbzf-Blog/p/9002137.html</guid>
<description>&lt;h2 id=&quot;结构体系图&quot;&gt;结构体系图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgsa.baidu.com/exp/w=500/sign=acce0e725043fbf2c52ca623807fca1e/e4dde71190ef76c6cd7dd0519e16fdfaaf516718.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;
&lt;h5 id=&quot;arraylistlinkedlistvector有什么区别&quot;&gt;ArrayList、LinkedList、Vector有什么区别？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;ArrayList
&lt;ul&gt;&lt;li&gt;只能装入引用对象（基本类型要转换为封装类）；&lt;/li&gt;
&lt;li&gt;线程不安全；&lt;/li&gt;
&lt;li&gt;底层由数组实现（顺序表），因为由顺序表实现，所以会具备顺序表的特点，如：需要声明长度、超出长度时需要进行扩容、不适合频繁的移动删除元素、检索元素快；&lt;/li&gt;
&lt;li&gt;capacity默认为10，超出时，capacity自动增长0.5倍&lt;code&gt;(oldCapacity &amp;gt;&amp;gt; 1)&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector：
&lt;ul&gt;&lt;li&gt;只能装入引用对象（基本类型要转换为封装类）；&lt;/li&gt;
&lt;li&gt;Vector通过synchronized方法保证线程安全；&lt;/li&gt;
&lt;li&gt;底层也由数组实现；&lt;/li&gt;
&lt;li&gt;capacity默认为10（在构造方法中），超出时增长capacityIncrement的量，capacityIncrement小于等于0时，则增长1倍&lt;code&gt;((capacityIncrement &amp;gt; 0) ? capacityIncrement : oldCapacity)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LinkedList
&lt;ul&gt;&lt;li&gt;只能装入引用对象（基本类型会转换为封装类）；&lt;/li&gt;
&lt;li&gt;线程不安全；&lt;/li&gt;
&lt;li&gt;底层实现为链表，具备链表的特点，如：不用声明长度、检索性能较差，但是插入移动删除较快。&lt;/li&gt;
&lt;li&gt;链表通过Node对象实现&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/PsPbnOn.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;arraylist的扩容消耗&quot;&gt;ArrayList的扩容消耗&lt;/h5&gt;
&lt;p&gt;由于ArrayList使用&lt;br/&gt;&lt;code&gt;elementData = Arrays.copyOf(elementData, newCapacity);&lt;/code&gt;&lt;br/&gt;进行扩容，而&lt;img src=&quot;https://i.imgur.com/25c4ThE.png&quot;/&gt;&lt;br/&gt;每次都会重新创建一个newLength长度的数组，所以扩容的空间复杂度为O(n),时间复杂度为O(n)&lt;/p&gt;
&lt;h5 id=&quot;arrays.aslist方法后的list可以扩容吗&quot;&gt;Arrays.asList方法后的List可以扩容吗？&lt;/h5&gt;
&lt;p&gt;不能，asList返回的List为只读的。其原因为：asList方法返回的ArrayList是Arrays的一个内部类，并且没有实现add，remove等操作&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/9tI31Kh.png&quot;/&gt;&lt;br/&gt;而在AbstractList中，add操作&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/Eb8NH9u.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;如何使list线程安全&quot;&gt;如何使List线程安全&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Collections.synchronizedList(list);&lt;/code&gt;&lt;br/&gt;或者使用手动的方法保护线程安全。&lt;/p&gt;
&lt;h5 id=&quot;list是有序的吗&quot;&gt;List是有序的吗？&lt;/h5&gt;
&lt;p&gt;这里的有序指有序性，有序或无序是指是否按照其添加的顺序来存储对象，List是有序的。&lt;/p&gt;
&lt;h5 id=&quot;list怎么实现排序&quot;&gt;List怎么实现排序？&lt;/h5&gt;
&lt;p&gt;实现排序，可以使用自定义排序&lt;br/&gt;&lt;code&gt;list.sort(new Comparator(){...})&lt;/code&gt;&lt;br/&gt;或者使用Collections进行快速排序&lt;br/&gt;&lt;code&gt;Collections.sort(list)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;list和array之间如何互相转换&quot;&gt;List和Array之间如何互相转换？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Array转List：List list = new ArrayList(array);&lt;/li&gt;
&lt;li&gt;List转Array：Object [] objects = list.toArray();&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;set&quot;&gt;Set&lt;/h2&gt;
&lt;h5 id=&quot;set与list有什么区别&quot;&gt;Set与List有什么区别？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Set
&lt;ul&gt;&lt;li&gt;只能装入引用对象（基本类型要转换为封装类）；&lt;/li&gt;
&lt;li&gt;线程不安全&lt;/li&gt;
&lt;li&gt;较List，是无序的（无法保证添加的顺序），而且元素不能重复&lt;/li&gt;
&lt;li&gt;底层使用了map进行实现（HashMap&amp;amp;LinkedHashMap）,借用map的key不能重复的特性，来实现不重复性。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/1Pqi8gl.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/VO9S814.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;hashsetlinkedhashsettreeset的区别&quot;&gt;HashSet、LinkedHashSet、TreeSet的区别？&lt;/h5&gt;
&lt;p&gt;都无法保证线程安全，底层都使用map实现不重复性（所以特性也在map中），Set都不能使用get(index)的方法获取元素，只能使用iterator进行获取。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashSet
&lt;ul&gt;&lt;li&gt;使用HashMap，无法保证有序性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LinkedHashSet
&lt;ul&gt;&lt;li&gt;使用LinkedHashMap,可以保证有序性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TreeSet
&lt;ul&gt;&lt;li&gt;使用NavigableMap，可以使用Comparator来控制顺序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;如何使set线程安全&quot;&gt;如何使Set线程安全&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Collections.synchronizedSet(set);&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;map&quot;&gt;Map&lt;/h2&gt;
&lt;h5 id=&quot;hashmaplinkedhashmaphashtabletreemap的区别&quot;&gt;HashMap、LinkedHashMap、Hashtable、TreeMap的区别？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;HashMap
&lt;ul&gt;&lt;li&gt;线程不安全&lt;/li&gt;
&lt;li&gt;允许有一个key为null&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;hash算法&lt;/strong&gt;，来确定key是否存在&lt;/li&gt;
&lt;li&gt;不能保证有序性&lt;/li&gt;
&lt;li&gt;默认大小为16，每次扩容默认增大1倍。默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LinkedHashMap&lt;br/&gt;HashMap的子类，将结构与操作更改为链表形式
&lt;ul&gt;&lt;li&gt;线程不安全&lt;/li&gt;
&lt;li&gt;accessOrder默认fasle，可以保证有序性&lt;/li&gt;
&lt;li&gt;在HashMap的线性单向链表的基础上，内部维护了一个双向链表&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/3pqR6hp.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hashtable
&lt;ul&gt;&lt;li&gt;父类为Dictionary，与HashMap不同&lt;/li&gt;
&lt;li&gt;线程安全，方法通过synchronized同步&lt;/li&gt;
&lt;li&gt;key&amp;amp;value都不能为null&lt;/li&gt;
&lt;li&gt;不能保证有序性&lt;/li&gt;
&lt;li&gt;默认大小为11，其余与HashMap一致&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TreeMap
&lt;ul&gt;&lt;li&gt;线程不安全&lt;/li&gt;
&lt;li&gt;内部使用&lt;strong&gt;红黑树&lt;/strong&gt;，需要key实现Comparable接口&lt;/li&gt;
&lt;li&gt;可以定义Comparator控制顺序&lt;/li&gt;
&lt;li&gt;迭代遍历时使用中序遍历&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;如何使map线程安全&quot;&gt;如何使Map线程安全&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Collections.synchronizedMap(map);&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;什么样的对象适合做为键有什么要求&quot;&gt;什么样的对象适合做为键，有什么要求？&lt;/h5&gt;
&lt;p&gt;String、Interger这样的类是final类型的，具有不可变性，且重写了equals()和hashCode()方法。换言之，做为key的对象，不可变性是必要的，因为要计算hashCode()，要防止放入时和取出时hashcode不一致。此外还需要重写equals()和hashCode()方法，用于比较对象一致性。&lt;/p&gt;
&lt;h5 id=&quot;hashmap初始化传入的容量参数的值就是hashmap实际分配的空间么&quot;&gt;HashMap初始化传入的容量参数的值就是HashMap实际分配的空间么？&lt;/h5&gt;
&lt;p&gt;不是，是比传入容量参数值大的最小的2的n次方，比如传入6，实际分配8。&lt;/p&gt;
&lt;h5 id=&quot;hashmap的底层数据结构是什么&quot;&gt;HashMap的底层数据结构是什么？&lt;/h5&gt;
&lt;p&gt;是一个数组，结合了顺序表+单向链表的形式，内部的每一个节点都是Node对象&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/x4qeJ0j.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;推荐几篇描述map原理还不错的文章&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 05:16:00 +0000</pubDate>
<dc:creator>薄峰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qbzf-Blog/p/9002137.html</dc:identifier>
</item>
<item>
<title>Spring消息之STOMP - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/8999998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/8999998.html</guid>
<description>&lt;h2&gt;一、STOMP 简介&lt;/h2&gt;
&lt;p&gt;    直接使用WebSocket（或SockJS）就很类似于使用TCP套接字来编写Web应用。因为没有高层级的线路协议（wire protocol），因此就需要我们定义应用之间所发送消息的语义，还需要确保连接的两端都能遵循这些语义。&lt;/p&gt;
&lt;p&gt;    就像HTTP在TCP套接字之上添加了请求-响应模型层一样，STOMP在WebSocket之上提供了一个基于帧的线路格式（frame-based wire format）层，用来定义消息的语义。&lt;/p&gt;
&lt;p&gt;    与HTTP请求和响应类似，STOMP帧由命令、一个或多个头信息以及负载所组成。例如，如下就是发送数据的一个STOMP帧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; SEND
transaction:tx&lt;/span&gt;-0&lt;span&gt;
destination:&lt;/span&gt;/app/&lt;span&gt;marco
content&lt;/span&gt;-length:20&lt;span&gt;

{&lt;/span&gt;&quot;message&quot;:&quot;Marco!&quot;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在这个例子中，STOMP命令是send，表明会发送一些内容。紧接着是三个头信息：一个表示消息的的事务机制，一个用来表示消息要发送到哪里的目的地，另外一个则包含了负载的大小。然后，紧接着是一个空行，STOMP帧的最后是负载内容。&lt;/p&gt;
&lt;h2&gt;二、服务端实现&lt;/h2&gt;
&lt;h3&gt;1、启用STOMP功能&lt;/h3&gt;
&lt;p&gt;    STOMP 的消息根据前缀的不同分为三种。如下，以 /app 开头的消息都会被路由到带有@MessageMapping 或 @SubscribeMapping 注解的方法中；以/topic 或 /queue 开头的消息都会发送到STOMP代理中，根据你所选择的STOMP代理不同，目的地的可选前缀也会有所限制；以/user开头的消息会将消息重路由到某个用户独有的目的地上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201805/1153954-20180506222500876-639399590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0efbdefa-7fdf-409c-a584-901f8a6b612f')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_0efbdefa-7fdf-409c-a584-901f8a6b612f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0efbdefa-7fdf-409c-a584-901f8a6b612f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0efbdefa-7fdf-409c-a584-901f8a6b612f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0efbdefa-7fdf-409c-a584-901f8a6b612f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableWebSocketMessageBroker
@PropertySource(&lt;/span&gt;&quot;classpath:resources.properties&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebSocketStompConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractWebSocketMessageBrokerConfigurer {

    @Value(&lt;/span&gt;&quot;${rabbitmq.host}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String host;

    @Value(&lt;/span&gt;&quot;${rabbitmq.port}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer port;

    @Value(&lt;/span&gt;&quot;${rabbitmq.userName}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;

    @Value(&lt;/span&gt;&quot;${rabbitmq.password}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将 &quot;/stomp&quot; 注册为一个 STOMP 端点。这个路径与之前发送和接收消息的目的地路径有所
     * 不同。这是一个端点，客户端在订阅或发布消息到目的地路径前，要连接到该端点。
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registry
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint(&lt;/span&gt;&quot;/stomp&quot;&lt;span&gt;).withSockJS();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 如果不重载它的话，将会自动配置一个简单的内存消息代理，用它来处理以&quot;/topic&quot;为前缀的消息
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registry
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureMessageBroker(MessageBrokerRegistry registry) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于内存的STOMP消息代理&lt;/span&gt;
        registry.enableSimpleBroker(&quot;/queue&quot;, &quot;/topic&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于RabbitMQ 的STOMP消息代理&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;        registry.enableStompBrokerRelay(&quot;/queue&quot;, &quot;/topic&quot;)
                .setRelayHost(host)
                .setRelayPort(port)
                .setClientLogin(userName)
                .setClientPasscode(password);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        registry.setApplicationDestinationPrefixes(&lt;/span&gt;&quot;/app&quot;, &quot;/foo&quot;&lt;span&gt;);
        registry.setUserDestinationPrefix(&lt;/span&gt;&quot;/user&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;2、处理来自客户端的STOMP消息&lt;/h3&gt;
&lt;p&gt;    服务端处理客户端发来的STOMP消息，主要用的是 @MessageMapping 注解。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  @MessageMapping(&quot;/marco&quot;&lt;span&gt;)
  @SendTo(&lt;/span&gt;&quot;/topic/marco&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  public&lt;/span&gt;&lt;span&gt; Shout stompHandle(Shout shout){
      LOGGER.info(&lt;/span&gt;&quot;接收到消息：&quot; +&lt;span&gt; shout.getMessage());
      Shout s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shout();
      s.setMessage(&lt;/span&gt;&quot;Polo!&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    2.1、@MessageMapping 指定目的地是“/app/marco”（“/app”前缀是隐含的，因为我们将其配置为应用的目的地前缀）。&lt;/p&gt;
&lt;p&gt;    2.2、方法接收一个Shout参数，因为Spring的某一个消息转换器会将STOMP消息的负载转换为Shout对象。Spring 4.0提供了几个消息转换器，作为其消息API的一部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201805/1153954-20180506225402000-1459244989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    2.3、尤其注意，这个处理器方法有一个返回值，这个返回值并不是返回给客户端的，而是转发给消息代理的，如果客户端想要这个返回值的话，只能从消息代理订阅。@SendTo 注解重写了消息代理的目的地，如果不指定@SendTo，帧所发往的目的地会与触发处理器方法的目的地相同，只不过会添加上“/topic”前缀。&lt;/p&gt;
&lt;p&gt;    2.4、如果客户端就是想要服务端直接返回消息呢？听起来不就是HTTP做的事情！即使这样，STOMP 仍然为这种一次性的响应提供了支持，用的是@SubscribeMapping注解，与HTTP不同的是，这种请求-响应模式是异步的...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   @SubscribeMapping(&quot;/getShout&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Shout getShout(){
       Shout shout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shout();
       shout.setMessage(&lt;/span&gt;&quot;Hello STOMP&quot;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shout;
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、发送消息到客户端&lt;/h3&gt;
&lt;h4&gt;3.1 在处理消息之后发送消息&lt;/h4&gt;
&lt;p&gt;    正如前面看到的那样，使用 @MessageMapping 或者 @SubscribeMapping 注解可以处理客户端发送过来的消息，并选择方法是否有返回值。&lt;/p&gt;
&lt;p&gt;    如果 @MessageMapping 注解的控制器方法有返回值的话，返回值会被发送到消息代理，只不过会添加上&quot;/topic&quot;前缀。可以使用@SendTo 重写消息目的地；&lt;/p&gt;
&lt;p&gt;    如果 @SubscribeMapping 注解的控制器方法有返回值的话，返回值会直接发送到客户端，不经过代理。如果加上@SendTo 注解的话，则要经过消息代理。&lt;/p&gt;
&lt;h4&gt;3.2 在应用的任意地方发送消息&lt;/h4&gt;
&lt;p&gt;    spring-websocket 定义了一个 SimpMessageSendingOperations 接口（或者使用SimpMessagingTemplate ），可以实现自由的向任意目的地发送消息，并且订阅此目的地的所有用户都能收到消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Autowired
&lt;/span&gt;&lt;span&gt;  private&lt;/span&gt;&lt;span&gt; SimpMessageSendingOperations simpMessageSendingOperations;


&lt;/span&gt;&lt;span&gt;  /**&lt;/span&gt;&lt;span&gt;
  * 广播消息，不指定用户，所有订阅此的用户都能收到消息
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shout
&lt;/span&gt;&lt;span&gt;  */&lt;/span&gt;&lt;span&gt;
  @MessageMapping(&lt;/span&gt;&quot;/broadcastShout&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; broadcast(Shout shout) {
      simpMessageSendingOperations.convertAndSend(&lt;/span&gt;&quot;/topic/shouts&quot;&lt;span&gt;, shout);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.3 为指定用户发送消息&lt;/h4&gt;
&lt;p&gt;    3.2介绍了如何广播消息，订阅目的地的所有用户都能收到消息。如果消息只想发送给特定的用户呢？spring-websocket 介绍了两种方式来实现这种功能，一种是 基于@SendToUser注解和Principal参数，一种是SimpMessageSendingOperations 接口的convertAndSendToUser方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基于@SendToUser注解和Principal参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    @SendToUser 表示要将消息发送给指定的用户，会自动在消息目的地前补上&quot;/user&quot;前缀。如下，最后消息会被发布在  /user/queue/notifications-username。但是问题来了，这个username是怎么来的呢？就是通过 principal 参数来获得的。那么，principal 参数又是怎么来的呢？需要在spring-websocket 的配置类中重写 configureClientInboundChannel 方法，添加上用户的认证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e44e6542-857f-468f-80a1-55b3251a915e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e44e6542-857f-468f-80a1-55b3251a915e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e44e6542-857f-468f-80a1-55b3251a915e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e44e6542-857f-468f-80a1-55b3251a915e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e44e6542-857f-468f-80a1-55b3251a915e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 1、设置拦截器
     * 2、首次连接的时候，获取其Header信息，利用Header里面的信息进行权限认证
     * 3、通过认证的用户，使用 accessor.setUser(user); 方法，将登陆信息绑定在该 StompHeaderAccessor 上，在Controller方法上可以获取 StompHeaderAccessor 的相关信息
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registration
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelInterceptorAdapter() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Message&amp;lt;?&amp;gt; preSend(Message&amp;lt;?&amp;gt;&lt;span&gt; message, MessageChannel channel) {
                StompHeaderAccessor accessor &lt;/span&gt;= MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、判断是否首次连接&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StompCommand.CONNECT.equals(accessor.getCommand())){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、判断用户名和密码&lt;/span&gt;
                    String username = accessor.getNativeHeader(&quot;username&quot;).get(0&lt;span&gt;);
                    String password &lt;/span&gt;= accessor.getNativeHeader(&quot;password&quot;).get(0&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;admin&quot;.equals(username) &amp;amp;&amp;amp; &quot;admin&quot;&lt;span&gt;.equals(password)){
                        Principal principal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Principal() {
                            @Override
                            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
                            }
                        };
                        accessor.setUser(principal);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是首次连接，已经登陆成功&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
            }

        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;spring-websocket 用户认证&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  @MessageMapping(&quot;/shout&quot;&lt;span&gt;)
  @SendToUser(&lt;/span&gt;&quot;/queue/notifications&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  public&lt;/span&gt;&lt;span&gt; Shout userStomp(Principal principal, Shout shout) {
        String name &lt;/span&gt;=&lt;span&gt; principal.getName();
        String message &lt;/span&gt;=&lt;span&gt; shout.getMessage();
        LOGGER.info(&lt;/span&gt;&quot;认证的名字是：{}，收到的消息是：{}&quot;&lt;span&gt;, name, message);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shout;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;convertAndSendToUser方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;   除了convertAndSend()以外，SimpMessageSendingOperations 还提供了convertAndSendToUser()方法。按照名字就可以判断出来，convertAndSendToUser()方法能够让我们给特定用户发送消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    @MessageMapping(&quot;/singleShout&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; singleUser(Shout shout, StompHeaderAccessor stompHeaderAccessor) {
        String message &lt;/span&gt;=&lt;span&gt; shout.getMessage();
        LOGGER.info(&lt;/span&gt;&quot;接收到消息：&quot; +&lt;span&gt; message);
        Principal user &lt;/span&gt;=&lt;span&gt; stompHeaderAccessor.getUser();
        simpMessageSendingOperations.convertAndSendToUser(user.getName(), &lt;/span&gt;&quot;/queue/shouts&quot;&lt;span&gt;, shout);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如上，这里虽然我还是用了认证的信息得到用户名。但是，其实大可不必这样，因为 convertAndSendToUser 方法可以指定要发送给哪个用户。也就是说，完全可以把用户名的当作一个参数传递给控制器方法，从而绕过身份认证！convertAndSendToUser 方法最终会把消息发送到 /user/sername/queue/shouts 目的地上。&lt;/p&gt;
&lt;h3&gt;4、处理消息异常&lt;/h3&gt;
&lt;p&gt;    在处理消息的时候，有可能会出错并抛出异常。因为STOMP消息异步的特点，发送者可能永远也不会知道出现了错误。@MessageExceptionHandler标注的方法能够处理消息方法中所抛出的异常。我们可以把错误发送给用户特定的目的地上，然后用户从该目的地上订阅消息，从而用户就能知道自己出现了什么错误啦...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     @MessageExceptionHandler(Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
     @SendToUser(&lt;/span&gt;&quot;/queue/errors&quot;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception handleExceptions(Exception t){
         t.printStackTrace();
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、客户端实现&lt;/h2&gt;
&lt;h3&gt;1、JavaScript 依赖&lt;/h3&gt;
&lt;p&gt;    STOMP 依赖 sockjs.js 和 stomp.min.js。stomp.min.js的下载链接：&lt;span&gt;&lt;a href=&quot;http://www.bootcdn.cn/stomp.js/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.bootcdn.cn/stomp.js/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;/js/stomp.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、JavaScript 客户端实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bd8a5038-492a-417e-823f-3a0e04209729')&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_bd8a5038-492a-417e-823f-3a0e04209729&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd8a5038-492a-417e-823f-3a0e04209729&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bd8a5038-492a-417e-823f-3a0e04209729',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd8a5038-492a-417e-823f-3a0e04209729&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;STOMP&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; url = 'http://localhost:8080/stomp'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SockJS(url);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stomp =&lt;span&gt; Stomp.over(sock);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strJson = JSON.stringify({'message': 'Marco!'&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认的和STOMP端点连接&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;stomp.connect(&quot;guest&quot;, &quot;guest&quot;, function (franme) {

});&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; headers=&lt;span&gt;{
    username:&lt;/span&gt;'admin'&lt;span&gt;,
    password:&lt;/span&gt;'admin'&lt;span&gt;
};

stomp.connect(headers, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (frame) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数是一个头信息的Map，它会包含在STOMP的帧中&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务支持&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; tx =&lt;span&gt; stomp.begin();
    stomp.send(&lt;/span&gt;&quot;/app/marco&quot;&lt;span&gt;, {transaction: tx.id}, strJson);
    tx.commit();


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅服务端消息 subscribe(destination url, callback[, headers])&lt;/span&gt;
    stomp.subscribe(&quot;/topic/marco&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (message) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content =&lt;span&gt; message.body;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; JSON.parse(content);
        console.log(&lt;/span&gt;&quot;订阅的服务端消息：&quot; +&lt;span&gt; obj.message);
    }, {});


    stomp.subscribe(&lt;/span&gt;&quot;/app/getShout&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (message) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content =&lt;span&gt; message.body;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; JSON.parse(content);
        console.log(&lt;/span&gt;&quot;订阅的服务端直接返回的消息：&quot; +&lt;span&gt; obj.message);
    }, {});


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;以下是针对特定用户的订阅&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; adminJSON = JSON.stringify({'message': 'ADMIN'&lt;span&gt;});
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第一种&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    stomp.send(&lt;/span&gt;&quot;/app/singleShout&quot;&lt;span&gt;, {}, adminJSON);
    stomp.subscribe(&lt;/span&gt;&quot;/user/queue/shouts&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (message) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content =&lt;span&gt; message.body;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; JSON.parse(content);
        console.log(&lt;/span&gt;&quot;admin用户特定的消息1：&quot; +&lt;span&gt; obj.message);
    });
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第二种&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    stomp.send(&lt;/span&gt;&quot;/app/shout&quot;&lt;span&gt;, {}, adminJSON);
    stomp.subscribe(&lt;/span&gt;&quot;/user/queue/notifications&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (message) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content =&lt;span&gt; message.body;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; JSON.parse(content);
        console.log(&lt;/span&gt;&quot;admin用户特定的消息2：&quot; +&lt;span&gt; obj.message);
    });

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;订阅异常消息&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    stomp.subscribe(&lt;/span&gt;&quot;/user/queue/errors&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (message) {
        console.log(message.body);
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若使用STOMP 1.1 版本，默认开启了心跳检测机制（默认值都是10000ms）&lt;/span&gt;
    stomp.heartbeat.outgoing = 20000&lt;span&gt;;

    stomp.heartbeat.incoming &lt;/span&gt;= 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端不从服务端接收心跳包&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;演示源代码链接：&lt;span&gt;&lt;a href=&quot;https://github.com/JMCuixy/SpringWebSocket&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/JMCuixy/SpringWebSocket&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 05:10:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/8999998.html</dc:identifier>
</item>
<item>
<title>Windows ML，系统内置的机器学习平台初探 - msp的昌伟哥哥</title>
<link>http://www.cnblogs.com/mantgh/p/9002027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantgh/p/9002027.html</guid>
<description>&lt;p&gt;人工智能现在很火，虽然最近风头隐隐有被区块链盖过，但仍是未来技术转型的首选方向之一。作为AI核心的机器学习，目前也进化到了可以基于平台自动训练模型的地步，例如Azure Machine Learning Service和Google AutoML Service。这使得训练模型的难度大大降低，开发人员可以分出更多精力关注在训练好的模型应用上。&lt;/p&gt;
&lt;p&gt;在这种背景下，各个操作系统平台纷纷推出内置的机器学习框架/运行环境，iOS有CoreML，Android有TensorFlow。Windows在最近的RS4（build 1803）更新之后，也正式内置了机器学习平台- &lt;strong&gt;Windows ML&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/599309/201805/599309-20180507092635670-1190434747.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Windows ML是什么？&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Windows ML是Windows全新的内置机器学习平台，用于本机执行预训练的机器学习模型，并提供了API允许我们快速集成到应用中。&lt;/p&gt;
&lt;p&gt;它的亮点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持硬件加速&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在兼容DirectX 12的设备上可以直接使用GPU加速运算，确保机器学习模型可以被高效执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本机执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不依赖于任何远程服务，不受任何网络连接限制，本机即可达到低延迟高性能的执行效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图像处理优化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对计算机视觉场景，对视频、图像和相机数据统一预处理为VideoFrame形式，简化图像处理流程。&lt;/p&gt;

&lt;h2&gt;模型要求&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/599309/201805/599309-20180507121322949-496229270.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Windows ML目前仅支持执行ONNX格式模型，其他格式需要预先转换后再使用。&lt;/p&gt;
&lt;p&gt;ONNX是由微软、Facebook和英特尔等公司推出的一个通用开放的机器学习模型格式，官方支持现有机器学习框架对其转换。&lt;a href=&quot;https://github.com/onnx/onnx&quot;&gt;ONNX项目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持转换的现有模型来源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Core ML&lt;/li&gt;
&lt;li&gt;Scikit-Learn&lt;/li&gt;
&lt;li&gt;XGBoost&lt;/li&gt;
&lt;li&gt;LibSVM&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用的转换工具为微软提供的WinMLTools：&lt;a href=&quot;https://pypi.org/project/winmltools/&quot; target=&quot;_blank&quot;&gt;https://pypi.org/project/winmltools/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转换工具使用教程请参考官方文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/machine-learning/conversion-samples&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/windows/uwp/machine-learning/conversion-samples &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;代码生成&lt;/h2&gt;
&lt;hr/&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;在安装了Windows SDK Build 17110或更新版本后，默认会为Visual Studio 2017项目添加模型代码生成工具&lt;span&gt;mlgen.exe&lt;span&gt;。它可以根据添加的ONNX模型文件，Visual Studio 2017 Preview自动生成C#/CX的定义文件，方便代码直接调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里以FNS-La-Muse模型为例，这是一个可以将图像转为特定风格的模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/599309/201805/599309-20180507120927765-192219649.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;331&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;生成的代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b4072e6e-c33d-473c-83f2-fa4e9adcdad4')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_b4072e6e-c33d-473c-83f2-fa4e9adcdad4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b4072e6e-c33d-473c-83f2-fa4e9adcdad4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b4072e6e-c33d-473c-83f2-fa4e9adcdad4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b4072e6e-c33d-473c-83f2-fa4e9adcdad4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Windows.Media;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Windows.Storage;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Windows.AI.MachineLearning.Preview;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FNSLaMuse&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FNSLaMuseModelInput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; VideoFrame inputImage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FNSLaMuseModelOutput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; VideoFrame outputImage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FNSLaMuseModelOutput()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.outputImage = VideoFrame.CreateWithSoftwareBitmap(&lt;span&gt;new&lt;/span&gt; Windows.Graphics.Imaging.SoftwareBitmap(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, &lt;span&gt;720&lt;/span&gt;, &lt;span&gt;720&lt;/span&gt;&lt;span&gt;));
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FNSLaMuseModel
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LearningModelPreview learningModel;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;FNSLaMuseModel&amp;gt;&lt;span&gt; CreateFNSLaMuseModel(StorageFile file)
        {
            LearningModelPreview learningModel &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; LearningModelPreview.LoadModelFromStorageFileAsync(file);
            FNSLaMuseModel model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FNSLaMuseModel();
            model.learningModel &lt;/span&gt;=&lt;span&gt; learningModel;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;FNSLaMuseModelOutput&amp;gt;&lt;span&gt; EvaluateAsync(FNSLaMuseModelInput input) {
            FNSLaMuseModelOutput output &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FNSLaMuseModelOutput();
            LearningModelBindingPreview binding &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LearningModelBindingPreview(learningModel);
            binding.Bind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inputImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, input.inputImage);
            binding.Bind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outputImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, output.outputImage);
            LearningModelEvaluationResultPreview evalResult &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; learningModel.EvaluateAsync(binding, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 目前由于SDK仍在预览中，所以Visual Studio正式版并不会自动调用mlgen工具生成定义文件，需要手动执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mlgen -i INPUT-FILE -l LANGUAGE -n NAMESPACE [-o OUTPUT-FILE]
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;INPUT-FILE&lt;/code&gt;: ONNX模型文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LANGUAGE&lt;/code&gt;: C++或者C#&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NAMESPACE&lt;/code&gt;: 命名空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OUTPUT-FILE&lt;/code&gt;: 输出路径，可缺省&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 总结&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;有了Windows ML后我们可以实现以前难以实现的机器学习特性，同时不用依赖外部web service，很多创新的体验可以实现，不仅仅是在PC，甚至在HoloLens上同样可以运用机器学习的能力。&lt;/p&gt;
&lt;h4&gt;最后给大家安利下我的开源项目- &lt;span&gt;&lt;a href=&quot;https://github.com/ChangweiZhang/Awesome-WindowsML-ONNX-Models&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Awesome WindowsML ONNX Models&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; ，这个项目除了提供我已经验证过的模型外，还提供了CoreML模型的快速转换工具。&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/599309/201805/599309-20180507121732233-2018151747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 同时我也在开发为HoloLens编写的Demo,最近将会和大家见面&lt;/p&gt;
</description>
<pubDate>Mon, 07 May 2018 04:20:00 +0000</pubDate>
<dc:creator>msp的昌伟哥哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantgh/p/9002027.html</dc:identifier>
</item>
</channel>
</rss>