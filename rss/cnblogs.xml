<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用 OpenSSL为WindowsServer远程桌面（RDP）创建自签名证书 (Self-signed SSL certificate) - ChasingDreams</title>
<link>http://www.cnblogs.com/chasingdreams2017/p/9420561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chasingdreams2017/p/9420561.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;笔者查阅很多资料，才写成此文章，如有错误，请读者们及时提出。&lt;br/&gt;一般大家使用远程桌面(Remote Desktop)连接Windows Server时，总会有一个警告提示，如图1&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1303627/201808/1303627-20180804231211395-293348145.png&quot; alt=&quot;图1&quot;/&gt;&lt;br/&gt;图1&lt;br/&gt;出现此警告的原因为证书为服务器的自签名证书，我们的客户端无法识别，故笔者思考，如何使用证书安全的使用远程桌面（RDP）。&lt;/p&gt;
&lt;h4 id=&quot;解决方法&quot;&gt;解决方法：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;使用WIndowsServer自带的&quot;AD证书服务&quot;，生成整个&lt;a href=&quot;https://baike.baidu.com/item/PKI/212376&quot;&gt;PKI&lt;/a&gt;，即拥有整套证书体系，自然所有有关认证问题迎刃而解。缺点是操作非常复杂，优点是安全，商业级别！&lt;/li&gt;
&lt;li&gt;使用OpenSSL全程自己搭建证书，比方式一会节省很多步骤，使用简单，适合开发测试，缺点是安全级别不能达到用于商业的高度（其实操作者熟知PKI、X509什么的，也能做出标准的证书）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;关于openca&quot;&gt;关于OpenCA:&lt;/h4&gt;
&lt;p&gt;OpenCA是一个开源项目，用于搭建私有&lt;a href=&quot;https://baike.baidu.com/item/PKI/212376&quot;&gt;PKI&lt;/a&gt;。笔者才疏学浅，尚未对此有所研究，希望有对此比较清楚的读者告知如何应用到远程桌面服务器身份认证上。^-^&lt;/p&gt;
&lt;h4 id=&quot;难点&quot;&gt;难点:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;客户端连接服务器远程桌面时需要检查证书吊销状态。检查证书吊销状态有两种方式： &lt;a href=&quot;http://www.cfca.com.cn/20150811/101230759.html&quot;&gt;CRL与OSCP&lt;/a&gt;&lt;br/&gt;1.1 OCSP&lt;br/&gt;默认情况，证书路径验证设置使用的是OCSP,但是由于我们是自签名证书，Windows检查时始终会提示&quot;Invalid Signer EKU&quot;/&quot;无效签名者 EKU&quot;,所以我们无法使用此方式验证证书吊销状态。&lt;br/&gt;1.2 CRL&lt;br/&gt;当OCSP不能满足我们的需求时，我们只能使用CRL来验证证书吊销状态啦，所以我们还需使用一个站点用于提供CRL&lt;/li&gt;
&lt;li&gt;在OpenSSL 中灵活使用&lt;code&gt;x509v3_config&lt;/code&gt;。目前好多文章都没有讲到如何在证书里添加&lt;code&gt;CRL分发点&lt;/code&gt;、&lt;code&gt;授权信息访问&lt;/code&gt;等扩展信息，究其原因就是没有理解X509z证书扩展的应用，当然也有好多文章里面有提及，但未明确指明，会让读者一头雾水。&lt;code&gt;强烈推荐使用OpenSSL的读者阅读&lt;/code&gt; &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man5/x509v3_config.html&quot;&gt;x509v3_config - X509 V3 certificate extension configuration format&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;兵贵神速，马上实战！&lt;/p&gt;
&lt;h2 id=&quot;openssl&quot;&gt;OpenSSL&lt;/h2&gt;
&lt;p&gt;笔者使用的是Ubuntu，所以可能会出现不同操作系统OpenSSL配置文件路径不一样的情况，请读者自行根据自身情况寻找默认配置文件.&lt;br/&gt;不要使用太旧的OpenSSL，当心漏洞。&lt;/p&gt;
&lt;h3 id=&quot;准备环境&quot;&gt;准备环境&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mkdir openssl.Test
cd openssl.Test
mkdir -p ./demoCA/{private,newcerts} 
touch demoCA/index.txt 
touch demoCA/serial
touch demoCA/crlnumber
echo 01 &amp;gt; demoCA/serial
echo 01 &amp;gt; demoCA/crlnumber
cp /etc/ssl/openssl.cnf .&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自建ca&quot;&gt;自建CA&lt;/h2&gt;
&lt;p&gt;根据提示输入信息时，请读者牢记输入内容，后文有用到。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置私钥&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl genrsa -des3 -out ./demoCA/private/cakey.pem 2048&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;申请自签名证书&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl req -new -x509 -days 365 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调整openssl.cnf&quot;&gt;调整openssl.cnf&lt;/h2&gt;
&lt;p&gt;打开我们之前复制过来的openssl.cnf&lt;/p&gt;
&lt;p&gt;[ CA_default ]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;default_crl_days= 365&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确保req下存在以下2行（默认第一行是有的，第2行被注释了）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ req ]
distinguished_name = req_distinguished_name
req_extensions = v3_req&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;v3_req节点示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ v3_req ]

# 在证书请求中添加扩展

# 作为最终证书，不能用此证书作为中间证书 具体表现为在查看证书中&quot;基本约束&quot;为 Subject Type=End Entity
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
# 暂且理解用来扩展域名吧，DNS.1建议写服务器域名，否则在做HTTPS网站时就呵呵了（题外话）， SANs是超级有用的！
subjectAltName = @alt_names
# 指定CRL地址的 必需
crlDistributionPoints = @crl_section
# CPS 说明，具体表现在查看证书&quot;免责说明&quot;中
certificatePolicies = @polsect

[ alt_names ]

DNS.1 = test.com
DNS.2 = a.test.com
DNS.3 = b.test.com

[crl_section]
URI.0 = http://example.com/rootca.crl

[polsect]

policyIdentifier = 2.5.29.32.0
CPS.1=&quot;http://example.com/&quot;
userNotice.1=@notice

[notice]

explicitText=&quot;Prower By Low-grade Coder&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成服务器证书&quot;&gt;生成服务器证书&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;设置私钥&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl genrsa -out userkey.pem 2048&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建证书申请&lt;br/&gt;&lt;code&gt;countryName&lt;/code&gt;、&lt;code&gt;stateOrProvinceName&lt;/code&gt;、&lt;code&gt;organizationName&lt;/code&gt; 默认要求与建CA时填写的要一致，如要修改规则可在&lt;code&gt;openssl.cnf&lt;/code&gt;中&lt;code&gt;[ CA_default ]&lt;/code&gt;里修改,&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# Common Name 写域名或IP
openssl req -new -days 365 -key userkey.pem -out userreq.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;签发&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl ca -in userreq.pem -out usercert.pem -extensions v3_req -config openssl.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;制作pfx&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl pkcs12 -export -inkey userkey.pem -in usercert.pem -out user.pfx&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;吊销证书&quot;&gt;吊销证书&lt;/h2&gt;
&lt;p&gt;好吧，我们没有需要吊销的证书，暂时忽略&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl ca -revoke usercert.pem -cert ./demoCA/cacert.pem -keyfile ./demoCA/private/cakey.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成吊销列表&quot;&gt;生成吊销列表&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;openssl ca -gencrl -out rootca.crl -cert ./demoCA/cacert.pem -keyfile ./demoCA/private/cakey.pem --config openssl.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把&lt;code&gt;rootca.crl&lt;/code&gt;部署到站点上，做到客户端使用HTTP/HTTPS协议能访问到配置文件中&lt;code&gt;[crl_section]&lt;/code&gt;的地址即可。&lt;/p&gt;
&lt;p&gt;准备工作到此完成！&lt;/p&gt;
&lt;h2 id=&quot;windowsserver&quot;&gt;WindowsServer&lt;/h2&gt;
&lt;h3 id=&quot;导入根证书&quot;&gt;导入根证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;cacert.pem&lt;/code&gt;改名为&lt;code&gt;cacert.crt&lt;/code&gt;,复制到服务器，点击安装到&lt;code&gt;本地计算机&lt;/code&gt;,至此，根证书安装完毕&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;导入服务器证书&quot;&gt;导入服务器证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;导入&lt;code&gt;user.pfx&lt;/code&gt;,&lt;code&gt;本地计算机&lt;/code&gt;和&lt;code&gt;当前用户&lt;/code&gt;都需要导入到&lt;code&gt;个人&lt;/code&gt;目录中。&lt;br/&gt;PS：使用&quot;根据证书类型，自动选择证书存储&quot;也可以啦，会默认选择&lt;code&gt;个人&lt;/code&gt;目录的&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;设定远程桌面证书&quot;&gt;设定远程桌面证书&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;certmgr.msc&lt;/code&gt; 打开证书管理器，展开 &lt;code&gt;个人&lt;/code&gt;-&amp;gt;&lt;code&gt;证书&lt;/code&gt;,双击我们刚刚导入的证书，选择&lt;code&gt;详细信息&lt;/code&gt;,找到&lt;code&gt;指纹&lt;/code&gt;,复制其内容到记事本(或命令行)，去除&lt;code&gt;空格&lt;/code&gt;，备用。&lt;br/&gt;PS：那一串十六进制最前面的空格超级隐蔽。&lt;/p&gt;
&lt;p&gt;使用命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wmic /namespace:\\root\cimv2\TerminalServices PATH Win32_TSGeneralSetting Set  SSLCertificateSHA1Hash=&quot;刚处理的指纹&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现更新成功字样即可，如失败，请仔细检查细节。&lt;/p&gt;
&lt;h3 id=&quot;修改组策略&quot;&gt;修改组策略&lt;/h3&gt;
&lt;p&gt;再次强调，证书默认吊销查询使用的OCSP，可是笔者至今未调通，只能通过修改组策略的方式强制走CRL，可是这样会有一系列弊端（当然也可以避免），如果有读者能使用OCSP验证证书吊销状态，此步骤可避免！届时请联系笔者！谢谢。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;启动组策略 gpedit.msc
[计算机配置]-&amp;gt;[安全设置]-&amp;gt;[公钥策略]
打开[证书路径验证设置]
选择[吊销]选项卡
勾选[定义这些策略设置]、[始终首选证书吊销列表(CRL)而非联机证书状态协议(OCSP)响应(不推荐)(P)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;应用&lt;/code&gt;-&amp;gt;&lt;code&gt;重启机器&lt;/code&gt;。至此，服务器端配置完毕。&lt;/p&gt;
&lt;h2 id=&quot;windows&quot;&gt;Windows&lt;/h2&gt;
&lt;h3 id=&quot;导入根证书-1&quot;&gt;导入根证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;cacert.pem&lt;/code&gt;改名为&lt;code&gt;cacert.crt&lt;/code&gt;,复制到服务器，点击安装到&lt;code&gt;本地计算机&lt;/code&gt;,至此，根证书安装完毕&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;是时候结束这个磨人的小东西了&quot;&gt;^.^ 是时候结束这个磨人的小东西了&lt;/h2&gt;
&lt;p&gt;打开远程桌面 &lt;code&gt;mstsc&lt;/code&gt;,验证结果,如图2&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1303627/201808/1303627-20180804231238267-749078923.png&quot; alt=&quot;图2&quot;/&gt;&lt;br/&gt;图2&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;肯定有读者会问，使用自签名证书连接远程桌面，需要客户端安装CA，岂不是很麻烦？&lt;br/&gt;对此问题，一般使用此方法用于开发测试学习，如不想配置WindowsServer证书服务器或OpenCA等，可以直接使用在线服务商的证书，只需把本文相关自建证书省略，即可应用。参考&lt;a href=&quot;http://blog.robiii.nl/2015/10/configure-your-windows-remote-desktop.html&quot;&gt;Configure your Windows Remote Desktop (RDP) to use TLS with a StartSSL certificate&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于ocsp笔者研究的进展&quot;&gt;关于OCSP笔者研究的进展&lt;/h2&gt;
&lt;p&gt;首先修改配置文件&lt;/p&gt;
&lt;pre class=&quot;cacert.crt```为ca证书，因为我们用的是base64形式的证书，所以直接改后缀```*.pem```-&amp;gt;```*.crt```没有任何问题。&quot;&gt;
&lt;code&gt;参考：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](https://www.cnblogs.com/guogangj/p/4118605.html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[ v3_req ]&lt;/p&gt;
&lt;p&gt;.....&lt;/p&gt;
&lt;p&gt;authorityInfoAccess = @ocsp_section&lt;/p&gt;
&lt;p&gt;[ ocsp_section ]&lt;br/&gt;caIssuers;URI.0 = http://example.com/cacert.crt&lt;br/&gt;OCSP;URI.0 = http://example.com/&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;其次创建个OCSP服务端 (OCSP Responser)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;openssl ocsp -index ./demoCA/index.txt -CA ./demoCA/cacert.pem -rsigner usercert.pem -rkey userkey.pem -port 8000 -text&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;接着再开一个终端，验证下证书

OCSP Client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;openssl ocsp -issuer ./demoCA/cacert.pem -url http://example.com:8000 -serial 01 -VAfile usercert.pem&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们会观察到OCSP工作正常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Response verify OK&lt;br/&gt;01: good&lt;br/&gt;This Update: Aug 4 09:20:46 2018 GMT&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;然后打开WindowServer，导入相关证书，使用```certutil```检查&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;certutil -url C:\Users...\cacert.crt&lt;br/&gt;&lt;code&gt;选择检索方式为OCSP，点击检索&lt;/code&gt;最终```出现&quot;Invalid Signer EKU&quot;/&quot;无效签名者 EKU&quot;的结果。&lt;br/&gt;笔者猜测毕竟我们自签名证书，服务器无法验证我们的身份吧。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://community.spiceworks.com/topic/2098362-rdp-a-revocation-check-could-not-be-performed-for-the-certificate&quot;&gt;[SOLVED] RDP - A revocation check could not be performed for the certificate - Microsoft Remote Desktop Services - Spiceworks&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://webcache.googleusercontent.com/search?q=cache:http://blog.robiii.nl/2015/10/configure-your-windows-remote-desktop.html&amp;amp;gws_rd=cr&quot;&gt;RobIII: Configure your Windows Remote Desktop (RDP) to use TLS with a StartSSL certificate&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd320345(v=ws.10)&quot;&gt;RDS: RD Gateway must be configured to use an SSL certificate signed by a trusted certification authority | Microsoft Docs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blogs.technet.microsoft.com/askds/2009/06/24/implementing-an-ocsp-responder-part-i-introducing-ocsp/&quot;&gt;Implementing an OCSP responder: Part I – Introducing OCSP | Ask the Directory Services Team&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://serverfault.com/questions/131983/openssl-how-to-setup-an-ocsp-server-for-checking-third-party-certificates&quot;&gt;OpenSSL: how to setup an OCSP server for checking third-party certificates? - Server Fault&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.51cto.com/zlyux/1744016&quot;&gt;Windows Server 2012 R2 远程桌面安全证书警告-zlyux-51CTO博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/tsh185/article/details/8107248&quot;&gt;openssl ocsp - CSDN博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man5/x509v3_config.html&quot;&gt;/docs/manmaster/man5/x509v3_config.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/howeverpf/article/details/21622545&quot;&gt;使用OpenSSL工具制作X.509证书的方法及其注意事项总结 - CSDN博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.sys4.de/how-create-and-administer-x509-certificate-chains-part-i-en.html&quot;&gt;How to create and administer X.509 Certificate chains, Part I&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://superuser.com/questions/738612/openssl-ca-keyusage-extension&quot;&gt;ssl - OpenSSL CA keyUsage extension - Super User&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;本文采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/2.5/cn/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议&lt;/a&gt;进行许可，发表在&lt;a href=&quot;https://blog.csdn.net/hatmen2&quot;&gt;CSDN&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/chasingdreams2017/&quot;&gt;博客园&lt;/a&gt;，欢迎读者转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接！请读者/爬虫们尊重&lt;code&gt;版权&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>ChasingDreams</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chasingdreams2017/p/9420561.html</dc:identifier>
</item>
<item>
<title>Python全栈 MySQL 数据库（SQL命令大全、MySQL 、Python调用） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9420563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9420563.html</guid>
<description>
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;p&gt;为了梦想与了信仰&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要三个方面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Linux终端命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.MySQL语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Python调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先删库 再跑路.....&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;                           终端命令：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vi                                                                文本编辑器&lt;/p&gt;
&lt;p&gt;cat /etc/password | grep “用户名”         获取user表&lt;/p&gt;

&lt;p&gt;sudo -i                                                       获取root权限&lt;/p&gt;

&lt;p&gt;sudo apt-get install python3-pip             安装pip3&lt;/p&gt;

&lt;p&gt;sudo pip3 install pymysql                        安装mysql&lt;/p&gt;

&lt;p&gt;sudo apt-get install mysql-server            安装服务端&lt;/p&gt;

&lt;p&gt;sudo apt-get install mysql-client             安装客户端&lt;/p&gt;

&lt;p&gt;sudo apt-get update                               读取列表 保存到 /var/lib/apt/lists&lt;/p&gt;

&lt;p&gt;sudo apt-get upgrade                             对比下载列表并更新&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql status                  查询状态&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql stop                     停止服务&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql restart                 重启服务&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql reload                 重新加载&lt;/p&gt;

&lt;p&gt;mysql -h主机地址 -u用户名 -p密码          链接mysql&lt;/p&gt;



&lt;p&gt;                                                             &lt;strong&gt; 修改mysql默认字符集：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sudo -i                                                                       1.获取root&lt;/p&gt;

&lt;p&gt;chmod  644 文件名                                                    2.修改文件权限&lt;/p&gt;

&lt;p&gt;cd etc/mysql/mysql.conf.d                                        3.进入配置文目录&lt;/p&gt;

&lt;p&gt;cp etc/msql.cnf/mysqld.cnf.bak                                4.备份&lt;/p&gt;

&lt;p&gt;subl mysqld.cnf                                                         5.vi打开源文件&lt;/p&gt;
&lt;p&gt;[mysqld]  目录&lt;/p&gt;
&lt;p&gt;character_set_server = utf8                                       6.添加命令&lt;/p&gt;
&lt;p&gt;/etc/init.d/mysql&lt;/p&gt;


&lt;p&gt;mysqldump -u用户 -p源库名 &amp;gt; ~/xxx.sql          &lt;strong&gt;   数据备份：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                                                       参数：&lt;/p&gt;
&lt;p&gt;          --all-databases                                                   1.备份所有库&lt;/p&gt;
&lt;p&gt;          库名                                                                     2.备份单个库&lt;/p&gt;
&lt;p&gt;          -B 库1 库2..                                                          3.备份多个库&lt;/p&gt;
&lt;p&gt;          库名 表1 表2...                                                     4.备份指定库指定表&lt;/p&gt;


&lt;p&gt;                                                                           &lt;strong&gt;  数据恢复：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mysql -uroot -p &amp;lt; 目标库名 xxx.sql                                  1. 恢复备份库&lt;/p&gt;
&lt;p&gt;mysql -uroot -p --one-database 目标库名 &amp;lt; xxx.sql        2. 恢复备份内某一个库&lt;/p&gt;
&lt;p&gt;恢复：表不删除 表记录删除覆盖&lt;/p&gt;



&lt;p&gt;                                                                     &lt;strong&gt; MySQL远程连接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo -i                                                               1.管理员模式&lt;/p&gt;
&lt;p&gt;cd /etc/mysql/mysql.conf.d/                             2.cd到mysql目录&lt;/p&gt;
&lt;p&gt;vi mysqld.cnf                                                     3.打开注释掉默认IP&lt;/p&gt;
&lt;p&gt;#bind-address = 127.0.0.1                                4.保存&lt;/p&gt;
&lt;p&gt;/etc/init.d/mysql restart                                    5.重启服务&lt;/p&gt;

&lt;p&gt;                                                                                                                                        &lt;strong&gt;授权用户：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grant 授权列表 on 库.表 to “用户名“@”%”identified by “密码” with grant option          1.命令格式&lt;/p&gt;
&lt;p&gt;示例：grant all privileges on *.* to &quot;tiger&quot;@&quot;%&quot; identified by &quot;123&quot; with grant option;          2.示例&lt;/p&gt;
&lt;p&gt;all privileges、select、insert ...                              4.库.表: *.*  所有库所有表  3.权限列表&lt;/p&gt;

&lt;p&gt;                                                 &lt;strong&gt; python3模块安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块名 ：pymysql &lt;/p&gt;
&lt;p&gt;        在线 ：sudo pip3 install pymysql&lt;/p&gt;
&lt;p&gt;离线 ：pymysql-0.7.11.tar.gz&lt;/p&gt;
&lt;p&gt;    $ tar -zxvf pymyql-0.7.11.tar.gz&lt;/p&gt;
&lt;p&gt;    $ cd pymysql-0.7.11&lt;/p&gt;
&lt;p&gt;    $ sudo python3 setup.py install&lt;/p&gt;
&lt;p&gt;        验证：&lt;/p&gt;
&lt;p&gt;            $ python3&lt;/p&gt;
&lt;p&gt;            &amp;gt;&amp;gt;&amp;gt; import pymysql&lt;/p&gt;
&lt;p&gt;            &amp;gt;&amp;gt;&amp;gt; &lt;/p&gt;

&lt;p&gt;                                                 &lt;strong&gt; python2模块安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块名 ：MySQLdb&lt;/p&gt;
&lt;p&gt;安装 ：sudo pip install mysql-python&lt;/p&gt;


&lt;p&gt;                                                 &lt;strong&gt; sqlalchemy 框架 安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在线 ：sudo pip3 install sqlalchemy&lt;/p&gt;
&lt;p&gt;    离线 ：&lt;/p&gt;
&lt;p&gt;      $ tar -zxvf SQLAlchemy-1.2.10.tar.gz&lt;/p&gt;
&lt;p&gt;      $ cd SQLAlchemy-1.2.10&lt;/p&gt;
&lt;p&gt;      $ sudo python3 setup.py install&lt;/p&gt;
&lt;p&gt;    验证：&lt;/p&gt;
&lt;p&gt;      $ python3&lt;/p&gt;
&lt;p&gt;      &amp;gt;&amp;gt;&amp;gt; import sqlalchemy&lt;/p&gt;
&lt;p&gt;      &amp;gt;&amp;gt;&amp;gt; &lt;/p&gt;

&lt;p&gt;                                                  &lt;strong&gt; pymysql使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;from pymsql import *                                   导入模块&lt;/p&gt;
&lt;p&gt;(db = pymysql.connect(...))                               1、建立数据库连接&lt;/p&gt;
&lt;p&gt;c = db.cursor())                                                 2、创建游标对象&lt;/p&gt;
&lt;p&gt;c.execute(&quot;insert ....&quot;)                                        3、游标方法: &lt;/p&gt;
&lt;p&gt;db.commit()                                                      4、提交到数据库&lt;/p&gt;
&lt;p&gt;c.close()                                                            5、关闭游标对象&lt;/p&gt;
&lt;p&gt;db.close()                                                         6、断开数据库连接 ：&lt;/p&gt;

&lt;p&gt;                                                                        7.&lt;strong&gt;connect对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;db = pymysql.connect(参数列表)&lt;/p&gt;
&lt;p&gt;      1、host ：主机地址,本地 localhost&lt;/p&gt;
&lt;p&gt;      2、port ：端口号,默认3306&lt;/p&gt;
&lt;p&gt;      3、user ：用户名&lt;/p&gt;
&lt;p&gt;      4、password ：密码&lt;/p&gt;
&lt;p&gt;      5、database ：库&lt;/p&gt;
&lt;p&gt;      6、charset ：编码方式,推荐使用 utf8&lt;/p&gt;
&lt;p&gt;                                                                       8.&lt;strong&gt;连接对象的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库连接对象(db)的方法&lt;/p&gt;
&lt;p&gt;      1、db.close() 关闭连接&lt;/p&gt;
&lt;p&gt;      2、db.commit() 提交到数据库执行&lt;/p&gt;
&lt;p&gt;      3、db.rollback() 回滚&lt;/p&gt;
&lt;p&gt;      4、cur = db.cursor() 返回游标对象,用于执行具体SQL命令&lt;/p&gt;
&lt;p&gt;                                                                     9.&lt;strong&gt;游标对象的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游标对象(cur)的方法&lt;/p&gt;
&lt;p&gt;      1、cur.execute(sql命令,[列表]) 执行SQL命令&lt;/p&gt;
&lt;p&gt;      2、cur.close() 关闭游标对象&lt;/p&gt;
&lt;p&gt;      3、cur.fetchone() 获取查询结果集的第一条数据&lt;/p&gt;
&lt;p&gt;                        ((记录1),)&lt;/p&gt;
&lt;p&gt;      4、cur.fetchmany(n) 获取n条&lt;/p&gt;
&lt;p&gt;                        ((记录1),(记录2))&lt;/p&gt;
&lt;p&gt;      5、cur.fetchall() 获取所有记录&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;ORM&lt;/strong&gt;：orm(Object Relation Mapping 对象关系映射) 定义：把对象模型映射到MySQL数据库中&lt;/p&gt;



&lt;p&gt;                                           &lt;strong&gt;&lt;span&gt;SQL命令：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;/var/lib/mysql                                                                          MySQL数据目录&lt;/p&gt;

&lt;p&gt;show variables like &quot;autocommit&quot;;                                          查询commit事务&lt;/p&gt;

&lt;p&gt;begin；                                                                                     开启事务&lt;/p&gt;

&lt;p&gt;commit；                                                                                  提交事务（MySQL默认自动提交）&lt;/p&gt;

&lt;p&gt;rollback；                                                                                 终止事务&lt;/p&gt;

&lt;p&gt;system sudo -i                                                                          由数据直接进入终端&lt;/p&gt;

&lt;p&gt;show databases；                                                                    查看已有库&lt;/p&gt;

&lt;p&gt;create database 库名；                                                             创建库&lt;/p&gt;

&lt;p&gt;create database 库名 charcater set utf8；                               指定字符集&lt;/p&gt;

&lt;p&gt;show create database 库名；                                                   查看库字符集&lt;/p&gt;

&lt;p&gt;select database（）；                                                              查看当前所在库&lt;/p&gt;

&lt;p&gt;use 库名；                                                                                切换库&lt;/p&gt;

&lt;p&gt;drop database 库名；                                                              删除库&lt;/p&gt;

&lt;p&gt;show tables；                                                                           查看已有表&lt;/p&gt;

&lt;p&gt;create table 表名（字段名1 数据类型，....）；                           创建表&lt;/p&gt;

&lt;p&gt;show create table 表名；                                                          查看表字符集&lt;/p&gt;

&lt;p&gt;desc 表名；                                                                               查看表结构&lt;/p&gt;

&lt;p&gt;drop table 表名；                                                                      删除表&lt;/p&gt;

&lt;p&gt;insert into 表名 values（值1），（值2）...；                             插入完整记录&lt;/p&gt;

&lt;p&gt;insert into 表名 （字段名1，...） values（值1），...；               插入字段数据&lt;/p&gt;

&lt;p&gt;select * from 表名 [where 条件]；                                             查询所有字段&lt;/p&gt;

&lt;p&gt;select 字段名1，字段名2，...from 表名[where 条件]；                查看字段&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型;                                        添加字段&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型 first；                               头插）&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型 after 字段名；                  指定插入）&lt;/p&gt;

&lt;p&gt;alter table 表名 drop 字段名；                                                   删除字段&lt;/p&gt;

&lt;p&gt;alter table 表名 modify 字段名 新数据类型；                             修改数据类型&lt;/p&gt;

&lt;p&gt;alter table 表名 rename 表名；                                                 表重命名&lt;/p&gt;

&lt;p&gt;delete from 表名 where 条件；                                                 删除表记录（必须加where）&lt;/p&gt;

&lt;p&gt;update 表名 set 字段1=值1，字段名2=值2，... where 条件       更改表记录（必须加where）&lt;/p&gt;

&lt;p&gt;alter table 表名 change 原名 新名 数据类型；                           字段重命名&lt;/p&gt;

&lt;p&gt; create table 表名 select .. from 表名 where 条件;                    复制表（不复制key）&lt;/p&gt;

&lt;p&gt;create table 表名 select * from 表名 where false;                    复制表结构（不复制key）&lt;/p&gt;

&lt;p&gt;sex enum（“M”,&quot;F&quot;,&quot;S&quot;） not null defaulf &quot;S&quot;                       约束&lt;/p&gt;

&lt;p&gt;show variables like 变量名；                                                    查询MySQL变量&lt;/p&gt;

&lt;p&gt;select 字段名列表 from 表名列表;                                              (笛卡尔积)&lt;/p&gt;

&lt;p&gt;select t1.name,t2.name from t1,t2 where 条件                        多表查询   &lt;/p&gt;

&lt;p&gt;create index 索引名 on 表名(字段名);                                         添加普通索引&lt;/p&gt;

&lt;p&gt;create table（....index（字段名），...）                                      创建表时创建普通索引&lt;/p&gt;

&lt;p&gt;drop index 索引名 on 表名；                                                      删除普通索引&lt;/p&gt;

&lt;p&gt;show index from 表名；                                                            查看普通索引&lt;/p&gt;

&lt;p&gt;create unique index 索引名 on表名（字段名）；                       添加唯一索引&lt;/p&gt;

&lt;p&gt;create table 表名( .... , unique key (字段名) );                             创建表时创建唯一索引&lt;/p&gt;

&lt;p&gt;drop unique index 索引名 on 表名；                                         删除唯一索引&lt;/p&gt;

&lt;p&gt;show unique index from 表名；                                                查看唯一索引&lt;/p&gt;

&lt;p&gt;alter table 表名 add primary key（字段名）；                           添加主键索引&lt;/p&gt;

&lt;p&gt;create table 表名( .... , id int， primary key (字段名) );                创建表时创主键一索引&lt;/p&gt;

&lt;p&gt;(id int primary key auto_increment,)auto_increment=10000;    设置自增长起始值&lt;/p&gt;

&lt;p&gt;alter table 表名 modify id int auto_increment;                            添加自增长&lt;/p&gt;

&lt;p&gt;alter table 表名 auto_increment=20000;                                     修改自增长起始值&lt;/p&gt;

&lt;p&gt;alter table 表名 modify id int;                                                       删除自增长&lt;/p&gt;

&lt;p&gt;alter table 表名 drop primary key;                                                删除主键索引&lt;/p&gt;

&lt;p&gt;show index from 表名\G;                                                             查看表索引&lt;/p&gt;

&lt;p&gt;desc 表名；                                                                                查看表结构（key）&lt;/p&gt;

&lt;p&gt;Non_Unique：1   ：index                                                         普通索引（查询结果）&lt;/p&gt;

&lt;p&gt;Non_Unique：0   ：unique                                                        唯一索引（查询结果）&lt;/p&gt;

&lt;p&gt;alter table 表名 drop foreign key 外键名;                                    删除外键&lt;/p&gt;

&lt;p&gt;show create table 表名;                                                                 查看外键名&lt;/p&gt;

&lt;p&gt;                                                                   &lt;strong&gt;  创建外键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;create......t1（）；&lt;/p&gt;
&lt;p&gt;create table t2（&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;foreign key(参考字段名)&lt;/p&gt;
&lt;p&gt;references 主表(被参考字段名)&lt;/p&gt;
&lt;p&gt;on delete 级联动作&lt;/p&gt;
&lt;p&gt;on update 级联动作）； &lt;/p&gt;
&lt;p&gt;                                                                    &lt;strong&gt; 添加外键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;alter table 表名 add &lt;/p&gt;
&lt;p&gt;foreign key(参考字段) references 主表(被参考字段)&lt;/p&gt;
&lt;p&gt;on delete ...&lt;/p&gt;
&lt;p&gt;on update ...&lt;/p&gt;
&lt;p&gt;                                                                     &lt;strong&gt;级联动作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;restrict(默认)不允许主表操作从表&lt;/p&gt;
&lt;p&gt;cascade ：跟随删除、更新&lt;/p&gt;
&lt;p&gt;set null：主表更改后从表值为NULL&lt;/p&gt;

&lt;p&gt;                                                                 &lt;strong&gt;    内链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select 字段名 from表1 &lt;/p&gt;
&lt;p&gt;inner join 表2 on 条件&lt;/p&gt;
&lt;p&gt;inner join 表3 on 条件...；&lt;/p&gt;

&lt;p&gt;                                                                  &lt;strong&gt;   外链接.左链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以左表为主显示查询结果&lt;/p&gt;
&lt;p&gt;         select 字段名 from 表1 &lt;/p&gt;
&lt;p&gt;         left join 表2 on 条件&lt;/p&gt;
&lt;p&gt;         left join 表3 on 条件...；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        以右表为主显示查询结果&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                                                     数据导入：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;load data  infile “文件名”&lt;/p&gt;
&lt;p&gt;into table 表名&lt;/p&gt;
&lt;p&gt;fields terminated by “分隔符”&lt;/p&gt;
&lt;p&gt;lines terminated by “\n”；&lt;/p&gt;

&lt;p&gt;                                                                 &lt;strong&gt;    数据导出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select ... from 表名&lt;/p&gt;
&lt;p&gt;into outfile “/var/lib/mysql-files/文件名”&lt;/p&gt;
&lt;p&gt;fields terminated by “分隔符”&lt;/p&gt;
&lt;p&gt;lines terminated by “\n”;&lt;/p&gt;

&lt;p&gt;                                                                   &lt;strong&gt;  数据恢复：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;恢复单个库&lt;/p&gt;
&lt;p&gt;     mysql -uroot -p &amp;lt; 目标库名 xxx.sql&lt;/p&gt;
&lt;p&gt;从所有库备份中恢复某一个库（-one-database）&lt;/p&gt;
&lt;p&gt;     mysql -uroot -p --one-database 目标库名 &amp;lt; xxx.sql&lt;/p&gt;
&lt;p&gt;恢复：表不删除 表记录删除覆盖&lt;/p&gt;

&lt;p&gt;                                                                    &lt;strong&gt; 数据备份：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysqldump -u用户 -p源库名 &amp;gt; ~/xxx.sql&lt;/p&gt;
&lt;p&gt;--all-databases  备份所有库&lt;/p&gt;
&lt;p&gt;库名             备份单个库&lt;/p&gt;
&lt;p&gt;-B 库1 库2..     备份多个库&lt;/p&gt;
&lt;p&gt;库名 表1 表2...  备份指定库指定表&lt;/p&gt;


&lt;p&gt;运行时间检测：&lt;/p&gt;
&lt;p&gt;   开启：set profiling=1；&lt;/p&gt;
&lt;p&gt;   关闭：set profiling=0；&lt;/p&gt;
&lt;p&gt;   查询执行记录：show profilings；&lt;/p&gt;



&lt;p&gt;                     &lt;strong&gt;&lt;span&gt; SQL查询：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3.select ... 聚合函数 from 表名&lt;/p&gt;
&lt;p&gt;1.where&lt;/p&gt;
&lt;p&gt;2.group by...&lt;/p&gt;
&lt;p&gt;4.having ...&lt;/p&gt;
&lt;p&gt;5.order by ...&lt;/p&gt;
&lt;p&gt;6.limit ...；&lt;/p&gt;

&lt;p&gt;select ... from 表名 where 条件(select ....);                         &lt;strong&gt;查询嵌套：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    2、找出每个国家攻击力最高的英雄的名字和攻击值&lt;/p&gt;
&lt;p&gt;       select name,gongji from sanguo&lt;/p&gt;
&lt;p&gt;       where &lt;/p&gt;
&lt;p&gt;       (country,gongji) in&lt;/p&gt;
&lt;p&gt;       (select country,max(gongji) from sanguo group by country);&lt;/p&gt;

&lt;p&gt;where：只能操作表中实际存在的字段&lt;/p&gt;
&lt;p&gt;group by：给查询结果进行分组&lt;/p&gt;
&lt;p&gt;having：对查询结果进一步筛选&lt;/p&gt;
&lt;p&gt;distinct：不显示字段重复值&lt;/p&gt;


&lt;p&gt;show engines;                                                                   查看所有存储引擎&lt;/p&gt;
&lt;p&gt;show create table 表名;                                                     查看表的存储引擎&lt;/p&gt;
&lt;p&gt;create table 表名(...)engine=myisam;                                创建表时指定存储引擎&lt;/p&gt;
&lt;p&gt;alter table 表名 engine=innodb;                                       添加储存引擎&lt;/p&gt;

&lt;p&gt;                                                                                         &lt;strong&gt; InnoDB：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB特点（2文件）：&lt;/p&gt;
&lt;p&gt;      行级锁、支持外键、事务操作&lt;/p&gt;
&lt;p&gt;      .frm（表结构，索引）、.ibd（表记录）&lt;/p&gt;

&lt;p&gt;MyISAM特点（3文件）：                                                  &lt;strong&gt;MyISAM：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      独享表空间、表级锁&lt;/p&gt;
&lt;p&gt;      .frm（结构）、.myd（记录）、.myi（索引）&lt;/p&gt;

&lt;p&gt;                                                                                              &lt;strong&gt;锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select ：加读锁之后别人不能更改表记录,但可以进行查询&lt;/p&gt;
&lt;p&gt;insert、delete、update ：加写锁之后别人不能查、不能改&lt;/p&gt;
&lt;p&gt;锁粒度：&lt;/p&gt;
&lt;p&gt;     表级锁 ：myisam&lt;/p&gt;
&lt;p&gt;     行级锁 ：innodb&lt;/p&gt;

&lt;p&gt;                                                                                         &lt;strong&gt;   调优：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.选择合适的存储引擎&lt;/p&gt;
&lt;p&gt;2.常用字段建立索引&lt;/p&gt;
&lt;p&gt;3.where 避免使用 !=、NULL判断、or链接、&lt;/p&gt;
&lt;p&gt;   like前置%、in、not in、*代替字段、&lt;/p&gt;


&lt;p&gt;                 &lt;strong&gt;      &lt;span&gt; 数据类型:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;数据类型:&lt;/p&gt;

&lt;p&gt;int             大整型（4个字节）  2**32 - 1（4294967295）&lt;/p&gt;

&lt;p&gt;tinyint         微小整型（一个字节） &lt;/p&gt;
&lt;p&gt;                有符号（signed默认）：-128 ~ 127&lt;/p&gt;
&lt;p&gt;                无符号（unsigned）：0 ~ 255&lt;/p&gt;

&lt;p&gt;smallint        小整型（2字节）&lt;/p&gt;
&lt;p&gt;bigint          极大整型（8字节）&lt;/p&gt;
&lt;p&gt;float           浮点数（4个字节，7个有效位）&lt;/p&gt;
&lt;p&gt;       字段名 float（m，n） m：总位数 n：小数位数&lt;/p&gt;
&lt;p&gt;decimal         浮点数（28个有效位）&lt;/p&gt;
&lt;p&gt;      字段名 decimal（m，n）m：总位数 n：小数位数&lt;/p&gt;
&lt;p&gt;            将9的倍数包装成4个字节&lt;/p&gt;
&lt;p&gt;      余数   字节&lt;/p&gt;
&lt;p&gt;        0      0&lt;/p&gt;
&lt;p&gt;       1-2     1&lt;/p&gt;
&lt;p&gt;       3-4     2&lt;/p&gt;
&lt;p&gt;       5-6     3&lt;/p&gt;
&lt;p&gt;       7-9     4&lt;/p&gt;

&lt;p&gt;字段名 enum（值1，值2...）；               单选（enum）&lt;/p&gt;

&lt;p&gt;字段名 set（值1，值2...）；                多选（set）&lt;/p&gt;
&lt;p&gt;    （多项放在一个字符串内用，号隔开）&lt;/p&gt;

&lt;p&gt;date：“YYYY-MM-DD”&lt;/p&gt;
&lt;p&gt;time：“HH：MM：SS”&lt;/p&gt;
&lt;p&gt;datetime：“YYYY-MM-DD HH：MM：SS”&lt;/p&gt;
&lt;p&gt;timestamp：“YYYY-MM-DD HH：MM：SS”&lt;/p&gt;
&lt;p&gt;datetime：不给值默认返回Null&lt;/p&gt;
&lt;p&gt;timestamp：不给值默认返回系统时间&lt;/p&gt;

&lt;p&gt;时间函数&lt;/p&gt;
&lt;p&gt;now（）                                                          返回服务器当前的时间&lt;/p&gt;
&lt;p&gt;curdate（）                                                    返回当前时期&lt;/p&gt;
&lt;p&gt;curtime（）                                                    返回当前日期&lt;/p&gt;
&lt;p&gt;year（date）                                                  返回指定时间的年份&lt;/p&gt;
&lt;p&gt;date（date）                                                  返回指定时间的日期&lt;/p&gt;
&lt;p&gt;time（date）                                                  返回指定时间的时间&lt;/p&gt;

&lt;p&gt;聚合函数&lt;/p&gt;
&lt;p&gt;avg（字段名）：求该字段的平均值&lt;/p&gt;
&lt;p&gt;sum（字段名）：求和&lt;/p&gt;
&lt;p&gt;max（字段名）：最大值&lt;/p&gt;
&lt;p&gt;min（字段名）：最小值&lt;/p&gt;
&lt;p&gt;count（字段名）：统计该字段的个数&lt;/p&gt;


&lt;p&gt;运算符：+ - * / %&lt;/p&gt;

&lt;p&gt;时间运算符&lt;/p&gt;
&lt;p&gt;select * from 表名&lt;/p&gt;
&lt;p&gt;where 字段名 运算符（时间-interval 时间间隔单位）；&lt;/p&gt;
&lt;p&gt;时间间隔单位：1 day | 2hour | 1 minute | 2year | month&lt;/p&gt;

&lt;p&gt;数值比较： =  !=  &amp;gt;  &amp;gt;= &amp;lt; &amp;lt;=&lt;/p&gt;
&lt;p&gt;字符比较： =  !=&lt;/p&gt;
&lt;p&gt;逻辑比较： and   or&lt;/p&gt;
&lt;p&gt;范围内比较：&lt;/p&gt;
&lt;p&gt;      1.where 字段名 between 值1 and 值2&lt;/p&gt;
&lt;p&gt;      2.where 字段名 in（值1，值2，....）&lt;/p&gt;
&lt;p&gt;      3.where 字段名 not in （值1，值2，...）&lt;/p&gt;
&lt;p&gt;空：where name is null&lt;/p&gt;
&lt;p&gt;非空：where name is not null&lt;/p&gt;
&lt;p&gt;NILL：空值，只能用is或is not取匹配&lt;/p&gt;
&lt;p&gt;“” ： 空字符串，用 = 或  != 去匹配&lt;/p&gt;
&lt;p&gt;模糊比较：&lt;/p&gt;
&lt;p&gt;     where 字段名 like 表达式&lt;/p&gt;
&lt;p&gt;     表达式&lt;/p&gt;
&lt;p&gt;        _ : 匹配单个字符&lt;/p&gt;
&lt;p&gt;       %：匹配0到多个字符&lt;/p&gt;
&lt;p&gt;        NULL不会被统计&lt;/p&gt;

&lt;p&gt;排序：order by ASC | DESC&lt;/p&gt;
&lt;p&gt;显示： limit 开始显示位置，条数   &lt;/p&gt;
&lt;p&gt;     每页显示n条记录，显示第m页：&lt;/p&gt;
&lt;p&gt;     limit（m-1）*n，n&lt;/p&gt;


&lt;p&gt;                     &lt;strong&gt;&lt;span&gt;   MySQL 与 Python 交互&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;29&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# mysqlpython.py

# 导入mysql模块
from pymysql import *


class MysqlPython:
    def __init__(self, database,  # 库
                 host=&quot;127.0.0.1&quot;,  # ip地址
                 user=&quot;root&quot;,  # 用户名
                 password=&quot;123456&quot;,  # 密码
                 port=3306,  # 端口
                 charset=&quot;utf8&quot;):  # 字符集
        self.host = host
        self.database = database
        self.user = user
        self.password = password
        self.port = port
        self.charset = charset

    def open(self):  # 创建数据库链接函数
        self.db = connect(host=self.host,
                          database=self.database,
                          user=self.user,
                          password=self.password,
                          port=self.port,
                          charset=self.charset)
        self.cur = self.db.cursor()  # 创建游标对象

    def close(self):  # 创建断开数据库链接　关闭游标函数
        self.cur.close()
        self.db.close()

    def zhixing(self, sql, L=[]):  # 创建pymysql.execute() 方法函数
        try:
            self.open()  # 链接数据库
            self.cur.execute(sql, L)  # 参数化执行ＳＱＬ命令
            self.db.commit()  # 提交数据
            print(&quot;ok&quot;)
        except Exception as e:
            self.db.rollback()  # 出错取消提交
            print(&quot;Failed&quot;, e)
        self.close()  # 断开数据库链接　关闭游标

    def all(self, sql, L=[]):
        try:
            self.open()
            self.cur.execute(sql, L)
            result = self.cur.fetchall()
            return result
        except Exception as e:
            print(&quot;Failed&quot;, e)
        self.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;数据库用户登录&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;div readability=&quot;13&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mysqlpython import Mysqlpython
from hashlib import sha1

uname = input(&quot;请输入用户名:&quot;)
pwd = input(&quot;请输入密码:&quot;)
# 用sha1给pwd加密

s1 = sha1()  # 创建sha1加密对象
s1.update(pwd.encode(&quot;utf8&quot;))  # 指定编码
pwd2 = s1.hexdigest()  # 返回16进制加密结果

sqlh = Mysqlpython(&quot;db4&quot;)
select = &quot;select password from user where \
          username=%s;&quot;
result = sqlh.all(select, [uname])
# print(result)
# (('7c4a8d09ca3762af61e59520943dc26494f8941b',),)

if len(result) == 0:
    print(&quot;用户名不存在&quot;)
elif result[0][0] == pwd2:
    print(&quot;登录成功&quot;)
else:
    print(&quot;密码错误&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ORM  sqlalchemy框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 创建一张表

# 连接数据库的模块
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String

engine = create_engine(&quot;mysql+pymysql://root:123456@localhost/db4&quot;, encoding=&quot;utf8&quot;)
Base = declarative_base()  # orm基类

class User(Base):  # 继承Base基类
    __tablename__ = &quot;t123&quot;
    id = Column(Integer, primary_key=True)
    name = Column(String(20))
    address = Column(String(40))

Base.metadata.create_all(engine)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 04 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9420563.html</dc:identifier>
</item>
<item>
<title>在多线程中使用静态方法是否有线程安全问题 - 李志章</title>
<link>http://www.cnblogs.com/lizhizhang/p/9420403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizhizhang/p/9420403.html</guid>
<description>&lt;p&gt;　类的成员分为两类，静态成员（static member）和实例成员(instance member)。静态成员属于类，实例成员则属于对象，即类的实例。&lt;/p&gt;
&lt;p&gt;    简单讨论一下在一个类中使用静态字段(static field)和静态方法(static method)是否会有线程安全问题。 &lt;/p&gt;
&lt;p&gt;    我们在知道, 静态字段(static field)和静态方法(static method)的调用是通过类来调用。静态方法不对特定的实例操作，只能访问静态成员。实例方法可对特定的实例操作，既能访问静态成员，也能访问实例成员。&lt;/p&gt;
&lt;p&gt;    那么,在多线程中使用静态方法是否有线程安全问题?这要看静态方法是是引起线程安全问题要看在静态方法中是否使用了静态成员。&lt;/p&gt;&lt;p&gt;    因为，在多线程中使用同一个静态方法时，每个线程使用各自的实例字段(instance field)的副本，而共享一个静态字段(static field)。所以说，如果该静态方法不去操作一个静态成员，只在方法内部使用实例字段(instance field)，不会引起安全性问题。但是，如果该静态方法操作了一个静态字段，则需要静态方法中采用互斥访问的方式进行安全处理。&lt;br/&gt;    &lt;br/&gt;    举个简单的例子，我们使用的Console.WriteLine();中WriteLine()是Console.WriteLine类的静态方法。&lt;/p&gt;&lt;p&gt;     对于ASP.NET, 多个客户端访问服务器端, 这是一个多线程的例子.只要理解了原因,我们可以在三层架构中的数据访问层中放心使用静态方法(static method)来访问数据库.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;先看一个类:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String hello(String str)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        String tmp = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;        tmp = tmp +&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hello方法会不会有多线程安全问题呢？没有！&lt;/p&gt;
&lt;p&gt;静态方法如果没有使用静态变量，则没有线程安全问题。&lt;br/&gt;为什么呢？因为静态方法内声明的变量，每个线程调用时，都会新创建一份，而不会共用一个存储单元。比如这里的tmp,每个线程都会创建自己的一份，因此不会有线程安全问题。&lt;br/&gt;注意:静态变量，由于是在类加载时占用一个存储区，每个线程都是共用这个存储区的，所以如果在静态方法里使用了静态变量，这就会有线程安全问题！&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 14:20:00 +0000</pubDate>
<dc:creator>李志章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lizhizhang/p/9420403.html</dc:identifier>
</item>
<item>
<title>讲讲网络模块中加解密那点儿事--AES+BASE64 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9419877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9419877.html</guid>
<description>&lt;p&gt;这次想来讲讲网络安全通信这一块，也就是网络层封装的那一套加密、解密，编码、解码的规则，不会很深入，但会大概将这一整块的讲一讲。&lt;/p&gt;
&lt;p&gt;之所以想写这篇，是因为，最近被抽过去帮忙做一个 C++ 项目，在 Android 中，各种编解码、加解密算法官方都已经封装好了，我们要使用非常的方便，但在 C++ 项目中很多都要自己写。&lt;/p&gt;
&lt;p&gt;然而，自己写是不可能的了，没这么牛逼也没这么多时间去研究这些算法，网上自然不缺少别人写好的现成算法。但不同项目应用场景自然不一样，一般来说，都需要对其进行修修改改才能拿到项目中来用。&lt;/p&gt;
&lt;p&gt;踩的坑实在有点儿多，所以想写一篇来总结一下。好了，废话结束，开始正文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q1: 你的 app 与后台各接口通信时有做身份校验吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2: 你的 app 与后台各接口通信的数据有涉及敏感数据吗？你是如何处理的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3: MD5 了解过吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4: AES(16位密钥 + CBC + PKCS5Padding) 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q5: BASE64 呢？或者 UTF-8?&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;身份校验----md5-算法&quot;&gt;身份校验 -- MD5 算法&lt;/h3&gt;
&lt;p&gt;第一点：&lt;strong&gt;为什么需要身份校验？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份校验是做什么，其实也就是校验访问接口的用户合法性。说得白一点，也就是要过滤掉那些通过脚本或其他非正常 app 发起的访问请求。&lt;/p&gt;
&lt;p&gt;试想一下，如果有人破解了服务端某个接口，然后写个脚本，模拟接口所需的各种参数，这样它就可以伪装成正常用户从这个接口拿到他想要的数据了。&lt;/p&gt;
&lt;p&gt;更严重点的是，如果他想图摸不轨，向服务端发送了一堆伪造的数据，如果这些数据会对服务端造成损失怎么办。&lt;/p&gt;
&lt;p&gt;所以，基本上服务端的接口都会有身份校验机制，来检测访问的对象是否合法。&lt;/p&gt;
&lt;p&gt;第二点：&lt;strong&gt;MD5 算法是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗的讲，MD5 算法能对一串输入生成一串唯一的不可逆的 128 bit 的 0 和 1 的二进制串信息。&lt;/p&gt;
&lt;p&gt;通常 app 都会在发起请求前根据自己公司所定义的规则做一次 MD5 计算，作为 token 发送给服务端进行校验。&lt;/p&gt;
&lt;p&gt;MD5 有两个特性：唯一性和不可逆性。&lt;/p&gt;
&lt;p&gt;唯一性可以达到防止输入被篡改的目的，因为一旦第三方攻击者劫持了这个请求，篡改了携带的参数，那么服务端只要再次对这些输入做一次 MD5 运算，比较计算的结果与 app 上传的 token 即可检测出输入是否有被修改。&lt;/p&gt;
&lt;p&gt;不可逆的特点，则是就算第三方攻击者劫持了这次请求，看到了携带的参数，以及 MD5 计算后的 token，那么他也无法从这串 token 反推出我们计算 MD5 的规则，自然也就无法伪造新的 token，那么也就无法通过服务端的校验了。&lt;/p&gt;
&lt;p&gt;第三点：&lt;strong&gt;理解 16 位和 32 位 MD5 值的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网上有很多在线进行 MD5 计算的工具，如 &lt;a href=&quot;http://www.cmd5.com/&quot; class=&quot;uri&quot;&gt;http://www.cmd5.com/&lt;/a&gt;，这里演示一下，尝试一下分别输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;I am dasu&lt;/code&gt; 和 &lt;code&gt;I'm dasu&lt;/code&gt; 看一下经过 MD5 运算后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-66628f61bc02489e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MD5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-03059a86616e8391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MD5_.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先确认一点，不同的输入，输出就会不一样，即使只做了细微修改，两者输出仍旧毫无规律而言。&lt;/p&gt;
&lt;p&gt;另外，因为经过 MD5 计算后输出是 128 bit 的 0 和 1 二进制串，但通常都是用十六进制来表示比较友好，1个十六进制是 4 个 bit，128 / 4 = 32，所以常说的 32 位的 MD5 指的是用十六进制来表示的输出串。&lt;/p&gt;
&lt;p&gt;那么，为什么还会有 16 位的 MD5 值？其实也就是嫌 32 位的数据太长了，所以去掉开头 8 位，末尾 8 位，截取中间的 16 位来作为 MD5 的输出值。&lt;/p&gt;
&lt;p&gt;所以，MD5 算法的输出只有一种：128 bit 的二进制串，而通常结果都用十六进制表示而已，32 位与 16 位的只是精度的区别而已。&lt;/p&gt;
&lt;p&gt;第四点：&lt;strong&gt;MD5 的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景很多：数字签名、身份校验、完整性（一致性）校验等等。&lt;/p&gt;
&lt;p&gt;这里来讲讲 app 和服务端接口访问通过 MD5 来达到身份校验的场景。&lt;/p&gt;
&lt;p&gt;app 持有一串密钥，这串密钥服务端也持有，除此外别人都不知道，因此 app 就可以跟服务端协商，两边统一下交互的时候都有哪些数据是需要加入 MD5 计算的，以怎样的规则拼接进行 MD5 运算的，这样一旦这些数据被三方攻击者篡改了，也能检查出来。&lt;/p&gt;
&lt;p&gt;也就是说，密钥和拼接规则都是关键点，不可以泄漏出去。&lt;/p&gt;
&lt;h3 id=&quot;敏感数据加密----aes-base64&quot;&gt;敏感数据加密 -- AES + BASE64&lt;/h3&gt;
&lt;p&gt;MD5 只能达到校验的目的，而 app 与服务端交互时，数据都是在网络中传输的，这些请求如果被三方劫持了，那么如果交互的数据里有一些敏感信息，就会遭到泄漏，存在安全问题。&lt;/p&gt;
&lt;p&gt;当然，如果你的 app 与服务端的交互都是 HTTPS 协议了的话，那么自然就是安全的，别人抓不到包，也看不到信息。&lt;/p&gt;
&lt;p&gt;如果还是基于 HTTP 协议的话，那么有很多工具都可以劫持到这个 HTTP 包，app 与服务端交互的信息就这样赤裸裸的展示在别人面前。&lt;/p&gt;
&lt;p&gt;所以，通常一些敏感信息都会经过加密后再发送，接收方拿到数据后再进行解密即可。&lt;/p&gt;
&lt;p&gt;而加解密的世界很复杂，对称加密、非对称加密，每一种类型的加解密算法又有很多种，不展开了，因为实在展开不了，我门槛都没踏进去，实在没去深入学习过，目前只大概知道个流程原理，会用的程度。&lt;/p&gt;
&lt;p&gt;那么，本篇就介绍一种网上很常见的一整套加解密、编解码流程：&lt;/p&gt;
&lt;h4 id=&quot;utf-8-aes-base64&quot;&gt;UTF-8 + AES + BASE64&lt;/h4&gt;
&lt;p&gt;UTF-8 和 BASE64 都属于编解码，AES 属于对称加密算法。&lt;/p&gt;
&lt;p&gt;信息其实本质上是由二进制串组成，通过各种不同的编码格式，来将这段二进制串信息解析成具体的数据。比如 ASCII 编码定义了一套标准的英文、常见符号、数字的编码；UTF-8 则是支持中文的编码。目前大部分的 app 所使用的数据都是基于 UTF-8 格式的编码的吧。&lt;/p&gt;
&lt;p&gt;AES 属于对称加密算法，对称的意思是说，加密方和解密方用的是同一串密钥。信息经过加密后会变成一串毫无规律的二进制串，此时再选择一种编码方式来展示，通常是 BASE64 格式的编码。&lt;/p&gt;
&lt;p&gt;BASE64 编码是将所有信息都编码成只用大小写字母、0-9数字以及 + 和 / 64个字符表示，所有称作 BASE64。&lt;/p&gt;
&lt;p&gt;不同的编码所应用的场景不同，比如 UTF-8 倾向于在终端上呈现各种复杂字符包括简体、繁体中文、日文、韩文等等数据时所使用的一种编码格式。而 BASE64 编码通常用于在网络中传输较长的信息时所使用的一种编码格式。&lt;/p&gt;
&lt;p&gt;基于以上种种，目前较为常见的 app 与服务端交互的一套加解密、编解码流程就是：UTF-8 + AES + BASE64&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-e12adc004153766d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加解密流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是从 app 端发数据给服务端的一个加解密、编解码过程。&lt;/p&gt;
&lt;p&gt;需要注意的是，因为 AES 加解密时输入和输出都是二进制串的信息，因此，在发送时需先将明文通过 UTF-8 解码成二进制串，然后进行加密，再对这串二进制密文通过 BASE64 编码成密文串发送给接收方。&lt;/p&gt;
&lt;p&gt;接收方的流程就是反着来一遍就对了。&lt;/p&gt;

&lt;p&gt;理论上基本清楚了，那么接下去就是代码实现了，Android 项目中要实现很简单，因为 JDK 和 SDK 中都已经将这些算法封装好了，直接调用 api 接口就可以了。&lt;/p&gt;
&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EncryptDecryptUtils {
    private static final String ENCODE = &quot;UTF-8&quot;;
    //AES算法加解密模式有多种，这里选择 CBC + PKCS5Padding 模式，CBC 需要一个AES_IV偏移量参数，而AES_KEY 是密钥。当然，这里都是随便写的，这些信息很关键，不宜泄露
    private static final String AES = &quot;AES&quot;;
    private static final String AES_IV = &quot;aaaaaaaaaaaaaaaa&quot;;
    private static final String AES_KEY = &quot;1111111111111111&quot;;//16字节，128bit，三种密钥长度中的一种
    private static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;

    /**
    * AES加密后再Base64编码，输出密文。注意AES加密的输入是二进制串，所以需要先将UTF-8明文转成二进制串
    */
    public static String doEncryptEncode(String content) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes(ENCODE)));
        //1. 先获取二进制串，再进行AES（CBC+PKCS5Padding)模式加密
        byte[] result = cipher.doFinal(content.getBytes(ENCODE));
        //2. 将二进制串编码成BASE64串
        return Base64.encodeToString(result, Base64.NO_WRAP);
    }

    /**
    * Base64解码后再进行AES解密，最后对二进制明文串进行UTF-8编码输出明文串
    */
    public static String doDecodeDecrypt(String content) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes(ENCODE)));
        //1. 先将BASE64密文串解码成二进制串
        byte[] base64 = Base64.decode(content, Base64.NO_WRAP);
        //2. 再将二进制密文串进行AES(CBC+PKCS5Padding)模式解密
        byte[] result = cipher.doFinal(base64);
        //3. 最后将二进制的明文串以UTF-8格式编码成字符串后输出
        return new String(result, Charset.forName(ENCODE)); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 的实现代码是不是很简单，具体算法的实现都已经封装好了，就是调一调 api 的事。&lt;/p&gt;
&lt;p&gt;这里需要稍微知道下，AES 加解密模式分很多种，首先，它有三种密钥形式，分别是 128 bit，192 bit，256 bit，注意是 bit，Java 中的字符串每一位是 1B = 8 bit，所以上面例子中密钥长度是 16 位的字符串。&lt;/p&gt;
&lt;p&gt;除了密钥外，AES 还分四种模式的加解密算法：ECB，CBC，CFB，OFB，这涉及到具体算法，我也不懂，就不介绍了，清楚上面是使用了 CBC 模式就可以了。&lt;/p&gt;
&lt;p&gt;最后一点，使用 CBC 模式进行加密时，是对明文串进行分组加密的，每组的大小都一样，因此在分组时就有可能会存在最后一组的数量不够的情况，那么这时就需要进行填充，而这个填充的概念就是 PKCS5Padding 和 PKCS7Padding 两种。&lt;/p&gt;
&lt;p&gt;这两种的填充规则都一样，具体可看其他的文章，区别只在于分组时规定的每组的大小。在PKCS5Padding中，明确定义 Block 的大小是 8 位，而在 PKCS7Padding 定义中，对于块的大小是不确定的，可以在 1-255 之间。&lt;/p&gt;
&lt;p&gt;稍微了解下这些就够了，如果你不继续往下研究 C++ 的写法，这些不了解也没事，会用就行。&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C++&lt;/h3&gt;
&lt;p&gt;c++ 坑爹的地方就在于，这整个流程，包括 UTF-8 编解码、AES 加解密、BASE64 编解码都得自己写。&lt;/p&gt;
&lt;p&gt;当然，不可能自己写了，网上轮子那么多了，但问题就在于，因为 AES 加解密模式太多了，网上的资料大部分都只是针对其中一种进行介绍，因此，如果不稍微了解一下相关原理的话，就无从下手进行修改了。&lt;/p&gt;
&lt;p&gt;我这篇，自然也只是介绍我所使用的模式，如果你刚好跟我一样，那也许可以帮到你，如果跟你不一样，至少我列出了资料的来源，整篇下来也稍微讲了一些基础性的原理，掌握这些，做点儿修修补补应该是可以的。&lt;/p&gt;
&lt;p&gt;贴代码前，先将我所使用的模式列出来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8 + AES(16位密钥 + CBC + PKCS5Padding) + BASE64&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实这些都类似于工具类，官方库没提供，那网上找个轮子就好了，都是一个 h 和 cpp 文件而已，复制粘贴下就可以了。重点在于准备好了这些工具类后，怎么用，怎么稍微修改。&lt;/p&gt;
&lt;p&gt;如果你不想自己网上找，那下面我已经将相关链接都贴出来了，去复制粘贴下就可以了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yinshi_blog/article/details/6731809&quot;&gt;c++ string、UTF8相互转换方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/csdn49532/article/details/50686222&quot;&gt;C++使用AES+Base64算法对文本进行加密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我最开始就是拿的第二篇来用的，然后才发现他所采用的模式是：AES(16位密钥 + CBC + PKCS7Padding) + BASE64&lt;/p&gt;
&lt;p&gt;也就是说，他的例子中不支持中文的加解密，而且填充模式采用的是 PKCS7Padding，跟我的不一致。一开始我也不了解相关原理基础，怎么调都调不出结果，无奈只能先去学习下原理基础。&lt;/p&gt;
&lt;p&gt;还好后面慢慢的理解了，也懂得该改哪些地方，也增加了 UTF-8 编解码的处理。下面贴的代码中注释会写得很清楚，整篇看下来，我相信，就算你模式跟我的也不一样，你的密钥是24位的、32位的，没关系，稍微改一改就可以了。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//EncryptDecryptUtils.h
#pragma once
#include &amp;lt;string&amp;gt;

using namespace std;

#ifndef AES_INFO
#define AES_INFO

#define AES_KEY &quot;1111111111111111&quot;  //AES 16B的密钥
#define AES_IV &quot;aaaaaaaaaaaaaaaa&quot; //AES CBC加解密模式所需的偏移量

#endif 

class EncryptDecryptUtils {
public:
    //解码解密
    static string doDecodeDecrypt(string content);
    //加密编码
    static string doEncryptEncode(string content);
    EncryptDecryptUtils();
    ~EncryptDecryptUtils();
private:
    //去除字符串中的空格、换行符
    static string removeSpace(string content);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下才是具体实现，其中在头部 include 的 AES.h，Base64.h，UTF8.h 需要先从上面给的博客链接中将相关代码复制粘贴过来。这些文件基本都是作为工具类使用，不需要进行改动。可能需要稍微改一改的就只是 AES.h 文件，因为不同的填充模式需要改一个常量值。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//EncryptDecryptUtils.cpp
#include &quot;EncryptDecryptUtils.h&quot;
#include &quot;AES.h&quot;
#include &quot;Base64.h&quot;
#include &quot;UTF8.h&quot;

EncryptDecryptUtils::EncryptDecryptUtils()
{
}
~EncryptDecryptUtils::EncryptDecryptUtils()
{
}

/**
* 流程：服务端下发的BASE64编码的密文字符串 -&amp;gt; 去除字符串中的换行符 -&amp;gt; BASE64解码 -&amp;gt; AES::CBC模式解密 -&amp;gt; 去掉AES::PKCS5Padding 填充 -&amp;gt; UTF-8编码 -&amp;gt; 明文字符串
*/
string EncryptDecryptUtils::doDecodeDecrypt(string content)
{   
    //1.去掉字符串中的\r\n换行符
    string noWrapContent = removeSpace(string);
    //2. Base64解码
    string strData = base64_decode(noWrapContent);
    size_t length = strData.length();

    //3. new些数组，给解密用
    char *szDataIn = new char[length + 1];
    memcpy(szDataIn, strData.c_str(), length + 1);
    char *szDataOut = new char[length + 1];
    memcpy(szDataOut, strData.c_str(), length + 1);

    //4. 进行AES的CBC模式解密
    AES aes;
    //在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。
    aes.MakeKey(string(AES_KEY).c_str(), string(AES_IV).c_str(), 16, 16);
    //这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明
    aes.Decrypt(szDataIn, szDataOut, length, AES::CBC);

    //5.去PKCS5Padding填充:解密后需要将字符串中填充的去掉，根据填充规则进行去除，感兴趣可去搜索相关的填充规则
    if (0x00 &amp;lt; szDataOut[length - 1] &amp;lt;= 0x16)
    {
        int tmp = szDataOut[length - 1];
        for (int i = length - 1; i &amp;gt;= length - tmp; i--)
        {
            if (szDataOut[i] != tmp)
            {
                memset(szDataOut, 0, length);
                break;
            }
            else
                szDataOut[i] = 0;
        }
    }

    //6. 将二进制的明文串转成UTF-8格式的编码方式，输出
    string srcDest = UTF8_To_string(szDataOut);
    delete[] szDataIn;
    delete[] szDataOut;
    return srcDest;
}

/**
* 流程：UTF-8格式的明文字符串 -&amp;gt; UTF-8解码成二进制串 -&amp;gt; AES::PKCS5Padding 填充 -&amp;gt; AES::CBC模式加密 -&amp;gt; BASE64编码 -&amp;gt; 密文字符串
*/
string EncryptDecryptUtils::doEncryptEncode(string content)
{
    //1. 先获取UTF-8解码后的二进制串
    string utf8Content = string_To_UTF8(content);
    size_t length = utf8Content.length();
    int block_num = length / BLOCK_SIZE + 1;
    
    //2. new 些数组供加解密使用
    char* szDataIn = new char[block_num * BLOCK_SIZE + 1];
    memset(szDataIn, 0x00, block_num * BLOCK_SIZE + 1);
    strcpy(szDataIn, utf8Content.c_str());

    //3. 进行PKCS5Padding填充：进行CBC模式加密前，需要填充明文串，确保可以分组后各组都有相同的大小。
    // BLOCK_SIZE是在AES.h中定义的常量，PKCS5Padding 和 PKCS7Padding 的区别就是这个 BLOCK_SIZE 的大小，我用的PKCS5Padding，所以定义成 8。如果你是使用 PKCS7Padding，那么就根据你服务端具体大小是在 1-255中的哪个值修改即可。
    int k = length % BLOCK_SIZE;
    int j = length / BLOCK_SIZE;
    int padding = BLOCK_SIZE - k;
    for (int i = 0; i &amp;lt; padding; i++)
    {
        szDataIn[j * BLOCK_SIZE + k + i] = padding;
    }
    szDataIn[block_num * BLOCK_SIZE] = '\0';

    char *szDataOut = new char[block_num * BLOCK_SIZE + 1];
    memset(szDataOut, 0, block_num * BLOCK_SIZE + 1);

    //4. 进行AES的CBC模式加密
    AES aes;
     //在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。
    aes.MakeKey(string(AES_KEY).c_str(), string(AES_IV).c_str(), 16, 16);
    //这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明
    aes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);
    
    //5. Base64编码
    string str = base64_encode((unsigned char*)szDataOut, block_num * BLOCK_SIZE);
    delete[] szDataIn;
    delete[] szDataOut;
    return str;
}

//去除字符串中的空格、换行符
string EncryptDecryptUtils::formatText(string src)
{
    int len = src.length();
    char *dst = new char[len + 1];
    int i = -1, j = 0;
    while (src[++i])
    {
        switch (src[i])
        {
        case '\n':
        case '\t':
        case '\r':
            continue;
        }
        dst[j++] = src[i];
    }
    dst[j] = '\0';
    string rel = string(dst);
    delete dst;
    return rel;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再列个在线验证 AES 加解密结果的网站，方便调试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.seacha.com/tools/aes.html&quot; class=&quot;uri&quot;&gt;http://www.seacha.com/tools/aes.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 实现那么方便，为什么还需要用 C++ 的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想一想，密钥信息那么重要，你要放在哪？像我例子那样直接写在代码中？那只是个例子，别忘了，app 混淆的时候，字符串都是不会参与混淆的，随便反编译下你的 app，密钥就暴露给别人了。&lt;/p&gt;
&lt;p&gt;那么，有其他比较好的方式吗？我只能想到，AES 加解密相关的用 C++ 来写，生成个 so 库，提供个 jni 接口给 app 层调用，这样密钥信息就可以保存在 C++ 中了。&lt;/p&gt;
&lt;p&gt;也许你会觉得，哪有人那么闲去反编译 app，而且正在写的 app 又没有什么价值让别人反编译。&lt;/p&gt;
&lt;p&gt;emmm，说是这么说，但安全意识还是要有的，至少也要先知道有这么个防护的方法，以及该怎么做，万一哪天你写的 app 就火了呢？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 12:50:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9419877.html</dc:identifier>
</item>
<item>
<title>Java基础面试题总结 - AntzUhl</title>
<link>http://www.cnblogs.com/LexMoon/p/javams.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/javams.html</guid>
<description>&lt;h2 id=&quot;面向对象和面向过程的区别&quot;&gt;&lt;span&gt;面向对象和面向过程的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;面向过程：&lt;/strong&gt;&lt;br/&gt;　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。&lt;br/&gt;缺点：没有面向对象易维护、易复用、易扩展&lt;br/&gt;&lt;strong&gt;面向对象：&lt;/strong&gt;&lt;br/&gt;　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护&lt;br/&gt;缺点：性能比面向过程低&lt;/p&gt;
&lt;h2 id=&quot;java语言有哪些特点&quot;&gt;&lt;span&gt;Java语言有哪些特点？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；&lt;/p&gt;
&lt;h2 id=&quot;什么是字节码采用字节码的最大好处是什么什么java是虚拟机&quot;&gt;&lt;span&gt;什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先看下java中的编译器和解释器：&lt;/strong&gt;&lt;br/&gt;　　Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。&lt;br/&gt;Java源代码----&amp;gt;编译器----&amp;gt;jvm可执行的Java字节码(即虚拟指令)----&amp;gt;jvm----&amp;gt;jvm中解释器-----&amp;gt;机器可执行的二进制机器码----&amp;gt;程序运行。&lt;br/&gt;&lt;strong&gt;采用字节码的好处：&lt;/strong&gt;&lt;br/&gt;　　Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。&lt;/p&gt;
&lt;h2 id=&quot;什么是java虚拟机&quot;&gt;&lt;span&gt;什么是Java虚拟机&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）&lt;/p&gt;
&lt;h2 id=&quot;什么是java程序的主类应用程序和小程序的主类有何不同&quot;&gt;&lt;span&gt;什么是Java程序的主类？应用程序和小程序的主类有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。&lt;/p&gt;
&lt;h2 id=&quot;什么是jdk什么是jre&quot;&gt;&lt;span&gt;什么是JDK?什么是JRE？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/11/8/9cf7f48fdbe608ae70080aa6c5a2f910?w=680&amp;amp;h=278&amp;amp;f=png&amp;amp;s=-1&quot; alt=&quot;JDK&quot;/&gt;&lt;br/&gt;　　JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。&lt;/p&gt;
&lt;h2 id=&quot;环境变量path和classpath的作用是什么如何设置这两个环境变量&quot;&gt;&lt;span&gt;环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Java环境变量PATH和CLASSPATH - 简书 http://www.jianshu.com/p/d63b099cf283&lt;/p&gt;
&lt;h2 id=&quot;java应用程序与小程序之间有那些差别&quot;&gt;&lt;span&gt;Java应用程序与小程序之间有那些差别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。&lt;/p&gt;
&lt;h2 id=&quot;字符型常量和字符串常量的区别&quot;&gt;&lt;span&gt;字符型常量和字符串常量的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1) 形式上:&lt;br/&gt;字符常量是单引号引起的一个字符&lt;br/&gt;字符串常量是双引号引起的若干个字符&lt;br/&gt;2) 含义上:&lt;br/&gt;字符常量相当于一个整形值(ASCII值),可以参加表达式运算&lt;br/&gt;字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;br/&gt;3) 占内存大小&lt;br/&gt;字符常量只占一个字节&lt;br/&gt;字符串常量占若干个字节(至少一个字符结束标志)&lt;/p&gt;
&lt;h2 id=&quot;java语言采用何种编码方案有何特点&quot;&gt;&lt;span&gt;Java语言采用何种编码方案？有何特点？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。&lt;/p&gt;
&lt;h2 id=&quot;构造器constructor是否可被override&quot;&gt;&lt;span&gt;构造器Constructor是否可被override&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;
&lt;h2 id=&quot;重载和重写的区别&quot;&gt;&lt;span&gt;重载和重写的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。&lt;br/&gt;　　重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。&lt;/p&gt;
&lt;h2 id=&quot;java-面向对象编程三大特性------封装继承多态&quot;&gt;&lt;span&gt;java 面向对象编程三大特性------封装、继承、多态&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jianyuerensheng/article/details/51602015&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/jianyuerensheng/article/details/51602015&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;string和stringbufferstringbuilder的区别是什么string为什么是不可变的&quot;&gt;&lt;span&gt;String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;br/&gt;　&lt;/p&gt;
&lt;p&gt;String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;br/&gt;&lt;strong&gt;对于三者使用的总结：&lt;/strong&gt;&lt;br/&gt;如果要操作少量的数据用 = String&lt;br/&gt;单线程操作字符串缓冲区 下操作大量数据 = StringBuilder&lt;br/&gt;多线程操作字符串缓冲区 下操作大量数据 = StringBuffer&lt;/p&gt;
&lt;h2 id=&quot;自动装箱与拆箱&quot;&gt;&lt;span&gt;自动装箱与拆箱&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;装箱&lt;/strong&gt;：将基本类型用它们对应的引用类型包装起来；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：将包装类型转换为基本数据类型；&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。&lt;/p&gt;
&lt;h2 id=&quot;类方法成员变量和局部变量的可用修饰符--&quot;&gt;&lt;span&gt;类、方法、成员变量和局部变量的可用修饰符 -&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yttcjj/article/details/6939239&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/yttcjj/article/details/6939239&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;在一个静态方法内调用一个非静态成员为什么是非法的&quot;&gt;&lt;span&gt;在一个静态方法内调用一个非静态成员为什么是非法的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。&lt;/p&gt;
&lt;h2 id=&quot;在java中定义一个不做事且没有参数的构造方法的作用&quot;&gt;&lt;span&gt;在Java中定义一个不做事且没有参数的构造方法的作用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。&lt;/p&gt;
&lt;h2 id=&quot;import-java和javax有什么区别&quot;&gt;&lt;span&gt;import java和javax有什么区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/EasonJim/p/6993139.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/EasonJim/p/6993139.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;接口和抽象类的区别是什么&quot;&gt;&lt;span&gt;接口和抽象类的区别是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法&lt;br/&gt;2.接口中的实例变量默认是final类型的，而抽象类中则不一定&lt;br/&gt;3.一个类可以实现多个接口，但最多只能实现一个抽象类&lt;br/&gt;4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定&lt;br/&gt;5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象&lt;br/&gt;从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。&lt;/p&gt;
&lt;h2 id=&quot;成员变量与局部变量的区别有那些&quot;&gt;&lt;span&gt;成员变量与局部变量的区别有那些？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；&lt;/li&gt;
&lt;li&gt;从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存&lt;/li&gt;
&lt;li&gt;从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。&lt;/li&gt;
&lt;li&gt;成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;创建一个对象用什么运算符对象实体与对象引用有何不同&quot;&gt;&lt;span&gt;创建一个对象用什么运算符？对象实体与对象引用有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）&lt;/p&gt;
&lt;h2 id=&quot;什么是方法的返回值返回值在类的方法里的作用是什么&quot;&gt;&lt;span&gt;什么是方法的返回值？返回值在类的方法里的作用是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！&lt;/p&gt;
&lt;h2 id=&quot;一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么&quot;&gt;&lt;span&gt;一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。&lt;/p&gt;
&lt;h2 id=&quot;构造方法有哪些特性&quot;&gt;&lt;span&gt;构造方法有哪些特性？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　1，名字与类名相同；2，没有返回值，但不能用void声明构造函数；3，生成类的对象时自动执行，无需调用。&lt;/p&gt;
&lt;h2 id=&quot;静态方法和实例方法有何不同&quot;&gt;&lt;span&gt;静态方法和实例方法有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;静态方法和实例方法的区别主要体现在两个方面：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;对象的相等与指向他们的引用相等两者有什么不同&quot;&gt;&lt;span&gt;对象的相等与指向他们的引用相等，两者有什么不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。&lt;/p&gt;
&lt;h2 id=&quot;在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是&quot;&gt;&lt;span&gt;在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　帮助子类做初始化工作。&lt;/p&gt;
&lt;h2 id=&quot;什么是多态机制java语言是如何实现多态的&quot;&gt;&lt;span&gt;什么是多态机制？Java语言是如何实现多态的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bornlili/article/details/55213563&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/bornlili/article/details/55213563&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;equals-和-的区别&quot;&gt;&lt;span&gt;equals 和 == 的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通俗点讲：==是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，==：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。&lt;/p&gt;
&lt;p&gt;术语来讲的区别：1.==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同&lt;br/&gt;2.==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同&lt;/p&gt;
&lt;h2 id=&quot;创建线程有几种不同的方式你喜欢哪一种为什么&quot;&gt;&lt;span&gt;创建线程有几种不同的方式？你喜欢哪一种？为什么？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;实现Runnable接口&lt;/li&gt;
&lt;li&gt;应用程序可以使用Executor框架来创建线程池&lt;/li&gt;
&lt;li&gt;实现Callable接口。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我更喜欢实现Runnable接口这种方法，当然这也是现在大多程序员会选用的方法。因为一个类只能继承一个父类而可以实现多个接口。同时，线程池也是非常高效的，很容易实现和使用。&lt;/p&gt;
&lt;h2 id=&quot;简述线程程序进程的基本概念以及他们之间关系是什么参考书籍java程序设计基础第五版&quot;&gt;&lt;span&gt;简述线程，程序、进程的基本概念。以及他们之间关系是什么？（参考书籍：《Java程序设计基础》第五版）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。&lt;br/&gt;线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。&lt;/p&gt;
&lt;h2 id=&quot;什么是多线程为什么程序的多线程功能是必要的&quot;&gt;&lt;span&gt;什么是多线程？为什么程序的多线程功能是必要的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;多线程就是几乎同时执行多个线程（一个处理器在某一个时间点上永远都只能是一个线程！即使这个处理器是多核的，除非有多个处理器才能实现多个线程同时运行。）。几乎同时是因为实际上多线程程序中的多个线程实际上是一个线程执行一会然后其他的线程再执行，并不是很多书籍所谓的同时执行。这样可以带来以下的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用线程可以把占据长时间的程序中的任务放到后台去处理&lt;/li&gt;
&lt;li&gt;用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度&lt;/li&gt;
&lt;li&gt;程序的运行速度可能加快&lt;/li&gt;
&lt;li&gt;在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。&lt;br/&gt;还有其他很多使用多线程的好处，这里就不一一说明了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;多线程与多任务的差异是什么参考书籍java程序设计基础第五版&quot;&gt;&lt;span&gt;多线程与多任务的差异是什么？（参考书籍：《Java程序设计基础》第五版）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;多任务与多线程是两个不同的概念，&lt;br/&gt;多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序。&lt;br/&gt;而多线程是针对一个进程而言的，表示在一个进程内部可以几乎同时执行多个线程&lt;/p&gt;
&lt;h2 id=&quot;线程有哪些基本状态这些状态是如何定义的&quot;&gt;&lt;span&gt;线程有哪些基本状态？这些状态是如何定义的?&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;新建(new)&lt;/strong&gt;：新创建了一个线程对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可运行(runnable)&lt;/strong&gt;：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行(running)&lt;/strong&gt;：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞(block)&lt;/strong&gt;：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：&lt;br/&gt;(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。&lt;br/&gt;(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。&lt;br/&gt;(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死亡(dead)&lt;/strong&gt;：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/15/16059cc91ee8efb3?w=876&amp;amp;h=492&amp;amp;f=png&amp;amp;s=-1&quot; alt=&quot;线程的基本状态&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;br/&gt;可以用早起坐地铁来比喻这个过程：&lt;br/&gt;还没起床：sleeping&lt;br/&gt;起床收拾好了，随时可以坐地铁出发：Runnable&lt;br/&gt;等地铁来：Waiting&lt;br/&gt;地铁来了，但要排队上地铁：I/O阻塞&lt;br/&gt;上了地铁，发现暂时没座位：synchronized阻塞&lt;br/&gt;地铁上找到座位：Running&lt;br/&gt;到达目的地：Dead&lt;/p&gt;
&lt;h2 id=&quot;什么是线程的同步程序中为什么要实现线程的同步是如何实现同步的&quot;&gt;&lt;span&gt;什么是线程的同步？程序中为什么要实现线程的同步？是如何实现同步的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。&lt;br/&gt;在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。&lt;/p&gt;
&lt;h2 id=&quot;在监视器monitor内部是如何做线程同步的程序应该做哪种级别的同步&quot;&gt;&lt;span&gt;在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.&lt;br/&gt;一旦方法或者代码块被 &lt;strong&gt;synchronized&lt;/strong&gt; 修饰, 那么这个部分就放入了监视器的监视区域, &lt;strong&gt;确保一次只能有一个线程执行该部分的代码&lt;/strong&gt;, 线程在获取锁之前不允许执行该部分的代码&lt;br/&gt;另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案&lt;/p&gt;
&lt;h2 id=&quot;什么是死锁deadlock&quot;&gt;&lt;span&gt;什么是死锁(deadlock)？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.so.com/doc/6950313-7172714.html&quot;&gt;360百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;死锁 :是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去 。&lt;br/&gt;产生原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为系统资源不足。&lt;/li&gt;
&lt;li&gt;进程运行推进顺序不合适。&lt;/li&gt;
&lt;li&gt;资源分配不当等。&lt;/li&gt;
&lt;li&gt;占用资源的程序崩溃等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。&lt;/p&gt;
&lt;p&gt;下面四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要下列条件之一不满足，就不会发生死锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互斥条件：一个资源每次只能被一个进程使用。&lt;/li&gt;
&lt;li&gt;请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。&lt;/li&gt;
&lt;li&gt;循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;br/&gt;死锁的解除与预防：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。&lt;/p&gt;
&lt;h2 id=&quot;如何确保n个线程可以访问n个资源同时又不导致死锁&quot;&gt;&lt;span&gt;如何确保N个线程可以访问N个资源同时又不导致死锁？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面一题我们知道了发生死锁的四个必要条件。我们只要使其中一个不成立就行了。一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。这也就是破坏了第四个条件循环等待条件。&lt;/p&gt;
&lt;h2 id=&quot;java中垃圾回收有什么目的什么时候进行垃圾回收&quot;&gt;&lt;span&gt;Java中垃圾回收有什么目的？什么时候进行垃圾回收？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。&lt;/p&gt;
&lt;p&gt;垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。&lt;/p&gt;
&lt;h2 id=&quot;finalize方法什么时候被调用析构函数finalization的目的是什么&quot;&gt;&lt;span&gt;finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1）垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；&lt;br/&gt;finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { }&lt;br/&gt;在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间&lt;/p&gt;
&lt;p&gt;2）GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。&lt;/p&gt;
&lt;h2 id=&quot;如果对象的引用被置为null垃圾收集器是否会立即释放对象占用的内存&quot;&gt;&lt;span&gt;如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;不会，在下一个垃圾回收周期中，这个对象将是可被回收的。&lt;/p&gt;

&lt;h2 id=&quot;servlet总结&quot;&gt;&lt;span&gt;Servlet总结&lt;/span&gt;：&lt;/h2&gt;
&lt;p&gt;在Java Web程序中，&lt;strong&gt;Servlet&lt;/strong&gt;主要负责接收用户请求&lt;strong&gt;HttpServletRequest&lt;/strong&gt;,在&lt;strong&gt;doGet()&lt;/strong&gt;,&lt;strong&gt;doPost()&lt;/strong&gt;中做相应的处理，并将回应&lt;strong&gt;HttpServletResponse&lt;/strong&gt;反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用&lt;strong&gt;init()方法&lt;/strong&gt;，销毁时调用&lt;strong&gt;destroy()方法&lt;/strong&gt;。&lt;strong&gt;Servlet需要在web.xml中配置&lt;/strong&gt;（MyEclipse中创建Servlet会自动配置），&lt;strong&gt;一个Servlet可以设置多个URL访问&lt;/strong&gt;。&lt;strong&gt;Servlet不是线程安全&lt;/strong&gt;，因此要谨慎使用类变量。&lt;/p&gt;
&lt;h2 id=&quot;阐述servlet和cgi的区别&quot;&gt;&lt;span&gt;阐述Servlet和CGI的区别?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CGI的不足之处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。&lt;/p&gt;
&lt;p&gt;2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销&lt;/p&gt;
&lt;p&gt;3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销&lt;/p&gt;
&lt;p&gt;2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销&lt;/p&gt;
&lt;p&gt;3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。&lt;/p&gt;
&lt;p&gt;4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。&lt;/p&gt;
&lt;p&gt;补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P7&lt;/p&gt;
&lt;h2 id=&quot;servlet接口中有哪些方法及servlet生命周期探秘&quot;&gt;&lt;span&gt;Servlet接口中有哪些方法及Servlet生命周期探秘&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Servlet接口定义了5个方法，其中&lt;strong&gt;前三个方法与Servlet生命周期相关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;void init(ServletConfig config) throws ServletException&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void destory()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;java.lang.String getServletInfo()&lt;/li&gt;
&lt;li&gt;ServletConfig getServletConfig()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;生命周期：&lt;/strong&gt; &lt;strong&gt;Web容器加载Servlet并将其实例化后，Servlet生命周期开始&lt;/strong&gt;，容器运行其&lt;strong&gt;init()方法&lt;/strong&gt;进行Servlet的初始化；请求到达时调用Servlet的&lt;strong&gt;service()方法&lt;/strong&gt;，service()方法会根据需要调用与请求对应的&lt;strong&gt;doGet或doPost&lt;/strong&gt;等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的&lt;strong&gt;destroy()方法&lt;/strong&gt;。&lt;strong&gt;init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行&lt;/strong&gt;。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P81&lt;/p&gt;
&lt;h2 id=&quot;get和post请求的区别&quot;&gt;&lt;span&gt;get和post请求的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；&lt;/p&gt;
&lt;p&gt;②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用&quot;?&quot;连接，而各个变量之间使用&quot;&amp;amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；&lt;/p&gt;
&lt;p&gt;③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；&lt;/p&gt;
&lt;p&gt;④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；&lt;/p&gt;
&lt;p&gt;⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是&quot;%20&quot;。&lt;/p&gt;
&lt;p&gt;补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。&lt;/p&gt;
&lt;h2 id=&quot;什么情况下调用doget和dopost&quot;&gt;&lt;span&gt;什么情况下调用doGet()和doPost()?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。&lt;/p&gt;
&lt;h2 id=&quot;转发forward和重定向redirect的区别&quot;&gt;&lt;span&gt;转发（Forward）和重定向（Redirect）的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转发是服务器行为，重定向是客户端行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转发（Forword）&lt;/strong&gt;&lt;br/&gt;通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重定向（Redirect）&lt;/strong&gt; 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从地址栏显示来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.&lt;br/&gt;redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从数据共享来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:转发页面和转发到的页面可以共享request里面的数据.&lt;br/&gt;redirect:不能共享数据.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从运用地方来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:一般用于用户登陆的时候,根据角色转发到相应的模块.&lt;br/&gt;redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从效率来说&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:高.&lt;br/&gt;redirect:低.&lt;/p&gt;
&lt;h2 id=&quot;自动刷新refresh&quot;&gt;&lt;span&gt;自动刷新（Refresh）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Response.setHeader(&quot;Refresh&quot;,&quot;1000;URL=http://localhost:8080/servlet/example.htm&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）&lt;/p&gt;
&lt;h2 id=&quot;servlet与线程安全&quot;&gt;&lt;span&gt;Servlet与线程安全&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。&lt;/strong&gt; 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。&lt;br/&gt;注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P92&lt;/p&gt;
&lt;h2 id=&quot;jsp和servlet是什么关系&quot;&gt;&lt;span&gt;JSP和Servlet是什么关系？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。&lt;/p&gt;
&lt;h2 id=&quot;jsp工作原理&quot;&gt;&lt;span&gt;JSP工作原理：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。&lt;br/&gt;工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。&lt;br/&gt;.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/31/1627bee073079a28?w=675&amp;amp;h=292&amp;amp;f=jpeg&amp;amp;s=133553&quot; alt=&quot;JSP工作原理&quot;/&gt;&lt;br/&gt;由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。&lt;/p&gt;
&lt;p&gt;开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P97&lt;/p&gt;
&lt;h2 id=&quot;jsp有哪些内置对象作用分别是什么&quot;&gt;&lt;span&gt;JSP有哪些内置对象？作用分别是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_34337272/article/details/64310849&quot;&gt;JSP内置对象 - CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JSP有9个内置对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request：封装客户端的请求，其中包含来自GET或POST请求的参数；&lt;/li&gt;
&lt;li&gt;response：封装服务器对客户端的响应；&lt;/li&gt;
&lt;li&gt;pageContext：通过该对象可以获取其他对象；&lt;/li&gt;
&lt;li&gt;session：封装用户会话的对象；&lt;/li&gt;
&lt;li&gt;application：封装服务器运行环境的对象；&lt;/li&gt;
&lt;li&gt;out：输出服务器响应的输出流对象；&lt;/li&gt;
&lt;li&gt;config：Web应用的配置对象；&lt;/li&gt;
&lt;li&gt;page：JSP页面本身（相当于Java程序中的this）；&lt;/li&gt;
&lt;li&gt;exception：封装页面抛出异常的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;request对象的主要方法有哪些&quot;&gt;&lt;span&gt;Request对象的主要方法有哪些？&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;setAttribute(String name,Object)：设置名字为name的request 的参数值&lt;/li&gt;
&lt;li&gt;getAttribute(String name)：返回由name指定的属性值&lt;/li&gt;
&lt;li&gt;getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组&lt;/li&gt;
&lt;li&gt;getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度&lt;/li&gt;
&lt;li&gt;getHeader(String name) ：获得HTTP协议定义的文件头信息&lt;/li&gt;
&lt;li&gt;getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getInputStream() ：返回请求的输入流，用于获得请求中的数据&lt;/li&gt;
&lt;li&gt;getMethod() ：获得客户端向服务器端传送数据的方法&lt;/li&gt;
&lt;li&gt;getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值&lt;/li&gt;
&lt;li&gt;getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getParameterValues(String name)：获得有name指定的参数的所有值&lt;/li&gt;
&lt;li&gt;getProtocol()：获取客户端向服务器端传送数据所依据的协议名称&lt;/li&gt;
&lt;li&gt;getQueryString() ：获得查询字符串&lt;/li&gt;
&lt;li&gt;getRequestURI() ：获取发出请求字符串的客户端地址&lt;/li&gt;
&lt;li&gt;getRemoteAddr()：获取客户端的 IP 地址&lt;/li&gt;
&lt;li&gt;getRemoteHost() ：获取客户端的名字&lt;/li&gt;
&lt;li&gt;getSession([Boolean create]) ：返回和请求相关 Session&lt;/li&gt;
&lt;li&gt;getServerName() ：获取服务器的名字&lt;/li&gt;
&lt;li&gt;getServletPath()：获取客户端所请求的脚本文件的路径&lt;/li&gt;
&lt;li&gt;getServerPort()：获取服务器的端口号&lt;/li&gt;
&lt;li&gt;removeAttribute(String name)：删除请求中的一个属性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;request.getattribute和-request.getparameter有何区别&quot;&gt;&lt;span&gt;request.getAttribute()和 request.getParameter()有何区别?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;从获取方向来看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter()是获取 POST/GET 传递的参数值；&lt;/p&gt;
&lt;p&gt;getAttribute()是获取对象容器中的数据值；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从用途来看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。&lt;/p&gt;
&lt;p&gt;getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了&lt;br/&gt;mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。&lt;/p&gt;
&lt;p&gt;另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。&lt;br/&gt;setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）&lt;/p&gt;
&lt;p&gt;getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用&lt;/p&gt;
&lt;h2 id=&quot;include指令include的行为的区别&quot;&gt;&lt;span&gt;include指令include的行为的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;include指令：&lt;/strong&gt; JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：&lt;br/&gt;&amp;lt;%@ include file=&quot;文件相对 url 地址&quot; %&amp;gt;&lt;/p&gt;
&lt;p&gt;i&lt;strong&gt;nclude动作：&lt;/strong&gt; 动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jsp九大内置对象七大动作三大指令-&quot;&gt;&lt;span&gt;JSP九大内置对象，七大动作，三大指令-&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_34337272/article/details/64310849&quot;&gt;JSP九大内置对象，七大动作，三大指令总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;讲解jsp中的四种作用域&quot;&gt;&lt;span&gt;讲解JSP中的四种作用域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JSP中的四种作用域包括page、request、session和application，具体来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;page&lt;/strong&gt;代表与一个页面相关的对象和属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request&lt;/strong&gt;代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;session&lt;/strong&gt;代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;application&lt;/strong&gt;代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何实现jsp或servlet的单线程模式&quot;&gt;&lt;span&gt;如何实现JSP或Servlet的单线程模式？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于JSP页面，可以通过page指令进行设置。&lt;br/&gt;&amp;lt;%@page isThreadSafe=”false”%&amp;gt;&lt;/p&gt;
&lt;p&gt;对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。&lt;/p&gt;
&lt;p&gt;说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。&lt;/p&gt;
&lt;h2 id=&quot;实现会话跟踪的技术有哪些&quot;&gt;&lt;span&gt;实现会话跟踪的技术有哪些？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;使用Cookie&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;向客户端发送Cookie&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Cookie c =new Cookie(&quot;name&quot;,&quot;value&quot;); //创建Cookie 
c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天
response.addCookie(c); //把Cookie放入到HTTP响应中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从客户端读取Cookie&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String name =&quot;name&quot;; 
Cookie[]cookies =request.getCookies(); 
if(cookies !=null){ 
   for(int i= 0;i&amp;lt;cookies.length;i++){ 
    Cookie cookie =cookies[i]; 
    if(name.equals(cookis.getName())) 
    //something is here. 
    //you can get the value 
    cookie.getValue(); 
       
   }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;URL 重写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 在Cookie被禁用的时候依然可以使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。&lt;/p&gt;
&lt;p&gt;3.隐藏的表单域&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name =&quot;session&quot; value=&quot;...&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; Cookie被禁时可以使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 所有页面必须是表单提交之后的结果。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HttpSession&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。&lt;/p&gt;
&lt;h2 id=&quot;cookie和session的的区别&quot;&gt;&lt;span&gt;Cookie和Session的的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。&lt;/li&gt;
&lt;li&gt;思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。&lt;/li&gt;
&lt;li&gt;Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;listsetmap三者的区别及总结&quot;&gt;&lt;span&gt;List，Set,Map三者的区别及总结&lt;/span&gt;&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;List：对付顺序的好帮手&lt;/strong&gt;&lt;/p&gt;
List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Set:注重独一无二的性质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不允许重复的集合。不会有多个元素引用相同的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Map:用Key来搜索的专家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;arraylist-与-linkedlist-区别&quot;&gt;&lt;span&gt;Arraylist 与 LinkedList 区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。&lt;/p&gt;
&lt;h2 id=&quot;arraylist-与-vector-区别为什么要用arraylist取代vector呢&quot;&gt;&lt;span&gt;ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector&lt;br/&gt;，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。&lt;/p&gt;
&lt;h2 id=&quot;hashmap-和-hashtable-的区别&quot;&gt;&lt;span&gt;HashMap 和 Hashtable 的区别&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧&lt;/p&gt;
&lt;h2 id=&quot;hashset-和-hashmap-区别&quot;&gt;&lt;span&gt;HashSet 和 HashMap 区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&amp;amp;h=363&amp;amp;f=jpeg&amp;amp;s=205536&quot; alt=&quot;HashSet 和 HashMap 区别&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hashmap-和-concurrenthashmap-的区别&quot;&gt;&lt;span&gt;HashMap 和 ConcurrentHashMap 的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xuefeng0707/article/details/40834595&quot;&gt;HashMap与ConcurrentHashMap的区别&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）&lt;/li&gt;
&lt;li&gt;HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hashset如何检查重复&quot;&gt;&lt;span&gt;HashSet如何检查重复&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hashCode（）与equals（）的相关规定：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两个对象相等，则hashcode一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个equals方法返回true&lt;/li&gt;
&lt;li&gt;两个对象有相同的hashcode值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;综上，equals方法被覆盖过，则hashCode方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;==与equals的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同&lt;/li&gt;
&lt;li&gt;==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;comparable-和-comparator的区别&quot;&gt;&lt;span&gt;comparable 和 comparator的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序&lt;/li&gt;
&lt;li&gt;comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().&lt;/p&gt;
&lt;h3 id=&quot;comparator定制排序&quot;&gt;&lt;span&gt;Comparator定制排序&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class CollectionsSort {

    public static void main(String[] args) {

        ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;();
        arrayList.add(-1);
        arrayList.add(3);
        arrayList.add(3);
        arrayList.add(-5);
        arrayList.add(7);
        arrayList.add(4);
        arrayList.add(-9);
        arrayList.add(-7);
        System.out.println(&quot;原始数组:&quot;);
        System.out.println(arrayList);
        // void reverse(List list)：反转
        Collections.reverse(arrayList);
        System.out.println(&quot;Collections.reverse(arrayList):&quot;);
        System.out.println(arrayList);
/*      
         * void rotate(List list, int distance),旋转。
         * 当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将
         * list的前distance个元素整体移到后面。
         
        Collections.rotate(arrayList, 4);
        System.out.println(&quot;Collections.rotate(arrayList, 4):&quot;);
        System.out.println(arrayList);*/
        
        // void sort(List list),按自然排序的升序排序
        Collections.sort(arrayList);
        System.out.println(&quot;Collections.sort(arrayList):&quot;);
        System.out.println(arrayList);

        // void shuffle(List list),随机排序
        Collections.shuffle(arrayList);
        System.out.println(&quot;Collections.shuffle(arrayList):&quot;);
        System.out.println(arrayList);

        // 定制排序的用法
        Collections.sort(arrayList, new Comparator&amp;lt;Integer&amp;gt;() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        System.out.println(&quot;定制排序后：&quot;);
        System.out.println(arrayList);
    }

}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重写compareto方法实现按年龄来排序&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;重写compareTo方法实现按年龄来排序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;package map;

import java.util.Set;
import java.util.TreeMap;

public class TreeMap2 {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        TreeMap&amp;lt;Person, String&amp;gt; pdata = new TreeMap&amp;lt;Person, String&amp;gt;();
        pdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;);
        pdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;);
        pdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;);
        pdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;);
        // 得到key的值的同时得到key所对应的值
        Set&amp;lt;Person&amp;gt; keys = pdata.keySet();
        for (Person key : keys) {
            System.out.println(key.getAge() + &quot;-&quot; + key.getName());

        }
    }
}

// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了

class Person implements Comparable&amp;lt;Person&amp;gt; {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     * TODO重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        // TODO Auto-generated method stub
        if (this.age &amp;gt; o.getAge()) {
            return 1;
        } else if (this.age &amp;lt; o.getAge()) {
            return -1;
        }
        return age;
    }
}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何对object的list排序&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何对Object的list排序？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;对objects数组进行排序，我们可以用Arrays.sort()方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;对objects的集合进行排序，需要使用Collections.sort()方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何实现数组与list的相互转换&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何实现数组与List的相互转换？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;List转数组：toArray(arraylist.size()方法；数组转List:Arrays的asList(a)方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;();
        arrayList.add(&quot;s&quot;);
        arrayList.add(&quot;e&quot;);
        arrayList.add(&quot;n&quot;);
        /**
         * ArrayList转数组
         */
        int size=arrayList.size();
        String[] a = arrayList.toArray(new String[size]);
        //输出第二个元素
        System.out.println(a[1]);//结果：e
        //输出整个数组
        System.out.println(Arrays.toString(a));//结果：[s, e, n]
        /**
         * 数组转list
         */
        List&amp;lt;String&amp;gt; list=Arrays.asList(a);
        /**
         * list转Arraylist
         */
        List&amp;lt;String&amp;gt; arrayList2 = new ArrayList&amp;lt;String&amp;gt;();
        arrayList2.addAll(list);
        System.out.println(list);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何求arraylist集合的交集-并集-差集-去重复并集&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何求ArrayList集合的交集 并集 差集 去重复并集&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要用到List接口中定义的几个方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;addAll(Collection&amp;lt;? extends E&amp;gt; c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾&lt;br/&gt;实例代码：&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;retainAll(Collection&amp;lt;?&amp;gt; c): 仅保留此列表中包含在指定集合中的元素。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;removeAll(Collection&amp;lt;?&amp;gt; c) :从此列表中删除指定集合中包含的所有元素。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;package list;

import java.util.ArrayList;
import java.util.List;

public class MethodDemo {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        List&amp;lt;Integer&amp;gt; list1 = new ArrayList&amp;lt;Integer&amp;gt;();
        list1.add(1);
        list1.add(2);
        list1.add(3);
        list1.add(4);

        List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;Integer&amp;gt;();
        list2.add(2);
        list2.add(3);
        list2.add(4);
        list2.add(5);
        // 并集
        // list1.addAll(list2);
        // 交集
        //list1.retainAll(list2);
        // 差集
        // list1.removeAll(list2);
        // 无重复并集
        list2.removeAll(list1);
        list1.addAll(list2);
        for (Integer i : list1) {
            System.out.println(i);
        }
    }

}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hashmap-的工作原理及代码实现&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;HashMap 的工作原理及代码实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5ab0568b5188255580020e56&quot;&gt;集合框架源码学习之HashMap(JDK1.8)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;concurrenthashmap-的工作原理及代码实现&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ConcurrentHashMap 的工作原理及代码实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/chengxiao/p/6842045.html&quot;&gt;ConcurrentHashMap实现原理及源码分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;参考书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《Head first java 》第二版 推荐阅读真心不错 （适合基础较差的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《Java核心技术卷1》推荐阅读真心不错 （适合基础较好的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《算法》第四版 （适合想对数据结构的Java实现感兴趣的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 12:11:00 +0000</pubDate>
<dc:creator>AntzUhl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/javams.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Apollo实现统一配置中心 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/9419379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/9419379.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　在微服务架构环境中，项目中配置文件比较繁杂，而且不同环境的不同配置修改相对频繁，每次发布都需要对应修改配置，如果配置出现错误，需要重新打包发布，时间成本较高，因此需要做统一的配置中心，能做到自动更新配置文件信息，解决以上问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804174604273-161191730.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Apollo（阿波罗）是携程框架部门研发的配置管理平台，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。其服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Apollo目前在国内开发者社区比较热，在Github上有超过&lt;strong&gt;5k&lt;/strong&gt;颗星，在国内众多互联网公司&lt;strong&gt;有落地案例&lt;/strong&gt;，可以说Apollo是目前配置中心产品领域&lt;strong&gt;No.1&lt;/strong&gt;的产品，其成熟度和企业级特性要&lt;strong&gt;远远强于Spring Cloud体系中的Spring Cloud Config产品&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　目前有针对Java和.Net的两个客户端供使用：&lt;/p&gt;
&lt;p&gt;　　Java客户端不依赖任何框架，能够运行于所有Java运行时环境，同时对Spring/Spring Boot环境也有额外支持。&lt;/p&gt;
&lt;p&gt;　　.Net客户端不依赖任何框架，能够运行于所有.Net运行时环境。&lt;/p&gt;
&lt;p&gt;　　更多Apollo介绍请浏览 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Apollo配置中心介绍&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2.1 快速安装&lt;/h2&gt;
&lt;p&gt;　　Apollo GitHub中提供了一个让我们快速上手的Quick Start，帮助我们快速在本地环境部署，启动Apollo配置中心。这里主要集中于针对开发环境的本地部署（单击），要部署到生产环境，请参考 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;Apollo分布式部署指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　这里我使用的是Windows Server的虚拟机在本机搭的，当然你可以在你的Linux虚拟机中搭建，另外你也可以通过&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo-Quick-Start-Docker%E9%83%A8%E7%BD%B2&quot; target=&quot;_blank&quot;&gt;Docker更快捷地部署Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　Step1.准备下列软件/环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt; =&amp;gt; JDK 1.8+&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mysql.com/downloads/&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; =&amp;gt; 5.6.6+&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitforwindows.org/&quot; target=&quot;_blank&quot;&gt;Gitbash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nobodyiam/apollo-build-scripts&quot; target=&quot;_blank&quot;&gt;Apollo QuickStart&lt;/a&gt;　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Step2.陆续安装Java JDK, MySQL与Git&lt;/p&gt;
&lt;p&gt;　　Step3.导入脚本（从QuickStart目录中的sql文件夹中拷贝），导入的结果会创建两个数据库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804180345292-758388507.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step4.修改demo.sh中关于数据库连接的信息，主要是url、username与password&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;# apollo config db info&lt;br/&gt;apollo_config_db_url=jdbc:mysql://&lt;span&gt;&lt;strong&gt;192.168.80.70&lt;/strong&gt;&lt;/span&gt;:3306/ApolloConfigDB?characterEncoding=utf8&lt;br/&gt;apollo_config_db_username=root&lt;br/&gt;apollo_config_db_password=&lt;span&gt;213224591&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;# apollo portal db info&lt;br/&gt;apollo_portal_db_url=jdbc:mysql://&lt;span&gt;&lt;strong&gt;192.168.80.70&lt;/strong&gt;&lt;/span&gt;:3306/ApolloPortalDB?characterEncoding=utf8&lt;br/&gt;apollo_portal_db_username=root&lt;br/&gt;apollo_portal_db_password=&lt;span&gt;213224591&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Step5.通过以下命令启动（切换到quickstart的目录中），后续可以将其作为Windows服务，不过生产环境一般用Linux。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cmd&amp;gt;cd C:\Apollo\apollo-build-scripts-master&lt;/p&gt;
&lt;p&gt;cmd&amp;gt;demo.sh start　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　启动后会最终显示以下信息：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
==== starting service ====
Service logging file is ./service/apollo-service.log
Started [3099]
Waiting for config service startup.......
Config service started. You may visit http://localhost:8080 for service status now!
Waiting for admin service startup....
Admin service started
==== starting portal ====
Portal logging file is ./portal/apollo-portal.log
Started [4071]
Waiting for portal startup......
Portal started. You can visit http://localhost:8070 now!
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;　　看到上述信息显示完毕，证明我们的Apollo已经成功启动起来了，那么我们可以去这两个端口8080和8070去看看：&lt;/p&gt;
&lt;p&gt;　　[8070 =&amp;gt; Apollo 配置中心管理界面，默认账号：apollo/admin]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804180926923-1799350822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进入之后会看到一个示例项目SampleApp，点进去可以看到其中有一个示例配置applicaiton&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804182441970-649329530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[8080 =&amp;gt; Eureka服务注册&amp;amp;发现，和Consul类似，因为Apollo采用了Eureka作为服务注册中心，对Apollo架构感兴趣的童鞋可以阅读波波老师的《&lt;a href=&quot;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&quot; target=&quot;_blank&quot;&gt;携程配置中心Apollo架构分析&lt;/a&gt;》，这里不是本文的重点]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804181806323-2147160271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 基本配置&lt;/h2&gt;
&lt;p&gt;　　Step1.创建一个新项目（这里部门可以自己在数据中编辑serverconfig表添加）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804183912266-1858967713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step2.默认情况下，创建新项目后有一个默认的application的Namespace，我们删除它，然后重新创建我们要用到的配置。对于一般共用的数据库、Redis、RabbitMQ等配置，我们一般会将其放到一个Public的配置列表中，而每个项目中私有的配置信息（如Swagger文档的说明信息）我们会单独创建一个Private的配置列表给每个项目。&lt;/p&gt;
&lt;p&gt;　　下图为创建一个共享的配置列表（在Apollo中称为Namespace，详细内容可以参考：&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E2%80%9CNamespace%E2%80%9D&quot; target=&quot;_blank&quot;&gt;Apollo核心概念之Namespace&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804184611324-1802336019.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　Step3.向Shared和ClientService两个Namespace中添加Key/Value配置项（可以通过文本形式添加，速度更快），添加之后记得点击发布，最终结果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804185633263-1302034738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在配置都有了，开始和我们的ASP.Net Core集成把。&lt;/p&gt;

&lt;h2&gt;3.1 准备工作&lt;/h2&gt;
&lt;p&gt;　　导入.Net Core的客户端package，看这个名字Com.Ctrip.Framework.Apollo.Configuration应该是Java程序员写的，特别的Java Style.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt;Install-Package Com.Ctrip.Framework.Apollo.Configuration　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　修改appsettings.json，添加apollo节点：指明apollo的AppId和Server地址 =&amp;gt; AppId 用来标识应用身份的唯一id，Apollo客户端针对不同的环境会从不同的服务器获取配置 ，MetaServer 就是客户端获取配置的服务器配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apollo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MetaServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.80.70:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 更改Program.cs&lt;/h2&gt;
&lt;p&gt;　　这里主要会在启动时读取appsettings.json中的AppId和MetaServer来连接Apollo，并且指定要读取哪个Namespace的配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
&lt;strong&gt;                .ConfigureAppConfiguration((hostingContext, builder) &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&amp;gt;&lt;span&gt;
                {
                    builder
                    .AddApollo(builder.Build().GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apollo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;))
                    .AddDefault()
                    .AddNamespace(&quot;&lt;span&gt;TEST3.Shared&lt;/span&gt;&quot;);
                    .AddNamespace(&quot;&lt;span&gt;ClientService&lt;/span&gt;&quot;);
                })&lt;/strong&gt;
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 更改StartUp.cs&lt;/h2&gt;
&lt;p&gt;　　对于StartUp.cs，它承担了很多初始化的注入工作，我们会在里边引入很多配置项，但是幸运的是我们不需要做太多更改，只是把配置项的Key换成Apollo中定义的即可。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IoC - DbContext&lt;/span&gt;
    services.AddDbContextPool&amp;lt;ClientDbContext&amp;gt;&lt;span&gt;(
                options &lt;/span&gt;=&amp;gt; options.UseSqlServer(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Swagger&lt;/span&gt;
    services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
    {
        s.SwaggerDoc(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.DocName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
        {
            Title &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Version &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Description &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Contact &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Contact
            {
                Name &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Contact:Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                Email &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Contact:Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            }
        });
        ......
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里通过查看Swagger API文档来验证一下是否读出来了配置项Value：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804194641266-695722913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多内容，请参考Apollo的.Net core客户端分支：&lt;a href=&quot;https://github.com/ctripcorp/apollo.net/tree/dotnet-core&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo.net/tree/dotnet-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这时如果我们在Apollo中更改了ClientService的Swagger.Title配置项并发布之后，重启一下ClientService，配置已经更改为下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804195339376-1535724574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇简单介绍了一下统一配置中心与Apollo的基本概念，然后介绍了Apollo的快速安装（基于QuickStart）与基本配置，最后通过与ASP.NET Core的集成演示了如何在项目中使用Apollo替代原有的配置文件（appsettings.json）。当然，本篇只是一个QuickStart，更多的内容都没有覆盖，需要我们去看官方Wiki了解。Apollo目前在国内开发者社区比较热，在Github上有超过&lt;strong&gt;5k&lt;/strong&gt;颗星，在国内众多互联网公司&lt;strong&gt;有落地案例&lt;/strong&gt;，值得我们学习和了解&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）min.jiang，《&lt;a href=&quot;https://www.cnblogs.com/ASPNET2008/p/5166922.html&quot; target=&quot;_blank&quot;&gt;统一配置中心&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（2）张乐，《&lt;a href=&quot;https://blog.csdn.net/lepdou/article/details/70880285&quot; target=&quot;_blank&quot;&gt;开源配置中心之Apollo&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（3）陈珙，《&lt;a href=&quot;https://www.cnblogs.com/skychen1218/p/9300745.html&quot; target=&quot;_blank&quot;&gt;基于Windows Server部署Apollo初次体验&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（4）Apollo Quick Start: &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Quick-Start&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo/wiki/Quick-Start&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（5）Apollo GitHub: &lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（6）杨波，《&lt;a href=&quot;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&quot; target=&quot;_blank&quot;&gt;携程配置中心Apollo架构分析&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（7）focus-lei，《&lt;a href=&quot;https://www.cnblogs.com/focus-lei/p/9077467.html&quot; target=&quot;_blank&quot;&gt;.Net core使用Apollo做统一配置中心&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（8）张善友，《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/8449863.html&quot;&gt;携程Apollo（阿波罗）配置中心在.NET Core项目快速集成&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（9）ctrip，《&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/.Net%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;Apollo .Net客户端使用指南&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 04 Aug 2018 11:58:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/9419379.html</dc:identifier>
</item>
<item>
<title>如何正确的在项目中接入微信JS-SDK - detectiveHLH</title>
<link>http://www.cnblogs.com/detectiveHLH/p/9419462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/detectiveHLH/p/9419462.html</guid>
<description>&lt;h2 id=&quot;微信js-sdk的功能&quot;&gt;微信JS-SDK的功能&lt;/h2&gt;
&lt;p&gt;如果你点进来，那么我相信你应该知道微信的JS-SDK可以用来做什么了。微信的官方文档描述如下。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。&lt;/p&gt;
&lt;p&gt;通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫等微信特有的能力，为微信用户提供更优质的网页体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过使用微信的JS-SDK，你可以让你网页在微信内调用拍照、语音、支付、位置、扫一扫这些只能在微信内使用的功能。进过下面的步骤，一步一步的配置，就可以让你正确的在项目中引入微信的JS-SDK。&lt;/p&gt;
&lt;h2 id=&quot;引入微信的js文件&quot;&gt;引入微信的JS文件&lt;/h2&gt;
&lt;p&gt;微信的javascript文件的链接是： &lt;a href=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot; class=&quot;uri&quot;&gt;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是只支持使用 AMD/CMD 标准模块加载方法加载。于是我就在npm的官网上找到了发布后的js-sdk，支持CommonJS的引入方式。npm的地址在 &lt;a href=&quot;https://www.npmjs.com/package/weixin-js-sdk&quot;&gt;这里&lt;/a&gt;。可以在你的项目中使用如下命令安装。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm install weixin-js-sdk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好后可以使用一下两种方式进行引入。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/* 使用CommonJs规范引入 */
const wx = require('weixin-js-sdk');

/* 使用ES6模块引入 */
import wx from 'weixin-js-sdk';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为wx.config实现权限签名算法&quot;&gt;为wx.config实现权限签名算法&lt;/h2&gt;
&lt;p&gt;如果你安装大部分你的教程来，他们会让你使用wx.config注入，获取权限。但是使用wx.config的前提是你必须要先实现权限签名算法。而权限签名算法的关键就是jsapi_ticket。关于jsapi_ticketm，官方的描述如下。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是企业号号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概什么意思呢，看官方文档可能有点懵。大概意思就是：你想用我的sdk？可以，我给你个2个小时有效期的调用凭证。这个凭证我每天发给你的次数有限，所以你要保存好，不然到时候再想要凭证，没门。&lt;/p&gt;
&lt;p&gt;这是通（很）俗（皮）的解释。下面来点正常的解释。想要获取jsapi_ticket，你就需要向下面这个url:&lt;a href=&quot;https://qyapi.weixin.qq.com/cgi-bin/get_jsapi_ticket?access_token=ACCESS_TOKE%E5%8F%91%E9%80%81Http&quot; class=&quot;uri&quot;&gt;https://qyapi.weixin.qq.com/cgi-bin/get_jsapi_ticket?access_token=ACCESS_TOKE发送Http&lt;/a&gt; GET请求，需要带上两个参数。access_token和type，如果你是获取jsapi_ticket，那么type就是固定的，值为jsapi。就可以在返回里面拿到ticket。并且你需要在服务器端缓存返回拿到的ticket。这个ticket就是上面通俗解释里的凭证，有效期两个小时，此后前端所有需要用到ticket的地方，后端需要去判断，如果ticket仍然没有过期，就从缓存中取出返回给前端，如果失效，就再发一个GET接口，获取后再存入缓存并且返回给前端。如果请求正常的话，会返回下列数据。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
    'errcode': 0,
    'errmsg': 'ok',
    'ticket': 'bxLdikRXVbTPdHSM05e5u5sUoXNKd8-41ZO3MhKoyN5OfkWITDGgnr2fwJ0m9E8NYzWKVZvdVtaUgWvsdshFKA',
    'expires_in': 7200,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到了jsapi_ticket之后，我们就可以开始进行权限签名算法了。算法的流程如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158320/201808/1158320-20180804181309821-28932153.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个逻辑需要在后端实现。为什么会在下文给出。将需要用到js-sdk页面的url、以及jsapi_ticket、noncestr（随机字符串）、timestamp（当前的时间戳）进行字典序&lt;br/&gt;排序，然后使用URL键值对的格式 （即 key1=value1&amp;amp;key2=value2…）拼接成字符串string。然后将这个string使用sha1加密，得到的结果就是signature了。然后将signature、timestamp、nonceStr返回给前端，wx.config需要用到这些数据。然后将它们用这里需要特别注意一下，官方的注意文档如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;签名用的noncestr和timestamp必须与wx.config中的nonceStr和timestamp相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;签名用的url必须是调用JS接口页面的完整URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;出于安全考虑，开发者必须在服务器端实现签名的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这里的官方文档其实也没有那么官方，其实就是告诉我们，实现上述签名逻辑必须在服务器，以及noncestr和timestamp必须要和在服务器端签名所使用的一致，还有就是调用微信js-sdk的页面的url必须要跟服务端签名所使用的url一致。所有在服务端可以直接从请求的header里面的referer获取。&lt;/p&gt;
&lt;p&gt;你把接口做好之后，只要能够正确的返回signature、nonceStr、timestamp（有后端的更好，直接找他们要接口就好了），就可以愉快的进行下一步了。&lt;/p&gt;
&lt;h2 id=&quot;通过config接口注入权限验证配置&quot;&gt;通过config接口注入权限验证配置&lt;/h2&gt;
&lt;p&gt;官方的描述如下。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进行了正确的微信javascript文件引入后（看上面）在页面中调用如下代码就可以注入权限验证配置。下面是官方给的样例代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;wx.config({
    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
    appId: '', // 必填，企业号的唯一标识，此处填写企业号corpid
    timestamp: , // 必填，生成签名的时间戳
    nonceStr: '', // 必填，生成签名的随机串
    signature: '',// 必填，签名，见附录1
    jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我给一个样例数据。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// data就是上一步说的后端返回的那些数据，包含signature、nonceStr、timestamp
const data = await getJsSDK();

wx.config({
    debug: true,
    appId: '你的appId',
    timestamp: data.timestamp,
    nonceStr: data.nonceStr,
    signature: data.signature,
    jsApiList: [
      'onMenuShareTimeline', // 分享到朋友圈
      'onMenuShareAppMessage', // 分享给朋友
      'onMenuShareQQ',// 分享到QQ
      'onMenuShareWeibo',// 分享到腾讯微博
      'onMenuShareQZone',// 分享到QQ空间
    ]
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注入后的生命周期函数&quot;&gt;注入后的生命周期函数&lt;/h2&gt;
&lt;p&gt;在调用config后会有两个结果，成（这）功（是）和（废）失（话）败。可以通过微信提供的两个接口来进行事件回调。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;wx.ready(function(){
    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。
});

wx.error(function(res){
    // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调用分享接口&quot;&gt;调用分享接口&lt;/h2&gt;
&lt;p&gt;在ready()中调用具体的分享接口。如分享到朋友圈、好友、QQ空间。代码如下。我把接口的所有的钩子函数都给了出来。其实常用的就只有的success和cancel。根据你个人的需求而定。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;wx.ready(function(){
  /* 分享到朋友圈 */
  wx.onMenuShareTimeline({
    title: '', // 分享标题
    link: '', // 分享链接，该链接域名必须与当前企业的可信域名一致
    imgUrl: '', // 分享图标
    success: function () {
      // 用户确认分享后执行的回调函数
    },
    cancel: function () {
      // 用户取消分享后执行的回调函数
    },
    trigger: function () {
      // 监听Menu中的按钮点击时触发的方法
    },
    complete: function () {
      // 接口调用完成时执行的回调函数，无论成功或失败都会执行
    },
    fail: function () {
      // 接口调用失败时执行的回调函数
    },
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;微信官方文档在这给了一个特别的提醒。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概意思就是，不要尝试在钩子函数中动态的修改title啊link啊的值，因为分享是同步的操作，ajax的值返回回来的时候分享的操作已经结束了。比起这个，要注意的是link字段，它的域名必须要跟微信后台配置的JS安全域域名一致，否则分享会失败。到这为止，微信js-sdk的接入就完成了。还有问题可以直接留言或者联系我。&lt;/p&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;最后还需要注意一点的是，如果页面的url发生了变化，在新的url下调用js-sdk一定要再调用一次签名接口，用新的url再进行一次签名，否则会调用不成功。&lt;/p&gt;
&lt;p&gt;微信官方文档地址在 &lt;a href=&quot;http://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 10:14:00 +0000</pubDate>
<dc:creator>detectiveHLH</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/detectiveHLH/p/9419462.html</dc:identifier>
</item>
<item>
<title>开放定址法之线性探测 - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9419387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9419387.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;之前我们所采用的那种方法&lt;span lang=&quot;zh-CN&quot;&gt;，也被称之为封闭定址法。每个桶单元里存的都是那些与这个桶地址比如K相冲突的词条。也就是说每个词条应该属于哪个桶所对应的列表，都是在事先已经注定的。经过一个确定的哈希函数，这些绿色方块只会掉到K这个桶里，它不可能被散列到其他的桶单元。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174154033-1471438856.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与此同时，分离链接散列算法还有一个亟待解决的缺点：需要指针，由于给新单元分配地址需要时间，这就导致了速度减慢，所以不太好。还有，因为链表是次第关联的结构，实现算法的代码自身的复杂程度和出错概率会大大增加。而只要采用这种策略，就很难保证每组冲突的词条在空间上能够彼此毗邻，因为动态分配的节点在内存里不一定是连续的，这样一来会导致一个致命缺陷（上篇文章末尾提到过）：对于稍大规模的词条集合，查找中将做大量的I／O操作，无法利用系统预先缓存，导致效率低下。&lt;/p&gt;

&lt;p&gt;因此或许我们应该放弃这种策略，并反其道而行之，仅仅依靠基本的散列表结构，就地排解冲突反而是更好的选择。也就是采用所谓的开放定址策略，它的特点在于：散列表所占用的空间在物理上始终是地址连续的一块，相应的所有的冲突都在这块连续空间中加以排解。而无需向分离链接那样申请额外的空间。对！所有的散列以及冲突排解都在这样一块封闭的空间内完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174227190-222388192.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;因此相应地，这种策略也可以称作为闭散列。如果有冲突发生，就要尝试选择另外的单元，直到找到一个可供存放的空单元。具体存放在哪个单元，是有不同优先级的，优先级最高的是他原本归属的那个单元。从这个单元往后，都按照某种优先级规则排成一个序列，而在查找的时候也是按着这个序列行进，每个词条对应的这个序列被称为探测序列&lt;span lang=&quot;en-US&quot;&gt;or查找链&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;抽象来说，就是我们遇到冲突后，会相继尝试&lt;span lang=&quot;en-US&quot;&gt;h0(x),h1(x),h2(x)这些单元&lt;span lang=&quot;zh-CN&quot;&gt;，其中&lt;span lang=&quot;en-US&quot;&gt;hi(x)= ( &lt;span lang=&quot;zh-CN&quot;&gt;Hash&lt;span lang=&quot;en-US&quot;&gt;( x ) + F ( I ) ) % TableSize&lt;span lang=&quot;zh-CN&quot;&gt;，并且约定F&lt;span lang=&quot;en-US&quot;&gt;(0)=0&lt;span lang=&quot;zh-CN&quot;&gt;，F（x）是解决冲突的方法，&lt;span lang=&quot;en-US&quot;&gt;就是刚才说的那个“优先级规则”&lt;span lang=&quot;zh-CN&quot;&gt;。因为所有的数据都要放在这块空间，所以开放定址所需要的表规模比分离链接要大。通常而言开放定址法的装填因子&lt;span lang=&quot;en-US&quot;&gt;lambda应该低于0.5&lt;span lang=&quot;zh-CN&quot;&gt;。而根据对不同F&lt;span lang=&quot;en-US&quot;&gt;(x)的选择&lt;span lang=&quot;zh-CN&quot;&gt;，学界划分出三种常用的探测序列：线性探测法、平方探测法、双散列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面要求各单位、各部门学习贯彻《关于解决散列表冲突问题的三种开放定址方法》&lt;/p&gt;

&lt;h2 lang=&quot;en-US&quot;&gt;1.线性探测法&lt;/h2&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;在线性探测法中&lt;span lang=&quot;zh-CN&quot;&gt;，函数F是关于&lt;span lang=&quot;en-US&quot;&gt;i的线性函数&lt;span lang=&quot;zh-CN&quot;&gt;，典型的情形是F&lt;span lang=&quot;en-US&quot;&gt;(i)=i&lt;span lang=&quot;zh-CN&quot;&gt;。这相当于逐个探测每个单元（必要时可以绕回）以查找出一个空单元。下面显示了将&lt;span lang=&quot;en-US&quot;&gt;{89,18,49,58,69}插入到一个散列表中的情况&lt;span lang=&quot;zh-CN&quot;&gt;（竖着看），使用了和之前一样的散列函数&lt;span lang=&quot;en-US&quot;&gt;hash(x)=x%size&lt;span lang=&quot;zh-CN&quot;&gt;，他们有冲突怎么办？用F&lt;span lang=&quot;en-US&quot;&gt;(i)=i这个方法&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;每次从i=0开始尝试&lt;span lang=&quot;zh-CN&quot;&gt;，那么根据&lt;span lang=&quot;en-US&quot;&gt;hi(x)= ( &lt;span lang=&quot;zh-CN&quot;&gt;Hash&lt;span lang=&quot;en-US&quot;&gt;( x ) + F ( I ) ) % TableSize就可以计算出各自不相冲突的地址了&lt;span lang=&quot;zh-CN&quot;&gt;。完美！（暂时的）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174303716-455210677.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们脑内单步调试一下：第一个冲突在&lt;span lang=&quot;en-US&quot;&gt;49产生:&lt;span lang=&quot;zh-CN&quot;&gt;（&lt;span lang=&quot;en-US&quot;&gt;49%10+0&lt;span lang=&quot;zh-CN&quot;&gt;）&lt;span lang=&quot;en-US&quot;&gt;%10=9&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;被89占了&lt;span lang=&quot;zh-CN&quot;&gt;，那接着往后试，&lt;span lang=&quot;en-US&quot;&gt;i=1&lt;span lang=&quot;zh-CN&quot;&gt;，（&lt;span lang=&quot;en-US&quot;&gt;49%10+1&lt;span lang=&quot;zh-CN&quot;&gt;）&lt;span lang=&quot;en-US&quot;&gt;%10=0&lt;span lang=&quot;zh-CN&quot;&gt;，空的，放入这个空闲地址，这个地址是开放的。&lt;span lang=&quot;en-US&quot;&gt;58依次和18,89,49产生冲突&lt;span lang=&quot;zh-CN&quot;&gt;，试选三次后才找到一个空单元。对&lt;span lang=&quot;en-US&quot;&gt;69的冲突也如此解决&lt;span lang=&quot;zh-CN&quot;&gt;，一旦冲突，试探紧邻其后的单元，直至找到空单元&lt;span lang=&quot;en-US&quot;&gt;or抵达散列表末尾&lt;span lang=&quot;zh-CN&quot;&gt;。线性探测序列&lt;span lang=&quot;en-US&quot;&gt;0-&amp;gt;1-&amp;gt;2-&amp;gt;3在物理上保持连贯性的&lt;span lang=&quot;zh-CN&quot;&gt;，具有局部性，&lt;span lang=&quot;en-US&quot;&gt;这样一来系统的缓存作用将得到充分发挥&lt;span lang=&quot;zh-CN&quot;&gt;，而对于大规模的数据集，这样一来更是可以减少&lt;span lang=&quot;en-US&quot;&gt;I/O的次数&lt;span lang=&quot;zh-CN&quot;&gt;。只要表足够大，总能找到一个空闲单元，但是这太费时间了。更糟的是——就算一开始空闲区域多，经过多次排解冲突后，数据所占据的单元也会开始形成一些区块，聚集在一起，被称为&lt;span lang=&quot;zh-CN&quot;&gt;一次聚集&lt;span lang=&quot;en-US&quot;&gt;(primary clustering)&lt;span lang=&quot;zh-CN&quot;&gt;，但在前面动机篇里说过，散列函数的初衷是避免数据扎堆，所以后面必须改进。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;那么&lt;span lang=&quot;en-US&quot;&gt;总体看来散列到区块的任何关键字都需要多次试选单元才能解决冲突&lt;span lang=&quot;zh-CN&quot;&gt;，然后被放到对应的那个区块里。下面做一个总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;优点&lt;span lang=&quot;zh-CN&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;无需附加空间（指针、链表、溢出区）&lt;/li&gt;
&lt;li&gt;探测序列具有局部性，可以利用系统缓存，减少IO&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;耗费时间&lt;span lang=&quot;en-US&quot;&gt;&amp;gt;O(1)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;en-US&quot;&gt;冲突增多——以往的冲突会导致后续的连环冲突&lt;span lang=&quot;zh-CN&quot;&gt;，发生惨烈的车祸&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174328490-960023195.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;光看这个图可能没什么感觉，举个例子吧，这样感触更深。我们开一个&lt;span lang=&quot;en-US&quot;&gt;size=7的散列&lt;span lang=&quot;zh-CN&quot;&gt;表，也保证了&lt;span lang=&quot;en-US&quot;&gt;size是素数&lt;span lang=&quot;zh-CN&quot;&gt;。把&lt;span lang=&quot;en-US&quot;&gt;{0&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;2&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;3&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;7}&lt;span lang=&quot;zh-CN&quot;&gt;，就按这个顺序依次插入。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前四个数都没问题，依次插入没有冲突。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174403743-1967438732.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;但是为了插入&lt;span lang=&quot;en-US&quot;&gt;7&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;我们先试探0&lt;span lang=&quot;zh-CN&quot;&gt;发现非空，往后走，依次试探&lt;span lang=&quot;en-US&quot;&gt;1,2,3都非空&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;直到4可以放进去&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174419254-1789302828.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;在这个散列表的生存期里只有&lt;span lang=&quot;en-US&quot;&gt;1个发生冲突&lt;span lang=&quot;zh-CN&quot;&gt;。看似很棒对吧，再来看另一插入次序：&lt;span lang=&quot;en-US&quot;&gt;{7&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;0&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;2&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;3}&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174440856-577133177.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;插入&lt;span lang=&quot;en-US&quot;&gt;7没问题&lt;span lang=&quot;zh-CN&quot;&gt;，但插入&lt;span lang=&quot;en-US&quot;&gt;0的时候就&lt;span lang=&quot;zh-CN&quot;&gt;有冲突了，实际上自此之后每一个数插入都会遇到冲突，前后对比可以看出，第二种插入顺序发生的很多冲突本来是可以避免的。这个时候想必我们改进这种策略的意愿就十分迫切了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;要支持词条的删除则需要格外的小心，现在我们来做一探讨。按照线性探测的规则，先后插入彼此冲突的一组词条都将存放在同一个查找序列中，而更确切的讲：它们应该按照逻辑次序构成整个查找链的一个前缀，其中不得有任何的空桶缝隙。因此词条的删除操作需要做额外的一些处理，如果我们不做一些事先准备，直接将词条删除（就类似对于链表，删除节点的时候不做链条调整，而直接&lt;span lang=&quot;en-US&quot;&gt;free那个单元&lt;span lang=&quot;zh-CN&quot;&gt;，那不直接凉了），就会造成查找链断裂，后续词条丢失——明明存在但访问不到。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对于这种连续空间的单元删除，一个直观的构想是：将后续词条悉数取出，再重新插入。但这太特么慢了，时间复杂度爆炸。其实对于这个问题有一种典型的处理手法：&lt;span lang=&quot;en-US&quot;&gt;lazy delete&lt;span lang=&quot;zh-CN&quot;&gt;，仅做一个删除标记，&lt;span lang=&quot;en-US&quot;&gt;比如里面预留一个del变量&lt;span lang=&quot;zh-CN&quot;&gt;，设置为&lt;span lang=&quot;en-US&quot;&gt;TRUE&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174505200-1591759125.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;那么在日后查找中&lt;span lang=&quot;zh-CN&quot;&gt;，遇到他之后就应该越过继续往后查找而不是在此返回。在插入时遇到，就把它视作一个空单元，数据覆盖即可。应该说针对开放定址策略，懒惰删除不仅是&lt;span lang=&quot;zh-CN&quot;&gt;“&lt;span lang=&quot;zh-CN&quot;&gt;不得已而为之&lt;span lang=&quot;zh-CN&quot;&gt;”&lt;span lang=&quot;zh-CN&quot;&gt;的方法，甚至可以说是针对这种情况的最优方法。因为毕竟在开放定址策略中，每一个桶单元都同时属于多个查找链。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;下面咱们聊聊严肃点的事，做一些细致分析。可以证明的是，使用线性探测的预期探测次数和装填因子存在函数关系，对于插入、查找失败的情况，大约需要$\frac{1}{2}\left( 1+\frac{1}{^{\left( 1-\lambda\right)^{2}}} \right)$&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;次&lt;span lang=&quot;zh-CN&quot;&gt;，对于查找成功的情况需要$\frac{1}{2}\left( 1+\frac{1}{\left( 1-\lambda\right)} \right)$&lt;span lang=&quot;en-US&quot;&gt;次&lt;span lang=&quot;zh-CN&quot;&gt;，这个显然更快一些。相关的证明过程和计算推导有点复杂&lt;span lang=&quot;en-US&quot;&gt;…这里就直接给出结论&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;那这个性能如何呢&lt;span lang=&quot;zh-CN&quot;&gt;，我们仔细来推敲一下，虽然刚才从感性认识的角度，我们能察觉到线性探测是有必要改进的，因为：我们能感知到，表中已有元素越多，新插入时需要探测的次数就越多，这貌似不是个好兆头。但是用数学背景作为背书才是有说服力的。（下面可能有点难以理解，但尽量试着理解吧）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804175107191-1179210660.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对于随机冲突的解决方法而言，可以假设每次探测与之前的探测无关，这是成立的，因为随机。并且假设有一个很大规模的表，先计算单次失败查找的期望探测次数——这也是找到一个空单元的期望次数。已知空单元所占比例是&lt;span lang=&quot;en-US&quot;&gt;1-&lt;span lang=&quot;zh-CN&quot;&gt;λ，那么预计需要探测的单元数量是$\frac{1}{1-\lambda}$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;span lang=&quot;zh-CN&quot;&gt;因此我们可以使用单次失败查找的开销来计算查找成功的平均开销&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这句话的内在逻辑是这样的“失败查找的探测次数&lt;span lang=&quot;en-US&quot;&gt;=插入时探测次数=查找成功的探测次数&lt;span lang=&quot;zh-CN&quot;&gt;”，看似挺矛盾的，我一开始也不太理解，但我们仔细分析一下就能认识到它的道理：首先，右式，一次成功查找的探测次数就等于这个元素插入的探测次数，这个不难理解，插入的时候探测&lt;span lang=&quot;en-US&quot;&gt;n次&lt;span lang=&quot;zh-CN&quot;&gt;，然后放入空单元；之后查找时也是探测&lt;span lang=&quot;en-US&quot;&gt;n次&lt;span lang=&quot;zh-CN&quot;&gt;，第&lt;span lang=&quot;en-US&quot;&gt;n+1次探测直接命中&lt;span lang=&quot;zh-CN&quot;&gt;，两者相等。然后说左式，在插入之前，即将插入时的的探测次数&lt;span lang=&quot;en-US&quot;&gt;=失败查找的探测次数&lt;span lang=&quot;zh-CN&quot;&gt;，因为插入前没有这个元素，自然查找失败。所以左式&lt;span lang=&quot;en-US&quot;&gt;=右式&lt;span lang=&quot;zh-CN&quot;&gt;，这就能大概理解了吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;还有一件事，早期的λ比较小，所以造次插入开销较低，从更降低了平均开销。比如在上面那个表中，λ&lt;span lang=&quot;en-US&quot;&gt;=0.5&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180804174854291-988576891.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;访问&lt;span lang=&quot;en-US&quot;&gt;18的开销是在18被插入时确定的&lt;span lang=&quot;zh-CN&quot;&gt;，此时λ&lt;span lang=&quot;en-US&quot;&gt;=0.2&lt;span lang=&quot;zh-CN&quot;&gt;，而由于&lt;span lang=&quot;en-US&quot;&gt;18是插入到一个比较稀疏的表中&lt;span lang=&quot;zh-CN&quot;&gt;，因此对他的访问比&lt;span lang=&quot;en-US&quot;&gt;更晚&lt;span lang=&quot;zh-CN&quot;&gt;插入的元素（&lt;span lang=&quot;en-US&quot;&gt;e.g. 69&lt;span lang=&quot;zh-CN&quot;&gt;）更容易。我们可以通过积分来估计平均的插入时间：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;$I\left(\lambda\right)=\frac{1}{\lambda}\int_{0}^{\lambda }{\frac{1}{1-x}dx=\frac{1}{\lambda }\ln \frac{1}{1-\lambda}}$&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;这就比之前线性探测的公式更好了，另外，聚集这个问题，不仅是理论上棘手，在具体实现中也时隐时现，就像幽灵一样。一个幽灵，数据聚集的幽灵，在开放定址表里徘徊。为了对这个幽灵进行神圣的围剿，学界的一切势力，计算机科学家，数学家，还有各路工程师都联合起来了。（这个幽灵的确也为散列理论的创新发展提供了动力，是有一定进步意义的）&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们再来看，如果λ&lt;span lang=&quot;en-US&quot;&gt;=0.75,那么上面的公式指出&lt;span lang=&quot;zh-CN&quot;&gt;，线性探测中&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;次插入预计要进行&lt;span lang=&quot;en-US&quot;&gt;8.5次探测&lt;span lang=&quot;zh-CN&quot;&gt;。如果λ&lt;span lang=&quot;en-US&quot;&gt;=0.9&lt;span lang=&quot;zh-CN&quot;&gt;，你猜猜我们要找多少次能找到空单元？&lt;span lang=&quot;en-US&quot;&gt;50次&lt;span lang=&quot;zh-CN&quot;&gt;！这绝对不合理。从这些公式我们可以窥见：如果整个表&lt;span lang=&quot;en-US&quot;&gt;&amp;gt;50%的区域被填满&lt;span lang=&quot;zh-CN&quot;&gt;，那么线性探测就不是个好办法。但另一方面，如果是个稀疏表，λ很小，那么线性探测可谓如鱼得水了——我们就算按这个“小”的概念里撑死了说，λ&lt;span lang=&quot;en-US&quot;&gt;=0.5&lt;span lang=&quot;zh-CN&quot;&gt;，插入时平均只用探测&lt;span lang=&quot;en-US&quot;&gt;…..猜猜….2.5次&lt;span lang=&quot;zh-CN&quot;&gt;！，并且对于成功查找平均只需要探测&lt;span lang=&quot;en-US&quot;&gt;1.5次&lt;span lang=&quot;zh-CN&quot;&gt;，酷不酷！&lt;span lang=&quot;en-US&quot;&gt; 要以时间条件地点为转移&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;这再次说明了CS里权衡之术的地位&lt;span lang=&quot;zh-CN&quot;&gt;，也是矛盾论的胜利，在矛盾普遍性原理的指导下，具体分析矛盾的特殊性，并找出解决矛盾的正确方法&lt;span lang=&quot;en-US&quot;&gt;2333&lt;span lang=&quot;zh-CN&quot;&gt;（扯远了扯远了）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下一篇我们讨论一个更优化的方案——平方探测法。&lt;/p&gt;


&lt;p&gt;ps.转载请注明出处&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 09:53:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9419387.html</dc:identifier>
</item>
<item>
<title>亚像素数值极值检测算法总结 - Mr-Lee</title>
<link>http://www.cnblogs.com/shine-lee/p/9419388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shine-lee/p/9419388.html</guid>
<description>&lt;p&gt;在计算机视觉领域，经常需要检测极值位置，比如SIFT关键点检测、模板匹配获得最大响应位置、统计直方图峰值位置、边缘检测等等，有时只需要像素精度就可以，有时则需要亚像素精度。本文尝试总结几种常用的一维离散数据极值检测方法，几个算法主要来自论文《A Comparison of Algorithms for Subpixel Peak Detection》，加上自己的理解和推导。&lt;/p&gt;

&lt;p&gt;给定如下离散值，求其极值位置。可知125为观察极值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[[60, 80, 100, 120, 125, 105, 70, 55]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果这些离散值是从某个分布&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;中等间距采样获得，其真正的极值位置应位于120和125之间。&lt;/p&gt;
&lt;p&gt;下面给出形式化的定义：给定一组离散值，令&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为观测到的极值点位置，其值为&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;，其左右相邻位置的值为&lt;span class=&quot;math inline&quot;&gt;\(f(x-1)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(f(x+1)\)&lt;/span&gt;，真正的极值点位置为&lt;span class=&quot;math inline&quot;&gt;\(x+\delta\)&lt;/span&gt;，令&lt;span class=&quot;math inline&quot;&gt;\(\hat{\delta}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;的估计值。&lt;/p&gt;

&lt;p&gt;假设&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的邻域&lt;/strong&gt;可通过某个模型进行近似，如高斯近似、抛物线近似，则可以利用&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的邻域信息根据模型估计出极值。使用的模型不同就有不同的算法，具体如下。&lt;/p&gt;
&lt;h2 id=&quot;高斯近似&quot;&gt;高斯近似&lt;/h2&gt;
&lt;p&gt;一维&lt;a href=&quot;https://wiki2.org/en/Gaussian_function&quot;&gt;高斯函数&lt;/a&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[y = y_{max} \cdot exp(-\frac{(x-\mu)^2}{2\sigma^2})\]&lt;/span&gt;&lt;br/&gt;当&lt;span class=&quot;math inline&quot;&gt;\(y_{max}=\frac{1}{\sqrt{2\sigma}\pi}\)&lt;/span&gt;时为标准高斯函数，形如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180726/aEJ4LB516D.png?imageslim&quot; alt=&quot;标准高斯函数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的邻域可用高斯近似，用&lt;span class=&quot;math inline&quot;&gt;\((x, f(x))\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\((x-1, f(x-1))\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\((x+1, f(x+1))\)&lt;/span&gt;三点对高斯函数进行拟合，获得模型参数&lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt;即为峰值位置，&lt;span class=&quot;math inline&quot;&gt;\(\hat{\delta}=\mu - x\)&lt;/span&gt;。将三点带入上面的高斯函数两边同时取对数求得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta} = \frac{1}{2} \frac{\ln(f(x-1)) - \ln(f(x+1))}{\ln(f(x-1)) - 2\ln(f(x)) + \ln(f(x+1))}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面可以看到，&lt;strong&gt;高斯近似相当于取对数后的抛物线近似&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;抛物线近似&quot;&gt;抛物线近似&lt;/h2&gt;
&lt;p&gt;使用抛物线近似&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的局部，可以将&lt;span class=&quot;math inline&quot;&gt;\((x, f(x))\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\((x-1, f(x-1))\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\((x+1, f(x+1))\)&lt;/span&gt;三点带入&lt;span class=&quot;math inline&quot;&gt;\(y=a(x-b)^2+c\)&lt;/span&gt;求参数&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;即为估计的极值位置，也可采用&lt;a href=&quot;https://wiki2.org/en/Taylor_series&quot;&gt;泰勒展开&lt;/a&gt;（&lt;a href=&quot;https://wiki2.org/en/Newton%27s_method&quot;&gt;牛顿法&lt;/a&gt;）来求极值。泰勒公式实际上是一种利用高阶导数通过多项式近似函数的方法，下面的图示可直观理解这种近似，图示为通过泰勒公式近似原点附近的正弦曲线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180726/05jaDF46Ei.png?imageslim&quot; alt=&quot;泰勒近似正弦曲线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;泰勒近似&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;附近，如只取到二阶则为抛物线近似。假设高阶可导，极值为&lt;span class=&quot;math inline&quot;&gt;\(f(x+\delta)\)&lt;/span&gt;，则根据泰勒公式，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(x+\delta) = f(x) + f'(x)\delta + \frac{1}{2} f''(x)\delta^2 + O(\delta^3)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;极值处导数为0，这里&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为常数&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;为变量，两边同时对&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;求导，忽略高阶项可得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'(x+\hat{\delta}) = f'(x) + f''(x)\hat{\delta} = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用一阶微分和二阶微分近似&lt;span class=&quot;math inline&quot;&gt;\(f'(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(f''(x)\)&lt;/span&gt;得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta} = - \frac{f'(x)}{f''(x)} = - \frac{(f(x+1)-f(x-1))/2}{(f(x+1)-f(x))-(f(x) - f(x-1))}= \frac{1}{2}\frac{f(x-1)-f(x+1)}{f(x+1)-2f(x)+ f(x-1)}\]&lt;/span&gt;&lt;br/&gt;与带入抛物线求参数的结果是一致的，加上对数则与高斯近似一致。&lt;/p&gt;
&lt;h2 id=&quot;质心算法&quot;&gt;质心算法&lt;/h2&gt;
&lt;blockquote readability=&quot;8.3957597173145&quot;&gt;
&lt;p&gt;In physics, the &lt;strong&gt;center of mass&lt;/strong&gt; of a distribution of mass in space is &lt;strong&gt;the unique point where the weighted relative position of the distributed mass sums to zero&lt;/strong&gt;, or the point where if a force is applied it moves in the direction of the force without rotating.——&lt;a href=&quot;https://wiki2.org/en/Center_of_mass&quot;&gt;Center of mass wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180804/EKfff2AKjH.png?imageslim&quot; alt=&quot;质心&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若将&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(x-1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(x+1\)&lt;/span&gt;看成质点，将&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(f(x-1)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(f(x+1)\)&lt;/span&gt;看成质点的质量，则可以把质心作为极值的估计。根据质点相对质心位置的质量加权和为零，可求得质心位置。令&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;为质心坐标，&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;分别为质点质量和坐标，则&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个质点的质心满足&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{i=1}^n m_i(r_i - R) = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令&lt;span class=&quot;math inline&quot;&gt;\(M = \sum_{i=1}^n m_i\)&lt;/span&gt;，质心坐标为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[R = \frac{1}{M} \sum_{i=1}^n m_ir_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;带入得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x + \hat{\delta} = \frac{(x-1)f(x-1)+xf(x)+(x+1)f(x+1)}{f(x-1)+f(x)+f(x+1)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta} = \frac{f(x+1)-f(x-1)}{f(x-1)+f(x)+f(x+1)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上考虑的是3质点系统的质心，还可考虑5质点、7质点等，甚至考虑所有点。&lt;/p&gt;
&lt;h2 id=&quot;线性插值&quot;&gt;线性插值&lt;/h2&gt;
&lt;p&gt;这个模型假设在极值两侧是线性增长和线性下降的，且&lt;strong&gt;上升和下降的速度相同&lt;/strong&gt;，即&lt;span class=&quot;math inline&quot;&gt;\(y=kx+b\)&lt;/span&gt;，上升侧&lt;span class=&quot;math inline&quot;&gt;\(k&amp;gt;0\)&lt;/span&gt;，下降侧&lt;span class=&quot;math inline&quot;&gt;\(k&amp;lt;0\)&lt;/span&gt;，两者绝对值相同，可以利用这个性质求解极值位置。&lt;/p&gt;
&lt;p&gt;若&lt;span class=&quot;math inline&quot;&gt;\(f(x+1)&amp;gt;f(x-1)\)&lt;/span&gt;则极值位于&lt;span class=&quot;math inline&quot;&gt;\((x, x+1)\)&lt;/span&gt;之间，可列等式&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{f(x) - f(x-1)}{x-(x-1)} = \frac{f(x+\delta)-f(x)}{x+\delta - x} = \frac{f(x+\delta)-f(x+1)}{x+1-(x+\delta)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta}=\frac{1}{2}\frac{f(x+1)-f(x-1)}{f(x)-f(x-1)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同理，若&lt;span class=&quot;math inline&quot;&gt;\(f(x-1)&amp;gt;f(x+1)\)&lt;/span&gt;求得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta}=\frac{1}{2}\frac{f(x+1)-f(x-1)}{f(x)-f(x+1)}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;数值微分滤波&quot;&gt;数值微分滤波&lt;/h2&gt;
&lt;p&gt;这个方法是利用极值处导数为0的性质，&lt;strong&gt;在微分滤波结果上插值得到导数为0的位置&lt;/strong&gt;，因已知极值点在&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;附近，因此只需在&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;附近做微分和插值即可。插值时取极值点两侧正负值连线的过零点作为极值点的估计，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180804/6mB6BHEK76.png?imageslim&quot; alt=&quot;Linear interpolation of the peak position&quot;/&gt;&lt;/p&gt;
&lt;p&gt;论文&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=10782&quot;&gt;Real-time numerical peak detector&lt;/a&gt;中定义了4阶和8阶线性滤波器&lt;span class=&quot;math inline&quot;&gt;\([1, 1, 0, -1, -1]\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\([1,1,1,1,0,-1,-1,-1,-1]\)&lt;/span&gt;，对应的函数形式为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g_4(x)=f(x-2)+f(x-1)-f(x+1)-f(x+2)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g_8(x)=f(x-4)+f(x-3)+f(x-2)+f(x-1) \\ -f(x+1)-f(x+2)-f(x+3)-f(x+4)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2阶形式为&lt;span class=&quot;math inline&quot;&gt;\(g_2(x) = f(x-1) -f(x+1)\)&lt;/span&gt;，这些滤波器的表现与数值微分滤波器相似。&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(f(x+1)&amp;gt;f(x-1)\)&lt;/span&gt;时，极值点位于&lt;span class=&quot;math inline&quot;&gt;\((x, x+1)\)&lt;/span&gt;之间，&lt;span class=&quot;math inline&quot;&gt;\(g(x)&amp;lt;0\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(g(x+1)&amp;gt;0\)&lt;/span&gt;，极值点位置为&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(g(x+1)\)&lt;/span&gt;连线的过零点，通过斜率求得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta} = \frac{g(x)}{g(x+1)-g(x)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;若&lt;span class=&quot;math inline&quot;&gt;\(f(x-1)&amp;gt;f(x+1)\)&lt;/span&gt;，则&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\delta} = \frac{g(x-1)}{g(x-1)-g(x)} - 1\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这些数值极值检测方法均是先获取观测极值&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;及其邻域信息，然后综合邻域信息在各自的模型假设下通过插值估计出极值位置。&lt;/strong&gt;若能知道数值来自的真实分布，则直接拟合真实分布然后求极值即可，但往往我们并不知道真实的分布是什么，即使知道真实分布，有时为了快速计算，也会采取插值的方式来估计极值，毕竟偏差可接受效果足够好就可以了。应用时，为了抗噪可对数据先平滑然后求极值，具体采用何种方法可在准确和速度间权衡——所用模型与真实分布越相近自然越准确，如果实在不知道怎么选，就实践对比吧（因为我也不知道），毕竟伟大领袖教导过我们——&lt;strong&gt;实践是检验真理的唯一标准&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;个人博客地址：&lt;a href=&quot;https://blog.shinelee.me/2018/08-04-%E4%BA%9A%E5%83%8F%E7%B4%A0%E6%95%B0%E5%80%BC%E6%9E%81%E5%80%BC%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html&quot;&gt;亚像素数值极值检测算法总结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 09:53:00 +0000</pubDate>
<dc:creator>Mr-Lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shine-lee/p/9419388.html</dc:identifier>
</item>
<item>
<title>java8新特性（二）_lambda表达式 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9418961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9418961.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近一直找java8相关新特性的文章，发现都太没有一个连贯性，毕竟大家写博客肯定都有自己的侧重点，这里找到一本书，专门介绍java8新特性的，感觉大家可以看看《写给大忙人看的JavaSE8》.这里我会结合书中的知识以及网上的知识，对于java8 的新特性进行总结，当然我自己写的也会有自己的侧重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;java8为什么增加了函数式编程&quot;&gt;java8为什么增加了函数式编程&lt;/h3&gt;
&lt;p&gt;java作为一门面向对象的编程语言诞生于20世纪90年代。在当时，面向对象编程是软件开发的主流模式。&lt;/p&gt;
&lt;p&gt;由于最近在并发和事件驱动（或者称为“互动”）编程中的优势，函数式编程又逐渐变得重要起来。&lt;/p&gt;
&lt;p&gt;这并不意味着面向对象编程不好，相反，最终的趋势是将面向对象编程和函数编程结合起来。&lt;/p&gt;
&lt;p&gt;java8主要在原来面向对象的基础上增加了函数式编程的能力.&lt;/p&gt;
&lt;p&gt;函数式编程的语言我就了解过一个_Erlang,有兴趣的大家可以看看Erlang这门语言。比如消息中间件rabbitmq 就是采用erlang写的。只要用过erlang的一定知道坚强2002和阿里的余锋。还有再推荐一个博客为“没有开花的树”的博主。至少对我帮助蛮多的。（有点扯远了）&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用lambda表达式&quot;&gt;为什么要使用lambda表达式&lt;/h3&gt;
&lt;h4 id=&quot;lambda表达式的定义&quot;&gt;lambda表达式的定义&lt;/h4&gt;
&lt;p&gt;lambda表达式是一段可以传递的代码，因此它可以被执行一次或者多次。&lt;/p&gt;
&lt;h4 id=&quot;实战代码对比&quot;&gt;实战代码对比&lt;/h4&gt;
&lt;p&gt;之前我们要在另一个独立线程中执行一些逻辑时，通常会将代码放到一个实现Runnable接口的类的run方法中。如下面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Worker implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            System.out.println(&quot;doWork&quot; + i);
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        Worker worker = new Worker();
        new Thread(worker).start();

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的关键在于，run方法中包含了你希望在另一个线程中需要执行的代码。&lt;/p&gt;
&lt;p&gt;到现在为止，在java 中向其他代码传递一段代码并不是很容易的。你不得不构建一个属于某个类的对象，由它的某个方法来包含所需的代码。&lt;/p&gt;
&lt;p&gt;我们看看使用lambda表达式重写上面的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 1000; i++) {
                System.out.println(&quot;doWork&quot; + i);
            }
        }).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lambda表达式语法&quot;&gt;lambda表达式语法&lt;/h3&gt;
&lt;h4 id=&quot;一般语法&quot;&gt;一般语法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;(Type1 param1,Type2 params,...) -&amp;gt; {

    statment1;
    statment2;
    .....
    return statmentM;
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单参数语法&quot;&gt;单参数语法&lt;/h4&gt;
&lt;p&gt;可以省略前面的小括号，但是我一般都是带着&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;param1 -&amp;gt;{
    ...
    ...
    return ...;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单语句语法&quot;&gt;单语句语法&lt;/h4&gt;
&lt;p&gt;可以省略后面的大括号&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;param1 -&amp;gt; statment
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数式接口&quot;&gt;函数式接口&lt;/h3&gt;
&lt;p&gt;在java中有许多已有的接口都需要封装代码块，如Runnable。lambda表达式与这些接口都是向后兼容的。&lt;/p&gt;
&lt;p&gt;对于只包含一个抽象方法的接口，你可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里注意一点，大家都知道接口中的方法是抽象的。事实上，接口经常会重新声明Object类中的方法。如toString等 这些方法命名并不是抽象的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们看下Runnable的代码 源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Runnable {
    /**
     * When an object implementing interface &amp;lt;code&amp;gt;Runnable&amp;lt;/code&amp;gt; is used
     * to create a thread, starting the thread causes the object's
     * &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method to be called in that separately executing
     * thread.
     * &amp;lt;p&amp;gt;
     * The general contract of the method &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意有个@FunctionalInterface 注解，有2个作用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译器会检查标注该注解的实体，检查它是否是只包含一个抽象方法的接口。&lt;/li&gt;
&lt;li&gt;在jacadoc页面也会包含一条声明，说明这个接口是一个函数式接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是这个注解并不是强制使用，从概念上讲，所有只含有一个抽象方法的接口都是函数式接口，但是使用@FunctionalInterface 注解会让你的代码更加清楚，毕竟代码的可读性是编程的第一规范。&lt;/p&gt;
&lt;h3 id=&quot;方法引用&quot;&gt;方法引用&lt;/h3&gt;
&lt;p&gt;有时候，你想要传递给其他代码的操作已经有实现的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class or instance :: method&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(x) -&amp;gt;  System.out.println(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就等同于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; System.out::println;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造器引用&quot;&gt;构造器引用&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;构造器引用同方法引用类似,不同的是在构造器引用中方法名是 new.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于拥有多个构造器的类,选择使用哪个构造器取决于上下文&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Class :: new&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;变量作用域&quot;&gt;变量作用域&lt;/h3&gt;
&lt;p&gt;外部变量在 lambda 表达式引用时，jdk 8 编译器会隐式做为 final 来处理&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 08:19:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9418961.html</dc:identifier>
</item>
</channel>
</rss>