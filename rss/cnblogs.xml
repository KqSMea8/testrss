<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基础拾遗-----mongoDB操作 - 王延领</title>
<link>http://www.cnblogs.com/kmonkeywyl/p/7865976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kmonkeywyl/p/7865976.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/6054335.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;基础拾遗------特性详解&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5726035.html&quot; target=&quot;_blank&quot;&gt;基础拾遗------webservice详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5728062.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;基础拾遗------redis详解&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5632911.html&quot; target=&quot;_blank&quot;&gt;基础拾遗------反射详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5688939.html&quot; target=&quot;_blank&quot;&gt;基础拾遗------委托详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5659217.html&quot; target=&quot;_blank&quot;&gt;基础拾遗------接口详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/5632677.html&quot; target=&quot;_blank&quot;&gt;基础拾遗------泛型详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/7795445.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;基础拾遗-----依赖注入&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/7802124.html%20&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;基础拾遗-----数据注解与验证&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kmonkeywyl/p/6080575.html%20&quot; target=&quot;_blank&quot;&gt;基础拾遗-----mongoDB操作&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　nosq互联网中运用极广的技术，mongo应该算是必不可少的技术之一，虽说我在项目中redis用的较多，mongo在项目中算是用的比较少的技术，但是也在以前的技术总监的要求下了解了一些先关的东西，但不够深入，只是简单的了解了一下，对它只是处于了解使用阶段，以下简单的把自己了解的东西介绍一下，其中类库是我们总监的编写了，再次仅作为记入。（虽说已经从原总监那离开好久，但是整体说来他的技术依然还是我见过最全面，最厉害的。在这页感谢那段时间对我的教导吧。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/688939/201711/688939-20171120141341680-998697577.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;378&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.1增加MongoDB密码&lt;/h2&gt;
&lt;div id=&quot;article_content&quot; class=&quot;article_content&quot; readability=&quot;77&quot;&gt;
&lt;h4&gt;1.1.1、给mongo添加权限认证&lt;/h4&gt;
&lt;p&gt;1、启动mongod， 非认证状态启动&lt;/p&gt;
&lt;p&gt;2、登录mongo&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;use admin
&lt;/span&gt;&amp;gt;db.createUser({user:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,pwd:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,roles:[{role:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userAdminAnyDatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,db:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}]})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/**不执行下面三句的话，只能mongo命令行可以访问，第三方程序无法访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;var&lt;/span&gt; schema = db.system.version.findOne({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authSchema&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}) 
&lt;/span&gt;&amp;gt;schema.currentVersion = &lt;span&gt;3&lt;/span&gt; 
&amp;gt;db.system.version.save(schema) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;use 你的DB名   --&amp;gt; 这点很重要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;db.createUser({user:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,pwd:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,roles:[{role:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;readWrite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,db:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的DB名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}]})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、修改mongo配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#auth = true  ----&amp;gt;  去掉#即可
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成。&lt;/p&gt;
&lt;h4&gt;1.1.2。新建DB或者给已有DB添加用户&lt;/h4&gt;
&lt;p&gt;1、可以用admin登录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;mongo localhost\admin -u admin -p 123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上面相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;var schema = db.system.version.findOne({&quot;_id&quot; : &quot;authSchema&quot;&lt;span&gt;}) 
&amp;gt;schema.currentVersion = 3 
&amp;gt;&lt;span&gt;db.system.version.save(schema) 
&amp;gt;&lt;span&gt;use 你的DB
&amp;gt;db.createUser({user:&quot;user&quot;,pwd:&quot;123456&quot;,roles:[{role:&quot;readWrite&quot;,db:&quot;你的DB名&quot;}]})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.1.3.登录查看&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;mongo登录

&amp;gt;&lt;span&gt;use admin

&amp;gt;db.auth(&quot;user&quot;,&quot;123456&quot;&lt;span&gt;)

&amp;gt;&lt;span&gt;use 你的DB名

&amp;gt;show collections;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;1.2.webconfig的配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;connectionStrings&amp;gt;
 &amp;lt;add name=&quot;TestDBContext&quot; connectionString=&quot;mongodb://user:pwd@ip:27017/TestMongo&quot;/&amp;gt;
&amp;lt;/connectionStrings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;csharp string&quot;&gt;其中TestMongo为mongo文件，不用考虑路径什么的，安装mongo的时候已经在服务里映射到。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;line number3 index2 alt2&quot; readability=&quot;6.5&quot;&gt;
&lt;h2&gt;1.3gloal实例化&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            MongoDBRepository.RegisterMongoDBContext(new TestDBContext());
            MongoDBRepository.RegisterMongoIndex();
&lt;/pre&gt;&lt;/div&gt;

&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;此上下文注册和ef操作类似，其中Student为上下文实例。请把要操作的实例实例化此处，便于后边操作。&lt;/p&gt;
&lt;div class=&quot;line number3 index2 alt2&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;MongoDBRepository.RegisterMongoIndex();是用来实例化索引的，需要添加所以的的字段需要表示一下特性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  [AttributeUsage(AttributeTargets.Property |&lt;span&gt; AttributeTargets.Field)]
    public class&lt;span&gt; BsonIndexAttribute : Attribute
    {
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  public class&lt;span&gt; Student : Entity
    {
        [BsonIndex]
        public string Name { get; set&lt;span&gt;; }
        public int Age { get; set&lt;span&gt;; }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;2.1。基本操作&lt;/h2&gt;
&lt;div class=&quot;line number3 index2 alt2&quot; readability=&quot;70.754399304801&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; Student : Entity
{
    public string Name { get; set&lt;span&gt;; }
    public int Age { get; set&lt;span&gt;; }
}
public class&lt;span&gt; TestDBContext : MongoDBContext
{
　　　//TestDBContext即配置文件中的节点的名称
    public TestDBContext() : base(&quot;TestDBContext&quot;&lt;span&gt;) { }
 
    public override void&lt;span&gt; OnRegisterModel(ITypeRegistration registration)
    {
        registration.RegisterType&amp;lt;Student&amp;gt;();//在上下文中注册可用的实例
&lt;span&gt;    }
}
    public void&lt;span&gt; Setup()
    {
        MongoDBRepository.RegisterMongoDBContext(new TestDBContext());//注册上下文
        Student student = new&lt;span&gt; Student();
        student.Name = &quot;wyl&quot;&lt;span&gt;;
        student.Age = 26&lt;span&gt;;
        student.Save();//保存当前实例到数据库
        student.Remove()//删除当前实例
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TestDBContext为上面的配置文件。&lt;/h2&gt;
&lt;p&gt;以下利用lamdam表达式的操作，自行领会&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
//获取实例
  var stud = Entity.Get&amp;lt;Student&amp;gt;&lt;span&gt;(student.Id);
var stud = Entity.Get&amp;lt;Student&amp;gt;(s=&amp;gt;s.Age==&quot;wyl&quot;);&amp;lt;br&amp;gt;
  //分页查询
  var querable = Entity.Select&amp;lt;Student&amp;gt;(s =&amp;gt; s.Age &amp;gt;= 19 &amp;amp;&amp;amp; s.Age &amp;lt;= 22, s =&amp;gt; s.Age, 1, 2, out pageCount, out&lt;span&gt; allCount).ToList();
 
  //批量删除
  Entity.RemoveAll&amp;lt;Student&amp;gt;(e =&amp;gt; e.Name == &quot;wyl&quot;&lt;span&gt;);
 
  //批量保存
  Entity.Save(new List&amp;lt;Student&amp;gt;&lt;span&gt;() {
              new Student{ Name=&quot;wyl&quot;, Age=33&lt;span&gt; },
              new Student{ Name=&quot;kmonkey&quot;, Age=30&lt;span&gt; }
          });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2.Mongo之DBRef关联操作&lt;/h2&gt;
&lt;p&gt;MongoDB对一对一，一对多，多对多关系的维护，官方文件建议用文档嵌套的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  public class&lt;span&gt; Student : Entity
    {
        public string Name { get; set&lt;span&gt;; }
        public int Age { get; set&lt;span&gt;; }
    }

    public class&lt;span&gt; Teacher : Entity
    {
        public string Name { get; set&lt;span&gt;; }
        public int Age { get; set&lt;span&gt;; }
    }

    public class&lt;span&gt; Master: RefEntity
    {
        public string Name { get; set&lt;span&gt;; }
    }    
    public class&lt;span&gt; School : Entity
    {
        public string Name { get; set&lt;span&gt;; }
        public List&amp;lt;MongoDBRef&amp;gt; Students { get; set&lt;span&gt;; }
        public List&amp;lt;MongoDBRef&amp;gt; Teachers { get; set&lt;span&gt;; }
        public MongoDBRef Master { get; set&lt;span&gt;; }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上案例：最终的记过就是&lt;span&gt;Master，&lt;span&gt;Teacher ，&lt;span&gt;Student 会被包含在&lt;span&gt;School 内，但是&lt;span&gt;Teacher ，&lt;span&gt;Student 老师并没有什么关联字段。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大致存储内容如下（手敲的结果，希望能看的懂）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{shcool:&quot;_id&quot;:&quot;342342345234rtwe5345&quot;,&quot;name&quot;:&quot;河南大学&quot;，Student：[{&quot;_id&quot;:&quot;s423423423&quot;,&quot;name&quot;:&quot;wyl&quot;,&quot;age&quot;:&quot;26&quot;}],&quot;Teacher&quot;:[{&quot;_id&quot;:&quot;34345345&quot;}......],&quot;Mater&quot;[{“id”:“4453453453”...........}]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是有没有发现一个问题，所有的学生和老师在同一个集合当中，但是老师和学生并没有集合，那么我们如果要查老师的集合或者学生的集合是不是麻烦的要死，我说的什么名表吗？select * from Teachets/Students。有人说我们可以件学生老师的对象，那样一对多的关系就在monggo文档中体现不出来了。&lt;/p&gt;
&lt;p&gt;那怎么解决呢？&lt;/p&gt;
&lt;p&gt;在类库中&lt;span&gt;IDBRefContainer接口是对其的封装。远离就是在shcool查询Student。这不是废话吗？是的不过如果有更好的方法可以提出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码 &lt;span class=&quot;cnblogs_code&quot;&gt;school.Pick&amp;lt;Student&amp;gt;(l=&amp;gt;l.name=&quot;wyl&quot;) 的形式。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3.MongoDB GridFS&lt;/h2&gt;
&lt;p&gt;1.GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。&lt;/p&gt;
&lt;p&gt;2.GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。&lt;/p&gt;
&lt;p&gt;3.GridFS 可以更好的存储大于16M的文件。&lt;/p&gt;
&lt;p&gt;4.GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。&lt;/p&gt;
&lt;p&gt;5.GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。&lt;/p&gt;
&lt;p&gt;6.每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。&lt;/p&gt;
&lt;p&gt;此接口在类库IMongoFile中：&lt;/p&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
  public void&lt;span&gt; CreateFileTestCase()
        {
            //加载本地文件，并实例一个IMongoFile
            IMongoFile file = MongoEntity.CreateFile&amp;lt;MyFile&amp;gt;(@&quot;c:\pic1.jpg&quot;, &quot;pic2.jpg&quot;, &quot;jpg&quot;&lt;span&gt;);

            //下载文件，等同于文件另存为 
            file.Download(@&quot;c:\beforesave.jpg&quot;&lt;span&gt;);

            //文件保存至数据库 
&lt;span&gt;            file.Save();

            //从数据中加载刚才保存的文件
            IMongoFile fs = MongoEntity.LoadFile&amp;lt;MyFile&amp;gt;&lt;span&gt;(file.Id);

            //将从数据中加载的文件下载
            fs.Download(@&quot;c:\aftersave.jpg&quot;&lt;span&gt;);

            //根据数据库中的文件名检索文件
            var files = MongoEntity.LoadAllFiles&amp;lt;MyFile&amp;gt;(&quot;pic2.jpg&quot;&lt;span&gt;);

            //根据文件id，将数据库中的文件下载到本地
            MongoEntity.DownloadFile&amp;lt;MyFile&amp;gt;(file.Id, @&quot;c:\copy.jpg&quot;&lt;span&gt;);

            Assert.AreEqual(file.Id, fs.Id);
            Assert.AreEqual(1&lt;span&gt;, files.Count);
            Assert.AreEqual(file.Id, files[0&lt;span&gt;].Id);
            Assert.IsNull(file.MD5);
            Assert.IsNotNull(fs.MD5);
            Assert.AreEqual(file.Size, fs.Size);
            Assert.AreEqual(file.Data, fs.Data);
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 源码地址：&lt;a href=&quot;https://github.com/kmonkey9006/MongoDB.Framework&quot; target=&quot;_blank&quot;&gt;https://github.com/kmonkey9006/MongoDB.Framework&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 20 Nov 2017 06:00:00 +0000</pubDate>
<dc:creator>王延领</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kmonkeywyl/p/7865976.html</dc:identifier>
</item>
<item>
<title>JavaScript中的内存泄漏以及如何处理 - 葡萄城控件技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/how-javascript-works-memory-management.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/how-javascript-works-memory-management.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;随着现在的编程语言功能越来越成熟、复杂，内存管理也容易被大家忽略。本文将会讨论JavaScript中的内存泄漏以及如何处理，方便大家在使用JavaScript编码时，更好的应对内存泄漏带来的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;像C语言这样的编程语言，具有简单的内存管理功能函数，例如malloc( )和free( )。开发人员可以使用这些功能函数来显式地分配和释放系统的内存。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当创建对象和字符串等时，JavaScript就会分配内存，并在不再使用时自动释放内存，这种机制被称为垃圾收集。这种释放资源看似是“自动”的，但本质是混淆的，这也给JavaScript（以及其他高级语言）的开发人员产生了可以不关心内存管理的错误印象。&lt;strong&gt;其实这是一个大错误。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;即使使用高级语言，开发人员也应该理解内存管理的知识。有时自动内存管理也会存在问题（例如垃圾收集器中的错误或实施限制等），开发人员必须了解这些问题才能正确地进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;无论你使用的是什么编程语言，内存生命周期几乎都是一样的：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120114302040-1222119677.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;以下是对内存生命周期中每个步骤发生的情况的概述：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;分配内存&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt; - 内存由操作系统分配，允许程序使用它。在简单的编程语言中，这个过程是开发人员应该处理的一个显式操作。然而，在高级编程语言中，系统会帮助你完成这个操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;内存使用&lt;/strong&gt; -&lt;strong&gt; &lt;/strong&gt; 这是程序使用之前申请内存的时间段，你的代码会通过使用分配的变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;来对内存进行读取和写入操作。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;释放内存&lt;/strong&gt;  - 对于不再需要的内存进行释放的操作，以便确保其变成空闲状态并且可以被再次使用。与分配内存操作一样，这个操作在简单的编程语言中是需要显示操作的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在硬件层面上，计算机的内存由大量的触发器组成的。每个触发器包含一些晶体管，并能够存储一位数据。单独的触发器可以通过唯一的标识符来寻址，所以我们可以读取和覆盖它们。因此，从概念上讲，我们可以把整个计算机内存看作是我们可以读写的一大块空间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;很多东西都存储在内存中：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;程序使用的所有变量和其他数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;程序的代码，包括操作系统的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;编译器和操作系统一起工作，来处理大部分的内存管理，但是我们需要了解从本质上发生了什么。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;编译代码时，编译器会检查原始数据类型，并提前计算它们需要多少内存，然后将所需的内存分配给调用堆栈空间中的程序。分配这些变量的空间被称为堆栈空间，随着函数的调用，内存会被添加到现有的内存之上。当终止时，空间以LIFO（后进先出）顺序被移除。例如如下声明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; n; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4个字节&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; x [&lt;span&gt;4&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4个元素的数组，每一个占4个字节&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; m; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8个字节&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;编译器插入与操作系统进行交互的代码，以便在堆栈中请求所需的字节数来存储变量。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在上面的例子中，编译器知道每个变量的确切内存地址。实际上，每当我们写入这个变量n，它就会在内部翻译成“内存地址4127963”。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;注意，如果我们试图访问x[4]，我们将访问与m关联的数据。这是因为我们正在访问数组中不存在的元素 - 它比数组中最后一个数据实际分配的元素多了4个字节x[3]，并且可能最终读取（或覆盖）了一些m比特。这对其余部分会产生不利的后果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120114559524-910325934.png&quot; alt=&quot;&quot; width=&quot;837&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当函数调用其它函数时，每个函数被调用时都会得到自己的堆栈块。它会保留所有的局部变量和一个程序计数器，还会记录执行的地方。当功能完成时，其内存块会被释放，可以再次用于其它目的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如若我们不知道编译时，变量需要的内存数量时，事情就会变得复杂。假设我们想要做如下事项：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; n = readInput（）; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取用户的输入&lt;/span&gt;
&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用“n”个元素创建一个数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在编译时，编译器不知道数组需要多少内存，因为它是由用户提供的输入值决定的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;因此，它不能为堆栈上的变量分配空间。相反，我们的程序需要在运行时明确地向操作系统请求适当的空间。这个内存是从堆空间分配的。下表总结了静态和动态内存分配之间的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120114707836-1204603160.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;现在来解释如何在JavaScript中分配内存。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;JavaScript使得开发人员免于处理内存分配的工作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; n = &lt;span&gt;374&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates memory for a number&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sessionstack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates memory for a string&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; o =&lt;span&gt; {
  a: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  b: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
}; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates memory for an object and its contained values&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; a = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (like object) allocates memory for the
                           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; array and its contained values&lt;/span&gt;
&lt;span&gt;
function f(a) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates a function (which is a callable object)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function expressions also allocate an object&lt;/span&gt;
someElement.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function() {
  someElement.style.backgroundColor &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一些函数调用也会导致对象分配：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; d = &lt;span&gt;new&lt;/span&gt; Date(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates a Date object&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; e = document.createElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; allocates a DOM element&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方法可以分配新的值或对象：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; s1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sessionstack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s2 = s1.substr(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; s2 is a new string
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Since strings are immutable, 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JavaScript may decide to not allocate memory, 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; but just store the [0, 3] range.&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; a1 = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;str1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a2 = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;str3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a3 =&lt;span&gt; a1.concat(a2); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new array with 4 elements being
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the concatenation of a1 and a2 elements&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;基本上在JavaScript中使用分配的内存，意味着在其中读写。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这可以通过读取或写入变量或对象属性的值，或者甚至将参数传递给函数来完成。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;大部分内存泄漏问题都是在这个阶段产生的，这个阶段最难的问题就是确定何时不再需要已分配的内存。它通常需要开发人员确定程序中的哪个部分不再需要这些内存，并将其释放。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;高级语言嵌入了一个名为垃圾收集器的功能，其工作是跟踪内存分配和使用情况，以便在不再需要分配内存的情况下自动释放内存。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;不幸的是，这个过程无法做到那么准确，因为像某些内存不再需要的问题是不能由算法来解决的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;大多数垃圾收集器通过收集不能被访问的内存来工作，例如指向它的变量超出范围的这种情况。然而，这种方式只能收集内存空间的近似值，因为在内存的某些位置可能仍然有指向它的变量，但它却不会被再次访问。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;由于确定一些内存是否“不再需要”，是不可判定的，所以垃圾收集机制就有一定的局限性。下面将解释主要垃圾收集算法及其局限性的概念。&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;垃圾收集算法所依赖的主要概念之一就是内存引用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在内存管理情况下，如果一个对象访问变量（可以是隐含的或显式的），则称该对象引用另一个对象。例如，JavaScript对象具有对其原对象（隐式引用）及其属性值（显式引用）的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在这种情况下，“对象”的概念扩展到比普通JavaScript对象更广泛的范围，并且还包含函数范围。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这是最简单的垃圾收集算法。如果有零个引用指向它，则该对象会被认为是“垃圾收集” 。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;看看下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; o1 =&lt;span&gt; {
  o2: {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 objects are created. 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'o2' is referenced by 'o1' object as one of its properties.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; None can be garbage-collected&lt;/span&gt;


&lt;span&gt;var&lt;/span&gt; o3 = o1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the 'o3' variable is the second thing that 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; has a reference to the object pointed by 'o1'.&lt;/span&gt;
&lt;span&gt;
                                                       
o1 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; now, the object that was originally in 'o1' has a         
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; single reference, embodied by the 'o3' variable&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; o4 = o3.o2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reference to 'o2' property of the object.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This object has now 2 references: one as
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a property. 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The other as the 'o4' variable&lt;/span&gt;
&lt;span&gt;
o3 &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The object that was originally in 'o1' has now zero
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; references to it. 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It can be garbage-collected.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; However, what was its 'o2' property is still
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; referenced by the 'o4' variable, so it cannot be
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; freed.&lt;/span&gt;
&lt;span&gt;
o4 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; what was the 'o2' property of the object originally in
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'o1' has zero references to it. 
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It can be garbage collected.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在周期方面有一个限制。例如下面的例子，创建两个对象并相互引用，这样会创建一个循环引用。在函数调用之后，它们将超出范围，所以它们实际上是无用的，可以被释放。然而，引用计数算法认为，由于两个对象中的每一个都被引用至少一次，所以两者都不能被垃圾收集机制收回。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function f() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o1 =&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o2 =&lt;span&gt; {};
  o1.p &lt;/span&gt;= o2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; o1 references o2&lt;/span&gt;
  o2.p = o1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; o2 references o1. This creates a cycle.&lt;/span&gt;
&lt;span&gt;}

f( );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120115004915-62677357.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p align=&quot;left&quot;&gt;&lt;span&gt;为了决定是否需要对象，标记和扫描算法会确定对象是否是活动的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;标记和扫描算法经过以下3个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;roots：通常，root是代码中引用的全局变量。例如，在JavaScript中，可以充当root的全局变量是“窗口”对象。Node.js中的相同对象称为“全局”。所有root的完整列表由垃圾收集器构建。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后算法会检查所有root和他们的子对象并且标记它们是活动的（即它们不是垃圾）。任何root不能达到的，将被标记为垃圾。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最后，垃圾回收器释放所有未标记为活动的内存块，并将该内存返回给操作系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120115052211-360802438.gif&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这个算法比引用计数垃圾收集算法更好。JavaScript垃圾收集（代码/增量/并发/并行垃圾收集）领域中所做的所有改进都是对这种标记和扫描算法的实现改进，但不是对垃圾收集算法本身的改进。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在上面的相互引用例子中，在函数调用返回之后，两个对象不再被全局对象可访问的对象引用。因此，它们将被垃圾收集器发现，从而进行收回。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/139239/201711/139239-20171120115257649-2068824765.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;318&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;即使在对象之间有引用，它们也不能从root目录中访问，从而会被认为是垃圾而收集。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;尽管垃圾收集器使用起来很方便，但它们也有自己的一套标准，其中之一是非决定论。换句话说，垃圾收集是不可预测的。你不能真正知道什么时候进行收集，这意味着在某些情况下，程序会使用更多的内存，虽然这是实际需要的。在其它情况下，在特别敏感的应用程序中，短暂暂停是很可能出现的。尽管非确定性意味着不能确定何时进行集合，但大多数垃圾收集实现了共享在分配期间进行收集的通用模式。如果没有执行分配，大多数垃圾收集会保持空闲状态。如以下情况：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;大量的分配被执行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大多数这些元素（或所有这些元素）被标记为无法访问（假设我们将一个引用指向不再需要的缓存）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;没有进一步的分配执行。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在这种情况下，大多数垃圾收集不会做出任何的收集工作。换句话说，即使有不可用的引用需要收集，但是收集器不会进行收集。虽然这并不是严格的泄漏，但仍会导致内存使用率高于平时。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;内存泄漏是应用程序使用过的内存片段，在不再需要时，不能返回到操作系统或可用内存池中的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;编程语言有各自不同的内存管理方式。但是是否使用某一段内存，实际上是一个不可判定的问题。换句话说，只有开发人员明确的知道是否需要将一块内存返回给操作系统。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;：全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;JavaScript以一种有趣的方式来处理未声明的变量：当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window，这意味着&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function foo(arg) {
    bar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;some text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相当于：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function foo(arg) {
    window.bar &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;some text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;bar只是foo函数中引用一个变量。如果你不使用var声明，将会创建一个多余的全局变量。在上述情况下，不会造成很大的问题。但是，如若是下面的这种情况。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;你也可能不小心创建一个全局变量this：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function foo() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.var1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;potential accidental global&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Foo called on its own, this points to the global object (window)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rather than being undefined.&lt;/span&gt;
foo( );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你可以通过在JavaScript文件的开始处添加‘use strict’;来避免这中错误，这种方式将开启严格的解析JavaScript模式，从而防止意外创建全局变量。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;意外的全局变量当然是一个问题。更多的时候，你的代码会受到显式的全局变量的影响，而这些全局变量在垃圾收集器中是无法收集的。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，那么确保将其分配为空值，或者在完成后重新分配。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;：被遗忘的定时器或回调&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;下面列举setInterval的例子，这也是经常在JavaScript中使用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;对于提供监视的库和其它接受回调的工具，通常在确保所有回调的引用在其实例无法访问时，会变成无法访问的状态。但是下面的代码却是一个例外：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; serverData =&lt;span&gt; loadData();
setInterval(function() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; renderer = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;renderer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(renderer) {
        renderer.innerHTML &lt;/span&gt;=&lt;span&gt; JSON.stringify(serverData);
    }
}, &lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;This will be executed every ~5 seconds.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的代码片段显示了使用引用节点或不再需要的数据的定时器的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;该renderer对象可能会在某些时候被替换或删除，这会使interval处理程序封装的块变得冗余。如果发生这种情况，那么处理程序及其依赖项都不会被收集，因为interval需要先停止。这一切都归结为存储和处理负载数据的serverData不会被收集的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;当使用监视器时，你需要确保做了一个明确的调用来删除它们。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当被监测对象变得无法访问，它们就会自动收集监测处理器。这是过去的一些浏览器无法处理的情况（例如旧的IE6）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;看下面的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; element = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;launch-button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; counter = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

function onClick(&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;) {
   counter&lt;/span&gt;++&lt;span&gt;;
   element.innerHtml &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; counter;
}

element.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do stuff&lt;/span&gt;
&lt;span&gt;
element.removeEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);
element.parentNode.removeChild(element);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now when element goes out of scope,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; both element and onClick will be collected even in old browsers &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; that don't handle cycles well.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于现代浏览器支持垃圾回收机制，所以当某个节点变的不能访问时，你不再需要调用removeEventListener，因为垃圾回收机制会恰当的处理这些节点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如果你正在使用jQueryAPI（其他库和框架也支持这一点），那么也可以在节点不用之前删除监听器。即使应用程序在较旧的浏览器版本下运行，库也会确保没有内存泄漏。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;：闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;JavaScript开发的一个关键方面是闭包。闭包是一个内部函数，可以访问外部（封闭）函数的变量。由于JavaScript运行时的实现细节，可能存在以下形式泄漏内存：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; theThing = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; replaceThing =&lt;span&gt; function（）{

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; originalThing =&lt;span&gt; theThing; 
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; unused =&lt;span&gt; function（）{ 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;（originalThing）&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对'originalThing'的引用&lt;/span&gt;
&lt;span&gt;      console.log（“hi”）; 
  };

  theThing &lt;/span&gt;=&lt;span&gt; { 
    longStr：&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Array（&lt;span&gt;1000000&lt;/span&gt;）.join（&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;），
    someMethod：function（）{ 
      console.log（“message”）; 
    } 
  }; 
};

setInterval（replaceThing，&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;）;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一旦replaceThing被调用，theThing会获取由一个大数组和一个新的闭包（someMethod）组成的新对象。然而，originalThing会被unused变量所持有的闭包所引用（这是theThing从以前的调用变量replaceThing）。需要记住的是，一旦在同一父作用域中为闭包创建了闭包的作用域，作用域就被共享了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在这种情况下，闭包创建的范围会将someMethod共享给unused。然而，unused有一个originalThing引用。即使unused从未使用过，someMethod 也可以通过theThing在整个范围之外使用replaceThing。而且someMethod通过unused共享了闭包范围，unused必须引用originalThing以便使其它保持活跃（两封闭之间的整个共享范围）。这就阻止了它被收集。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;所有这些都可能导致相当大的内存泄漏。当上面的代码片段一遍又一遍地运行时，你会看到内存使用率的不断上升。当垃圾收集器运行时，其内存大小不会缩小。这种情况会创建一个闭包的链表，并且每个闭包范围都带有对大数组的间接引用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;：超出DOM引用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在某些情况下，开发人员会在数据结构中存储DOM节点，例如你想快速更新表格中的几行内容的情况。如果在字典或数组中存储对每个DOM行的引用，则会有两个对同一个DOM元素的引用：一个在DOM树中，另一个在字典中。如果你不再需要这些行，则需要使两个引用都无法访问。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; elements =&lt;span&gt; {
    button: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    image: document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
};

function doStuff() {
    elements.image.src &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://example.com/image_name.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}

function removeImage() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The image is a direct child of the body element.&lt;/span&gt;
    document.body.removeChild(document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; At this point, we still have a reference to #button in the
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;global elements object. In other words, the button element is
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;still in memory and cannot be collected by the GC.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在涉及DOM树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（标签）的引用，并决定从DOM中删除该表格，还需要保留对该特定单元格的引用，则可能会出现严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元之外的所有东西，但情况并非如此。由于单元格是表格的一个子节点，并且子节点保留着对父节点的引用，所以对表格单元格的这种引用，会将整个表格保存在内存中。&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;span&gt;以上内容是对JavaScript内存管理机制的讲解，以及常见的四种内存泄漏的分析。希望对JavaScript的编程人员有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原文链接：https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;转载请注明出自：葡萄城控件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.grapecity.com.cn/enterprise-solutions/activereports_server/library/&quot; target=&quot;_blank&quot;&gt;【报表福利大放送】100余套报表模板免费下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;post_title_link_7722088&quot; href=&quot;http://www.cnblogs.com/powertoolsteam/p/shorthand-javascript.html&quot;&gt;JavaScript 开发人员需要知道的简写技巧&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/wijmo_spec.html&quot; target=&quot;_blank&quot;&gt;1分钟选好最合适你的JavaScript框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/powertoolsteam/p/top_10_JavaScript_edit.html&quot; target=&quot;_blank&quot;&gt;Top 10 JavaScript编辑器，你在用哪个？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 04:06:00 +0000</pubDate>
<dc:creator>葡萄城控件技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/how-javascript-works-memory-management.html</dc:identifier>
</item>
<item>
<title>“天龙八步”细说浏览器输入URL后发生了什么 - 雪融无痕</title>
<link>http://www.cnblogs.com/webdeve/p/7865520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webdeve/p/7865520.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_960d0e5be8aeb306374ed3de2386da09&amp;amp;t=gif&amp;amp;o=&amp;amp;s=&amp;amp;v=1510794252&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint lang-js&quot;&gt;
本文摘要：
1.DNS域名解析；
2.建立TCP连接；
3.发送HTTP请求；
4.服务器处理请求；
5.返回响应结果；
6.关闭TCP连接；
7.浏览器解析HTML；
8.浏览器布局渲染；
总结
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_1dc9c46af00bdf09321b9f45f416d2b8&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147636&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;p&gt;输入网址&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当我们在浏览器输入网址并回车后，一切从这里开始。&lt;/p&gt;
&lt;h3&gt;一、DNS域名解析&lt;/h3&gt;
&lt;p&gt;我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。&lt;/p&gt;
&lt;p&gt;客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_30e8bb3698b452378b01c28af7ae65dd&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147724&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;250&quot; align=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DNS服务器层次结构&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img title=&quot;&quot; src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_bcf7489d5afe7dfd2771a5285bd08a6c&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147775&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;356&quot; align=&quot;&quot;/&gt; &lt;/div&gt;
&lt;p&gt;浏览器客户端向本地DNS服务器发送一个含有域名www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;从客户端到本地服务器属于&lt;strong&gt;递归查询&lt;/strong&gt;，而DNS服务器之间的交互属于&lt;strong&gt;迭代查询&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;二、建立TCP链接&lt;/h3&gt;
&lt;p&gt;费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_de268246c246d388ffb8f0f1c6a7f95c&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147842&quot; alt=&quot;&quot;/&gt;&lt;p&gt;三次握手&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。&lt;/p&gt;
&lt;p&gt;上图也可以这么理解：&lt;/p&gt;
&lt;p&gt;客户端：“你好，在家不，有你快递。”&lt;/p&gt;
&lt;p&gt;服务端：“在的，送来就行。”&lt;/p&gt;
&lt;p&gt;客户端：“好嘞。”&lt;/p&gt;
&lt;h3&gt;三、发送HTTP请求&lt;/h3&gt;
&lt;p&gt;与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_006b5abbcc97dae541d478ca88888320&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147906&quot; alt=&quot;&quot;/&gt;&lt;p&gt;请求报文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在浏览器中查看报文首部（以google浏览器为例）：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_8b148bd4156b50ff72f57ad93b51dd0e&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147944&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。&lt;/p&gt;
&lt;h3&gt;四、服务器处理请求&lt;/h3&gt;
&lt;p&gt;服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_cb100084d3a99618a25eda16bb739daf&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147960&quot; alt=&quot;&quot;/&gt;&lt;p&gt;服务器处理请求&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;五、返回响应结果&lt;/h3&gt;
&lt;p&gt;在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_6d8d70fbb7fc1c6b5dc2ed3eecd75281&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511147979&quot; alt=&quot;&quot;/&gt;&lt;p&gt;响应报文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。&lt;/p&gt;
&lt;p&gt;状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_fe6a06dd343b55123a5a47d441638b78&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511148002&quot; alt=&quot;&quot;/&gt;&lt;p&gt;状态码类别&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;六、关闭TCP连接&lt;/h3&gt;
&lt;p&gt;为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_807cf81f3bfd12250ade1d2f7e75773e&amp;amp;t=png&amp;amp;o=&amp;amp;s=&amp;amp;v=1511148020&quot; alt=&quot;&quot;/&gt;&lt;p&gt;4次握手&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;上图可以这么理解：&lt;/p&gt;
&lt;p&gt;客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”&lt;/p&gt;
&lt;p&gt;服务端：“收到，我看看我这边有木有数据了。”&lt;/p&gt;
&lt;p&gt;服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”&lt;/p&gt;
&lt;p&gt;客户端：“好嘞。”&lt;/p&gt;
&lt;h3&gt;七、浏览器解析HTML&lt;/h3&gt;
&lt;p&gt;准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。&lt;/p&gt;

&lt;p&gt;浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。&lt;/p&gt;
&lt;p&gt;要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。&lt;/p&gt;
&lt;h3&gt;八、浏览器布局渲染&lt;/h3&gt;
&lt;p&gt;根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。&lt;/p&gt;
&lt;p&gt;reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。&lt;/p&gt;
&lt;p&gt;最后浏览器绘制各个节点，将页面展示给用户。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文系统地讲述从浏览器从输入域名到最终页面展示的整体流程。篇幅所限，本文的每一步讲述其实并不全面，所以后面我会单独就域名解析、HTTP请求/响应、浏览器的解析、渲染等内容单独开篇讲解，感兴趣的朋友也可以关注我的&lt;a href=&quot;http://www.xuecaijie.com/#1Q3Bh3Nw8OqKFF&quot; target=&quot;_blank&quot;&gt;个人博客&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;更多技术分享，欢迎关注『&lt;strong&gt;网站建设运维百科&lt;/strong&gt;』&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;http://blog.cnezsoft.com/file.php?f=201711/f_b04fdddbeb65ea91879b03ee5003df2a&amp;amp;t=jpg&amp;amp;o=&amp;amp;s=&amp;amp;v=1511148037&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/&lt;/p&gt;
&lt;p&gt;http://taligarsiel.com/Projects/howbrowserswork1.htm&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/34873227&lt;/p&gt;
&lt;p&gt;图片制作工具：Axure、PS、 Ulead GIF Animator、 ProcessOn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.cnezsoft.com/1Q3Bq3Nu8OsKFF.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 03:30:00 +0000</pubDate>
<dc:creator>雪融无痕</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webdeve/p/7865520.html</dc:identifier>
</item>
<item>
<title>【JAVA零基础入门系列】Day15 对象的比较 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/7865409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/7865409.html</guid>
<description>&lt;p&gt;　　最近一直有事，博客也停笔了一段时间，十分抱歉。&lt;/p&gt;
&lt;p&gt;　　这一篇主要讲讲对象的比较，什么是对象的比较，我们知道两个数值类型只需要用“==”符号即可进行相等判断，但如果是两个Goods对象呢？如何进行比较？这时候，我们的equals方法就派上用场了。equals方法是类的祖先Object类的另一个protected方法，既然是protected方法(能被同一个包里的所有类所访问, 能被该类的子类所访问，子类可以和父类不在一个包中)，子类是可以直接访问的，但如果没有覆盖该方法，那么使用的只是Object的原始比较方法，return(this==obj) ，仅仅比较两个对象的地址是否一致。&lt;/p&gt;
&lt;p&gt;　　对于String类型，已经设计好了equals方法，所以我们只需要拿来用就可以了，如果是我们自定义的类，那就得重写该方法来进行覆盖，下面还是用Goods类来举一个小栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Goods {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTitle() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTitle(String title) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Goods(String title, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是简化版的Goods类，有两个私有成员变量以及它们的设置器，访问器，还有一个构造器，下面我们来重写父类的equals方法，判断两个Goods是否相等，逻辑上，我们只需要两者标题和价格一致即可认为两个商品是相等的（当然可以根据实际情况进行调整），下面我们来设计一下equals方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Frank
 * @create 2017/11/20
 * @description 被测试类，测试equals方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Goods {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTitle() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTitle(String title) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Goods(String title, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆盖equals方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        Goods tmp &lt;/span&gt;=&lt;span&gt; (Goods) obj;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (price == tmp.getPrice() &amp;amp;&amp;amp;&lt;span&gt; title.equals(tmp.getTitle())){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们覆盖了父类的equals方法，在equals方法中将obj强制类型转换为Goods类，再比较两者价格和标题是否相等，只要都相等，则返回true，否则返回false，这也符合我们的需求，下面测试一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Frank
 * @create 2017/11/20
 * @description 测试类，用于测试equals方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Goods a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;Java&quot;,100&lt;span&gt;);
        Goods b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;C++&quot;,100&lt;span&gt;);
        Goods c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;Java&quot;,100&lt;span&gt;);
        System.out.println(a.equals(b));
        System.out.println(a.equals(c));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果为：false  ture&lt;/p&gt;
&lt;p&gt;　　这样我们就简单的实现了equals方法，但是，这个equals方法并不完美，首先，由于我们传入的是Object对象，所以并不知道它原本的类型是否为Goods类型，如果不是Goods类型，当然不能拿来比较，于是我们得先进行一下类型判断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (obj.getClass() != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Goods tmp &lt;/span&gt;=&lt;span&gt; (Goods) obj;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (price == tmp.getPrice() &amp;amp;&amp;amp;&lt;span&gt; title.equals(tmp.getTitle())){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　仍旧不完美，如果比较的对象就是自身或者两者指向同一个对象的话，直接返回true即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检测是否为自比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;this&lt;/span&gt; == obj || obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (obj.getClass() != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Goods tmp &lt;/span&gt;=&lt;span&gt; (Goods) obj;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (price == tmp.getPrice() &amp;amp;&amp;amp;&lt;span&gt; title.equals(tmp.getTitle())){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在就好很多了，那么此时我们调用equals方法跟使用”==“比较符号有什么区别呢，来看一个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Goods a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;Java&quot;,100&lt;span&gt;);
        Goods b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;C++&quot;,100&lt;span&gt;);
        Goods c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Goods(&quot;Java&quot;,100&lt;span&gt;);
        Goods d &lt;/span&gt;=&lt;span&gt; a;
        System.out.println(a.equals(b));
        System.out.println(a.equals(c));
        System.out.println(a.equals(d));
        System.out.println(a&lt;/span&gt;==&lt;span&gt;b);
        System.out.println(a&lt;/span&gt;==&lt;span&gt;c);
        System.out.println(a&lt;/span&gt;==&lt;span&gt;d);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于前三个输出应该没什么问题，主要看后三个，这里用相等比较符时，判断的仅仅是两个变量存储的内容是否一致，由于a、b、c、d均为引用类型，所以比较的仅仅是它们是否指向相同的对象，这里只有a跟d指向的是相同的对象，c虽然title和price都与a相同，但是跟a是两个完全不同的对象，因此没有返回的是false。&lt;/p&gt;
&lt;p&gt;　　另外，有人也许会问，做类型判断的时候，为什么不用instanceof或者isInstance方法，这里简单说明一下原因。instance判断的是a对象是否和b对象属于同一个类，或者有同一个父类，或者实现了同一个接口。isinstance方法则判断两种类型是否可以进行强转。&lt;/p&gt;
&lt;p&gt;　　由于这个小栗子并没有相关上下文，所以还是直接用getClass方法进行判断比较稳妥，当然，以后可以根据具体实际情况进行修改。&lt;/p&gt;
&lt;p&gt;　　至此，equals方法讲解完毕，很简单吧。之后还是会继续更新的，欢迎大家继续关注！&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 03:13:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/7865409.html</dc:identifier>
</item>
<item>
<title>使用 Rust 构建分布式 Key-Value Store - 腾讯云技术社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/7865246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/7865246.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;腾讯云社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;构建一个分布式 Key-Value Store 并不是一件容易的事情，我们需要考虑很多的问题，首先就是我们的系统到底需要提供什么样的功能，譬如：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一致性：我们是否需要保证整个系统的线性一致性，还是能容忍短时间的数据不一致，只支持最终一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;稳定性：我们能否保证系统 7 x 24 小时稳定运行。系统的可用性是 4 个 9，还有 5 个 9？如果出现了机器损坏等灾难情况，系统能否做的自动恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;扩展性：当数据持续增多，能否通过添加机器就自动做到数据再次平衡，并且不影响外部服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分布式事务：是否需要提供分布式事务支持，事务隔离等级需要支持到什么程度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的问题在系统设计之初，就需要考虑好，作为整个系统的设计目标。为了实现这些特性，我们就需要考虑到底采用哪一种实现方案，取舍各个方面的利弊等。&lt;/p&gt;
&lt;p&gt;后面，我将以我们开发的分布式 Key-Value &lt;a href=&quot;https://github.com/pingcap/tikv&quot; target=&quot;_blank&quot;&gt;TiKV&lt;/a&gt; 作为实际例子，来说明下我们是如何取舍并实现的。&lt;/p&gt;
&lt;h2 id=&quot;tikv&quot;&gt;TiKV&lt;/h2&gt;
&lt;p&gt;TiKV 是一个分布式 Key-Value store，它使用 Rust 开发，采用 Raft 一致性协议保证数据的强一致性，以及稳定性，同时通过 Raft 的 Configuration Change 机制实现了系统的可扩展性。&lt;/p&gt;
&lt;p&gt;TiKV 提供了基本的 KV API 支持，也就是通常的 Get，Set，Delete，Scan 这样的 API。TiKV 也提供了支持 ACID 事务的 Transaction API，我们可以使用 Begin 开启一个事务，在事务里面对 Key 进行操作，最后再用 Commit 提交一个事务，TiKV 支持 SI 以及 SSI 事务隔离级别，用来满足用户的不同业务场景。&lt;/p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;/h2&gt;
&lt;p&gt;在规划好 TiKV 的特性之后，我们就要开始进行 TiKV 的开发。这时候，我们面临的第一个问题就是采用什么样的语言进行开发。当时，摆在我们眼前的有几个选择：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Go，Go 是我们团队最擅长的一门语言，而且 Go 提供的 goroutine，channel 这些机制，天生的适合大规模分布式系统的开发，但灵活方便的同时也有一些甜蜜的负担，首先就是 GC，虽然现在 Go 的 GC 越来越完善，但总归会有短暂的卡顿，另外 goroutine 的调度也会有切换开销，这些都可能会造成请求的延迟增高。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Java，现在世面上面有太多基于 Java 做的分布式系统了，但 Java 一样有 GC 等开销问题，同时我们团队在 Java 上面没有任何开发经验，所以没有采用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;C++，C++ 可以认为是开发高性能系统的代名词，但我们团队没有特别多的同学能熟练掌握 C++，所以开发大型 C++ 项目并不是一件非常容易的事情。虽然使用现代 C++ 的编程方式能大量减少 data race，dangling pointer 等风险，我们仍然可能犯错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们排除了上面几种主流语言之后，我们发现，为了开发 TiKV，我们需要这门语言具有如下特性：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态语言，这样才能最大限度的保证运行性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无 GC，完全手动控制内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Memory safe，尽量避免 dangling pointer，memory leak 等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Thread safe，不会遇到 data race 等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包管理，我们可以非常方便的使用第三方库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;高效的 C 绑定，因为我们还可能使用一些 C library，所以跟 C 交互不能有开销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，我们决定使用 &lt;a href=&quot;https://www.rust-lang.org/zh-CN/&quot; target=&quot;_blank&quot;&gt;Rust&lt;/a&gt;，Rust 是一门系统编程语言，它提供了我们上面想要的语言特性，但选择 Rust 对我们来说也是很有风险的，主要有两点：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们团队没有任何 Rust 开发经验，全部都需要花时间学习 Rust，而偏偏 Rust 有一个非常陡峭的学习曲线。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基础网络库的缺失，虽然那个时候 Rust 已经出了 1.0，但我们发现很多基础库都没有，譬如在网络库上面只有 mio，没有好用的 RPC 框架，HTTP 也不成熟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但我们还是决定使用 Rust，对于第一点，我们团队花了将近一个月的时间来学习 Rust，跟 Rust 编译器作斗争，而对于第二点，我们就完全开始自己写。&lt;/p&gt;
&lt;p&gt;幸运的，当我们越过 Rust 那段阵痛期之后，发现用 Rust 开发 TiKV 异常的高效，这也就是为啥我们能在短时间开发出 TiKV 并在生产环境中上线的原因。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一致性协议&lt;/h2&gt;
&lt;p&gt;对于分布式系统来说，CAP 是一个不得不考虑的问题，因为 P 也就是 Partition Tolerance 是一定存在的，所以我们就要考虑到底是选择 C - Consistency 还是 A - Availability。&lt;/p&gt;
&lt;p&gt;我们在设计 TiKV 的时候就决定 - 完全保证数据安全性，所以自然就会选择 C，但其实我们并没有完全放弃 A，因为多数时候，毕竟断网，机器停电不会特别频繁，我们只需要保证 HA - High Availability，也就是 4 个 9 或者 5 个 9 的可用性就可以了。&lt;/p&gt;
&lt;p&gt;既然选择了 C，我们下一个就考虑的是选用哪一种分布式一致性算法，现在流行的无非就是 Paxos 或者 Raft，而 Raft 因为简单，容易理解，以及有很多现成的开源库可以参考，自然就成了我们的首要选择。&lt;/p&gt;
&lt;p&gt;在 Raft 的实现上，我们直接参考的 &lt;a href=&quot;https://github.com/coreos/etcd&quot; target=&quot;_blank&quot;&gt;etcd&lt;/a&gt; 的 Raft。etcd 已经被大量的公司在生产环境中使用，所以它的 Raft 库质量是很有保障的。虽然 etcd 是用 Go 实现的，但它的 Raft library 是类似 C 的实现，所以非常便于我们用 Rust 直接翻译。在翻译的过程中，我们也给 etcd 的 Raft fix 了一些 bug，添加了一些功能，让其变得更加健壮和易用。&lt;/p&gt;
&lt;p&gt;现在 Raft 的代码仍然在 TiKV 工程里面，但我们很快会将独立出去，变成独立的 library，这样大家就能在自己的 Rust 项目中使用 Raft 了。&lt;/p&gt;
&lt;p&gt;使用 Raft 不光能保证数据的一致性，也可以借助 Raft 的 Configuration Change 机制实现系统的水平扩展，这个我们会在后面的文章中详细的说明。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;选择了分布式一致性协议，下一个就要考虑数据存储的问题了。在 TiKV 里面，我们会存储 Raft log，然后也会将 Raft log 里面实际的客户请求应用到状态机里面。&lt;/p&gt;
&lt;p&gt;首先来看状态机，因为它会存放用户的实际数据，而这些数据完全可能是随机的 key - value，为了高效的处理随机的数据插入，自然我们就考虑使用现在通用的 LSM Tree 模型。而在这种模型下，RocksDB 可以认为是现阶段最优的一个选择。&lt;/p&gt;
&lt;p&gt;RocksDB 是 Facebook 团队在 LevelDB 的基础上面做的高性能 Key-Value Storage，它提供了很多配置选项，能让大家根据不同的硬件环境去调优。这里有一个梗，说的是因为 RocksDB 配置太多，以至于连 RocksDB team 的同学都不清楚所有配置的意义。&lt;/p&gt;
&lt;p&gt;关于我们在 TiKV 中如何使用，优化 RocksDB，以及给 RocksDB 添加功能，fix bug 这些，我们会在后面文章中详细说明。&lt;/p&gt;
&lt;p&gt;而对于 Raft Log，因为任意 Log 的 index 是完全单调递增的，譬如 Log 1，那么下一个 Log 一定是 Log 2，所以 Log 的插入可以认为是顺序插入。这种的，最通常的做法就是自己写一个 Segment File，但现在我们仍然使用的是 RocksDB，因为 RocksDB 对于顺序写入也有非常高的性能，也能满足我们的需求。但我们不排除后面使用自己的引擎。&lt;/p&gt;
&lt;p&gt;因为 RocksDB 提供了 C API，所以可以直接在 Rust 里面使用，大家也可以在自己的 Rust 项目里面通过 &lt;a href=&quot;https://github.com/pingcap/rust-rocksdb&quot; target=&quot;_blank&quot;&gt;rust-rocksdb&lt;/a&gt; 这个库来使用 RocksDB。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;分布式事务&lt;/h2&gt;
&lt;p&gt;要支持分布式事务，首先要解决的就是分布式系统时间的问题，也就是我们用什么来标识不同事务的顺序。通常有几种做法：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;TrueTime，TrueTime 是 Google Spanner 使用的方式，不过它需要硬件 GPS + 原子钟支持，而且 Spanner 并没有在论文里面详细说明硬件环境是如何搭建的，外面要自己实现难度比较大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;HLC，HLC 是一种混合逻辑时钟，它使用 Physical Time 和 Logical Clock 来确定事件的先后顺序，HLC 已经在一些应用中使用，但 HLC 依赖 NTP，如果 NTP 精度误差比较大，很可能会影响 commit wait time。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TSO，TSO 是一个全局授时器，它直接使用一个单点服务来分配时间。TSO 的方式很简单，但会有单点故障问题，单点也可能会有性能问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TiKV 采用了 TSO 的方式进行全局授时，主要是为了简单。至于单点故障问题，我们通过 Raft 做到了自动 fallover 处理。而对于单点性能问题，TiKV 主要针对的是 PB 以及 PB 以下级别的中小规模集群，所以在性能上面只要能保证每秒百万级别的时间分配就可以了，而网络延迟上面，TiKV 并没有全球跨 IDC 的需求，在单 IDC 或者同城 IDC 情况下，网络速度都很快，即使是异地 IDC，也因为有专线不会有太大的延迟。&lt;/p&gt;
&lt;p&gt;解决了时间问题，下一个问题就是我们采用何种的分布式事务算法，最通常的就是使用 2 PC，但通常的 2 PC 算法在一些极端情况下面会有问题，所以业界要不通过 Paxos，要不就是使用 3 PC 等算法。在这里，TiKV 参考 Percolator，使用了另一种增强版的 2 PC 算法。&lt;/p&gt;
&lt;p&gt;这里先简单介绍下 Percolator 的分布式事务算法，Percolator 使用了乐观锁，也就是会先缓存事务要修改的数据，然后在 Commit 提交的时候，对要更改的数据进行加锁处理，然后再更新。采用乐观锁的好处在于对于很多场景能提高整个系统的并发处理能力，但在冲突严重的情况下反而没有悲观锁高效。&lt;/p&gt;
&lt;p&gt;对于要修改的一行数据，Percolator 会有三个字段与之对应，Lock，Write 和 Data：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Lock，就是要修改数据的实际 lock，在一个 Percolator 事务里面，有一个 primary key，还有其它 secondary keys， 只有 primary key 先加锁成功，我们才会再去尝试加锁后续的 secondary keys。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Write，保存的是数据实际提交写入的 commit timestamp，当一个事务提交成功之后，我们就会将对应的修改行的 commit timestamp 写入到 Write 上面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Data，保存实际行的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当事务开始的时候，我们会首先得到一个 start timestamp，然后再去获取要修改行的数据，在 Get 的时候，如果这行数据上面已经有 Lock 了，那么就可能终止当前事务，或者尝试清理 Lock。&lt;/p&gt;
&lt;p&gt;当我们要提交事务的时候，先得到 commit timestamp，会有两个阶段：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Prewrite：先尝试给 primary key 加锁，然后尝试给 second keys 加锁。如果对应 key 上面已经有 Lock，或者在 start timestamp 之后，Write 上面已经有新的写入，Prewrite 就会失败，我们就会终止这次事务。在加锁的时候，我们也会顺带将数据写入到 Data 上面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Commit：当所有涉及的数据都加锁成功之后，我们就可以提交 primay key，这时候会先判断之前加的 Lock 是否还在，如果还在，则删掉 Lock，将 commit timestamp 写入到 Write。当 primary key 提交成功之后，我们就可以异步提交 second keys，我们不用在乎 primary keys 是否能提交成功，即使失败了，也有机制能保证数据被正常提交。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 TiKV 里面，事务的实现主要包括两块，一个是集成在 TiDB 中的 &lt;a href=&quot;https://github.com/pingcap/tidb/tree/master/store/tikv&quot; target=&quot;_blank&quot;&gt;tikv client&lt;/a&gt;，而另一个则是在 TiKV 中的 &lt;a href=&quot;https://github.com/pingcap/tikv/tree/master/src/storage&quot; target=&quot;_blank&quot;&gt;storage&lt;/a&gt; mod 里面，后面我们会详细的介绍。&lt;/p&gt;
&lt;h2 id=&quot;rpc-&quot;&gt;RPC 框架&lt;/h2&gt;
&lt;p&gt;RPC 应该是分布式系统里面常用的一种网络交互方式，但实现一个简单易用并且高效的 RPC 框架并不是一件容易的事情，幸运的是，现在有很多可以供我们进行选择。&lt;/p&gt;
&lt;p&gt;TiKV 从最开始设计的时候，就希望使用 gRPC，但 Rust 当时并没有能在生产环境中可用的 gRPC 实现，我们只能先基于 mio 自己做了一个 RPC 框架，但随着业务的复杂，这套 RPC 框架开始不能满足需求，于是我们决定，直接使用 Rust 封装 Google 官方的 C gRPC，这样就有了 &lt;a href=&quot;https://github.com/pingcap/grpc-rs&quot; target=&quot;_blank&quot;&gt;grpc-rs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里先说一下为什么我们决定使用 gRPC，主要有如下原因：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;gRPC 应用广泛，很多知名的开源项目都使用了，譬如 Kubernetes，etcd 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;gRPC 有多种语言支持，我们只要定义好协议，其他语言都能直接对接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;gRPC 有丰富的接口，譬如支持 unary，client streaming，server streaming 以及 duplex streaming。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;gRPC 使用 protocol buffer，能高效的处理消息的编解码操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;gRPC 基于 HTTP/2，一些 HTTP/2 的特性，譬如 duplexing，flow control 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最开始开发 rust gRPC 的时候，我们先准备尝试基于一个 rust 的版本来开发，但无奈遇到了太多的 panic，果断放弃，于是就将目光放到了 Google gRPC 官方的库上面。Google gRPC 库提供了多种语言支持，譬如 C++，C#，Python，这些语言都是基于一个核心的 C gRPC 来做的，所以我们自然选择在 Rust 里面直接使用 C gRPC。&lt;/p&gt;
&lt;p&gt;因为 Google 的 C gRPC 是一个异步模型，为了简化在 rust 里面异步代码编写的难度，我们使用 rust Future 库将其重新包装，提供了 Future API，这样就能按照 Future 的方式简单使用了。&lt;/p&gt;
&lt;p&gt;关于 gRPC 的详细介绍以及 rust gRPC 的设计还有使用，我们会在后面的文章中详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;监控&lt;/h2&gt;
&lt;p&gt;很难想象一个没有监控的分布式系统是如何能稳定运行的。如果我们只有一台机器，可能时不时看下这台机器上面的服务还在不在，CPU 有没有问题这些可能就够了，但如果我们有成百上千台机器，那么势必要依赖监控了。&lt;/p&gt;
&lt;p&gt;TiKV 使用的是 Prometheus，一个非常强大的监控系统。Prometheus 主要有如下特性：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于时序的多维数据模型，对于一个 metric，我们可以用多种 tag 进行多维区分。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自定义的报警机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;丰富的数据类型，提供了 Counter，Guage，Histogram 还有 Summary 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;强大的查询语言支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提供 pull 和 push 两种模式支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持服务的动态发现和静态配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能跟 Grafana 深度整合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为 Prometheus 并没有 Rust 的客户端，于是我们开发了 &lt;a href=&quot;https://github.com/pingcap/rust-prometheus&quot; target=&quot;_blank&quot;&gt;rust-prometheus&lt;/a&gt;。Rust Prometheus 在设计上面参考了 Go Prometehus 的 API，但我们只支持了 最常用的 Counter，Guage 和 Histogram，并没有实现 Summary。&lt;/p&gt;
&lt;p&gt;后面，我们会详细介绍 Prometheus 的使用，以及不同的数据类型的使用场景等。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;要做好一个分布式的 Key-Value Store，测试是非常重要的一环。 只有经过了最严格的测试，我们才能有信心去保证整个系统是可以稳定运行的。&lt;/p&gt;
&lt;p&gt;从最开始开发 TiKV 的时候，我们就将测试摆在了最重要的位置，除了常规的 unit test，我们还做了更多，譬如：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Stability test，我们专门写了一个 stability test，随机的干扰整个系统，同时运行我们的测试程序，看结果的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Jepsen，我们使用 Jepsen 来验证 TiKV 的线性一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Namazu，我们使用 Namazu 来干扰文件系统以及 TiKV 线程调度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Failpoint，我们在 TiKV 很多关键逻辑上面注入了 fail point，然后在外面去触发这些 fail，在验证即使出现了这些异常情况，数据仍然是正确的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面仅仅是我们的一些测试案例，当代码 merge 到 master 之后，我们的 CI 系统在构建好版本之后，就会触发所有的 test 执行，只有当所有的 test 都完全跑过，我们才会放出最新的版本。&lt;/p&gt;
&lt;p&gt;在 Rust 这边，我们根据 FreeBSD 的 Failpoint 开发了 &lt;a href=&quot;https://github.com/pingcap/fail-rs&quot; target=&quot;_blank&quot;&gt;fail-rs&lt;/a&gt;，并已经在 TiKV 的 Raft 中注入了很多 fail，后面还会在更多地方注入。我们也会基于 Rust 开发更多的 test 工具，用来测试整个系统。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;上面仅仅列出了我们用 Rust 开发 TiKV 的过程中，一些核心模块的设计思路。这篇文章只是一个简单的介绍，后面我们会针对每一个模块详细的进行说明。还有一些功能我们现在是没有做的，譬如 open tracing，这些后面都会慢慢开始完善。&lt;/p&gt;
&lt;p&gt;我们的目标是通过 TiKV，在分布式系统领域，提供一套 Rust 解决方案，形成一个 Rust ecosystem。这个目标很远大，欢迎任何感兴趣的同学加入。&lt;/p&gt;

&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/992585?utm_source=bky&quot; target=&quot;_blank&quot;&gt;网页加速特技之 AMP&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/846600?utm_source=bky&quot; target=&quot;_blank&quot;&gt;表格行与列边框样式处理的原理分析及实战应用&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/775773?utm_source=bky&quot; target=&quot;_blank&quot;&gt;EB级别云存储是如何涨成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community/article/727528?utm_source=bky&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此文已由作者授权腾讯云技术社区发布，转载请注明&lt;a class=&quot; wrap external&quot; href=&quot;https://cloud.tencent.com/community/article/906224?utm_source=bky&quot; target=&quot;_blank&quot;&gt;原文出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文链接：https://cloud.tencent.com/community/article/906224?utm_source=bky&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//cloud.tencent.com/community&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;腾讯云社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 02:46:00 +0000</pubDate>
<dc:creator>腾讯云技术社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/7865246.html</dc:identifier>
</item>
<item>
<title>谈谈个人网站的建立（六）—— 数据库同步 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/7865051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/7865051.html</guid>
<description>&lt;p&gt;欢迎访问我的个人网站O(∩_∩)O哈哈~希望大佬们能给个star，个人网站网址：&lt;a href=&quot;http://www.wenzhihuai.com&quot; class=&quot;uri&quot;&gt;http://www.wenzhihuai.com&lt;/a&gt;，个人网站代码地址：&lt;a href=&quot;https://github.com/Zephery/newblog&quot; class=&quot;uri&quot;&gt;https://github.com/Zephery/newblog&lt;/a&gt;。&lt;br/&gt;先来回顾一下上一篇的小集群架构，tomcat集群，nginx进行反向代理，服务器异地：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171018051437.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;由上一篇讲到，部署的时候，将war部署在不同的服务器里，通过spring-session实现了session共享，基本的分布式部署还算是完善了点，但是想了想数据库的访问会不会延迟太大，毕竟一个服务器在北京，一个在深圳，然后试着ping了一下：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171118033130.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;果然，36ms。。。看起来挺小的，但是对比一下sql执行语句的时间：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171118034129.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;大部分都能在10ms内完成，而最长的语句是insert语句，可见，由于异地导致的36ms延时还是比较大的，捣鼓了一下，最后还是选择换个架构，每个服务器读取自己的数据库，然后数据库底层做一下主主复制，让数据同步。最终架构如下：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171118035150.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;数据库复制的基本问题就是让一台服务器的数据与其他服务器保持同步。MySql目前支持两种复制方式：基于行的复制和基于语句的复制，这两者的基本过程都是在主库上记录二进制的日志、在备库上重放日志的方式来实现异步的数据复制。其过程分为三步：&lt;br/&gt;(1)master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）；&lt;br/&gt;(2)slave将master的binary log events拷贝到它的中继日志(relay log)；&lt;br/&gt;(3)slave重做中继日志中的事件，将改变反映它自己的数据。&lt;/p&gt;
&lt;p&gt;![](http://image.wenzhihuai.com/images/20171118040843.png)&lt;/p&gt;
&lt;p&gt;该过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。&lt;br/&gt;下一步就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。&lt;br/&gt;SQL slave thread处理该过程的最后一步。SQL线程从中继日志读取事件，更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。&lt;br/&gt;此外，在master中也有一个工作线程：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。&lt;br/&gt;MySql的基本复制方式有主从复制、主主复制，主主复制即把主从复制的配置倒过来再配置一遍即可，下面的配置则是主从复制的过程，到时候可自行改为主主复制。其他的架构如：一主库多备库、环形复制、树或者金字塔型都是基于这两种方式，可参考《高性能MySql》。&lt;/p&gt;

&lt;h3 id=&quot;创建所用的复制账号&quot;&gt;2.1 创建所用的复制账号&lt;/h3&gt;
&lt;p&gt;由于是个自己的小网站，就不做过多的操作了，直接使用root账号&lt;/p&gt;
&lt;h3 id=&quot;配置master&quot;&gt;2.2 配置master&lt;/h3&gt;
&lt;p&gt;接下来要对mysql的serverID，日志位置，复制方式等进行操作，使用vim打开my.cnf。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;[client]
default-character-set=utf8

[mysqld]
character_set_server=utf8
init_connect= SET NAMES utf8

datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid

# master
log-bin=mysql-bin
# 设为基于行的复制
binlog-format=ROW
# 设置server的唯一id
server-id=2
# 忽略的数据库，不使用备份
binlog-ignore-db=information_schema
binlog-ignore-db=cluster
binlog-ignore-db=mysql
# 要进行备份的数据库
binlog-do-db=myblog&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启Mysql之后，查看主库状态，show master status。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171118050128.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中，File为日志文件，指定Slave从哪个日志文件开始读复制数据，Position为偏移，从哪个POSITION号开始读，Binlog_Do_DB为要备份的数据库。&lt;/p&gt;
&lt;h3 id=&quot;配置slave&quot;&gt;2.3 配置slave&lt;/h3&gt;
&lt;p&gt;从库的配置跟主库类似，vim /etc/my.cnf配置从库信息。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
[client]
default-character-set=utf8

[mysqld]
character_set_server=utf8
init_connect= SET NAMES utf8

datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid

# slave
log-bin=mysql-bin
# 服务器唯一id
server-id=3
# 不备份的数据库
binlog-ignore-db=information_schema
binlog-ignore-db=cluster
binlog-ignore-db=mysql
# 需要备份的数据库
replicate-do-db=myblog
# 其他相关信息
slave-skip-errors=all
slave-net-timeout=60
# 开启中继日志
relay_log         = mysql-relay-bin
# 
log_slave_updates = 1
# 防止改变数据
read_only         = 1&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启slave，同时启动复制，还需要调整一下命令。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;mysql&amp;gt; CHANGE MASTER TO MASTER_HOST = '119.23.46.71', MASTER_USER = 'root', MASTER_PASSWORD = 'helloroot', MASTER_PORT = 3306, MASTER_LOG_FILE = 'mysql-bin.000009', MASTER_LOG_POS = 346180; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看见slave已经开始进行同步了。我们使用show slave status\G来查看slave的状态。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171118051031.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中日志文件和POSITION不一致是合理的，配置好了的话，即使重启，也不会影响到主从复制的配置。&lt;/p&gt;
&lt;p&gt;某天在Github上漂游，发现了阿里的canal，同时才知道上面这个业务是叫异地跨机房同步，早期，阿里巴巴B2B公司因为存在杭州和美国双机房部署，存在跨机房同步的业务需求。不过早期的数据库同步业务，主要是基于trigger的方式获取增量变更，不过从2010年开始，阿里系公司开始逐步的尝试基于数据库的日志解析，获取增量变更进行同步，由此衍生出了增量订阅&amp;amp;消费的业务。下面是基本的原理：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171120094405.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;原理相对比较简单：&lt;/p&gt;
&lt;p&gt;1.canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议&lt;br/&gt;2.mysql master收到dump请求，开始推送binary log给slave(也就是canal)&lt;br/&gt;3.canal解析binary log对象(原始为byte流)&lt;/p&gt;
&lt;p&gt;其中，配置过程如下：&lt;a href=&quot;https://github.com/alibaba/canal&quot; class=&quot;uri&quot;&gt;https://github.com/alibaba/canal&lt;/a&gt;，可以搭配Zookeeper使用。在ZKUI中能够查看到节点：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20171120100237.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;一般情况下，还要配合阿里的另一个开源产品使用&lt;a href=&quot;https://github.com/alibaba/otter&quot;&gt;otter&lt;/a&gt;，相关文档还是找找GitHub吧，个人搭建完了之后，用起来还是不如直接使用mysql的主主复制，而且异地机房同步这种大企业才有的业务。&lt;/p&gt;
&lt;p&gt;公司又要996了，实在是忙不过来，感觉自己写的还是急躁了点，困==&lt;/p&gt;
&lt;p&gt;欢迎访问我的个人网站O(∩_∩)O哈哈~希望能给个star&lt;br/&gt;个人网站网址：&lt;a href=&quot;http://www.wenzhihuai.com&quot; class=&quot;uri&quot;&gt;http://www.wenzhihuai.com&lt;/a&gt;&lt;br/&gt;个人网站代码地址：&lt;a href=&quot;https://github.com/Zephery/newblog&quot; class=&quot;uri&quot;&gt;https://github.com/Zephery/newblog&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 02:16:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/7865051.html</dc:identifier>
</item>
<item>
<title>Winform界面中主从表编辑界面的快速处理 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/7865083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/7865083.html</guid>
<description>&lt;p&gt;在Winform开发中，我们往往除了常规的单表信息录入外，有时候设计到多个主从表的数据显示、编辑等界面，单表的信息一般就是控件和对象实体一一对应，然后调用API保存即可，主从表就需要另外特殊处理，本随笔介绍如何快速实现主从表编辑界面的处理，结合GridControl控件的GridView控件对象，实现数据在列表中的实时编辑，非常方便。&lt;/p&gt;
&lt;h3&gt;1、主从表的界面设计及展示&lt;/h3&gt;
&lt;p&gt;主从表一般涉及两个以上的表，一个是主表，其他的是从表的，在实际情况下，一般包含两个表较多，我们这里以两个表的主从表关系进行分析处理。&lt;/p&gt;
&lt;p&gt;例如我们建立两个报销申请单表关系如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/8867/201711/8867-20171120094817524-1761609300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于报销的主从表信息，我们可以在列表中进行展示，如下界面所示，分为两部分：一部分是主表信息，一部分是从表信息，单击主表信息后，显示对应从表的列表信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/8867/201711/8867-20171120095214586-399405380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们新增一条主表记录的时候，那么可以弹出一个新的界面进行数据的维护处理，方便我们录入主从表的信息，界面如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/8867/201711/8867-20171120095537008-239052755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面界面包括了主表信息，以及从表的信息（在GridView中实时录入）两部分，这样填写后统一进行提交处理。&lt;/p&gt;

&lt;h3&gt;2、主从表编辑界面的处理&lt;/h3&gt;
&lt;p&gt;这里主要介绍一下主从表的编辑界面处理，也就是上面这个界面的实现处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/8867/201711/8867-20171120095537008-239052755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中初始化GridView的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化明细表的GridView数据显示
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitDetailGrid()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始清空列&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gridView1.Columns.Clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置部分列隐藏&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Header_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主表编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apply_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;申请单编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加下拉列表列，并绑定数据源&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;).CreateComboBox().BindDictItems(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建日期列并指定格式&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; OccurTime = &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OccurTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发生时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;&lt;span&gt;).CreateDateEdit();
            OccurTime.EditMask &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            OccurTime.DisplayFormat.FormatString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数值列&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeAmount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用金额&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).CreateSpinEdit();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建备注列&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeDescription&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用说明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;).CreateMemoEdit();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化GridView，可以新增列&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.InitGridView(GridType.NewItem, &lt;span&gt;false&lt;/span&gt;, EditorShowMode.MouseDownFocused, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转义列内容显示&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CustomColumnDisplayText += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomColumnDisplayTextEventHandler(gridView1_CustomColumnDisplayText);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理单元格的样式&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.RowCellStyle += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RowCellStyleEventHandler(gridView1_RowCellStyle);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不允许头部排序&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.OptionsCustomization.AllowSort = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制序号&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CustomDrawRowIndicator += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Info.IsRowIndicator &amp;amp;&amp;amp; e.RowHandle &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    e.Info.DisplayText &lt;/span&gt;= (e.RowHandle + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToString();
                }
            };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对输入单元格进行非空校验&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.ValidateRow += &lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ValidateRowEventArgs e)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = gridControl1.ValidateRowNull(e, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[]
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                });
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增行的内容初始化&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.InitNewRow += (s, e) =&amp;gt;&lt;span&gt;
            {
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Guid.NewGuid().ToString());
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Header_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tempInfo.ID);
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apply_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tempInfo.Apply_ID);
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OccurTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
            };
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; gridView1_RowCellStyle(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, DevExpress.XtraGrid.Views.Grid.RowCellStyleEventArgs e)
        {
            GridView gridView &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gridView1;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Column.FieldName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeAmount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                e.Appearance.BackColor &lt;/span&gt;=&lt;span&gt; Color.Green;
                e.Appearance.BackColor2 &lt;/span&gt;=&lt;span&gt; Color.LightCyan;
            }
        }
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; gridView1_CustomColumnDisplayText(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, DevExpress.XtraGrid.Views.Base.CustomColumnDisplayTextEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; columnName =&lt;span&gt; e.Column.FieldName;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Column.ColumnType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DateTime))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Value == DBNull.Value || Convert.ToDateTime(e.Value) &amp;lt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1900-1-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                    {
                        e.DisplayText &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        e.DisplayText &lt;/span&gt;= Convert.ToDateTime(e.Value).ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;
&lt;span&gt;                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码都有详细的备注，主要就是我们根据数据库表的关系，创建对应显示的字段即可，其中有需要隐藏的那么就不要显示（方便获取对应的值）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置部分列隐藏&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Header_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主表编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apply_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;申请单编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Visible = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要绑定下拉列表类似的字段，那么创建对应的数据类型，然后调用绑定函数绑定即可，如下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加下拉列表列，并绑定数据源&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeeType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;).CreateComboBox().BindDictItems(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;费用类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是一些特殊的输入需要设置格式显示或者掩码，那么如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建日期列并指定格式&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; OccurTime = &lt;span&gt;this&lt;/span&gt;.gridView1.CreateColumn(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OccurTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发生时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;&lt;span&gt;).CreateDateEdit();
            OccurTime.EditMask &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            OccurTime.DisplayFormat.FormatString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外有一个值得注意的就是我们新增一行从表记录的时候，需要记录一些主表的属性，这样的话，我们就是在行初始化的时候，赋值给从表的隐藏列即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增行的内容初始化&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.gridView1.InitNewRow += (s, e) =&amp;gt;&lt;span&gt;
            {
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Guid.NewGuid().ToString());
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Header_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tempInfo.ID);
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apply_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tempInfo.Apply_ID);
                gridView1.SetRowCellValue(e.RowHandle, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OccurTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DateTime.Now);
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在界面中如果我们需要显示主表的信息，那么就根据条件获取对应的主表记录对象，然后显示给界面控件即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示常规的对象内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;info&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DisplayInfo(ReimbursementInfo info)
        {
            tempInfo &lt;/span&gt;= info;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新给临时对象赋值，使之指向存在的记录对象&lt;/span&gt;
&lt;span&gt;
            txtCategory.Text &lt;/span&gt;=&lt;span&gt; info.Category;
            txtReason.Text &lt;/span&gt;=&lt;span&gt; info.Reason;
            txtTotalAmount.Value &lt;/span&gt;=&lt;span&gt; info.TotalAmount;
            txtNote.Text &lt;/span&gt;=&lt;span&gt; info.Note;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而保存的时候，我们把界面内容重新赋值给对应的主表对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 编辑或者保存状态下取值函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;info&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetInfo(ReimbursementInfo info)
        {
            info.Category &lt;/span&gt;=&lt;span&gt; txtCategory.Text;
            info.Reason &lt;/span&gt;=&lt;span&gt; txtReason.Text;
            info.TotalAmount &lt;/span&gt;=&lt;span&gt; txtTotalAmount.Value;
            info.Note &lt;/span&gt;=&lt;span&gt; txtNote.Text;

            info.ApplyDate &lt;/span&gt;=&lt;span&gt; DateTime.Now;
            info.ApplyDept &lt;/span&gt;= &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.LoginUserInfo.DeptId;
            info.CurrentLoginUserId &lt;/span&gt;= &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.LoginUserInfo.ID;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而我们需要获取GridView明细输入的时候，就通过一个函数遍历获取GridView的行记录，转换为相应的对象即可，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取明细列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;ReimbursementDetailInfo&amp;gt;&lt;span&gt; GetDetailList()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ReimbursementDetailInfo&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.gridView1.RowCount; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; detailInfo = gridView1.GetRow(i) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ReimbursementDetailInfo;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (detailInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    list.Add(detailInfo);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样处理完这些信息后，我们就可以在主表保存的时候，同时保存明细表信息即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 新增状态下的数据保存
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; SaveAddNew()
        {
            ReimbursementInfo info &lt;/span&gt;= tempInfo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须使用存在的局部变量，因为部分信息可能被附件使用&lt;/span&gt;
&lt;span&gt;            SetInfo(info);
            info.Creator &lt;/span&gt;= &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.LoginUserInfo.ID;
            info.CreateTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 新增数据

                &lt;span&gt;bool&lt;/span&gt; succeed = BLLFactory&amp;lt;Reimbursement&amp;gt;&lt;span&gt;.Instance.Insert(info);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (succeed)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可添加其他关联操作&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; GetDetailList();
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; detailInfo &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
                    {
                        BLLFactory&lt;/span&gt;&amp;lt;ReimbursementDetail&amp;gt;&lt;span&gt;.Instance.InsertUpdate(detailInfo, detailInfo.ID);
                    }
                    
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                LogTextHelper.Error(ex);
                MessageDxUtil.ShowError(ex.Message);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
BLLFactory&amp;lt;ReimbursementDetail&amp;gt;.Instance.InsertUpdate(detailInfo, detailInfo.ID);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以对新增记录保存，也可以对存在的记录进行更新。&lt;/p&gt;
&lt;p&gt;通过上面的介绍，我们可以看到不同的主从表其实逻辑还是很通用的，我们可以把它们的逻辑抽取出来，通过代码生成工具进行快速生成即可。&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 02:13:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/7865083.html</dc:identifier>
</item>
<item>
<title>【机器学习】人工神经网络ANN - 水奈樾</title>
<link>http://www.cnblogs.com/rucwxb/p/7865021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rucwxb/p/7865021.html</guid>
<description>&lt;p&gt;&lt;span&gt;感谢中国人民大学的胡鹤老师，课程理论实践结合，讲得很好~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;神经网络是从生物领域自然的鬼斧神工中学习智慧的一种应用。人工神经网络（ANN）的发展经历的了几次高潮低谷，如今，随着数据爆发、硬件计算能力暴增、深度学习算法的优化，我们迎来了又一次的ANN雄起时代，以深度学习为首的人工神经网络，又一次走入人们的视野。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感知机模型perception&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不再处理离散情况，而是连续的数值，学习时权值在变化，从而记忆存储学到的知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;神经元输入：类似于线性回归z =w1x1+w2x2 +⋯ +wnxn= wT・x（linear threshold unit (LTU)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;神经元输出：激活函数，类似于二值分类，模拟了生物学中神经元只有激发和抑制两种状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120081827774-238211325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;增加篇值，输出层哪个节点权重大，输出哪一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120082604040-467819979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用Hebb准则，下一个权重调整方法参考当前权重和训练效果 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120082550805-2020381011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#一个感知机的例子&lt;br/&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; load_iris
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Perceptron
iris &lt;/span&gt;=&lt;span&gt; load_iris()
X &lt;/span&gt;= iris.data[:, (2, 3)] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; petal length, petal width&lt;/span&gt;
y = (iris.target == 0).astype(np.int) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Iris Setosa?&lt;/span&gt;
per_clf = Perceptron(random_state=42&lt;span&gt;)
per_clf.fit(X, y)
y_pred &lt;/span&gt;= per_clf.predict([[2, 0.5]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;之后有人提出，perception无法处理异或问题，但是，使用多层感知机（MLP）可以处理这个问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; heaviside(z):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (z &amp;gt;=&lt;span&gt; 0).astype(z.dtype)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sigmoid(z):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1/(1+np.exp(-&lt;span&gt;z))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;做了多层activation，手工配置权重&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; mlp_xor(x1, x2, activation=&lt;span&gt;heaviside):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; activation(-activation(x1 + x2 - 1.5) + activation(x1 + x2 - 0.5) - 0.5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如图所示，两层MLP，包含输入层，隐层，输出层。所谓的深度神经网络，就是隐层数量多一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120084803571-1937790826.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120085016274-923865625.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120085030680-1447726687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;激活函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是几个激活函数的例子，其微分如右图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120083646602-351761502.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1214565/201711/1214565-20171120083952055-864488443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;step是最早提出的一种激活函数，但是它在除0外所有点的微分都是0，没有办法计算梯度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;logit和双曲正切函数tanh梯度消失，数据量很大时，梯度无限趋近于0，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;relu在层次很深时梯度也不为0，无限传导下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;如何自动化学习计算权重——backpropagation&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先正向做一个计算，根据当前输出做一个error计算，作为指导信号反向调整前一层输出权重使其落入一个合理区间，反复这样调整到第一层，每轮调整都有一个学习率，调整结束后，网络越来越合理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;step函数换成逻辑回归函数σ(z) = 1 / (1 + exp(–z))，无论x落在哪个区域，最后都有一个非0的梯度可以使用，落在（0,1）区间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双曲正切函数The hyperbolic tangent function tanh (z) = 2σ(2z) – 1，在（-1,1）的区间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The ReLU function ReLU (z) = max (0, z)，层次很深时不会越传递越小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多分类时，使用softmax（logistics激活函数）最为常见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用MLP多分类输出层为softmax，隐层倾向于使用ReLU，因为向前传递时不会有数值越来越小得不到训练的情况产生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以mnist数据集为例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; construction phase&lt;/span&gt;
n_inputs = 28*28 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MNIST&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 隐藏层节点数目&lt;/span&gt;
n_hidden1 = 300&lt;span&gt;
n_hidden2 &lt;/span&gt;= 100&lt;span&gt;
n_outputs &lt;/span&gt;= 10&lt;span&gt;

X &lt;/span&gt;= tf.placeholder(tf.float32, shape=(None, n_inputs), name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
y &lt;/span&gt;= tf.placeholder(tf.int64, shape=(None), name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; neuron_layer(X, n_neurons, name, activation=&lt;span&gt;None):
    with tf.name_scope(name):
        n_inputs &lt;/span&gt;= int(X.get_shape()[1&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标准差初始设定，研究证明设为以下结果训练更快&lt;/span&gt;
        stddev = 2 /&lt;span&gt; np.sqrt(n_inputs)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用截断的正态分布，过滤掉极端的数据，做了一个初始权重矩阵，是input和neurons的全连接矩阵&lt;/span&gt;
        init = tf.truncated_normal((n_inputs, n_neurons), stddev=&lt;span&gt;stddev)
        W &lt;/span&gt;= tf.Variable(init, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weights&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; biases项初始化为0&lt;/span&gt;
        b = tf.Variable(tf.zeros([n_neurons]), name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;biases&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该层输出&lt;/span&gt;
        z = tf.matmul(X, W) +&lt;span&gt; b
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据activation选择激活函数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; activation==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tf.nn.relu(z)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; z

with tf.name_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dnn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 算上输入层一共4层的dnn结构&lt;/span&gt;
    hidden1 = neuron_layer(X, n_hidden1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hidden1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, activation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    hidden2 &lt;/span&gt;= neuron_layer(hidden1, n_hidden2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hidden2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, activation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出最后结果值&lt;/span&gt;
    logits = neuron_layer(hidden2, n_outputs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用TensorFlow自带函数实现，最新修改成dense函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; fully_connected
with tf.name_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dnn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    hidden1 &lt;/span&gt;= fully_connected(X, n_hidden1, scope=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hidden1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    hidden2 &lt;/span&gt;= fully_connected(hidden1, n_hidden2, scope=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hidden2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    logits &lt;/span&gt;= fully_connected(hidden2, n_outputs, scope=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, activation_fn=&lt;span&gt;None)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用logits（网络输出）计算交叉熵，取均值为误差&lt;/span&gt;
with tf.name_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
      xentropy &lt;/span&gt;= tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=&lt;span&gt;logits)
    loss &lt;/span&gt;= tf.reduce_mean(xentropy, name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

learning_rate &lt;/span&gt;= 0.01&lt;span&gt;
with tf.name_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;train&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    optimizer &lt;/span&gt;=&lt;span&gt; tf.train.GradientDescentOptimizer(learning_rate)
    training_op &lt;/span&gt;=&lt;span&gt; optimizer.minimize(loss)

with tf.name_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    correct &lt;/span&gt;= tf.nn.in_top_k(logits, y, 1&lt;span&gt;)
    accuracy &lt;/span&gt;=&lt;span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

init &lt;/span&gt;=&lt;span&gt; tf.global_variables_initializer()
saver &lt;/span&gt;=&lt;span&gt; tf.train.Saver()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Execution Phase&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_data
mnist &lt;/span&gt;= input_data.read_data_sets(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tmp/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 外层大循环跑400次，每个循环中小循环数据量50&lt;/span&gt;
n_epochs = 400&lt;span&gt;
batch_size &lt;/span&gt;= 50&lt;span&gt;
with tf.Session() as sess:
    init.run()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; epoch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n_epochs):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; iteration &lt;span&gt;in&lt;/span&gt; range(mnist.train.num_examples //&lt;span&gt; batch_size):
            X_batch, y_batch &lt;/span&gt;=&lt;span&gt; mnist.train.next_batch(batch_size)
            sess.run(training_op, feed_dict&lt;/span&gt;=&lt;span&gt;{X: X_batch, y: y_batch})
        acc_train &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: X_batch, y: y_batch})
        acc_test &lt;/span&gt;= accuracy.eval(feed_dict=&lt;span&gt;{X: mnist.test.images,y: mnist.test.labels})
         &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(epoch, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Train accuracy:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, acc_train, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test accuracy:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, acc_test)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下次再跑模型时不用再次训练了&lt;/span&gt;
save_path = saver.save(sess, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_final.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下次调用&lt;/span&gt;
&lt;span&gt;with tf.Session() as sess:
    saver.restore(sess, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./my_model_final.ckpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; or better, use save_path&lt;/span&gt;
    X_new_scaled = mnist.test.images[:20&lt;span&gt;]
    Z &lt;/span&gt;= logits.eval(feed_dict=&lt;span&gt;{X: X_new_scaled})
    y_pred &lt;/span&gt;= np.argmax(Z, axis=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;超参数设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;隐层数量：一般来说单个隐层即可，对于复杂问题，由于深层模型可以实现浅层的指数级别的效果，且每层节点数不多，加至overfit就不要再加了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每层神经元数量：以漏斗形逐层递减，输入层最多，逐渐features更少代表性更强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;激活函数选择（activation function）：隐层多选择ReLU，输出层多选择softmax&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 01:58:00 +0000</pubDate>
<dc:creator>水奈樾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rucwxb/p/7865021.html</dc:identifier>
</item>
<item>
<title>四、VueJs 填坑日记之搭建Axios接口请求工具 - 王 二 麻 子</title>
<link>http://www.cnblogs.com/xinhudong/p/7865004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinhudong/p/7865004.html</guid>
<description>&lt;p&gt;上一章，我们认识了项目的目录结构，以及对项目的目录结构做了一些调整，已经能把项目重新跑起来了。今天我们来搭建api接口调用工具Axios。Vue本身是不支持ajax调用的，如果你需要这些功能就需要安装对应的工具。&lt;/p&gt;
&lt;p&gt;支持ajax请求的工具很多，像superagent和axios。今天我们用的就是axios，因为听说最近网上大部分的教程书籍都使用的是axios，本身axios这个工具就已经做了很好的优化和封装，但是在使用时，还是比较繁琐，所以我们来重新封装一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;安装Axios工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
cnpm install axios -D
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/441889/201711/441889-20171120094922024-1206670026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在安装的时候，一定要切换进入咱们的项目根目录，再运行安装命令，然后如提示以上信息，则表示安装完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;封装Axios工具&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;编辑src/api/index.js文件（我们在上一章整理目录结构时，在src/api/目录新建了一个空的index.js文件），现在我们为该文件填写内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;76&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 配置API接口地址
var root = 'https://cnodejs.org/api/v1'
// 引用axios
var axios = require('axios')
// 自定义判断元素类型JS
function toType (obj) {
        return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
}
// 参数过滤函数
function filterNull (o) {
        for (var key in o) {
                if (o[key] === null) {
                        delete o[key]
                }
                if (toType(o[key]) === 'string') {
                        o[key] = o[key].trim()
                } else if (toType(o[key]) === 'object') {
                        o[key] = filterNull(o[key])
                } else if (toType(o[key]) === 'array') {
                        o[key] = filterNull(o[key])
                }
        }
        return o
}

/*
  接口处理函数
  这个函数每个项目都是不一样的，我现在调整的是适用于
  https://cnodejs.org/api/v1 的接口，如果是其他接口
  需要根据接口的参数进行调整。参考说明文档地址：
  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd
  主要是，不同的接口的成功标识和失败提示是不一致的。
  另外，不同的项目的处理方法也是不一致的，这里出错就是简单的alert
*/
function apiAxios (method, url, params, success, failure) {
        if (params) {
                params = filterNull(params)
        }
        axios({
                method: method,
                url: url,
                data: method === 'POST' || method === 'PUT' ? params : null,
                params: method === 'GET' || method === 'DELETE' ? params : null,
                baseURL: root,
                withCredentials: false
        })
        .then(function (res) {
        if (res.data.success === true) {
                if (success) {
                        success(res.data)
                }
        } else {
                if (failure) {
                        failure(res.data)
                } else {
                        window.alert('error: ' + JSON.stringify(res.data))
                }
        }
        })
        .catch(function (err) {
                let res = err.response
                if (err) {
                        window.alert('api error, HTTP CODE: ' + res.status)
                }
        })
}

// 返回在vue模板中的调用接口
export default {
        get: function (url, params, success, failure) {
                return apiAxios('GET', url, params, success, failure)
        },
        post: function (url, params, success, failure) {
                return apiAxios('POST', url, params, success, failure)
        },
        put: function (url, params, success, failure) {
                return apiAxios('PUT', url, params, success, failure)
        },
        delete: function (url, params, success, failure) {
                return apiAxios('DELETE', url, params, success, failure)
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多关于AxIos的解释请参见：https://github.com/mzabriskie/axios&lt;/p&gt;
&lt;p&gt;配置Axios工具&lt;br/&gt;我们在使用之前，需要在src/main.js中进行简单的配置，先来看一下原始的main.js文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
    new Vue({
    el: '#app',
    router,
    template: '&amp;lt;App/&amp;gt;',
    components: { App }
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'

// 引用API文件
import api from './api/index.js'
// 将API方法绑定到全局
Vue.prototype.$api = api

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
    el: '#app',
    router,
    template: '&amp;lt;App/&amp;gt;',
    components: { App }
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以上的配置，我们就可以在项目中使用axios工具了，接下来我们来测试一下这个工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用Axios工具&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;我们来修改一下 src/page/Index.vue 文件，将代码调整为以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;index page&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
    created () {
        this.$api.get('topics', null, r =&amp;gt; {
            console.log(r)
        })
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在Index.vue中向浏览器的控制台输入一些接口请求到的数据，如果你和我也一样，那说明我们的接口配置完成正确。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/441889/201711/441889-20171120095152946-488426199.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你是按我的操作一步一步来，那最终结果应该和我一样。如果出错请仔细检查代码。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 01:53:00 +0000</pubDate>
<dc:creator>王 二 麻 子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinhudong/p/7865004.html</dc:identifier>
</item>
<item>
<title>手工搭建基于ABP的框架(3) - 登录，权限控制与日志 - 古霜卡比</title>
<link>http://www.cnblogs.com/skabyy/p/7695258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skabyy/p/7695258.html</guid>
<description>&lt;blockquote readability=&quot;3.781512605042&quot;&gt;
&lt;p&gt;为了防止不提供原网址的转载，特在这里加上原文链接：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/skabyy/p/7695258.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/skabyy/p/7695258.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇将实现登录、权限控制、日志配置与审计日志的功能。首先我们先实现登录功能，在登录的基础上，通过控权使得只有ID为1988的用户才能创建tweet。最后配置Log4Net日志，并开启审计日志，记录所有Web请求。&lt;/p&gt;
&lt;h3 id=&quot;简单的界面&quot;&gt;简单的界面&lt;/h3&gt;
&lt;p&gt;为了测试方便，在实现登录功能之前，先简单实现了几个页面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;Tweets列表页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201710/576869-20171019212042193-1337253711.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建tweet页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201710/576869-20171019212102068-1585306366.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201710/576869-20171019212119474-2125744491.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;页面代码没有什么特别的，这里就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;登录&quot;&gt;登录&lt;/h3&gt;
&lt;p&gt;我们不希望所有人都能创建tweet，而是只有已登录的用户才能创建。本小节将实现登录功能，限制创建tweet页面只有已登陆用户才能访问。&lt;/p&gt;
&lt;p&gt;首先在&lt;code&gt;Web.config&lt;/code&gt;的&lt;code&gt;system.web&lt;/code&gt;里加上这段配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201710/576869-20171028164213055-1422439620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后设置首页和登录页面可以匿名访问。给&lt;code&gt;Home/Index&lt;/code&gt;和&lt;code&gt;Account/Login&lt;/code&gt;这两个Action加上&lt;code&gt;AllowAnonymous&lt;/code&gt;特性。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[AllowAnonymous]
public ActionResult Index()

[AllowAnonymous]
public ActionResult Login(string returnUrl)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来实现登录功能。登录功能的实现有两步：&lt;/p&gt;
&lt;ol readability=&quot;19.189834024896&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;用户发起登录请求后，验证完用户名密码，生成cookie，然后把cookie返回给前端。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[HttpPost]
[AllowAnonymous]
public ActionResult LoginAjax(LoginInput input)
{
    // 这里应该放验证用户名密码是否正确的代码。
    // 为了测试方便，这里跳过验证，使用任意用户名任意密码都能登录。
    var username = input.Username;
    var ticket = new FormsAuthenticationTicket(
        1 /* version */,
        username,
        DateTime.Now,
        DateTime.Now.Add(FormsAuthentication.Timeout),
        false /* persistCookie */,
        &quot;&quot; /* userData */);
    var userCookie = new HttpCookie(
        FormsAuthentication.FormsCookieName,
        FormsAuthentication.Encrypt(ticket));
    HttpContext.Response.Cookies.Add(userCookie);
    return Json(&quot;OK&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;code&gt;LoginAjax&lt;/code&gt;接口要加上&lt;code&gt;AllowAnonymous&lt;/code&gt;特性允许匿名访问&lt;/strong&gt;。为了测试方便，这里没有对用户名密码进行验证，使用任意用户名任意密码都能登录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;24.418898433552&quot;&gt;
&lt;p&gt;用户每次访问时，根据&lt;code&gt;userId&lt;/code&gt;创建claim、identity和principal，并把principal赋值给&lt;code&gt;HttpContext.Current.User&lt;/code&gt;。这部分代码实现在过滤器。新建过滤器类&lt;code&gt;MvcAuthorizeAttribute&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MvcAuthorizeAttribute : AuthorizeAttribute
{
    public override void OnAuthorization(AuthorizationContext filterContext)
    {
        // IIS会从cookie解析出userId并生成一个principal赋值给Thread.CurrentPrincipal
        var userId = Thread.CurrentPrincipal?.Identity?.Name;

        if (!string.IsNullOrEmpty(userId))
        {
            // 创建identity
            var identity = new GenericIdentity(userId);
            // 添加Type为AbpClaimTypes.UserId使userId能注入到AbpSession
            identity.AddClaim(new Claim(AbpClaimTypes.UserId, userId));
            // 创建principal
            var principal = new GenericPrincipal(identity, null);
            // 同步Thread.CurrentPrincipal
            Thread.CurrentPrincipal = principal;
            if (HttpContext.Current != null)
            {
                // 将principal赋值给HttpContext.Current.User，用户就登录进去了。
                HttpContext.Current.User = principal;
            }
        }

        base.OnAuthorization(filterContext);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于claim、identity和principal这三个概念的详细解释可以看&lt;a href=&quot;http://www.cnblogs.com/savorboard/p/aspnetcore-identity.html&quot;&gt;这位哥们的博客&lt;/a&gt;。然后将过滤器&lt;code&gt;MvcAuthorizeAttribute&lt;/code&gt;加到全局过滤器配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;filters.Add(new MvcAuthorizeAttribute());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到过滤器&lt;code&gt;MvcAuthorizeAttribute&lt;/code&gt;继承了&lt;code&gt;AuthorizeAttribute&lt;/code&gt;。因而将这个过滤器加到全局过滤后，除了带&lt;code&gt;AllowAnonymous&lt;/code&gt;特性的Action外，其他Action被未登录用户访问时就会跳转到登录页面。&lt;/p&gt;
&lt;p&gt;另外为了让ABP能够使用登录用户信息，要将&lt;code&gt;Type&lt;/code&gt;为&lt;code&gt;AbpClaimTypes.UserId&lt;/code&gt;，值为&lt;code&gt;userId&lt;/code&gt;的&lt;code&gt;Claim&lt;/code&gt;添加到&lt;code&gt;Identity&lt;/code&gt;里，这样&lt;code&gt;userId&lt;/code&gt;会自动注入到&lt;code&gt;AbpSession&lt;/code&gt;中。我们在后续代码中也可以通过&lt;code&gt;AbpSession.UserId.HasValue&lt;/code&gt;来判断用户是否已登陆。&lt;/p&gt;
&lt;p&gt;需要注意的一点是&lt;strong&gt;ABP只支持数字类型的&lt;code&gt;userId&lt;/code&gt;&lt;/strong&gt;。所以要确保&lt;code&gt;userId&lt;/code&gt;是一个能转成整数的字符串。如果需要其他类型的&lt;code&gt;userId&lt;/code&gt;（比如字符串类型）则需要&lt;a href=&quot;http://www.cnblogs.com/sheng-jie/p/6370338.html&quot;&gt;对&lt;code&gt;AbpSession&lt;/code&gt;进行扩展&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;权限控制&quot;&gt;权限控制&lt;/h3&gt;
&lt;p&gt;本小节将对创建tweet的权限做进一步的限制，让只有ID为1988的用户才可以创建tweet。为了实现权限控制，我们需要实现三个部分：&lt;/p&gt;
&lt;ol readability=&quot;25.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义权限。&lt;/p&gt;
&lt;p&gt;新建类&lt;code&gt;MyTweetAuthorizationProvider&lt;/code&gt;，在&lt;code&gt;SetPermissions&lt;/code&gt;方法中定义创建tweet的权限。&lt;code&gt;MyTweetAuthorizationProvider&lt;/code&gt;要继承&lt;code&gt;AuthorizationProvider&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class MyTweetPermission
{
    public const string CreateTweet = &quot;CreateTweet&quot;;
}

public class MyTweetAuthorizationProvider : AuthorizationProvider
{
    public override void SetPermissions(IPermissionDefinitionContext context)
    {
        context.CreatePermission(MyTweetPermission.CreateTweet);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;权限判断逻辑。即哪些用户拥有哪些权限的逻辑。&lt;/p&gt;
&lt;p&gt;通过实现接口&lt;code&gt;IPermissionChecker&lt;/code&gt;来实现自定义的权限判断逻辑。新建类&lt;code&gt;MyTweetPermissionChecker&lt;/code&gt;，并将逻辑写在方法&lt;code&gt;IsGrantedAsync&lt;/code&gt;中。我们只允许ID为“1988”的用户创建tweet。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyTweetPermissionChecker : IPermissionChecker, ITransientDependency
{
    public IAbpSession AbpSession { get; set; }

    public Task&amp;lt;bool&amp;gt; IsGrantedAsync(string permissionName)
    {
        var userId = AbpSession.GetUserId();
        return IsGrantedAsync(new UserIdentifier(null, userId), permissionName);
    }

    public Task&amp;lt;bool&amp;gt; IsGrantedAsync(UserIdentifier user, string permissionName)
    {
        var userId = user.UserId;
        var t = new Task&amp;lt;bool&amp;gt;(() =&amp;gt;
        {
            if (permissionName == MyTweetPermission.CreateTweet)
            {
                return userId == 1988;
            }
            return true;
        });
        t.Start();
        return t;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有两个地方要注意。一个是类&lt;code&gt;MyTweetPermissionChecker&lt;/code&gt;同时要实现&lt;code&gt;ITransientDependency&lt;/code&gt;，才能被自动注入（&lt;code&gt;IPermissionChecker&lt;/code&gt;并没有继承&lt;code&gt;ITransientDependency&lt;/code&gt;）。另一个地方是方法&lt;code&gt;IsGrantedAsync&lt;/code&gt;是异步方法，要返回&lt;code&gt;Task&amp;lt;bool&amp;gt;&lt;/code&gt;类型，并且确保返回的task已经&lt;code&gt;Start&lt;/code&gt;了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;30&quot;&gt;
&lt;p&gt;标记哪些方法（一般是Action或&lt;code&gt;AppService&lt;/code&gt;的方法）属于哪些权限。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;AbpMvcAuthorize&lt;/code&gt;将创建tweet的权限标记在Action &lt;code&gt;/Home/CreateTweet&lt;/code&gt;上：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[AbpMvcAuthorize(MyTweetPermission.CreateTweet)]
public ActionResult CreateTweet()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让&lt;code&gt;AbpMvcAuthorize&lt;/code&gt;能生效，我们还需要让&lt;code&gt;HomeController&lt;/code&gt;继承&lt;code&gt;AbpController&lt;/code&gt;（在实践中，一般要在&lt;code&gt;AbpController&lt;/code&gt;上再封装一个&lt;code&gt;BaseController&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class HomeController : AbpController&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且&lt;code&gt;MyTweetWebModule&lt;/code&gt;要依赖&lt;code&gt;AbpWebMvcModule&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[DependsOn(
    typeof(AbpWebMvcModule),
    typeof(AbpWebApiModule),
    typeof(MyTweetApplicationModule))]
public class MyTweetWebModule : AbpModule&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，创建tweet的POST接口也要控权。由于WebAPI是取不到AbpSession的（如果一定要用WebAPI只能用其它方法控权），因此我们需要另外做一个MVC版本的接口来控权（然后前端也做相应的修改）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TweetController : AbpController
{
    private IMyTweetAppService _myTweetAppService;

    public TweetController(IMyTweetAppService appSvc)
    {
        _myTweetAppService = appSvc;
    }

    [HttpPost]
    [AbpMvcAuthorize(MyTweetPermission.CreateTweet)]
    public ActionResult Create(CreateTweetInput input)
    {
        var tweet = _myTweetAppService.CreateTweet(input);
        return Json(tweet);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;另外，你也可以在应用层上标记权限（前提是你是用MVC接口调用应用层的方法，而非WebAPI）。&lt;strong&gt;Controller用&lt;code&gt;AbpMvcAuthorize&lt;/code&gt;标记权限，而AppService用&lt;code&gt;AbpAuthorize&lt;/code&gt;标记权限。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[AbpAuthorize(MyTweetPermission.CreateTweet)]
public object CreateTweet(CreateTweetInput input)&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;测试一下，用“1988”登录可以正常访问（正常访问的不截图了）。而其他用户则提示无访问权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201710/576869-20171030220708840-78336123.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;日志配置与审计日志&quot;&gt;日志配置与审计日志&lt;/h3&gt;
&lt;h4 id=&quot;日志配置&quot;&gt;日志配置&lt;/h4&gt;
&lt;p&gt;ABP框架使用Log4Net来进行日志管理，并且在Log4Net基础上封装了个&lt;code&gt;Abp.Castle.Log4Net&lt;/code&gt;包。首先将NuGet包&lt;code&gt;Abp.Castle.Log4Net&lt;/code&gt;安装到&lt;code&gt;MyTweet.Web&lt;/code&gt;项目。&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;MyTweet.Web&lt;/code&gt;根目录下创建Log4Net的配置文件（你也可以在其他你喜欢的位置创建，只要后面代码里写对路径就行），文件名为&lt;code&gt;log4net.config&lt;/code&gt;。下面是我用的配置文件，基本上用的Log4Net默认的配置内容，只是日志存放文件修改到了&lt;code&gt;Logs/Logs.txt&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;log4net&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;appender&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;RollingFileAppender&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;log4net.Appender.RollingFileAppender&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Logs/Logs.txt&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;appendToFile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;rollingStyle&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Size&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;maxSizeRollBackups&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;maximumFileSize&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10000KB&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;staticLogFileName&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;layout&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;log4net.Layout.PatternLayout&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;conversionPattern&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;%-5level %date [%-5.5thread] %-40.40logger - %message%newline&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;root&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;appender-ref&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;RollingFileAppender&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;level&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;DEBUG&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;logger&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;NHibernate&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;level&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;WARN&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/logger&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/log4net&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建好配置文件后，到&lt;code&gt;MvcApplication&lt;/code&gt;的&lt;code&gt;Application_Start&lt;/code&gt;方法里加上下面这行代码，开启日志功能。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IocManager.Instance.IocContainer.AddFacility&amp;lt;LoggingFacility&amp;gt;(
    f =&amp;gt; f.UseAbpLog4Net().WithConfig(&quot;log4net.config&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有个要注意的地方是需要在文件开头加上下面这行&lt;code&gt;using&lt;/code&gt;语句，不然&lt;code&gt;f.UseAbpLog4Net&lt;/code&gt;会报错。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Abp.Castle.Logging.Log4Net;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好后，我们可以使用依赖注入注入到&lt;code&gt;ILogger&lt;/code&gt;接口的&lt;code&gt;Logger&lt;/code&gt;对象来写日志。在首页的Action方法中加上几行写日志的代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[AllowAnonymous]
public ActionResult Index()
{
    if (AbpSession.UserId.HasValue)
    {
        Logger.Info(string.Format(&quot;用户{0}访问了首页！&quot;, AbpSession.UserId));
    }
    else
    {
        Logger.Info(&quot;匿名用户访问了首页！&quot;);
    }
    return View();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别用匿名身份和登录用户身份访问一下首页，然后到&lt;code&gt;MyTweet.Web&lt;/code&gt;的根目录下查看&lt;code&gt;Logs/Logs.txt&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201711/576869-20171104014450857-998755182.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;审计日志&quot;&gt;审计日志&lt;/h4&gt;
&lt;p&gt;维基百科说： “审计跟踪（也叫审计日志）是与安全相关的按照时间顺序的记录，记录集或者记录源，它们提供了活动序列的文档证据，这些活动序列可以在任何时间影响一个特定的操作，步骤或其他”。&lt;/p&gt;
&lt;p&gt;对于我们Web应用来说，审计日志负责记录所有用户的请求。如果是硬编码实现的话，我们需要在所有的Action方法里加上记录日志的代码。这显然是既耗时又不科学的。幸运的是我们不需要这么做，ABP框架自带审计日志的功能。只要我们配置好日志功能（前面已经做了），ABP会默认记录所有已登陆用户（通过&lt;code&gt;AbpSession.UserId.HasValue&lt;/code&gt;判断是否已登陆）的访问。查看&lt;code&gt;Logs/Logs.txt&lt;/code&gt;文件会发现刚才我们访问首页的行为已经被记录到日志里了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INFO  2017-11-02 15:39:23,055 [29   ] Abp.Auditing.SimpleLogAuditingStore      - AUDIT LOG: MyTweet.Web.Controllers.HomeController.Index is executed by user 1988 in 1 ms from 10.211.55.3 IP address with succeed.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行日志记录了这些信息：用户名、用户IP地址、访问的方法、响应耗时以及访问结果。另外，在这行日志的开头有这个字段：&lt;code&gt;Abp.Auditing.SimpleLogAuditingStore&lt;/code&gt;。这个表示该日志内容是由类&lt;code&gt;Abp.Auditing.SimpleLogAuditingStore&lt;/code&gt;处理记录的。该类实现了&lt;code&gt;IAuditingStore&lt;/code&gt;接口。如果我们要自定义审计日志的内容，我们需要自己实现这个接口。下面我们实现一个输出中文的审计日志。在&lt;code&gt;MyTweet.Web&lt;/code&gt;项目下新建类&lt;code&gt;MyTweetLogAuditingStore&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyTweetLogAuditingStore : IAuditingStore, ITransientDependency
{
    public ILogger Logger { get; set; }

    public MyTweetLogAuditingStore()
    {
        Logger = NullLogger.Instance;
    }

    public Task SaveAsync(AuditInfo auditInfo)
    {
        var userId = auditInfo.UserId;
        var userIp = auditInfo.ClientIpAddress;
        var browserInfo = auditInfo.BrowserInfo;
        var action = $&quot;{auditInfo.ServiceName}.{auditInfo.MethodName}&quot;;
        var ms = auditInfo.ExecutionDuration;
        var msg = $&quot;用户{userId}（坐标{userIp}）使用{browserInfo}访问了方法{action}，该方法在{ms}毫秒内进行了回击，回击结果：&quot;;
        if (auditInfo.Exception == null)
        {
            Logger.Info(msg + &quot;成功！&quot;);
        }
        else
        {
            Logger.Warn(msg + &quot;出错了：&quot; + auditInfo.Exception.Message);
        }
        return Task.FromResult(0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再访问首页，然后看看日志记了啥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INFO  2017-11-02 16:45:53,374 [35   ] et.Web.App_Start.MyTweetLogAuditingStore - 用户1988（坐标10.211.55.3）使用Chrome / 61.0 / WinNT访问了方法MyTweet.Web.Controllers.HomeController.Index，该方法在77毫秒内进行了回击，回击结果：成功！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于审计日志的其他配置这里不再多说，有需要的同学可以看&lt;a href=&quot;http://www.cnblogs.com/farb/p/ABPAuditLog.html&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;我们已经使用ABP搭建了一个相对完整的tweet应用。它虽然十分简陋，但也是五脏俱全。它能够进行数据库访问，拥有登录、控权、日志等功能。后面会再添加UoW、单元测试等内容。&lt;/p&gt;
&lt;p&gt;关于ABP后续的学习和使用，除了查看&lt;a href=&quot;https://aspnetboilerplate.com/Pages/Documents&quot;&gt;官方文档&lt;/a&gt;外，强烈建议直接阅读&lt;a href=&quot;https://github.com/aspnetboilerplate/aspnetboilerplate&quot;&gt;ABP的源码&lt;/a&gt;。为了弄清楚一些犄角旮旯的细节，在文档里翻找半天往往不如直接查阅代码来得效率高。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 01:48:00 +0000</pubDate>
<dc:creator>古霜卡比</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skabyy/p/7695258.html</dc:identifier>
</item>
</channel>
</rss>