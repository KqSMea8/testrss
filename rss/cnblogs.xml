<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Vue状态管理vuex - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/7554127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/7554127.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue提供了vuex。本文将详细介绍Vue状态管理vuex&lt;/p&gt;

&lt;h3&gt;引入&lt;/h3&gt;
&lt;p&gt;　　当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const sourceOfTruth =&lt;span&gt; {}
const vmA = new&lt;span&gt; Vue({
  data: sourceOfTruth
})
const vmB = new&lt;span&gt; Vue({
  data: sourceOfTruth
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在当 &lt;code&gt;sourceOfTruth&lt;/code&gt; 发生变化，&lt;code&gt;vmA&lt;/code&gt; 和 &lt;code&gt;vmB&lt;/code&gt; 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 &lt;code&gt;this.$root.$data&lt;/code&gt; 去访问。现在有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，采用一个简单的 &lt;strong&gt;store 模式&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
var store =&lt;span&gt; {
  debug: true&lt;span&gt;,
  state: {
    message: 'Hello!'&lt;span&gt;
  },
  setMessageAction (newValue) {
    if (this.debug) console.log('setMessageAction triggered with'&lt;span&gt;, newValue)
    this.state.message =&lt;span&gt; newValue
  },
  clearMessageAction () {
    if (this.debug) console.log('clearMessageAction triggered'&lt;span&gt;)
    this.state.message = ''&lt;span&gt;
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，现在也会有一个 log 记录 bug 之前发生了什么&lt;/p&gt;
&lt;p&gt;　　此外，每个实例/组件仍然可以拥有和管理自己的私有状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
var vmA = new&lt;span&gt; Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})
var vmB = new&lt;span&gt; Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://cn.vuejs.org/images/state.png&quot; alt=&quot;状态管理&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]不应该在action中替换原始的状态对象，组件和store需要引用同一个共享对象，mutation才能够被观察&lt;/p&gt;
&lt;p&gt;　　接着继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，最终达成了 Flux 架构。这样约定的好处是，能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能&lt;/p&gt;
&lt;p&gt;【状态管理模式】&lt;/p&gt;
&lt;p&gt;　　下面以一个简单的计数应用为例，来说明状态管理模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state&lt;/span&gt;
&lt;span&gt;  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      count: &lt;/span&gt;0&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; view&lt;/span&gt;
&lt;span&gt;  template: `
  &lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;{{count}}&amp;lt;/span&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;+&quot; @click=&quot;increment&quot;&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;span&gt;  `,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions&lt;/span&gt;
&lt;span&gt;  methods: {
    increment () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这个状态自管理应用包含以下几个部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;state，驱动应用的数据源；
view，以声明方式将 state 映射到视图；
actions，响应在 view 上的用户输入导致的状态变化。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个表示“单向数据流”理念的极简示意：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://vuex.vuejs.org/zh-cn/images/flow.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　但是，当应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏，存在以下两个问题&lt;/p&gt;
&lt;p&gt;　　1、多个视图依赖于同一状态&lt;/p&gt;
&lt;p&gt;　　2、来自不同视图的行为需要变更同一状态&lt;/p&gt;
&lt;p&gt;　　对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。&lt;/p&gt;
&lt;p&gt;　　因此，为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为&lt;/p&gt;
&lt;p&gt;　　另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。&lt;/p&gt;
&lt;p&gt;　　这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://vuex.vuejs.org/zh-cn/images/vuex.png&quot; alt=&quot;vuex&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【使用情况】&lt;/p&gt;
&lt;p&gt;　　虽然 Vuex 可以帮助管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。&lt;/p&gt;
&lt;p&gt;　　如果不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果应用够简单，最好不要使用 Vuex。一个简单的 global event bus 就足够所需了。但是，如果需要构建是一个中大型单页应用，很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择&lt;/p&gt;

&lt;h3&gt;开始&lt;/h3&gt;
&lt;p&gt;【安装】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install vuex --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在一个模块化的打包系统中，必须显式地通过 &lt;code&gt;Vue.use()&lt;/code&gt; 来安装 Vuex&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import Vuex from &lt;/span&gt;'vuex'&lt;span&gt;

Vue.use(Vuex)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当使用全局 script 标签引用 Vuex 时，不需要以上安装过程&lt;/p&gt;
&lt;p&gt;【概述】&lt;/p&gt;
&lt;p&gt;　　每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：&lt;/p&gt;
&lt;p&gt;　　1、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新&lt;/p&gt;
&lt;p&gt;　　2、不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解应用&lt;/p&gt;
&lt;p&gt;【最简单的store】&lt;/p&gt;
&lt;p&gt;　　下面来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)&lt;/span&gt;&lt;span&gt;
const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;0&lt;span&gt;
  },
  mutations: {
    increment (state) {
      state.count&lt;/span&gt;++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在，可以通过 &lt;code&gt;store.state&lt;/code&gt; 来获取状态对象，以及通过 &lt;code&gt;store.commit&lt;/code&gt; 方法触发状态变更：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.commit('increment'&lt;span&gt;)
console.log(store.state.count) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过提交 mutation 的方式，而非直接改变 &lt;code&gt;store.state.count&lt;/code&gt;，是因为想要更明确地追踪到状态的变化。这个简单的约定能够让意图更加明显，这样在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，甚至可以实现如时间穿梭般的调试体验。&lt;/p&gt;
&lt;p&gt;　　由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation&lt;/p&gt;
&lt;p&gt;　　下面是一个使用vuex实现的简单计数器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;0&lt;span&gt;
  },
  mutations: {
    increment: state &lt;/span&gt;=&amp;gt; state.count++&lt;span&gt;,
    decrement: state &lt;/span&gt;=&amp;gt; state.count--&lt;span&gt;,
  }
})
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  computed: {
    count () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store.state.count
    }
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; view&lt;/span&gt;
&lt;span&gt;  template: `
  &lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;-&quot; @click=&quot;decrement&quot;&amp;gt;
    &amp;lt;span&amp;gt;{{count}}&amp;lt;/span&amp;gt;
    &amp;lt;input type=&quot;button&quot; value=&quot;+&quot; @click=&quot;increment&quot;&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;span&gt;  `,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions&lt;/span&gt;
&lt;span&gt;  methods: {
    increment () {
      store.commit(&lt;/span&gt;'increment'&lt;span&gt;)
    },
    decrement () {
      store.commit(&lt;/span&gt;'decrement'&lt;span&gt;)
    },    
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3&gt;state&lt;/h3&gt;
&lt;p&gt;【单一状态树】&lt;/p&gt;
&lt;p&gt;　　Vuex 使用单一状态树——用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照&lt;/p&gt;
&lt;p&gt;【在VUE组件中获得VUEX状态】&lt;/p&gt;
&lt;p&gt;　　如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Counter 组件&lt;/span&gt;
const Counter =&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;{{ count }}&amp;lt;/div&amp;gt;`,
&lt;span&gt;  computed: {
    count () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store.state.count
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每当 &lt;code&gt;store.state.count&lt;/code&gt; 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM&lt;/p&gt;
&lt;p&gt;　　然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。&lt;/p&gt;
&lt;p&gt;　　Vuex 通过 &lt;code&gt;store&lt;/code&gt; 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件&lt;/span&gt;
&lt;span&gt;  store,
  components: { Counter },
  template: `
    &lt;/span&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
      &amp;lt;counter&amp;gt;&amp;lt;/counter&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  `
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过在根实例中注册 &lt;code&gt;store&lt;/code&gt; 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过&lt;code&gt;this.$store&lt;/code&gt;访问到。下面来更新下 &lt;code&gt;Counter&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const Counter =&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;{{ count }}&amp;lt;/div&amp;gt;`,
&lt;span&gt;  computed: {
    count () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.count
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【mapState辅助函数】&lt;/p&gt;
&lt;p&gt;　　当一个组件需要获取多个状态时，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，可以使用&lt;code&gt;mapState&lt;/code&gt;辅助函数帮助生成计算属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在单独构建的版本中辅助函数为 Vuex.mapState&lt;/span&gt;
import { mapState } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  computed: mapState({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 箭头函数可使代码更简练&lt;/span&gt;
    count: state =&amp;gt;&lt;span&gt; state.count,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传字符串参数 'count' 等同于 `state =&amp;gt; state.count`&lt;/span&gt;
    countAlias: 'count'&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了能够使用 `this` 获取局部状态，必须使用常规函数&lt;/span&gt;
&lt;span&gt;    countPlusLocalState (state) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.count + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localCount
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当映射的计算属性的名称与 state 的子节点名称相同时，也可以给 &lt;code&gt;mapState&lt;/code&gt; 传一个字符串数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: mapState([
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射 this.count 为 store.state.count&lt;/span&gt;
  'count'&lt;span&gt;
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【对象展开运算符】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　mapState&lt;/code&gt; 函数返回的是一个对象。如何将它与局部计算属性混合使用呢？通常，需要使用一个工具函数将多个对象合并为一个，将最终对象传给 &lt;code&gt;computed&lt;/code&gt; 属性。但是自从有了对象展开运算符，可以极大地简化写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  localComputed () { &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用对象展开运算符将此对象混入到外部对象中&lt;/span&gt;
&lt;span&gt;  ...mapState({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【组件仍然保有局部状态】&lt;/p&gt;
&lt;p&gt;　　使用 Vuex 并不意味着需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态&lt;/p&gt;

&lt;h3&gt;Getter&lt;/h3&gt;
&lt;p&gt;　　有时候需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  doneTodosCount () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.$store.state.todos.filter(todo =&amp;gt;&lt;span&gt; todo.done).length
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果有多个组件需要用到此属性，要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想&lt;/p&gt;
&lt;p&gt;　　Vuex 允许在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算&lt;/p&gt;
&lt;p&gt;　　Getter 接受 state 作为其第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    todos: [
      { id: &lt;/span&gt;1, text: '...', done: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
      { id: &lt;/span&gt;2, text: '...', done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; }
    ]
  },
  getters: {
    doneTodos: state &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.filter(todo =&amp;gt;&lt;span&gt; todo.done)
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Getter 会暴露为 &lt;code&gt;store.getters&lt;/code&gt; 对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
store.getters.doneTodos &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; [{ id: 1, text: '...', done: true }]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Getter 也可以接受其他 getter 作为第二个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;getters: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  doneTodosCount: (state, getters) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getters.doneTodos.length
  }
}
store.getters.doneTodosCount &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以很容易地在任何组件中使用它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  doneTodosCount () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.getters.doneTodosCount
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以通过让 getter 返回一个函数，来实现给 getter 传参。在对 store 里的数组进行查询时非常有用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;getters: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  getTodoById: (state, getters) =&amp;gt; (id) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.find(todo =&amp;gt; todo.id ===&lt;span&gt; id)
  }
}
store.getters.getTodoById(&lt;/span&gt;2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; { id: 2, text: '...', done: false }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;如果箭头函数不好理解，翻译成普通函数如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getTodoById = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(state,getters){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(id){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.find(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(todo){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; todo.id ===&lt;span&gt; id
    })
  }
}
store.getters.getTodoById(&lt;/span&gt;2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; { id: 2, text: '...', done: false }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【mapGetters辅助函数】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　mapGetters&lt;/code&gt; 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import { mapGetters } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  computed: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用对象展开运算符将 getter 混入 computed 对象中&lt;/span&gt;
&lt;span&gt;    ...mapGetters([
      &lt;/span&gt;'doneTodosCount'&lt;span&gt;,
      &lt;/span&gt;'anotherGetter'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    ])
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果想将一个 getter 属性另取一个名字，使用对象形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mapGetters({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射 `this.doneCount` 为 `store.getters.doneTodosCount`&lt;/span&gt;
  doneCount: 'doneTodosCount'&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;mutation&lt;/h3&gt;
&lt;p&gt;　　更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;1&lt;span&gt;
  },
  mutations: {
    increment (state) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变更状态&lt;/span&gt;
      state.count++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 &lt;code&gt;increment&lt;/code&gt; 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，需要以相应的 type 调用 store.commit 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.commit('increment')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【提交载荷(Payload)】&lt;/p&gt;
&lt;p&gt;　　可以向 &lt;code&gt;store.commit&lt;/code&gt; 传入额外的参数，即 mutation 的 载荷（payload）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;mutations: {
  increment (state, n) {
    state.count &lt;/span&gt;+=&lt;span&gt; n
  }
}
store.commit(&lt;/span&gt;'increment', 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;mutations: {
  increment (state, payload) {
    state.count &lt;/span&gt;+=&lt;span&gt; payload.amount
  }
}
store.commit(&lt;/span&gt;'increment'&lt;span&gt;, {
  amount: &lt;/span&gt;10&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【对象风格的提交方式】&lt;/p&gt;
&lt;p&gt;　　提交 mutation 的另一种方式是直接使用包含 &lt;code&gt;type&lt;/code&gt; 属性的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;store.commit({
  type: &lt;/span&gt;'increment'&lt;span&gt;,
  amount: &lt;/span&gt;10&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mutations: {
  increment (state, payload) {
    state.count &lt;/span&gt;+=&lt;span&gt; payload.amount
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【遵守响应规则】&lt;/p&gt;
&lt;p&gt;　　既然 Vuex 的 store 中的状态是响应式的，那么当变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：&lt;/p&gt;
&lt;p&gt;　　1、最好提前在store中初始化好所有所需属性&lt;/p&gt;
&lt;p&gt;　　2、当需要在对象上添加新属性时，应该使用 &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, 或者以新对象替换老对象&lt;/p&gt;
&lt;p&gt;　　例如，利用对象展开运算符可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
state.obj = { ...state.obj, newProp: 123 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【使用常量替代Mutation事件类型】&lt;/p&gt;
&lt;p&gt;　　使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让代码合作者对整个 app 包含的 mutation 一目了然&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutation-types.js&lt;/span&gt;
export const SOME_MUTATION = 'SOME_MUTATION'
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store.js&lt;/span&gt;
import Vuex from 'vuex'&lt;span&gt;
import { SOME_MUTATION } from &lt;/span&gt;'./mutation-types'&lt;span&gt;

const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: { ... },
  mutations: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名&lt;/span&gt;
&lt;span&gt;    [SOME_MUTATION] (state) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutate state&lt;/span&gt;
&lt;span&gt;    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【Mutation必须是同步函数】&lt;/p&gt;
&lt;p&gt;　　一条重要的原则就是mutation必须是同步函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mutations: {
  someMutation (state) {
    api.callAsyncMethod(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      state.count&lt;/span&gt;++&lt;span&gt;
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　假如正在debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态改变都是不可追踪的&lt;/p&gt;
&lt;p&gt;【在组件中提交Mutation】&lt;/p&gt;
&lt;p&gt;　　可以在组件中使用 &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; 提交 mutation，或者使用 &lt;code&gt;mapMutations&lt;/code&gt; 辅助函数将组件中的 methods 映射为 &lt;code&gt;store.commit&lt;/code&gt; 调用（需要在根节点注入 &lt;code&gt;store&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import { mapMutations } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  methods: {
    ...mapMutations([
      &lt;/span&gt;'increment', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.increment()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;

      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; `mapMutations` 也支持载荷：&lt;/span&gt;
      'incrementBy' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`&lt;/span&gt;
&lt;span&gt;    ]),
    ...mapMutations({
      add: &lt;/span&gt;'increment' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.add()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;
&lt;span&gt;    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;action&lt;/h3&gt;
&lt;p&gt;　　在 mutation 中混合异步调用会导致程序很难调试。例如，当能调用了两个包含异步回调的 mutation 来改变状态，怎么知道什么时候回调和哪个先回调呢？这就是为什么要区分这两个概念。在 Vuex 中，mutation 都是同步事务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.commit('increment'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任何由 &quot;increment&quot; 导致的状态变更都应该在此刻完成。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Action类似于mutation，不同之处在于：&lt;/p&gt;
&lt;p&gt;　　1、Action 提交的是 mutation，而不是直接变更状态&lt;/p&gt;
&lt;p&gt;　　2、Action 可以包含任意异步操作&lt;/p&gt;
&lt;p&gt;　　下面来注册一个简单的action&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;0&lt;span&gt;
  },
  mutations: {
    increment (state) {
      state.count&lt;/span&gt;++&lt;span&gt;
    }
  },
  actions: {
    increment (context) {
      context.commit(&lt;/span&gt;'increment'&lt;span&gt;)
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 &lt;code&gt;context.commit&lt;/code&gt; 提交一个 mutation，或者通过 &lt;code&gt;context.state&lt;/code&gt; 和 &lt;code&gt;context.getters&lt;/code&gt; 来获取 state 和 getters&lt;/p&gt;
&lt;p&gt;　　实践中，会经常用到 ES2015 的 参数解构 来简化代码（特别是需要调用 &lt;code&gt;commit&lt;/code&gt; 很多次的时候）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  increment ({ commit }) {
    commit(&lt;/span&gt;'increment'&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【分发Action】&lt;/p&gt;
&lt;p&gt;　　Action 通过 &lt;code&gt;store.dispatch&lt;/code&gt; 方法触发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.dispatch('increment')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　乍一眼看上去感觉多此一举，直接分发 mutation 岂不更方便？实际上并非如此，mutation必须同步执行这个限制，而Action 就不受约束，可以在 action 内部执行异步操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  incrementAsync ({ commit }) {
    setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      commit(&lt;/span&gt;'increment'&lt;span&gt;)
    }, &lt;/span&gt;1000&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Actions 支持同样的载荷方式和对象方式进行分发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以载荷形式分发&lt;/span&gt;
store.dispatch('incrementAsync'&lt;span&gt;, {
  amount: &lt;/span&gt;10&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以对象形式分发&lt;/span&gt;
&lt;span&gt;store.dispatch({
  type: &lt;/span&gt;'incrementAsync'&lt;span&gt;,
  amount: &lt;/span&gt;10&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  checkout ({ commit, state }, products) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把当前购物车的物品备份起来&lt;/span&gt;
    const savedCartItems =&lt;span&gt; [...state.cart.added]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发出结账请求，然后乐观地清空购物车&lt;/span&gt;
&lt;span&gt;    commit(types.CHECKOUT_REQUEST)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 购物 API 接受一个成功回调和一个失败回调&lt;/span&gt;
&lt;span&gt;    shop.buyProducts(
      products,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功操作&lt;/span&gt;
      () =&amp;gt;&lt;span&gt; commit(types.CHECKOUT_SUCCESS),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 失败操作&lt;/span&gt;
      () =&amp;gt;&lt;span&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)
    )
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）&lt;/p&gt;
&lt;p&gt;【在组件中分发Action】&lt;/p&gt;
&lt;p&gt;　　在组件中使用 &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; 分发 action，或者使用 &lt;code&gt;mapActions&lt;/code&gt; 辅助函数将组件的 methods 映射为 &lt;code&gt;store.dispatch&lt;/code&gt; 调用（需要先在根节点注入 &lt;code&gt;store&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import { mapActions } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  methods: {
    ...mapActions([
      &lt;/span&gt;'increment', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`&lt;/span&gt;

      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; `mapActions` 也支持载荷：&lt;/span&gt;
      'incrementBy' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`&lt;/span&gt;
&lt;span&gt;    ]),
    ...mapActions({
      add: &lt;/span&gt;'increment' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.add()` 映射为 `this.$store.dispatch('increment')`&lt;/span&gt;
&lt;span&gt;    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【组合Action】&lt;/p&gt;
&lt;p&gt;　　Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，如何才能组合多个 action，以处理更加复杂的异步流程？&lt;/p&gt;
&lt;p&gt;　　首先，需要明白 &lt;code&gt;store.dispatch&lt;/code&gt; 可以处理被触发的 action 的处理函数返回的 Promise，并且 &lt;code&gt;store.dispatch&lt;/code&gt; 仍旧返回 Promise：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  actionA ({ commit }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        commit(&lt;/span&gt;'someMutation'&lt;span&gt;)
        resolve()
      }, &lt;/span&gt;1000&lt;span&gt;)
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.dispatch('actionA').then(() =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在另外一个 action 中也可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  actionB ({ dispatch, commit }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dispatch('actionA').then(() =&amp;gt;&lt;span&gt; {
      commit(&lt;/span&gt;'someOtherMutation'&lt;span&gt;)
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，如果利用 async / await 这个 JavaScript 新特性，可以像这样组合 action：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设 getData() 和 getOtherData() 返回的是 Promise&lt;/span&gt;
&lt;span&gt;
actions: {
  async actionA ({ commit }) {
    commit(&lt;/span&gt;'gotData'&lt;span&gt;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&lt;/span&gt;'actionA') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待 actionA 完成&lt;/span&gt;
    commit('gotOtherData'&lt;span&gt;, await getOtherData())
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一个 &lt;code&gt;store.dispatch&lt;/code&gt; 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行&lt;/p&gt;

&lt;h3&gt;module&lt;/h3&gt;
&lt;p&gt;　　由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。&lt;/p&gt;
&lt;p&gt;　　为了解决以上问题，Vuex 允许将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const moduleA =&lt;span&gt; {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB &lt;/span&gt;=&lt;span&gt; {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; moduleA 的状态&lt;/span&gt;
store.state.b &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; moduleB 的状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【模块的局部状态】&lt;/p&gt;
&lt;p&gt;　　对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const moduleA =&lt;span&gt; {
  state: { count: &lt;/span&gt;0&lt;span&gt; },
  mutations: {
    increment (state) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的 `state` 对象是模块的局部状态&lt;/span&gt;
      state.count++&lt;span&gt;
    }
  },

  getters: {
    doubleCount (state) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.count * 2&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样，对于模块内部的 action，局部状态通过 &lt;code&gt;context.state&lt;/code&gt; 暴露出来，根节点状态则为 &lt;code&gt;context.rootState&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const moduleA =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  actions: {
    incrementIfOddOnRootSum ({ state, commit, rootState }) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((state.count + rootState.count) % 2 === 1&lt;span&gt;) {
        commit(&lt;/span&gt;'increment'&lt;span&gt;)
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const moduleA =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  getters: {
    sumWithRootCount (state, getters, rootState) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.count +&lt;span&gt; rootState.count
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【命名空间】&lt;/p&gt;
&lt;p&gt;　　默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应&lt;/p&gt;
&lt;p&gt;　　如果希望模块具有更高的封装度和复用性，可以通过添加 &lt;code&gt;namespaced: true&lt;/code&gt; 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  modules: {
    account: {
      namespaced: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模块内容（module assets）&lt;/span&gt;
      state: { ... }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响&lt;/span&gt;
&lt;span&gt;      getters: {
        isAdmin () { ... } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; getters['account/isAdmin']&lt;/span&gt;
&lt;span&gt;      },
      actions: {
        login () { ... } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; dispatch('account/login')&lt;/span&gt;
&lt;span&gt;      },
      mutations: {
        login () { ... } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; commit('account/login')&lt;/span&gt;
&lt;span&gt;      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 嵌套模块&lt;/span&gt;
&lt;span&gt;      modules: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承父模块的命名空间&lt;/span&gt;
&lt;span&gt;        myPage: {
          state: { ... },
          getters: {
            profile () { ... } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; getters['account/profile']&lt;/span&gt;
&lt;span&gt;          }
        },

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进一步嵌套命名空间&lt;/span&gt;
&lt;span&gt;        posts: {
          namespaced: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

          state: { ... },
          getters: {
            popular () { ... } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; getters['account/posts/popular']&lt;/span&gt;
&lt;span&gt;          }
        }
      }
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启用了命名空间的 getter 和 action 会收到局部化的 &lt;code&gt;getter&lt;/code&gt;，&lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt;。换言之，在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 &lt;code&gt;namespaced&lt;/code&gt; 属性后不需要修改模块内的代码&lt;/p&gt;
&lt;p id=&quot;在命名空间模块内访问全局内容（global-assets）&quot;&gt;【在命名空间模块内访问全局内容（Global Assets）】&lt;/p&gt;
&lt;p&gt;　　如果希望使用全局 state 和 getter，&lt;code&gt;rootState&lt;/code&gt; 和 &lt;code&gt;rootGetter&lt;/code&gt; 会作为第三和第四参数传入 getter，也会通过 &lt;code&gt;context&lt;/code&gt; 对象的属性传入 action&lt;/p&gt;
&lt;p&gt;　　若需要在全局命名空间内分发 action 或提交 mutation，将 &lt;code&gt;{ root: true }&lt;/code&gt; 作为第三参数传给 &lt;code&gt;dispatch&lt;/code&gt; 或 &lt;code&gt;commit&lt;/code&gt;即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;modules: {
  foo: {
    namespaced: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    getters: {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个模块的 getter 中，`getters` 被局部化了&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你可以使用 getter 的第四个参数来调用 `rootGetters`&lt;/span&gt;
&lt;span&gt;      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'foo/someOtherGetter'&lt;/span&gt;
        rootGetters.someOtherGetter &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'someOtherGetter'&lt;/span&gt;
&lt;span&gt;      },
      someOtherGetter: state &lt;/span&gt;=&amp;gt;&lt;span&gt; { ... }
    },

    actions: {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个模块中， dispatch 和 commit 也被局部化了&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 他们可以接受 `root` 属性以访问根 dispatch 或 commit&lt;/span&gt;
&lt;span&gt;      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'foo/someGetter'&lt;/span&gt;
        rootGetters.someGetter &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'someGetter'&lt;/span&gt;
&lt;span&gt;
        dispatch(&lt;/span&gt;'someOtherAction') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'foo/someOtherAction'&lt;/span&gt;
        dispatch('someOtherAction', &lt;span&gt;null&lt;/span&gt;, { root: &lt;span&gt;true&lt;/span&gt; }) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'someOtherAction'&lt;/span&gt;
&lt;span&gt;
        commit(&lt;/span&gt;'someMutation') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'foo/someMutation'&lt;/span&gt;
        commit('someMutation', &lt;span&gt;null&lt;/span&gt;, { root: &lt;span&gt;true&lt;/span&gt; }) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'someMutation'&lt;/span&gt;
&lt;span&gt;      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【带命名空间的绑定函数】&lt;/p&gt;
&lt;p&gt;　　当使用 &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; 和 &lt;code&gt;mapMutations&lt;/code&gt; 这些函数来绑定命名空间模块时，写起来可能比较繁琐&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  ...mapState({
    a: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.some.nested.module.a,
    b: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.some.nested.module.b
  })
},
methods: {
  ...mapActions([
    &lt;/span&gt;'some/nested/module/foo'&lt;span&gt;,
    &lt;/span&gt;'some/nested/module/bar'&lt;span&gt;
  ])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于这种情况，可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  ...mapState(&lt;/span&gt;'some/nested/module'&lt;span&gt;, {
    a: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.a,
    b: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.b
  })
},
methods: {
  ...mapActions(&lt;/span&gt;'some/nested/module'&lt;span&gt;, [
    &lt;/span&gt;'foo'&lt;span&gt;,
    &lt;/span&gt;'bar'&lt;span&gt;
  ])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而且，可以通过使用 &lt;code&gt;createNamespacedHelpers&lt;/code&gt; 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import { createNamespacedHelpers } from 'vuex'&lt;span&gt;

const { mapState, mapActions } &lt;/span&gt;= createNamespacedHelpers('some/nested/module'&lt;span&gt;)

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  computed: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 `some/nested/module` 中查找&lt;/span&gt;
&lt;span&gt;    ...mapState({
      a: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.a,
      b: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.b
    })
  },
  methods: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 `some/nested/module` 中查找&lt;/span&gt;
&lt;span&gt;    ...mapActions([
      &lt;/span&gt;'foo'&lt;span&gt;,
      &lt;/span&gt;'bar'&lt;span&gt;
    ])
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【注意事项】&lt;/p&gt;
&lt;p&gt;　　如果开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，可以通过插件的参数对象来允许用户指定空间名称：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过插件的参数对象得到空间名称&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 然后返回 Vuex 插件函数&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt; createPlugin (options =&lt;span&gt; {}) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (store) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把空间名字添加到插件模块的类型（type）中去&lt;/span&gt;
    const namespace = options.namespace || ''&lt;span&gt;
    store.dispatch(namespace &lt;/span&gt;+ 'pluginAction'&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【模块动态注册】&lt;/p&gt;
&lt;p&gt;　　在 store 创建之后，可以使用 &lt;code&gt;store.registerModule&lt;/code&gt; 方法注册模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册模块 `myModule`&lt;/span&gt;
store.registerModule('myModule'&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册嵌套模块 `nested/myModule`&lt;/span&gt;
store.registerModule(['nested', 'myModule'&lt;span&gt;], {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后就可以通过 &lt;code&gt;store.state.myModule&lt;/code&gt; 和 &lt;code&gt;store.state.nested.myModule&lt;/code&gt; 访问模块的状态。&lt;/p&gt;
&lt;p&gt;　　模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，&lt;code&gt;vuex-router-sync&lt;/code&gt; 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。&lt;/p&gt;
&lt;p&gt;　　也可以使用 &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; 来动态卸载模块。注意，不能使用此方法卸载静态模块（即创建 store 时声明的模块）&lt;/p&gt;
&lt;p&gt;【模块重用】&lt;/p&gt;
&lt;p&gt;　　有时可能需要创建一个模块的多个实例，例如：&lt;/p&gt;
&lt;p&gt;　　1、创建多个 store，他们公用同一个模块 (例如当 &lt;code&gt;runInNewContext&lt;/code&gt; 选项是 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;'once'&lt;/code&gt; 时，为了在服务端渲染中避免有状态的单例)&lt;/p&gt;
&lt;p&gt;　　2、在一个 store 中多次注册同一个模块&lt;/p&gt;
&lt;p&gt;　　如果使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。&lt;/p&gt;
&lt;p&gt;　　实际上这和 Vue 组件内的 &lt;code&gt;data&lt;/code&gt; 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const MyReusableModule =&lt;span&gt; {
  state () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      foo: &lt;/span&gt;'bar'&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutation, action 和 getter 等等...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;项目结构&lt;/h3&gt;
&lt;p&gt;　　Vuex 并不限制代码结构。但是，它规定了一些需要遵守的规则：&lt;/p&gt;
&lt;p&gt;　　1、应用层级的状态应该集中到单个 store 对象中&lt;/p&gt;
&lt;p&gt;　　2、提交 mutation 是更改状态的唯一方法，并且这个过程是同步的&lt;/p&gt;
&lt;p&gt;　　3、异步逻辑都应该封装到 action 里面&lt;/p&gt;
&lt;p&gt;　　只要遵守以上规则，可以随意组织代码。如果store文件太大，只需将 action、mutation 和 getter 分割到单独的文件&lt;/p&gt;
&lt;p&gt;　　对于大型应用，希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;插件&lt;/h3&gt;
&lt;p&gt;　　Vuex 的 store 接受 &lt;code&gt;plugins&lt;/code&gt; 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const myPlugin = store =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 store 初始化后调用&lt;/span&gt;
  store.subscribe((mutation, state) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次 mutation 之后调用&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutation 的格式为 { type, payload }&lt;/span&gt;
&lt;span&gt;  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后像这样使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  plugins: [myPlugin]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【在插件中提交Mutation】&lt;/p&gt;
&lt;p&gt;　　在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。&lt;/p&gt;
&lt;p&gt;　　通过提交 mutation，插件可以用来同步数据源到 store。例如，同步 websocket 数据源到 store（下面是个大概例子，实际上 &lt;code&gt;createPlugin&lt;/code&gt; 方法可以有更多选项来完成复杂任务）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createWebSocketPlugin (socket) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; store =&amp;gt;&lt;span&gt; {
    socket.on(&lt;/span&gt;'data', data =&amp;gt;&lt;span&gt; {
      store.commit(&lt;/span&gt;'receiveData'&lt;span&gt;, data)
    })
    store.subscribe(mutation &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mutation.type === 'UPDATE_DATA'&lt;span&gt;) {
        socket.emit(&lt;/span&gt;'update'&lt;span&gt;, mutation.payload)
      }
    })
  }
}
const plugin &lt;/span&gt;=&lt;span&gt; createWebSocketPlugin(socket)

const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state,
  mutations,
  plugins: [plugin]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【生成State快照】&lt;/p&gt;
&lt;p&gt;　　有时候插件需要获得状态的“快照”，比较改变的前后状态。想要实现这项功能，需要对状态对象进行深拷贝：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const myPluginWithSnapshot = store =&amp;gt;&lt;span&gt; {
  let prevState &lt;/span&gt;=&lt;span&gt; _.cloneDeep(store.state)
  store.subscribe((mutation, state) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    let nextState &lt;/span&gt;=&lt;span&gt; _.cloneDeep(state)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较 prevState 和 nextState...&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存状态，用于下一次 mutation&lt;/span&gt;
    prevState =&lt;span&gt; nextState
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成状态快照的插件应该只在开发阶段使用，使用 webpack 或 Browserify，让构建工具帮助处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  plugins: process.env.NODE_ENV !== 'production'
    ?&lt;span&gt; [myPluginWithSnapshot]
    : []
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面插件会默认启用。在发布阶段，需要使用 webpack 的 DefinePlugin 或者是 Browserify 的 envify 使 &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;【内置Logger插件】&lt;/p&gt;
&lt;p&gt;　　Vuex 自带一个日志插件用于一般的调试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import createLogger from 'vuex/dist/logger'&lt;span&gt;

const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  plugins: [createLogger()]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　createLogger&lt;/code&gt; 函数有几个配置项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const logger =&lt;span&gt; createLogger({
  collapsed: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自动展开记录的 mutation&lt;/span&gt;
&lt;span&gt;  filter (mutation, stateBefore, stateAfter) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若 mutation 需要被记录，就让它返回 true 即可&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顺便，`mutation` 是个 { type, payload } 对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; mutation.type !== &quot;aBlacklistedMutation&quot;&lt;span&gt;
  },
  transformer (state) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在开始记录之前转换状态&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例如，只返回指定的子树&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; state.subTree
  },
  mutationTransformer (mutation) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutation 按照 { type, payload } 格式记录&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们可以按任意方式格式化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mutation.type
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　日志插件还可以直接通过 &lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;script&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 标签引入，它会提供全局方法 &lt;code&gt;createVuexLogger&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　要注意，logger 插件会生成状态快照，所以仅在开发环境使用&lt;/p&gt;

&lt;h3&gt;严格模式&lt;/h3&gt;
&lt;p&gt;　　开启严格模式，仅需在创建 store 的时候传入 &lt;code&gt;strict: true&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  strict: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到&lt;/p&gt;
&lt;p&gt;【开发环境与发布环境】&lt;/p&gt;
&lt;p&gt;　　不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。&lt;/p&gt;
&lt;p&gt;　　类似于插件，可以让构建工具来处理这种情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  strict: process.env.NODE_ENV !== 'production'&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;表单处理&lt;/h3&gt;
&lt;p&gt;　　当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 &lt;code&gt;v-model&lt;/code&gt; 会比较棘手：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;input v-model=&quot;obj.message&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　假设这里的 &lt;code&gt;obj&lt;/code&gt; 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，&lt;code&gt;v-model&lt;/code&gt; 会试图直接修改 &lt;code&gt;obj.message&lt;/code&gt;。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。&lt;/p&gt;
&lt;p&gt;　　用“Vuex 的思维”去解决这个问题的方法是：给 &lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;input&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 中绑定 value，然后侦听 &lt;code&gt;input&lt;/code&gt; 或者 &lt;code&gt;change&lt;/code&gt; 事件，在事件回调中调用 action:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;input :value=&quot;message&quot; @input=&quot;updateMessage&quot;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;computed: {
  ...mapState({
    message: state &lt;/span&gt;=&amp;gt;&lt;span&gt; state.obj.message
  })
},
methods: {
  updateMessage (e) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.commit('updateMessage'&lt;span&gt;, e.target.value)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是 mutation 函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;mutations: {
  updateMessage (state, message) {
    state.obj.message &lt;/span&gt;=&lt;span&gt; message
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【双向绑定的计算属性】&lt;/p&gt;
&lt;p&gt;　　必须承认，这样做比简单地使用“&lt;code&gt;v-model&lt;/code&gt; + 局部状态”要啰嗦得多，并且也损失了一些 &lt;code&gt;v-model&lt;/code&gt; 中很有用的特性。另一个方法是使用带有 setter 的双向绑定计算属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;input v-model=&quot;message&quot;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;computed: {
  message: {
    get () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.obj.message
    },
    set (value) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.commit('updateMessage'&lt;span&gt;, value)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;【测试Mutation】&lt;/p&gt;
&lt;p&gt;　　Mutation 很容易被测试，因为它们仅仅是一些完全依赖参数的函数。这里有一个小技巧，如果在 &lt;code&gt;store.js&lt;/code&gt; 文件中定义了 mutation，并且使用 ES2015 模块功能默认输出了 Vuex.Store 的实例，那么仍然可以给 mutation 取个变量名然后把它输出去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const state =&lt;span&gt; { ... }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `mutations` 作为命名输出对象&lt;/span&gt;
export const mutations =&lt;span&gt; { ... }

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state,
  mutations
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是用 Mocha + Chai 测试一个 mutation 的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutations.js&lt;/span&gt;
export const mutations =&lt;span&gt; {
  increment: state &lt;/span&gt;=&amp;gt; state.count++&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutations.spec.js&lt;/span&gt;
import { expect } from 'chai'&lt;span&gt;
import { mutations } from &lt;/span&gt;'./store'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解构 `mutations`&lt;/span&gt;
const { increment } =&lt;span&gt; mutations

describe(&lt;/span&gt;'mutations', () =&amp;gt;&lt;span&gt; {
  it(&lt;/span&gt;'INCREMENT', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟状态&lt;/span&gt;
    const state = { count: 0&lt;span&gt; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 应用 mutation&lt;/span&gt;
&lt;span&gt;    increment(state)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 断言结果&lt;/span&gt;
    expect(state.count).to.equal(1&lt;span&gt;)
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【测试Action】&lt;/p&gt;
&lt;p&gt;　　Action 应对起来略微棘手，因为它们可能需要调用外部的 API。当测试 action 的时候，需要增加一个 mocking 服务层——例如，可以把 API 调用抽象成服务，然后在测试文件中用 mock 服务回应 API 调用。为了便于解决 mock 依赖，可以用 webpack 和 inject-loader 打包测试文件。&lt;/p&gt;
&lt;p&gt;　　下面是一个测试异步 action 的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions.js&lt;/span&gt;
import shop from '../api/shop'&lt;span&gt;

export const getAllProducts &lt;/span&gt;= ({ commit }) =&amp;gt;&lt;span&gt; {
  commit(&lt;/span&gt;'REQUEST_PRODUCTS'&lt;span&gt;)
  shop.getProducts(products &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    commit(&lt;/span&gt;'RECEIVE_PRODUCTS'&lt;span&gt;, products)
  })
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions.spec.js&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 require 语法处理内联 loaders。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; inject-loader 返回一个允许我们注入 mock 依赖的模块工厂&lt;/span&gt;
import { expect } from 'chai'&lt;span&gt;
const actionsInjector &lt;/span&gt;= require('inject-loader!./actions'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 mocks 创建模块&lt;/span&gt;
const actions =&lt;span&gt; actionsInjector({
  &lt;/span&gt;'../api/shop'&lt;span&gt;: {
    getProducts (cb) {
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        cb([ &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; mocked response &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; ])
      }, &lt;/span&gt;100&lt;span&gt;)
    }
  }
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用指定的 mutaions 测试 action 的辅助函数&lt;/span&gt;
const testAction = (action, args, state, expectedMutations, done) =&amp;gt;&lt;span&gt; {
  let count &lt;/span&gt;= 0

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟提交&lt;/span&gt;
  const commit = (type, payload) =&amp;gt;&lt;span&gt; {
    const mutation &lt;/span&gt;=&lt;span&gt; expectedMutations[count]

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      expect(mutation.type).to.equal(type)
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (payload) {
        expect(mutation.payload).to.deep.equal(payload)
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (error) {
      done(error)
    }

    count&lt;/span&gt;++
    &lt;span&gt;if&lt;/span&gt; (count &amp;gt;=&lt;span&gt; expectedMutations.length) {
      done()
    }
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用模拟的 store 和参数调用 action&lt;/span&gt;
&lt;span&gt;  action({ commit, state }, ...args)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查是否没有 mutation 被 dispatch&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (expectedMutations.length === 0&lt;span&gt;) {
    expect(count).to.equal(&lt;/span&gt;0&lt;span&gt;)
    done()
  }
}

describe(&lt;/span&gt;'actions', () =&amp;gt;&lt;span&gt; {
  it(&lt;/span&gt;'getAllProducts', done =&amp;gt;&lt;span&gt; {
    testAction(actions.getAllProducts, [], {}, [
      { type: &lt;/span&gt;'REQUEST_PRODUCTS'&lt;span&gt; },
      { type: &lt;/span&gt;'RECEIVE_PRODUCTS', payload: { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; mocked response &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; } }
    ], done)
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【测试Getter】&lt;/p&gt;
&lt;p&gt;　　如果getter 包含很复杂的计算过程，很有必要测试它们。Getter 的测试与 mutation 一样直截了当。&lt;/p&gt;
&lt;p&gt;　　测试一个 getter 的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getters.js&lt;/span&gt;
export const getters =&lt;span&gt; {
  filteredProducts (state, { filterCategory }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.products.filter(product =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; product.category ===&lt;span&gt; filterCategory
    })
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getters.spec.js&lt;/span&gt;
import { expect } from 'chai'&lt;span&gt;
import { getters } from &lt;/span&gt;'./getters'&lt;span&gt;

describe(&lt;/span&gt;'getters', () =&amp;gt;&lt;span&gt; {
  it(&lt;/span&gt;'filteredProducts', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟状态&lt;/span&gt;
    const state =&lt;span&gt; {
      products: [
        { id: &lt;/span&gt;1, title: 'Apple', category: 'fruit'&lt;span&gt; },
        { id: &lt;/span&gt;2, title: 'Orange', category: 'fruit'&lt;span&gt; },
        { id: &lt;/span&gt;3, title: 'Carrot', category: 'vegetable'&lt;span&gt; }
      ]
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟 getter&lt;/span&gt;
    const filterCategory = 'fruit'

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 getter 的结果&lt;/span&gt;
    const result =&lt;span&gt; getters.filteredProducts(state, { filterCategory })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 断言结果&lt;/span&gt;
&lt;span&gt;    expect(result).to.deep.equal([
      { id: &lt;/span&gt;1, title: 'Apple', category: 'fruit'&lt;span&gt; },
      { id: &lt;/span&gt;2, title: 'Orange', category: 'fruit'&lt;span&gt; }
    ])
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【执行测试】&lt;/p&gt;
&lt;p&gt;　　如果mutation 和 action 编写正确，经过合理地 mocking 处理之后这些测试应该不依赖任何浏览器 API，因此可以直接用 webpack 打包这些测试文件然后在 Node 中执行。换种方式，也可以用 &lt;code&gt;mocha-loader&lt;/code&gt; 或 Karma + &lt;code&gt;karma-webpack&lt;/code&gt;在真实浏览器环境中进行测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Node中执行测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; webpack.config.js&lt;/span&gt;
module.exports =&lt;span&gt; {
  entry: &lt;/span&gt;'./test.js'&lt;span&gt;,
  output: {
    path: __dirname,
    filename: &lt;/span&gt;'test-bundle.js'&lt;span&gt;
  },
  module: {
    loaders: [
      {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
        exclude: &lt;/span&gt;/node_modules/&lt;span&gt;
      }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;webpack
mocha test&lt;/span&gt;-bundle.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在浏览器中测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、安装 &lt;code&gt;mocha-loader&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　2、上述 webpack 配置中的 &lt;code&gt;entry&lt;/code&gt; 改成 &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　3、&lt;/em&gt;用以上配置启动 &lt;code&gt;webpack-dev-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　4、访问 &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;热加载&lt;/h3&gt;
&lt;p&gt;　　使用 webpack 的 Hot Module Replacement API，Vuex 支持在开发过程中热重载 mutation、module、action 和 getter。也可以在 Browserify 中使用 browserify-hmr 插件。&lt;/p&gt;
&lt;p&gt;　　对于 mutation 和模块，需要使用 &lt;code&gt;store.hotUpdate()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store.js&lt;/span&gt;
import Vue from 'vue'&lt;span&gt;
import Vuex from &lt;/span&gt;'vuex'&lt;span&gt;
import mutations from &lt;/span&gt;'./mutations'&lt;span&gt;
import moduleA from &lt;/span&gt;'./modules/a'&lt;span&gt;

Vue.use(Vuex)

const state &lt;/span&gt;=&lt;span&gt; { ... }

const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state,
  mutations,
  modules: {
    a: moduleA
  }
})

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (module.hot) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使 action 和 mutation 成为可热重载模块&lt;/span&gt;
  module.hot.accept(['./mutations', './modules/a'], () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取更新后的模块&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`&lt;/span&gt;
    const newMutations = require('./mutations').&lt;span&gt;default&lt;/span&gt;&lt;span&gt;
    const newModuleA &lt;/span&gt;= require('./modules/a').&lt;span&gt;default&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载新模块&lt;/span&gt;
&lt;span&gt;    store.hotUpdate({
      mutations: newMutations,
      modules: {
        a: newModuleA
      }
    })
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 04 Oct 2017 23:27:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/7554127.html</dc:identifier>
</item>
<item>
<title>使用javaAPI操作hdfs - huabingood</title>
<link>http://www.cnblogs.com/yanghuabin/p/7628088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanghuabin/p/7628088.html</guid>
<description>&lt;p&gt;&lt;span&gt;欢迎到https://github.com/huabingood/everyDayLanguagePractise查看源码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一.构建环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在hadoop的安装包中的share目录中有hadoop所有你能想象到的内容。&lt;br/&gt;        进入安装包下的share文件夹你会看到doc和hadoop文件夹。其中doc中是hadoop的整个document。而hadoop文件夹中则存放着所有开发hadoop所有用到的jar包，其依赖放到相应的lib文件夹中。&lt;br/&gt;       我们这次用到的是hadoop文件夹中的common以及hdfs文件夹中的内容。在创建工程时，继续将这两个文件夹中的jar包添加到相应的工程中，然后将文件夹中的lib文件夹的所有jar包作为依赖也添加到工程文件中（common和hdfs文件的lib文件中的jar包可能存在重复，注意去重。）；其中source文件夹是该模块的源码包，如果想在IDEA中看到源码，需要将这些内容也添加到工程中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二.操作HDFS流程&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;获取HDFS的配置，根据HDFS的配置获取整个HDFS操作系统的内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;打开HDFS操作系统，进行操作&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;文件夹的操作：增删改查&lt;/li&gt;
&lt;li&gt;文件的上传下载&lt;/li&gt;
&lt;li&gt;文件的IO操作——hdfs之间的复制&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;三.具体的操作命令&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据配置获取HDFS文件操作系统（共有三种方式）
&lt;ol&gt;&lt;li&gt;方法一：直接获取配置文件方法&lt;br/&gt;通常情况下该方法用于本地有hadoop系统，可以直接进行访问。此时仅需在配置文件中指定要操作的文件系统为hdfs即可。这里的conf的配置文件可以设置hdfs的各种参数，并且优先级比配置文件要搞&lt;/li&gt;
&lt;li&gt;方法二：指定URI路径，进而获取配置文件创建操作系统&lt;br/&gt;通常该方法用于本地没有hadoop系统，但是可以通过URI的方式进行访问。此时要给给定hadoop的NN节点的访问路径，hadoop的用户名，以及配置文件信息（此时会自动访问远程hadoop的配置文件）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 根据配置文件获取HDFS操作对象
                 * 有两种方法：
                 *  1.使用conf直接从本地获取配置文件创建HDFS对象
                 *  2.多用于本地没有hadoop系统，但是可以远程访问。使用给定的URI和用户名，访问远程的配置文件，然后创建HDFS对象。
                 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; FileSystem
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FileSystem getHadoopFileSystem() {
            
            
                    FileSystem fs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    Configuration conf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法一，本地有配置文件，直接获取配置文件（core-site.xml，hdfs-site.xml）
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据配置文件创建HDFS对象
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时必须指定hdsf的访问路径。&lt;/span&gt;
                    conf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件系统为必须设置的内容。其他配置参数可以自行设置，且优先级最高&lt;/span&gt;
                    conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://huabingood01:9000&quot;&lt;span&gt;);
            
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据配置文件创建HDFS对象&lt;/span&gt;
                        fs =&lt;span&gt; FileSystem.get(conf);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                        logger.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,e);
                    }
            
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法二：本地没有hadoop系统，但是可以远程访问。根据给定的URI和用户名，访问hdfs的配置参数
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时的conf不需任何设置，只需读取远程的配置文件即可。&lt;/span&gt;
                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;conf = new Configuration();
                    // Hadoop的用户名
                    String hdfsUserName = &quot;huabingood&quot;;
            
                    URI hdfsUri = null;
                    try {
                        // HDFS的访问路径
                        hdfsUri = new URI(&quot;hdfs://huabingood01:9000&quot;);
                    } catch (URISyntaxException e) {
                        e.printStackTrace();
                        logger.error(e);
                    }
            
                    try {
                        // 根据远程的NN节点，获取配置信息，创建HDFS对象
                        fs = FileSystem.get(hdfsUri,conf,hdfsUserName);
                    } catch (IOException e) {
                        e.printStackTrace();
                        logger.error(e);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        logger.error(e);
                    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法三，反正我们没有搞懂。&lt;/span&gt;
                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;conf  = new Configuration();
                    conf.addResource(&quot;/opt/huabingood/pseudoDistributeHadoop/hadoop-2.6.0-cdh5.10.0/etc/hadoop/core-site.xml&quot;);
                    conf.addResource(&quot;/opt/huabingood/pseudoDistributeHadoop/hadoop-2.6.0-cdh5.10.0/etc/hadoop/hdfs-site.xml&quot;);
            
                    try {
                        fs = FileSystem.get(conf);
                    } catch (IOException e) {
                        e.printStackTrace();
                        logger.error(e);
                    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fs;
                } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.添加文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 这里的创建文件夹同shell中的mkdir -p 语序前面的文件夹不存在
     * 跟java中的IO操作一样，也只能对path对象做操作；但是这里的Path对象是hdfs中的
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fs
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; myCreatePath(FileSystem fs){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        Path path &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/huabingood/hyw&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; even the path exist,it can also create the path.&lt;/span&gt;
            b =&lt;span&gt; fs.mkdirs(path);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            logger.error(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fs.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
                logger.error(e);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.删除文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除文件，实际上删除的是给定path路径的最后一个
     * 跟java中一样，也需要path对象，不过是hadoop.fs包中的。
     * 实际上delete(Path p)已经过时了，更多使用delete(Path p,boolean recursive)
     * 后面的布尔值实际上是对文件的删除，相当于rm -r
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fs
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; myDropHdfsPath(FileSystem fs){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; drop the last path&lt;/span&gt;
        Path path = &lt;span&gt;new&lt;/span&gt; Path(&quot;/huabingood/hadoop.tar.gz&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            b &lt;/span&gt;= fs.delete(path,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            logger.error(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fs.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
                logger.error(e);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4.重命名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 重命名文件夹
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hdfs
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; myRename(FileSystem hdfs){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        Path oldPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/huabingood&quot;&lt;span&gt;);
        Path newPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/huabing&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            b &lt;/span&gt;=&lt;span&gt; hdfs.rename(oldPath,newPath);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            logger.error(e);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                hdfs.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
                logger.error(e);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5.文件夹的递归遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 遍历文件夹
             * public FileStatus[] listStatus(Path p)
             * 通常使用HDFS文件系统的listStatus(path)来获取改定路径的子路径。然后逐个判断
             * 值得注意的是：
             *  1.并不是总有文件夹中有文件，有些文件夹是空的，如果仅仅做是否为文件的判断会有问题，必须加文件的长度是否为0的判断
             *  2.使用getPath()方法获取的是FileStatus对象是带URL路径的。使用FileStatus.getPath().toUri().getPath()获取的路径才是不带url的路径
             * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hdfs
             * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; listPath 传入的HDFS开始遍历的路径
             * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
             &lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; recursiveHdfsPath(FileSystem hdfs,Path listPath){
        
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;FileStatus[] files = null;
                try {
                    files = hdfs.listStatus(listPath);
                    Path[] paths = FileUtil.stat2Paths(files);
                    for(int i=0;i&amp;lt;files.length;i++){
                        if(files[i].isFile()){
                            // set.add(paths[i].toString());
                            set.add(paths[i].getName());
                        }else {
                            recursiveHdfsPath(hdfs,paths[i]);
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                    logger.error(e);
                }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        
                FileStatus[] files &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    files &lt;/span&gt;=&lt;span&gt; hdfs.listStatus(listPath);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际上并不是每个文件夹都会有文件的。&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(files.length == 0&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不使用toUri()，获取的路径带URL。&lt;/span&gt;
&lt;span&gt;                        set.add(listPath.toUri().getPath());
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否为文件&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (FileStatus f : files) {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (files.length == 0 ||&lt;span&gt; f.isFile()) {
                                set.add(f.getPath().toUri().getPath());
                            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是文件夹，且非空，就继续遍历&lt;/span&gt;
&lt;span&gt;                                recursiveHdfsPath(hdfs, f.getPath());
                            }
                        }
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                    logger.error(e);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set;
            } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　6.文件的判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 文件简单的判断
     * 是否存在
     * 是否是文件夹
     * 是否是文件
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fs
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myCheck(FileSystem fs){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isExists = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isDirectorys = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isFiles = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        Path path &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/huabingood01&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            isExists &lt;/span&gt;=&lt;span&gt; fs.exists(path);
            isDirectorys &lt;/span&gt;=&lt;span&gt; fs.isDirectory(path);
            isFiles &lt;/span&gt;=&lt;span&gt; fs.isFile(path);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
            logger.error(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fs.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
                logger.error(e);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isExists){
            System.out.println(&lt;/span&gt;&quot;lu jing not cun zai.&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;lu jing cun zai.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isDirectorys){
                System.out.println(&lt;/span&gt;&quot;Directory&quot;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isFiles){
                System.out.println(&lt;/span&gt;&quot;Files&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7.文件配置信息的查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取配置的所有信息
     * 首先，我们要知道配置文件是哪一个
     * 然后我们将获取的配置文件用迭代器接收
     * 实际上配置中是KV对，我们可以通过java中的Entry来接收
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showAllConf(){
        Configuration conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();
        conf.set(&lt;/span&gt;&quot;fs.defaultFS&quot;, &quot;hdfs://huabingood01:9000&quot;&lt;span&gt;);
        Iterator&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;String,String&amp;gt;&amp;gt; it =&lt;span&gt; conf.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()){
            Map.Entry&lt;/span&gt;&amp;lt;String,String&amp;gt; entry =&lt;span&gt; it.next();
            System.out.println(entry.getKey()&lt;/span&gt;+&quot;=&quot; +&lt;span&gt;entry.getValue());
        }
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　8.文件的上传&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 文件下载
     * 注意下载的路径的最后一个地址是下载的文件名
     * copyToLocalFile(Path local,Path hdfs)
     * 下载命令中的参数是没有任何布尔值的，如果添加了布尔是，意味着这是moveToLocalFile()
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fs
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getFileFromHDFS(FileSystem fs){
        Path HDFSPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/hadoop-2.6.0-cdh5.10.0.tar.gz&quot;&lt;span&gt;);
        Path localPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/home/huabingood&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            fs.copyToLocalFile(HDFSPath,localPath);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            logger.error(&lt;/span&gt;&quot;zhe li you cuo wu !&quot;&lt;span&gt; ,e);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                fs.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
                logger.error(&lt;/span&gt;&quot;zhe li you cuo wu !&quot;&lt;span&gt;, e);
            }
        }
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　9.文件的下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 文件的下载
             * 注意事项同文件的上传
             * 注意如果上传的路径不存在会自动创建
             * 如果存在同名的文件，会覆盖
             * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fs
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myPutFile2HDFS(FileSystem fs){
        
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; pathExists = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果上传的路径不存在会创建
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该路径文件已存在，就会覆盖&lt;/span&gt;
                Path localPath = &lt;span&gt;new&lt;/span&gt; Path(&quot;/home/huabingood/绣春刀.rmbv&quot;&lt;span&gt;);
                Path hdfsPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/huabingood/abc/efg/绣春刀.rmbv&quot;&lt;span&gt;);
        
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    fs.copyFromLocalFile(localPath,hdfsPath);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        fs.close();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
        
            } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　10.文件的IO操作——HDFS之间文件的复制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * hdfs之间文件的复制
             * 使用FSDataInputStream来打开文件open(Path p)
             * 使用FSDataOutputStream开创建写到的路径create(Path p)
             * 使用 IOUtils.copyBytes(FSDataInputStream,FSDataOutputStream,int buffer,Boolean isClose)来进行具体的读写
             * 说明：
             *  1.java中使用缓冲区来加速读取文件，这里也使用了缓冲区，但是只要指定缓冲区大小即可，不必单独设置一个新的数组来接受
             *  2.最后一个布尔值表示是否使用完后关闭读写流。通常是false，如果不手动关会报错的
             * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hdfs
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copyFileBetweenHDFS(FileSystem hdfs){
                Path inPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/hyw/test/hadoop-2.6.0-cdh5.10.0.tar.gz&quot;&lt;span&gt;);
                Path outPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Path(&quot;/huabin/hadoop.tar.gz&quot;&lt;span&gt;);
        
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; byte[] ioBuffer = new byte[1024*1024*64];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int len = 0;&lt;/span&gt;
&lt;span&gt;        
                FSDataInputStream hdfsIn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                FSDataOutputStream hdfsOut &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    hdfsIn &lt;/span&gt;=&lt;span&gt; hdfs.open(inPath);
                    hdfsOut &lt;/span&gt;=&lt;span&gt; hdfs.create(outPath);
        
                    IOUtils.copyBytes(hdfsIn,hdfsOut,&lt;/span&gt;1024*1024*64,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;while((len=hdfsIn.read(ioBuffer))!= -1){
                        IOUtils.copyBytes(hdfsIn,hdfsOut,len,true);
                    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                    logger.error(e);
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    hdfsOut.close();
                    hdfsIn.close();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
        
                }
        
            } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 04 Oct 2017 15:59:00 +0000</pubDate>
<dc:creator>huabingood</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanghuabin/p/7628088.html</dc:identifier>
</item>
<item>
<title>可迭代对象、迭代器、生成器的理解 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7628049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7628049.html</guid>
<description>&lt;p&gt;所有的生成器都是迭代器&lt;/p&gt;
&lt;p&gt;关于迭代器和生成器的一种定义：迭代器用于从集合中取出元素；生成器用于凭空生成元素。&lt;/p&gt;
&lt;p&gt;Python中，所有的集合都是可以迭代的，在Python语言内部，迭代器用于支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;for 循环&lt;/li&gt;
&lt;li&gt;构建和扩展集合类型&lt;/li&gt;
&lt;li&gt;逐行遍历文本文件&lt;/li&gt;
&lt;li&gt;列表推导，字典推导，集合推导&lt;/li&gt;
&lt;li&gt;元组拆包&lt;/li&gt;
&lt;li&gt;调用函数时，使用*拆包实参&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如同标题本文的标题一样，这边文章主要讲解三个方面，可迭代对象，迭代器，生成器，下面逐个开始理解&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;可迭代对象&lt;/h2&gt;
&lt;p&gt;先通过下面单词序列例子来理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence(object):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, index):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.words[index]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.words)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        用于打印实例化对象时，显示自定义内容，
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        reprlib.repr函数生成的字符换最多有30个字符，当超过怎会通过省略号显示
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        :return: 自定义内容格式
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; s = Sentence(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;the time has come,&quot; the Walrus said,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; s:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(word)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list(s))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232705771-1608875321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先从结果来看，我们可以看出这个类的实例是可以迭代的，&lt;br/&gt;并且我们从打印print(s)的结果可以看出，显示的也是我们定义的内容，如果我们在类中没有通过__repr__自定义，打印结果将为：&lt;br/&gt;&amp;lt;__main__.Sentence object at 0x102a08fd0&amp;gt;&lt;br/&gt;同时这里的实例化对象也是一个序列，所以我们可以通过s[0]这种方式来获取每个元素&lt;br/&gt;我们都知道序列可以迭代，那么序列为啥可以迭代，继续深入理解&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;序列可以迭代原因&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;解释器需要迭代对象x时，会自动调用iter(x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内置的iter函数作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查对象是否实现了__iter__方法，如果实现调用它，获取一个迭代器&lt;/li&gt;
&lt;li&gt;如果没有实现__iter__方法，但是实现了__getitem__方法，python会创建一个迭代器，尝试按顺序（从0开始）获取元素&lt;/li&gt;
&lt;li&gt;如果尝试失败，会抛出TypeError异常，通常会提示：“C object is not iterable”,其中C是目标对象所属的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;任何python序列可以迭代的原因是，他们都实现了__getitem__方法，并且标准的序列也实现了__iter__方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于如何判断x对象是否为可迭代对象，&lt;span&gt;有两种方法：iter(x)或者isinstance(x,abc.Iterable)&lt;/span&gt;&lt;br/&gt;那么这两种判断法有什么区别么？&lt;br/&gt;其实从Python3.4之后建议是通过iter(x)方法来进行判断，因为iter方法会考虑__getitem__方法，而abc.Iterable不会考虑，所以iter(x)的判断方法更加准确&lt;/p&gt;
&lt;p&gt;就像我最开始写的那个例子，分别通过这两种方式来测试,可以看出，其实这个类是可以迭代的，但是通过abc.Iterable的方式来判断，确实不可迭代的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232739896-1369565500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于可迭代对象的一个小结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用iter内置函数可以获取迭代器的对象，如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的&lt;/li&gt;
&lt;li&gt;序列都可以迭代&lt;/li&gt;
&lt;li&gt;实现了__getitem__方法，而且其参数是从零开始的索引，这种对象也可以迭代&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_3&quot;&gt;迭代器&lt;/h2&gt;
&lt;p&gt;首先我们要明白可迭代的对象和迭代器之间的关系：&lt;br/&gt;Python从可迭代的对象中获取迭代器&lt;/p&gt;
&lt;p&gt;一个简单的例子，当我们循环字符串的时候，字符串就是一个可迭代的对象，背后就是有迭代器，只不过我们看不到，下面为代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过for循环方式&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; s:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;.center(50, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过while循环方式&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; it =&lt;span&gt; iter(s)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(next(it))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt;&lt;span&gt; it
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式都可以获取可迭代对象里的内容，但是while循环的方式如果不通过try/except方式获取异常，最后就会提示StopIteration的错误，这是因为Python语言内部会处理for循环和其他迭代上下文（如列表推导，元组拆包等等）中的StopIteration&lt;/p&gt;
&lt;p&gt;标准的迭代器接口有两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;__next__：返回下一个可用的元素，如果没有元素了抛出StopIteration异常&lt;/li&gt;
&lt;li&gt;__iter__：返回self,以便在应该使用迭代器的地方使用迭代器，例如for循环&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为迭代器只需要__next__和__iter__两个方法，所以除了调用next()方法，以及捕获StopIteration异常之外，没有办法检查是否还有遗留元素，并且没有办法还原迭代器，如果想要再次迭代，就需要调用iter(...)传入之前构建迭代器的可迭代对象&lt;/p&gt;
&lt;p&gt;我们把刚开始写的sentence类通过迭代器的方式来实现，要说的是这种写法不符合python的习惯做法，这里是为了更好的理解迭代器和可迭代对象之间的重要区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; abc
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SentenceIterator(self.words)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SentenceIterator:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,words):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         self.words =&lt;span&gt; words
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         self.index =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             word =&lt;span&gt; self.words[self.index]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IndexError:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopIteration()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         self.index += 1
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; word
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以很清楚的明白，我们定义了一个SenteneIterator是一个迭代器，也实现了迭代器应该有的两种方法：__next__和__iter__方法，这样我们通过 issubclass(SentenceIterator,abc.Iterator)检查&lt;br/&gt;这里我们还能看到可迭代对象和迭代器的区别：&lt;br/&gt;&lt;span&gt;可迭代对象有__iter__方法，每次都实例化一个新的迭代器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;迭代器要实现__next__和__iter__两个方法，__next__用于获取下一个元素，__iter__方法用于迭代器本身，因此迭代器可以迭代，但是可迭代对象不是迭代器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有人肯定在想在Sentence类中实现__next__方法，让Sentence类既是可迭代对象也是自身的迭代器，但是这种想法是不对的，这是也是常见的反模式。所以&lt;span&gt;可迭代对象一定不能是自身的迭代器&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;生成器&lt;/h2&gt;
&lt;p&gt;先通过用生成器方式替换上个例子中SentenceIterator类，例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.words:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; word
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面这个代码中，我们通过yield关键字，这里的__iter__函数其实就是生成器函数，迭代器其实是生成器对象，每次调用__iter__方法，都会自动创建。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;生成器的工作原理&lt;/h3&gt;
&lt;p&gt;Python函数定义体中有yield关键字，该函数就是生成器函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成器函数会创建一个生成器对象，包装生成器函数的定义体，把生成器传给next(...)函数时，生成器函数会向前，执行函数定义体中的下一个yield语句，返回产出的值，并在函数定义体的当前位置暂停，最终，函数的定义体返回时，外层的生成器对象会抛出SotpIteration异常，这一点和迭代器协议一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面是一个生成器的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232936224-1963899459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实我们要明白进行for循环的过程其实就是在隐式的调用next()函数&lt;br/&gt;当我们写了好几种Sentence类的时候，感觉我们通过生成器方式实现的挺简单了，其实还有更简单的方法的，代码例子如下,这里的finditer函数构建了一个迭代器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; match &lt;span&gt;in&lt;/span&gt;&lt;span&gt; RE_WORD.finditer(self.text):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; match.group()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;关于生成器表达式&lt;/h3&gt;
&lt;p&gt;生成器表达式可以理解为列表推导的惰性版本，不会直接构成列表，而是返回一个生成器，按需惰性生成元素。&lt;br/&gt;关于实现Sentence,还可以通过生成器表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (match.group() &lt;span&gt;for&lt;/span&gt; match &lt;span&gt;in&lt;/span&gt; RE_WORD.finditer(self.text))
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 04 Oct 2017 15:31:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7628049.html</dc:identifier>
</item>
<item>
<title>用 Python 撸一个区块链 - kidney</title>
<link>http://www.cnblogs.com/kidney/p/7627145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kidney/p/7627145.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文翻译自 Daniel van Flymen 的文章 Learn Blockchains by Building One&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略有删改。原文地址：&lt;a href=&quot;https://hackernoon.com/learn-blockchains-by-building-one-117428612f46&quot; target=&quot;_blank&quot;&gt;https://hackernoon.com/learn-blockchains-by-building-one-117428612f46&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相信你和我一样对数字货币的崛起感到新奇，并且想知道其背后的技术——区块链是怎样实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是理解区块链并非易事，至少对于我来说是如此。晦涩难懂的视频、漏洞百出的教程以及示例的匮乏令我倍受挫折。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。如果你也这样做，那么读完本文，你将获得一个可用的区块链以及对区块链的深刻理解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;开始之前...&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先你需要知道区块链是由被称为区块的记录构成的不可变的、有序的链式结构，这些记录可以是交易、文件或任何你想要的数据，最重要的是它们是通过 Hash 连接起来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你不了解 Hash，这里有个例子 &lt;a href=&quot;https://learncryptography.com/hash-functions/what-are-hash-functions&quot;&gt;https://learncryptography.com/hash-functions/what-are-hash-functions&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，你需要安装 Python3.6+，Flask，Request&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install Flask==0.12.2 requests==2.18.4
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;同时你还需要一个 HTTP 客户端，比如 Postman，cURL 或任何其它客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的源代码在这里：&lt;a href=&quot;https://github.com/dvf/blockchain&quot;&gt;https://github.com/dvf/blockchain&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步： 打造一个 Blockchain&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中。首先创建一个 Blockchain 类，在构造函数中我们创建了两个列表，一个用于储存区块链，一个用于储存交易。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.chain =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_block(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Creates a new Block and adds it to the chain&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Adds a new transaction to the list of transactions&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hash(block):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Hashes a Block&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; last_block(self):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Returns the last Block in the chain&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一个区块有五个基本属性：index，timestamp（in Unix time），transaction 列表，工作量证明（稍后解释）以及前一个区块的 Hash 值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; block =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1506057125.900785&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8527147fe1f5426f9dd545de4b27ee00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a77f5cdfa2934df3954a5c7c7da5df1f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 5&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ],
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 324984774000&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;到这里，区块链的概念应该比较清楚了：每个新的区块都会包含上一个区块的 Hash 值。这一点非常关键，它是区块链不可变性的根本保障。如果攻击者破坏了前面的某个区块，那么后面所有区块的 Hash 都会变得不正确。不理解？慢慢消化~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要一个向区块添加交易的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self, sender, recipient, amount):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        Creates a new transaction to go into the next mined Block
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        :param sender: &amp;lt;str&amp;gt; Address of the Sender
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        :param recipient: &amp;lt;str&amp;gt; Address of the Recipient
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :param amount: &amp;lt;int&amp;gt; Amount
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :return: &amp;lt;int&amp;gt; The index of the Block that will hold this transaction
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.current_transactions.append({
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: sender,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: recipient,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: amount,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;new_transaction() 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块——下一个待挖掘的区块——的索引，稍后在用户提交交易时会有用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当 Blockchain 实例化后，我们需要创建一个初始的区块（创世块），并且给它预设一个工作量证明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了添加创世块的代码，我们还需要补充 new_block(), new_transaction() 和 hash() 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.chain =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create the genesis block&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         self.new_block(previous_hash=1, proof=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; new_block(self, proof, previous_hash=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         block =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: len(self.chain) + 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: time(),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: self.current_transactions,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: proof,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: previous_hash &lt;span&gt;or&lt;/span&gt; self.hash(self.chain[-1&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Reset the current list of transactions&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        self.chain.append(block)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; block
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self, sender, recipient, amount):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        self.current_transactions.append({
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: sender,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: recipient,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: amount,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + 1
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; last_block(self):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.chain[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hash(block):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         block_string = json.dumps(block, sort_keys=&lt;span&gt;True).encode()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; hashlib.sha256(block_string).hexdigest()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面的代码应该很直观，我们基本上有了区块链的雏形。但此时你肯定很想知道一个区块究竟是怎样被创建或挖掘出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的区块来自工作量证明（PoW）算法。PoW 的目标是计算出一个符合特定条件的数字，这个数字对于所有人而言必须在计算上非常困难，但易于验证。这就是工作量证明的核心思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc...0。设 x = 5，求 y？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hashlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sha256
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; x = 5
&lt;span&gt;3&lt;/span&gt; y = 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We don't know what y should be yet...&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; sha256(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{x*y}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode()).hexdigest()[-1] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     y += 1
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The solution is y = {y}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;结果是 y = 21 // hash(5 * 21) = 1253e9373e...5e3600155e860&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在比特币中，工作量证明算法被称为 Hashcash，它和上面的问题很相似，只不过计算难度非常大。这就是矿工们为了争夺创建区块的权利而争相计算的问题。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，就会获得一定数量的比特币奖励（通过交易）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络要验证结果，当然非常容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们来实现一个 PoW 算法，和上面的例子非常相似，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; uuid &lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid4
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; proof_of_work(self, last_proof):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         proof =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; self.valid_proof(last_proof, proof) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; False:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             proof += 1
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proof
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; valid_proof(last_proof, proof):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         guess = f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{last_proof}{proof}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.encode()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         guess_hash =&lt;span&gt; hashlib.sha256(guess).hexdigest()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; guess_hash[:4] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;衡量算法复杂度的办法是修改零的个数。4 个零足够用于演示了，你会发现哪怕多一个零都会大大增加计算出结果所需的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的 Blockchain 基本已经完成了，接下来我们将使用 HTTP requests 来与之交互。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：作为 API 的 Blockchain&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将使用 Flask 框架，它十分轻量并且很容易将网络请求映射到 Python 函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将创建三个接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /transactions/new 创建一个交易并添加到区块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /mine 告诉服务器去挖掘新的区块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /chain 返回整个区块链&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的服务器将扮演区块链网络中的一个节点。我们先添加一些常规代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; textwrap &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dedent
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; uuid &lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid4
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, jsonify, request
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Instantiate our Node&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; app = Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Generate a globally unique address for this node&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; node_identifier = str(uuid4()).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Instantiate the Blockchain&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; blockchain =&lt;span&gt; Blockchain()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mine():
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;We'll mine a new Block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;   
&lt;span&gt;24&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/transactions/new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction():
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;We'll add a new transaction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; full_chain():
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     response =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: blockchain.chain,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: len(blockchain.chain),
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 200
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     app.run(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=5000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这是用户发起交易时发送到服务器的请求：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;someone else's address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 5
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们已经有了向区块添加交易的方法，因此剩下的部分就很简单了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/transactions/new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     values =&lt;span&gt; request.get_json()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the required fields are in the POST'ed data&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     required = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; all(k &lt;span&gt;in&lt;/span&gt; values &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; required):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Missing values&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 400
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create a new Transaction&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     index = blockchain.new_transaction(values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     response = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Transaction will be added to Block {index}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 201
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;挖掘端正是奇迹发生的地方，它只做三件事：计算 PoW；通过新增一个交易授予矿工一定数量的比特币；构造新的区块并将其添加到区块链中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mine():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We run the proof of work algorithm to get the next proof...&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     last_block =&lt;span&gt; blockchain.last_block
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     last_proof = last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     proof =&lt;span&gt; blockchain.proof_of_work(last_proof)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We must receive a reward for finding the proof.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The sender is &quot;0&quot; to signify that this node has mined a new coin.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    blockchain.new_transaction(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         sender=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         recipient=&lt;span&gt;node_identifier,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         amount=1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Forge the new Block by adding it to the chain&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     block =&lt;span&gt; blockchain.new_block(proof)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     response =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New Block Forged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 200
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;需注意交易的接收者是我们自己的服务器节点，目前我们做的大部分事情都只是围绕 Blockchain 类进行交互。到此，我们的区块链就算完成了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三步：交互演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 Postman 演示，略。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四步：一致性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这真的很棒，我们已经有了一个基本的区块链可以添加交易和挖矿。但是，整个区块链系统必须是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点运行在同一条链上呢？这就是一致性问题，我们要想在网络中添加新的节点，就必须实现保证一致性的算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。让我们新增几个接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1. /nodes/register 接收以 URL 的形式表示的新节点的列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2. /nodes/resolve 用于执行一致性算法，用于解决任何冲突，确保节点拥有正确的链&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; urllib.parse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlparse
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.nodes =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; register_node(self, address):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         parsed_url =&lt;span&gt; urlparse(address)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.nodes.add(parsed_url.netloc)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注意到我们用 set 来储存节点，这是一种避免重复添加节点的简便方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面提到的冲突是指不同的节点拥有的链存在差异，要解决这个问题，我们规定最长的合规的链就是最有效的链，换句话说，只有最长且合规的链才是实际存在的链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们再添加两个方法，一个用于添加相邻节点，另一个用于解决冲突。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; valid_chain(self, chain):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         last_block =&lt;span&gt; chain[0]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         current_index = 1
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; current_index &amp;lt;&lt;span&gt; len(chain):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             block =&lt;span&gt; chain[current_index]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{last_block}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{block}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n-----------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the hash of the block is correct&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] !=&lt;span&gt; self.hash(last_block):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the Proof of Work is correct&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.valid_proof(last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             last_block =&lt;span&gt; block
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             current_index += 1
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; resolve_conflicts(self):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         neighbours =&lt;span&gt; self.nodes
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         new_chain =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We're only looking for chains longer than ours&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         max_length =&lt;span&gt; len(self.chain)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Grab and verify the chains from all the nodes in our network&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neighbours:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             response = requests.get(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://{node}/chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; response.status_code == 200&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 length = response.json()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 chain = response.json()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check if the length is longer and the chain is valid&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; length &amp;gt; max_length &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.valid_chain(chain):
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     max_length =&lt;span&gt; length
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     new_chain =&lt;span&gt; chain
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Replace our chain if we discovered a new, valid chain longer than ours&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; new_chain:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             self.chain =&lt;span&gt; new_chain
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在你可以新开一台机器，或者在本机上开启不同的网络接口来模拟多节点的网络，或者邀请一些朋友一起来测试你的区块链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我希望本文能激励你创造更多新东西。我之所以对数字货币入迷，是因为我相信区块链会很快改变我们看待事物的方式，包括经济、政府、档案管理等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者补充参考：&lt;a href=&quot;https://www.zhihu.com/question/22076666&quot; target=&quot;_blank&quot;&gt;比特币是什么&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 12:50:00 +0000</pubDate>
<dc:creator>kidney</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kidney/p/7627145.html</dc:identifier>
</item>
<item>
<title>简单说明CGI是什么 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/7627035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/7627035.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog1&quot;&gt;&lt;span&gt;1. CGI是什么&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog2&quot;&gt;&lt;span&gt;2. 各种术语解释&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3&quot;&gt;&lt;span&gt;3. web server和CGI的交互模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.1&quot;&gt;&lt;span&gt;3.1 CGI模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.2&quot;&gt;&lt;span&gt;3.2 模块模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.3&quot;&gt;&lt;span&gt;3.3 php-fpm模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;CGI是common gateway interface的缩写，大家都译作通用网关接口，但很不幸，我们无法见名知意。&lt;/p&gt;
&lt;p&gt;我们知道，web服务器所处理的内容都是静态的，要想处理动态内容，需要依赖于web应用程序，如php、jsp、python、perl等。但是web server如何将动态的请求传递给这些应用程序？它所依赖的就是cgi协议。没错，是协议，也就是web server和web应用程序交流时的规范。换句话说，通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能&quot;处理&quot;动态请求，你肯定知道处理两字为什么要加上双引号。&lt;/p&gt;
&lt;p&gt;简单版的cgi工作方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193828411-28489808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，在谷歌搜索栏中搜索一个关键词&quot;http&quot;，对应的URL为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。&lt;/p&gt;
&lt;p&gt;有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。&lt;/p&gt;


&lt;p&gt;说实话，对于一个没接触过编程语言的人来说，刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗，跟cgi有几毛钱关系，fastcgi又是什么？我想，非科班出身的强迫症患者(包括我)一定会被这些概念折腾的死去活来。&lt;/p&gt;
&lt;p&gt;以php为例，我将一次动态请求相关的概念大致都简单解释一遍。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cgi&lt;/code&gt;：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi&lt;/code&gt;：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-cgi&lt;/code&gt;：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-fmp&lt;/code&gt;：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，&lt;strong&gt;php-fpm是php-cgi的进程管理器&lt;/strong&gt;因此它也算是fastcgi协议的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi进程/线程&lt;/code&gt;：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，&lt;strong&gt;调用并初始化zend虚拟机&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi脚本&lt;/code&gt;：被执行的php源代码文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zend虚拟机&lt;/code&gt;：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi进程/线程和zend虚拟机的关系&lt;/code&gt;：cgi进程调用并初始化zend虚拟机的各种环境。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以php-fpm为例，web server从转发动态请求到结束的过程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193620568-1574617626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而每个php-cgi进程的作用大致包括：(有些功能分类错误，请无视，知道大致功能就够了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193753208-1919724771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，尽管php-fpm的全称为PHP FastCGI Process Manager，但严格地讲，php-fpm不是fastcgi的进程管理器，而是php fastcgi即php-cgi的进程管理器。fastcgi只是一种协议，不是进程。就像http协议一样，apache对它的实现是httpd，nginx对它的实现就叫nginx。&lt;/p&gt;
&lt;p&gt;再次说明，cgi和fastcgi是一种协议。各种支持和WEB交互的编程语言对cgi/fastcgi协议都做了各自的实现(当然，任何一种语言都能写cgi脚本)，而php上的php-cgi和php-fpm正是php对fastcgi协议的实现。&lt;/p&gt;


&lt;p&gt;web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-constant&quot;&gt;ProxyRequests&lt;/span&gt; off
&lt;span class=&quot;hljs-constant&quot;&gt;ProxyPassMatch&lt;/span&gt; ^&lt;span class=&quot;hljs-regexp&quot;&gt;/(.*\.php)$ fcgi:/&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/127.0.0.1:9000/usr&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/local/apache&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/htdocs/&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cgi模式&lt;/code&gt;：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;动态模块模式&lt;/code&gt;：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-fpm模式&lt;/code&gt;：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。&lt;/p&gt;

&lt;h2 id=&quot;3-1-cgi-&quot;&gt;3.1 CGI模式&lt;/h2&gt;
&lt;p&gt;使用CGI模式时，当动态请求到达，httpd临时启动一个cgi解释器，并通过cgi协议转发要运行的内容。当cgi脚本运行结束后，将结果返回给httpd，然后cgi解释器进程自我销毁。当多个动态请求到达时，将先后启动懂个cgi解释器。因此，这种方法效率极低。&lt;/p&gt;
&lt;p&gt;在注释掉php5_module的LoadModule相关行后，使用action指令指定要使用cgi运行的类型。但注意，action指令是mod_action提供的，所以必须已经加载该模块。&lt;/p&gt;
&lt;p&gt;例如：指定MIME类型为image/gif的请求使用images.cgi运行。显然，images.cgi脚本你必须先写好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;Action&lt;/span&gt; image/gif /cgi-bin/images.cgi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以通过添加handler来复合文件类型，再使用某个cgi脚本去运行这个handler中的任意类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AddHandler &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;-file-type .xyz
Action &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;-file-type &lt;span class=&quot;hljs-string&quot;&gt;&quot;/cgi-bin/program.cgi&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于php来说，则可以使用安装php时bin目录下提供的php-cgi程序作为cgi程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; php]
pear  peardev  pecl  phar  phar.phar  php  php-cgi  php-config  phpize


[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; php]


Action application/&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;-httpd-php /usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/php/bin/cgi-bin/php-cgi
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;3-2-&quot;&gt;3.2 模块方式&lt;/h2&gt;
&lt;p&gt;在编译php时，将php5_module模块编译到apache中，例如在编译php时在./configure配置中加上&quot;--with-apxs2=/usr/local/apache/bin/apxs&quot;。&lt;/p&gt;
&lt;p&gt;这种交互模式下，httpd在启动时加载并激活php_module。也就是说，php-cgi常驻在httpd进程内部。当动态请求到达时，httpd不用再生成cgi解释器，而是直接将动态请求转发给它内部php-cgi。&lt;/p&gt;
&lt;p&gt;配置实用这种交互模式非常简单，只需使用LoadModule加载php_module，再添加对应的MIME处理器即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; php5_module modules/libphp5.so


&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfModule mime_module&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php .php
&lt;span class=&quot;hljs-keyword&quot;&gt;AddType&lt;/span&gt; applicaiton/x-httpd-php-source .phps
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfModule&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;3-3-php-fpm-&quot;&gt;3.3 php-fpm方式&lt;/h2&gt;
&lt;p&gt;前面说了，php-fpm是php-cgi的进程管理器。这种交互方式实际上是让php-cgi以独立于httpd的方式存在，目前基本使用php-fpm的方式管理php-cgi进程。也就是说，这种模式下，php-cgi和httpd已经分离了，它们的分离意味着请求的动静分离变为可能：httpd和php-fpm分别运行在不同服务器上。动静分离后，压力也分散到各自的服务器上。&lt;/p&gt;
&lt;p&gt;要让php-fpm以这种方式运行，需要在编译的./configure配置选项中添加&quot;--enable-fpm&quot;选项。当然，还得启动php-fpm服务。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service php-fpm &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;start&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样php-cgi进程就开放着端口(默认9000)等待httpd转发动态请求。要让httpd能够转发请求到php-cgi上，需要在httpd.conf中关闭正向代理，并设置fastcgi协议代理参数。例如，转发到192.168.100.54主机上的php-fpm。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;LoadModule&lt;/span&gt; proxy_module modules/mod_proxy.so
&lt;span class=&quot;hljs-constant&quot;&gt;LoadModule&lt;/span&gt; proxy_fcgi_module modules/mod_proxy_fcgi.so


&lt;span class=&quot;hljs-constant&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php .php
&lt;span class=&quot;hljs-constant&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php-source .phps


&lt;span class=&quot;hljs-constant&quot;&gt;ProxyRequests&lt;/span&gt; off
&lt;span class=&quot;hljs-constant&quot;&gt;ProxyPassMatch&lt;/span&gt; ^&lt;span class=&quot;hljs-regexp&quot;&gt;/(.*\.php)$ fcgi:/&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/192.168.100.54:9000/usr&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/local/apache&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/htdocs/&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/7627035.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/h3&gt;
</description>
<pubDate>Wed, 04 Oct 2017 11:50:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/7627035.html</dc:identifier>
</item>
<item>
<title>使用docker部署standalone cinder - 孤独的居士</title>
<link>http://www.cnblogs.com/sting2me/p/7625776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sting2me/p/7625776.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;/strong&gt;版权：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。如有问题，可以邮件：wangxu198709@gmail.com&lt;/p&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;OpenStack社区一直在尝试用Container技术来部署其各个组件，由此还发展出了kolla这个big tent项目，以及衍生项目kolla-ansible。&lt;/p&gt;
&lt;p&gt;最近项目上有些调整，有了些自由时间，于是开始尝试使用container方式部署OpenStack的组件，自然是从最熟悉的Cinder开始。&lt;/p&gt;
&lt;p&gt;惊喜的发现Cinder项目自身就有一个简单易上手的脚步，可以帮助理解以container部署Cinder的基本步骤和方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; [请在ROOT用户下执行下面所有的命令，主要是docker和后面的local-attach都需要root或者sudo，直接使用root会少掉很多坑]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;配置环境&lt;/h2&gt;
&lt;h3&gt;首先clone下来cinder的源代码：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/cinder&lt;/span&gt;
&lt;span&gt;
cd contrib&lt;/span&gt;/block-box/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是安装相关的依赖了，如make, docker，docker-compose&lt;/p&gt;
&lt;h3&gt;安装make及相关包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; build-essential
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装docker&lt;/h3&gt;
&lt;p&gt;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04&lt;/p&gt;
&lt;h3&gt;安装docker-compose&lt;/h3&gt;
&lt;p&gt;https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-16-04&lt;/p&gt;
&lt;p&gt;接下来就是build需要的docker image了&lt;/p&gt;

&lt;p&gt;这个过程中，会clone loci-cinder项目，如果遇到不能clone这个项目，你可以把loci-cinder项目clone到本地，然后修改目录下的Makefile, 指向本地的loci-cinder就行。我就遇到这种问题，于是我做了如下修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
# git &lt;span&gt;diff&lt;/span&gt;&lt;span&gt; Makefile
&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; --git a/contrib/block-box/Makefile b/contrib/block-box/&lt;span&gt;Makefile
index ca173cc..ff60a56 &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt;
--- a/contrib/block-box/&lt;span&gt;Makefile
&lt;/span&gt;+++ b/contrib/block-box/&lt;span&gt;Makefile
@@ &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt; +&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;&lt;span&gt; @@
 CINDER_BRANCH &lt;/span&gt;?= master # master, stable/ocata, refs/changes/&lt;span&gt;67&lt;/span&gt;/&lt;span&gt;418167&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
 NAME_PREFIX &lt;/span&gt;?= &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;-PLATFORM ?= debian # ubuntu, centos
&lt;/span&gt;&lt;span&gt;+PLATFORM ?=&lt;/span&gt;&lt;span&gt;&lt;span&gt; ubuntu # debian, centos
&lt;/span&gt; TAG &lt;/span&gt;?=&lt;span&gt; latest
 
 all: base lvm devbox
 
 base:
&lt;/span&gt;&lt;span&gt;-       docker build https://git.openstack.org/openstack/loci-cinder.git\#:$(PLATFORM) --tag cinder:$(TAG) --build-arg PROJECT_REF=$(CINDER_BRANCH)
&lt;/span&gt;&lt;span&gt;+       docker build /root/containerized/loci-cinder/$(PLATFORM) --tag cinder:$(TAG) --build-arg PROJECT_REF=&lt;/span&gt;&lt;span&gt;&lt;span&gt;$(CINDER_BRANCH)
&lt;/span&gt; 
 lvm:
        docker build &lt;/span&gt;-t cinder-lvm -f ./docker_files/Dockerfile.cinder-lvm .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Docker 的image build好过后，马上就可以使用docker-compose命令启动cinder的相关service了。&lt;/p&gt;
&lt;h2&gt;启动docker的相关service&lt;/h2&gt;
&lt;p&gt;启动之前你要按照自己的需求，修改目录下的&lt;strong&gt;etc-cinder/cinder.conf&lt;/strong&gt; 和 &lt;strong&gt;docker-compose.yml&lt;/strong&gt;文件，你可以参考我的gist文件 &lt;a title=&quot;cinder conf for docker&quot; href=&quot;https://gist.github.com/peter-wangxu/7c310888c9c78694efb91bb2cfd2ca69&quot; target=&quot;_blank&quot;&gt;cinder.conf&lt;/a&gt; 和 &lt;a title=&quot;docker-compose.yml for docker&quot; href=&quot;https://gist.github.com/peter-wangxu/f5bcbf6f904ef9706d604e571a8693d2&quot; target=&quot;_blank&quot;&gt;docker-compose.yml&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;docker-compose -f docker-compose.yml up -d&lt;/p&gt;
&lt;p&gt;docker-compose up -d&lt;br/&gt;Creating network &quot;blockbox_cindernet&quot; with driver &quot;bridge&quot;&lt;br/&gt;Creating blockbox_mariadb_1 ...&lt;br/&gt;Creating blockbox_rabbitmq_1 ...&lt;br/&gt;Creating blockbox_mariadb_1&lt;br/&gt;Creating blockbox_mariadb_1 ... done&lt;br/&gt;Creating blockbox_rabbitmq_1 ... done&lt;br/&gt;Creating blockbox_cinder-api_1 ... done&lt;br/&gt;Creating blockbox_cinder-scheduler_1 ...&lt;br/&gt;Creating blockbox_cinder-scheduler_1 ... done&lt;br/&gt;Creating blockbox_cinder-volume_1 ...&lt;br/&gt;Creating blockbox_cinder-volume_1 ... done&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;启动后，查看启动的container，发现cinder-api服务启动后又退出了。&lt;/p&gt;

&lt;p&gt;最后发现，cinder api的相关code有变动，需要在 当前目录(contrib/block-box)的 etc-cinder/cinder.conf，加入下面&lt;span&gt;绿色&lt;/span&gt;内容，cinder-api才能启动成功，不让会因为找不到key manager而退出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[database]
&lt;span&gt;connection = mysql+pymysql://cinder:password@mariadb/cinder?charset=utf8
&lt;/span&gt;&lt;span&gt;[key_manager]
backend = cinder.keymgr.conf_key_mgr.ConfKeyManager&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改后，重新启动所有docker containers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose -f docker-&lt;span&gt;compose.yml down
docker&lt;/span&gt;-compose -f docker-compose.yml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等一段时间，重新检查所有的docker containers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                   NAMES
67180a6e8056        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bash -c 'pip inst...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;38&lt;/span&gt; seconds ago      Up &lt;span&gt;37&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;volume_1
d963f200be2a        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cinder-scheduler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;39&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;scheduler_1
5166d688bbbd        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sh /init-scripts/...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;39&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;api_1
a14757b40830        mariadb             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker-entrypoint...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;40&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds       &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt;-&amp;gt;&lt;span&gt;3306&lt;/span&gt;/&lt;span&gt;tcp                                  blockbox_mariadb_1
b23d77e10bad        rabbitmq            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker-entrypoint...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;40&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds       &lt;span&gt;4369&lt;/span&gt;/tcp, &lt;span&gt;5671&lt;/span&gt;/tcp, &lt;span&gt;25672&lt;/span&gt;/tcp, &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;5672&lt;/span&gt;-&amp;gt;&lt;span&gt;5672&lt;/span&gt;/tcp   blockbox_rabbitmq_1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有服务都启动成功，后面使用cinder client请求cinder volume&lt;/p&gt;
&lt;p&gt;TIPS: 可以使用下面命令查看docker里面的log。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker logs &amp;lt;container &lt;span&gt;id&lt;/span&gt;&amp;gt; -f 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用cinder volume&lt;/h2&gt;
&lt;h3&gt;安装cinder client&lt;/h3&gt;
&lt;p&gt;接下来，在host上新建virtual environment并在venv中安装最新的cinder client（只有最新的cinder client才有对noauth这种认证方式的支持）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建venv
virtualenv pyenv

. pyenv&lt;/span&gt;/bin/&lt;span&gt;activate
git clone https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/python-cinderclient&lt;/span&gt;
pip &lt;span&gt;install&lt;/span&gt; -e python-cinderclient
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接请求请求cinder api&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
(pyenv) peter@ubuntu16:~/pyenv$ cinder --os-auth-type=noauth --os-endpoint=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8776/v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --os-user-&lt;span&gt;id&lt;/span&gt;=admin --os-tenant-&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;admin list
&lt;/span&gt;+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
| ID                                   | Status    | Name   | Size | Volume Type | Bootable | Attached to |
+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
| 0fefa93d-475e-4cde-&lt;span&gt;9246&lt;/span&gt;-cc5666fde991 | available | peter1 | &lt;span&gt;10&lt;/span&gt;   | -           | &lt;span&gt;false&lt;/span&gt;    |             |
+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意上面使用了--os-auth-type-noauth,这就是让它直接请求cinder api，而不是先到keystone去认证。使用--os-endpoint=127.0.0.1:8776/v3是因为cinder-api同时暴露在了host上的这个端口上。&lt;/p&gt;
&lt;p&gt;这样，就可以使用很多cinder的命令，比如cinder create，list，snapshot-create等等，相关的storage就可以被这个standalone的cinder来管理了。&lt;/p&gt;

&lt;h3&gt;使用local-attach&lt;/h3&gt;
&lt;p&gt;volume创建好后，这里不能给到VM直接使用，因为没有nova:)。尴尬，难道volume就不能给host用了吗？当然可以。opestack社区提供了一个cinder client的plugin，让volume可以直接attach给一个host&lt;/p&gt;

&lt;p&gt;安装python-brick-cinderclient-ext&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/python-brick-cinderclient-ext&lt;/span&gt;
pip &lt;span&gt;install&lt;/span&gt; -e python-brick-cinderclient-ext/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我把刚才创建的volume暴露给host使用（记得在host上安装open-iscsi包）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cinder --os-auth-type=noauth --os-endpoint=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8776/v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --os-user-&lt;span&gt;id&lt;/span&gt;=admin --os-tenant-&lt;span&gt;id&lt;/span&gt;=admin local-attach 0fefa93d-475e-4cde-&lt;span&gt;9246&lt;/span&gt;-cc5666fde991
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，要保证--os-user-id和--os-tenant-id使用与create volume一样的参数，否则会出现NotVolumeFound类似的error&lt;/p&gt;

&lt;h2&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;https://thenewstack.io/deploying-cinder-stand-alone-storage-service/&lt;/p&gt;
&lt;p&gt;https://gorka.eguileor.com/standalone-cinder/&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 11:21:00 +0000</pubDate>
<dc:creator>孤独的居士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sting2me/p/7625776.html</dc:identifier>
</item>
<item>
<title>如何使用windows版Docker并在IntelliJ IDEA使用Docker运行Spring Cloud项目 - 嘿123</title>
<link>http://www.cnblogs.com/hei12138/p/ideausedocker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hei12138/p/ideausedocker.html</guid>
<description>

&lt;h2&gt;#1：前提准备&lt;/h2&gt;
&lt;p&gt;　　1.1 首先请确认你的电脑是windows10专业版或企业版，只有这只有这两个版本才带有hyper-v&lt;/p&gt;
&lt;h2&gt;#2：介绍&lt;/h2&gt;
&lt;p&gt;　　以往我们如果想要在windows上使用docker，都是使用virual box来创建虚拟机，自从windows10发布以来，微软宣布了一系列的linux软件登陆windows，其中就包括了docker，现在我们可以使用windows自带的hyper-v虚拟机来创建运行docker服务。&lt;/p&gt;
&lt;p&gt;　　InteliiJ Idea作为目前最实用的IDE对Docker也提供了支持。&lt;/p&gt;
&lt;h2&gt;#3：安装Docker for windows&lt;/h2&gt;
&lt;p&gt;　　3.1 从官网下载docker for windows，https://store.docker.com/editions/community/docker-ce-desktop-windows，下载完毕后进入安装界面,docker会自动安装，界面一闪而过，电脑运行速度还不错，安装完成之后，docker会弹个窗告诉你hyper-v未开启，像这样。&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915101354438-566977396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不过如果你现在点击OK基本上是没有用的，得先去BIOS里打开硬件虚拟化，本机是惠普的机器，开启点按f10进入bios，其他品牌的机器自行搜索进入，像这样&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102029407-479666203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启电脑后docker会自动运行，依然弹出上面那个hyper-v未开启的窗口，这回可以点击OK让docker来帮你开启hyper-v，或者是自己在控制面板-程序-程序和功能-启用或关闭windows功能里开启hyper-v&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102317860-1492440511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，我们的docker for windows已经安装完成。在命令行中输入docker --version可以查看已经安装的docker版本&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102525047-1664902951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.2 使用docker中的镜像 &lt;/p&gt;
&lt;p&gt;　　　　3.2.1  先用官方镜像作个示例 &lt;/p&gt;
&lt;p&gt;　　　　　　使用 docker search &amp;lt;imageName&amp;gt; 来搜索对应的镜像 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915103256860-698319588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用 docker pull &amp;lt;镜像名:tag&amp;gt; 例如docker pull nginx:latest  ,tag不输入是默认拉取最新的　&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915111606313-812271906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当镜像下载玩之后我们通过docker images命令来查看所有本地的镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161120521-390528689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里下载了java以及nginx的镜像 其中还有我已经打包好的spring cloud的eureka注册中心的镜像&lt;/p&gt;
&lt;p&gt;使用docker run命令来运行镜像，我这里运行nginx的镜像&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161757849-323512683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用docker运行nginx成功后访问localhost:80就可以访问到nginx的主页，说明我们已经在docker运行了我们的第一个镜像，虽然是官方镜像，但心里的成就感还是不低的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161918224-949237030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好的，在运行了第一个镜像之后，我们要开始在IntelliJ IDEA中使用docker并构建我们的第一个spring boot程序放到docker中去运行&lt;/p&gt;
&lt;h2&gt;#4:IDEA的准备工作&lt;/h2&gt;
&lt;p&gt;1：Docker插件，首先需要在你的IDEA中安装Docker插件，定位到File-Setting-Plugins后搜索Docker Integration安装。&lt;/p&gt;
&lt;p&gt;2：配置Docker服务器，在IDEA中定位到File-Setting-build,Execution,Deployment-Docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004162612380-651440164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你没用使用Docker Machine来管理虚拟机的需求的话,我们使用默认的Docker守护进程就OK了，不过在此之前我们还需要设置一下docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163101646-304599227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163227693-1287318838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将docker与本地的连接设置为不需要TLS加密。&lt;/p&gt;
&lt;p&gt;在完成这一步之后，可以在IDEA的配置窗口看到成功连接到了本机上的docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163401349-1138898720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们已经完成对docker的配置，接下来就可以进入真正的实施阶段。&lt;/p&gt;
&lt;h2&gt;#5：创建spring cloud项目&lt;/h2&gt;
&lt;p&gt;　1.首先在Idea中创建一个spring boot项目，怎么创建在此就不再赘述了&lt;/p&gt;
&lt;p&gt;创建完成之后，我们在pom.xml中添加依赖项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164149615-518635213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地编写的是spring cloud的注册中心项目，所以还需要加上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164229130-1305494229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spring的版本需要与spring cloud的版本号对应，详细的对应信息可以去http://projects.spring.io/spring-cloud/查看&lt;/p&gt;
&lt;p&gt; 由于本次只是简单地示范如何在IDEA中部署spring boot项目到docker中，所以在项目中只需要对eureka注册中心进行简单的配置就OK了，&lt;/p&gt;
&lt;p&gt;在启动类中加上注解标明这是一个eureka注册中心的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164846411-1118389797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在配置文件中配置端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164935552-726189701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就完成了项目的编写，可以先启动看看项目是否能够启动，启动之后我们访问http://localhost:8761/ ,可以看到我们的eureka注册中心已经启动，项目编写没有问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004165126458-522792399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就到了如何把项目部署到docker中去的问题了&lt;/p&gt;
&lt;h2&gt;#6：将项目部署到Docker中&lt;/h2&gt;
&lt;p&gt;首先我们需要编写Dockerfile文件，在src-main目录下新建docker文件夹，然后在其中新建Dockerfile文件&lt;/p&gt;
&lt;p&gt;文件内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004165945568-635777686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中红框的地方是本项目打包之后的jar包名字，默认是artifactId-version.jar,同时我们可以看到在左上叫有个运行的标记，很对，这个就是用来在IDEA构建jar包到镜像，然后放到Docker中运行的按钮,不过我们还是需要先配置一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170030661-1071842763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先配置镜像名称以及容器名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170451161-1746553335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后需要对docker容器需要映射的端口号进行配置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170919865-309353323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击run,可以看到，很快就报错了，这是由于DockerFile与我们生成的jar包不在同一个文件夹造成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170956443-919319526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我找到了两种方案：&lt;/p&gt;
&lt;h3&gt;方案1：先使用maven命令&lt;/h3&gt;
&lt;p&gt;mvn clean package&lt;/p&gt;
&lt;p&gt;对项目进行打包，命令执行完毕之后可以在target目录下看到已经打包完成的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171402661-1703226286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把jar包放到Dockerfile所在的目录下，像这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171506083-1084820071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后接着点击Dockerfile中的运行，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171701443-1614590011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Deploylog窗口中，可以看到，这次构建镜像就成功了,在log窗口中可以看到我们的项目在运行过程中打出的日志信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171747630-37221645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，这次的构建和部署都成功了,访问http://localhost:8761/，出现了我们想要看到的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004180412958-215432444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在命令行中使用docker ps 命令查看正在运行的容器信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004172007802-837286534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们在IDEA中编写的项目已经运行到了docker中。&lt;/p&gt;
&lt;h3&gt;方案2：使用docker-maven-plugin插件，在pom.xml中配置插件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174136458-2020532391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在ternimal中运行 mvn clean package -DskipTests=true docker:build命令，打包项目并构建镜像，命令执行完毕可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174311646-167541329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在docker窗口下，我们构建的镜像已经出现在窗口中了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174411740-825246592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右键点击创建一个新的容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174538802-73797904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转到我们的部署配置里面，只需要像方案1中的一样进行配置完毕后点击run就OK了,访问http://localhost:8761/，同样可以看到我们的eureka的运行信息。docker ps 命令也显示我们的容器已经运行起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004175255521-1104190253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;#7：总结&lt;/h2&gt;
&lt;p&gt;好的，到这里我们先是在安装了windows版的docker,然后使用IDEA创建了一个spring cloud项目，并在IDEA中将此项目部署到了docker中，本次随笔就到此为止了。&lt;/p&gt;
&lt;p&gt;如果你对本篇博客有兴趣的话，欢迎共同交流和讨论&lt;/p&gt;
&lt;p&gt;有任何问题请联系hei12138@outlook,com&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 10:07:00 +0000</pubDate>
<dc:creator>嘿123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hei12138/p/ideausedocker.html</dc:identifier>
</item>
<item>
<title>深入理解计算机系统（3.6）------汇编的流程控制 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7593368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7593368.html</guid>
<description>&lt;p&gt;　　前面我们所讲的所有指令，代码执行顺序都是一条接着一条顺序的执行。但是实际上在编码过程中，会有某些结构，比如条件语句（if-else），循环语句（for,do-while）和分支语句（switch）等等，都要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。&lt;/p&gt;
&lt;p&gt;　　在机器代码中，提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。&lt;/p&gt;
&lt;p&gt;　　那么本篇博客我们就来详细介绍在汇编语言中的流程控制。&lt;/p&gt;

&lt;h3&gt;1、条件码&lt;/h3&gt;
&lt;p&gt;　　前面我们在 &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ysocean/p/7593362.html&quot;&gt;操作数指示符和数据传送指令&lt;/a&gt; 中介绍了整数寄存器，在 32位 CPU 中包含一组 8 个存储 32 位值的寄存器，即整数寄存器。它可以存储一些地址或者整数的数据，有的用来记录某些重要的程序状态，有的则用来保存临时数据。&lt;/p&gt;
&lt;p&gt;　　而这里我们要介绍的是条件码（condition code）寄存器。它与整数寄存器不同，它是由单个位组成的寄存器，也就是它们当中的值只能为 0 或者 1。当有算术与逻辑操作发生时，这些条件码寄存器当中的值会相应的发生变化。&lt;/p&gt;
&lt;p&gt;　　也就是说可以检测这些寄存器来执行条件分支指令。常用的条件码如下：&lt;/p&gt;
&lt;p&gt;　　①、CF：进位标志寄存器。最近的操作是最高位产生了进位。它可以记录无符号操作的溢出，当溢出时会被设为1。&lt;/p&gt;
&lt;p&gt;　　②、ZF：零标志寄存器，最近的操作得出的结果为0。当计算结果为0时将会被设为1。&lt;/p&gt;
&lt;p&gt;　　③、SF：符号标志寄存器，最近的操作得到的结果为负数。当计算结果为负数时会被设为1。&lt;/p&gt;
&lt;p&gt;　　④、OF：溢出标志寄存器，最近的操作导致一个补码溢出（正溢出或负溢出）。当计算结果导致了补码溢出时，会被设为1。&lt;/p&gt;
&lt;p&gt;　　从上面可以看出，CF和OF可以判断有符号和补码的溢出，ZF判断结果是否为0，SF判断结果的符号。这是底层机器的设定，而我们所编程用的高级语言（比如C，Java）就是靠这四个寄存器，演化出各种各样的流程控制。&lt;/p&gt;

&lt;h3&gt;2、设置条件码&lt;/h3&gt;
&lt;p&gt;　　通常情况下，条件码寄存器的值无法主动被改变，它们大多时候是被动改变，这算是条件码寄存器的特色。这其实理解起来并不困难，因为条件码寄存器是1位的，而我们的数据格式最低为b，也就是8位，因此你无法使用任何数据传送指令去传送一个单个位的值。&lt;/p&gt;
&lt;p&gt;　　几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于subl %edx,%eax这个减法指令，假设%edx和%eax寄存器的值都为0x10，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。&lt;/p&gt;
&lt;p&gt;　　这里我们需要说明的是，leal 指令作为地址计算的时候，是不改变任何条件码的。&lt;/p&gt;
&lt;p&gt;　　前面我们所讲的算术逻辑指令，在改变整数寄存器的值后，会根据结果设置不同的条件码。而这里还有另外两种指令，它们只设置条件码，而不改变任何其他寄存器的值。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004111725599-1349960030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　①、CMP 指令，指令形式 CMP S2，S1。然后会根据 S1-S2 的差来设置条件码。除了只设置条件码而不更新目标寄存器外，CMP 指令和 SUB 指令的行为是一样的。比如两个操作数相等，那么之差为0，那么就会将零标志设置为 1；其他的标志也可以用来确定两个数的大小关系。&lt;/p&gt;
&lt;p&gt;　　②、TEST 指令，和 AND 指令一样，除了TEST指令只设置条件码而不改变目的寄存器的值。比如对于如下指令：&lt;/p&gt;
&lt;p&gt;　　　　MOV AL,40H&lt;/p&gt;
&lt;p&gt;　　　　TESTB AL,08H&lt;/p&gt;
&lt;p&gt;　　　　上面的指令就是用来测试 AL 寄存器的左起第四位是否为0，结果就是 0100 0000（40H）&amp;amp; 0000 1000（08H），测试结果左起第4位是0，所以各个标志位：CF=0,OF=0,SF=0,ZF=1&lt;/p&gt;

&lt;h3&gt;3、访问条件码&lt;/h3&gt;
&lt;p&gt;　　对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码，通常不会直接读取。常用的有如下三种方法：&lt;/p&gt;
&lt;p&gt;　　①、可以根据条件码寄存器的某个组合，将一个字节设置为0或1。&lt;/p&gt;
&lt;p&gt;　　②、可以直接条件跳转到程序的某个其它的部分。&lt;/p&gt;
&lt;p&gt;　　③、可以有条件的传送数据。&lt;/p&gt;
&lt;p&gt;　　对于第一种情况，下图描述的指令便是根据条件码的某个组合，将一个字节设置为0或1，这一整类指令称为 SET 指令，它们的区别就在与它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：这些指令的后缀表示不同的条件而不是操作数的大小。比如指令 setl 和 setb 表示 “小于时设置（set less）”和“低于时设置（set below）”，而不是“设置长字（set long word）”和“设置字节（set byte）”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004115643880-1175035796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;上图所说的同义名，比如说setg（表示“设置大于”）和 setnle（表示“不小于等于”）指的就是同一条机器指令，编译器和反编译器会随意决定使用哪个名字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　还有set指令中的目的操作数，只能是前面我们所讲的8个单字节的寄存器或者是存储一个字节的存储器位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们分别对 set 指令出现的后缀做简单介绍：&lt;/p&gt;
&lt;p&gt;　　①、e-&amp;gt;ZF（相等）:equals的意思，这里代表的组合是ZF，因为ZF在结果为0时设为1。因此ZF代表的意义是相等。&lt;/p&gt;
&lt;p&gt;　　②、ne-&amp;gt;~ZF（不相等）:not equals 的意思，这里代表的组合是~ZF，也就是ZF做“非运算”，则很明显是不相等的意思。&lt;/p&gt;
&lt;p&gt;　　③、s-&amp;gt;SF（负数）：这里代表的组合是SF，因为SF在计算结果为负数时设为1，此时可以认为b为0，即a&amp;lt;0。因此这里是负数的意思。&lt;/p&gt;
&lt;p&gt;　　④、ns-&amp;gt;~SF（非负数）：与s相反，加上n则是not的意思，因此这里代表非负数。&lt;/p&gt;
&lt;p&gt;　　⑤、l-&amp;gt;SF^OF（有符号的小于）：l代表的是less。这里的组合是SF^OF，即对SF和OF做“异或运算”。“异或运算”的意思则是代表，SF和OF不能相等。那么有两种情况，当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&amp;lt;0，也就是a&amp;lt;b，也就是小于的意思。当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&amp;lt;0，即a&amp;lt;b。综合前面两种情况，SF^OF则代表小于的意思。&lt;/p&gt;
&lt;p&gt;　　⑥、le-&amp;gt;(SF^OF)|ZF（有符号的小于等于）：le是less equals的意思。有了前面小于的基础，这里就很容易理解了。SF^OF代表小于，ZF代表等于，因此两者的“或运算”则代表小于等于。&lt;/p&gt;
&lt;p&gt;　　⑦、g-&amp;gt;~(SF^OF)&amp;amp;~ZF（有符号的大于）：g是greater的意思。这里的组合是~(SF^OF)&amp;amp;~ZF，相对来说就比较复杂了。不过有了前面的铺垫，这个也非常好理解。SF^OF代表小于，则~(SF^OF)代表大于等于，而~ZF代表不等于，将~(SF^OF)与~ZF取“与运算”，则代表大于等于且不等于，也就是大于。&lt;/p&gt;
&lt;p&gt;　　⑧、ge-&amp;gt;~(SF^OF)（有符号的大于等于）：ge是greater equals的意思。&lt;/p&gt;
&lt;p&gt;　　⑨、b-&amp;gt;CF（无符号的小于）：b是below的意思。CF是无符号溢出标志，这里的意思是指如果a-b结果溢出了，则代表a是小于b的，即a&amp;lt;b。其实这个结论很显然，关键点就在于，无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&amp;lt;0。因此这个结论就显而易见了。&lt;/p&gt;
&lt;p&gt;　　⑩、be-&amp;gt;CF|ZF（无符号的小于等于）：这里是below equals的意思。因此这里会与ZF计算“或运算”，字面上也很容易理解，即CF（小于）|（或）ZF（等于），也就是小于等于。&lt;/p&gt;
&lt;p&gt;　　⑪、a-&amp;gt;~CF&amp;amp;~ZF（无符号的大于）：a代表的是above。这个组合也是非常好理解的，CF代表小于，则~CF代表大于等于，~ZF代表不等于，因此~CF&amp;amp;~ZF则代表大于等于且不等于，即大于。&lt;/p&gt;
&lt;p&gt;　　⑫、ae-&amp;gt;~CF（无符号的大于等于）：ae是above equals的意思。&lt;/p&gt;
&lt;p&gt;　　比如对于setae %al指令来说，%al是%eax寄存器中的最后一个字节，这个指令的含义是，将~CF的值设置到%eax寄存器的最后一个字节。&lt;/p&gt;

&lt;h3&gt;4、跳转指令 jump&lt;/h3&gt;
&lt;p&gt;　　正常情况下，指令会按照他们出现的顺序一条一条地执行。而跳转指令（jump）会导致执行切换到程序中一个全新的位置，我们可以理解为方法或者函数的调用。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。比如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    movl $0,%eax
    jmpl  .L1
    movl (%eax),%edx
.L1:
    popl %edx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　指令 jmpl .L1 会导致程序跳过 movl 指令，从 popl 开始执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。&lt;/p&gt;
&lt;p&gt;　　如下图所示，jump 指令有三种跳转方式：&lt;/p&gt;
&lt;p&gt;　　①直接跳转：跳转目标是作为指令的一部分编码的，比如上面的直接给一个标号作为跳转目标&lt;/p&gt;
&lt;p&gt;　　②间接跳转：跳转目标是从寄存器或者存储器位置中读出的，比如 jmp *%eax 表示用寄存器 %eax 中的值作为跳转目标；再比如 jmp *(%eax) 以 %eax 中的值作为读地址，从存储器中读取跳转目标。&lt;/p&gt;
&lt;p&gt;　　③其他条件跳转：根据条件码的某个组合，或者跳转，或者继续执行代码序列中的下一条指令。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004155623161-873652680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　比如对于如下代码：文件名为 hello.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int exchange(int x,int y)
{
        if(x &amp;lt; y){
                return y-x;
        }else{
                return x-y;
        }
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们执行如下命令，将C程序hello.c变为汇编程序 hello.s&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
gcc -O0 -S hello.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-O0是优化选项，还有O0 --&amp;gt;&amp;gt; O1 --&amp;gt;&amp;gt; O2 --&amp;gt;&amp;gt; O3，分别是从没有优化到优化级别最高。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004171357333-1793876232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相信看了前面几篇博客的相关指令介绍，这个汇编代码不难理解。x,y分别存放于栈顶地址偏移量为-4和-8的位置，然后比较x-y的值，也就是指令 cmpl -8(%rbp),%eax，如果x大于或等于y,那么跳转到 .L2 的位置，然后计算 subl %eax,%ecx 的值，即x-y。&lt;/p&gt;
&lt;p&gt;　　我们还可以通过如下命令生成目标文件 hello.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
gcc -O0 -c hello.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过如下命令查看反汇编代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
objdump -d hello.o
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004173456396-819661583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、循环 &lt;/h3&gt;
&lt;p&gt;　　C 语言提供了多种循环结构，比如 do-while、while和for。汇编中没有相应的指令存在，我们可以用条件测试和跳转指令组合起来实现循环的效果。而大多数汇编器会根据一个循环的do-while 循环形式来产生循环代码，即其他的循环一般也会先转换成 do-while 形式，然后在编译成机器代码。&lt;/p&gt;
&lt;p&gt;　　比如如下 do-while 循环：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004174324755-885008959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的汇编代码就不做过多的介绍了，应该很容易看明白。&lt;/p&gt;

&lt;h3&gt;6、条件传送指令 cmov&lt;/h3&gt;
&lt;p&gt;　　条件传送指令。顾名思义，条件传送指令的意思就是在满足条件的时候进行传送的指令，也就是cmov指令。它与set指令十分相似，同样有12种，也就是加上12种条件码寄存器的组合即可，如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004174749599-2077484997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　条件传送指令相当于一个if/else的赋值判断，一般情况下，条件传送指令的性能高于if/else的赋值判断。但是因为条件传送指令将对两个表达式都求值，因此如果两个表达式计算量很大时，那么条件传送指令的性能就可能不如if/else的分支判断了。不过总的来说，这种情况还是很少的，因此条件传送指令还是很有用的，只是并不是所有的处理器都支持条件传送指令，这依赖于处理器以及编译器的编译方式。&lt;/p&gt;
&lt;p&gt;　　条件传送指令最大的缺点便是可能引起意料之外的错误，比如对于下面这一段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int cread(int *xp){
    return (xp ? *xp : 0);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　咋一看，这一段代码是没问题的，不过如果使用条件传送指令去实现这段代码的话，将可能引起空指针引用的错误。因为条件传送指令会先对两个表达式进行计算，也就是说无论xp是否有值，都将计算*xp这个表达式，因此当xp为空指针0时，则会产生错误。由此可见，条件传送指令也不是哪都能用的，通常情况下，编译器会帮我们尽力处理这种错误。&lt;/p&gt;

</description>
<pubDate>Wed, 04 Oct 2017 10:02:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7593368.html</dc:identifier>
</item>
<item>
<title>TeamFlowy——结合Teambition与Workflowy提高生产力 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/teamflowy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/teamflowy.html</guid>
<description>&lt;p&gt;Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。&lt;/p&gt;
&lt;p&gt;当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。&lt;/p&gt;
&lt;h2 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;TeamFlowy是一个Python脚本，运行以后，它会登录Workflowy账号，读取上面所有的条目。名为[Teambition]的条目是任务开始的标记，这个条目下面的一级条目会作为任务被添加到Teambition中。如果任务下面还有二级条目，这些二级条目会作为子任务被添加到任务中。由于Teambition是按照项目-Stage-任务-子任务的形式组织一个工程（其中Stage对应了Teambition中工程下面的面板，例如：“待处理”，“进行中”，“完成”。）不会存在子任务的子任务，所以Workflowy中[Teambition]这个条目下面最多出现二级缩进。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-28-13.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;h3 id=&quot;workflowy&quot;&gt;Workflowy&lt;/h3&gt;
&lt;p&gt;获取Workflowy上面的条目，需要进行三步操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;登录Workflowy&lt;/li&gt;
&lt;li&gt;获取所有条目对应的JSON字符串&lt;/li&gt;
&lt;li&gt;提取需要添加到Teambition中的条目&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;登录workflowy&quot;&gt;登录Workflowy&lt;/h4&gt;
&lt;p&gt;打开Chrome监控登录Wokrflowy的过程，可以看到登录Workflowy需要访问的接口为：&lt;code&gt;https://workflowy.com/accounts/login/&lt;/code&gt;。使用HTTP &lt;code&gt;POST&lt;/code&gt;方式发送请求，提交的数据包括&lt;code&gt;username&lt;/code&gt;，&lt;code&gt;password&lt;/code&gt;和一个不知道用途的&lt;code&gt;next&lt;/code&gt;。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-47-51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Python的第三方网络模块&lt;code&gt;requests&lt;/code&gt;向这个模块发送&lt;code&gt;POST&lt;/code&gt;请求，提交用户名和密码即可实现登录。其代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;login_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://workflowy.com/accounts/login/'&lt;/span&gt;
session &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.Session()
session.post(login_url,
             data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'username'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'12345@qq.com'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'password'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'8888888'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'next'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;获取所有条目&quot;&gt;获取所有条目&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;requests&lt;/code&gt;的&lt;code&gt;session&lt;/code&gt;登录Workflowy以后，Cookies会被自动保存到&lt;code&gt;session&lt;/code&gt;这个对象里面。于是使用&lt;code&gt;session&lt;/code&gt;继续访问Workfowy就可以以登录后的身份查看自己的各个条目。&lt;/p&gt;
&lt;p&gt;通过Chrome可以看到获取所有条目的接口为&lt;code&gt;https://workflowy.com/get_initialization_data?client_version=18&lt;/code&gt;，接口返回的数据是一个包含所有条目的超大型JSON字符串，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-55-40.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Python的json模块可以解析这个JSON字符串为字典，并获取所有条目，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;outline_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://workflowy.com/get_initialization_data?client_version=18'&lt;/span&gt;
outlines_json &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; session.get(outline_url).text
outlines_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; json.loads(outlines_json)
project_list &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; outlines_dict.get(&lt;span class=&quot;st&quot;&gt;'projectTreeData'&lt;/span&gt;, {})&lt;span class=&quot;op&quot;&gt;\&lt;/span&gt;
    .get(&lt;span class=&quot;st&quot;&gt;'mainProjectTreeInfo'&lt;/span&gt;, {})&lt;span class=&quot;op&quot;&gt;\&lt;/span&gt;
    .get(&lt;span class=&quot;st&quot;&gt;'rootProjectChildren'&lt;/span&gt;, [])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;提取任务与子任务&quot;&gt;提取任务与子任务&lt;/h4&gt;
&lt;p&gt;所有的条目层层嵌套在列表-字典结构中，其基本的形态如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;{
    &lt;span class=&quot;st&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [子条目], 
    &lt;span class=&quot;co&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;308496&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;957996b9-67ce-51c7-a796-bfbee44e3d3f&quot;&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;AutoEmo&quot;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的&lt;code&gt;nm&lt;/code&gt;为这个条目的名字。如果一个条目有子条目，那么&lt;code&gt;ch&lt;/code&gt;列表中就会有很多个字典，每个字典的都是这个结构，如果一个条目没有子条目，那么就没有&lt;code&gt;ch&lt;/code&gt;这个key。这样一层一层嵌套下去：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt; {
    &lt;span class=&quot;st&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [
        {
            &lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
            &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;5117e20b-25ba-ba91-59e1-790c0636f78e&quot;&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;准备并熟背一段自我介绍，在任何需要自我介绍的场合都有用&quot;&lt;/span&gt;
        }, 
        {
            &lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;4894b23e-6f47-8028-a26a-5fb315fc4e6f&quot;&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;姓名，来自哪里，什么工作&quot;&lt;/span&gt;,
            &lt;span class=&quot;co&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [
                {&lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;5435246&lt;/span&gt;, 
                 &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;4894b23e-6f47-8028-a26a-5fbadfasdc4e6f&quot;&lt;/span&gt;, 
                 &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;工作经验&quot;&lt;/span&gt;}
            ]
        }
    ], 
    &lt;span class=&quot;co&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;ea282a1c-94f3-1a44-c5b3-7907792e9e6e&quot;&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;自我介绍&quot;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于条目和子条目的结构是一样的，那么就可以使用递归来解析每一个条目。由于需要添加到Teambition的任务，从名为[Teambition]的条目开始，于是可以使用下面这样一个函数来解析：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;task_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {}
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; extract_task(sections, task_dict, target_section&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;):
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; section &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; sections:
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; section[&lt;span class=&quot;st&quot;&gt;'nm'&lt;/span&gt;]
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; target_section:
            task_dict[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [x[&lt;span class=&quot;st&quot;&gt;'nm'&lt;/span&gt;] &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; section.get(&lt;span class=&quot;st&quot;&gt;'ch'&lt;/span&gt;, [])]
            &lt;span class=&quot;cf&quot;&gt;continue&lt;/span&gt;

        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[Teambition]'&lt;/span&gt;:
            target_section &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
        sub_sections &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; section.get(&lt;span class=&quot;st&quot;&gt;'ch'&lt;/span&gt;, [])
        extract_task(sub_sections, task_dict, target_section&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;target_section)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下图所示为一段需要添加到Teambition中的条目，运行这段函数以后，得到的结果为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;{&lt;span class=&quot;st&quot;&gt;'登录Workflowy'&lt;/span&gt;: [], &lt;span class=&quot;st&quot;&gt;'获取需要添加到Teambition的内容'&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'获取任务'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'获取子任务'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'调试Teambition API'&lt;/span&gt;: [], &lt;span class=&quot;st&quot;&gt;'添加任务到Teambition'&lt;/span&gt;: []}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-09-03.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;teambition&quot;&gt;Teambition&lt;/h2&gt;
&lt;p&gt;将任务添加到Teambition，需要使用Teambition的Python SDK登录Teambition并调用API添加任务。Teambition的Python SDK在使用&lt;code&gt;OAuth2&lt;/code&gt;获取&lt;code&gt;access_token&lt;/code&gt;的时候有一个坑，需要特别注意。&lt;/p&gt;
&lt;h3 id=&quot;登录teambition&quot;&gt;登录Teambition&lt;/h3&gt;
&lt;h4 id=&quot;设置teambition应用&quot;&gt;设置Teambition应用&lt;/h4&gt;
&lt;p&gt;Teambition 是使用&lt;code&gt;OAuth2&lt;/code&gt;来进行权限验证的，所以需要获取&lt;code&gt;access_token&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先打开Teambition的&lt;a href=&quot;https://developer.teambition.com/dashboard&quot;&gt;开发者中心&lt;/a&gt;并单击&lt;code&gt;新建应用&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-14-38.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用名称可以随便写。创建好应用以后，可以看到应用的信息，需要记录&lt;code&gt;Client ID&lt;/code&gt;和&lt;code&gt;Client Secret&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-18-20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左侧的&lt;code&gt;OAuth2&lt;/code&gt;配置，填写回调URL，如下图所示。这里的这个URL其实使用任何一个可以访问的网站的域名都可以，这里以我的博客地址为例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-20-49.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用python获取access_token&quot;&gt;使用Python获取access_token&lt;/h4&gt;
&lt;p&gt;首先在Python中安装Teambition的SDK：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;pip&lt;/span&gt; install teambition&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，在Python中获取授权URL：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; teambition &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Teambition

tb_client_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'7bfae080-a8dc-11e7-b543-77a936726657'&lt;/span&gt;
tb_client_secret &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'9830fc8c-81b3-45ed-b3c0-e039ab8f2d8b'&lt;/span&gt;
tb &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Teambition(tb_client_id,
                tb_client_secret)
authorize_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.oauth.get_authorize_url(&lt;span class=&quot;st&quot;&gt;'https://kingname.info'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(authorize_url)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码运行以后，会得到一段形如下面这段URL的授权URL：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://account.teambition.com/oauth2/authorize?client_id=7bfae080-a8dc-11e7-b543-77a936726657&amp;amp;redirect_uri=https://kingname.info&amp;amp;state=&amp;amp;lang=zh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在电脑浏览器中&lt;strong&gt;人工&lt;/strong&gt;访问这个URL，会出现下面这样的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-31-25.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击&lt;code&gt;授权并登录&lt;/code&gt;，可以看到浏览器上面的网址变为形如：&lt;code&gt;https://kingname.info/?code=Pn7ebs4sZh3NYOz2FvVJQ4uu&lt;/code&gt;，此时，需要记录&lt;code&gt;code=&lt;/code&gt;后面的这一串字符串&lt;code&gt;Pn7ebs4sZh3NYOz2FvVJQ4uu&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来就是Teambition的SDK的坑点了，根据Teambition官方文档的说法，要获取access_token，只需要如下两段代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Pn7ebs4sZh3NYOz2FvVJQ4uu'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;#前面浏览器中的字符串&lt;/span&gt;
tb.oauth.fetch_access_token(code)
&lt;span class=&quot;co&quot;&gt;# 上面的代码完成授权，接下来直接使用tb.xxxx就可以操作任务了。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际上，上面这一段代码一定会报错。提示&lt;code&gt;grant invaild&lt;/code&gt;。要解决这个问题，就必需使用Teambition的HTTP 接口来人工获取access_token。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Pn7ebs4sZh3NYOz2FvVJQ4uu'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;#前面浏览器中的字符串&lt;/span&gt;
fetch_result_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; session.post(&lt;span class=&quot;st&quot;&gt;'https://account.teambition.com/oauth2/access_token'&lt;/span&gt;,
                  data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'client_id'&lt;/span&gt;: tb_client_id,
                        &lt;span class=&quot;co&quot;&gt;'client_secret'&lt;/span&gt;: tb_client_secret,
                        &lt;span class=&quot;co&quot;&gt;'code'&lt;/span&gt;: code,
                        &lt;span class=&quot;co&quot;&gt;'grant_type'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'code'&lt;/span&gt;}).json()
tb_access_token &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fetch_result_dict.get(&lt;span class=&quot;st&quot;&gt;'access_token'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时得到的access_token是一段非常长的字符串。接下来，重新初始化tb变量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tb &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Teambition(tb_client_id,
                tb_client_secret,
                access_token&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tb_access_token)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化以后，使用tb这个变量，就可以对工程和任务进行各种操作了。&lt;/p&gt;
&lt;h4 id=&quot;teambition的简单使用&quot;&gt;Teambition的简单使用&lt;/h4&gt;
&lt;p&gt;要在某个工程里面创建任务，就需要知道工程的ID。首先在Teambition中手动创建一个工程，在浏览器中打开工程，URL中可以看到工程的ID，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-45-51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了工程ID以后，就可以使用下面的代码创建任务：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; create_task(task_name, sub_task_list):
        tasklist &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.tasklists.get(project_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'59d396ee1013d919f3348675'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
        tasklist_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tasklist[&lt;span class=&quot;st&quot;&gt;'_id'&lt;/span&gt;]
        todo_stage_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tasklist[&lt;span class=&quot;st&quot;&gt;'stageIds'&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
        task_info &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.tasks.create(task_name, tasklist_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tasklist_id, stage_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;todo_stage_id)
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; sub_task_list:
            task_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; task_info[&lt;span class=&quot;st&quot;&gt;'_id'&lt;/span&gt;]
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; sub_task_name &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; sub_task_list:
                tb.subtasks.create(sub_task_name, task_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;task_id)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'task: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{task_name}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; with sub tasks: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{sub_task_list}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; added.'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码首先使用&lt;code&gt;tb.tasklists.get()&lt;/code&gt;根据工程ID获得任务组的ID和&lt;code&gt;待处理&lt;/code&gt;这个面板的ID，接下来调用&lt;code&gt;tb.tasks.create()&lt;/code&gt;接口添加任务。从添加任务返回的信息里面拿到任务的ID，再根据任务ID，调用&lt;code&gt;tb.subtasks.create()&lt;/code&gt;添加子任务ID。&lt;/p&gt;
&lt;h2 id=&quot;效果测试&quot;&gt;效果测试&lt;/h2&gt;
&lt;p&gt;上面的代码实现了TeamFlowy的基本逻辑。运行TeamFlowy脚本以后，[Teambition]这个条目下面的任务被成功的添加到了Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-55-34.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将代码组合起来并进行完善，让代码更容易使用，完整的代码可以查看&lt;a href=&quot;https://github.com/kingname/TeamFlowy&quot; class=&quot;uri&quot;&gt;https://github.com/kingname/TeamFlowy&lt;/a&gt;。完整的代码运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-17-01-11.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 09:23:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/teamflowy.html</dc:identifier>
</item>
<item>
<title>JavaWeb（一）之细说Servlet - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7625851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7625851.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其实javaWeb的知识早就学过了，可是因为现在在搞大数据开发，所以web的知识都忘记了。准备开始慢慢的把Web的知识一点一点的回忆起来，多学一点没有关系，就怕到时候要用的话，什么都不会了。&lt;/p&gt;

&lt;h2&gt;1.1、Servlet简介&lt;/h2&gt;
&lt;p&gt;　　Servlet 运行&lt;span&gt;在服务端的Java小程序&lt;/span&gt;，是sun公司提供&lt;span&gt;一套规范（接口）&lt;/span&gt;，用来&lt;span&gt;处理客户端请求、响应给浏览器的动态资源&lt;/span&gt;。但&lt;span&gt;servlet的实质就是java代码&lt;/span&gt;，通过java的API 动态的向客户端输出内容。&lt;/p&gt;
&lt;p&gt;　　Servlet是Java Web的三大组件（Servlet,Filter,Listener）之一，属于动态资源 ,运行在 Web 服务器或应用服务器上的程序作用为处理请求，服务器会把接收的请求交给Servlet来处理，在Servlet中通常需要：&lt;/p&gt;
&lt;p&gt;　　　　接受请求数据、处理请求、完成响应&lt;/p&gt;
&lt;p&gt;　　例如：客户端发出登录请求，或输出注册请求，这些请求都应该有Servlet来完成处理。每个Servlet都必须实现javax.servle.Servlet接口。&lt;/p&gt;
&lt;p&gt;　　总结：　　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的&lt;/span&gt;，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B/S模式(浏览器/服务器)。&lt;/p&gt;
&lt;p&gt;　　　　B/S:浏览器/服务器。 浏览器通过网址来访问服务器，比如访问百度，在浏览器中输入www.baidu.com，这个时候浏览器就会显示百度的首页。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004151503943-34533384.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　补充1：&lt;/p&gt;
&lt;p&gt;　　　　servlet规范（sun公司自己制定了一种&lt;span&gt;用于扩展web服务器功能的组件规范&lt;/span&gt;）：包含三个技术点（三大组件）　　　&lt;/p&gt;
&lt;p&gt;　　　　servlet技术&lt;br/&gt;　　　　filter技术---过滤器&lt;br/&gt;　　　　listener技术---监听器&lt;/p&gt;
&lt;p&gt;　　　　1）扩展web服务器功能&lt;/p&gt;
&lt;p&gt;　　　　　　web服务器(tomcat、Weblogic、iis、apache)&lt;span&gt;没有处理动态资源请求的能&lt;/span&gt;力(即该请求需要计算),只能处理静态资源的请求(如果浏览器请求某个html页面，&lt;br/&gt;　　　　　　web服务器查看请求的html页面是否存在，存在则返回。)如果要让web服务器处理动态资源的请求，则需要使用cgi程序、组件加容器的方式。&lt;/p&gt;
&lt;p&gt;　　　　2）组件（可以单独部署的软件模块，组件必须要符合相应的规范。）&lt;/p&gt;
&lt;p&gt;　　　　　　优点是可以加快软件开发的速度，提高软件的可维护性。容器：为组件提供运行环境，并且管理组件的生命周期。组件并不完全依赖特定的容器，只要符合相应的规范就可以。&lt;/p&gt;
&lt;p&gt;　　补充2：　　　&lt;/p&gt;
&lt;p&gt;　　　　Servlet和普通java类的区别：&lt;/p&gt;
&lt;p&gt;　　　　　　客户不能直接&lt;span&gt;创建Servlet对象和调用Servlet的方法&lt;/span&gt;，只能通过向Web服务器发出HTTP请求，间接调用Servlet的方法。　&lt;/p&gt;
&lt;h2&gt;1.2、实现Servlet的方式　&lt;/h2&gt;
&lt;p&gt;　　实现javax.servlet.Servlet接口&lt;br/&gt;　　继承javax.servlet.GenericServlet类&lt;br/&gt;　　继承javax.servlet.http.HttpServlet类&lt;/p&gt;
&lt;p&gt;　　通常会去继承HttpServlet类来完成Servlet&lt;/p&gt;
&lt;h2&gt;1.3、Servlet与线程安全问题&lt;/h2&gt;
&lt;p&gt;　　一个类型的Servlet只有一个实例对象，那么就有可能会出现一个Servlet同时处理多个请求，线程不安全，但Servlet工作效率高。&lt;/p&gt;
&lt;p&gt;　　解决方案：　　　　&lt;/p&gt;
&lt;p&gt;　　　　不要在Servlet中创建成员，创建局部变量变量即可！&lt;br/&gt;　　　　可以创建无状态成员！&lt;br/&gt;　　　　可以创建有状态的成员，但状态必须位为只读的！　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3b2160aa-86ed-4a53-8a46-d7e4d5229106')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3b2160aa-86ed-4a53-8a46-d7e4d5229106',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Servlet extends HttpServlet {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无状态成员&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public class User {
        public void hello() {
            System.out.println(&quot;Hello&quot;);
        }
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建有状态的成员，但状态必须位为只读的&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public class User {
        private String name = &quot;zhangsan&quot;;
        public String getName() {
            return name;
        }
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doPost()...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doGet()...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;示例代码&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　Tomcat 是&lt;span&gt;Web应用服务器,是一个Servlet/JSP容器&lt;/span&gt;. Tomcat 作为&lt;span&gt;Servlet容器,负责处理客户请求,把请求传送给Servlet,&lt;/span&gt;并将&lt;span&gt;Servlet的响应传送回给客户&lt;/span&gt;.而&lt;span&gt;Servlet是一种运行在支持&lt;/span&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;&lt;span&gt;Java语言的服务器上的组件&lt;/span&gt;.。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　从http协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　但是在上面这个图中，并不知道是如何转变的，只知道浏览器发送过来的请求也就是request，我们响应回去的就用response。忽略了其中的细节，现在就来探究一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004152356927-1466503539.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;334&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）Tomcat将&lt;span&gt;http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象&lt;/span&gt;，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。&lt;/p&gt;
&lt;p&gt;　　2）Tomcat同时会要&lt;span&gt;响应的信息封装为HttpServletResponse类型的response对象&lt;/span&gt;，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。&lt;/p&gt;
&lt;p&gt;　　Java Servlet API 是&lt;span&gt;Servlet容器(tomcat)和servlet之间的接口&lt;/span&gt;，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。&lt;/p&gt;
&lt;p&gt;　　所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。&lt;/p&gt;

&lt;h2&gt;3.1、手动编写一个Servlet&lt;/h2&gt;
&lt;p&gt;　　1）创建一个Servlet_demo_0010继承HttpServlet，重写doGet和doPost方法，也就是看请求的方式是get还是post，然后用不同的处理方式来处理请求。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004154455193-1338293430.png&quot; alt=&quot;&quot; width=&quot;962&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）在web.xml中配置Servlet_demo_0010，为什么需要配置？让浏览器发出的请求知道到达哪个servlet，也就是让tomcat将封装好的request找到对应的servlet让其使用。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155214240-1913840074.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　按照步骤，首先浏览器通过http://localhost:4040/Web_Servlet/ServletTest来找到web.xml中的url-pattern，这就是第一步，匹配到了url-pattern后，就会找到第二步servlet的名字MyServlet，知道了名字，&lt;/p&gt;
&lt;p&gt;　　　　就可以通过servlet-name找到第三步，到了第三步，也就能够知道servlet的位置了。然后到其中找到对应的处理方式进行处理。&lt;/p&gt;
&lt;p&gt;　　3）测试&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155537974-857003946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155605193-177148756.png&quot; alt=&quot;&quot;/&gt;说明配置成功了！（输出get因为http请求默认是get请求）&lt;/p&gt;
&lt;h2&gt;3.2、使用Eclipse向导创建一个Servlet&lt;/h2&gt;
&lt;p&gt;　　这个就相对简单了，web.xml不用我们手动配置，工具直接帮我们自动配置了&lt;/p&gt;
&lt;p&gt;　　1）右击项目，在new选项中有直接新建servlet的选项&lt;/p&gt;
&lt;p&gt;　　2）配置Servlet_demo_0020类中的信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155947536-939879966.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）配置web.xml中的servlet信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004160342865-2021108287.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）查看Servlet_demo_0020类中的代码和web.xml，其中的配置跟手动的配置是一样的，只是用图形化界面，让我们更方便的创建servlet而产生的。&lt;/p&gt;

&lt;h2&gt;4.1、生命周期方法与特性&lt;/h2&gt;
&lt;p&gt;　　void init(ServletConfig servletConfig)：Servlet对象创建之后马上执行的初始化方法，只执行一次；&lt;br/&gt;　　void service(ServletRequest servletRequest, ServletResponse servletResponse)：每次处理请求都是在调用这个方法，它会被调用多次；&lt;br/&gt;　　void destroy()：在Servlet被销毁之前调用，负责释放Servlet对象占用的资源的方法；&lt;/p&gt;
&lt;p&gt;　　特性：　　&lt;/p&gt;
&lt;p&gt;　　　　单例，一个类只有一个对象，当然可能存在多个Servlet类&lt;br/&gt;　　　　线程不安全的，所以它的效率高。&lt;/p&gt;
&lt;p&gt;　　Servlet类由自己编写，但&lt;span&gt;对象由服务器来创建，并由服务器来调用相应的方法　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.2、Servlet生命周期　&lt;/h2&gt;
&lt;p&gt;　　服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf)&lt;/p&gt;
&lt;p&gt;　　该servlet对象去&lt;span&gt;处理所有客户端请求&lt;/span&gt;，在service(ServletRequest req，ServletResponse res)方法中执行&lt;/p&gt;
&lt;p&gt;　　最后服务器关闭时，才会销毁这个servlet对象，执行destroy()方法。&lt;/p&gt;
&lt;p&gt;　　图解：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004161231755-1999767937.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　详细说明：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004161403880-897398880.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结（面试会问）：　　　&lt;/p&gt;
&lt;p&gt;　　1）Servlet何时创建&lt;br/&gt;　　　　默认第一次访问servlet时创建该对象（调用init()方法）&lt;br/&gt;　　2）Servlet何时销毁&lt;br/&gt;　　　　服务器关闭servlet就销毁了(调用destroy()方法)&lt;br/&gt;　　3）每次访问必须执行的方法&lt;br/&gt;　　　　public void service(ServletRequest arg0, ServletResponse arg1)&lt;/p&gt;

&lt;h2&gt;5.1、Servlet执行过程&lt;/h2&gt;
&lt;p&gt;　　在浏览器的地址栏输入：http://ip:port/appNames/servlet&lt;/p&gt;
&lt;p&gt;　　1）通过浏览器和ip：port和这个服务器建立连接。&lt;br/&gt;　　2） 浏览器会生成&lt;span&gt;一个请求数据包（路径appNames/servlet）向服务器发送请求&lt;/span&gt;。&lt;br/&gt;　　3） 服务器收到请求数据包，分析请求资源路径做精准定位，通过请求的appName查找webapps文件下面的appName做匹配，匹配上了需要获取web.xml中的servlet(mapping)。　&lt;br/&gt;　　4） 服务器创建两个对象：&lt;br/&gt;　　　　第一个对象：请求对象，该对象实现了HttpServletRequest接口，服务器会将请求数据包中的数据解析出来,存储在该对象里。这样做的好处是没有必要理解http协议，只需要读取request。&lt;br/&gt;　　　　第二个对象：响应对象，实现了HttpServletResponse接口，作用是servlet处理完成后的结果可以存放到该对象上，然后服务器依据该对象的数据生成响应数据包。&lt;br/&gt;　　5） servlet在执行servlet()方法时，可以通过request获取请求数据，也可以将处理结果存放到response上。然后服务器与响应对象直接形成一个默契，生成一个响应数据包给浏览器。&lt;br/&gt;　　6）浏览器解析服务器返回的响应数据包，生成响应的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004162348458-448911593.png&quot; alt=&quot;&quot; width=&quot;1012&quot; height=&quot;280&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　Servlet访问的过程：&lt;/p&gt;
&lt;p&gt;　　　　Http请求----&amp;gt;web.xml--------&amp;gt;  url -pattern-----&amp;gt;servlet-name-----&amp;gt;servlet-class-----&amp;gt;   QuickStratServlet(对应的Class文件)&lt;/p&gt;
&lt;h2&gt;5.2、Servlet配置&lt;/h2&gt;
&lt;div readability=&quot;30&quot;&gt;
&lt;p&gt;　　1）基本配置web.xml文件&lt;br/&gt;　　　　&amp;lt;!--servlet的类的配置--&amp;gt;&lt;br/&gt;　　　　&amp;lt;!--servlet的虚拟路径的配置--&amp;gt;&lt;br/&gt;　　  其中url-pattern的配置方式：&lt;br/&gt;　　　　1）完全匹配：访问的资源与配置的资源完全相同才能访问到　　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　绝对地址只能映射到1个地址&lt;br/&gt;　　　　　　格式：/目录/目录/文件名.扩展名&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;/quickStartServlet&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;　　　　2）目录匹配：格式：/虚拟的目录..../*　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　格式：/目录/目录/*&lt;/p&gt;
&lt;p&gt;　　　　　　这类映射重点匹配目录，只要目录符合映射模式，不考虑文件名，这个Servlet可以响应多个请求URL。&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;/aaa/bbb/ccc/*&amp;lt;/url-pattern&amp;gt; //* 代表任意&lt;br/&gt;　　　　3）匹配扩展名：格式：*.扩展名；　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　格式：*.扩展名&lt;/p&gt;
&lt;p&gt;　　　　　　以匹配扩展名的方式进行URL映射，不考虑文件的目录信息，也可以响应多地址的请求。&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;*.abcd&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　　　注意：第二种与第三种混用   如 ：/aaa/bbb/*.cba  （错误）&lt;/p&gt;

&lt;div readability=&quot;96.5&quot;&gt;
&lt;p&gt;　　2）服务器启动实例化Servlet配置&lt;br/&gt;　　　　Servlet何时创建：默认第一次访问时创建&lt;br/&gt;　　　　为什么是默认？&lt;br/&gt;　　　　当在Servlet的配置是，加上一个配置&amp;lt;load-onstartup&amp;gt; ；&lt;br/&gt;　　　　servlet对象在服务器启动时就创建。&amp;lt;!--数字代表优先级，数字越小优先级越高--&amp;gt;&lt;br/&gt;　　　　&amp;lt;load-on-startup&amp;gt;4&amp;lt;/load-on-startup&amp;gt; 最好取中间数字 4/5。&lt;/p&gt;
&lt;p&gt;　　3）缺省Servlet　　&lt;/p&gt;
&lt;p&gt;　　　　可以将url-pattern 配置一个/，代表该servlet是缺省的servlet。&lt;/p&gt;
&lt;p&gt;　　　　什么是缺省的servlet？&lt;/p&gt;
&lt;p&gt;    　　　　　　当你访问资源地址所有的servlet都不匹配时，缺省的servlet赋值处理。&lt;/p&gt;
&lt;p&gt;　　　　其实，web应用中所有的资源的响应都是servlet负责，包括静态资源（html页面）。（有配置缺省的servlet，无法访问到静态资源。）&lt;/p&gt;
&lt;h2&gt;5.3、创建的servlet是继承自httpServlet，而不是直接实现Servlet接口的原理&lt;/h2&gt;
&lt;p&gt;　　servlet的生命周期中，可以看出，执行的是service方法，为什么我们就只需要写doGet和doPost方法呢？&lt;/p&gt;
&lt;p&gt;　　查看源码，httpServlet的继承结构&lt;/p&gt;
&lt;p&gt;　　httpServlet继承GenericServlet。懂的人立马就应该知道，GenericServlet(通用Servlet)的作用是什么？大概的就是&lt;span&gt;将实现Servlet接口的方法，简化编写servlet的步骤&lt;/span&gt;。具体下面详解&lt;/p&gt;
&lt;div readability=&quot;136&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004164924177-2105983718.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;35&quot;/&gt;&lt;p&gt;　　GenericServlet的继承结构，实现了Servlet接口和ServletConfig接口&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004164954068-1717596710.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Servlet接口内容&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165049802-57023843.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从这里可以看到，Servlet生命周期的三个关键方法，init、service、destroy。还有另外两个方法，一个&lt;span&gt;getServletConfig()方法来获取ServletConfig对象&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　ServletConfig对象可以&lt;span&gt;获取到Servlet的一些信息&lt;/span&gt;，ServletName、ServletContext、InitParameter、InitParameterNames、通过查看ServletConfig这个接口就可以知道：&lt;/p&gt;
&lt;p&gt;　　ServletConfig接口内容&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165238911-1211686638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中&lt;span&gt;ServletContext对象是servlet上下文对象&lt;/span&gt;，功能有很多，获得了ServletContext对象，就能&lt;span&gt;获取大部分我们需要的信息，比如获取servlet的路径，等方法&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　到此，就知道了Servlet接口中的内容和作用，总结起来就是，三个生命周期运行的方法，&lt;span&gt;获取ServletConfig，而通过ServletConfig又可以获取到ServletContext&lt;/span&gt;。而GenericServlet实现了Servlet接口后，&lt;/p&gt;
&lt;p&gt;　　也就说明我们可以直接继承GenericServlet，就可以使用上面我们所介绍Servlet接口中的那几个方法了，能拿到ServletConfig，也可以拿到ServletContext，不过那样太麻烦，不能直接获取ServletContext，&lt;/p&gt;
&lt;p&gt;　　所以&lt;span&gt;GenericServlet除了实现Servlet接口外，还实现了ServletConfig接口，那样，就可以直接获取ServletContext&lt;/span&gt;了。&lt;/p&gt;
&lt;p&gt;　　GenericServlet类的内容详解&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165531396-1686459379.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看上图，用红色框框起来的就是实现Servlet和ServletConfig接口所实现的方法，有9个，这很正常，但是我们可以发现，init方法有两个，一个是带有参数ServletConfig的，一个有无参的方法，为什么这样设计？&lt;/p&gt;
&lt;p&gt;　　这里需要知道其中做了什么事情，来看看这两个方法分别做了什么事？&lt;/p&gt;
&lt;p&gt;　　　　init(ServletConfig config)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165755130-1171472805.png&quot; alt=&quot;&quot; width=&quot;736&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　init()&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165833052-1089090448.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　一个成员变量config&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165918599-247610247.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;27&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　getServletConfig()&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165943396-344420017.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过这几个方法一起来讲解，首先看init(ServletConfig config)方法，&lt;span&gt;因为只有init(ServletConfig config)中带有ServletConfig对象，为了方便能够在其他地方也能直接使用ServletConfig对象，而不仅仅局限在init(ServletConfig config)方法中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以创建一个私有的成员变量config，在init(ServletConfig config)方法中就将其赋值给config，然后通过getServletConfig()方法就能够获取ServletConfig对象了&lt;/span&gt;，这个可以理解，但是在init(ServletConfig config)中，158行，还调用了一个init()方法，&lt;/p&gt;
&lt;p&gt;　　并且这个init()方法是空的，什么读没有，这是为什么呢？这个原因是为了防止一件事情，当我们需要在init方法中做一点别的事情，我们想到的方法就是继承GenericServlet并且重写了init(ServletConfig config)方法，这样依赖，&lt;/p&gt;
&lt;p&gt;　　就破坏了原本在GenericServlet类中init(ServletConfig config)写的代码了，也就是在GenericServlet类中的成员变量config会一直是null，无法得到赋值，因为被重写了，就不会在执行GenericServlet中init(ServletConfig config)方法中的代码。&lt;/p&gt;
&lt;p&gt;　　要想赋值，就必须在重写的init(ServletConfig config)方法中调用父类的init(ServletConfig config)方法，也就是super.init(ServletConfig config)，这样一来，就很不方便，怕有时候会忘了写这句代码，所以在GenericServlet类中增加一个init()方法，&lt;/p&gt;
&lt;p&gt;　　以后需要在init方法中需要初始化别的数据，只需要重写init()这个方法，而不需要去覆盖init(ServletConfig config)这个方法，这样设计，就好很多，不用在管init(ServletConfig config)这个其中的内容了。也不用出现其他的问题。&lt;/p&gt;
&lt;p&gt;　　service(ServletRequest req, ServletResponse res)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170337661-218506448.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一个抽象方法，说明在GenericServlet类中并没有实现该内容，那么我们想到的是，在它上面肯定还有一层，也就是还有一个子类继承它，实现该方法，要是让我们自己写的Servlet继承GenericServlet，&lt;/p&gt;
&lt;p&gt;　　需要自己写service方法，那岂不是累死，并且我们可以看到，service方法中的参数还是ServletRequest，ServletResponse。并没有跟http相关对象挂钩，所以我们接着往下面看。&lt;/p&gt;
&lt;p&gt;　　HttpServlet类详解&lt;/p&gt;
&lt;p&gt;　　　　继承了GenericServlet类，通过我们上面的推测，这个类主要的功能肯定是实现service方法的各种细节和设计。并且通过类名可以知道，该类就跟http挂钩了。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170533099-1296713229.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　关注service(HttpServletRequest req, HttpServletResponse resp)方法和service(ServletRequest req, ServletResponse res)方法。&lt;/p&gt;
&lt;p&gt;　　　　service(ServletRequest req, ServletResponse res)方法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170648021-401084464.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　该方法中就做一件事情，就是将ServletRequest和ServletResponse这两个对象强转为HttpServletRequest和HttpServletResponse对象。为什么能这样转？&lt;/p&gt;
&lt;p&gt;　　　　首先要知道req、res是什么类型，通过打印System.out.println(req)，可以知道，req实际上的类型是org.apache.catalina.connector.RequestFacade&lt;/p&gt;
&lt;p&gt;　　　　Tomcat中的源码：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170755240-1909992374.png&quot; alt=&quot;&quot;/&gt;　　　&lt;/p&gt;
&lt;p&gt;　　　　通过图可以得知，&lt;span&gt;req的继承结构：RequestFacade、httpServletRequest、ServletRequest&lt;/span&gt;，我们知道本身req是ServletRequest，那么从继承结构上看，它也可以看成HttpServletRequest，也可以看成ServletRequest，&lt;/p&gt;
&lt;p&gt;　　　　所以强转为HttpServletRequest是可以的，如果不明白，我举个例子，ArrayList、List、Object 这个，Object obj = new ArrayList();  List list = new ArrayList();  一个ArrayList对象可以看成List对象， 也可以看成一个Object对象，&lt;/p&gt;
&lt;p&gt;　　　　现在obj是不是可以堪称List对象呢？答案是可以的，因为obj就是ArrayList对象，既然是ArrayList对象，那么就可以看成是List对象。一样的道理，RequestFacade 对应 ArrayList、httpServleRequest对应 List、 ServletRequest 对应 Object。&lt;/p&gt;
&lt;p&gt;　　　　转换为httpServletRequest和HttpServletResponse对象之后，在调用service(HttpServletRequest req, HttpServletResponse resp)方法。&lt;/p&gt;
&lt;p&gt;　　　　service(HttpServletRequest req, HttpServletResponse resp)&lt;/p&gt;
&lt;p&gt;　　　　这个方法就是&lt;span&gt;判断浏览器过来的请求方式是哪种&lt;/span&gt;，每种的处理方式不一样，我们常用的就是get，post，并且，我们处理的方式可能有很多的内容，所以，在该方法内会将get，post等其他5种请求方式提取出来，&lt;/p&gt;
&lt;p&gt;　　　　变成单个的方法，然后我们需要编写servlet时，就可以直接重写doGet或者doPost方法就行了，而不是重写service方法，更加有针对性。所以这里就回到了我们上面编写servlet时的情况，继承httpServlet，&lt;/p&gt;
&lt;p&gt;　　　　而只要重写两个方法，一个doGet，一个doPost，其实就是service方法会调用这两个方法中的一个(看请求方式)。所&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 喜欢就点个“推荐”哦！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 04 Oct 2017 09:16:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7625851.html</dc:identifier>
</item>
</channel>
</rss>