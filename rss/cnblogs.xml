<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第8篇 Java中的集合(Set) - Zero_Yi</title>
<link>http://www.cnblogs.com/JuanF/p/9326776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JuanF/p/9326776.html</guid>
<description>&lt;h3&gt;Set类型与List类型的区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Set： 无序、不可重复&lt;/li&gt;
&lt;li&gt;List： 有序、可重复&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1、HashSet&lt;/h2&gt;
&lt;h3&gt;HashSet的存储结构：HashMap&lt;/h3&gt;
&lt;h3&gt;特点：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;HashSet通过比较存放的哈希码（hashCode）来确定对象存放的位置&lt;/li&gt;
&lt;li&gt;当两个对象的哈希值相等时，HashSet通过对象的equals方法来判断两个对象是否相同，如果相同则丢弃该对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于判断元素是否存在的依据是hashCode和equals方法，所以我们在使用时通常重写类的这两个方法，来达到自定义对象比较规则的目的。&lt;/p&gt;
&lt;p&gt;该比较只实现判断两个对象是否相同，从而达到存放不重复的效果，并无排序功能。&lt;/p&gt;
&lt;h3&gt;重写hashCode()和equals(Object obj)方法实现对象比较&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 重写hashCode方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {        
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ID;
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 重写equals方法，必须在执行hashCode方法得到相同哈希值之后才进入该方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getClass() !=&lt;span&gt; obj.getClass())
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    Student other &lt;/span&gt;=&lt;span&gt; (Student) obj;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ID !=&lt;span&gt; other.ID)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;习题：已知ArrayList集合s1, 现要实现将s1中重复的元素移除&lt;/h3&gt;
&lt;p&gt;方法1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HashSet&amp;lt;String&amp;gt; s2 = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;(s1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HashSet&amp;lt;String&amp;gt; s2 = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;&lt;span&gt;();
s2.addAll(s1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法3：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HashSet&amp;lt;String&amp;gt; s2 = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String string : s1) {
    s2.add(string);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、TreeSet&lt;/h2&gt;
&lt;p&gt;TreeSet使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序。&lt;/p&gt;
&lt;h3&gt;构造方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;TreeSet&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot;&gt;Collection&lt;/a&gt;&amp;lt;? extends &lt;a title=&quot;TreeSet 中的类型参数&quot;&gt;E&lt;/a&gt;&amp;gt; c)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的&lt;em&gt;自然顺序&lt;/em&gt;进行排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;&lt;a&gt;TreeSet&lt;/a&gt;&lt;/strong&gt;(&lt;a title=&quot;java.util 中的接口&quot;&gt;Comparator&lt;/a&gt;&amp;lt;? super &lt;a title=&quot;TreeSet 中的类型参数&quot;&gt;E&lt;/a&gt;&amp;gt; comparator)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造一个新的空 TreeSet，它根据指定比较器进行排序。该比较器为实现了Comparator接口的类的实体对象。&lt;/p&gt;
&lt;h3&gt;自然顺序的规则&lt;/h3&gt;
&lt;p&gt;TreeSet使用的元素的自然顺序由元素自己提供比较规则。&lt;/p&gt;
&lt;p&gt;通常这个比较规则有两种实现方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;元素对象实现Comparable接口，并实现接口的CompareTo方法&lt;/li&gt;
&lt;li&gt;TreeSet在实例化的时候传入一个该元素对象的比较器，该比较器实现了Comparator接口，并实现接口的compare方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;实现Comparable接口：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;Student&amp;gt;&lt;span&gt;{
&lt;br/&gt;...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 重写Comparable接口的compareTo方法，将o的name属性与本对象的name属性对比
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Student o) {                
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name.compareTo(o.name);
    }&lt;br/&gt;｝        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;传入比较器：&lt;/h3&gt;
&lt;h4&gt;比较器类&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyComparator &lt;span&gt;implements&lt;/span&gt; Comparator&amp;lt;Student&amp;gt;&lt;span&gt;{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Student o1, Student o2) {        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; o1.getAge() -&lt;span&gt; o2.getAge();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HashSet&amp;lt;Student&amp;gt; stuList = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Student&amp;gt;(&lt;span&gt;new&lt;/span&gt; MyComparator());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;练习：使用TreeSet对存储字符串并根据字符串长度排序&lt;/h3&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化TreeSet，并通过匿名类传入比较器&lt;/span&gt;
    TreeSet&amp;lt;String&amp;gt; tSet = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;String&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(String o1, String o2) {                
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; o2.length() -&lt;span&gt; o1.length();
            }                
        }
    );
    
    tSet.add(&lt;/span&gt;&quot;asd&quot;&lt;span&gt;);
    tSet.add(&lt;/span&gt;&quot;asd1&quot;&lt;span&gt;);
    tSet.add(&lt;/span&gt;&quot;asd111&quot;&lt;span&gt;);
    tSet.add(&lt;/span&gt;&quot;asd11&quot;&lt;span&gt;);
    
    System.out.println(tSet);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[asd111, asd11, asd1, asd]
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Jul 2018 15:49:00 +0000</pubDate>
<dc:creator>Zero_Yi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JuanF/p/9326776.html</dc:identifier>
</item>
<item>
<title>负的CPU保护环 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/9326738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/9326738.html</guid>
<description>&lt;h2 id=&quot;什么是cpu保护环&quot;&gt;&lt;span&gt;什么是CPU保护环？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot;&gt;计算机科学&lt;/a&gt;中, &lt;strong&gt;分级保护域&lt;/strong&gt;（英语：hierarchical protection domains），经常被叫作&lt;strong&gt;保护环&lt;/strong&gt;（Protection Rings），又称&lt;strong&gt;环型保护&lt;/strong&gt;（Rings Protection）、&lt;strong&gt;CPU环&lt;/strong&gt;（CPU Rings），简称Rings。这是一种用来在发生故障时保护数据和功能，提升容错度，避免恶意操作 ，提升&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8&quot;&gt;计算机安全&lt;/a&gt;的设计方式。工作在不同Ring中的对象对资源有不同的访问级别。Rings是从最高特权级（通常对应最小的数字）到最低特权级（最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），同时内层Ring可以随便使用外层Ring的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201807/1072319-20180717234134808-109500174.png&quot; alt=&quot;Priv_rings&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rings的概念最早出现于x86保护模式的设计中。现在，这些Rings通常存储于段选择子和段描述符的特权级位置上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ring0-2为“管理员”层级，可以做大部分事情，但是Ring1-2不能使用特权指令——例如加载描述符表的&lt;code&gt;LGDT&lt;/code&gt;、&lt;code&gt;LLDT&lt;/code&gt;和加载任务寄存器的指令&lt;code&gt;ltr&lt;/code&gt;以及停机指令&lt;code&gt;hlt&lt;/code&gt;等等（Intel的初衷是让驱动存在于此Ring1-2，但现代操作系统通常将驱动也放在Ring0上）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ring3代表“用户模式”。如果你的当前特权级（CFL）或者请求特权级（RFL）在这个环上，那么你需要通过系统调用请求内核帮你完成一些资源利用操作，例如I/O读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上，Rings的设计将用户程序和服务程序对资源的利用进行隔离。正确使用Rings可以提升资源使用的安全性。例如，某个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6&quot;&gt;间谍软件&lt;/a&gt;作为一个在Ring 3运行的用户程序，它在不通知用户的时候打开&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%91%84%E5%83%8F%E5%A4%B4&quot;&gt;摄像头&lt;/a&gt;应该会被阻止，因为访问硬件需要使用被&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F&quot;&gt;驱动程序&lt;/a&gt;保留的Ring 1的方法。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么会有负的保护环&quot;&gt;&lt;span&gt;为什么会有负的保护环？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在现在的处理器中，大多有对虚拟化的硬件支持，例如Intel VT-x 和 AMD-V。在进行虚拟化之前，需要一些“高级管理员程序”初始化虚拟控制结构（这被称为VMCS），随后定义虚拟机并调用 &lt;code&gt;vmenter&lt;/code&gt; 和处理 &lt;code&gt;vmexit&lt;/code&gt; 进行虚拟化。而这些代码就工作在“Ring-1”层级。事实上，CPU并没有定义这种层级，但是考虑到每一个被虚拟化的内核都认为它们对系统有完全的控制权（Ring0），而它们又是被虚拟层所控制（对它们不可见），所以称其为“Ring-1”也是有道理的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统管理模式（&lt;a href=&quot;https://en.wikipedia.org/wiki/System_Management_Mode&quot;&gt;SMM&lt;/a&gt;）是另一种执行特殊指令的操作模式。电脑主板上会有一些固件（例如BIOS）建立起SMM来处理系统管理中断，例如为了实现高级电源管理。当这些事件/中断发生后，操作系统（甚至是上面提到的虚拟层）都会被挂起，随后CPU进入一个特殊的地址空间处理中断。由于SMM对于操作系统和虚拟层都不可见，所以通常称其工作在“Ring-2”下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人可能记得去年有一个新闻：&lt;a href=&quot;http://news.mydrivers.com/1/554/554587.htm&quot;&gt;MINIX悄然成最流行系统：暗藏核弹级漏洞&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Intel现代处理器都支持ME管理引擎，用来管理协调内部的诸多模块，尤其是传统芯片组整合进入之后，处理器已经差不多成了SoC（System on Chip）单芯片系统，更需要一个“协同总管CPU”，而MINIX就是这个微型CPU的操作系统。 AMD也有自己的协同处理器，称为PSP。这个CPU可以对芯片组做任何事情，&lt;strong&gt;即使是在系统通电但还没有启动的时候（甚至系统的启动也是它的管理范畴）&lt;/strong&gt;。所以我们也称其工作在“Ring-3”下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从安全的角度考虑，程序工作的Ring值越低，其行为的可见性也就越低。例如用户程序不会意识到自己是工作在一个“虚拟地址”中，而OS不会意识到自己只是多个被虚拟化出来的一个，而虚拟层不会意识到自己在工作过程中SMM已经完成了对一些中断的处理，而协同处理器对以上所有对象都是不可见的。可以想象，如果能够在Ring值更低的层级植入恶意程序，其被查杀的难度也会越高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，以上说明基于x86架构，其他的架构CPU也有类似设计方式，例如ARM的user (3), supervisor (0), VMM (-1) 和TrustZone (-2)。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Protection_ring&quot;&gt;Protection ring From Wikipedia&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://software.intel.com/en-us/forums/watercooler-catchall/topic/306240&quot;&gt;Ring Architecture Question From Intel&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://manybutfinite.com/post/cpu-rings-privilege-and-protection/&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://security.stackexchange.com/questions/129098/what-is-protection-ring-1&quot;&gt;What is protection ring -1?&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://book.douban.com/subject/20492528/&quot;&gt;《x86汇编语言:从实模式到保护模式》&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 17 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/9326738.html</dc:identifier>
</item>
<item>
<title>3YAdmin-专注通用权限控制与表单的后台管理系统模板 - 若若若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9326716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9326716.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/wjkang/3YAdmin&quot;&gt;3YAdmin&lt;/a&gt;基于React+Antd构建。GitHub搜索React+Antd+Admin出来的结果没有上百也有几十个，为什么还要写这个东西呢？&lt;/p&gt;
&lt;p&gt;一个后台管理系统的核心我认为应该是权限控制，表单以及错误信息收集这三大块，前两个最为重要。而GitHub上的大多数项目关注点都不在这里，各种第三方组件堆砌在一起，看起来很炫酷，但是实用性没多大，改起来也麻烦(如果是vue,可以看我的另一个项目&lt;a href=&quot;https://github.com/wjkang/vue-quasar-admin&quot;&gt;vue-quasar-admin&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;有人可能会有疑问：权限控制，不同系统实现不一样，根本没法做到通用。权限控制的模型就那几种，而且大部分都是RBAC，可能做不到完全通用，但是至少改动不会太大。&lt;/p&gt;
&lt;h2 id=&quot;yadmin&quot;&gt;3YAdmin&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://github.com/wjkang/3YAdmin&quot;&gt;3YAdmin&lt;/a&gt;是一个专注通用权限控制与表单的后台管理系统模板。&lt;/p&gt;
&lt;p&gt;  3YAdmin支持两种布局模式，Tab模式和正常模式。两种模式是webpack打包编译时确定的，打包某个模式时不会引入另外一种模式下的多余代码(React 实现Tab模式比较蛋疼)。&lt;/p&gt;
&lt;p&gt;  3YAdmin实现了RBAC权限控制模型的核心功能页面和操作。&lt;/p&gt;
&lt;p&gt;  3YAdmin通过解析定义好的JSON数据，可以生成查询表单，静态表单，动态表单。&lt;/p&gt;
&lt;p&gt;  搭配&lt;a href=&quot;https://github.com/wjkang/lazy-mock&quot;&gt;lazy-mock&lt;/a&gt; 可以快速生成前后端带mock数据的增删改查功能(简单的代码生成器)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jaycewu/p/9326716.html&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be46aa44f07&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/facebook/react/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/react-16.3.2-brightgreen.svg&quot; alt=&quot;react&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/antd-3.5.3-brightgreen.svg&quot; alt=&quot;antd&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/axios-0.18.0-brightgreen.svg&quot; alt=&quot;axios&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/reduxjs/redux&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/redux-4.0.0-brightgreen.svg&quot; alt=&quot;redux&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/react--router--dom-4.2.2-brightgreen.svg&quot; alt=&quot;react-router-dom&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/jaycewu/p/9326716.html&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/license-MIT-brightgreen.svg&quot; alt=&quot;MIT&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;online demo:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jaycewu.coding.me/3YAdmin-preview&quot;&gt;Tab Mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jaycewu.coding.me/3YAdmin-preview-common&quot;&gt;Common Mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录账号:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin 123

test 123456

website_admin 123456&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;功能与特点&quot;&gt;功能与特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;真实后端数据支持&lt;/li&gt;
&lt;li&gt;登录/登出&lt;/li&gt;
&lt;li&gt;收缩左侧菜单栏&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;li&gt;按需加载&lt;/li&gt;
&lt;li&gt;Tag标签导航&lt;/li&gt;
&lt;li&gt;面包屑&lt;/li&gt;
&lt;li&gt;全屏/退出全屏&lt;/li&gt;
&lt;li&gt;动态菜单与静态菜单&lt;/li&gt;
&lt;li&gt;菜单按模块划分&lt;/li&gt;
&lt;li&gt;通用权限控制
&lt;ul&gt;&lt;li&gt;菜单级权限控制&lt;/li&gt;
&lt;li&gt;接口级权限控制&lt;/li&gt;
&lt;li&gt;元素级权限控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全局可配置loading效果&lt;/li&gt;
&lt;li&gt;网络异常处理&lt;/li&gt;
&lt;li&gt;模块
&lt;ul&gt;&lt;li&gt;系统模块
&lt;ul&gt;&lt;li&gt;系统设置
&lt;ul&gt;&lt;li&gt;菜单管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;权限管理
&lt;ul&gt;&lt;li&gt;功能管理&lt;/li&gt;
&lt;li&gt;角色管理&lt;/li&gt;
&lt;li&gt;角色权限管理&lt;/li&gt;
&lt;li&gt;角色用户管理&lt;/li&gt;
&lt;li&gt;用户角色管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组织架构
&lt;ul&gt;&lt;li&gt;部门管理&lt;/li&gt;
&lt;li&gt;职位管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;审计日志&lt;/li&gt;
&lt;li&gt;数据初始化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;例子
&lt;ul&gt;&lt;li&gt;权限测试页&lt;/li&gt;
&lt;li&gt;错误页&lt;/li&gt;
&lt;li&gt;JSON表单(通过解析JSON数据,动态生成表单)
&lt;ul&gt;&lt;li&gt;Search Form(查询表单)&lt;/li&gt;
&lt;li&gt;Common Form(静态表单,解析第一次后,JSON数据改变后表单不会跟着变)&lt;/li&gt;
&lt;li&gt;Dynamic Form(动态表单,JSON数据改变后表单重新生成)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装使用&quot;&gt;安装使用&lt;/h2&gt;
&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;git clone https://github.com/wjkang/3YAdmin.git

npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后台mock服务&lt;/p&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;git clone -b 3YAdmin https://github.com/wjkang/quasar-admin-server.git

npm install

npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run&quot;&gt;Run&lt;/h2&gt;
&lt;h3 id=&quot;development&quot;&gt;Development&lt;/h3&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;productionbuild&quot;&gt;Production(Build)&lt;/h3&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;直接将react-react-app生成的配置复制出来进行修改，都在react-scripts文件夹下，当前配置了antd按需引入，分chunk打包以及使用了AutoDllPlugin。可以按照自己的需要进行修改。&lt;/p&gt;
&lt;p&gt;打包模式的配置需修改buils.js与start.js文件中的process.env.REACT_APP_LAYOUT_MODE&lt;/p&gt;
&lt;h2 id=&quot;使用教程&quot;&gt;使用教程&lt;/h2&gt;
&lt;p&gt;后面会出详细使用教程以及前后端分离的后台管理系统前端架构设计思路(包含vue和react)，喜欢的话可以给个star。&lt;/p&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa3f4080?w=1913&amp;amp;h=872&amp;amp;f=jpeg&amp;amp;s=17544&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa489ed8?w=1911&amp;amp;h=868&amp;amp;f=jpeg&amp;amp;s=28493&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa746b37?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=39638&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fcf1f787?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=51561&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fc440fb4?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=102208&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4670a06e5?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=84317&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4b809cdb8?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=77884&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4c776b40f?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=73593&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4c7abdd9e?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=74306&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4ff033b19?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=49744&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be50ddb4bb3?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=97566&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be554015a57?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=74087&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:34:00 +0000</pubDate>
<dc:creator>若若若邪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9326716.html</dc:identifier>
</item>
<item>
<title>Java并发编程笔记之基础总结(二) - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9324072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9324072.html</guid>
<description>&lt;h3&gt;一.线程中断&lt;/h3&gt;
&lt;p&gt;Java 中线程中断是一种线程间协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是需要被中断的线程根据中断状态自行处理。&lt;/p&gt;
&lt;p&gt;　　1.void interrupt() 方法：中断线程，例如当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 并没有实际被中断，会继续往下执行的。如果线程 A 因为调用了 wait 系列函数或者 join 方法或者 sleep 函数而被阻塞挂起，这时候线程 B 调用了线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。&lt;/p&gt;

&lt;p&gt;　　2.boolean isInterrupted()：检测当前线程是否被中断，如果是返回 true，否者返回 false，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isInterrupted() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递false，说明不清除中断标志&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; isInterrupted(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.boolean interrupted():检测当前线程是否被中断，如果是返回 true，否者返回 false，与 isInterrupted 不同的是该方法如果发现当前线程被中断后会清除中断标志，并且该函数是 static 方法，可以通过 Thread 类直接调用。另外从下面代码可以知道 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; boolean interrupted() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个线程使用 Interrupted 优雅退出的经典使用例子，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){    
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{    
         ....    
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程退出条件&lt;/span&gt;
         &lt;span&gt;while&lt;/span&gt;(!Thread.currentThread().isInterrupted()&amp;amp;&amp;amp; more work to &lt;span&gt;do&lt;/span&gt;&lt;span&gt;){    
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do more work;    &lt;/span&gt;
&lt;span&gt;         }    
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){    
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thread was interrupted during sleep or wait    &lt;/span&gt;
&lt;span&gt;    }    
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{    
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cleanup, if required    &lt;/span&gt;
&lt;span&gt;    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个根据中断标志判断线程是否终止的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterruptTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前线程被中断则退出循环&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;Thread.currentThread().isInterrupted())
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线程&lt;/span&gt;
&lt;span&gt;        thread.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠1s，以便中断前让子线程输出点东西&lt;/span&gt;
        Thread.sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断子线程&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread interrupt thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        thread.interrupt();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子线程执行完毕&lt;/span&gt;
&lt;span&gt;        thread.join();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717155718360-1098815264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码子线程 thread 通过检查当前线程中断标志来控制是否退出循环，主线程在休眠 1s 后调用 thread 的 interrupt() 方法设置了中断标志，所以线程 thread 退出了循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：中断一个线程仅仅是设置了该线程的中断标志，也就是设置了线程里面的一个变量的值，本身是不能终止当前线程运行的，一般程序里面是检查这个标志的状态来判断是否需要终止当前线程。&lt;/p&gt;

&lt;h3&gt;二.理解线程上下文切换&lt;/h3&gt;
&lt;p&gt;在多线程编程中，线程个数一般都大于 CPU 个数，而每个 CPU 同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行，CPU 资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片，在时间片内占用 CPU 执行任务。当前线程的时间片使用完毕后当前就会处于就绪状态并让出 CPU 让其它线程占用，这就是上下文切换，从当前线程的上下文切换到了其它线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么就有一个问题让出 CPU 的线程等下次轮到自己占有 CPU 时候如何知道之前运行到哪里了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以在切换线程上下文时候需要保存当前线程的执行现场，当再次执行时候根据保存的执行现场信息恢复执行现场&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程上下文切换时机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.当前线程的 CPU 时间片使用完毕处于就绪状态时候；&lt;/p&gt;
&lt;p&gt;　　2.当前线程被其它线程中断时候&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：由于线程切换是有开销的，所以并不是开的线程越多越好，比如如果机器是4核心的，你开启了100个线程，那么同时执行的只有4个线程，这100个线程会来回切换线程上下文来共享这四个 CPU。&lt;/p&gt;

&lt;h3&gt;三.线程死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是线程死锁呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161132774-1067772434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，线程 A 已经持有了资源1的同时还想要资源2，线程 B 在持有资源2的时候还想要资源1，所以线程1和线程2就相互等待对方已经持有的资源，就进入了死锁状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么产生死锁的原因都有哪些，学过操作系统的应该都知道死锁的产生必须具备以下四个必要条件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.互斥条件&lt;/strong&gt;：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.请求并持有条件&lt;/strong&gt;：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3.不可剥夺条件&lt;/strong&gt;：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.环路等待条件&lt;/strong&gt;：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn正在等待已被 T0 占用的资源。&lt;/p&gt;

&lt;p&gt;下面通过一个例子来说明线程死锁，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLockTest1 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建资源&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object resourceA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object resourceB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程A&lt;/span&gt;
        Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceB) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程B&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceB) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceA) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                };
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;        threadA.start();
        threadB.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161510784-600410248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面分析下代码和结果，其中 Thread-0 是线程 A，Thread-1 是线程 B，代码首先创建了两个资源，并创建了两个线程。&lt;/p&gt;
&lt;p&gt;从输出结果可以知道线程调度器先调度了线程 A，也就是把 CPU 资源让给了线程 A，线程 A 调用了 getResourceA() 方法，方法里面使用 synchronized(resourceA) 方法获取到了 resourceA 的监视器锁，然后调用 sleep 函数休眠 1s，休眠 1s 是为了保证线程 A 在执行 getResourceB 方法前让线程 B 抢占到 CPU 执行 getResourceB 方法。&lt;/p&gt;
&lt;p&gt;线程 A 调用了 sleep 期间，线程 B 会执行 getResourceB 方法里面的 synchronized(resourceB)，代表线程 B 获取到了 objectB 对象的监视器锁资源，然后调用 sleep 函数休眠 1S。&lt;/p&gt;
&lt;p&gt;好了，到了这里线程 A 获取到了 objectA 的资源，线程 B 获取到了 objectB 的资源。线程 A 休眠结束后会调用 getResouceB 方法企图获取到 ojbectB 的资源，而 ObjectB 资源被线程 B 所持有，所以线程 A 会被阻塞而等待。而同时线程 B 休眠结束后会调用 getResourceA 方法企图获取到 objectA 上的资源，而资源 objectA 已经被线程 A 持有，所以线程 A 和 B 就陷入了相互等待的状态也就产生了死锁。&lt;/p&gt;

&lt;p&gt;下面从产生死锁的四个条件来谈谈本案例如何满足了四个条件。&lt;/p&gt;
&lt;p&gt;首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了资源互斥条件。&lt;/p&gt;
&lt;p&gt;线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就构造了持有并等待。&lt;/p&gt;
&lt;p&gt;线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这构造了资源的不可剥夺条件。&lt;/p&gt;
&lt;p&gt;线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这构成了循环等待条件。&lt;/p&gt;
&lt;p&gt;所以线程 A 和 B 就形成了死锁状态。&lt;/p&gt;
&lt;h4&gt;那么如何避免线程死锁呢？&lt;/h4&gt;
&lt;p&gt;要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是学过操作系统童鞋应该都知道目前只有持有并等待和循环等待是可以被破坏的。&lt;/p&gt;
&lt;p&gt;造成死锁的原因其实和申请资源的顺序有很大关系，使用资源申请的有序性原则就可以避免死锁，那么什么是资源的有序性呢，先看一下对上面代码的修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程B&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceB) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                };
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161716732-795083047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码可知修改了线程 B 中获取资源的顺序和线程 A 中获取资源顺序一致，其实资源分配有序性就是指假如线程 A 和 B 都需要资源1，2，3……n 时候，对资源进行排序，线程 A 和 B 只有在获取到资源 n-1 时候才能去获取资源 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：编写并发程序，多个线程进行共享多个资源时候要注意采用资源有序分配法避免死锁的产生。&lt;/p&gt;

&lt;h3&gt;四守护线程与用户线程&lt;/h3&gt;
&lt;p&gt;Java 中线程分为两类，分别为 Daemon 线程（守护线程）和 User 线程（用户线程），在 JVM 启动时候会调用 main 函数，main 函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程（严格说属于 JVM 线程）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么守护线程和用户线程有什么区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区别之一是当最后一个非守护线程结束时候，JVM 会正常退出，而不管当前是否有守护线程；也就是说守护线程是否结束并不影响 JVM 的退出。言外之意是只要有一个用户线程还没结束正常情况下 JVM 就不会退出。&lt;/p&gt;
&lt;p&gt;那么 Java 中如何创建一个守护线程呢？代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Thread daemonThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为守护线程&lt;/span&gt;
        daemonThread.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        daemonThread.start();

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知只需要设置线程的 daemon 参数为 true 即可。&lt;/p&gt;
&lt;p&gt;下面通过例子来加深用户线程与守护线程的区别的理解，首先看下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserThreadTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;){}
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线&lt;/span&gt;
&lt;span&gt;        thread.start();

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717162105967-744109618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码在 main 线程中创建了一个 thread 线程，thread 线程里面是无限循环，运行代码从结果看 main 线程已经运行结束了，那么 JVM 进程已经退出了？从 IDE 的输出结侧上的红色方块说明 JVM 进程并没有退出，另外 Mac 上执行 &lt;code&gt;ps -eaf | grep java&lt;/code&gt; 会输出结果，也可以证明这个结论。&lt;/p&gt;
&lt;p&gt;这个结果说明了当父线程结束后，子线程还是可以继续存在的，也就是子线程的生命周期并不受父线程的影响。也说明了当用户线程还存在的情况下 JVM 进程并不会终止。&lt;/p&gt;
&lt;p&gt;那么我们把上面的 thread 线程设置为守护线程后在运行看看会有什么效果，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DaemonThreadTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;){}
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为守护线程&lt;/span&gt;
        thread.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线&lt;/span&gt;
&lt;span&gt;        thread.start();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717162357032-1173066310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上在启动线程前设置线程为守护线程，从输出结果可知 JVM 进程已经终止了，执行 &lt;code&gt;ps -eaf |grep java&lt;/code&gt; 也看不到 JVM 进程了。这个例子里面 main 函数是唯一的用户线程，thread 线程是守护线程，当 main 线程运行结束后，JVM 发现当前已经没有用户线程了，就会终止 JVM 进程。&lt;/p&gt;
&lt;p&gt;Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 DestroyJavaVM 线程，该线程会等待所有用户线程结束后终止 JVM 进程。&lt;/p&gt;
&lt;p&gt;下面通过简单的 JVM 代码来证明这个结论，翻开 JVM 的代码，最终会调用到 JavaMain 这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; JNICALL
JavaMain(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt; _args)
{   
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行Java中的main函数 &lt;/span&gt;
    (*env)-&amp;gt;&lt;span&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main函数返回值&lt;/span&gt;
    ret = (*env)-&amp;gt;ExceptionOccurred(env) == NULL ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待所有非守护线程结束，然后销毁JVM进程&lt;/span&gt;
&lt;span&gt;    LEAVE();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LEAVE 是 C 语言里面的一个宏定义，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; LEAVE() 
    &lt;span&gt;do&lt;/span&gt;&lt;span&gt; { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((*vm)-&amp;gt;DetachCurrentThread(vm) !=&lt;span&gt; JNI_OK) { 
            JLI_ReportErrorMessage(JVM_ERROR2); 
            ret &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
        } 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (JNI_TRUE) { 
            (&lt;/span&gt;*vm)-&amp;gt;&lt;span&gt;DestroyJavaVM(vm); 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret; 
        } 
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (JNI_FALSE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。&lt;/p&gt;
&lt;p&gt;在 Tomcat 的 NIO 实现 NioEndpoint 中会开启一组接受线程用来接受用户的链接请求和一组处理线程负责具体处理用户请求，那么这些线程是用户线程还是守护线程呢？下面我们看下 NioEndpoint 的 startInternal 方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startInternal() throws Exception {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
            running &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            paused &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            ...

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建处理线程&lt;/span&gt;
            pollers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller[getPollerThreadCount()];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;pollers.length; i++&lt;span&gt;) {
                pollers[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller();
                Thread pollerThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(pollers[i], getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-ClientPoller-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;i);
                pollerThread.setPriority(threadPriority);
                pollerThread.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明为守护线程&lt;/span&gt;
&lt;span&gt;                pollerThread.start();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动接受线程&lt;/span&gt;
&lt;span&gt;            startAcceptorThreads();
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startAcceptorThreads() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getAcceptorThreadCount();
        acceptors &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Acceptor[count];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;) {
            acceptors[i] &lt;/span&gt;=&lt;span&gt; createAcceptor();
            String threadName &lt;/span&gt;= getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Acceptor-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
            acceptors[i].setThreadName(threadName);
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(acceptors[i], threadName);
            t.setPriority(getAcceptorThreadPriority());
            t.setDaemon(getDaemon());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置是否为守护线程，默认为守护线程&lt;/span&gt;
&lt;span&gt;            t.start();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean daemon = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setDaemon(boolean b) { daemon =&lt;span&gt; b; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; boolean getDaemon() { &lt;span&gt;return&lt;/span&gt; daemon; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码也就是说默认情况下接受线程和处理线程都是守护线程，这意味着当 Tomact 收到 shutdown 命令后 Tomact 进程会马上消亡，而不会等处理线程处理完当前的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：如果你想在主线程结束后 JVM 进程马上结束，那么创建线程的时候可以设置线程为守护线程，否则如果希望主线程结束后子线程继续工作，等子线程结束后在让 JVM 进程结束那么就设置子线程为用户线程。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9324072.html</dc:identifier>
</item>
<item>
<title>oracle锁表查询，资源占用，连接会话，低效SQL等性能检查 - 孤城孤刀</title>
<link>http://www.cnblogs.com/xyhero/p/283d2f21cca31a6af04bf56ed303f4c9.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyhero/p/283d2f21cca31a6af04bf56ed303f4c9.html</guid>
<description>&lt;p&gt;查找使用CPU多的用户session&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; a.sid,
       spid,
       status,
       substr(a.program, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;) prog,
       a.terminal,
       osuser,
       value &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;60&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt; value
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$session a, v$process b, v$sesstat c
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.statistic# &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; c.sid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.sid
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.paddr &lt;span&gt;=&lt;/span&gt;&lt;span&gt; b.addr
 &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; value &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oracle数据库查询效率低的SQL&lt;/p&gt;
&lt;p&gt;检查低效率的语句&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; executions,
       disk_reads,
       buffer_gets,
       &lt;/span&gt;&lt;span&gt;round&lt;/span&gt;((buffer_gets &lt;span&gt;-&lt;/span&gt; disk_reads) &lt;span&gt;/&lt;/span&gt; buffer_gets, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) hit_radio,
       &lt;/span&gt;&lt;span&gt;round&lt;/span&gt;(disk_reads &lt;span&gt;/&lt;/span&gt; executions, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) reads_per_run,
       sql_text
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; executions &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;1表示执行次数超过一次&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; buffer_gets &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; (buffer_gets &lt;span&gt;-&lt;/span&gt; disk_reads) &lt;span&gt;/&lt;/span&gt; buffer_gets &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0.8&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; disk_reads是读硬盘的数量&lt;/span&gt;
 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查执行时间7月1日以后超过30秒的语句&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
  &lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$session_longops s
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; s.start_time &lt;span&gt;&amp;gt;&lt;/span&gt; to_date(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy-mm-dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; s.LAST_UPDATE_TIME &lt;span&gt;-&lt;/span&gt; s.START_TIME &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1440&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
   &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; start_time;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查目前打开的游标情况&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; sql_text, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; v$open_cursor &lt;span&gt;where&lt;/span&gt; &lt;span&gt;user_name&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sql_text &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;desc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查指定时间的语句情况&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; v$sql s &lt;span&gt;where&lt;/span&gt; first_load_time &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-01/00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; s.EXECUTIONS &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;监控当前数据库谁在运行什么SQL语句&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; osuser, username, sql_text &lt;span&gt;from&lt;/span&gt; v$session a, v$sqltext b &lt;span&gt;where&lt;/span&gt; a.sql_address &lt;span&gt;=&lt;/span&gt; b.address &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; address, piece;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等待最多的sql&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; a.program,
      a.session_id,
       a.&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;,
       d.username,
       s.sql_text,
       &lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(a.wait_time &lt;span&gt;+&lt;/span&gt;&lt;span&gt; a.time_waited) total_wait_time
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$active_session_history a, v$sqlarea s, dba_users d
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.sample_time &lt;span&gt;between&lt;/span&gt; sysdate &lt;span&gt;-&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2880&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;&lt;span&gt; sysdate
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.sql_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.sql_id
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.&lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; d.&lt;span&gt;user_id&lt;/span&gt;
 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; a.program, a.session_id, a.&lt;span&gt;user_id&lt;/span&gt;, s.sql_text, d.username;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看消耗资源最多的sql&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; hash_value, executions, buffer_gets, disk_reads, parse_calls
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; buffer_gets &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;10000000&lt;/span&gt;
    &lt;span&gt;or&lt;/span&gt; disk_reads &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;
 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; buffer_gets &lt;span&gt;+&lt;/span&gt; &lt;span&gt;100&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; disk_reads &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最占用资源的查询&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; b.username username,
       a.disk_reads reads,
       a.executions &lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;,
       a.disk_reads &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; decode(a.executions, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, a.executions) rds_exec_ratio,
       a.sql_text Statement
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea a, dba_users b
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.parsing_user_id &lt;span&gt;=&lt;/span&gt; b.&lt;span&gt;user_id&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; a.disk_reads &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;100000&lt;/span&gt;
 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; a.disk_reads &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看某条sql语句的资源消耗&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; hash_value, buffer_gets, disk_reads, executions, parse_calls
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; hash_value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;228801498&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; address &lt;span&gt;=&lt;/span&gt; hextoraw(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cbd8e4b0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询会话执行的实际SQL&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; a.sid, a.username, s.sql_text
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$session a, v$sqltext s
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.sql_address &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.address
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.sql_hash_value &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.hash_value
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.status &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACTIVE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; a.username, a.sid, s.piece;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;占用最多内存的sql语句&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; b.username username,
       a.buffer_gets gets,
       a.executions &lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;,
       a.buffer_gets &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; decode(a.executions, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, a.executions) rds_exec_ratio,
       a.sql_text Statement
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea a, dba_users b
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.parsing_user_id &lt;span&gt;=&lt;/span&gt; b.&lt;span&gt;user_id&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; a.buffer_gets &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;100000&lt;/span&gt;
 &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; a.buffer_gets &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用频率最高的5个查询语句&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; sql_text, executions
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt;&lt;span&gt; sql_text,
               executions,
               rank() &lt;/span&gt;&lt;span&gt;over&lt;/span&gt;(&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; executions &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;) exec_rank
          &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sql)
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; exec_rank &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;消耗磁盘读取最多的sql&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; disk_reads, sql_text
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt;&lt;span&gt; sql_text,
               disk_reads,
               dense_rank() &lt;/span&gt;&lt;span&gt;over&lt;/span&gt;(&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; disk_reads &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;) disk_reads_rank
          &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sql)
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; disk_reads_rank &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要大量缓冲读取（逻辑读）操作的查询&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; buffer_gets, sql_text
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt;&lt;span&gt; sql_text,
               buffer_gets,
               dense_rank() &lt;/span&gt;&lt;span&gt;over&lt;/span&gt;(&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; buffer_gets &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;) buffer_gets_rank
          &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sql)
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; buffer_gets_rank &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oracle数据库查询当前连接会话数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; s.value, s.sid, a.username
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sesstat s, v$statname n, v$session a
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; n.statistic# &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.statistic#
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;session pga memory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; s.sid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.sid
 &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; s.value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询oracle用户名，机器名，锁表对象&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; l.session_id sid,
      s.serial#,
      l.locked_mode,
      l.oracle_username,
      l.os_user_name,
      s.machine,
      s.terminal,
      o.&lt;/span&gt;&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;,
      s.logon_time
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$locked_object l, all_objects o, v$session s
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; l.&lt;span&gt;object_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; o.&lt;span&gt;object_id&lt;/span&gt;
  &lt;span&gt;and&lt;/span&gt; l.session_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.sid
       &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sid, s.serial#;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪个sql语句导致锁表的&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; l.session_id sid,
      s.serial#,
      l.locked_mode,
      l.oracle_username,
      s.&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;#,
      l.os_user_name,
      s.machine,
      s.terminal,
      a.sql_text,
      a.action
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$sqlarea a, v$session s, v$locked_object l
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; l.session_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.sid
  &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; s.prev_sql_addr &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.address
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sid, s.serial#;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; b.sql_text
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$session a, v$sql b
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.sid &lt;span&gt;=&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;session_id&lt;/span&gt;
         &lt;span&gt;and&lt;/span&gt; a.SQL_ADDRESS &lt;span&gt;=&lt;/span&gt; b.ADDRESS(&lt;span&gt;+&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;锁表查询&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$locked_object;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; v$locked_object;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪个表被锁&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; b.owner, b.&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;, a.session_id, a.locked_mode
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$locked_object a, dba_objects b
       &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; b.&lt;span&gt;object_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; a.&lt;span&gt;object_id&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪个session引起的&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; b.username, b.sid, b.serial#, b.logon_time
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$locked_object a, v$session b
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.session_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; b.sid
       &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; b.logon_time;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;杀掉进程&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;3028:SID,15898:SERIAL#&lt;/span&gt;
&lt;span&gt;alter&lt;/span&gt; system &lt;span&gt;kill&lt;/span&gt; session &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3028,15898&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示正在等待锁的所有会话&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_waiters;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询表空间使用情况&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;upper&lt;/span&gt;&lt;span&gt;(f.tablespace_name) &quot;表空间名&quot;,
        d.tot_grootte_mb &quot;表空间大小(m)&quot;,
        d.tot_grootte_mb &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; f.total_bytes &quot;已使用空间(m)&quot;,
        to_char(&lt;/span&gt;&lt;span&gt;round&lt;/span&gt;((d.tot_grootte_mb &lt;span&gt;-&lt;/span&gt; f.total_bytes) &lt;span&gt;/&lt;/span&gt;d.tot_grootte_mb &lt;span&gt;*&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;990.99&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;||&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; &quot;使用比&quot;,
        f.total_bytes &quot;空闲空间(m)&quot;,
        f.max_bytes &quot;最大块(m)&quot;
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt;&lt;span&gt; tablespace_name,
              &lt;/span&gt;&lt;span&gt;round&lt;/span&gt;(&lt;span&gt;sum&lt;/span&gt;(bytes) &lt;span&gt;/&lt;/span&gt; (&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) total_bytes,
              &lt;/span&gt;&lt;span&gt;round&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;(bytes) &lt;span&gt;/&lt;/span&gt; (&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) max_bytes
         &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dba_free_space
        &lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; tablespace_name) f,
         (&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; dd.tablespace_name,
                 &lt;/span&gt;&lt;span&gt;round&lt;/span&gt;(&lt;span&gt;sum&lt;/span&gt;(dd.bytes) &lt;span&gt;/&lt;/span&gt; (&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) tot_grootte_mb
            &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dba_data_files dd
           &lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; dd.tablespace_name) d
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; d.tablespace_name &lt;span&gt;=&lt;/span&gt;&lt;span&gt; f.tablespace_name
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看空间占用多的表或索引，&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;
    segment_name 对象,
    segment_type 对象类型,
    bytes &lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt;&lt;span&gt; MB,
    tablespace_name 表空间名称
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
    user_segments
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt;
    bytes &lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：查看ins用户下的表的空间要使用ins用户登录数据库&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;表空间不足如何处理？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、查看表在哪个表空间&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; tablespace_name,table_name &lt;span&gt;from&lt;/span&gt; user_tables &lt;span&gt;where&lt;/span&gt; table_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TB_BASE_USER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、获取用户的默认表空间&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; username,default_tablespace &lt;span&gt;from&lt;/span&gt; dba_users &lt;span&gt;where&lt;/span&gt; username&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCOTT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、找出该表空间对应的数据文件及路径&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_data_files t &lt;span&gt;where&lt;/span&gt; t.tablespace_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;USERS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、查看表空间使用情况&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;5、方案一：扩展表空间&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\ORACLE\PRODUCT\11.2.0\DBHOME_1\DATABASE\TEST_SPACE.DBF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; resize 500M
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;自动增长&lt;/span&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\ORACLE\PRODUCT\11.2.0\DBHOME_1\DATABASE\TEST_SPACE.DBF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; autoextend onnext 50m maxsize 500m;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;增加数据文件&lt;/span&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace tablespace_name &lt;span&gt;add&lt;/span&gt; datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\ORACLE\PRODUCT\11.2.0\DBHOME_1\DATABASE\TEST_SPACE.DBF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  size 500M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、方案二：移动至其他表空间&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; ins.app_iops_dev_daily_nj move tablespace TBS_OSSMOB_ANDROID;
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; index_name rebuild tablespace tablespace_name;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;如果有索引的话必须重建索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表空间尽量让free百分比保持在10%以上，如果低于10%就增加datafile或者resize datafile，一般数据文件不要超过2G&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;等待最多的用户&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;
    s.sid,
    s.username,
    &lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(a.wait_time &lt;span&gt;+&lt;/span&gt;&lt;span&gt; a.time_waited) total_wait_time
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
    v$active_session_history a,
    v$session s
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;span&gt;
    a.sample_time &lt;/span&gt;&lt;span&gt;BETWEEN&lt;/span&gt; sysdate &lt;span&gt;-&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2880&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt;&lt;span&gt; sysdate
&lt;/span&gt;&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt;
    s.sid,
    s.username
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt;
    total_wait_time &lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具有最高等待的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; o.owner,
       o.&lt;/span&gt;&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;,
       o.object_type,
       a.event,
       &lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(a.wait_time &lt;span&gt;+&lt;/span&gt;&lt;span&gt; a.time_waited) total_wait_time
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$active_session_history a, dba_objects o
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.sample_time &lt;span&gt;between&lt;/span&gt; sysdate &lt;span&gt;-&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2880&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;&lt;span&gt; sysdate
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.current_obj# &lt;span&gt;=&lt;/span&gt; o.&lt;span&gt;object_id&lt;/span&gt;
 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o.owner, o.&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;, o.object_type, a.event
 &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; total_wait_time &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; a.session_id,
       s.osuser,
       s.machine,
       s.program,
       o.owner,
       o.&lt;/span&gt;&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;,
       o.object_type,
       a.event,
       &lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(a.wait_time &lt;span&gt;+&lt;/span&gt;&lt;span&gt; a.time_waited) total_wait_time
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; v$active_session_history a, dba_objects o, v$session s
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; a.sample_time &lt;span&gt;between&lt;/span&gt; sysdate &lt;span&gt;-&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2880&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;&lt;span&gt; sysdate
   &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; a.current_obj# &lt;span&gt;=&lt;/span&gt; o.&lt;span&gt;object_id&lt;/span&gt;
   &lt;span&gt;and&lt;/span&gt; a.session_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.sid
 &lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; o.owner,
          o.&lt;/span&gt;&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;,
          o.object_type,
          a.event,
          a.session_id,
          s.program,
          s.machine,
          s.osuser
 &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; total_wait_time &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oracle数据库查看各用户资源占用的SQL语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;
    se.sid,
    ses.username,
    ses.osuser,
    n. NAME,
    se.VALUE
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
    v$statname n,
    v$sesstat se,
    v$session ses
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;span&gt;
    n.statistic # &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; se.statistic#
&lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; se.sid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; ses.sid
&lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; ses.username &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; n. NAME &lt;span&gt;IN&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CPU used by this session&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db block gets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;consistent gets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;physical reads&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;free buffer requested&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table scans (long tables)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table scan rows gotten&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sorts (memory)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sorts (disk)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sorts (rows)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;session uga memory max&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;session pga memory max&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt;
    sid,
    n.statistic #;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Jul 2018 15:20:00 +0000</pubDate>
<dc:creator>孤城孤刀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyhero/p/283d2f21cca31a6af04bf56ed303f4c9.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第四门课（3）目标检测（Object detection） - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9326637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9326637.html</guid>
<description>&lt;h2&gt;3.1目标定位&lt;/h2&gt;
&lt;p&gt;（1）案例1：在构建自动驾驶时，需要定位出照片中的行人、汽车、摩托车和背景，即四个类别。可以设置这样的输出，首先第一个元素p&lt;sub&gt;c&lt;/sub&gt;=1表示有要定位的物体，那么用另外四个输出元素表示定位框的中心坐标和宽高，再用3个输出元素one-hot表示是三个类别中的哪一类。当第一个元素p&lt;sub&gt;c&lt;/sub&gt;=0时表示是背景，然后就不需要考虑其他输出了，如下图所示（&lt;strong&gt;需要注意的是是根据图片的标签y来决定使用几个元素的&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717201605500-1345646596.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）损失函数：上图中左下角是使用了平方误差损失函数这是为了方便解释方便而使用的。实际使用中p&lt;sub&gt;c&lt;/sub&gt;使用逻辑回归，c&lt;sub&gt;1&lt;/sub&gt;,c&lt;sub&gt;2&lt;/sub&gt;,c&lt;sub&gt;3&lt;/sub&gt;是用softmax激活然后然后用对数损失函数，位置信息是使用平方误差损失函数，然后将这些损失函数相加起来得到最终的代价函数。当标签y=0时，只考虑p&lt;sub&gt;c&lt;/sub&gt;即可。&lt;/p&gt;
&lt;h2&gt;3.2特征点检测&lt;/h2&gt;
&lt;p&gt;（1）特征点检测就是第一个单元输出1，表示有这个对象（如人脸），然后如果在人脸上定义了64个特征点（如下图所示），每个特征点用（x,y）表示，那么网络将会有1+2*68=129个单元输出。需要注意的一点是在标注样本时，所有标签在所有图片中务必保持一致，比如说，第5个特征点表示左眼的外眼角，那么所有图片的第五个特征点都应该是这个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717203358791-888805087.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3目标检测&lt;/h2&gt;
&lt;p&gt;（1）案例是检测图片中的汽车，首先是有裁剪合适的照片（裁剪合适是指照片中如果有汽车那么汽车将占满整张图），进行训练一个可以分类汽车的网络，即输出是否有汽车。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204358475-456221849.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）滑动窗口目标检测是用一个滑动窗口从图片的最左上角从做到右（设定一定步长）从上到下去滑动，分别将窗口内的图片裁剪下来送入到之间训练好的网络中，判断有无汽车，然后改变窗口大小，以及步长等，重复上面步骤，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204756738-430346787.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204809273-1527405459.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）滑动窗口的问题就是计算量非常的大，因为要保证精确度化不能用太大的步长，这样滑动窗口很多，而且很多地方是属于重复计算了。&lt;/p&gt;
&lt;h2&gt;3.4卷积的滑动窗口实现&lt;/h2&gt;
&lt;p&gt;（1）将全连接层转换为卷积层，如下图所示5*5*16与400个单元进行全连接可以转换为用400个5*5*16的卷积核来卷积5*5*16，这样每一个卷积核其实就相当与都是全连接的结果，唯一的区别就是之前全连接输出是400个单元，现在输出是1*1*400，维度不同，下一层全连接转卷积同样操作，最后一层原来是输出4个单元，现在变成了1*1*4，维度不同，仅此而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717211235664-1533712577.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）上一节中一个一个滑动框输入网络中，有许多计算是重叠的，即多次计算，所以可以将原图直接输入到网络中，这样避免了重复计算。之所以将前面的全连接层变成卷积层，是因为只有都是卷积层的时候才可以输入任意尺寸的图片，更具体的说是参数不随图片尺寸变化，而全连接层参数w时固定的意味着图片输入尺寸要固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717211755244-1659188765.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）该方法还存在的一个问题就是边界框位置不够准确。&lt;/p&gt;
&lt;h2&gt;3.5Bounding Box预测（YOLO算法）&lt;/h2&gt;
&lt;p&gt;（1）将一张图3*3共9个单元（在论文中是分成19*19，论文默认前提是一个单元里只有一个对象），每个单元都有上面提到的1+4+3=8个输出（还是用上面无人驾驶的例子，3个类别加一个背景）所以整个网络输出为3*3*8。换言之就是输入一张图片，然后网络最终输出的维度为3*3*8，3*3是指有图片分成这么多格子，然后每个格子需要用到8个参数。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717214347020-1339547375.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）YOLO中将对象（即识别的物体）的中心点落在哪一个网格中就，它就属于哪个网格，一个对象只能属于一个网络，即使这个目标可能横跨了好多个网格。&lt;/p&gt;
&lt;p&gt;（3）b&lt;sub&gt;x&lt;/sub&gt;,b&lt;sub&gt;y&lt;/sub&gt;,b&lt;sub&gt;w&lt;/sub&gt;,b&lt;sub&gt;h&lt;/sub&gt;一种表示方法：将网格（注意不是整张图）的左上角记做（0,0），网格右下角为（1,1），所以bx,by的值都在0到1之间，反证法如果超过1说明它不应该划分到这个网格中。bw,bh也是相对于网格的比例，所以其值可能大于1.如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717215009320-402557521.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.6交并比&lt;/h2&gt;
&lt;p&gt;（1）IoU=（A∩B）/（A∪B），一般将交并比的值大于0.5看成是检测正确的，当然这个值可以根据实际情况来定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717215815060-417923554.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.7非极大值抑制&lt;/h2&gt;
&lt;p&gt;（1）需要理解的一点是，我们做的样本标签中一个对象只会属于一个网格（中心点落在该网格上），但是当我们开始对网络进行预测时，很多网格都会觉得这个对象是属于自己的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717221659125-117097115.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）用只有一个类别（如汽车）来说明非极大值抑制的过程。首先将预测到有汽车的网格中概率小于阈值的都去掉（比如说0.6），然后将剩下预测到有汽车的都进行排序，去其中可能性最大的，它将成为一个预测结果，然后与它的交并比大于某个阈值的都去掉，然后再在剩下中取最大可能性的，重复以上步骤，直到处理完全部。&lt;/p&gt;
&lt;p&gt;如下图所示（下图中的pc其实是之前的pc乘上类别概率c1、c2或c3）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717222501302-1103494451.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）当有多个类别时，按类别分开进行非极大值抑制。&lt;/p&gt;
&lt;h2&gt;3.8Anchor Box&lt;/h2&gt;
&lt;p&gt;（1）上面都是假设一个网格里面只有一个对象，如果有两个对象，如下图所示，人和汽车的中心点几乎重合，这时可以提出一种新概念，即在一个网格框中设置多个不同形状的anchor box,比如说两个，一个瘦高的，一个挨胖的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717224814407-861633352.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）其实实质就是每个网格的第三维度增加输出，把之前的3*3*8变成3*3*16（如下图所示），有时候会变成四个维度如3*3*2*8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717224435891-993557660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）有一点需要注意的是，在给样本打标签时要做到统一，比如说瘦高型的，那么将对应到前八个输出，如果是矮胖型的对应到后面的八个输出。&lt;/p&gt;
&lt;p&gt;（4）当超过两个对象在同一个网格（其实概率特别小），暂时没有什么好的办法；如果两个对象都是与同一种类型（比如说瘦高型的），也没什么特别好的办法。&lt;/p&gt;
&lt;h2&gt;3.9YOLO算法&lt;/h2&gt;
&lt;p&gt;（1）将上面提到的各个模块组合在一起其实就是YOLO算法了，每个网格多个anchor box，最后再做非极大值抑制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717225956821-219785882.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.10候选区域（Region proposals）&lt;/h2&gt;
&lt;p&gt;（1）RCNN：首先使用传统图像分割的方法，对图像进行分割，然后提取出2000个可能有对象的候选框，&lt;strong&gt;这样相对于最开始提到的滑动框的方式减少了非常多的框&lt;/strong&gt;，&lt;strong&gt;其他二者其实是一回事，&lt;/strong&gt;然后送入网络，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717230857216-1636266985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）Fast RCNN：即先将整个图像进行卷积，然后再将候选框映射到卷积之后的输出做分类，其实就是上面提到的卷积整幅图减少重复计算。&lt;/p&gt;
&lt;p&gt;（3）Faster RCNN:由于使用传统的图像分割选出候选框需要非常多的时间，所以使用卷积神经网络来选出候选框。三个算法特点如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717231439439-457032727.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:15:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9326637.html</dc:identifier>
</item>
<item>
<title>动手做webserver的核心之http解析 - yswenli</title>
<link>http://www.cnblogs.com/yswenli/p/9326453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yswenli/p/9326453.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;        webserver往小里说核心功能就是socket管理、url处理、http协议处理、业务dll管理等；下面简介绍一下http协议：超文本传输协议(HTTP)是一种通信协议，当时就是为web传输设计的一个基于tcp的协议；基于这个字面上理解，可以简单的点说就是用tcp来传输文本、数据的一种编解码格式。传输协议一般比如说定个长度+内容，或者以回车符作为结尾等方式。http协议是文本传输协议，所以也是采用回车符来结尾的方式来实现编码传输解析的； 这里使用分析工具来简单分析一下http的基本格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201807/542396-20180717205108960-570740782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      从上图可以看出http的基本格式一般大体为成header和body,header的第一行是固定的status line，header与body之间用回车符+空行+回车符来分隔的&lt;/p&gt;
&lt;h2&gt;GET&lt;/h2&gt;
&lt;p&gt;      webserver一般收到get请求如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
1  GET /yswenli/p/8858669.html HTTP/1.1 
2 &lt;span&gt; Host www.cnblogs.com
3  User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36  Accept image/webp,image/*,*/*;q=0.8 
4  Referer https://www.cnblogs.com/yswenli/p/8858669.html 
5  Accept-&lt;span&gt;Encoding gzip, deflate, sdch  
6  Accept-Language zh-CN,zh;q=0.8&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      也就是说如果发起了一个get请求的时候，webserver只是收到一个一个http header，直接全部收取后解析就行&lt;/p&gt;
&lt;h2&gt;POST&lt;/h2&gt;
&lt;p&gt;       如果是一个post请求呢？查看html相关内容，可以看post有很多方式，总体上分成三种，一种是默认的application/x-www-form-urlencoded：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.example.com HTTP/1.1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Content-Type: application/x-www-form-urlencoded;charset=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; title=test&amp;amp;sub%5B%5D=&lt;span&gt;1&lt;/span&gt;&amp;amp;sub%5B%5D=&lt;span&gt;2&lt;/span&gt;&amp;amp;sub%5B%5D=&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这种格式就是带有header和body两部分内容，解析的时候可以先按get收头部，然后再取body，body里面的参数取值是先urldecode再htmldecode就可以了。&lt;/p&gt;
&lt;p&gt;      第二种就是json、xml、plaine等：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.example.com HTTP/1.1 &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Content-Type: application/json;charset=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这种和上面类似，不过在取body的时候直接读就行~&lt;/p&gt;
&lt;p&gt;      还有第三种multipart/form-data，这种模式格式比较复杂，它支持多键值对、多文件的方式，使用特定的boundary来分隔body&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.example.com HTTP/1.1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Content-Type:multipart/form-data; boundary=----&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; ------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; Content-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;yswenli
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; ------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Content-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; filename=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chrome.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; Content-Type: image/&lt;span&gt;png
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;PNG ... content of chrome.png ...&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; ------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Content-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;title
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; ------&lt;span&gt;WebKitFormBoundaryrGKCBY7qhFd3TrwA
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Content-Disposition: form-data; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; filename=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chrome2.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
19 Content-Type: image/&lt;span&gt;png
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;PNG ... content of chrome.png ...
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; ------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这种格式也是带有header和body两部分内容，解析的时候先按get收头部，然后再取body，body里面的内容先按boundry进行分割，然后再根据content-type进行判断取出文件内容。&lt;/p&gt;
&lt;h2&gt;TCP转HTTP&lt;/h2&gt;
&lt;p&gt;      即然拿到相关数据格式，并研究分析了http的编码格式，下面就可以开始解码了。首先使用一个data来接收socket的tcp数据包，然后统一分析http包的header，直到截取到\r\n+&quot;&quot;+\r\n为止。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (MemoryStream ms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream(buffer))
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 ms.Position = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt; (SAEA.Common.StreamReader streamReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAEA.Common.StreamReader(ms))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; str =&lt;span&gt; streamReader.ReadLine();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                             &lt;span&gt;this&lt;/span&gt;.HeaderStr =&lt;span&gt; _stringBuilder.ToString();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                            _stringBuilder.Clear();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.HeaderStr))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                            _stringBuilder.AppendLine(str);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      上面使用了一个自定义的StreamReader，原因是自带的那个无法定位Stream的Position；若已成功解析出http的header，接下来就可以根据header来判断提交的方式是get还是post等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 解析http请求的数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;onUnpackage&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetRequest(&lt;span&gt;byte&lt;/span&gt;[] data, Action&amp;lt;RequestDataReader&amp;gt;&lt;span&gt; onUnpackage)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_locker)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                _cache.AddRange(data);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; buffer =&lt;span&gt; _cache.ToArray();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAnalysis)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     isAnalysis =&lt;span&gt; _httpStringReader.Analysis(buffer);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAnalysis)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;post需要处理body&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (_httpStringReader.Method ==&lt;span&gt; ConstString.POSTStr)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; contentLen =&lt;span&gt; _httpStringReader.ContentLength;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; positon =&lt;span&gt; _httpStringReader.Position;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; totlalLen = contentLen +&lt;span&gt; positon;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (buffer.Length ==&lt;span&gt; totlalLen)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            _httpStringReader.AnalysisBody(buffer);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                            onUnpackage.Invoke(_httpStringReader);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             Array.Clear(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                             buffer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                            _cache.Clear();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             _cache = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        onUnpackage.Invoke(_httpStringReader);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         Array.Clear(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         buffer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                        _cache.Clear();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         _cache = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      已解析header的话，就可以根据上面说的相关post的http数据格式来解析body。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ContentType)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ConstString.FORMENCTYPE1:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.Forms = GetRequestForms(Encoding.UTF8.GetString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Body));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ConstString.FORMENCTYPE2:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                         &lt;span&gt;using&lt;/span&gt; (MemoryStream ms = &lt;span&gt;new&lt;/span&gt; MemoryStream(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Body))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                             ms.Position = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                             &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAEA.Common.StreamReader(ms))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                                 StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                                 &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                     str =&lt;span&gt; sr.ReadLine();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                                    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                                        sb.AppendLine(str);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; (str.IndexOf(CT) &amp;gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                                        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                                             &lt;span&gt;var&lt;/span&gt; filePart =&lt;span&gt; GetRequestFormsWithMultiPart(sb.ToString());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;                                             &lt;span&gt;if&lt;/span&gt; (filePart != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                                            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                                                sr.ReadLine();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                                                 filePart.Data = sr.ReadData(sr.Position, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Boundary);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                                                 &lt;span&gt;if&lt;/span&gt; (filePart.Data != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                                                {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                                     filePart.Data = filePart.Data.Take(filePart.Data.Length - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;).ToArray();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                                                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.PostFiles == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                                     &lt;span&gt;this&lt;/span&gt;.PostFiles = &lt;span&gt;new&lt;/span&gt; List&amp;lt;FilePart&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PostFiles.Add(filePart);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                                            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                            sb.Clear();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                            sr.ReadLine();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                                        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                                    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                                 &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.Json = Encoding.UTF8.GetString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Body);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      至此，http的相关解析就完成了，详细的代码可参见：&lt;/p&gt;
&lt;p&gt;      1.&lt;a title=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/Net/HCoder.cs&quot; href=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/Net/HCoder.cs&quot; target=&quot;_blank&quot;&gt;HCode&lt;/a&gt;主要功能收取tcp包、 &lt;/p&gt;
&lt;p&gt;      2.&lt;a title=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/Base/RequestDataReader.cs&quot; href=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/Base/RequestDataReader.cs&quot; target=&quot;_blank&quot;&gt;RequestDataReader&lt;/a&gt;主要功能是收到的tcp包近http协议转成webrequest、&lt;/p&gt;
&lt;p&gt;      3.&lt;a title=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/HttpRequest.cs&quot; href=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/HttpRequest.cs&quot; target=&quot;_blank&quot;&gt;HttpRequest&lt;/a&gt;主要功能是将转换的数据进行model赋值、&lt;/p&gt;
&lt;p&gt;      4.&lt;a title=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/HttpContext.cs&quot; href=&quot;https://github.com/yswenli/SAEA/blob/master/Src/SAEA.WebAPI/Http/HttpContext.cs&quot; target=&quot;_blank&quot;&gt;HttpContext&lt;/a&gt;主要功能是映射到处理业务并返回http数据&lt;/p&gt;

&lt;p&gt;转载请标明本文来源：&lt;a title=&quot;https://www.cnblogs.com/yswenli/p/9326453.html&quot; href=&quot;https://www.cnblogs.com/yswenli/p/9326453.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yswenli/p/9326453.html&lt;/a&gt;&lt;br/&gt;更多内容欢迎star/fork作者的github：&lt;a href=&quot;https://github.com/yswenli/SAEA&quot; target=&quot;_blank&quot;&gt;https://github.com/yswenli/SAEA&lt;/a&gt;&lt;br/&gt;如果发现本文有什么问题和任何建议，也随时欢迎交流~&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 14:44:00 +0000</pubDate>
<dc:creator>yswenli</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yswenli/p/9326453.html</dc:identifier>
</item>
<item>
<title>机器学习——超参数搜索 - molearner</title>
<link>http://www.cnblogs.com/wkslearner/p/9302044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkslearner/p/9302044.html</guid>
<description>&lt;h3 id=&quot;基础概念&quot;&gt;基础概念&lt;/h3&gt;
&lt;p&gt;超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，在机器学习过程中需要对超参数进行优化，给学习器选择一组最优超参数，以提高学习的性能和效果。比如，树的数量或树的深度，学习率（多种模式）以及k均值聚类中的簇数等都是超参数。&lt;/p&gt;
&lt;p&gt;与超参数区别的概念是参数，它是模型训练过程中学习到的一部分，比如回归系数，神经网络权重等。简单的描述参数是模型训练获得的，超参数是人工配置参数（本质上是参数的参数，每次改变超参数，模型都要重新训练）。&lt;/p&gt;

&lt;h3 id=&quot;超参数调优&quot;&gt;超参数调优&lt;/h3&gt;
&lt;p&gt;在模型训练过程中的参数最优化，一般都是对参数的可能值进行有效搜索，然后用评价函数选取出最优参数，比如梯度下降法。&lt;/p&gt;
&lt;p&gt;同理，人工的超参数选择过程，我们也可以采取类似参数搜索的办法，来提高效率，如果进行人工试错的方式，会非常浪费时间。&lt;/p&gt;
&lt;p&gt;超参数搜索过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将数据集分为训练集，验证集及测试集。&lt;/li&gt;
&lt;li&gt;选择模型性能评价指标&lt;/li&gt;
&lt;li&gt;用训练集对模型进行训练&lt;/li&gt;
&lt;li&gt;在验证集上对模型进行参数进行搜索，用性能指标评价参数好坏&lt;/li&gt;
&lt;li&gt;选出最优参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常见超参数搜索算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网格搜索&lt;/li&gt;
&lt;li&gt;随机搜索&lt;/li&gt;
&lt;li&gt;启发式搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;网格搜索&quot;&gt;网格搜索&lt;/h3&gt;
&lt;p&gt;网格搜索是在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果（暴力搜索）。&lt;/p&gt;
&lt;p&gt;原理：在一定的区间内，通过循环遍历，尝试每一种可能性，并计算其约束函数和目标函数的值，对满足约束条件的点，逐个比较其目标函数的值，将坏的点抛弃，保留好的点，最后便得到最优解的近似解。&lt;/p&gt;
&lt;p&gt;为了评价每次选出的参数的好坏，我们需要选择评价指标，评价指标可以根据自己的需要选择accuracy、f1-score、f-beta、percision、recall等。&lt;/p&gt;
&lt;p&gt;同时，为了避免初始数据的划分对结果的影响，我们需要采用交叉验证的方式来减少偶然性，一般情况下网格搜索需要和交叉验证相结合使用。&lt;/p&gt;
&lt;p&gt;python的sklearn包中网格搜索函数GridSearchCV：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GridSearchCV(
estimator,param_grid, scoring=None, fit_params=None, n_jobs=1, iid=True, 
refit=True,cv=None, verbose=0, pre_dispatch='2*n_jobs', 
error_score='raise',return_train_score=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;estimator：所使用的分类器&lt;/li&gt;
&lt;li&gt;param_grid：值为字典或者列表，需要最优化的参数的取值范围，如paramters = {'n_estimators':range(10,100,10)}。&lt;/li&gt;
&lt;li&gt;scoring :准确度评价指标，默认None,这时需要使用score函数；或者如scoring='roc_auc'。&lt;/li&gt;
&lt;li&gt;fit_params:字典类型数据，主要用于给fit方法传递参数。&lt;/li&gt;
&lt;li&gt;n_jobs: 并行数，int：个数,-1：跟CPU核数一致, 1:默认值。&lt;/li&gt;
&lt;li&gt;pre_dispatch：指定总共分发的并行任务数。当n_jobs大于1时，数据将在每个运行点进行复制，这可能导致OOM，而设置pre_dispatch参数，则可以预先划分总共的job数量，使数据最多被复制pre_dispatch次。&lt;/li&gt;
&lt;li&gt;iid:默认True,为True时，默认为各个样本fold概率分布一致，误差估计为所有样本之和，而非各个fold的平均。&lt;/li&gt;
&lt;li&gt;cv :交叉验证参数，默认None，使用三折交叉验证。指定fold数量，默认为3，也可以是yield训练/测试数据的生成器。&lt;/li&gt;
&lt;li&gt;refit :默认为True,程序将会以交叉验证训练集得到的最佳参数，重新对所有可用的训练集与验证集进行训练，作为最终用于性能评估的最佳模型参数。即在搜索参数结束后，用最佳参数结果再次fit一遍全部数据集。&lt;/li&gt;
&lt;li&gt;verbose：日志冗长度，int：冗长度，0：不输出训练过程，1：偶尔输出，&amp;gt;1：对每个子模型都输出。&lt;/li&gt;
&lt;li&gt;error_score: 默认为raise，可选择参数numeric，在模型拟合过程中如果产生误差，在raise情况下，误差分数将会提高，如果选择numeric，则fitfailedwarning会提高。&lt;/li&gt;
&lt;li&gt;return_train_score:布尔类型数据，默认为Ture ,为False时交叉验证的结果不包含训练得分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;网格搜索python简单实现&quot;&gt;网格搜索python简单实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import pandas as pd
from sklearn import  datasets
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
from xgboost.sklearn import XGBClassifier

iris = datasets.load_iris()
parameters = {'n_estimators':range(100,150,10),'max_depth':range(3,5,1)}
xgc=XGBClassifier()
clf = GridSearchCV(xgc, parameters)
clf.fit(iris.data, iris.target)
cv_result = pd.DataFrame.from_dict(clf.cv_results_)

best_param=clf.best_params_
best_score=clf.best_score_

y_pred = clf.predict(iris.data)
print(classification_report(y_true=iris.target, y_pred=y_pred))&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;随机搜索&quot;&gt;随机搜索&lt;/h3&gt;
&lt;p&gt;随机搜索（random search）是利用随机数去求函数近似的最优解的方法，区别于网格搜索的暴力搜索方式。&lt;/p&gt;
&lt;p&gt;原理：在一定的区间内，不断随机地而不是有倾向性产生随机点，并计算其约束函数和目标函数的值，对满足约束条件的点，逐个比较其目标函数的值，将坏的点抛弃，保留好的点，最后便得到最优解的近似解。&lt;/p&gt;
&lt;p&gt;这种方法是建立在概率论的基础上，所取随机点越多，则得到最优解的概率也就越大。这种方法存在精度较差的问题，找到近似最优解的效率高于网格搜索。随机搜索一般用于粗选或普查。&lt;/p&gt;
&lt;p&gt;python的sklearn包中随机搜索函数RandomizedSearchCV：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RandomizedSearchCV(estimator, param_distributions, n_iter=10, scoring=None, 
fit_params=None, n_jobs=1, iid=True, refit=True, cv=None, verbose=0,
pre_dispatch=‘2*n_jobs’, random_state=None, error_score=’raise’)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;estimator：所使用的分类器&lt;/li&gt;
&lt;li&gt;param_distributions：值为字典或者列表，需要最优化的参数的取值范围，同时需要选择一种rvs方法来进行抽样，比如scipy.stats.distributions&lt;/li&gt;
&lt;li&gt;n_iter : 抽样参数，默认为10，具体的值选择需要根据模型的相应效果进行评估。&lt;/li&gt;
&lt;li&gt;scoring :准确度评价指标，默认None,这时需要使用score函数；或者如scoring='roc_auc'。&lt;/li&gt;
&lt;li&gt;fit_params:字典类型数据，主要用于给fit方法传递参数。&lt;/li&gt;
&lt;li&gt;n_jobs: 并行数，int：个数,-1：跟CPU核数一致, 1:默认值。&lt;/li&gt;
&lt;li&gt;pre_dispatch：指定总共分发的并行任务数。当n_jobs大于1时，数据将在每个运行点进行复制，这可能导致OOM，而设置pre_dispatch参数，则可以预先划分总共的job数量，使数据最多被复制pre_dispatch次。&lt;/li&gt;
&lt;li&gt;iid:默认True,为True时，默认为各个样本fold概率分布一致，误差估计为所有样本之和，而非各个fold的平均。&lt;/li&gt;
&lt;li&gt;cv :交叉验证参数，默认None，使用三折交叉验证。指定fold数量，默认为3，也可以是yield训练/测试数据的生成器。&lt;/li&gt;
&lt;li&gt;refit :默认为True,程序将会以交叉验证训练集得到的最佳参数，重新对所有可用的训练集与验证集进行训练，作为最终用于性能评估的最佳模型参数。即在搜索参数结束后，用最佳参数结果再次fit一遍全部数据集。&lt;/li&gt;
&lt;li&gt;verbose：日志冗长度，int：冗长度，0：不输出训练过程，1：偶尔输出，&amp;gt;1：对每个子模型都输出。&lt;/li&gt;
&lt;li&gt;random_state:随机种子，默认为None,int类型或者随机状态实例，伪随机数生成器状态用于从可能的值列表而不是scipy中随机抽样。统计分布。如果int，随机状态是随机数生成器所使用的种子;如果随机状态实例，随机状态是随机数生成器;如果没有，随机数生成器是np.random所使用的随机状态实例。&lt;/li&gt;
&lt;li&gt;error_score: 默认为raise，可选择参数numeric，在模型拟合过程中如果产生误差，在raise情况下，误差分数将会提高，如果选择numeric，则fitfailedwarning会提高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;随机搜索python简单实现&quot;&gt;随机搜索python简单实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import pandas as pd
from sklearn import  datasets
from sklearn.model_selection import GridSearchCV,RandomizedSearchCV
from sklearn.metrics import classification_report
from xgboost.sklearn import XGBClassifier

iris = datasets.load_iris()
parameters = {'n_estimators':range(100,150,10),'max_depth':range(3,5,1)}
xgc=XGBClassifier()
clf = RandomizedSearchCV(xgc, parameters,cv=5)
clf.fit(iris.data, iris.target)
cv_result = pd.DataFrame.from_dict(clf.cv_results_)

best_param=clf.best_params_
best_score=clf.best_score_

y_pred = clf.predict(iris.data)
print(classification_report(y_true=iris.target, y_pred=y_pred))&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;启发式搜索&quot;&gt;启发式搜索&lt;/h3&gt;
&lt;p&gt;启发式搜索(Heuristically Search)又称为有信息搜索(Informed Search)，它是利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。&lt;/p&gt;
&lt;p&gt;原理：在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。&lt;/p&gt;
&lt;p&gt;启发式搜索有模拟退火算法(SA)、遗传算法(GA)、列表搜索算法(ST)、进化规划(EP)、进化策略(ES)、蚁群算法(ACA)、人工神经网络(ANN)...等。&lt;/p&gt;
&lt;p&gt;启发式搜索非常多样化，而且在sklearn包中并没有现成的函数，如果有需要我们可以针对某一种启发式算法的实现过程进行了解，然后用python手动实现。&lt;/p&gt;
&lt;p&gt;这里我们着手对遗传算法的实现过程做些了解。&lt;/p&gt;

&lt;h4 id=&quot;遗传算法&quot;&gt;遗传算法&lt;/h4&gt;
&lt;p&gt;遗传算法（Genetic Algorithm）是一种通过模拟自然进化过程搜索最优解的方法，它的思想来自于进化论，生物种群具有自我进化的能力，能够不断适应环境，优势劣汰之后得到最优的种群个体。进化的行为主要有选择，遗传，变异，遗传算法希望能够通过将初始解空间进化到一个较好的解空间。&lt;/p&gt;
&lt;p&gt;原理：遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码，初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。&lt;/p&gt;
&lt;p&gt;遗传算法的实现步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化候选参数集，并编码为基因序列（初始化种群，一组参数编码为一个种群个体，共n个种群个体 ），即对参数进行编码，同时设定进化代数m。&lt;/li&gt;
&lt;li&gt;个体评估，计算各个种群个体的适应度（适应度描述了该个体对自然环境的适应能力，表征了其个体存活能力和生殖机会），用适应度函数表示。&lt;/li&gt;
&lt;li&gt;选择运算，选择是模拟自然选择，把优秀的个体选择出来（基于适应度），以进行后续的遗传和变异。&lt;/li&gt;
&lt;li&gt;交叉运算，交叉是模拟繁殖后代的基因重组。&lt;/li&gt;
&lt;li&gt;变异运算，变异是模拟基因突变。&lt;/li&gt;
&lt;li&gt;经过选择，交叉，变异，生产下一代群体，重复此过程，直到停止条件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的实现步骤可以知道，遗传算法包含以下几个主要部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基因编码&lt;/li&gt;
&lt;li&gt;适应度函数&lt;/li&gt;
&lt;li&gt;遗传算子，包含选择，交叉，变异&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了基本遗传算法的实现过程，后续就是对每个算法实现过程的细节寻找合适的方法进行处理。换到机器学习参数最优化的问题上，就是使用遗传算法搜索参数空间获得最优的模型性能评价指标的过程。&lt;/p&gt;
&lt;p&gt;启发式搜索先到这里，后续有时间可以尝试python代码实现参数最优化的过程。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 14:33:00 +0000</pubDate>
<dc:creator>molearner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkslearner/p/9302044.html</dc:identifier>
</item>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第十九课（递归函数、闭包） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9326393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9326393.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;每天坚持手写  一天一篇  决定坚持几年 全栈工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;　Python人工智能从入门到精通&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;装饰器 decorators&lt;/span&gt;&lt;/strong&gt;（专业提高篇）&lt;br/&gt;　　&lt;strong&gt;装饰器是一个函数&lt;/strong&gt; ，主要用来包装另一个函数或类&lt;br/&gt;　　装饰的目的是在 &lt;strong&gt;不改变函数&lt;/strong&gt;的的原名（或类名）的情况下&lt;br/&gt;　　&lt;strong&gt;改变对象的行为&lt;/strong&gt;&lt;br/&gt;函数装饰器&lt;br/&gt;　　函数装饰器指装饰器传入的是一个函数，返回的也是一个函数&lt;br/&gt;&lt;strong&gt;　　原理就是改变原变量绑定的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　语法：&lt;br/&gt;　　def 装饰器函数名（参数）：&lt;br/&gt;　　　　语句块&lt;br/&gt;　　　　return 函数对象&lt;/p&gt;
&lt;p&gt;      例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意函数装饰器的定义用调用&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mydeco(fn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fx():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=========这是myfunc调用之前==========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fn()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;---------这是myfunc调用之后----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fx


@mydeco
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myfunc():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myfunc被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; myfunc = mydeco(myfunc)  # 原理是改变原变量绑定的函数&lt;/span&gt;
&lt;span&gt;

myfunc()
myfunc()
myfunc()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意一个函数被两个装饰器先后顺序装饰&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; message_send(fn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fy(name, x):
        fn(name, x)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;办理了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;元的业务![工商银行]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fy


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----- 以下是小王写的装饰器函数用来进行权限验证----&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; privileged_check(fn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fx(name, x):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在检查权限.... 通过&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fn(name, x)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fx


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ------- 以下是老魏写的程序----------&lt;/span&gt;
&lt;span&gt;@privileged_check
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; save_money(name, x):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存钱&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;存钱:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; myfunc = mydeco(myfunc)&lt;/span&gt;
&lt;span&gt;@message_send
@privileged_check
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; withdraw(name, x):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;取钱:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -------以下是调用者小李写的程序&lt;/span&gt;
save_money(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小张&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 200&lt;span&gt;)
save_money(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小赵&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 500&lt;span&gt;)
withdraw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小杨&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 300)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数的文档字符串：&lt;br/&gt;　　函数内第一次未被赋值给任何变量的字符串是此函数的文档字符串&lt;br/&gt;def 函数名（参数列表）：&lt;br/&gt;　　函数文档字符串&lt;br/&gt;　　函数语句块&lt;br/&gt;　　help（函数变量） 查看函数信息&lt;br/&gt;　　fa.__doc__ 查看文档字符串&lt;br/&gt;函数定义语句（def 语句）的完整语法：&lt;br/&gt;　　&lt;strong&gt;[ @装饰器] &lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;[ @装饰器]&lt;/strong&gt;&lt;br/&gt;　　[ ... ]&lt;br/&gt;　　def 函数名（[位置形参]， [ *元组形参]， [命名关键字形参]， [**字典形参]）&lt;br/&gt;　　文档字符串&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块 Module：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　模块是一个包含有一系列数据、函数、类等组成的程序组&lt;br/&gt;　　模块是一个文件，模块文件通常以.py结尾&lt;br/&gt;　　作用：&lt;br/&gt;　　　　让一些相关的数据、函数、类等有逻辑的组织在一起，使用逻辑结构清晰&lt;br/&gt;　　　　模块的数据、函数、类等 可提供给其他模块或程序使用&lt;br/&gt;模块的分类;&lt;br/&gt;　　&lt;strong&gt;内建模块&lt;/strong&gt;（builtins）在解析器的内可以直接使用、&lt;br/&gt;　　&lt;strong&gt;标准库模块&lt;/strong&gt;，安装python时已安装且可以使用&lt;br/&gt;　　&lt;strong&gt;第三方模块&lt;/strong&gt;（通常开源），需要自己安装&lt;br/&gt;　　&lt;strong&gt;用户自己编写模块&lt;/strong&gt;（可以作为其他人的第三方模块）&lt;br/&gt;模块的导入：&lt;br/&gt;　　&lt;span&gt;import&lt;/span&gt; 语句：&lt;br/&gt;　　inport 模块名1 [ as 模块新名1]， 模块2 [as 模块2新名]， .........&lt;br/&gt;　　作用：&lt;br/&gt;　　　　将某模块整体导入到当前模块中&lt;br/&gt;　　impoer math 数学模块&lt;br/&gt;　　impoer sys os copy&lt;/p&gt;
&lt;p&gt;　　用法：&lt;br/&gt;　　　　模块名.属性名&lt;br/&gt;　　　　模块名.函数属性名（实参）&lt;br/&gt;&lt;span&gt;from import&lt;/span&gt; ：&lt;br/&gt;　　语法：&lt;br/&gt;　　　　from 模块名 import 模块属性名1[as 属性新名1]&lt;br/&gt;　　　　模块属性名2[as 属性名2]&lt;br/&gt;　　作用：&lt;br/&gt;　　　　将谋模块的一个或多个属性导入到当前模块的作用域&lt;br/&gt;from math import pi as p&lt;br/&gt;&lt;span&gt;from import * &lt;/span&gt;&lt;br/&gt;　　语法：&lt;br/&gt;　　　　 from 模块名 import 模块属性名1 [as 属性新名1], 模块属性名2 [as 属性新名2], ....&lt;br/&gt;　　作用：&lt;br/&gt;　　　　将某模块的所有属性全部导入到当前模块&lt;br/&gt;dir函数：&lt;br/&gt;　　dir([对象]) 返回一个字符串的列表&lt;br/&gt;　　说明：&lt;br/&gt;　　　　如果没有给参数调用，则返回当前作用域内的所有变量的列表&lt;br/&gt;　　　　如果给定一个对象作为参数，则返回这个对象的所有变量类型列表&lt;br/&gt;　　　　对于一个模块，返回这个模块的全部属性&lt;br/&gt;　　　　对于一个类 ，返回这个类的所有变量 ，并递归基类对象的所有变量&lt;br/&gt;　　　　对于他的对象，所有类变量和基类变量&lt;br/&gt;内建模块 ：&lt;br/&gt;　　math模块：&lt;/p&gt;
&lt;h3 id=&quot;math&quot;&gt;&lt;span&gt;数学模块 math&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;模块名: math&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;linux下为内建模块&lt;/li&gt;
&lt;li&gt;Mac OS下为标准库模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;数学模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;import math
# 或
from math import *
&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;math.e&lt;/td&gt;
&lt;td&gt;自然对数的底e&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.pi&lt;/td&gt;
&lt;td&gt;圆周率pi&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.ceil(x)&lt;/td&gt;
&lt;td&gt;对x向上取整，比如x=1.2，返回2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.floor(x)&lt;/td&gt;
&lt;td&gt;对x向下取整，比如x=1.2，返回1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.sqrt(x)&lt;/td&gt;
&lt;td&gt;返回x的平方根&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.factorial(x)&lt;/td&gt;
&lt;td&gt;求x的阶乘&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;math.log(x[, base])&lt;/td&gt;
&lt;td&gt;返回以base为底x的对数, 如果不给出base,则以自然对数e为底&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.log10(x)&lt;/td&gt;
&lt;td&gt;求以10为底x的对数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.pow(x, y)&lt;/td&gt;
&lt;td&gt;返回 x**y (x的y次方)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.fabs(x)&lt;/td&gt;
&lt;td&gt;返回浮点数x的绝对值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;角度和弧度degrees互换&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.degree(x)&lt;/td&gt;
&lt;td&gt;将弧度x转换为角度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.radians(x)&lt;/td&gt;
&lt;td&gt;将角度x转换为弧度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;三角函数&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.sin(x)&lt;/td&gt;
&lt;td&gt;返回x的正弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.cos(x)&lt;/td&gt;
&lt;td&gt;返回x的余弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.tan(x)&lt;/td&gt;
&lt;td&gt;返回x的正切(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.asin(x)&lt;/td&gt;
&lt;td&gt;返回x的反正弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.acos(x)&lt;/td&gt;
&lt;td&gt;返回x的反余弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.atan(x)&lt;/td&gt;
&lt;td&gt;返回x的反正切(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;time&quot;&gt;&lt;span&gt;时间模块 time&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;此模块提供了时间相关的函数，且一直可用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;时间简介&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;公元纪年是从公元 0000年1月1日0时开始的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;计算机元年是从1970年1月1日0时开始的,此时时间为0,之后每过一秒时间+1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的.&lt;br/&gt;UTC 时间不会因时区问题而产生错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_2&quot;&gt;时间元组&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;时间元组是一个9个整型元素组成的,这九个元素自前至后依次为:
&lt;ul&gt;&lt;li&gt;四位的年(如: 1993)&lt;/li&gt;
&lt;li&gt;月 (1-12)&lt;/li&gt;
&lt;li&gt;日 (1-31)&lt;/li&gt;
&lt;li&gt;时 (0-23)&lt;/li&gt;
&lt;li&gt;分 (0-59)&lt;/li&gt;
&lt;li&gt;秒 (0-59)&lt;/li&gt;
&lt;li&gt;星期几 (0-6, 周一是 0)&lt;/li&gt;
&lt;li&gt;元旦开始日 (1-366)&lt;/li&gt;
&lt;li&gt;夏令时修正时间 (-1, 0 or 1).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;如果年份值小于100,则会自动转换为加上1900后的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;time_1&quot;&gt;模块名: time&lt;/h4&gt;
&lt;h4 id=&quot;_3&quot;&gt;时间模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;import time
# 或
from time import xxx
# 或
from time import *
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.altzone&lt;/td&gt;
&lt;td&gt;夏令时时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;time.daylight&lt;/td&gt;
&lt;td&gt;夏令时校正时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.timezone&lt;/td&gt;
&lt;td&gt;本地区时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;time.tzname&lt;/td&gt;
&lt;td&gt;时区名字的元组， 第一个名字为未经夏令时修正的时区名,&lt;br/&gt;第一个名字为经夏令时修正后的时区名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注： CST为中国标准时间(China Standard Time UTC+8:00)&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.time()&lt;/td&gt;
&lt;td&gt;返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.sleep(secs)&lt;/td&gt;
&lt;td&gt;让程序按给定秒数的浮点数睡眠一段时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.gmtime([secs])&lt;/td&gt;
&lt;td&gt;用给定秒数转换为用UTC表达的时间元组&lt;br/&gt;(缺省返回当前时间元组)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.asctime([tuple])&lt;/td&gt;
&lt;td&gt;将时间元组转换为日期时间字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.mktime(tuple)&lt;/td&gt;
&lt;td&gt;将本地日期时间元组转换为新纪元秒数时间(UTC为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.localtime([secs])&lt;/td&gt;
&lt;td&gt;将UTC秒数时间转换为日期元组（以本地时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;练习:&lt;br/&gt;1. 请编写函数fun 其功能是计算下列多项式的和:&lt;br/&gt;fn = 1 + 1/1! + 1/2! + 1/3! + 1/4! + .. + 1/n!&lt;br/&gt;(建义用数学模块的factorial实现)&lt;/p&gt;
&lt;p&gt;求当n 等于100时,fn的值&lt;br/&gt;看一下fn(100)的值是什么&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1 + 1 / 1
    &lt;span&gt;return&lt;/span&gt; fun(n - 1) + (1 /&lt;span&gt;  math.factorial(n))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fun(100))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180717225217539-687740936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 写一个程序，以电子时钟格式:&lt;br/&gt;HH:MM:SS格式显示时间&lt;br/&gt;要求每隔一秒变化一次&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    x &lt;/span&gt;= time.time() % (3600 * 24&lt;span&gt;)
    h &lt;/span&gt;= x // 3600&lt;span&gt;
    m &lt;/span&gt;= (x % 3600) // 60&lt;span&gt;
    s &lt;/span&gt;= x % 60&lt;span&gt;
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%02d:%02d:%02d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (h + 8, m, s))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方法二：&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    s &lt;/span&gt;=&lt;span&gt; time.localtime()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%02d:%02d:%02d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (s[3], s[4], s[5]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180717225121950-844350790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3 写函数f(n)求下多项式的和&lt;br/&gt;fn = 1/1 - 1/3 + 1/5 - 1/7 + 1/9 .... 1/(2*n-1)的和&lt;/p&gt;
&lt;p&gt;求当n取值为1000000时，&lt;br/&gt;1） 打印 f(1000000) 的值&lt;br/&gt;2） 打印 f(1000000) * 4的值，看看是什么&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fn(n):
    s &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x % 2 ==&lt;span&gt; 0:
            s &lt;/span&gt;-= 1 / (x * 2 - 1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            s &lt;/span&gt;+= 1 / (x * 2 - 1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s * 4  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处乘4&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(fn(1000000))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方法二：
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fn(n):
    s &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x % 2 !=&lt;span&gt; 0:
            s &lt;/span&gt;+= (1 / (x * 2 - 1)) - (1 / ((x * 2 + 2) - 1&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s * 4
&lt;span&gt;print&lt;/span&gt;(fn(1000000))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180717230900509-1255365094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;1. 输入一个圆的半径，打印出这个圆的面积&lt;br/&gt;2. 输入一个圆的面积，打印出这个圆的半径&lt;/p&gt;
&lt;p&gt;(要求用math模块内的函数和数据实现)&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math
r &lt;/span&gt;= float(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input radius of a circle:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
s &lt;/span&gt;= math.pi * r ** 2
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
s &lt;/span&gt;= float(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input acreage of a circle:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
x &lt;/span&gt;= s /&lt;span&gt; math.pi
r &lt;/span&gt;=&lt;span&gt; math.sqrt(x)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180717231546920-562000102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;装饰器 decorators&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;装饰器 顾名思义 在不改变原函数的基础上改变功能 就好比在卧室里贴壁纸&lt;/span&gt;&lt;br/&gt;&lt;span&gt;壁纸是后来加上去的 但是墙还是墙 没有任何变化 不管我是贴上去还是撕下来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不可能说吧墙砸烂再贴&lt;/span&gt;&lt;br/&gt;&lt;span&gt;墙就是原函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;壁纸就是内部装饰函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;装饰器本身也是一个函数 但是他要传入一个函数 返回一个函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;传入的函数： 形参就是原函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;返回的函数：就是装饰函数内部嵌套的函数 也是最终装饰函数 是它最终调用的原函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里利用内部嵌套函数调用外部函数的形参变量（原函数）用内部嵌套函数来装饰原函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;返回后的函数是内部嵌套的函数 外部函数被释放 这也是一个典型的闭包函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;调用装饰函数 @message_send 等同于 myfunc = mydeco(myfunc)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;可以有多层装饰最外层依次包含内部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;函数的文档字符串 就是给你写的函数加一个注解 但是这个不等同与注释 因为注释不会被解释执行器所识别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;他是一个字符串形式的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;函数名.__doc__ 查看该函数注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;4种模块：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;内建模块是解释执行器自带的模块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;标准库模块是安装python时自动安装的模块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第三方模块是自己下载安装是的模块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有一种就是自己写的模块 可以自己用 也可以给别人用 相当于自定义第三方模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;import 调用模块 [一系列参数...]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;math 、 time 标准库模块 直接导入就可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180717233933984-105040851.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 17 Jul 2018 14:30:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9326393.html</dc:identifier>
</item>
<item>
<title>Towards Accurate Multi-person Pose Estimation in the Wild 论文阅读 - bobxx</title>
<link>http://www.cnblogs.com/bobxxxl/p/9326304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobxxxl/p/9326304.html</guid>
<description>&lt;p&gt;论文名：&lt;a href=&quot;http://openaccess.thecvf.com/content_cvpr_2017/papers/Papandreou_Towards_Accurate_Multi-Person_CVPR_2017_paper.pdf&quot;&gt;Towards Accurate Multi-person Pose Estimation in the Wild&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者(第一作者)及单位：George Papandreou, 谷歌&lt;/p&gt;
&lt;p&gt;发表期刊/会议：CVPR2016&lt;/p&gt;
&lt;p&gt;被引次数（截止到发博日期，以谷歌学术为数据来源）：52&lt;/p&gt;

&lt;p&gt;论文实现的是多人的姿态估计，使用的是自顶向下（top-down）的方法，即：先由目标检测方法把人检测出来，然后再进行单人的姿态估计。这篇论文的总体流程是：第一步，使用Faster-RCNN进行人的检测。第二步，进行姿态估计。&lt;/p&gt;
&lt;h2 id=&quot;第一步使用faster-rcnn进行人的提取&quot;&gt;第一步、使用Faster-RCNN进行人的提取&lt;/h2&gt;
&lt;p&gt;这部分看起来没什么好说的，但是，读论文就要事无巨细，所以来看一下详细实现。&lt;/p&gt;
&lt;p&gt;文章中使用了基于ResNet101的Faster-RCNN,但是做了一些更改，就是把卷积操作用atrous convolution给修改了，具体修改可以看一下原文的参考文献，我们这里看一下atrous convolution是什么，atrous convolution频繁的在deeplab的论文里出现，这里特意找了一下，如&lt;a href=&quot;http://liangchiehchen.com/projects/DeepLab.html&quot;&gt;下图&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liangchiehchen.com/fig/atrous_example4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图(b)就是atrous convolution，接下来我们看一个二维的卷积，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liangchiehchen.com/fig/deeplab_aspp.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这幅图虽然是讲的时空金字塔池化，但是上面的卷积核我们可以直观的看到，可以说就是带孔的卷积，这样可以用相对更少的参数得到更大感受野的feature map（这样说也不知道对不对），论文中这么做的目的是为了让ResNet的输出由原来的stride=32变成stride=8,这样子就可以产生更“稠密”的feature map,我的理解是具有更大的感受野和更多的信息。另外，这里用的Faster-RCNN是重新训练过的，并且训练的时候只保留“人”这一个类别。&lt;/p&gt;
&lt;h2 id=&quot;第二步姿态估计&quot;&gt;第二步、姿态估计&lt;/h2&gt;
&lt;p&gt;这部分是本文的重头戏，其骨干就是用ResNet来同时做了分类和回归。&lt;/p&gt;
&lt;p&gt;对于分类问题，论文中将以关节点为中心，以R为半径的区域归为１，其余位置为０。对于回归问题，回归了一个向量，也就是偏移量，定义为：&lt;br/&gt;$$&lt;br/&gt;F_{k}(x_{i})=l_k-x_i&lt;br/&gt;$$&lt;br/&gt;其中ｌ_k为关节点坐标。为什么要这样呢？直接回归出关节点不好吗，实际上直接回归是很难的，谷歌的deeppose论文就是直接回归的，但是也是用了很多了阶段不停地修正才能得到真正的坐标，我曾经试过只用一个阶段单纯的回归坐标，但是结果是所有的预测结果都是一样的，必须经过修正才可以让网络学到真正能识别关节的特征，所以这就是本文的两步走策略，我先找到一个大概区域，然后根据我预测的偏移量投票出我真正的关节点坐标，那么怎么得到呢，公式如下：&lt;br/&gt;$$&lt;br/&gt;f_k(x_i)=\sum_{j}\frac{1}{\pi R^2}G(x_j+F_k(x_j)-x_i)h_k(x_j)&lt;br/&gt;$$&lt;br/&gt;其中G()是 bilinear interpolation kernel，恕我才疏学浅，这个函数找了很久都不知道是什么，看字面是双线性内插算法，但是双线性内插公式要有四个已知点，这部分等以后搞懂了再说吧。但是论文中提到，如果heatmap（也就是那个圆）和offset（偏移向量）都是完美的话，那么f应该是冲击响应函数，我们看一下论文里的图片，直觉上理解一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203133/201807/1203133-20180717221037278-689868749.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203133/201807/1203133-20180717221049651-1636131093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面就是实验结果，其中还提到了基于OKS的非最大值抑制，但是可惜没有说具体怎么做，关于非最大值抑制的相关问题，由于这个也很重要，以后单写一篇随笔吧。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 14:12:00 +0000</pubDate>
<dc:creator>bobxx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobxxxl/p/9326304.html</dc:identifier>
</item>
</channel>
</rss>