<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Paramiko模块 - ﹏亦°洛轩づ</title>
<link>http://www.cnblogs.com/charles8866/p/8401788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charles8866/p/8401788.html</guid>
<description>&lt;p&gt;python 的paramiko 模块，改模块是基于ssh用于连接远程服务器并执行相关操作&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SSHClient&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于连接远程服务器并执行基本命令：&lt;/p&gt;
&lt;p&gt;基于用户名密码的连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建SSH对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; ssh =&lt;span&gt; paramiko.SSHClient()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许连接不在know_hosts文件中的主机&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接服务器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; ssh.connect(hostname=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=22, username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行命令&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取命令结果&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标准输出只有在正确的情况下才会有输出，错误的情况下没有&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; res,err =&lt;span&gt; stdout.read(),stderr.read()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; result = res &lt;span&gt;if&lt;/span&gt; res &lt;span&gt;else&lt;/span&gt;&lt;span&gt; err
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; ssh.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果遇到这样的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201141845656-297490913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;/strong&gt;&lt;/span&gt;这个函数就能够能好的解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在linux中直接通过ssh去登录远程，会出现如下的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142509343-1570168661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入yes之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142622406-966138291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码就可以登录。&lt;/p&gt;
&lt;p&gt;在linux中如果有一个文件 /root/.ssh/known_hosts &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142328468-433660454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 里面就有一个10.0.0.41的相关rsa信息，如果这个文件里有这个安全的签名认证，就可以直接输入密码连接，否则就需要自己做判断是否加入known_hosts&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;/strong&gt;就是解决了这个问题，自动添加认证&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里，不能执行“top”命令，只能让他执行那种一次性执行完毕的命令&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; SFtpClient&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ssh远程传文件命令：&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;    #r即使是目录也会传，p是会把文件的权限也传过去&lt;br/&gt;scp -rp -P52113 文件名 root@10.0.0.41:/tmp/&lt;br/&gt;查看文件内容，目录内容可以用：more ****&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt;用于连接远程服务器并执行上传和下载&lt;/p&gt;
&lt;p&gt;基于用户名密码上传下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko

transport &lt;/span&gt;= paramiko.Transport((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.5.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 22&lt;span&gt;))
transport.connect(username&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

sftp &lt;/span&gt;=&lt;span&gt; paramiko.SFTPClient.from_transport(transport)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将location.py 上传至服务器 /tmp/test.py&lt;/span&gt;
sftp.put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;笔记&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/test_from_win&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将remove_path 下载到本地 local_path&lt;/span&gt;
sftp.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fromlinux.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

transport.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; put()方法是上传文件，get()方法是下载文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面两种方式都是用了明文用户名密码，这个是很不安全的。所以可以用密钥去连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ssh密钥-----RSA非对称密钥验证&lt;/p&gt;
&lt;p&gt;公钥（public key）：是给别人的&lt;/p&gt;
&lt;p&gt;私钥（private key）&lt;/p&gt;
&lt;p&gt;10.0.0.31 ----------》10.0.0.41   这样就可以无密码连接&lt;/p&gt;
&lt;p&gt;私钥　　　　　　　　公钥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在linux中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. linux中生成公钥私钥对：#&lt;span&gt;ssh-keygen&lt;/span&gt;(默认保存在/root/.ssh/id_rsa)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201152114968-559765586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;私钥在id_rsa中，公钥在id_rsa.pub中&lt;/p&gt;
&lt;p&gt;b.将本地的公钥添加到远程机器的authorized_keys中，从而实现SSH无密码登录。&lt;span&gt;ssh-copy-id &quot;-p22 root@192.168.5.9&quot;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c.利用ssh远程无密码登录：&lt;span&gt;ssh root@192.168.5.9 -p22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在windows中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko

private_key &lt;/span&gt;= paramiko.RSAKey.from_private_key_file(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id_rsa9.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建SSH对象&lt;/span&gt;
ssh =&lt;span&gt; paramiko.SSHClient()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许连接不在know_hosts文件中的主机&lt;/span&gt;
&lt;span&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接服务器&lt;/span&gt;
ssh.connect(hostname=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.5.12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=22, username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaoming&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pkey=&lt;span&gt;private_key)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行命令&lt;/span&gt;
stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取命令结果&lt;/span&gt;
result =&lt;span&gt; stdout.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
ssh.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
使用rz/sz命令可以将linux生成的公钥上传到windows上：sz ~/.ssh/id_rsa&lt;br/&gt;安装rz/sz命令：yum install lrzsz&lt;br/&gt;然后将得到的id_rsa放到项目当中就可以使用了&lt;/pre&gt;

</description>
<pubDate>Thu, 01 Feb 2018 15:32:00 +0000</pubDate>
<dc:creator>﹏亦&amp;#176;洛轩づ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charles8866/p/8401788.html</dc:identifier>
</item>
<item>
<title>JavaScript基础：BOM的常见内置方法和内置对象 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8401662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8401662.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8401662.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;bom的介绍&quot;&gt;BOM的介绍&lt;/h2&gt;
&lt;h3 id=&quot;javascript的组成&quot;&gt;JavaScript的组成&lt;/h3&gt;
&lt;p&gt;JavaScript基础分为三个部分：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;：文档对象模型，操作&lt;strong&gt;网页上的元素&lt;/strong&gt;的API。比如让盒子移动、变色、轮播图等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt;：浏览器对象模型，操作&lt;strong&gt;浏览器部分功能&lt;/strong&gt;的API。比如让浏览器自动滚动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是bom&quot;&gt;什么是BOM&lt;/h3&gt;
&lt;p&gt;BOM：Browser Object Model，浏览器对象模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BOM的结构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图也可以看出：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;window对象是BOM的顶层(核心)对象&lt;/strong&gt;，所有对象都是通过它延伸出来的，也可以称为window的子对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DOM越是BOM的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;window对象：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;window对象是JavaScript中的顶级对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全局变量、自定义函数也是window对象的属性和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;window对象下的属性和方法调用时，可以省略window。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面讲一下 &lt;strong&gt;BOM 的常见内置方法和内置对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;弹出系统对话框&quot;&gt;弹出系统对话框&lt;/h2&gt;
&lt;p&gt;比如说，&lt;code&gt;alert(1)&lt;/code&gt;是&lt;code&gt;window.alert(1)&lt;/code&gt;的简写，因为它是window的子方法。&lt;/p&gt;
&lt;p&gt;系统对话框有三种：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//不同浏览器中的外观是不一样的&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;confirm&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//兼容不好&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;prompt&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//不推荐使用&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;打开窗口关闭窗口&quot;&gt;打开窗口、关闭窗口&lt;/h2&gt;
&lt;p&gt;1、打开窗口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    window.open(url,target,param)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;url：要打开的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;target：新窗口的位置。可以是：&lt;code&gt;_blank&lt;/code&gt; 、&lt;code&gt;_self&lt;/code&gt;、 &lt;code&gt;_parent&lt;/code&gt; 父框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;param：新窗口的一些设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;返回值：新窗口的句柄。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;param&lt;/strong&gt;这个参数，可以填各种各样的参数（），比如：&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;name：新窗口的名称，可以为空&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;featurse：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fullscreen= { yes/no/1/0 } 是否全屏，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;channelmode= { yes/no/1/0 } 是否显示频道栏，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;toolbar= { yes/no/1/0 } 是否显示工具条，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;directories = { yes/no/1/0 } 是否显示转向按钮，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;status= { yes/no/1/0 } 是否显示窗口状态条，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;menubar= { yes/no/1/0 } 是否显示菜单，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;width=number 窗口宽度（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;height=number 窗口高度（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;top=number 窗口离屏幕顶部距离（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;left=number 窗口离屏幕左边距离（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。&lt;/p&gt;
&lt;p&gt;2、关闭窗口：window.close()&lt;/p&gt;
&lt;p&gt;（1）和（2）的代码举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;点击我打开一个新的页面&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;点击我关闭本页面&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;a1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//举例1： window.open(&quot;http://www.jd.com&quot;,&quot;_blank&quot;);&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; json &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;helloworld&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;fullscreen&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;location&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;width&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;left&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;_blank&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; json)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//举例2&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;//关闭本页面&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;a2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、新窗口相关：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;新窗口.moveTo(5,5)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新窗口.moveBy()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新窗口.resizeTo()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;window.resizeBy()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; newWin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;demo.html&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;_blank&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; json)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;newWin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;moveTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;location对象&quot;&gt;location对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;window.location&lt;/code&gt;可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;location对象的属性&quot;&gt;location对象的属性&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;href&lt;/strong&gt;：跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;hash 返回url中#后面的内容，包含#&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;host 主机名，包括端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hostname 主机名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pathname url中的路径部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;protocol 协议 一般是http、https&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;search 查询字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;location.href属性举例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例1：&lt;/strong&gt;点击盒子时，进行跳转。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;smyhvae&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;div&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;location&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;href&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//点击div时，跳转到指定链接&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;//     window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;);  //方式二&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;举例2：5秒后自动跳转到百度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;location&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;href&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;location对象的方法&quot;&gt;location对象的方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;location.assign()：改变浏览器地址栏的地址，并记录到历史中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;navigator对象&lt;/h2&gt;
&lt;p&gt;window.navigator 的一些属性可以获取客户端的一些信息。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;userAgent&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;platform&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2140.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;history对象&lt;/h2&gt;
&lt;p&gt;1、历史记录管理&lt;/p&gt;
&lt;p&gt;2、后退：&lt;/p&gt;
&lt;p&gt;3、前进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;history.forward()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;history.go(1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用的不多。因为浏览器中已经自带了这些功能的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2146.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 14:56:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8401662.html</dc:identifier>
</item>
<item>
<title>TCP/IP详解 卷1 第二十章 TCP的成块数据流 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8401523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8401523.html</guid>
<description>&lt;p&gt;1.&lt;span&gt;停止等待协议：&lt;/span&gt;是tcp保证传输可靠的重要途径，“停止等待”就是指发送完一个分组就停止发送，等待对方确认之后，才能继续发送下一个分组&lt;/p&gt;
&lt;p&gt;停止等待协议的优点是简单，缺点就是信道的利用率太低，一次只发送一个消息，信道大部分时间都是空闲的。&lt;/p&gt;

&lt;p&gt;2：&lt;span&gt;超时重传有一下三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）  分组丢失：发送方发出来了，接收方没有收到&lt;/p&gt;
&lt;p&gt;2）  确认丢失：接收方收到了，也发送了确认分组，但是确认分组丢失了&lt;/p&gt;
&lt;p&gt;3）  确认延时：确认分组没有丢失，由于传输太慢，发送方在规定时间内没有收到接收方发的确认分组。&lt;/p&gt;

&lt;p&gt;3.下面两个协议就是解决信道效率太低和增大吞吐量，以及流量控制：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;连续ARQ协议：&lt;/span&gt;它是指发送方维护着一个窗口，这个窗口中不止有一个分组，而是有好几个分组。窗口的大小是由接收方返回的win值决定的。所以窗口大小 是动态变化的。只要在窗口中的分组都可以被发送，这就使得TCP一次不是只发送一个分组了。从而大大提高了信道利用率。并且它采用累积确认的方式，对于按序到达的最后一个分组进行确认。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;滑动窗口协议&lt;/span&gt;：因为窗口不断往前走。该协议允许发送方在停止并等待确认前发送多个数据分组。不需要每发送一个就分组就停下来等待确认。所以可以加速数据的传输，还可以控制流量。&lt;/p&gt;
&lt;p&gt;3）累积确认：如果发送方发送了5个分组，接收端只收到了1 2 4 5 ，没有收到3，那么我的确认信息会是说明我期望下一个收到的组是第三个，此时发送方会将3 4 5都重发一遍。&lt;/p&gt;

&lt;h2&gt;20.1 引言&lt;/h2&gt;
&lt;p&gt;本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。&lt;/p&gt;
&lt;p&gt;该协议允许发送方在停止并等待确认前可以连续发送多个分组。&lt;/p&gt;

&lt;h2&gt;20.2 正常数据流&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;经受时延的确认：&lt;/strong&gt;&lt;/span&gt;假设 A -&amp;gt; B，B要对A的数据进行确认，当有一个分组来的时候，B不立即确认，而是启动一个定时器（RFC规定要小于500ms，很多都是200ms），等待200ms，如果在这期间A又来了其他的数据就可以一起确认了 。或者A要发数据给B了，就顺带把之前的也确认了。&lt;/p&gt;
&lt;p&gt;比如下面这样，对1025的确认放到了跟2049一起。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221411187-75629837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用滑动窗口协议，接收方不必确认每一个收到的分组。在TCP中，ACK是累积的—它们表示连接方已经正确收到了一直到确认号减1的所有字节。比如上面的2049，就表示我收到了2048个字节。&lt;/p&gt;

&lt;h2&gt;20.3 滑动窗口协议&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221433500-225660853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如上面的例子，应该是右边发送数据给左边。左边进行确认。窗口往右移动。&lt;/p&gt;
&lt;p&gt;接收方通告的窗口称为提出的窗口（offered window）：上面的4 – 9&lt;/p&gt;
&lt;p&gt;说明接收方已经收到了3字节的数据，且通告窗口大小为6.&lt;/p&gt;
&lt;p&gt;当接收方确认数据后，这个滑动窗口不断的向右移动。下面用三个术语来描述窗口左右边沿的运动：&lt;/p&gt;
&lt;p&gt;1）  称窗口&lt;strong&gt;左边沿向右边沿靠近为&lt;span&gt;窗口合拢&lt;/span&gt;&lt;/strong&gt;。这种现象发生在数据被发送和确认时。&lt;/p&gt;
&lt;p&gt;2）  当窗口&lt;strong&gt;右边沿向右移动时将允许发送更多的数据，我们称之为&lt;span&gt;窗口张开&lt;/span&gt;&lt;/strong&gt;。这种现象发生在另一端的接收进程读取已经确认的数据，并释放了TCP的接收缓存时。&lt;span&gt;（就是接收方读取了缓冲区里面的数据的时候）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）&lt;/strong&gt; 当&lt;strong&gt;右边沿向左移动，称为&lt;span&gt;窗口收缩&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221444640-461372373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果左边沿到达右边沿，则称其为一个零窗口。此时发送方不能发送任何数据。&lt;/p&gt;

&lt;h2&gt;20.4 窗口大小&lt;/h2&gt;
&lt;p&gt;由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。&lt;/p&gt;
&lt;p&gt;插口API允许进程设置发送和接收缓存的大小。接收缓存的大小是该连接上所能通告的最大窗口大小。有一些应用程序通过修改插口缓存大小来增加性能。&lt;/p&gt;

&lt;h2&gt;20.5 PUSH标志&lt;/h2&gt;
&lt;p&gt;发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。（这里的数据包括与PUSH一起传送的数据，以及接收方TCP已经为接收进程收到的其他数据）&lt;/p&gt;

&lt;p&gt;假设一个客户端发送数据给服务器，设置了PUSH标志：&lt;/p&gt;
&lt;p&gt;对客户端来说：客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓冲中滞留。&lt;/p&gt;
&lt;p&gt;对服务器来说：TCP收到一个设置了PUSH标志的报文时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;目前大多数的API没有向应用程序提供通知其TCP设置PUSH的方法，很多实现程序任务PUSH已经过时了。一个好的TCP实现能够自动设置PUSH标志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。&lt;/p&gt;

&lt;h2&gt;20.6 慢启动&lt;/h2&gt;
&lt;p&gt;“慢启动”slow start算法：通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞窗口（congestion window）：&lt;/span&gt;&lt;/strong&gt;当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ack，拥塞窗口就增加一个报文段（慢启动以报文段大小为单位进行增加）。&lt;/p&gt;
&lt;p&gt;发送方取拥塞窗口与通告窗口中的最小值作为发送上限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞窗口是发送方用的流量控制，而通告窗口则的接收方用的流量控制。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最开始为1，确认一个后变成了2，就可以发送两个报文段了，当这两个被确认以后拥塞窗口就变成了4。这是一种&lt;strong&gt;&lt;span&gt;指数增加的关系&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当到达互联网的极限时，中间路由器开始丢弃分组，这就通知发送方它的拥塞窗口开的过大。&lt;/p&gt;

&lt;h2&gt;20.7 成块数据的吞吐量&lt;/h2&gt;
&lt;p&gt;通常发送一个分组的时间取决于两个因素：&lt;/p&gt;
&lt;p&gt;1）  传播延时：由光的有限速率、传输设备的等待时间引起（这个一般是固定的）&lt;/p&gt;
&lt;p&gt;2）  媒体速率的发送延时：媒体每秒可传输的比特数。（取决与 分组的大小。）&lt;/p&gt;
&lt;p&gt;假设A发数据给B，拥塞窗口慢慢增大，到最后，发送方和接收方的之间的管道被填满。此时无论拥塞窗口和通过窗口是多少，它都不能再容纳更多的数据。每当接收方在某一时间单位从网络上移去一个报文段，发送方就再发送一个报文段到网络上。但是不管有多少报文段填充了这个管道，返回路径上总是有相同数目的ack，这就是连接的理想稳定状态。&lt;/p&gt;

&lt;h3&gt;20.7.1 带宽时延乘积&lt;/h3&gt;
&lt;p&gt;如何设置窗口大小呢。下面是计算公式： &lt;span&gt;带宽 * RTT&lt;/span&gt; ，括号里面是单位。&lt;/p&gt;
&lt;p&gt;c a p a c i t y (bit) = b a n d w i d t h (b/s) × ro u n d-trip time ( s )&lt;/p&gt;
&lt;p&gt;一般称之为带宽时延乘积。这个值依赖于网络速度和两端的RTT。&lt;/p&gt;
&lt;p&gt;比如：一条穿越美国（RTT约为60ms）的T1电话线路（1544000 b/s）的带宽时延乘积为11580字节。&lt;strong&gt;&lt;span&gt;1544000 * 0.06 / 8&lt;/span&gt;&lt;/strong&gt; 就是字节了。&lt;/p&gt;
&lt;p&gt; 所以增加RTT和增加带宽都可以使管道容量增加。&lt;/p&gt;

&lt;h3&gt;20.7.2 拥塞&lt;/h3&gt;
&lt;p&gt;发送拥塞的两种情况：&lt;/p&gt;
&lt;p&gt;1）  数据到达一个大的管道并向一个较小的管道发送时便会发送拥塞。&lt;/p&gt;
&lt;p&gt;2）  当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发送拥塞&lt;/p&gt;

&lt;h2&gt;20.8 紧急方式&lt;/h2&gt;
&lt;p&gt;urgent mode：它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。&lt;/p&gt;

&lt;p&gt;如何发送紧急数据：设置TCP首部中的两个字段来发出紧急数据。URG置为1，并且从一个16bit的紧急指针被置为一个正的偏移量，该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号。&lt;/p&gt;

&lt;p&gt;TCP本身对紧急数据知之甚少，没有办法指明紧急数据从数据流的何处开始。TCP通过连接传送的唯一信息就是紧急方式已经开始（URG置为1）和指向紧急数据最后一个字节的指针。其他的事情留给应用程序去处理。&lt;/p&gt;

</description>
<pubDate>Thu, 01 Feb 2018 14:18:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8401523.html</dc:identifier>
</item>
<item>
<title>Asp.net core 2.0.1 Razor 的使用学习笔记（一） - 沉默种子</title>
<link>http://www.cnblogs.com/chonghanyu/p/8400214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chonghanyu/p/8400214.html</guid>
<description>&lt;p&gt;环境：vs2017 版本：15.5.6&lt;/p&gt;
&lt;p&gt;这里说明下， Razor页面模式跟mvc出现了严重的不同。正如微软官方说的一样“Razor 页面是 ASP.NET Core MVC 的一个新功能，它可以使基于页面的编码方式更简单高效。”&lt;/p&gt;
&lt;p&gt;但就代码说没有什么不同几乎完全一样，但是存放的位置却有了根本的区别。个人研究分析的结果是：Razor页面模式其实是把mvc中的控制器化整为零了，即原来控制器中的操作代码被分布放到了各个页面的.cshtml.cs文件中了。这样一来由原来mvc中文件按类型分类变成了按功能分类，这样的好处就是每个页面形成了模块化，这个页面涉及的数据都在这里，便于维护，不用控制器、模型、视图来回切换了，给我的感觉多少有些像原来的web窗体的页面结构，当然化整为零后每个页面的操作不用全部去读取控制器，可能在性能有提升。&lt;/p&gt;
&lt;p&gt;同时，这种变化使代码功能单一，易于维护，更不易出现错误，所以还是值得一学的。 &lt;/p&gt;
&lt;p&gt;一、新建项目&lt;/p&gt;
&lt;p&gt;1、文件》新建》项目》Visual c#》.NET Core》ASP.NET Core Web应用程序（“.NET Framework” 4.6.1）&lt;/p&gt;
&lt;p&gt;2、依次选择“.NET Core”》“ASP.NET Core 2.0”，然后选择“Web 应用程序”（身份验证类型：个人用户账户）。&lt;/p&gt;
&lt;p&gt;二、修改数据库连接。引自“张不水”兄的研究成果。&lt;/p&gt;
&lt;p&gt;1、相对路径：&lt;/p&gt;
&lt;p&gt;修改appsettings.json文件中的&quot;ConnectionStrings&quot;（第3行）&lt;/p&gt;
&lt;p&gt;&quot;DefaultConnection&quot;: &quot;Data Source=(localdb)\\mssqllocaldb;AttachDbFilename=%CONTENTROOTPATH%\\App_Data\\aspnet123.mdf;Integrated Security=True;Connect Timeout=30;MultipleActiveResultSets=true”&lt;/p&gt;
&lt;p&gt;需注意的是：AttachDbFilename=%CONTENTROOTPATH%\\App_Data\\aspnet123.mdf;&lt;/p&gt;
&lt;p&gt;使用 ContentRootPath 是将文件放置在项目目录下而不是wwwroot目录下，这样更安全。&lt;/p&gt;
&lt;p&gt;ContentRootPath 用于包含应用程序文件。&lt;br/&gt;WebRootPath 用于包含Web服务性的内容文件。&lt;br/&gt;实际使用区别如下：&lt;/p&gt;
&lt;p&gt;ContentRoot: C:\MyApp\&lt;br/&gt;WebRoot: C:\MyApp\wwwroot\&lt;/p&gt;
&lt;p&gt;2、修改Startup.cs&lt;/p&gt;
&lt;p&gt;修改后的代码：&lt;/p&gt;
&lt;p&gt;①修改Startup方法为如下&lt;/p&gt;
&lt;pre&gt;
public Startup(IConfiguration configuration,IHostingEnvironment env)
        {
            Configuration = configuration;&lt;br/&gt;//新添加
            _env = env;
        }
&lt;/pre&gt;
&lt;p&gt;②添加public IHostingEnvironment _env { get; }&lt;/p&gt;
&lt;p&gt;③修改ConfigureServices方法&lt;/p&gt;
&lt;p&gt;注销掉原有的services.AddDbContext&lt;/p&gt;
&lt;p&gt;//添加修改（）声明变量conn并做相应处理&lt;br/&gt;string conn = Configuration.GetConnectionString(&quot;DefaultConnection&quot;);&lt;br/&gt;if (conn.Contains(&quot;%CONTENTROOTPATH%&quot;))&lt;br/&gt;{&lt;br/&gt;conn = conn.Replace(&quot;%CONTENTROOTPATH%&quot;, _env.ContentRootPath);&lt;br/&gt;}&lt;br/&gt;//修改默认的连接服务为conn&lt;br/&gt;services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;&lt;br/&gt;options.UseSqlServer(conn));&lt;/p&gt;
&lt;p&gt;修改完成后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9db4f3f-f465-4671-b3a7-5cf4fd6fa273')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9db4f3f-f465-4671-b3a7-5cf4fd6fa273',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration, IHostingEnvironment env)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新添加&lt;/span&gt;
            _env =&lt;span&gt; env;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新添加&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IHostingEnvironment _env { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加修改（）声明变量conn并做相应处理&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; conn = Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (conn.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%CONTENTROOTPATH%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                conn &lt;/span&gt;= conn.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%CONTENTROOTPATH%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _env.ContentRootPath);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改默认的连接服务为conn&lt;/span&gt;
            services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                      options.UseSqlServer(conn));


            services.AddIdentity&lt;/span&gt;&amp;lt;ApplicationUser, IdentityRole&amp;gt;&lt;span&gt;()
                .AddEntityFrameworkStores&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;&lt;span&gt;()
                .AddDefaultTokenProviders();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add application services.&lt;/span&gt;
            services.AddTransient&amp;lt;IEmailSender, EmailSender&amp;gt;&lt;span&gt;();

            services.AddMvc();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
                app.UseBrowserLink();
                app.UseDatabaseErrorPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            app.UseStaticFiles();

            app.UseAuthentication();

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、手动在项目中添加“App_data”文件夹，并复制粘贴一个标准的内容为空的.mdf文件。&lt;/p&gt;
&lt;p&gt;为方便大家学习我这里为大家提供了&lt;a title=&quot;示例数据库&quot; href=&quot;http://files.cnblogs.com/files/chonghanyu/App_Data.rar&quot; target=&quot;_blank&quot;&gt;示例数据库&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 14:16:00 +0000</pubDate>
<dc:creator>沉默种子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chonghanyu/p/8400214.html</dc:identifier>
</item>
<item>
<title>[搬运]  .NET Core 2.1中改进的堆栈信息 - 张很水</title>
<link>http://www.cnblogs.com/chenug/p/8401356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenug/p/8401356.html</guid>
<description>&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;原文 : &lt;a href=&quot;https://www.ageofascent.com/2018/01/26/stack-trace-for-exceptions-in-dotnet-core-2.1/&quot;&gt;Stacktrace improvements in .NET Core 2.1&lt;/a&gt;&lt;br/&gt;作者 : &lt;a href=&quot;https://www.ageofascent.com/authors/ben-adams/&quot;&gt;Ben Adams&lt;/a&gt;&lt;br/&gt;译者 : &lt;a href=&quot;https://www.jianshu.com/u/910143584bd2&quot;&gt;张很水&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;. NET Core 2.1 现在具有可读的异步堆栈信息！使得异步、迭代器和字典 ( key not found ) 中的堆栈更容易追踪！&lt;/p&gt;
&lt;p&gt;这个大胆的主张意味着什么？&lt;/p&gt;
&lt;p&gt;要知道，为了确定调用 异步 和 迭代器方法的实际重载，（这在以前）从堆栈信息中跟踪几乎是不可能的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key '0' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题-使堆栈信息可读&quot;&gt;问题: “使堆栈信息可读”&lt;/h3&gt;
&lt;p&gt;David Kean(&lt;a href=&quot;https://twitter.com/davkean&quot;&gt;@davkean&lt;/a&gt;) 于 2017 年 10 月 13 日在&lt;a href=&quot;https://github.com/dotnet/corefx/issues/24627&quot;&gt;dotnet/corefx#24627&lt;/a&gt; 提出 &lt;strong&gt;使堆栈信息可读&lt;/strong&gt; 的问题:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如今在 任务 (Task)、异步 (async) 和 等待 (await) 中普遍存在堆栈难以阅读的现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于在 .NET 中输出异步的可阅读堆栈信息已经梦魂萦绕了5年...&lt;/p&gt;
&lt;p&gt;我直到 2017 年 10 月才意识到这个问题，好在 .NET Core 现在是完全开源的，所以我可以改变它。&lt;/p&gt;
&lt;p&gt;作为参考，请参阅文章底部的代码，它将会输出如下的异常堆栈：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__8.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;Main&amp;gt;d__1.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（为简洁起见，删除了行号，如 &lt;code&gt;in C:\Work\Exceptions\Program.cs:line 14&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;有时甚至可见更详细的胶水信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() 
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) 
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task) 
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟踪堆栈的一般用途是确定在源代码中发生错误的位置以及对应的路径。&lt;/p&gt;
&lt;p&gt;然而，现如今我们无法避免异步堆栈，同时还要面对很多无用的噪声（干扰）。&lt;/p&gt;
&lt;h3 id=&quot;pr-隐藏请求中的异常堆栈帧&quot;&gt;PR: “隐藏请求中的异常堆栈帧 ”&lt;/h3&gt;
&lt;p&gt;堆栈信息通常是从抛出异常的地方直接输出的。&lt;/p&gt;
&lt;p&gt;当异步函数抛出异常时，它会执行一些额外的步骤来确保响应，并且在延续执行（既定方法）之前会进行清理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-add6cd5bdb8443ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;在异步函数抛出异常&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当这些额外的步骤被添加到调用堆栈中时，它们不会对我们确定堆栈信息有任何帮助，因为它们实际上是在出现异常 &lt;strong&gt;之后&lt;/strong&gt; 执行。&lt;/p&gt;
&lt;p&gt;所以它们是非常嘈杂和重复的，对于确定代码在哪里出现异常上并没有任何额外的价值。&lt;/p&gt;
&lt;p&gt;实际产生的调用堆栈和输出的不一致:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-be349d0f420576a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;输出堆栈前&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在删除这些异常堆栈帧后（&lt;code&gt;隐藏请求中的异常堆栈帧&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14652&quot;&gt;dotnet/coreclr#14652&lt;/a&gt; ），跟踪堆栈开始变得平易近人：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__6.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;Main&amp;gt;d__0.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且输出的调用堆栈与实际的调用堆栈一致: &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-247414d00de0a170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一致的堆栈信息&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pr-删除异步的-edi-边界&quot;&gt;PR: “删除异步的 Edi 边界”&lt;/h3&gt;
&lt;p&gt;异步中的异常使用 &lt;strong&gt;ExceptionDispatchInfo&lt;/strong&gt; 类传播，这意味着着在每个连接点都会有这样的边界信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--- End of stack trace from previous location where exception was thrown ---&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这只是让你知道两部分调用堆栈已经合并，并且有个过渡。&lt;/p&gt;
&lt;p&gt;它如此频繁地出现在异步中，增加了很多噪音，并没有任何附加价值。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;删除异步的 Edi 边界&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15781&quot;&gt;dotnet/coreclr#15781&lt;/a&gt; 后 &lt;strong&gt;所有的&lt;/strong&gt; 堆栈信息变得有价值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__6.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__1.MoveNext()
   at Program.&amp;lt;Main&amp;gt;d__0.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pr-处理迭代器和异步方法中的堆栈&quot;&gt;PR: “处理迭代器和异步方法中的堆栈”&lt;/h3&gt;
&lt;p&gt;在上一节中，堆栈已经是干净了，但是要确定是什么情况，还是很困难的一件事。&lt;/p&gt;
&lt;p&gt;堆栈中包含着由 C# 编译器创建的异步状态机的基础方法签名，而不仅仅是（你的）源代码产生的。&lt;/p&gt;
&lt;p&gt;你可以确定方法的名称，但是如果不深入挖掘，则无法确定所调用的实际重载。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;处理迭代器和异步方法中的堆栈&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14655&quot;&gt;dotnet/coreclr#14655&lt;/a&gt; 之后，堆栈更接近原始来源：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pr-实现-keynotfoundexception-的堆栈追踪&quot;&gt;PR: “实现 KeyNotFoundException 的堆栈追踪”&lt;/h3&gt;
&lt;p&gt;因为有额外的奖励，我着手实现抛出 “ KeyNotFoundException ” 的堆栈追踪。&lt;/p&gt;
&lt;p&gt;Anirudh Agnihotry (&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15201&quot;&gt;@Anipik&lt;/a&gt;) 提出了 &lt;code&gt;实现 KeyNotFoundException 的堆栈追踪&lt;/code&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15201&quot;&gt;dotnet/coreclr#15201&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这意味着这个异常现在要告诉你哪个 key 找不到的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key '0' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支持的运行时以及相关进展&quot;&gt;支持的运行时以及相关进展&lt;/h3&gt;
&lt;p&gt;这些改进将在稍晚的时间发布到 Mono 上，并在下一个阶段发布。但是如果您使用的是较早的运行时版本 (.NET Core 1.0 - 2.0; .NET Framework 或 Mono) 想要获得一样的效果，需要使用 &lt;a href=&quot;https://github.com/benaadams/Ben.Demystifier&quot;&gt;Ben.Demystifier&lt;/a&gt; 提供的Nuget 包，并且在你的异常中使用 &lt;code&gt;.Demystify()&lt;/code&gt; 的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;catch (Exception e)
{
    Console.WriteLine(e.Demystify());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些改进将会产生与 C＃相得映彰的输出信息，最令人高兴的还是全都会被内置！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at TValue System.Collections.Generic.Dictionary&amp;lt;TKey, TValue&amp;gt;.get_Item(TKey key)
   at IEnumerable&amp;lt;int&amp;gt; Program.Sequence(int start)+MoveNext()
   at IEnumerable&amp;lt;int&amp;gt; Program.Sequence(int start, int end)+MoveNext()
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync()
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1, int v2)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1, int v2, int v3)
   at async Task Program.Main(string[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.NET Core 2.1 将成为 .NET Core 的最佳版本，原因说不完，这只是变得更美好的一小步...&lt;/p&gt;
&lt;h4 id=&quot;上面提到的触发异常的代码及对应的堆栈信息&quot;&gt;上面提到的触发异常的代码及对应的堆栈信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static Dictionary&amp;lt;int, int&amp;gt; _dict = new Dictionary&amp;lt;int, int&amp;gt;();

    static async Task Main(string[] args)
    {
        try
        {
            var value = await MethodAsync(1, 2, 3, 4);
            Console.WriteLine(value);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1, int v2, int v3)
        =&amp;gt; await MethodAsync(v0, v1, v2);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1, int v2)
        =&amp;gt; await MethodAsync(v0, v1);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1)
        =&amp;gt; await MethodAsync(v0);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0)
        =&amp;gt; await MethodAsync();

    static async Task&amp;lt;int&amp;gt; MethodAsync()
    {
        await Task.Delay(1000);

        int value = 0;
        foreach (var i in Sequence(0, 5))
        {
            value += i;
        }

        return value;
    }

    static IEnumerable&amp;lt;int&amp;gt; Sequence(int start, int end)
    {
        for (var i = start; i &amp;lt;= end; i++)
        {
            foreach (var item in Sequence(i))
            {
                yield return item;
            }
        }
    }

    static IEnumerable&amp;lt;int&amp;gt; Sequence(int start)
    {
        var end = start + 10;
        for (var i = start; i &amp;lt;= end; i++)
        {
            _dict[i] = _dict[i] + 1; // Throws exception
            yield return i;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 01 Feb 2018 13:24:00 +0000</pubDate>
<dc:creator>张很水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenug/p/8401356.html</dc:identifier>
</item>
<item>
<title>正则表达式（轻松入门级） - MS-LY</title>
<link>http://www.cnblogs.com/MaShuai666/p/8401348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaShuai666/p/8401348.html</guid>
<description>&lt;p&gt;前言：正则表达式又称为火星文，因为视觉上让人感觉很复杂。本文将会详细介绍正则表达式，初学者只要认真阅读过，定会有收获。&lt;/p&gt;
&lt;p&gt;1、正则的概念&lt;/p&gt;
&lt;p&gt;　　正则表达式（regular expression）是一个描述字符规则的对象。可以用来检查一个字符串是否含有某个子字符串，将匹配的子字符串替换或者从某个字符串中取出符合某个条件的子串等。&lt;/p&gt;
&lt;p&gt;　　为什么要用正则：前端往往有大量的表达数据校验工作，采用正则表达式会使得数据校验的工作量大大减轻。常用效果（邮箱、手机号、身份证号等等）。&lt;/p&gt;
&lt;p&gt;2、创建方式&lt;/p&gt;
&lt;p&gt;　　第一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过构造函数的方式&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; oReg = &lt;span&gt;new&lt;/span&gt; RegExp('study', 'i');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第二种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过语法糖（简写）的形式&lt;/span&gt;
 　&lt;span&gt;var&lt;/span&gt; oReg = /study/i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修饰符：&lt;/p&gt;
&lt;p&gt;　　i ：表示忽略大小写。&lt;/p&gt;
&lt;p&gt;　　g：表示全局匹配，查找所有匹配而非在找到第一个匹配后停止。&lt;/p&gt;
&lt;p&gt;　　m：多行匹配。&lt;/p&gt;
&lt;p&gt;3、正则对象方法&lt;/p&gt;
&lt;p&gt;　　test：检索字符串中指定的值。返回true或false。&lt;/p&gt;
&lt;p&gt;　　exec：用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果，如果未找到匹配，则返回值为null。&lt;/p&gt;
&lt;p&gt;　　下面我们来个举个列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 首先我来看test&lt;/span&gt;&lt;span&gt;
　　//&lt;/span&gt;&lt;span&gt;我们要在字符串str中找出符合Reg的规则的子字符串，符合则返回true，不符合则返回false&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1= /good/&lt;span&gt;ig;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg2= /goood/&lt;span&gt;ig;
    console.log(Reg1.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
    console.log(Reg2.test(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接下来我们再来看 exec&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果，如果未找到匹配，则返回值为null&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg= /good/&lt;span&gt;ig;
    console.log(Reg.exec(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good&quot;, index: 0, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, index: 5, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good&quot;, index: 29, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, index: 34, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注：如果没有指定g修饰符，那么每次匹配都是从头开始匹配，如果指定g修饰符以后，下次匹配则从上次匹配的结束位置开始匹配。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、字符串函数&lt;/p&gt;
&lt;p&gt;　　search：检索与正则表达式相匹配的值，返回字符串中第一个与正则表达式相匹配的子串的起始位置，如果没有找到则返回-1。&lt;/p&gt;
&lt;p&gt;　　match ：找到一个或多个正则表达式的匹配。&lt;/p&gt;
&lt;p&gt;　　replace：替换与正则表达式匹配的子串。&lt;/p&gt;
&lt;p&gt;　　split      ：把字符串分割为字符串数组。&lt;/p&gt;
&lt;p&gt;　　单看概念不容易理解，看看下面的小实列就一目了然&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;br/&gt;　　　var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg= /study/&lt;span&gt;ig;
     console.log(str.search(Reg));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
     console.log(str.match(Reg));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;study&quot;, &quot;study&quot;]&lt;/span&gt;
     console.log(str.replace(Reg,'aaaa'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Good good aaaa, Day day up! Good good aaaa&lt;/span&gt;
     console.log(str.split(Reg));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good good &quot;, &quot;, Day day up! Good good &quot;, &quot;&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、正则表达式构成&lt;/p&gt;
&lt;p&gt;　　正则表达式是由普通字符（列如字符a到z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。&lt;/p&gt;
&lt;p&gt;　　①元字符---限定符：&lt;/p&gt;
&lt;p&gt;　　*：匹配前面的子表达式零次或多次。&lt;/p&gt;
&lt;p&gt;　　+：匹配前面的子表达式一次或多次。&lt;/p&gt;
&lt;p&gt;　　？：匹配前面的子表达式零次或一次。&lt;/p&gt;
&lt;p&gt;　　{n}：匹配确定n次。&lt;/p&gt;
&lt;p&gt;　　{n,}：至少匹配n次。&lt;/p&gt;
&lt;p&gt;　　{n,m}：最少匹配n次且最多匹配m次。&lt;/p&gt;
&lt;p&gt;　　实列如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str ='gd god good goood gooood'&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1 =/go*d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;*：匹配前面的子表达式零次或多次&lt;/span&gt;
     console.log(str.match(Reg1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;gd&quot;, &quot;god&quot;, &quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg2 =/go+d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+：匹配前面的子表达式一次或多次&lt;/span&gt;
     console.log(str.match(Reg2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;god&quot;, &quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg3 =/go?d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;？：匹配前面的子表达式零次或一次&lt;/span&gt;
     console.log(str.match(Reg3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;gd&quot;, &quot;god&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg4 =/go{2}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n}：匹配确定n次&lt;/span&gt;
     console.log(str.match(Reg4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg5 =/go{2,}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n,}：至少匹配n次&lt;/span&gt;
     console.log(str.match(Reg5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;
     

     &lt;span&gt;var&lt;/span&gt; Reg6 =/go{1,3}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n, m}：最少匹配n次且最多匹配m次&lt;/span&gt;
     console.log(str.match(Reg6));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;god&quot;, &quot;good&quot;, &quot;goood&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　②元字符---字符匹配符：&lt;/p&gt;
&lt;p&gt;　　字符匹配符用于匹配某个或某些字符。&lt;/p&gt;
&lt;p&gt;　　[xyz]：字符集合。匹配所包含的任意一个字符。&lt;/p&gt;
&lt;p&gt;　　[^xyz]：负值字符集合。匹配未包含的任意字符。&lt;/p&gt;
&lt;p&gt;　　[a-z]：字符范围。匹配指定范围内的任意字符。&lt;/p&gt;
&lt;p&gt;　　[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。&lt;/p&gt;
&lt;p&gt;　　\d：匹配一个数字字符。&lt;/p&gt;
&lt;p&gt;　　\D：匹配一个非数字字符。&lt;/p&gt;
&lt;p&gt;　　\w：匹配包含下划线的任何单词字符。等价于[a-z0-9A-Z_]&lt;/p&gt;
&lt;p&gt;　　\W：匹配任何非单词字符。等价于[^a-z0-9A-Z_]&lt;/p&gt;
&lt;p&gt;　　\s：匹配任何空白字符。&lt;/p&gt;
&lt;p&gt;　　\S：匹配任何非空白字符。&lt;/p&gt;
&lt;p&gt;　　·：匹配除”\n”之外的任何单个字符。&lt;/p&gt;
&lt;p&gt;　　实列如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;var&lt;/span&gt; str = 'aiod acd abd add aed afd ahd $%#@ 12345678 asdfghh'&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1 = /a[abc]d/ig;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[xyz]：字符集合。匹配所包含的任意一个字符&lt;/span&gt;
     console.log(str.match(Reg1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;acd&quot;, &quot;abd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg2 = /a[^abc]d/ig;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[^xyz]：负值字符集合。匹配未包含的任意字符&lt;/span&gt;
     console.log(str.match(Reg2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg3 = /a[a-z]d/ig;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a-z]：字符范围。匹配指定范围内的任意字符&lt;/span&gt;
     console.log(str.match(Reg3)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg4 = /a[^a-e]d/ig;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符&lt;/span&gt;
     console.log(str.match(Reg4)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg5 = /\d+/ig;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  \d：匹配一个数字字符。&lt;/span&gt;
     console.log(str.match(Reg5));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;12345678&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg6 = /\D+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \D：匹配一个非数字字符&lt;/span&gt;
     console.log(str.match(Reg6));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod acd abd add aed afd ahd $%#@ &quot;, &quot; asdfghh&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg7 = /\w+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   \w：匹配包含数字,字母,下划线的任何单词字符,等价于[a-z0-9A-Z_]&lt;/span&gt;
     console.log(str.match(Reg7));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod&quot;, &quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;12345678&quot;, &quot;asdfghh&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg8 = /\W+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \W：匹配任何非单词字符。等价于[^a-z0-9A-Z_]&lt;/span&gt;
     console.log(str.match(Reg8));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; $%#@ &quot;, &quot; &quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg9 = /\s+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \s：匹配任何空白字符&lt;/span&gt;
     console.log(str.match(Reg9));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg10 = /\S+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \S：匹配任何非空白字符&lt;/span&gt;
     console.log(str.match(Reg10)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod&quot;, &quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;$%#@&quot;, &quot;12345678&quot;, &quot;asdfghh&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　③元字符---定位符：&lt;/p&gt;
&lt;p&gt;　　定位符可以将一个正则表达式固定在一行的开始或结束，也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。　　&lt;/p&gt;
&lt;p&gt;　　^：匹配输入字符串的开始位置。&lt;/p&gt;
&lt;p&gt;　　$：匹配输入字符串的结束位置。&lt;/p&gt;
&lt;p&gt;　　\b：匹配一个单词边界，也就是单词和空格间的位置。&lt;/p&gt;
&lt;p&gt;　　\B：匹配非单词边界。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ^：匹配输入字符串的开始位置。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str  ='123456'&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1  =/^\d+/&lt;span&gt;ig;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg2  =/\d/&lt;span&gt;ig;
    console.log(Reg1.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$：匹配输入字符串的结束位置。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str ='abcd789'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg =/.+\d{3}$/&lt;span&gt;ig;
    console.log(Reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; \b：限定单词以什么开头和结尾，\B：限定单位不以什么开头和结尾&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = 'good ogoodm goods sgoods'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg1 = /\bg\w+/&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg2 = /\w+d\b/&lt;span&gt;g;
console.log(str.match(reg1));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, &quot;goods&quot;]&lt;/span&gt;
console.log(str.match(reg2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;]&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; reg3 = /\Bg\w+/&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg4 = /\w+d\B/&lt;span&gt;g;
console.log(str.match(reg3));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;goodm&quot;, &quot;goods&quot;]&lt;/span&gt;
console.log(str.match(reg4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;ogood&quot;, &quot;good&quot;, &quot;sgood&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　④元字符---转义符&lt;/p&gt;
&lt;p&gt;　　\：用于匹配某些特殊字符（遇到特殊字符需要用反斜杠转义）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 特殊字符：. + * ? {} [] ^ $ \&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; str = '++++++-*/%'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /\++/&lt;span&gt;g;
    console.log(str.match(oReg));//[&quot;++++++&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　⑤元字符---选择匹配符&lt;/p&gt;
&lt;p&gt;　　|：可以匹配多个规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择匹配符&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = 'gooqd gaawd gwwsd'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /g(ooq|aaw)d/&lt;span&gt;g;
console.log(str.match(oReg));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;gooqd&quot;, &quot;gaawd&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　接下来是常用简单型检测案例&lt;/p&gt;
&lt;p&gt;　　1、手机号检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; reg = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、检测中文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串只能是中文&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /^[\u2E80-\u9FFF]+$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、身份证检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 18位身份证检测&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; oReg = /^\d{17}[\dxX]$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、日期检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期检测&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; oReg = /^\d{4}(\-|\/)\d{1,2}\1\d{1,2}$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、去除首尾空格&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去除首尾的空格&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; sVal =&lt;span&gt; oSpace.value;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /^\s+(\S*)\s+$/&lt;span&gt;;
console.log(sVal.replace(oReg, &lt;/span&gt;'$1'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6、检测文件格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测文件格式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /.+\.(jpg|jpeg|png|gif)$/i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、检测邮编&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测邮编&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /^\d{6}$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、过滤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = '小明说小强是混蛋，小强说他不是混蛋'&lt;span&gt;;
str.replace(&lt;/span&gt;/混蛋/g, '**');
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Thu, 01 Feb 2018 13:21:00 +0000</pubDate>
<dc:creator>MS-LY</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MaShuai666/p/8401348.html</dc:identifier>
</item>
<item>
<title>Android开发模板代码（一）——简单打开图库选择照片 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8401279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8401279.html</guid>
<description>&lt;p&gt;&lt;span&gt;首先，先贴上样本代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查权限&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkPermission() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ContextCompat.checkSelfPermission(&lt;span&gt;this&lt;/span&gt;, Manifest.permission.WRITE_EXTERNAL_STORAGE) !=&lt;span&gt; PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发现没有权限，调用requestPermissions方法向用户申请权限，requestPermissions接收三个参数，第一个是context，第二个是一个String数组，我们把要申请的权限
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名放在数组中即可，第三个是请求码，只要是唯一值就行&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            openAlbum();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有权限就打开相册&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openAlbum() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过intent打开相册，使用startactivityForResult方法启动actvity，会返回到onActivityResult方法，所以我们还得复写onActivityResult方法&lt;/span&gt;
        Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(&quot;android.intent.action.GET_CONTENT&quot;&lt;span&gt;);
        intent.setType(&lt;/span&gt;&quot;image/*&quot;&lt;span&gt;);
        startActivityForResult(intent, CHOOSE_PHOTO);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出窗口向用户申请权限&lt;/span&gt;
&lt;span&gt;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRequestPermissionsResult(&lt;span&gt;int&lt;/span&gt; requestCode, @NonNull String[] permissions, @NonNull &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] grantResults) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.onRequestPermissionsResult(requestCode, permissions, grantResults);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出授权的窗口，这条语句也可以删除，没有影响
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得了用户的授权结果，保存在grantResults中，判断grantResult中的结果来决定接下来的操作&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (requestCode) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grantResults.length &amp;gt; 0 &amp;amp;&amp;amp; grantResults[0] ==&lt;span&gt; PackageManager.PERMISSION_GRANTED) {
                    openAlbum();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;授权失败，无法操作&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode, Intent data) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityResult(requestCode, resultCode, data);
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (requestCode) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CHOOSE_PHOTO:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resultCode ==&lt;span&gt; RESULT_OK) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= 19&lt;span&gt;) {
                        handleImageOnkitKat(data);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高于4.4版本使用此方法处理图片&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        handleImageBeforeKitKat(data);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低于4.4版本使用此方法处理图片&lt;/span&gt;
&lt;span&gt;                    }
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    @TargetApi(&lt;/span&gt;19&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleImageOnkitKat(Intent data) {
        String imagePath &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Uri uri &lt;/span&gt;=&lt;span&gt; data.getData();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DocumentsContract.isDocumentUri(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, uri)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是document类型的uri，则通过document id处理&lt;/span&gt;
            String docId =&lt;span&gt; DocumentsContract.getDocumentId(uri);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;com.android.providers.media.documents&quot;&lt;span&gt;.equals(uri.getAuthority())) {
                String id &lt;/span&gt;= docId.split(&quot;:&quot;)[1];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析出数字格式的id&lt;/span&gt;
                String selection = MediaStore.Images.Media._ID + &quot;=&quot; +&lt;span&gt; id;
                imagePath &lt;/span&gt;=&lt;span&gt; getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;com.android,providers.downloads.documents&quot;&lt;span&gt;.equals(uri.getAuthority())) {
                Uri contentUri &lt;/span&gt;= ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;&lt;span&gt;), Long.valueOf(docId));
                imagePath &lt;/span&gt;= getImagePath(contentUri, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;content&quot;&lt;span&gt;.equalsIgnoreCase(uri.getScheme())) {
            imagePath &lt;/span&gt;= getImagePath(uri, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        displayImage(imagePath);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleImageBeforeKitKat(Intent data) {
        Uri uri &lt;/span&gt;=&lt;span&gt; data.getData();
        String imagePath &lt;/span&gt;= getImagePath(uri, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        displayImage(imagePath);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得图片路径&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getImagePath(Uri uri, String selection) {
        String path &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Cursor cursor &lt;/span&gt;= getContentResolver().query(uri, &lt;span&gt;null&lt;/span&gt;, selection, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内容提供器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (cursor != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cursor.moveToFirst()) {
                path &lt;/span&gt;= cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路径&lt;/span&gt;
&lt;span&gt;            }
        }
        cursor.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; path;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示图片&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; displayImage(String imagePath) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imagePath != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Bitmap bitImage &lt;/span&gt;= BitmapFactory.decodeFile(imagePath);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式化图片&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;
            mImage.setImageBitmap(bitImage);&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为imageView设置图片&lt;/span&gt;
&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Toast.makeText(MainActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;获取图片失败&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用说明：&lt;/h2&gt;
&lt;h3&gt;一、在AndroidManiFest文件中添加存储卡权限&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;span&gt;uses-permission &lt;span&gt;android:name=&lt;span&gt;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;二、通过findviewbyid找到Button或者是imageButton，并绑定监听事件&lt;/h3&gt;
&lt;h3&gt;三、复制上述的样本代码放在onClick事件下面,同时，添加一个全局静态变量&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180201205735281-1437393461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四、在button或者是imageButton的点击事件调用checkPermission方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180201195347687-1728979997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;五、通过findviewbyid找到ImageView，修改display方法中的调用设置图片的对象名为实际项目中的imageView的对象名，详情可以看代码加红的部分，将mImage修改即可&lt;/h3&gt;
&lt;h2&gt;简单的逻辑介绍：&lt;/h2&gt;
&lt;p&gt;画了一张流程图，逻辑还是比较清晰的，这里就不做过多说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180201205240531-1898099913.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PS：其实还可以在最后面添加裁剪图片的操作，之后在设置图片，我上度娘搜索了资料，看得还是很懵逼，等研究透彻再做补充了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Stars-One/ChangePictureFromAlbum&quot; target=&quot;_blank&quot;&gt; Demo下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Feb 2018 13:18:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8401279.html</dc:identifier>
</item>
<item>
<title>开发人员的奋斗目标 - 一是二</title>
<link>http://www.cnblogs.com/1si2/p/devroad.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1si2/p/devroad.html</guid>
<description>&lt;div class=&quot;level1&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;作为开发人员或者其他技术人员，从一个新手变成一个熟手之后，就觉得自己应该差不多了，对于再度前进的方向会变得迷茫。很多开始人员缺乏稍微长远一点的规划，比如，问及开发人员：你两年之后希望和现在有什么区别。80%的开发人员会回答：我希望两年之后，技术比现在要好一些。这样的回答，只描述了量变，没有描述质变。也就是说，没有翻天覆地的变化。为了让我们开发人员及其他技术人员知道什么叫做质变，进而有一个新的目标，本文档尝试对质变这一问题予以说明，并就如何产生这样的质变提供一些建议。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;高级才是真正为自己开发&quot; class=&quot;sectionedit2&quot;&gt;高级才是真正为自己开发&lt;/h2&gt;
&lt;div class=&quot;level2&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;对于技术人员来讲，按照德雷福斯模型可以分为五级：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;新手：只能按照指令一步步地走。新手没有接触过当前行业，所以只能按照指令一步步地走完过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;初级（高级新手）：能够完成一个局部工作。不需要给出指令，只需要给出一个局部工作的目标，初级可以完成这一局部工作，但初级没有形成全局概念，不知道自己所做的内容在全局所占据的份量有多重。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;中级（胜任者）：能够完成全局工作。这一层面的技术人员，对于一个领域的方方页面都能够了解，在给定目标的情况下，可以独立完成一个项目，可以带人，不会频繁求助高级。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;高级（精通者）：具备主动性，能够根据环境纠正自己的目标和手段。高级能够站在一个中立的层面考虑什么应该做，什么不应该做，怎么样代价最小，需要权衡付出与收益。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;专家：凭直觉工作，每击必中要害。在长期的解决问题过程中，专家形成了丰富的经验积累，可以快速抓住问题的关键点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上的分级，有一个重要的分水岭——中级跨向高级。中级及以下（下称中级）都是为别人而开发，高级（下称高级）及以上都是为自己而开发。所以，在主动性，做的目的、手段方面，中级与高级都存在着本质的区别。以下就来看看这三方面的区别。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;由被动到主动&quot; class=&quot;sectionedit3&quot;&gt;由被动到主动&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;人做事的时候，有着内在的动力来推动。作为中级，事情都是由别人安排的，自己不愿意主动承担责任。类似于这样的说话方式，会出现在中级身上：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;怎么需求又变了，能不能把需求确定了再做&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这样做不行的，框架已经定好了，只能按那样的方式来做&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;我辛辛苦苦写的这么多代码，又白费了&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这个还是不要改了吧，改起来很难的，我担心出问题&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这个问题不是我这边出的，是XX那边的接口问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上可以看到，中级作为一个被动完成任务的状态，会尽量让事情少摊到自己身上。并且会多有抱怨，因为对于中级来讲，一个不断改变的需求产生的原因总是别人的原因，与自己无关，自己只是一个代码的实现者。我们可以看看高级对应的说话方式大概会是怎么样：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;这个需求为什么要改成这样，能跟我详细说明一下不，我看看是不是值得改一下&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;我跟架构组沟通一下，这样改一下应该可以让整个项目变得更加简单&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;我先做的这个原型，代价很小，我们已经确认了原型，现在我开始写代码做实现&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;我觉得这样改可以让整个项目更加简单，当然，直接一刀切会有很大的影响，我们看看怎么切过来&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这的确是个问题，我来跟进一下，找一下原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;高级作为一个主动解决问题的人，会考虑到业务方的需求，对所需要付出的代价做一些权衡，不会推脱问题，会将问题先收下来，进一步去找问题的原因，会尽量让一个项目变得简单可理解，勇于根据现实的改变来调整当前的目标和技术手段。&lt;/p&gt;
&lt;p&gt;从积极性方面来讲，一种主动积极的心态才能为自己创造更多的机会。中级被动的状态，把复杂的事情推脱掉，进而也阻断了自己解决复杂问题的机会，从而能力不能得到提升。中级会一个误区，认为可以自己通过看书，看视频来获得提升。但可以说，最有效的提升方式，就是通过实际地解决问题，让自己的能力得到提升。看书、看视频在能力提升方面起的作用是，在实际解决问题的过程中，会给一个思路，让人把问题给总结起来，加深对解决问题的理解，能够让解决特殊问题变为解决比较普遍的问题。&lt;/p&gt;
&lt;p&gt;比如，在使用docker的过程中，如果只是看看书，看看视频，是无法知道docker容器之间的网络交互的。只有实实在在地使用docker做出来有价值的结构，在做这个结构的过程中遇到问题，并且解决问题，个人才能知道docker容器的网络交互是怎么样的，再配合看书，看视频，就可以很好地理解网络交互为什么是这样。&lt;/p&gt;
&lt;p&gt;所以，如果中级没有在主动性方面有一个根本性的转变，中级就会停留在原地。同时，有了转变，就能够有着越来越多的机会提升自己，进而与中级快速拉开距离。这样的距离，就是一个分水岭，中级还是那个中级，但高级很快就不是那个高级了。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;完成任务到表达自我&quot; class=&quot;sectionedit4&quot;&gt;完成任务到表达自我&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;针对于同一个目标，中级与高级的处理方式有着不同的态度。中级是为了完成任务，所以接受到的目标越是清晰，越是不变，对自己来讲越是有利。实际上，我们所面对的大多数都是中级，这就迫使高级人员需要将目标描述得清晰、可视化。&lt;/p&gt;
&lt;p&gt;高级对待同一个目标的态度是，这又是一次提升自我我机会，我要挖掘这一次机会的所有价值。目标不清晰，没有关系，我可以通过沟通来将目标弄清楚，这样可以锻炼我的沟通能力。框架有问题，没有关系，我可以尝试着做一定的修改，看看是不是那样做可以简化项目，这可以锻炼我的抽象能力。我一定要将这个项目做得很完美，无论是用户体验，还是代码格式，我都要写好，这样才能挖掘这一次机会的所有价值。咦，我发现代码有很多是重复的，嗯，我需要写一个代码生成器，生成那些重复的代码。我发现所有的 Dao 都有 insert/update/delete/select 方法，我可以写一个通用的 Dao，利用 java 的继承机制，这些方法就不会再写了。达成目标，就是把我方方面面的想法都表现出来的过程。这就是高级的表达自我的过程。&lt;/p&gt;
&lt;p&gt;一个给定的项目，都有着现实的价值，也就是说，一个项目都有着对应的用户群体，做好一个项目，就是拿现实的、客观的评判标准来评判自己的想法是不是对的，自己做的事情是不是有价值的。中级不会考虑到这一个层面，所以中级只是简单地完成任务。高级则会考虑这个项目的价值在哪里，高级自己可以借助这一个项目过程印证自己的哪些想法。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;被工具使用到使用工具&quot; class=&quot;sectionedit5&quot;&gt;被工具使用到使用工具&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;25&quot;&gt;
&lt;p&gt;在确定目标之后，中级会使用自己熟悉的工具和手段来达成目标。中级作为一个胜任者，对于一个明确的目标，有着很熟悉的工具和手段，是可以完成目标的。同时， &lt;em&gt;中级的极限也就是针对具体的目标，采用熟悉的手段达成目标&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;高级对于一个目标的认知是，通过一个有价值的目标来确认自己的想法，所以不会受限于工具与手段，并且为了让自己的抽象能力得到提升，更愿意花时间去研究新工具、新手段，进而让解决问题的方式变得更加简单。高级会重视生产力这一概念，提升自己的生产能力。提升生产能力，主要就是提升个人使用工具的能力。&lt;/p&gt;
&lt;p&gt;抛开工具，人与人之间差别是不大的。人与人的差别大距离拉开，就在于不同的人使用的工具不同，或者对同一个工具的使用有效程度不同。这里要注意：工具除了包含了扩展行动能力的交通工具，扩展表现能力的PPT、Word，扩展编码速度的Eclipse、Idea等， &lt;em&gt;最重要的是，工具也包含了扩展思维能力的思维模式&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;实际上，人每使用一种新的工具，都要有与之相应的思维模式来匹配。比如，作为开发人员，不能用 Eclipse 的快捷键来对 Idea 起作用，要从 Eclipse 转到 Idea ，就需要把之前的一切思维习惯都改变掉。以下将介绍中级向高级转变的方法，本质上就是提供新的思维模式工具，让开发人员在使用新的思维模式工具的过程中，让自己产生改变。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;高级开发必做的事情&quot; class=&quot;sectionedit6&quot;&gt;高级开发必做的事情&lt;/h2&gt;
&lt;div class=&quot;level2&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;我们已经知道高级与中级是一个分水岭。中级的极限达到了，就会止步不前，同时，一旦转变思维，就会由中级变为高级，高级在解决每一个问题的时候，都得到锻炼和提升，从而与静止状态的中级渐行渐远。有很多思维模式，作为一个不断改变的高级会慢慢地发现新的思维模式，这里将介绍几个入高级大门的思维模式，请大家务必掌握这几种思维模式，在解决问题、沟通与交流的时候，可以试着实践以下几种思维模式。随着使用的次数增多，如同打字一样，多得成为了自己的潜意识，这就为自己在本质上产生改变建立了基础。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;建立溯因推理模型&quot; class=&quot;sectionedit7&quot;&gt;建立溯因推理模型&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;52&quot;&gt;
&lt;p&gt;关于推理，有两种主要方法：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;演绎法：规则+情境=结果&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;归纳法：情境+结果=规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两种方法，演绎是根据规则，再匹配满足规则的情境，进而得到结果。比如&lt;/p&gt;
&lt;p&gt;演绎，就是把一个抽象的规则使用具体地演绎（表达）出来。这就引发了一个问题——规则是怎么产生的？规则的产生，通常是由归纳法来产生的，归纳就是将多个相似的具体情境+结果进行抽象，进而得到规则，如：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;情境1：孔子是人&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;结果1：孔子要吃饭才能活&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;情境2：曹操是人&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;结果2：曹操要吃西瓜才能活&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：人都要通过吃来维持生存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是两种很常见的方法。有一种补充的方法如下：&lt;/p&gt;
&lt;p&gt;这种方法通常用于提供创造性的新思路，先拿之前的例子看看这一方法是怎么样的：&lt;/p&gt;
&lt;p&gt;这实际上就是拿情境来验证规则，结果——韩梅梅通过吃来维持生存，是不是因为规则——人都要通过吃来维持生存——这一规则发生了作用呢？那就看一下情境是不是匹配：韩梅梅是人——这一情境是不是成立。对于中级来讲，他们通常会把复杂的问题抛出去，自己不去解决，所以，无法应用这一思维模式来解决问题，进而会变得越来越不灵活。高级则会应用这一思维模式，在遇到一个问题的时候，充分尝试各种可能性，并最终找到解决问题的方式。比如，遇到这样的问题&lt;/p&gt;
&lt;p&gt;高级遇到这一问题的时候，大概一个一个按如下规则地去验证：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：本地网络有问题——情境：看看手机能不能上其它的网站&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：服务端域名解析出错——情境：ping 一下域名，看看是不是有问题&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：服务器停机了——情境：让运维登录一下服务，看看是不是停机了&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;规则：内存占用过高——情境：让运维看一下机器的资源占用情况，是不是内存、CPU占用过高&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：用户权限被调整了——情境：了解一下最近有没有做什么修改&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到，面对一个问题，高级会寻找各种规则，并使用情境来证明是否被相应的规则影响。这一个过程，激活了高级的思路，让高级把所有经历过的规则再一次提取出来，一一使用，相当于复习了所有可知的规则。在已知的规则被穷尽的时候，就要创造性地突破自己知道的规则，寻找更多的信息，产生新的规则。对于手机端没有取到数据这样的问题，可能最后只是无意识地在服务器上敲击一个命令：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
df -h
&lt;/pre&gt;
&lt;p&gt;然后意外地发现磁盘已经满了，然后进而尝试着删除几个文件，又可以取数据了，接下来很快磁盘又满了，问题又出现了。进而判断应该是磁盘满导致的。然后再深究，我们写的程序没有记录日志啊，怎么就磁盘满了呢？结果通过以下命令一层层地寻找大文件：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
du -sh *
&lt;/pre&gt;
&lt;p&gt;发现大文件原来是 out，然后又想了一想，昨天李雷说安装了一个什么监控，不会是这个监控打出来的日志文件吧，然后问一下李雷……&lt;/p&gt;
&lt;p&gt;通过这个过程，可以看到溯因推理可以让自己瞬间经历一次人生百态，把所有可能想到的问题都想到，必要时还需要创造性地构建规则，还要看运气……当这样的事情多了之后，类似的问题再度出现的时候，也许高级会是随口一说：是不是XXX有问题，然后一验证，果然是的。这就是专家，这就是凭直觉工作，这就是直接点中要害。但需要说明，没有反复多次的经历人生百态，反复多次地穷尽所有想法，是无法形成专家级别的直觉的。&lt;/p&gt;
&lt;p&gt;具体怎么操作呢？当遇到一个问题的时候，人通常的反应是这样的：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这个我没有遇到过，我不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;X工，你帮我看看，我这里出了这个问题&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;X工，我已经想了所有能够想到的办法，你指点一下吧&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;X工，这个问题，我觉得是这个原因引起的，你帮我改一个配置看看/你帮我重新部署一下看看&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么我不自己改配置/部署？我不知道怎么改/部署啊&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要把这样无意识的反应变为这样（注：以下是内心的独白，有些被系统屏蔽的话，的确是问题很烦人，真不想继续下去了）：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这个问题应该是这个原因引起的，我验证一下&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;我&lt;em&gt;，不是这个原因，我再看看是不是因为这个 - 我&lt;/em&gt;，又不是这个原因，是不是服务器有问题呢，重新部署服务器好麻烦哦，我先看看配置是不是可以改一下（评估付出与收益）&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;这个已经在用了，直接改配置影响很大，我&lt;em&gt;的要自己部署一个，真&lt;/em&gt;麻烦&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;晕，启动报错，看看是什么原因&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;我晕，还要下载另外一个依赖包&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;终于部署好了，我**&lt;em&gt;，还要不要人活啊，不是这个原因 - 已经搞了5个小时了，他&lt;/em&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;我&lt;em&gt;，真&lt;/em&gt;搞笑，原来就是配置文件上多加了一个 “/”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的解决问题过程，收益不在于最终的结果，而是挖掘了高级所有的能力。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;建立抽象-具体思维模型&quot; class=&quot;sectionedit8&quot;&gt;建立抽象-具体思维模型&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;抽象-具体的思维模型，与归纳-演绎推理相对应。这里提出这个模型，是把这一模型当作验证自己是否真的弄明白了一个事物的本质的工具来介绍。高级在解决问题的时候，不仅仅以找到问题的解决方案为目的，而是通过不同的人生百态经历，找到相似的东西，提炼相似的东西，在提炼的基础上再度进行抽象。比如：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;情境1：孔子是人&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;结果1：孔子要吃饭才能活&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;情境2：曹操是人&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;结果2：曹操要吃西瓜才能活&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot;&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;规则：人都要通过吃来维持生存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是第一个层面的抽象，进一步挖掘和提炼，可以得到更抽象的规则：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;动物都要能够吃来维持生存&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;动物和植物都要有吸收和排放&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;生物的本质就是新陈代谢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在描述一个规则的时候，又要针对不同理解层面的人，给出不同的具体解释，就是见人说人话，见鬼说鬼话。如果高级能够在抽象与具体两个层面做到越是深入，则高级越是能够以最小的代价记忆规则，同时又能够将最高层面的抽象规则自由应用于不同的场景。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;认识生产力概念&quot; class=&quot;sectionedit9&quot;&gt;认识生产力概念&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;40&quot;&gt;
&lt;p&gt;生产力，以直白的语言来描述就是，提高生产力的结果就是：减少投入，扩大产出。提高生产力的手段是：改变生产工具。需要再度说明 &lt;em&gt;工具包含了扩展思维能力的思维模式&lt;/em&gt; 。对于所有人而言，人的产出只可以分为两类：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;消费资料：生产出来的产品，是给别人使用和消耗的&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;生产资料：生产产品的时候所依赖的物质工具&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如，开发团员开发出来一个办公系统，给企业员工使用，这个办公系统，对于开发人员就是消费资料，对于企业来讲，就是生产资料。开发人员在开发办公系统的时候，所用到的技术框架，编码工具，电脑，服务器等，就是开发人员的生产资料，使用相应的生产资料又需要开发人员必备与生产资料相适应的思维模式。&lt;/p&gt;
&lt;p&gt;如果要提高开发人员的生产力，开发人员把时间都花在做项目，就相当于把时间消耗在使用既定的生产资料来得到产出。同时，也就没有时间打磨生产资料，让生产资料变得更加强大。从而使得开发人员的能力受限于相应的生产资料和相应的生产模式。所以我们要在生产资料方面做持续的投入，这种投入包含了工具的投入和思维模式改变的投入。&lt;/p&gt;
&lt;p&gt;比如，在我们现有的开发中，生产资料经历了 gnif1.0 gnif2.0 到目前的 gnif3.0 的变更，相应地，需要开发人员掌握三种框架所需要的思维模式。我们的开发环境由原来的手动打包变为现在的自动构建，与此同时，需要开发人员改变对打包的理解。&lt;/p&gt;
&lt;p&gt;对于高级来讲，高级会有意识地为生产资料留时间。或者说，极端一点，宁可加班多花时间把生产模式改变了，然后使用新的生产模式来做生产，也不愿意快速地为了完成任务而使用固定的模式低效地达成目标。高级的积累，就是生产资料的积累。&lt;/p&gt;
&lt;p&gt;比如， Emacs 作为一款好用的编辑器，在大多数情况下，它的生产力要高于一般的编辑器。比如，它可以：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为命令行终端，运行各种命令&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为文件管理器，移动、复制文件&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为笔记本，记录各种笔记&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为日历，对重要的事情做提醒&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为文档编辑器，可以很好的组织和规划文档&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为代码编辑器，可以对几乎所有代码进行高亮显示&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;作为Lisp的入门语言，让人接触一种表达能力更强的语言&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;如果有一些功能不存在/不如意，可以自己开发/修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的编辑器，是越用越高效，是值得让个人的思维模式与这样的工具匹配的。之所以越用越高效，就体现在它是生产资料的积累这一点。&lt;/p&gt;
&lt;p&gt;又如， Idea 作为能够更加快速智能提示的工具，比起 Eclipse 来讲，能够提升 Java 代码的编写速度，也是值得从 Eclipse 转向使用 Idea 的。&lt;/p&gt;
&lt;p&gt;高级心中的座右铭是：工欲善其事，必先利其器。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;由被灌输变为分享&quot; class=&quot;sectionedit10&quot;&gt;由被灌输变为分享&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;作为中级，眼界会受限于自己所使用的工具和模式，有些中级在完成特定目标的时候，遇到自己熟悉的工具手段，这时候他达成目标的速度有可能比起高级还要快。这个时候，中级会倾向于认为自己掌握的东西是一种绝活、必杀技，他是不愿意分享经验给大家的。作为高级，时时处于改变的状态，他们非常确信明天的自己比今天的自己懂得更多，所以有着将自己的经验分享出来的基础。也就是，中级认为资源是匮乏的，高级认为资源是丰足的。&lt;/p&gt;
&lt;p&gt;分享的过程，也是将想法拿出来的过程，这一过程可以有以下好处：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;让自己想法与别人的想法碰撞，得到更好的想法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;把自己的想法拿出来，让大家来印证，从而让自己的想法有更广泛的适用性&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;分享的同时，也为被分享创造了条件，个人可以免费获得自己经验不到的信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;高级会在适当的时候将自己的想法分享给高级，从而收获到更多。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;写在最后&quot; class=&quot;sectionedit11&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;对于技术人员，从中级转向高级，首先要从理念层面做出改变，由被动做事变为积极做事，主动沟通，提供有价值的想法，让自己的想法得到印证。其次要将文中提及的四种思维模式由有意识地去实践变为无意识地运用自如。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 11:25:00 +0000</pubDate>
<dc:creator>一是二</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1si2/p/devroad.html</dc:identifier>
</item>
<item>
<title>去哪儿网玩乐事业部-数据模式演进 - 李秋</title>
<link>http://www.cnblogs.com/liqiu/p/8399226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiu/p/8399226.html</guid>
<description>&lt;p&gt;一转眼在去哪儿网玩乐事业部工作快4年了，经历了数据团队的组建和发展，回顾一下整体过程，经历了很多坎坷，普通而不简单。下面是大事记&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2014年（系统搭建）：开发报表平台、接入HADOOP、搭建调度系统&lt;/li&gt;
&lt;li&gt;2015年（数据集市）：搭建数据集市、开发数据同步工具&lt;/li&gt;
&lt;li&gt;2016年（数据应用）：系统定价、多维分析&lt;/li&gt;
&lt;li&gt;2017年（数据重构）：重构底层、数据分级、元数据、数据质量&lt;/li&gt;
&lt;li&gt;2018年（数据化运营）：实时系统、用户画像、模型搭建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2014年组建数据团队，整体结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/153316/201801/153316-20180131170655968-1817454952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当时迅速区理解了业务，并区分出来了核心主题，并且主要工作是产出数据，也就是数据报表。 2014年大数据还是比较新鲜的，部门非常重视，配置了NB的产品和技术，老大在很多重要场合宣称部门要转向数据化运营，产品和运营的KPI由数据产考核，并且为此搭建了CRM系统。&lt;/p&gt;
&lt;p&gt;按理说数据团队应该策马奔腾迈向小康社会了。但是蜜月期很短，几个月后就逐步出现了问题。最主要的表现是BOSS、产品、运营看见的数据不准确、不一致、不及时....&lt;/p&gt;

&lt;p&gt;蜜月期过了之后，BOSS经常在重要场合表达对数据团队的失望，我记得非常清楚的话是：“你们知道我为了TMD数据团队背后做了多少努力吗？我咨询了XXX个公司，XXX说咱们的数据，TMD1个月就能搭起来”。或者是：“你们到底要做什么，难道就是一个提数的吗？好，你们就做一个提数的工具吧！”。当时的情况：&lt;a href=&quot;http://www.cnblogs.com/liqiu/p/4869748.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/liqiu/p/4869748.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重新审视了数据的问题之后，决心从底层做起，搭建数据集市（数据宽表）。效果确实很好，缓解了数据一致性、数据及时性、数据准确性的问题。大家对数据团队的期望基本稳定了，系统也随之稳定了下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/153316/201801/153316-20180131172443125-1508765834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 数据稳定之后，希望做一些有意思的东西出来，首先就是解决数据同步的问题，业界有sqoop、dataX，但是对于PG支持的不好，特别是PG的扩展属性，比如hstore支持的有限，所以决定自己开发。&lt;/p&gt;
&lt;h2&gt;1 数据同步&lt;/h2&gt;
&lt;p&gt;项目名称是synchronous，它的设计借鉴了DATAX的插件设计理念，DATAX的文档：&lt;a href=&quot;https://github.com/alibaba/DataX&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/DataX&lt;/a&gt;。synchronous和DATAX的技术上区别是：代码小巧，精炼，易懂易读，有兴趣的同学可以快速深入，读懂了synchronous有助于快速理解DATAX。&lt;/p&gt;
&lt;p&gt;下面偏重流程方面介绍一下synchronous：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择同步的双方：插件的好处就是扩展性强，可随时增加数据源&lt;/li&gt;
&lt;li&gt;CHECK元数据：至少两边的数据字段要一致&lt;/li&gt;
&lt;li&gt;选择数据分片：数据量可能很大，需要分片处理&lt;/li&gt;
&lt;li&gt;同步数据：采用多线程的生产者消费者模型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/153316/201802/153316-20180201095135875-154401361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;详细设计过程可见：&lt;a href=&quot;http://www.cnblogs.com/liqiu/p/4882821.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/liqiu/p/4882821.html&lt;/a&gt; ； 代码在：&lt;a href=&quot;https://github.com/autumn-star/synchronous&quot; target=&quot;_blank&quot;&gt;https://github.com/autumn-star/synchronous&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2 系统定价&lt;/h2&gt;
&lt;p&gt;去哪儿以前是taobao的模式，只提供平台和流量。后来有了自营产品，随着业务的发展，自营产品越来越多，定价就是问题了。按照一般的策略是保证利润率的情况下，比竞对低一点。&lt;/p&gt;
&lt;h2&gt;3 自动化接口&lt;/h2&gt;
&lt;p&gt;经常需要给外部提供数据，如果每个都写dao、dto、service和controller，开发和维护成本特别高，所以研发了一个系统，配置SQL直接吐出数据接口数据，比如一个接口需要统计一段时间每个产品的订单量和份数，那么数据表里面保存这样一个记录,主键id是1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;
  product_id, &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;产品id&lt;/span&gt;
  &lt;span&gt;SUM&lt;/span&gt;(quantity) &lt;span&gt;as&lt;/span&gt; quantity, &lt;span&gt;--&lt;/span&gt;&lt;span&gt;份数&lt;/span&gt;
  &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; order_num &lt;span&gt;--&lt;/span&gt;&lt;span&gt;订单量&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; table1
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; stat_date &lt;span&gt;between&lt;/span&gt; @{start_date} &lt;span&gt;and&lt;/span&gt;&lt;span&gt; @{end_date}
&lt;/span&gt;&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; product_id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问的时候，带着参数就可以，比如：url?id=1&amp;amp;start_date=2017-01-01&amp;amp;end_date=2017-10-01。这样就吐出了时间在2017-01-01~2017-10-01之间的数据。&lt;/p&gt;
&lt;h2&gt;4 多维&lt;/h2&gt;
&lt;p&gt;为了将开发从无休止的SQL需求中解救出来，搭建了多维系统，就是数据立方体。当时用的是saiku+kylin，可是saiku需要持久的前端投入，kylin对少量维度支持的还好，维度达到几十个之后就出现问题了，所以这个项目就暂定了。但是底层数据还在，我们转而推出一个页面转成SQL的简易方案（不支持上卷、下钻、跨天和图形对比），虽然交互性差，但由于成本极低，一直支持长尾的数据需求。&lt;/p&gt;

&lt;p&gt;年初遇到了一些问题，技术方面：1、部分数据产出延迟；2、维护成本高，人员流动性高；3、宽表不能完全满足需求，随之关联了几十上百张数据表；业务方面没有明确的收益预期；&lt;/p&gt;
&lt;p&gt;调研了携程、阿里的数据体系之后，决定先重新搭建数据仓库，解决提升数据质量和降低人力成本，然后再发展个性化应用。步骤如下：&lt;/p&gt;
&lt;h2&gt;1. 协调资源&lt;/h2&gt;
&lt;p&gt;所谓资源，就是要人和时间。向BOSS说明兄弟部门投入多少多少人力和时间达到了什么效果，反观咱们只有那么点点...当然由于众志成城、团结一心，可以只用XX成本就能达到那个效果...&lt;/p&gt;
&lt;p&gt;成功之后，自己也认识到了差距，确实起点比较低，历经N次电话会议，逐步理解了数据仓库的搭建方案和应用细节&lt;/p&gt;
&lt;h2&gt;2. 搭建仓库&lt;/h2&gt;
&lt;p&gt;首先选型，kimball还是inmon，区别就不多说了。选择的是Kimball，为了让运营和产品用的更方便，也产出了宽表，这样宽表可以覆盖90%的需求，宽表+维度表可以覆盖剩下的需求。 &lt;/p&gt;
&lt;p&gt;2017的数据仓库结构图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/153316/201802/153316-20180201165821671-711740183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. 维护&lt;/h2&gt;
&lt;p&gt;数据仓库要准确、及时的产出数据，由于数据分散人力有限，不可能保证所有数据都百分百符合预期，所以要对数据进行分级。首先BOSS关心的报表，以及依赖的数据表是一级重要，要实时的严格校验，这里叫强一致性校验，如果发现问题需要在任何时候电话+qt+邮件预警。财务和运营的KPI数据次之，白天qt+邮件预警即可，最后是其他的数据。&lt;/p&gt;
&lt;p&gt;数据仓库的迭代周期也很关键，业务主要使用的是宽表，我们总结了以往的经验后，发现业务经常遇到新需求就希望在宽表增加字段，避免关联的烦恼，随着字段的增加，又不控制必然会重新陷入到到自然演化体系的困局。所以采用的办法是建立一个原则：准确+常用。如果符合这个原则的属性，是以月为单位排期加入到宽表里面，这样宽表就有了生命力&lt;/p&gt;

&lt;p&gt;这是正在进行的，仅介绍一下愿景，随着精细化运营的来临，必然对数据提出更细致更及时的要求，那么以离线为主T-1的瓶颈更加凸显出来，所以要搭建实时的数据仓库。另外随着分析经验的积累，不能像以前那样粗狂的看报表，而要细分用户群，采用不同的策略，所以需要高质量的用户画像，那么今年会从实时+用户画像两个方面展开...&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 10:39:00 +0000</pubDate>
<dc:creator>李秋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiu/p/8399226.html</dc:identifier>
</item>
<item>
<title>ActiveMQ入门练习 - 小破孩123</title>
<link>http://www.cnblogs.com/AndroidJotting/p/8400390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AndroidJotting/p/8400390.html</guid>
<description>&lt;p&gt;　　ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。&lt;/p&gt;
&lt;p&gt;　　JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。&lt;/p&gt;
&lt;p&gt;　　JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JMS客户机发送消息。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.2265625&quot;&gt;　　本篇我将和大家一起分享一下Apache JMS的使用，ApacheMQ：&lt;a href=&quot;http://activemq.apache.org/&quot; target=&quot;_blank&quot;&gt;http://activemq.apache.org/&lt;/a&gt;，下载后解压，这里需要说明，使用之前请先配置Java环境变量。启动后打开浏览器输入：http://localhost:8161/admin，这里需要通过密码登录，默认用户名：admin 密码：admin（用户名密码是在conf/users.properties中配置的）&lt;/div&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/618613/201802/618613-20180201171531031-487635807.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　下面就是我们如何进行消息的发送和接收，这里有两种方式：点对点收发；发布订阅。下面我们就一一进行探讨。&lt;/p&gt;
&lt;p&gt;　　首先搭建一下测试环境，这里我通过Maven进行项目的创建，我们需要引入activemq的核心activemq-all-5.15.2.jar，以及单元测试&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;72.682942879705&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;activemq-all&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${active-mq-version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/junit/junit &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面我们就开始消息的收发，先来探讨一下点对点的消息收发：&lt;/p&gt;
&lt;p&gt;　　1、消息的发送&lt;/p&gt;
&lt;p&gt;　　原理上我们通过ConnectionFactory会话工厂 ---&amp;gt; 创建一个会话连接 ---&amp;gt; 通过会话连接创建一个会话线程 ---&amp;gt; 通过会话线程创建一个消息队列 ---&amp;gt; 通过会话线程和消息队列创建一个消息生产者（MessageProducer） ---&amp;gt; 最后由消息生产者进行消息的发送。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConnectionFactory factory;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话连接工厂&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Connection connection;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话连接&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Session session;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话接收或发送消息线程&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Destination destination;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MessageProducer messageProducer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息发送者&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过ActiveMQConnectionFactory创建会话工厂&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
factory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKER_URL);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话连接工厂&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置会话连接额度地址和用户名密码在（这里我使用的是默认的地址和用户名密码）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String USERNAME =&lt;span&gt; ActiveMQConnection.DEFAULT_USER;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PASSWORD =&lt;span&gt; ActiveMQConnection.DEFAULT_PASSWORD;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String BROKER_URL = ActiveMQConnection.DEFAULT_BROKER_URL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面封装了一下上面的过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * @Description 发送消息
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; queryName 消息队列名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; msg 消息内容
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     *
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 高尚
     * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
     * @date 创建时间：2018年1月31日 下午3:54:22
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; producerSendQueryMessage(&lt;span&gt;final&lt;/span&gt; String queryName, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String msg){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connection &lt;/span&gt;= factory.createConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话连接&lt;/span&gt;
            connection.start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动会话连接&lt;/span&gt;&lt;span&gt;
            session &lt;/span&gt;= connection.createSession(&lt;span&gt;true&lt;/span&gt;, Session.AUTO_ACKNOWLEDGE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话线程&lt;/span&gt;
            destination = session.createQueue(queryName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息队列&lt;/span&gt;
            messageProducer = session.createProducer(destination);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话生成者&lt;/span&gt;
            Message message = session.createTextMessage(msg);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息对象&lt;/span&gt;
            messageProducer.send(message);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
&lt;span&gt;            session.commit();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
            e.printStackTrace();
            flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; connection){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里单独说一下connection.createSession生成会话线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Session session =&lt;span&gt; connection.createSession(paramA,paramB);
paramA是设置事务，paramB是设置acknowledgment mode

paramA 取值有：
&lt;/span&gt;1、&lt;span&gt;true&lt;/span&gt;&lt;span&gt;：支持事务
为true时：paramB的值忽略， acknowledgment mode被jms服务器设置为SESSION_TRANSACTED 。 　
&lt;/span&gt;2、&lt;span&gt;false&lt;/span&gt;&lt;span&gt;：不支持事务 
为false时：paramB的值可为Session.AUTO_ACKNOWLEDGE、Session.CLIENT_ACKNOWLEDGE、DUPS_OK_ACKNOWLEDGE其中一个。

paramB 取值有：
&lt;/span&gt;1&lt;span&gt;、Session.AUTO_ACKNOWLEDGE：为自动确认，客户端发送和接收消息不需要做额外的工作。
&lt;/span&gt;2&lt;span&gt;、Session.CLIENT_ACKNOWLEDGE：为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会删除消息。 
&lt;/span&gt;3&lt;span&gt;、DUPS_OK_ACKNOWLEDGE：允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。在需要考虑资源使用时，这种模式非常有效。
&lt;/span&gt;4、SESSION_TRANSACTED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　到这里我们的消息发送模块就封装完成，下面我们看一下消息的接收：&lt;/p&gt;
&lt;p&gt;　　原理上我们通过ConnectionFactory会话工厂 ---&amp;gt; 创建一个会话连接 ---&amp;gt; 通过会话连接创建一个会话线程 ---&amp;gt; 通过会话线程创建一个消息队列 ---&amp;gt; 通过会话线程和消息队列创建一个消息消费者（MessageConsumer） ---&amp;gt; 最后由消息消费者进行消息获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /**&lt;/span&gt;&lt;span&gt;
     * @Description 接收消息队列中的消息
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; queryName 消息队列名称
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     *
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 高尚
     * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
     * @date 创建时间：2018年1月31日 下午4:24:14
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; consumerGetQueryMessage(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String queryName){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connection &lt;/span&gt;= factory.createConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话连接&lt;/span&gt;
            connection.start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动会话连接&lt;/span&gt;
            session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
            destination &lt;/span&gt;=&lt;span&gt; session.createQueue(queryName);
            messageConsumer &lt;/span&gt;=&lt;span&gt; session.createConsumer(destination);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                TextMessage message &lt;/span&gt;=&lt;span&gt; (TextMessage) messageConsumer.receive();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; message){
                    System.out.println(queryName&lt;/span&gt;+&quot;发送消息：&quot;+&lt;span&gt;message.getText());
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
            System.out.println(&quot;消费消息异常&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; connection){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后单独说一下messageConsumer.receive方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
messageConsumer.receive();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一直等到消息&lt;/span&gt;
messageConsumer.receive(1000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等到消息1秒钟&lt;/span&gt;
messageConsumer.receiveNoWait();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不等待消息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然这样的接收消息方式是不是感觉很low，当然我们还可以通过监听器来实现消息接收的监听（MessageListener），我们实现MessageListener接口，自定义消息接收监听器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Description 消息监听器
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 高尚
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @date 创建时间：2018年1月31日 下午4:52:36
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MsgListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MessageListener {
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 监听的会话队列
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String queryName;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message msg) {
        TextMessage textMsg &lt;/span&gt;=&lt;span&gt; (TextMessage) msg;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; textMsg){
                System.out.println(&lt;/span&gt;&quot;【&quot; + queryName + &quot;】发送的消息：&quot; +&lt;span&gt; textMsg.getText());
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
            e.printStackTrace();
            System.out.println(&lt;/span&gt;&quot;获取会话消息异常&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MsgListener(String queryName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.queryName =&lt;span&gt; queryName;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们需要简单修改一个消息接收策略：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /**&lt;/span&gt;&lt;span&gt;
     * @Description 通过Listener接收消息队列中的消息
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; queryName 消息队列名称
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     *
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 高尚
     * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
     * @date 创建时间：2018年1月31日 下午4:24:14
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumerGetQueryMessageListener(String queryName) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connection &lt;/span&gt;= factory.createConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建会话连接&lt;/span&gt;
            connection.start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动会话连接&lt;/span&gt;
            session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
            destination &lt;/span&gt;=&lt;span&gt; session.createQueue(queryName);
            messageConsumer &lt;/span&gt;=&lt;span&gt; session.createConsumer(destination);
            MsgListener msgListener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MsgListener(queryName);
            messageConsumer.setMessageListener(msgListener);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                Thread.sleep(&lt;/span&gt;10000&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
            System.out.println(&quot;消费消息异常&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; connection){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后我们一起看一下消息的发布和订阅，首先消息的发布和订阅与点点的消息收发基本一致，不同点在于会话线程的创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
destination = session.createTopic(queryName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息发布线程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其他部分一致，没有什么难度，这里不再阐述，大家可以自行测试。当然我也为大家提供了测试参考代码：&lt;a href=&quot;https://github.com/hpugs/ActiveMQ&quot; target=&quot;_blank&quot;&gt;https://github.com/hpugs/ActiveMQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　到这里关于ActiveMQ入门部分就和大家探讨完毕，如有错误还有指教。谢谢&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 01 Feb 2018 10:05:00 +0000</pubDate>
<dc:creator>小破孩123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AndroidJotting/p/8400390.html</dc:identifier>
</item>
</channel>
</rss>