<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习之类别不平衡问题 (2) —— ROC和PR曲线 - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/8592091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/8592091.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/massquantity/p/8550875.html&quot;&gt;机器学习之类别不平衡问题 (1) —— 各种评估指标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;机器学习之类别不平衡问题 (2) —— ROC和PR曲线&lt;/p&gt;
&lt;h3 id=&quot;完整代码&quot;&gt;&lt;a href=&quot;https://github.com/massquantity/Class-Imbalance&quot;&gt;完整代码&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;ROC曲线和PR（Precision - Recall）曲线皆为类别不平衡问题中常用的评估方法，二者既有相同也有不同点。本篇文章先给出ROC曲线的概述、实现方法、优缺点，再阐述PR曲线的各项特点，最后给出两种方法各自的使用场景。&lt;/p&gt;

&lt;h2 id=&quot;roc曲线&quot;&gt;ROC曲线&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192012324-716569783.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ROC曲线常用于二分类问题中的模型比较，主要表现为一种真正例率 (TPR) 和假正例率 (FPR) 的权衡。具体方法是在不同的分类阈值 (threshold) 设定下分别以TPR和FPR为纵、横轴作图。由ROC曲线的两个指标，&lt;span class=&quot;math inline&quot;&gt;\(TPR = \frac{TP}{P} = \frac{TP}{TP+FN}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(FPR = \frac{FP}{N} = \frac{FP}{FP+TN}\)&lt;/span&gt; 可以看出，当一个样本被分类器判为正例，若其本身是正例，则TPR增加；若其本身是负例，则FPR增加，因此ROC曲线可以看作是随着阈值的不断移动，所有样本中正例与负例之间的“对抗”。曲线越靠近左上角，意味着越多的正例优先于负例，模型的整体表现也就越好。&lt;/p&gt;

&lt;h2 id=&quot;auc-area-under-the-curve&quot;&gt;AUC (Area Under the Curve)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180318120925502-1195803259.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先看一下ROC曲线中的随机线，图中[0,0]到[1,1]的虚线即为随机线，该线上所有的点都表示该阈值下TPR=FPR，根据定义，&lt;span class=&quot;math inline&quot;&gt;\(TPR = \frac{TP}{P}\)&lt;/span&gt;，表示所有正例中被预测为正例的概率；&lt;span class=&quot;math inline&quot;&gt;\(FPR = \frac{FP}{N}\)&lt;/span&gt;，表示所有负例中被被预测为正例的概率。若二者相等，意味着无论一个样本本身是正例还是负例，分类器预测其为正例的概率是一样的，这等同于随机猜测（注意这里的“随机”不是像抛硬币那样50%正面50%反面的那种随机）。&lt;/p&gt;
&lt;p&gt;上图中B点就是一个随机点，无论是样本数量和类别如何变化，始终将75%的样本分为正例。&lt;/p&gt;
&lt;p&gt;ROC曲线围成的面积 (&lt;strong&gt;即AUC&lt;/strong&gt;)可以解读为：从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。可以看到位于随机线上方的点(如图中的A点)被认为好于随机猜测。在这样的点上TPR总大于FPR，意为正例被判为正例的概率大于负例被判为正例的概率。&lt;/p&gt;
&lt;p&gt;从另一个角度看，由于画ROC曲线时都是先将所有样本按分类器的预测概率排序，所以AUC反映的是分类器对样本的排序能力，依照上面的例子就是A排在B前面的概率。AUC越大，自然排序能力越好，即分类器将越多的正例排在负例之前。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ROC曲线的绘制方法&lt;/strong&gt;：假设有P个正例，N个反例，首先拿到分类器对于每个样本预测为正例的概率，根据概率对所有样本进行逆序排列，然后将分类阈值设为最大，即把所有样本均预测为反例，此时图上的点为 (0,0)。然后将分类阈值依次设为每个样本的预测概率，即依次将每个样本划分为正例，如果该样本为真正例，则TP+1，即&lt;span class=&quot;math inline&quot;&gt;\(TPR + \frac{1}{P}\)&lt;/span&gt; ; 如果该样本为负例，则FP+1，即&lt;span class=&quot;math inline&quot;&gt;\(FPR + \frac{1}{N}\)&lt;/span&gt;。最后的到所有样本点的TPR和FPR值，用线段相连。&lt;/p&gt;&lt;p&gt;下面进行实现，先模拟生成一个正例：负例=10：1的数据集，用PCA降到2维进行可视化：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;X,y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; make_classification(n_samples&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;, n_features&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, n_informative&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,
                         n_redundant&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, n_classes&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, n_clusters_per_class&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
                         weights&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;fl&quot;&gt;0.9&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;], flip_y&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2018&lt;/span&gt;)

sns.lmplot(&lt;span class=&quot;st&quot;&gt;&quot;pca_a&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;pca_b&quot;&lt;/span&gt;,data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;X_pca, hue&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;y&quot;&lt;/span&gt;, fit_reg&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;, markers&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;&quot;o&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;x&quot;&lt;/span&gt;],size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,aspect&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.5&lt;/span&gt;,legend&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
plt.legend(fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;,bbox_to_anchor&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.98&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.6&lt;/span&gt;),edgecolor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'r'&lt;/span&gt;)   
plt.xlabel(&lt;span class=&quot;st&quot;&gt;&quot;axis_1&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;&quot;axis_2&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192101943-919864468.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将数据分成训练集和测试集，使用Logistic Regression和Random Forest作图：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;kf &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; StratifiedKFold(n_splits&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; train_index, test_index &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; kf.split(X,y):
    X_train, X_test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; X[train_index], X[test_index]
    y_train, y_test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y[train_index], y[test_index] 
    
lr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; LogisticRegression()
lr.fit(X_train,y_train)
pos_prob_lr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lr.predict_proba(X_test)[:,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;co&quot;&gt;# Logistic Regression的正例预测概率&lt;/span&gt;

rf &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; RandomForestClassifier(random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt;)
rf.fit(X_train,y_train)
pos_prob_rf &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; rf.predict_proba(X_test)[:,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;co&quot;&gt;# Random Forest的正例预测概率&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_roc(pos_prob,y_true):
    pos &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_true[y_true&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
    neg &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_true[y_true&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
    threshold &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.sort(pos_prob)[::&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]        &lt;span class=&quot;co&quot;&gt;# 按概率大小逆序排列&lt;/span&gt;
    y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_true[pos_prob.argsort()[::&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]]
    tpr_all &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; fpr_all &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
    tpr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; fpr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    x_step &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;float&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(neg))
    y_step &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;float&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(pos))
    y_sum &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;                                  &lt;span class=&quot;co&quot;&gt;# 用于计算AUC&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(threshold)):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; y[i] &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
            tpr &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; y_step
            tpr_all.append(tpr)
            fpr_all.append(fpr)
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            fpr &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; x_step
            fpr_all.append(fpr)
            tpr_all.append(tpr)
            y_sum &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; tpr
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; tpr_all,fpr_all,y_sum&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;x_step         &lt;span class=&quot;co&quot;&gt;# 获得总体TPR，FPR和相应的AUC&lt;/span&gt;

tpr_lr,fpr_lr,auc_lr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_roc(pos_prob_lr,y_test)  
tpr_rf,fpr_rf,auc_rf &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_roc(pos_prob_rf,y_test)

plt.figure(figsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;))
plt.plot(fpr_lr,tpr_lr,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Logistic Regression (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_lr),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.plot(fpr_rf,tpr_rf,&lt;span class=&quot;st&quot;&gt;'g'&lt;/span&gt;,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Random Forest (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_rf),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.xlabel(&lt;span class=&quot;st&quot;&gt;&quot;False Positive Rate&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;&quot;True Positive Rate&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.title(&lt;span class=&quot;st&quot;&gt;&quot;ROC Curve&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.legend(loc&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;lower right&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192113928-1531049464.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;roc曲线的优点&quot;&gt;ROC曲线的优点&lt;/h2&gt;
&lt;p&gt;放一张混淆矩阵图可能看得更清楚一点 :&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180319202049237-1345985044.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;兼顾正例和负例的权衡。因为TPR聚焦于正例，FPR聚焦于与负例，使其成为一个比较均衡的评估方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;ROC曲线选用的两个指标，&lt;span class=&quot;math inline&quot;&gt;\(TPR = \frac{TP}{P} = \frac{TP}{TP+FN}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(FPR = \frac{FP}{N} = \frac{FP}{FP+TN}\)&lt;/span&gt;，都不依赖于具体的类别分布。&lt;/p&gt;&lt;p&gt;注意TPR用到的TP和FN同属P列，FPR用到的FP和TN同属N列，所以即使P或N的整体数量发生了改变，也不会影响到另一列。也就是说，即使正例与负例的比例发生了很大变化，ROC曲线也不会产生大的变化，而像Precision使用的TP和FP就分属两列，则易受类别分布改变的影响。&lt;/p&gt;&lt;p&gt;参考文献 [1] 中举了个例子，负例增加了10倍，ROC曲线没有改变，而PR曲线则变了很多。作者认为这是ROC曲线的优点，即具有鲁棒性，在类别分布发生明显改变的情况下依然能客观地识别出较好的分类器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192137987-2118846259.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我们来验证一下是不是这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;X_test_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.vstack((X_test,X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;],X_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]))
y_test_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(y_test.tolist() &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; y_test[y_test&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].tolist()&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;# 10x倍负例的测试集&lt;/span&gt;

pos_prob_lr_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lr.predict_proba(X_test_dup)[:,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
pos_prob_rf_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; rf.predict_proba(X_test_dup)[:,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
tpr_lr_dup,fpr_lr_dup,auc_lr_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_roc(pos_prob_lr_dup,y_test_dup)
tpr_rf_dup,fpr_rf_dup,auc_rf_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_roc(pos_prob_rf_dup,y_test_dup)

plt.figure(figsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;))
plt.plot(fpr_lr_dup,tpr_lr_dup,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Logistic Regression (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_lr_dup),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.plot(fpr_rf_dup,tpr_rf_dup,&lt;span class=&quot;st&quot;&gt;'g'&lt;/span&gt;,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Random Forest (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_rf_dup),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.xlabel(&lt;span class=&quot;st&quot;&gt;&quot;False Positive Rate&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;&quot;True Positive Rate&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.title(&lt;span class=&quot;st&quot;&gt;&quot;ROC Curve&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.legend(loc&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;lower right&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192149657-529714444.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Logistic Regression的曲线几乎和先前一模一样，但Random Forest的曲线却产生了很大变化。个中原因看一下两个分类器的预测概率就明白了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pos_prob_lr_dup[:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;]
array([&lt;span class=&quot;fl&quot;&gt;0.15813023&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.12075471&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.02763748&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.00983065&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.06201179&lt;/span&gt;,
       &lt;span class=&quot;fl&quot;&gt;0.04986294&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.09926128&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.05632981&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.15558692&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.05856262&lt;/span&gt;,
       &lt;span class=&quot;fl&quot;&gt;0.08661055&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.00787402&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.1617371&lt;/span&gt; , &lt;span class=&quot;fl&quot;&gt;0.04063957&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.14103442&lt;/span&gt;,
       &lt;span class=&quot;fl&quot;&gt;0.07734239&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0213237&lt;/span&gt; , &lt;span class=&quot;fl&quot;&gt;0.03968638&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.03771455&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.04874451&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pos_prob_rf_dup[:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;]
array([&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. ,
       &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. , &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;. ])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到Logistic Regression的预测概率几乎没有重复，而Random Forest的预测概率则有很多重复，因为Logistic Regression可以天然输出概率，而Random Forest本质上属于树模型，只能输出离散值。scikit-learn中树模型的predict_proba() 方法表示的是一个叶节点上某一类别的样本比例，但只显示小数点后一位，致使大量样本的预测概率都一样。当画ROC曲线时需要先将样本根据预测概率排序，若几个样本的概率一样，则只能按原来的顺序排列。上面的操作就是将所有累加的负例都排在了原始数据后面，致使正例的顺序都很靠前，造成Random Forest的结果好了不少。解决办法就是将所有样本随机排序，就能产生和原来差不多的ROC曲线了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;index &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.random.permutation(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(X_test_dup))
X_test_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; X_test_dup[index]
y_test_dup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_test_dup[index]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;roc曲线的缺点&quot;&gt;ROC曲线的缺点&lt;/h2&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上文提到ROC曲线的优点是不会随着类别分布的改变而改变，但这在某种程度上也是其缺点。因为负例N增加了很多，而曲线却没变，这等于产生了大量FP。像信息检索中如果主要关心正例的预测准确性的话，这就不可接受了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在类别不平衡的背景下，负例的数目众多致使FPR的增长不明显，导致ROC曲线呈现一个过分乐观的效果估计。ROC曲线的横轴采用FPR，根据FPR = &lt;span class=&quot;math inline&quot;&gt;\(\frac{FP}{N}\)&lt;/span&gt; = &lt;span class=&quot;math inline&quot;&gt;\(\frac{FP}{FP+TN}\)&lt;/span&gt;，当负例N的数量远超正例P时，FP的大幅增长只能换来FPR的微小改变。结果是虽然大量负例被错判成正例，在ROC曲线上却无法直观地看出来。（当然也可以只分析ROC曲线左边一小段）&lt;br/&gt;举个例子，假设一个数据集有正例20，负例10000，开始时有20个负例被错判，&lt;span class=&quot;math inline&quot;&gt;\(FPR = \frac{20}{20+9980} = 0.002\)&lt;/span&gt;，接着又有20个负例错判，&lt;span class=&quot;math inline&quot;&gt;\(FPR_{2} = \frac{40}{40+9960} =0.004\)&lt;/span&gt;，在ROC曲线上这个变化是很细微的。而与此同时Precision则从原来的0.5下降到了0.33，在PR曲线上将会是一个大幅下降。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;pr-precision-recall-曲线&quot;&gt;PR (Precision Recall) 曲线&lt;/h2&gt;
&lt;p&gt;PR曲线展示的是Precision vs Recall的曲线，PR曲线与ROC曲线的相同点是都采用了TPR (Recall)，都可以用AUC来衡量分类器的效果。不同点是ROC曲线使用了FPR，而PR曲线使用了Precision，因此PR曲线的两个指标都聚焦于正例。类别不平衡问题中由于主要关心正例，所以在此情况下PR曲线被广泛认为优于ROC曲线。&lt;/p&gt;
&lt;p&gt;PR曲线的绘制与ROC曲线类似，PR曲线的AUC面积计算公式为： &lt;span class=&quot;math display&quot;&gt;\[\sum_{n}(R_n-R_{n-1})P_n\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面仍使用上面的数据集画图：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_pr(pos_prob,y_true):
    pos &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_true[y_true&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
    threshold &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.sort(pos_prob)[::&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
    y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; y_true[pos_prob.argsort()[::&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]]
    recall &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [] &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; precision &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    tp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; fp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    auc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(threshold)):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; y[i] &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
            tp &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            recall.append(tp&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(pos))
            precision.append(tp&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;(tp&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;fp))
            auc &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; (recall[i]&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;recall[i&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;precision[i]
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            fp &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            recall.append(tp&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(pos))
            precision.append(tp&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;(tp&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;fp))
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; precision,recall,auc

precision_lr,recall_lr,auc_lr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_pr(pos_prob_lr,y_test)
precision_rf,recall_rf,auc_rf &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_pr(pos_prob_rf,y_test)

plt.figure(figsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;))
plt.plot(recall_lr,precision_lr,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Logistic Regression (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_lr),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.plot(recall_rf,precision_rf,label&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Random Forest (AUC: {:.3f})&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(auc_rf),linewidth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
plt.xlabel(&lt;span class=&quot;st&quot;&gt;&quot;Recall&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;&quot;Precision&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
plt.title(&lt;span class=&quot;st&quot;&gt;&quot;Precision Recall Curve&quot;&lt;/span&gt;,fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;)
plt.legend(fontsize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1188231/201803/1188231-20180317192232386-1930593348.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到上文中ROC曲线下的AUC面积在0.8左右，而PR曲线下的AUC面积在0.68左右，类别不平衡问题中ROC曲线确实会作出一个比较乐观的估计，而PR曲线则因为Precision的存在会不断显现FP的影响。&lt;/p&gt;

&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li&gt;ROC曲线由于兼顾正例与负例，所以适用于评估分类器的整体性能，相比而言PR曲线完全聚焦于正例。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果有多份数据且存在&lt;strong&gt;不同&lt;/strong&gt;的类别分布，比如信用卡欺诈问题中每个月正例和负例的比例可能都不相同，这时候如果只想单纯地比较分类器的性能且剔除类别分布改变的影响，则ROC曲线比较适合，因为类别分布改变可能使得PR曲线发生变化时好时坏，这种时候难以进行模型比较；反之，如果想测试不同类别分布下对分类器的性能的影响，则PR曲线比较适合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果想要评估在&lt;strong&gt;相同&lt;/strong&gt;的类别分布下正例的预测情况，则宜选PR曲线。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;类别不平衡问题中，ROC曲线通常会给出一个乐观的效果估计，所以大部分时候还是PR曲线更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最后可以根据具体的应用，在曲线上找到最优的点，得到相对应的precision，recall，f1 score等指标，去调整模型的阈值，从而得到一个符合具体应用的模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference:&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Tom Fawcett. &lt;a href=&quot;https://ccrma.stanford.edu/workshops/mir2009/references/ROCintro.pdf&quot;&gt;&lt;em&gt;An introduction to ROC analysis&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jesse Davis, Mark Goadrich0 &lt;a href=&quot;http://pages.cs.wisc.edu/~jdavis/davisgoadrichcamera2.pdf&quot;&gt;&lt;em&gt;The Relationship Between Precision-Recall and ROC Curves&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Haibo He, Edwardo A. Garcia. &lt;a href=&quot;http://www.ele.uri.edu/faculty/he/PDFfiles/ImbalancedLearning.pdf&quot;&gt;&lt;em&gt;Learning from Imbalanced Data&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;周志华. 《机器学习》&lt;/li&gt;
&lt;li&gt;Pang-Ning Tan, etc. &lt;em&gt;Introduction to Data Mining&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stats.stackexchange.com/questions/7207/roc-vs-precision-and-recall-curves&quot; class=&quot;uri&quot;&gt;https://stats.stackexchange.com/questions/7207/roc-vs-precision-and-recall-curves&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Mon, 19 Mar 2018 23:12:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/massquantity/p/8592091.html</dc:identifier>
</item>
<item>
<title>数据结构-优先队列 接口定义与实现分析 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/8594182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/8594182.html</guid>
<description>&lt;p&gt;顾名思义，优先队列将数据按优先级顺序排列。一个优先队列由许多有序的元素构成，优先级最高的元素可以有效而快速的确定。&lt;/p&gt;
&lt;p&gt;例如，用来做负载均衡的服务器，当连接请求到达时，优先队列可以告知当前哪台服务器是处理此连接请求最佳的服务器。一般情况下，最空闲的服务器获取的优先级最高，因为它可以最好地处理服务请求。&lt;/p&gt;
&lt;h3&gt;优先队列的接口定义&lt;/h3&gt;
&lt;p&gt;优先队列的基本接口包含，1、初始化优先队列；2、销毁优先队列；3、向优先队列中插入一个元素；4、提取优先队列顶部的元素（释放）；5、获取优先队列中优先级最高的元素（不释放）；6、统计优先队列中元素的数量。&lt;/p&gt;
&lt;p&gt;我们以名称pqueue作为优先级队列的名称，下面是各接口的定义：&lt;/p&gt;
&lt;p&gt;pqueue_init&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void pqueue_init(PQueue *pqueue, int (*compare)(const void *key1,const void *key2), void (*destroy)(void *data));&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;初始化优先队列pqueue。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在对优先队列进行其他操作之前必须先调用初始化函数。在优先队列形成过程中，&lt;strong&gt;函数指针compare&lt;/strong&gt;会被优先队列的各种操作调用，用来维持优先队列的堆特性。如果队列中较大的值有较高的优先级，那么当key1&amp;gt;key2时，函数返回1；当key1=key2时，函数返回-1。如果相反，队列中较小的值有较高的优先级，那么函数的返回结果相反。&lt;strong&gt;参数destroy是另一个函数指针&lt;/strong&gt;，通过调用pqueue_destroy来释放动态分配的内存空间。例如，如果一个优先队列包含使用malloc动态分配内存的数据，那么当销毁队列时，destroy会调用free来释放内存空间。当一个结构化数据包含若干动态分配内存的数据成员时，destroy应该指向一个用户自定义的析构函数来释放数据成员和结构本身的内存空间。如果优先队列中的数据不需要释放，那么destroy应指向NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;
&lt;p&gt;pqueue_destory&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void pqueue_destroy(PQueue *pqueue);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;销毁优先队列pqueue&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在调用pqueue_destroy之后不再允许进行其他操作，除非再次调用pqueue_init。&lt;/p&gt;
&lt;p&gt;pqueue_destory会从优先队列中提取所有的元素，在删除每个元素的同时调用pqueue_init中destroy所指向的销毁函数（前提是此函数指针不为NULL）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt; O(n)，其中n是优先队列中结点的个数。&lt;/p&gt;
&lt;p&gt;pqueue_insert&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int pqueue_insert(PQueue *pqueue, const void *data);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果插入元素成功，返回0，否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：向优先队列pqueue中插入一个元素。新元素包含一个指向data的指针，只要结点仍然存在于优先队列中，此指针就一直有效。与data相关的内存空间由函数的调用者来管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(lg n)，其中n是优先队列中结点的个数。&lt;/p&gt;
&lt;p&gt; pqueue_extract&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int pqueue_extract(PQueue *pqueue, void **data);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果元素提取成功返回0；否则返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：从优先队列pqueue中提取优先队列顶部的元素。返回时，data指向已提取元素中存储的数据。与data有关的内存空间将由函数的调用者来管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(lg n)，其中n是优先队列中结点的个数。&lt;/p&gt;
&lt;p&gt;pqueue_peek&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void *pqueue_peek(const PQueue *pqueue);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：优先队列中优先级最高的元素；如果队列为空，那么返回NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：获取优先队列pqueue中优先级最高元素的宏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;
&lt;p&gt;pqueue_size&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int pqueue_size(const PQueue *pqueue);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：优先队列中的结点个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：获取优先队列pqueue结点个数的宏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;
&lt;h3&gt;优先队列的实现与分析&lt;/h3&gt;
&lt;p&gt;实现优先队列最常用而简单的方法就是维护一个有序数据集。优先级最高的元素位于数据集的头部。然而，插入或提取元素之后必须重新排列数据集，这是一个复杂度为o(n)的操作（n为数据集元素的个数）。&lt;/p&gt;
&lt;p&gt;因此，更好的方法就是 &lt;strong&gt;用一个局部有序的堆来实现优先队列&lt;/strong&gt;。位于堆顶部的结点优先级最高，而且插入或提取数据之后重新排列堆的复杂度仅为o(lg n)。&lt;/p&gt;
&lt;p&gt;优先队列与堆的操作基本相同，优先队列仅仅比堆多了一个接口而已。因此，我们可以通过 &lt;strong&gt;typedef Heap PQueue&lt;/strong&gt; 这种简单的方式来实现一个优先队列。&lt;/p&gt;
&lt;p&gt;为了实现这些接口，我们只需要将优先队列的相应操作定义成堆的操作就可以了。优先队列中独有的操作pqueue_peek与pqueue_extract相类似，只是&lt;strong&gt;pqueue_peek返回队列中优先级最高的元素而不删除它。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：优先队列的头文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;pqueue.h&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#ifndef PQUEUE_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; PQUEUE_H&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;heap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将优先队列作为堆实现&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef Heap PQueue;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;优先队列的公共接口&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; pqueue_init heap_init
&lt;span&gt;#define&lt;/span&gt; pqueue_destroy heap_destroy
&lt;span&gt;#define&lt;/span&gt; pqueue_insert heap_insert
&lt;span&gt;#define&lt;/span&gt; pqueue_extract heap_extract 

&lt;span&gt;#define&lt;/span&gt; pqueue_peek(pqueue)((pqueue)-&amp;gt;tree == NULL ? NULL : (pqueue)-&amp;gt;tree[0])

&lt;span&gt;#define&lt;/span&gt; pqueue_size heap_size
&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PQUEUE_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 优先队列的示例：包裹分拣&lt;/h3&gt;
&lt;p&gt;很多大型快递公司每天要处理数以百万计的包裹，将这些包裹按照优先级排序是非常重要的。这在投递的人力、物力有限的情况下尤为重要。在这种情况下，具有高优先级的包裹往往优先投递。例如，一架用于投递服务的飞机，如果它每天只跑一个往返，那么那些要求第二天就要投递的包裹在当天就应该将上飞机。&lt;/p&gt;
&lt;p&gt;确保包裹能够按照正确的优先级顺序送达指定目的地的方法是，将包裹的信息按照正确的优先级顺序存储在一个优先队列中。包裹分拣时，首先扫描包裹的信息，并将信息录入系统中。对于每个扫描过的包裹，其信息将会按照优先级顺序存储到队列中，以便包裹在系统中传递时，具有最高优先级的包裹将首先传递。&lt;/p&gt;
&lt;p&gt;示例列举两个函数get_parcel和put_parcel，它们都是用来操作一个包含包裹信息parcel的优先队列。parcel在parcel.h中定义，此处不再列举。一个分拣器调用put_parcel将一个包裹信息加载到系统中。parcel中传递给put_parcel的一个成员变量代表优先序号。put_parcel将一个包裹插入一个优先队列中，并按照优先级找到它在队列中的位置。当分拣器准备在系统中传递下一个包裹时，它会调用get_parcel。函数get_parcel会取到最高优先级的包裹，这样就能保证包裹按照正确的顺序处理。&lt;/p&gt;
&lt;p&gt;优先队列是管理包裹的最佳方法，因为某些场合，我们只关心下一个优先级最高的包裹是哪一个。这样可以避免维护包裹完全有序的系统开销。get_parcel和put_parcel的时间复杂度都是O(lg n)，因为这两个函数分别只调用了复杂度为O(lg n)的函数pqueue_extract和pqueue_insert。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：包裹分拣函数的示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;parcels.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;parcel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;parcels.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;pqueue.h&amp;gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;get_parcel 从优先队列提取包裹&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; get_parcel(PQueue *parcels,parcel *&lt;span&gt;parcel)
{
    parcel &lt;/span&gt;*&lt;span&gt;data;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pqueue_size(parcels)==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;没有包裹可返回&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
        &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pqueue_extract(parcels,(&lt;span&gt;void&lt;/span&gt; **)&amp;amp;data)!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            memcpy(parcel,data,&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(parcel));
            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;put_parcel 将包裹插入优先队列&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; put_parcel(PQueue *parcels,&lt;span&gt;const&lt;/span&gt; parcel *&lt;span&gt;parcel)
{
    parcel &lt;/span&gt;*&lt;span&gt;data;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为包裹分配空间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((data = (parcel *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(parcel)))==&lt;span&gt;NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将包裹插入优先队列中&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(data,parcel,&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(parcel));
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pqueue_insert(parcels,data)!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 19 Mar 2018 22:41:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/8594182.html</dc:identifier>
</item>
<item>
<title>RedissonLock分布式锁源码分析 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/8604226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/8604226.html</guid>
<description>&lt;p&gt;最近碰到的一个问题，Java代码中写了一个定时器，分布式部署的时候，多台同时执行的话就会出现重复的数据，为了避免这种情况，之前是通过在配置文件里写上可以执行这段代码的IP，代码中判断如果跟这个IP相等，则执行，否则不执行，想想也是一种比较简单的方式吧，但是感觉很low很low，所以改用分布式锁。&lt;br/&gt;目前分布式锁常用的三种方式：1.数据库的锁；2.基于Redis的分布式锁；3.基于ZooKeeper的分布式锁。其中数据库中的锁有共享锁和排他锁，这两种都无法直接解决数据库的单点和可重入的问题，所以，本章还是来讲讲基于Redis的分布式锁，也可以用其他缓存（Memcache、Tair等）来实现。&lt;/p&gt;
&lt;h2 id=&quot;一实现分布式锁的要求&quot;&gt;一、实现分布式锁的要求&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;互斥性。在任何时候，当且仅有一个客户端能够持有锁。&lt;/li&gt;
&lt;li&gt;不能有死锁。持有锁的客户端崩溃后，后续客户端能够加锁。&lt;/li&gt;
&lt;li&gt;容错性。大部分Redis或者ZooKeeper节点能够正常运行。&lt;/li&gt;
&lt;li&gt;加锁解锁相同。加锁的客户端和解锁的客户端必须为同一个客户端，不能让其他的解锁了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二redis实现分布式锁的常用命令&quot;&gt;二、Redis实现分布式锁的常用命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.SETNX key val&lt;/strong&gt;&lt;br/&gt;当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。&lt;br/&gt;&lt;strong&gt;2.expire key timeout&lt;/strong&gt;&lt;br/&gt;为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。&lt;br/&gt;&lt;strong&gt;3.delete key&lt;/strong&gt;&lt;br/&gt;删除key，此处用来解锁使用。&lt;br/&gt;&lt;strong&gt;4.HEXISTS key field&lt;/strong&gt;&lt;br/&gt;当key 中存储着field的时候返回1，如果key或者field至少有一个不存在返回0。&lt;br/&gt;&lt;strong&gt;5.HINCRBY key field increment&lt;/strong&gt;&lt;br/&gt;将存储在 key 中的哈希（Hash）对象中的指定字段 field 的值加上增量 increment。如果键 key 不存在，一个保存了哈希对象的新建将被创建。如果字段 field 不存在，在进行当前操作前，其将被创建，且对应的值被置为 0。返回值是增量之后的值。&lt;/p&gt;
&lt;h2 id=&quot;三常见写法&quot;&gt;三、常见写法&lt;/h2&gt;
&lt;p&gt;由上面三个命令，我们可以很快的写一个分布式锁出来：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (conn.&lt;span class=&quot;fu&quot;&gt;setnx&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;lock&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(1L)) { 
    &lt;span class=&quot;co&quot;&gt;//do something&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;; 
} 
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样也会存在问题，如果获取该锁的客户端挂掉了怎么办？一般而言，我们可以通过设置expire的过期时间来防止客户端挂掉所带来的影响，可以降低应用挂掉所带来的影响，不过当时间失效的时候，要保证其他客户端只有一台能够获取。&lt;/p&gt;
&lt;h2 id=&quot;四redisson&quot;&gt;四、Redisson&lt;/h2&gt;
&lt;p&gt;Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。——摘自百度百科&lt;/p&gt;
&lt;h3 id=&quot;测试例子&quot;&gt;4.1 测试例子&lt;/h3&gt;
&lt;p&gt;先在pom引入Redssion&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.redisson&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;redisson&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.6.1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;起100个线程，同时对count进行操作，每次操作减1，加锁的时候能够保持顺序输出，不加的话为随机。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RedissonTest &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; RedissonClient redisson;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count = &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;init&lt;/span&gt;() {
        Config config = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Config&lt;/span&gt;();
        config.&lt;span class=&quot;fu&quot;&gt;useSingleServer&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;setAddress&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;redis://119.23.46.71:6340&quot;&lt;/span&gt;)
                .&lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;)
                .&lt;span class=&quot;fu&quot;&gt;setDatabase&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;);
        redisson = Redisson.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(config);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        RLock lock = redisson.&lt;span class=&quot;fu&quot;&gt;getLock&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;anyLock&quot;&lt;/span&gt;);
        lock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
        count--;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(count);
        lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;fu&quot;&gt;init&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;; i++) {
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RedissonTest&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果（部分结果）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;...
9930
9929
9928
9927
9926
9925
9924
9923
9922
9921

...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去掉lock.lock()和lock.unlock()之后（部分结果）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;...
9930
9931
9933
9935
9938
9937
9940
9941
9942
9944
9947
9946
9914
...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;五redissonlock源码分析&quot;&gt;五、RedissonLock源码分析&lt;/h2&gt;
&lt;p&gt;最新版的Redisson要求redis能够支持eval的命令，否则无法实现，即Redis要求2.6版本以上。在lua脚本中可以调用大部分的Redis命令，使用脚本的好处如下：&lt;br/&gt;&lt;strong&gt;(1)减少网络开销&lt;/strong&gt;:在Redis操作需求需要向Redis发送5次请求，而使用脚本功能完成同样的操作只需要发送一个请求即可，减少了网络往返时延。&lt;br/&gt;&lt;strong&gt;(2)原子操作&lt;/strong&gt;:Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说在编写脚本的过程中无需担心会出现竞态条件，也就无需使用事务。事务可以完成的所有功能都可以用脚本来实现。&lt;br/&gt;&lt;strong&gt;(3)复用&lt;/strong&gt;:客户端发送的脚本会永久存储在Redis中，这就意味着其他客户端(可以是其他语言开发的项目)可以复用这一脚本而不需要使用代码完成同样的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;使用到的全局变量&quot;&gt;5.1 使用到的全局变量&lt;/h3&gt;
&lt;p&gt;全局变量：&lt;br/&gt;&lt;strong&gt;expirationRenewalMap&lt;/strong&gt;：存储entryName和其过期时间，底层用的netty的PlatformDependent.newConcurrentHashMap()&lt;br/&gt;&lt;strong&gt;internalLockLeaseTime&lt;/strong&gt;：锁默认释放的时间：30 * 1000，即30秒&lt;br/&gt;&lt;strong&gt;id&lt;/strong&gt;：UUID，用作客户端的唯一标识&lt;br/&gt;&lt;strong&gt;PUBSUB&lt;/strong&gt;：订阅者模式，当释放锁的时候，其他客户端能够知道锁已经被释放的消息，并让队列中的第一个消费者获取锁。使用PUB/SUB消息机制的优点：减少申请锁时的等待时间、安全、 锁带有超时时间、锁的标识唯一，防止死锁 锁设计为可重入，避免死锁。&lt;br/&gt;&lt;strong&gt;commandExecutor&lt;/strong&gt;：命令执行器，异步执行器&lt;/p&gt;
&lt;h3 id=&quot;加锁&quot;&gt;5.2 加锁&lt;/h3&gt;
&lt;p&gt;以lock.lock()为例，调用lock之后，底层使用的是lockInterruptibly，之后调用lockInterruptibly(-1, null);&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180316081203383746214.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;（1）我们来看一下lockInterruptibly的源码，如果别的客户端没有加锁，则当前客户端进行加锁并且订阅，其他客户端尝试加锁，并且获取ttl，然后等待已经加了锁的客户端解锁。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//leaseTime默认为-1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lockInterruptibly&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; leaseTime, TimeUnit unit) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {
    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; threadId = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//获取当前线程ID&lt;/span&gt;
    Long ttl = &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(leaseTime, unit, threadId);&lt;span class=&quot;co&quot;&gt;//尝试加锁&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果为空，当前线程获取锁成功，否则已经被其他客户端加锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ttl == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;//等待释放，并订阅锁&lt;/span&gt;
    RFuture&amp;lt;RedissonLockEntry&amp;gt; future = &lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(threadId);
    commandExecutor.&lt;span class=&quot;fu&quot;&gt;syncSubscription&lt;/span&gt;(future);
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 重新尝试获取锁&lt;/span&gt;
            ttl = &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(leaseTime, unit, threadId);
            &lt;span class=&quot;co&quot;&gt;// 成功获取锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ttl == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 等待锁释放&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ttl &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;fu&quot;&gt;getEntry&lt;/span&gt;(threadId).&lt;span class=&quot;fu&quot;&gt;getLatch&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(ttl, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;fu&quot;&gt;getEntry&lt;/span&gt;(threadId).&lt;span class=&quot;fu&quot;&gt;getLatch&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;();
            }
        }
    } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// 取消订阅&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;unsubscribe&lt;/span&gt;(future, threadId);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）下面是tryAcquire的实现，调用的是tryAcquireAsync&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Long &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; threadId) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;tryAcquireAsync&lt;/span&gt;(leaseTime, unit, threadId));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）下面是tryAcquireAsync的实现，异步尝试进行加锁，尝试加锁的时候leaseTime为-1。通常如果客户端没有加锁成功，则会进行阻塞，leaseTime为锁释放的时间。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; RFuture&amp;lt;Long&amp;gt; &lt;span class=&quot;fu&quot;&gt;tryAcquireAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; threadId) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (leaseTime != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {   &lt;span class=&quot;co&quot;&gt;//在lock.lock()的时候，已经声明了leaseTime为-1，尝试加锁&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLockInnerAsync&lt;/span&gt;(leaseTime, unit, threadId, RedisCommands.&lt;span class=&quot;fu&quot;&gt;EVAL_LONG&lt;/span&gt;);
    }
    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = &lt;span class=&quot;fu&quot;&gt;tryLockInnerAsync&lt;/span&gt;(commandExecutor.&lt;span class=&quot;fu&quot;&gt;getConnectionManager&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getCfg&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getLockWatchdogTimeout&lt;/span&gt;(), TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;, threadId, RedisCommands.&lt;span class=&quot;fu&quot;&gt;EVAL_LONG&lt;/span&gt;);
    &lt;span class=&quot;co&quot;&gt;//监听事件，订阅消息&lt;/span&gt;
    ttlRemainingFuture.&lt;span class=&quot;fu&quot;&gt;addListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FutureListener&amp;lt;Long&amp;gt;() {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;operationComplete&lt;/span&gt;(Future&amp;lt;Long&amp;gt; future) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!future.&lt;span class=&quot;fu&quot;&gt;isSuccess&lt;/span&gt;()) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
            }
            Long ttlRemaining = future.&lt;span class=&quot;fu&quot;&gt;getNow&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// lock acquired&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ttlRemaining == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;//获取新的超时时间&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;scheduleExpirationRenewal&lt;/span&gt;(threadId);
            }
        }
    });
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ttlRemainingFuture;  &lt;span class=&quot;co&quot;&gt;//返回ttl时间&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）下面是tryLockInnerAsyncy异步加锁，使用lua能够保证操作是原子性的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;T&amp;gt; RFuture&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;tryLockInnerAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {
    internalLockLeaseTime = unit.&lt;span class=&quot;fu&quot;&gt;toMillis&lt;/span&gt;(leaseTime);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; commandExecutor.&lt;span class=&quot;fu&quot;&gt;evalWriteAsync&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;(), LongCodec.&lt;span class=&quot;fu&quot;&gt;INSTANCE&lt;/span&gt;, command,
              &lt;span class=&quot;st&quot;&gt;&quot;if (redis.call('exists', KEYS[1]) == 0) then &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;return nil; &quot;&lt;/span&gt; +
              &lt;span class=&quot;st&quot;&gt;&quot;end; &quot;&lt;/span&gt; +
              &lt;span class=&quot;st&quot;&gt;&quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +
                  &lt;span class=&quot;st&quot;&gt;&quot;return nil; &quot;&lt;/span&gt; +
              &lt;span class=&quot;st&quot;&gt;&quot;end; &quot;&lt;/span&gt; +
              &lt;span class=&quot;st&quot;&gt;&quot;return redis.call('pttl', KEYS[1]);&quot;&lt;/span&gt;,
                Collections.&amp;lt;Object&amp;gt;&lt;span class=&quot;fu&quot;&gt;singletonList&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;()), internalLockLeaseTime, &lt;span class=&quot;fu&quot;&gt;getLockName&lt;/span&gt;(threadId));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数&lt;br/&gt;&lt;strong&gt;KEYS[1]&lt;/strong&gt;(getName()) ：需要加锁的key，这里需要是字符串类型。&lt;br/&gt;&lt;strong&gt;ARGV[1]&lt;/strong&gt;(internalLockLeaseTime) ：锁的超时时间，防止死锁&lt;br/&gt;&lt;strong&gt;ARGV[2]&lt;/strong&gt;(getLockName(threadId)) ：锁的唯一标识，也就是刚才介绍的 id（UUID.randomUUID()） + “:” + threadId&lt;br/&gt;lua脚本解释&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode lua&quot;&gt;
&lt;code class=&quot;sourceCode lua&quot;&gt;&lt;span class=&quot;co&quot;&gt;--检查key是否被占用了，如果没有则设置超时时间和唯一标识，初始化value=1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'exists'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
  redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hset'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
  redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pexpire'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;--如果锁重入,需要判断锁的key field 都一致情况下 value 加一 &lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hexists'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; 
  redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hincrby'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;--锁重入重新设置超时时间  &lt;/span&gt;
  redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pexpire'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; 
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--返回剩余的过期时间&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pttl'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）流程图&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180320010140455516380.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;解锁&quot;&gt;5.3 解锁&lt;/h3&gt;
&lt;p&gt;解锁的代码很简单，大意是将该节点删除，并发布消息。&lt;br/&gt;（1）unlock源码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;() {
        Boolean opStatus = &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;unlockInnerAsync&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;()));
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (opStatus == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException(&lt;span class=&quot;st&quot;&gt;&quot;attempt to unlock lock, not locked by current thread by node id: &quot;&lt;/span&gt;
                    + id + &lt;span class=&quot;st&quot;&gt;&quot; thread-id: &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (opStatus) {
            &lt;span class=&quot;fu&quot;&gt;cancelExpirationRenewal&lt;/span&gt;();
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）异步解锁，并返回是否成功&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;fu&quot;&gt;unlockInnerAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; threadId) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; commandExecutor.&lt;span class=&quot;fu&quot;&gt;evalWriteAsync&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;(), LongCodec.&lt;span class=&quot;fu&quot;&gt;INSTANCE&lt;/span&gt;, RedisCommands.&lt;span class=&quot;fu&quot;&gt;EVAL_BOOLEAN&lt;/span&gt;,
            &lt;span class=&quot;st&quot;&gt;&quot;if (redis.call('exists', KEYS[1]) == 0) then &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;return 1; &quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;end;&quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;return nil;&quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;end; &quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); &quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;if (counter &amp;gt; 0) then &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;return 0; &quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;else &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;redis.call('del', KEYS[1]); &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;redis.call('publish', KEYS[2], ARGV[1]); &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;return 1; &quot;&lt;/span&gt;+
            &lt;span class=&quot;st&quot;&gt;&quot;end; &quot;&lt;/span&gt; +
            &lt;span class=&quot;st&quot;&gt;&quot;return nil;&quot;&lt;/span&gt;,
            Arrays.&amp;lt;Object&amp;gt;&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;(), &lt;span class=&quot;fu&quot;&gt;getChannelName&lt;/span&gt;()), LockPubSub.&lt;span class=&quot;fu&quot;&gt;unlockMessage&lt;/span&gt;, internalLockLeaseTime, &lt;span class=&quot;fu&quot;&gt;getLockName&lt;/span&gt;(threadId));

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入的参数有：&lt;br/&gt;参数：&lt;br/&gt;&lt;strong&gt;KEYS[1]&lt;/strong&gt;(getName())：需要加锁的key，这里需要是字符串类型。&lt;br/&gt;&lt;strong&gt;KEYS[2]&lt;/strong&gt;(getChannelName())：redis消息的ChannelName,一个分布式锁对应唯一的一个 channelName:“redisson_lock__channel__{” + getName() + “}”&lt;br/&gt;&lt;strong&gt;ARGV[1]&lt;/strong&gt;(LockPubSub.unlockMessage)：redis消息体，这里只需要一个字节的标记就可以，主要标记redis的key已经解锁，再结合redis的Subscribe，能唤醒其他订阅解锁消息的客户端线程申请锁。&lt;br/&gt;&lt;strong&gt;ARGV[2]&lt;/strong&gt;(internalLockLeaseTime)：锁的超时时间，防止死锁&lt;br/&gt;&lt;strong&gt;ARGV[3]&lt;/strong&gt;(getLockName(threadId)) ：锁的唯一标识，也就是刚才介绍的 id（UUID.randomUUID()） + “:” + threadId&lt;/p&gt;
&lt;p&gt;此处lua脚本的作用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode lua&quot;&gt;
&lt;code class=&quot;sourceCode lua&quot;&gt;&lt;span class=&quot;co&quot;&gt;--如果keys[1]不存在，则发布消息，说明已经被解锁了&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'exists'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
    redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'publish'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--key和field不匹配，说明当前客户端线程没有持有锁，不能主动解锁。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hexists'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--将value减1，这里主要用在重入锁&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; counter &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hincrby'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;counter &lt;span class=&quot;ot&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; 
    redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'pexpire'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;--删除key并消息&lt;/span&gt;
    redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'del'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; 
    redis&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;call&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'publish'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; KEYS&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; ARGV&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;        &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）删除过期信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;cancelExpirationRenewal&lt;/span&gt;() {
    Timeout task = expirationRenewalMap.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getEntryName&lt;/span&gt;());
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (task != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        task.&lt;span class=&quot;fu&quot;&gt;cancel&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Redis2.6版本之后引入了eval，能够支持lua脚本，更好的保证了redis的原子性，而且redisson采用了大量异步的写法来避免性能所带来的影响。本文只是讲解了下redisson的重入锁，其还有公平锁、联锁、红锁、读写锁等，有兴趣的可以看下。感觉这篇文章写得也不是很好，毕竟netty还没开始学，有些api也不太清楚，希望各位大佬能够建议建议~~&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;1.&lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;redisson&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://www.cnblogs.com/linjiqin/p/8003838.html&quot;&gt;Redis分布式锁的正确实现方式&lt;/a&gt;&lt;br/&gt;3.&lt;a href=&quot;https://www.cnblogs.com/yuyutianxia/p/7149363.html&quot;&gt;分布式锁的多种实现方式&lt;/a&gt;&lt;br/&gt;4.&lt;a href=&quot;http://ifeve.com/redis-lock/&quot;&gt;用Redis构建分布式锁&lt;/a&gt;&lt;br/&gt;5.&lt;a href=&quot;http://blog.csdn.net/u010612491/article/details/51427180&quot;&gt;基于Redis的分布式锁实现&lt;/a&gt;&lt;br/&gt;6.&lt;a href=&quot;http://blog.jobbole.com/99751/&quot;&gt;基于Redis实现分布式锁，Redisson使用及源码分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Mar 2018 17:34:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/8604226.html</dc:identifier>
</item>
<item>
<title>麻省理工18年春软件构造课程阅读07“设计规格说明” - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8606687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8606687.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/&quot;&gt;MIT_6.031_sp18: Software Construction&lt;/a&gt;课程的Readings部分，采用&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;协议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们学校（哈工大）大二软件构造课程的大部分素材取自此，也是推荐的阅读材料之一，于是打算做一些翻译工作，自己学习的同时也能帮到一些懒得看英文的朋友。另外，该课程的阅读资料中有许多练习题，但是没有标准答案，所给出的答案均为译者所写，有错误的地方还请指出。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;审校：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0 Tue Mar 20 00:49:34 CST 2018&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;本次课程的目标&quot;&gt;&lt;span&gt;本次课程的目标&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;理解待决定（underdetermined）规格说明，并能够辨别评估待决定的规格说明。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;理解声明性的规格说明和操作性的规格说明之间的区别，并能够写出声明性的规格说明。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;理解前置条件、后置条件、及规格说明的“强度”，并能够比较两个规格说明之间的强度。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;能够写出逻辑严密、前后连贯的规格说明。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在这篇阅读中我们会比较相似行为的不同规格说明，并从三个维度探讨它们之间的区别：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个规格说明的&lt;strong&gt;决定性&lt;/strong&gt;：它对输入输出的空间是否有严格的限制？例如要求输出只有一种可能，或者可以有多种可能性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个规格说明的&lt;strong&gt;声明性&lt;/strong&gt;：它是否仅仅声明了输出应该是什么，或者还要求了实现的方法（输出是如何计算出的）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个规格说明的&lt;strong&gt;强度&lt;/strong&gt;：它的实现方法是否仅限于一个小集合，或者有很多种满足要求的实现方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于一个特定的模块，不同的规格说明会产生不同的效果，接下来我们就探讨如何设计出最好的的规格说明。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;决定性的-vs.-待决定性的规格说明&quot;&gt;&lt;span&gt;决定性的 vs. 待决定性的规格说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;回忆之前的阅读中我们定义的两个&lt;code&gt;find&lt;/code&gt;函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findFirst&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr[i] == val) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findLast&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; ; i &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i--) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr[i] == val) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里提一下，函数名中的后缀 &lt;code&gt;First&lt;/code&gt; and &lt;code&gt;Last&lt;/code&gt; 只是为了区分开它们实现方法，当被应用到实际的代码中时，它们都叫做&lt;code&gt;find&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是&lt;code&gt;find&lt;/code&gt;的一种可能的规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findExactlyOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs exactly once in arr
- effects:
  returns index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的后缀名 &lt;code&gt;ExactlyOne&lt;/code&gt;也仅是一种提示符，为了区分开同一模块的不同规格说明设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们说，&lt;code&gt;findExactlyOne&lt;/code&gt;是&lt;strong&gt;完全决定性的&lt;/strong&gt;（fully deterministic）：当输入满足前置条件后，输出能够完全确定——仅仅只有一种可能的返回情况。不存在一个输入对应多种输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;findFirst&lt;/code&gt; 和 &lt;code&gt;findLast&lt;/code&gt; 的实现方法都满足这个规格说明的要求，所以如果有一个客户使用了这个规格说明的&lt;code&gt;find&lt;/code&gt;模块，我们可以用 &lt;code&gt;findFirst&lt;/code&gt; 和 &lt;code&gt;findLast&lt;/code&gt; 进行等价替换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是&lt;code&gt;find&lt;/code&gt;的另一种规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;AnyIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs in arr
- effects:
  returns index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个规格说明就不是决定性的——当&lt;code&gt;val&lt;/code&gt;出现多次时，它没有要求返回哪一个的下标。即它仅仅承诺了你可以根据返回的下标找到对应的&lt;code&gt;val&lt;/code&gt; 。对于一个输入，这个模块有多种输出的可能性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意一点，当我们说“非决定性”（underdetermined）的时候，并不是指“不确定性”（nondeterministic）。不确定性的代码是指一会的行为是这样，过一会又变成了那样（即使对于同一个输入）。有很多不确定的例子：例如一个依赖于随机数的函数，或者一个依赖于当前时间的程序。&lt;strong&gt;但是一个非决定性的规格说明并不一定代表对应的模块的行为是非确定性的&lt;/strong&gt;，模块可以是由完全确定行为（一个输入就对应一个确定的输出）的代码写的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的例子中，规格说明没有要求返回值是多种可能的哪一个，我们既可以使用 &lt;code&gt;findFirst&lt;/code&gt; 又可以使用 &lt;code&gt;findLast&lt;/code&gt;实现这个模块，但是这两个实现方法本身是确定性的（译者注：确定性在算法层面，对于同一个输入，有同一个输出）。甚至，我们可以使用非确定性的代码满足规格说明，例如每次使用随机数决定返回多个下标中的哪一个。而使用者只会关注规格说明，他们无法确定模块会返回哪一种结果（译者注：决定性在使用者应用层面，他只能依赖规格说明的描述）。在大多数情况下，非决定性的规格说明会给实现者更多实现的自由，另外，一个非决定性的规格说明对应的模块大多是用确定性的代码实现的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Distinguished&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;code&gt;findFirst&lt;/code&gt;和&lt;code&gt;findLast&lt;/code&gt;两种对&lt;code&gt;find&lt;/code&gt;的实现方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findFirst&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr[i] == val) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findLast&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; ; i &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i--) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr[i] == val) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;考虑下面这个规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
effects:

returns largest index i such that arr[i] = val, or -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; no such i&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以下哪一种输入会使&lt;code&gt;findFirst&lt;/code&gt; 不满足规格说明？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下哪一种输入会使&lt;code&gt;findLast&lt;/code&gt;不满足规格说明？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Over/under&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上文中我们提到了 &lt;code&gt;find&lt;/code&gt; 的一种非决定性的规格说明:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;AnyIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs in arr
- effects:
  returns index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当数组中含有多个&lt;code&gt;val&lt;/code&gt;时，这个规格说明允许多种返回情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于下面的每一个规格说明，判断它的决定性大于或小于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt; 的决定性，或者它是完全决定性的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs exactly once in arr
- effects:
  returns index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 大于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;, 但是不是完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 小于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
effects:

returns largest index i such that arr[i] = val, or -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; no such i&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 大于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;, 但是不是完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 小于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs in arr
- effects:
  returns largest index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] 大于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;, 但是不是完全决定性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 小于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;声明性的-vs.-操作性的规格说明&quot;&gt;&lt;span&gt;声明性的 vs. 操作性的规格说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;笼统的说，规格说明分为两种：操作性的（Operational）规格说明给出了实现过程的步骤（就像伪代码一样），而声明性的（Declarative）规格说明不对实现过程进行要求，它们仅仅给出最后输出的属性和意义，以及它们和输入之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在绝大多是情况下，声明性的规格说明更合适。它们通常会更简洁、更易懂、并且最重要的是，它们不会让使用者尝试依赖特定的实现方案（很多时候一个模块的实现方案会不得不改变）。例如，如果我们想要允许多种方案来实现&lt;code&gt;find&lt;/code&gt; ，我们就不会在规格说明要求“从数组低位开始向上遍历搜索”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有些时候，程序员想要给维护者（maintainer）模块的实现信息，于是他们将实现描述写在了规格说明中。要记住，规格说明是给使用者而非模块的开发者使用的，&lt;strong&gt;如果你想要用描述模块的实现方法，将它们注释在模块里面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，对于一种声明性的规格说明，可以有多种描述方法，例如下面这几个声明性的规格说明都是等价的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;startsWith&lt;/span&gt;(String str, String prefix)
effects:

returns &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; and only &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; there exists String suffix such that prefix + suffix = str&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;startsWith&lt;/span&gt;(String str, String prefix)
effects:

returns &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; and only &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; there exists integer i such that str.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, i) = prefix&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;startsWith&lt;/span&gt;(String str, String prefix)
effects:

returns &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; the first prefix.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() characters of str are the characters of prefix, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; otherwise&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们要做的就是给使用者选择一个最清晰易懂的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-1&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Joint declaration&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出下面这个规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;join&lt;/span&gt;(String delimiter, String[] elements)
effects:

append together the strings in elements, but at each step, &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; there are more elements left, insert delimiter&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;重写这个规格说明，使得它是声明性的而非操作性的。&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] effects: 将所有的元素通过 &lt;code&gt;new StringJoiner(delimiter)&lt;/code&gt;相加&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] effects: 通过一个循环将各个元素和分隔符叠加起来&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] effects: 返回一个元素的连接体（元素保持原有顺序），并在各个元素中插入分隔符。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;更强或更弱的规格说明&quot;&gt;&lt;span&gt;更强或更弱的规格说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;假设你想要改变一个方法——不管是它的实现方法还是规格说明本身。并且现在已经有使用者在依赖你之前的规格说明来使用方法了，你该怎么确定新的规格说明可以安全的替换原有的规格说明呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：规格说明S2强于（等于）规格说明S1，如果：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;S2的前置条件弱于或等价于S1的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;S2的后置条件强于或等于S1的后置条件。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果S2强于S1，那么任何S2的实现方法都可以拿来实现S1，并且在程序中可以安全的用S2的模块替换S1模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两个条件实际上表现了一种思想：你可以弱化前置条件（译者注：即更容易满足前置条件，或者说满足前置条件的集合扩大了），这会让使用者的限制更少（译者注：例如不用对模块的输入先进行一些检查），也可以强化后置条件（译者注：在使用者看来，就是模块的返回更清晰，更有保证性，不用对多种可能情况进行处理）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，对于 &lt;code&gt;find&lt;/code&gt;的规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findExactlyOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs exactly once in a
- effects:
  returns index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以被替换为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;AnyIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs at least once in a
- effects:
  returns index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，他的前置条件变弱了。而这个规格说明可以继续加强：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;FirstIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs at least once in a
- effects:
  returns lowest index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;即强化了后置条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么下面这个规格说明呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findCanBeMissing&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  nothing
- effects:
  returns index i such that a[i] = val, or -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; no such i&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们试着将它和 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;比较，它的前置条件更弱。但是它的后置条件也更弱——对于满足 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;的输入， &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;承诺返回最小下标，但是&lt;code&gt;findCanBeMissing&lt;/code&gt;没有做任何承诺。&lt;strong&gt;所以它们是不可比较的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在下面的练习中我们会继续用 &lt;code&gt;findCanBeMissing&lt;/code&gt; 和其他的规格说明进行比较。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;图示化规格说明&quot;&gt;&lt;span&gt;图示化规格说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;I试着将Java中的全部方法想象成一个太空，太空中的每一个星星就是一个方法。在这里我们先将上面提到的 &lt;code&gt;findFirst&lt;/code&gt; 和 &lt;code&gt;findLast&lt;/code&gt; 画出来。记住，对于 &lt;code&gt;findFirst&lt;/code&gt; 和 &lt;code&gt;findLast&lt;/code&gt; ，&lt;strong&gt;它们的算法/行为是固定的，不能在这个空间中表示一个范围&lt;/strong&gt;，所以我们用点来表示实际的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005724966-866285820.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而一个规格说明会在这个太空中描述出一个范围，在这个范围中的实现方法都满足规格说明的要求（即前置条件和后置条件），而在范围之外的不满足规格说明的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;findFirst&lt;/code&gt; 和 &lt;code&gt;findLast&lt;/code&gt; 都是满足 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;的，所以它们都在 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;描述的范围内：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005732400-587047080.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以想象使用者站在地上向天空望去：规格说明就好像星云的规定边界一样&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;实现者可以自由的在一个星云中移动（即改变实现方案/代码），例如提升原有算法的性能或修复一个bug，而不必担心这种改变会导致使用者的不变。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用者只选取某一个星云，而不在意或依赖到底是其中的哪一个星星。他们可以自由的将模块应用在各个环境（只要满足规格说明）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;该如何描述两个规格说明之间的关系呢？现在假设有S1和S2两个规格说明，它们一开始的强度是一样的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;我们先从加强后置条件考虑，如果S2的后置条件变的强于S1的后置条件。那么S2就是强于S1的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;想一想&lt;strong&gt;强化后置条件&lt;/strong&gt;对于实现者来说意味着什么：更少的自由度，因为输入的空间变小了。例如之前的规格说明是&lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt; ，而更改后的规格说明变成了 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt; 。所以以前在“星云”内的实现方案现在可能在新的星云之外了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，是否存在一种实现方案，它在 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt; 之内但是在&lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;之外呢？这是不可能的，因为所有满足&lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt; 的实现方案都强于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt; 的要求。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;接着想一想&lt;strong&gt;弱化前置条件&lt;/strong&gt;，这也会使S2变得更强。实现方案需要处理更多的可能输入空间，如果之前它们没有在意这写数据范围，现在可能就会暴露出一些bug。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于一个更强的规格说明，它在图示中能描绘的实现范围更小，而一个更弱的规格说明描述的实现范围更大：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005747537-2028028032.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上图中，由于&lt;code&gt;findLast&lt;/code&gt; 是从数组的最后一个元素开始遍历，所以它不符合&lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;的后置条件，即它会在&lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;描绘的范围之外。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于一个既不强于S1也不弱于S1的规格说明S3，它和S1的范围可能是有重叠的（即存在实现方案即满足S1，也满足S3），也可能是没有重叠的。在这两种情况下，S1和S3都是不可比较的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-2&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Bulking up&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个规格说明被强化后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Strength is truth&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下关于A和B规格说明的关系的描述哪一个是对的？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] A强于B，且A的前置条件更弱&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] A强于B，且前置条件相同&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] A强于B，且A的前置条件更强&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] A强于B，且前置条件不可比较&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] A和B不可比较&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Finding findExactlyOne&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是 &lt;code&gt;find&lt;/code&gt; 的各种规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findExactlyOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs exactly once in a
- effects:
  returns index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;AnyIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs at least once in a
- effects:
  returns index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; findOneOrMore,&lt;span class=&quot;fu&quot;&gt;FirstIndex&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs at least once in a
- effects:
  returns lowest index i such that a[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findCanBeMissing&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  nothing
- effects:
  returns index i such that a[i] = val, or -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; no such i&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于前三个规格说明，下面哪一个图的描述是正确的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 1.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005804672-1806335065.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 2.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005812097-860367699.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 3.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005820230-1972836049.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 4.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005826218-903402643.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Finding findCanBeMissing&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;findCanBeMissing&lt;/code&gt;和 &lt;code&gt;findExactlyOne&lt;/code&gt;是何种关系？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt; 弱于 &lt;code&gt;findExactlyOne&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;findCanBeMissing&lt;/code&gt; 强于 &lt;code&gt;findExactlyOne&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt; 和 &lt;code&gt;findExactlyOne&lt;/code&gt; 不可比较&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;How does &lt;code&gt;findCanBeMissing&lt;/code&gt; compare to &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;?&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt; 弱于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;findCanBeMissing&lt;/code&gt; 强于 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt; 和 &lt;code&gt;findOneOrMore,AnyIndex&lt;/code&gt; 不可比较&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;How does &lt;code&gt;findCanBeMissing&lt;/code&gt; compare to &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;?&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt; 弱于 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;findCanBeMissing&lt;/code&gt;强于 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;findCanBeMissing&lt;/code&gt; 和 &lt;code&gt;findOneOrMore,FirstIndex&lt;/code&gt; 不可比较&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Found&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面关于 &lt;code&gt;findCanBeMissing&lt;/code&gt; 的描述哪一个是正确的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 1.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005856306-251195799.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 2.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005908442-1098499409.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 3.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005921187-1954624633.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 4.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005929581-1288154225.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 5.&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180320005939092-494861451.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;设计好的规格说明&quot;&gt;&lt;span&gt;设计好的规格说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;什么因素对一个方法的设计最重要？毫无疑问是初期该方法的规格说明设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个好的规格设计应该简洁清楚、结构明确、易于理解的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，规格说明的具体内容是很难用一套固定的设计规则描述的，不过这里我们有一些有用的指导方针。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;规格说明应该逻辑明确&quot;&gt;&lt;span&gt;规格说明应该逻辑明确&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;规格说明不应当有很多种情况（或者if-else判断）、也不应该有很多参数，布尔类型1的标志也是不好的。思考下面这个规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sumFind&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] b, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
effects:

returns the sum of all indices in arrays a and b at which val appears&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个设计合理吗？可能不是：它的逻辑不明确，因为它尝试将两个毫不相干的事情一起完成（在两个数组里面查找并将下标相加）。将这两件事情用两个分别的模块来完成会更合理。一个在两个数组中查找对应的下标，另一个将这两个下标相加然后输出结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是另外一个例子，&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8531425.html&quot;&gt;“代码评审”&lt;/a&gt;中的 &lt;code&gt;countLongWords&lt;/code&gt; 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; LONG_WORD_LENGTH = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String longestWord;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Update longestWord to be the longest element of words, and print&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * the number of elements with length &amp;gt; LONG_WORD_LENGTH to the console.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param words &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;list to search for long words&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;countLongWords&lt;/span&gt;(List&amp;lt;String&amp;gt; words)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除了槽糕的使用全局变量和打印而非返回结果（译者注：这两个问题都在&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8531425.html&quot;&gt;“代码评审”&lt;/a&gt;这个阅读中谈到了）。这个规格说明的逻辑也是有问题的——它试着同时完成两件事：找到最长的词和统计符合长度要求的词的个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将这两件事情用两个不同的方法完成不仅会更加简单（易于理解），也会在其他的上下文中方便复用。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用的结果应该清晰&quot;&gt;&lt;span&gt;调用的结果应该清晰&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;思考下面这个规格说明，它将一个值放在一个映射中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(Map&amp;lt;K,V&amp;gt; map, K key, V val)
- requires:
  val may be &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, and map may contain &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; values
- effects:
  &lt;span class=&quot;fu&quot;&gt;inserts&lt;/span&gt; (key, val) into the mapping, overriding any existing mapping &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; key, and returns old value &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; key, unless none, in which &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; it returns &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意到前置条件中并没有规定key键对应值不能是&lt;code&gt;null&lt;/code&gt; 。但是后置条件中将&lt;code&gt;null&lt;/code&gt;作为一个特殊条件来返回。这意味着如果返回值是&lt;code&gt;null&lt;/code&gt; ，那么使用者就不能判断到底是这个key对应的值是&lt;code&gt;null&lt;/code&gt; ，还是这个key值以前不存在。因此，这不是一个好的设计，它会产生歧义。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;规格说明应该足够强&quot;&gt;&lt;span&gt;规格说明应该足够“强”&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;译者注：这里的强主要指后置条件的强度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，规格说明应该保证对于一般的输入（满足前置条件的空间）它会满足要求，这里要说的是对于一些前置条件之外的特殊情况的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，对于一个错误的输入，抛出异常并且允许任意的更改就是毫无意义的。因为使用者无法确定模块在抛出异常前对对象做了哪些更改。这里有一个规格说明就描述了这样的缺项（并且它的描述是操作性的，这也不好）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(List&amp;lt;T&amp;gt; list1, List&amp;lt;T&amp;gt; list2)
effects:

adds the elements of list2 to list1, unless it encounters a &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; element, at which point it &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; a NullPointerException&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果异常 &lt;code&gt;NullPointerException&lt;/code&gt; 被抛出，使用者就得想方设法找到是&lt;code&gt;list2&lt;/code&gt;中的哪一个&lt;code&gt;null&lt;/code&gt;元素导致了异常的发生（&lt;code&gt;list1&lt;/code&gt;被做了哪些改变）。（译者注：这些应该在抛出时进行描述）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;规格说明也应该足够弱&quot;&gt;&lt;span&gt;规格说明也应该足够“弱”&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;译者注：这里的强度主要指前置条件的强度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考下面这个规格说明，该模块试着打开一个文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; File &lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;(String filename)
effects:

opens a file named filename&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是一个不好的规格说明。它缺乏一些重要的细节：这个文件打开后是进行写还是读操作？这个文件是已经存在的吗？（如果不存在的话，这个模块会进行创建吗？）并且它的强度太大了（译者注：前置条件过弱），毕竟这个模块是不能保证正确打开一个文件的。例如，模块所在的进程可能没有打开这个文件权限，或者这个文件的已经损坏了，操作系统拒绝打开它（译者注：即有很多程序不能控制的因素决定的打开是否成功）。所以，这个规格说明应该更弱一些，例如说明使用者应该具有该文件的读/写权限，这个文件存在等等。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;规格说明应该尽可能使用抽象的数据类型&quot;&gt;&lt;span&gt;规格说明应该尽可能使用抽象的数据类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们之前在&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8494132.html&quot;&gt;“Java基础”&lt;/a&gt;中谈到了Java的聚合类型，里面说到了对数据抽象的要求说明例如 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 以及具体的实现方法例如 &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在规格说明中使用抽象的数据类型会给使用者和实现者更多的自由。在Java中，这通常意味着使用接口类型，例如 &lt;code&gt;Map&lt;/code&gt; 或 &lt;code&gt;Reader&lt;/code&gt; 而不是具体的实现类型例如 &lt;code&gt;HashMap&lt;/code&gt; 或 &lt;code&gt;FileReader&lt;/code&gt; 。现在考虑下面这个规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ArrayList&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;reverse&lt;/span&gt;(ArrayList&amp;lt;T&amp;gt; list)
effects:

returns a &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; list which is the reversal of list, i.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;. newList[i] = list[n-i&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;] &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; all &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ≤ i &amp;lt; n, where n = list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个规格说明强制使用者传入一个 &lt;code&gt;ArrayList&lt;/code&gt; ，并且强制实现者返回一个 &lt;code&gt;ArrayList&lt;/code&gt; ，即使&lt;code&gt;List&lt;/code&gt;实现方法有很多种。从描述上看，对应模块的行为应该不会依赖于 &lt;code&gt;ArrayList&lt;/code&gt;的实现特性。所以这里最好写成更抽象的数据类型&lt;code&gt;List&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用前置条件还是后置条件&quot;&gt;&lt;span&gt;使用前置条件还是后置条件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;另一个设计的问题就是是否使用前置条件，如果使用的话，是否需要模块在一开始对参数进行检查，判断其符合前置条件后再进行后续工作。事实上，使用前置条件的一个最常见的要求就是输入必须精确满足前置条件，因为模块检查参数的资源代价可能会很大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正如上面所提到的，“重量级”的前置条件会让使用者不方便，因为他们必须确保输入不违反前置条件的要求，如果违反了，从错误中恢复的方法将是不可预测的。所以使用者大多不喜欢前置条件，这也是为什么Java API 类趋向于（作为后置条件）在参数不合法的时候抛出一个非检查的异常。这样的手段使得发现bug更加容易。通常情况下，&lt;strong&gt;快速失败/报错&lt;/strong&gt;总是更好的（即离bug越近越好），而不是让错误的参数继续参与剩下的运算。例如，&lt;code&gt;atan(y, x)&lt;/code&gt;可能会要求输入不能是(0,0)（但不是前置条件），&lt;strong&gt;但是它依然会接受这种参数并抛出一个明确的异常，而不是让这个参数参与剩下的计算并返回一个“垃圾值”。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候，检查参数是不可行的，这个时候前置条件就是必须的了。例如我们想用二分查找的办法实现&lt;code&gt;find&lt;/code&gt; ，我们会要求这个数组是已经排序过的了。如果强制要求模块检查这个数组是否已经排好序，这个带来的线性复杂度相对于我们要实现的目标是承受不起的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于是否使用前置条件是一个工程上的判断。关键点在于检查需要使用的资源量以及这个模块被使用的范围。当这个模块仅仅在类的内部使用时，我们设置前置条件，仔细检查所有的调用是否合理。但是如果这个方法是公开的，并且会被其他的开发者使用，那么使用前置条件就不那么合理。像Java API一样，你应该抛出一个异常。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;关于访问控制&quot;&gt;&lt;span&gt;关于访问控制&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;1.9767441860465&quot;&gt;
&lt;p&gt;&lt;span&gt;阅读: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/package/index.html&quot;&gt;&lt;strong&gt;Packages&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阅读: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;&lt;strong&gt;Controlling Access&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;在之前的阅读中，我们一直在使用public的方法，也没有对此进行特别的考虑。一个方法是public还是private取决于这个类的功能。公共的方法可以被程序中其他的部分访问。将一个方法公开就相当于你想让方法所在的类为其他的类提供对应的服务。如果你将所有的方法设置为公开访问的——包括那些本来只设计在内部使用的方法，未来更改这个类就会变得很困难，因为外部可能会依赖这个类的内部实现。总之，这会让你的代码不具备&lt;strong&gt;可改动性&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将一个内部使用的方法设置为公开访问也会让类的接口变得复杂。保持内部方法私有会让接口简洁而且符合逻辑，这会让你的代码&lt;strong&gt;易于理解&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在接下来的几个阅读中，当我们开始使用类的内部状态时，我们会看到更多的使用private修饰的理由，这会让你的代码&lt;strong&gt;远离bug&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;类方法和实例方法static-vs.-instance&quot;&gt;&lt;span&gt;类方法和实例方法（static vs. instance）&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;1.5384615384615&quot;&gt;
&lt;p&gt;&lt;span&gt;阅读: &lt;a href=&quot;http://www.codeguru.com/java/tij/tij0037.shtml#Heading79&quot;&gt;&lt;strong&gt;the static keyword&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;同时，我们也一直在使用static方法而没有过多的考虑。类方法是指那些不与特定的类实例（对象）相关联的方法（译者注：或者说没有this指针），而实例方法（没有static修饰）必须通过特定的对象来调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例方法的规格说明和类方法的规格说明是一样的，但它们通常会利用实例对应的具体属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，下面这个非常熟悉的规格说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs in arr
- effects:
  returns index i such that arr[i] = val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果这里不是使用 &lt;code&gt;int[]&lt;/code&gt;，而是一个&lt;code&gt;IntArray&lt;/code&gt; 对象呢？那么&lt;code&gt;IntArray&lt;/code&gt; 必须提供一个实例方法，对应的规格说明就会是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
- requires:
  val occurs in &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; array
- effects:
  returns index i such that the value at index i in &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; array is val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在以后的课程中我们会讨论很多关于实例方法的规格说明的内容。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;阅读小练习-3&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Show me a sign&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面哪一些选项代表了好的规格说明的属性？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] 该规格说明是声明性的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 该规格说明是操作性的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 规格说明的强度应该越大越好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 规格说明的强度应该越弱越好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 模块的实现应该允许忽略错误的参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 模块的实现应该允许根据具体的参数选择不同的算法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 规格说明应该强调使用者对于模块具体实现的理解&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;That’s an odd way of looking at it&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;secondToLastIndexOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
  - requires:
    val appears in arr an odd number of times
  - effects:
    returns the 2nd-largest i such that arr[i] == val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于上面这个规格说明，以下哪一些批评是合理的？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] 这个规格说明的定义有问题，我们无法实现它（译者注：当输入的数组只有一个元素的时候）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 这个规格说明的逻辑不对（译者注：odd number、2nd-largest都不合理，应该使用更一般化的要求）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 这个规格说明不是决定性的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 这个规格说明不是操作性的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Behavioral oddities&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;secondToLastIndexOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
  - requires:
    val appears in arr an odd number of times
  - effects:
    returns the 2nd-largest i such that arr[i] == val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;思考下面这些对于 &lt;code&gt;secondToLastIndexOf&lt;/code&gt;的测试用例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;[ 1, 3, 4 ], 3&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[ ] 合理的测试用例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，后置条件变强，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 如果后置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;[ 1, 3, 3, 4 ], 3&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[ ] 合理的测试用例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 如果前置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，后置条件变强，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果后置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;[ 1, 3, 3, 3, 4 ], 3&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] 合理的测试用例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，后置条件变强，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果后置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;[ 3, 3, 3, 3 ], 3&lt;/code&gt; 抛出一个异常&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[ ] 合理的测试用例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果前置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] 如果前置条件变弱，后置条件变强，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] 如果后置条件变弱，这个测试用例就是合理的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Odd doc&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;secondToLastIndexOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; val)
  - requires:
    val appears in arr an odd number of times
  - effects:
    returns the 2nd-largest i such that arr[i] == val&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（首先这是一个糟糕的规格说明）在下面选取合适的行组成这个规格说明在代码中的注释：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;/*&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;/**&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;* Finds the second-to-last occurrence of a value in an array.&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;* Find j, the largest index such that arr[j] == val.&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;* Then find i, the largest index such that i &amp;lt; j and arr[i] == val.&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;* @param arr array to search&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;* @param arr fixed-size array of integers to search&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;* @param val value to search for&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;* @param val value to search for, requires val appears in arr an odd number of times&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;* @return index i&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;* @return second-largest index i such that arr[i] == val&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;*/&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;规格说明在使用者和实现者之间起着一道防火墙的作用——对于人和代码之间也是一样。正如上篇阅读谈到的（译者注：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8566500.html&quot;&gt;“规格说明”&lt;/a&gt;），这使得独立开发成为可能：使用者可以在不阅读模块源码的情况下将源码应用到各个地方，使用者可以不在意模块被使用的环境（只要他们都遵循规格说明的要求）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际使用中，声明性的规格说明是最重要的。前置条件（弱化规格说明）使得使用者更困难（确保输入合法），但是&lt;strong&gt;合理的使用&lt;/strong&gt;会使得实现者能够做出一些假设，从而选择更合适的实现方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和往常一样，试着将这篇阅读的知识点和我们的三个目标联系起来：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;远离bug&lt;/strong&gt;. 如果没有规格说明，即使是最小的更改都有可能使得整个程序崩溃，改动起来也是很麻烦的。一个结构良好、逻辑明确的规格说明会最小化使用者和实现者之间的误解，并帮助我们进行静态检查、测试、代码评审等等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;易于理解&lt;/strong&gt;. 一个好的规格说明会让使用者不必去阅读源码也能正确安全地使用模块。例如，你可能永远不会去阅读&lt;a href=&quot;https://hg.python.org/cpython/file/7ae156f07a90/Objects/dictobject.c#l1990&quot;&gt;Python &lt;code&gt;dict.update&lt;/code&gt;&lt;/a&gt; ，但是通过阅读&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.update&quot;&gt;对应的声明性规格说明&lt;/a&gt;你就能很好的应用它。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可改动性&lt;/strong&gt;. 一个合理的“弱”规格说明会给实现者一定的自由，而一个“强”的规格说明会给使用者一定的自由。我们甚至可以改变规格说明本身：只要我们是加强了它而不是削弱了它（减弱前置条件或者增强后置条件）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 19 Mar 2018 17:07:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8606687.html</dc:identifier>
</item>
<item>
<title>Python 从入门到入门基础练习十五题 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8606255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8606255.html</guid>
<description>&lt;p&gt;1、永远的 HelloWorld&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、M与N的数学运算：用户输入两个数 M 和 N，其中 N 是整数，计算M 和 N 的5种数学运算结果，并依次输出，结果间用空格分隔。&lt;/p&gt;
&lt;p&gt;5种数学运算分别是：M 与 N 的和、M 与 N 的乘积、M 的 N 次幂、M除 N 的余数、M 和 N 中较大的值。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;3&quot;&gt;m = eval(input())&lt;br/&gt;n = eval(input())&lt;p&gt;list = []&lt;br/&gt;list.append(str(m+n))&lt;br/&gt;list.append(str(m*n))&lt;br/&gt;list.append(str(m**n))&lt;br/&gt;list.append(str(m%n))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m &amp;gt; n:&lt;br/&gt;list.append(str(m))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;list.append(str(n))&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;.join(tuple(list)))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、将输入的字符串垂直输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(string)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; char &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; string:&lt;br/&gt;print(char)&lt;p&gt;s = input()&lt;br/&gt;Output(s)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、计算矩形面积：用户输入矩形的长和宽，计算其面积并输出，结果四舍五入，保留2位小数。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;2&quot;&gt;a = eval(input(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请输入矩形长度:&quot;&lt;/span&gt;))&lt;br/&gt;b = eval(input(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请输入矩形宽度:&quot;&lt;/span&gt;))&lt;p&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;面积是:%.2f&quot;&lt;/span&gt;%(a*b))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、计算2的n次方，n由用户输入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;a = eval(input())&lt;p&gt;print(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;**a)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、成绩转换：编写一个学生成绩转换程序，用户输入百分制的学生成绩，成绩大于或等于60的输出“pass”，否则输出“fail”，成绩不四舍五入。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;2&quot;&gt;a = eval(input())&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; &amp;gt;= a &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pass&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;fail&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、完美立方：找到大于1的4个整数满足完美立方等式：a3=b3+c3+d3（例如123=63+83+103）。编写一个程序，对于任意给定的正整数N（N ≤100），寻找所有的四元组（a,b,c,d），满足a3=b3+c3+d3，其中1&amp;lt;a，b，c，d≤N。&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;18&quot;&gt;n = int(input())  &lt;p&gt;list_cube = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):&lt;br/&gt;list_cube.append(i * i * i)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, n + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; b &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, a - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; list_cube[a] &amp;lt; (list_cube[b] + list_cube[b + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] + list_cube[b + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(b + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, a):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; list_cube[a] &amp;lt; (list_cube[b] + list_cube[c] + list_cube[c + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(c + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, a):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; list_cube[a] == (list_cube[b] + list_cube[c] + list_cube[d]):&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Cube=%d,Tripe=(%d,%d,%d)&quot;&lt;/span&gt; % (a, b, c, d))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、货币转换：写一个程序进行货币间币值转换，其中：人民币和美元间汇率固定为：1美元 = 6.78人民币。&lt;/p&gt;
&lt;p&gt;程序可以接受人民币或美元输入，转换为美元或人民币输出。人民币采用RMB表示，美元USD表示，符号和数值之间没有空格。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re&lt;br/&gt;money = input().lower()&lt;br/&gt;tmp=re.findall(&lt;span class=&quot;hljs-string&quot;&gt;'usd|rmb'&lt;/span&gt;,money)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; len(tmp)==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; len(tmp)&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'wrong'&lt;/span&gt;)&lt;br/&gt;money=re.sub(tmp[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;hljs-string&quot;&gt;''&lt;/span&gt;,money)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:&lt;br/&gt;num=float(money)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'usd'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; tmp:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'RMB%.2f'&lt;/span&gt;%(num*&lt;span class=&quot;hljs-number&quot;&gt;6.78&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'USD%.2f'&lt;/span&gt;%(num/&lt;span class=&quot;hljs-number&quot;&gt;6.78&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'wrong'&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9、月份缩写：如果有 months = &quot;Jan.Feb.Mar.Apr.May.Jun.Jul.Aug.Sep.Oct.Nov.Dec.&quot;，编写一个程序，用户输入一个月份的数字，输出月份的缩写。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;2&quot;&gt;months = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Jan.Feb.Mar.Apr.May.Jun.Jul.Aug.Sep.Oct.Nov.Dec.&quot;&lt;/span&gt;&lt;br/&gt;n = input()&lt;p&gt;&lt;br/&gt;index = (int(n)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)*&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;&lt;br/&gt;month = months[index: index + &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]&lt;br/&gt;print(month)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10、温度转换：编写程序将用户输入华氏度转换为摄氏度，或将输入的摄氏度转换为华氏度。&lt;/p&gt;
&lt;p&gt;转换算法如下：（C表示摄氏度、F表示华氏度）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;     &lt;span class=&quot;hljs-attribute&quot;&gt;C&lt;/span&gt; = ( F - &lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt; ) / &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;&lt;br/&gt;F = C * &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要求如下：&lt;/p&gt;
&lt;p&gt;(1) 输入输出的摄氏度采用大写字母C开头，温度可以是整数或小数，如：C12.34指摄氏度12.34度；&lt;/p&gt;
&lt;p&gt;(2) 输入输出的华氏度采用大写字母F开头，温度可以是整数或小数，如：F87.65指摄氏度87.65度；&lt;/p&gt;
&lt;p&gt;(3) 不考虑异常输入的问题，输出保留小数点后两位；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;Temperature = input()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; Temperature[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-string&quot;&gt;'F'&lt;/span&gt;]:&lt;br/&gt;C = (eval(Temperature[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:])&lt;span class=&quot;hljs-number&quot;&gt;-32&lt;/span&gt;)/&lt;span class=&quot;hljs-number&quot;&gt;1.8&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C{:.2f}&quot;&lt;/span&gt;.format(C))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;F = &lt;span class=&quot;hljs-number&quot;&gt;1.8&lt;/span&gt;*eval(Temperature[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:])+&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;F{:.2f}&quot;&lt;/span&gt;.format(F))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;11、汇率兑换：按照1美元=6人民币的汇率来编写一个美元与人民币的双向兑换程序&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;5&quot;&gt;money = input()&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; money[&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-string&quot;&gt;'$'&lt;/span&gt;]:&lt;br/&gt;m = &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;*eval(money[:&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;])&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{:.2f}R&quot;&lt;/span&gt;.format(m))&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; money[&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-string&quot;&gt;'R'&lt;/span&gt;]:&lt;br/&gt;m = eval(money[:&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;])/&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{:.2f}$&quot;&lt;/span&gt;.format(m))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入错误！&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;12、恺撒密码：凯撒密码是古罗马凯撒大帝用来对军事情报进行加解密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列中该字符后面的第三个字符，即，字母表的对应关系如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&lt;br/&gt;密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于原文字符P，其密文字符C满足如下条件：C=(P+3) mod 26&lt;/p&gt;
&lt;p&gt;上述是凯撒密码的加密方法，解密方法反之，即：P=(C-3) mod 26&lt;/p&gt;
&lt;p&gt;假设用户可能使用的输入仅包含小写字母a~z和空格，请编写一个程序，对输入字符串进行凯撒密码加密，直接输出结果，其中空格不用进行加密处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;sr1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abcdefghijklmnopqrstuvwxyz&quot;&lt;/span&gt;&lt;br/&gt;sr2 = sr1.upper()&lt;br/&gt;sr = sr1 + sr1 + sr2 + sr2&lt;br/&gt;in_str = input(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;out_str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; in_str:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; j == &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;:&lt;br/&gt;out_str = out_str + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;&lt;br/&gt;i = sr.find(j)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;):&lt;br/&gt;out_str = out_str + sr[i+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;br/&gt;print(out_str)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;13、个人所得税计算：个人所得税采用“超额累进税率”计算方法，简化公式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;   缴税 = （个人薪金扣险所得 – 个税免征额）* 税率&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，个税免征额为3500元，税率根据应纳税额数量而不同，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img-blog.csdn.net/20180320001456826&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;注意：“应纳税额”为：个人薪金扣险所得 – 个税免征额&lt;/p&gt;
&lt;p&gt;请编写一个程序根据用户输入计算个人所得税，用户输入是个人薪金扣险所得。&lt;/p&gt;
&lt;p&gt;约定用户输入为以人民币元为单位的整数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;m = int(input())&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;3500&lt;/span&gt;:&lt;br/&gt;m1 = m - &lt;span class=&quot;hljs-number&quot;&gt;3500&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1500&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.03&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;4500&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;9000&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;35000&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.25&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;55000&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.3&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; m1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;80000&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.35&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0.45&lt;/span&gt; * m1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;ans = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%.0f&quot;&lt;/span&gt;%ans)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;14、3位水仙花数计算：“3位水仙花数”是指一个三位整数，其各位数字的3次方和等于该数本身。例如：ABC是一个“3位水仙花数”，则：A的3次方＋B的3次方＋C的3次方 = ABC。&lt;/p&gt;
&lt;p&gt;请按照从小到大的顺序输出所有的3位水仙花数，请用一个“逗号+空格”分隔输出结果。&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; math&lt;br/&gt;list = []&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;):&lt;br/&gt;x = math.floor(i / &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)&lt;br/&gt;y = math.floor((i - x * &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;) / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;z = i - math.floor(i / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == x ** &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; + y ** &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; + z ** &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;:&lt;br/&gt;list.append(str(i))&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot;&lt;/span&gt;.join(tuple(list)))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;15、统计下列英文诗歌：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;All that doth flow we cannot liquid name&lt;br/&gt;Or &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; would fire &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; water be the same;&lt;br/&gt;But that &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; liquid which &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; moist &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; wet&lt;br/&gt;Fire that property can never get.&lt;br/&gt;Then &lt;span class=&quot;hljs-string&quot;&gt;'tis not cold that doth the fire put out&lt;br/&gt;But '&lt;/span&gt;tis the wet that makes it die, &lt;span class=&quot;hljs-literal&quot;&gt;no&lt;/span&gt; doubt.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编程实现对纽卡斯伯爵的不朽名篇What Is Liquid的统计工作。这首诗（1）有多少个字符？（计入空格和换行符）（2）判断是否以All开头？（3）判断是否以That's all, folks!结尾？（4）第一次和最后一次出现单词the的位置（偏移量）。（5）the出现的总次数？（6）判断诗中出现的所有字符是否都是字母和数字？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;All that doth flow we cannot liquid name Or else would fire and water be the same;But that is liquid which is moist and wet Fire that property can never get. Then 'tis not cold that doth the fire put out But 'tis the wet that makes it die, no doubt. &quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;这首词总共有:&quot;&lt;/span&gt; + str(&lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(s)) + &lt;span class=&quot;hljs-string&quot;&gt;&quot;个字符串&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;这首诗是否以All开头:&quot;&lt;/span&gt;,s.startswith(&lt;span class=&quot;hljs-string&quot;&gt;'All'&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;这首诗是否以That\'s all, folks!结尾:&quot;&lt;/span&gt;,s.endswith(&lt;span class=&quot;hljs-string&quot;&gt;'That\'s all, folks!'&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一次出现单词the的位置:&quot;&lt;/span&gt;,s.&lt;span class=&quot;hljs-built_in&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;' the '&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;最后一次出现单词the的位置:&quot;&lt;/span&gt;,s.rfind(&lt;span class=&quot;hljs-string&quot;&gt;' the '&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;the在诗中出现的总次数:&quot;&lt;/span&gt;,s.count(&lt;span class=&quot;hljs-string&quot;&gt;' the '&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;是否诗中出现的所有字符都是字母和数字:&quot;&lt;/span&gt;,s.isalnum())&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 19 Mar 2018 16:26:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8606255.html</dc:identifier>
</item>
<item>
<title>软件质量与测试--第二周作业 WordCount - wzf_hehe</title>
<link>http://www.cnblogs.com/wzf-hehe/p/8605961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzf-hehe/p/8605961.html</guid>
<description>&lt;h2 id=&quot;github地址&quot;&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/wzfhuster/software_test_tasks&quot; class=&quot;uri&quot;&gt;https://github.com/wzfhuster/software_test_tasks&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;psp表格&quot;&gt;psp表格：&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Planning&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;计划&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;30&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;· Estimate&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 估计这个任务需要多少时间&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;50&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;40&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Development&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;开发&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;300&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;400&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;· Analysis&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 需求分析 (包括学习新技术)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;50&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;80&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;· Design Spec&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 生成设计文档&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;40&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;· Design Review&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 设计复审 (和同事审核设计文档)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;50&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;· Coding Standard&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 代码规范 (为目前的开发制定合适的规范)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;40&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;59&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;· Design&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 具体设计&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;30&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;40&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;· Coding&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 具体编码&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;120&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;180&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;· Code Review&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 代码复审&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;90&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;89&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;· Test&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 测试（自我测试，修改代码，提交修改）&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;60&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;189&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Reporting&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;报告&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;120&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;150&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;· Test Report&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 测试报告&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;20&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;· Size Measurement&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 计算工作量&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;· Postmortem &amp;amp; Process Improvement Plan&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;· 事后总结, 并提出过程改进计划&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;50&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td/&gt;
&lt;td align=&quot;center&quot;&gt;合计&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;1072&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1497&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;解题思路:&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;首先：&lt;/strong&gt; 根据需求首先最传入main函数中的args解析出对应的命令，文件名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-c命令：&lt;/strong&gt; 由于需求中没有明确说明我默认回车换行不算字符，然后首先用BufferedReader对象逐行的读取源文件，&lt;br/&gt;　　　　每一行暂时保存到String对象中，然后利用String对象的length（）方法直接返回改行的字符数，然后把各行的&lt;br/&gt;　　　　字符数都加起来，即得到总的字符数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-w命令：&lt;/strong&gt; 对于计算单词数则同样，因为以换行隔开的也是单个单词，所以还是逐行读取，然后利用String对象的&lt;br/&gt;　　　　一个split方法，就可以指定以空格,逗号作为分隔符，返回一个字符串数组，然后对字符数组的个数相加&lt;br/&gt;　　　　　即得单词的个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-l命令：&lt;/strong&gt; 这个也就很简单了，直接用readLine（）函数每读一行计数器就加一，返回总的行数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-a命令：&lt;/strong&gt; 这个就是在读取每一行的时候对当前行进行判断，设置三个计数器，分别记录代码行，注释行，空行的行数&lt;br/&gt;　　　　当该行全是空格或者制表符或者不超过一个字符时就是空行，若是以//开头或者}//开头的就是注释行，否&lt;br/&gt;　　　　　则就是代码行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-o命令：&lt;/strong&gt; 这个就是就是将统计结果写入一个指定的文件中，代码中可以用一个ArrayList&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;程序的设计实现过程&quot;&gt;程序的设计实现过程&lt;/h2&gt;
&lt;p&gt;　　对命令的解析采用一个for循环，对传入的字符串数组的每个字符串都对其进行判断，看对应哪个命令就调用相应的处理程序进行处理，程序的实现我只写了一个类，在这个类中既有main函数，也有其它功能函数的实现，由于需要将多个功能的查询结果写入到一个文件中所以我在类中添加了一个静态的ArrayList&lt;/p&gt;

&lt;h2 id=&quot;代码说明&quot;&gt;代码说明：&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package wordCount;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; WordCount {
    
    &lt;span class=&quot;co&quot;&gt;//这里创建的list用来存放每个命令处理后的输出的结果&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//用来保存这些结果，需要输出到文件时，就将list中的结果都输出到指定文件中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ArrayList&amp;lt;String&amp;gt; sList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args){
        WordCount wc = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;WordCount&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;&amp;gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; last = args.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        String name = args[last];   &lt;span class=&quot;co&quot;&gt;//用来存放读取文件的名字&lt;/span&gt;
        String outputName = &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;     &lt;span class=&quot;co&quot;&gt;//用来存放输出文件的名字&lt;/span&gt;
        String tmp;
        
        &lt;span class=&quot;co&quot;&gt;//是否将结果写入某个文件的标志&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flag = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        
        &lt;span class=&quot;co&quot;&gt;//这个for用来判断是否需要将信息输出到一个文件中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;last;i++)
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args[i].&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-o&quot;&lt;/span&gt;))
            {
                flag=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
                name = args[last&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;];
                outputName = args[last];
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
        
        &lt;span class=&quot;co&quot;&gt;//这个for用来循环读取命令行中传入的参数&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;last;i++)
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args[i].&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-c&quot;&lt;/span&gt;)) 
                {
                    tmp = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(wc.&lt;span class=&quot;fu&quot;&gt;getC&lt;/span&gt;(name));
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(tmp);
                    sList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(tmp);
                }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args[i].&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-w&quot;&lt;/span&gt;))
            {
                tmp = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(wc.&lt;span class=&quot;fu&quot;&gt;getW&lt;/span&gt;(name));
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(tmp);
                sList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(tmp);
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args[i].&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-l&quot;&lt;/span&gt;))
            {
                tmp = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(wc.&lt;span class=&quot;fu&quot;&gt;getl&lt;/span&gt;(name));
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(tmp);
                sList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(tmp);
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(args[i].&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-a&quot;&lt;/span&gt;))
            {
                tmp = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(wc.&lt;span class=&quot;fu&quot;&gt;geta&lt;/span&gt;(name));
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(tmp);
                sList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(tmp);
            }
        
        &lt;span class=&quot;co&quot;&gt;//如果flag=1，表示需要将结果输出到一个文件中&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            {
                wc.&lt;span class=&quot;fu&quot;&gt;writeFile&lt;/span&gt;(outputName);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;将信息写入&quot;&lt;/span&gt;+outputName+&lt;span class=&quot;st&quot;&gt;&quot;文件成功！！！&quot;&lt;/span&gt;);
            }
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;请先输入参数！！！&quot;&lt;/span&gt;);   &lt;span class=&quot;co&quot;&gt;//如果wc.exe后面没有输入参数，就打印提示信息&lt;/span&gt;
                
    }
    
    
    &lt;span class=&quot;co&quot;&gt;//该函数用来计算指定文件中字符的个数，《其中回车换行都没计入字符数中！！！》&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getC&lt;/span&gt;(String fileName)
    {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        String s;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(fileName));
            &lt;span class=&quot;co&quot;&gt;//FileReader in = new FileReader(fileName);&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((s=in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;())!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                count+=s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;();
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (FileNotFoundException e1) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;找不到文件!!!&quot;&lt;/span&gt;);
            e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; fileName+&lt;span class=&quot;st&quot;&gt;&quot;, 字符数为：&quot;&lt;/span&gt;+count;
    }
    
    
    &lt;span class=&quot;co&quot;&gt;//该函数用来计算指定文件中单词的个数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getW&lt;/span&gt;(String fileName)
    {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        String s;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(fileName));
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((s = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;())!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!s.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;())
                    {
                        String ss []  = s.&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; |,|    &quot;&lt;/span&gt;);
                        count+=ss.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
                    }
            }
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (FileNotFoundException e1) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;找不到文件!!!&quot;&lt;/span&gt;);
            e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; fileName+&lt;span class=&quot;st&quot;&gt;&quot;, 单词数为：&quot;&lt;/span&gt;+count;
    }
    
    &lt;span class=&quot;co&quot;&gt;//该函数用来计算指定文件中的总的行数，包括空的行和注释行&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getl&lt;/span&gt;(String fileName)
    {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        String s;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(fileName));
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((s = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;())!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                ++count;
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (FileNotFoundException e1) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;找不到文件!!!&quot;&lt;/span&gt;);
            e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; fileName+&lt;span class=&quot;st&quot;&gt;&quot;, 总的行数为：&quot;&lt;/span&gt;+count;
    }
    
    
    &lt;span class=&quot;co&quot;&gt;//该函数用来返回具体的代码行数，注释行数和空的行数！！！&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;geta&lt;/span&gt;(String fileName)
    {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,space=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,h=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        String s;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(fileName));
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((s = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;())!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(s.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;() || s.&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()&amp;lt;=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) ++space;
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; t=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
                    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(t&amp;lt;s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()&amp;amp;&amp;amp;s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(t)==' ') ++t;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;((t&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;&amp;lt;s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;amp;&amp;amp; s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(t)=='/' &amp;amp;&amp;amp; s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(t&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)=='/')
                            || (t&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;&amp;lt;s.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;amp;&amp;amp; s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(t&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)=='/' &amp;amp;&amp;amp; s.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(t&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;)=='/')) ++h;
                    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                        ++count;
                }
            }
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (FileNotFoundException e1) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;找不到文件!!!&quot;&lt;/span&gt;);
            e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; fileName+&lt;span class=&quot;st&quot;&gt;&quot;, 代码行/空行/注释行:&quot;&lt;/span&gt;+count+&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;+space+&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;+h;
    }
    
    &lt;span class=&quot;co&quot;&gt;//该行数用来将结果写入指定的文件中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeFile&lt;/span&gt;(String fileName)
    {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            FileWriter w = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileWriter(fileName);
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;i &amp;lt; sList.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();i++)
                {
                    w.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(sList.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(i));
                    w.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
                }
            w.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;呵呵，在写文件过程中出现了错误！！！&quot;&lt;/span&gt;);
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;测试设计过程&quot;&gt;测试设计过程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;测试没有参数输入的情况：&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试单个功能：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;wc.exe -c test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -w test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -l test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -a test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c test.txt -o output.txt&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试组合的输入功能：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;wc.exe -c -w test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c -l test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -w -l test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c -w -l test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -a test.txt -o output.txt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试文件的绝对路径和相对路径：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;wc.exe -c D:/test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c test.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c D:/test.txt -o D:/output.txt&lt;/li&gt;
&lt;li&gt;wc.exe -c D:/test.txt -o output.txt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试错误参数的输入：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;wc.exe -c&lt;/li&gt;
&lt;li&gt;wc.exe test.txt -c&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考文献链接&quot;&gt;参考文献链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tw19811220/article/details/41040937&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/tw19811220/article/details/41040937&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/etjnety/article/details/7842618&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/etjnety/article/details/7842618&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/math/p/se-tools-001.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/math/p/se-tools-001.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Mar 2018 15:51:00 +0000</pubDate>
<dc:creator>wzf_hehe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wzf-hehe/p/8605961.html</dc:identifier>
</item>
<item>
<title>celery学习之入门 - python学习中</title>
<link>http://www.cnblogs.com/c-x-a/p/8605904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/8605904.html</guid>
<description>&lt;h2&gt;Celery 简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/736399/201803/736399-20180319224338763-1683680636.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;493&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Celery 是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;broker：一个消息传输的中间件。每当应用程序调用celery的异步任务的时候，会向broker传递消息，而后celery的worker将会取到消息，执行相应程序。这是消费者和生产者之间的桥梁。broker字符串，RabiitMQ使用&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;amqp://localhost，Redis使用redis://localhost&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;backend: 通常程序发送的消息，发完就完了，可能都不知道对方时候接受了。为此，celery实现了一个backend，用于存储这些消息以及celery执行的一些消息和结果。&lt;/li&gt;
&lt;li&gt;worker: Celery类的实例，作用就是执行各种任务。注意在celery3.1.25后windows是不支持celery worker的！&lt;/li&gt;
&lt;li&gt;producer: 发送任务，将其传递给broker&lt;/li&gt;
&lt;li&gt;beat: celery实现的定时任务。可以将其理解为一个producer，因为它也是通过网络调用定时将任务发送给worker执行。注意在windows上celery是不支持定时任务的！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 由于celery只是任务队列，而不是真正意义上的消息队列，它自身不具有存储数据的功能，所以broker和backend需要通过第三方工具来存储信息，celery官方推荐的是 &lt;a href=&quot;https://link.jianshu.com/?t=https://www.rabbitmq.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;RabbitMQ&lt;/a&gt;和&lt;a href=&quot;https://link.jianshu.com/?t=https://redis.io/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Redis&lt;/a&gt;，另外mongodb等也可以作为broker或者backend，可能不会很稳定，我们这里选择Redis作为broker兼backend。&lt;/p&gt;
&lt;h2&gt;Celery 安装&lt;/h2&gt;
&lt;div readability=&quot;34.813186813187&quot;&gt;
&lt;p&gt;目前，Windows使用celery只能安装 3.1.25版&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
 pip install celery==3.1.25  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/736399/201803/736399-20180319225134381-1658329818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来一个简单例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.celeryproject.org/en/master/getting-started/introduction.html#get-started&quot; target=&quot;_blank&quot;&gt;使用官网上的例子&lt;/a&gt;，然后把broker的信息改好，这里我们使用redis&lt;/p&gt;
&lt;p&gt;关于redis的安装请点击 &lt;a href=&quot;http://www.cnblogs.com/c-x-a/p/8605772.html&quot; target=&quot;_blank&quot;&gt;windows下redis的安装&lt;/a&gt;，linux的话直接pip install redis即可。&lt;/p&gt;

&lt;p&gt;首先在D:\CeleryDemo新建一个文件叫task.py输入以下代码。在输入之前确保redis服务是启动的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from celery import Celery

app = Celery('tasks',  backend='redis://localhost:6379/0', broker='redis://localhost:6379/0') #配置好celery的backend和broker

@app.task  #普通函数装饰为 celery task
def add(x, y):
    return x + y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　broker 我们有了，backend 我们有了，task 我们也有了，现在就该运行 worker 进行工作了，在 task.py 所在目录下运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
celery -A task worker --loglevel=info     意思就是运行 task 这个任务集合的 worker 进行工作（当然此时broker中还没有任务，worker此时相当于待命状态）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　可以看到如下内容：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/736399/201803/736399-20180319233435036-1805997140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后一步，触发任务，最简单方式就是在task.py所在目录下写一个trigger.py调用被装饰成 task 的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from task import add
import time
result = add.delay(4, 4) #不要直接 add(4, 4)，这里需要用 celery 提供的接口 delay 进行调用
while not result.ready():
    time.sleep(1)
print ('task done: {0}'.format(result.get()))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　运行之后可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/736399/201803/736399-20180319233818548-1193167438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 好了，恭喜你已经入门了。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 19 Mar 2018 15:39:00 +0000</pubDate>
<dc:creator>python学习中</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/8605904.html</dc:identifier>
</item>
<item>
<title>mybatis-spring整合 - 江南小俊</title>
<link>http://www.cnblogs.com/jnxj/p/8605902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jnxj/p/8605902.html</guid>
<description>&lt;p&gt;Spring,mybatis,mybatis-spring,mysql等。。。&lt;/p&gt;
&lt;p&gt;&amp;lt;properties&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- spring版本号 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;spring.version&amp;gt;4.2.5.RELEASE&amp;lt;/spring.version&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- mybatis版本号 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;mybatis.version&amp;gt;3.2.8&amp;lt;/mybatis.version&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- mysql驱动版本号 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;mysql-driver.version&amp;gt;5.1.29&amp;lt;/mysql-driver.version&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- log4j日志包版本号 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;slf4j.version&amp;gt;1.7.18&amp;lt;/slf4j.version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;log4j.version&amp;gt;1.2.17&amp;lt;/log4j.version&amp;gt;&lt;/p&gt;

&lt;p&gt;       &amp;lt;/properties&amp;gt;&lt;/p&gt;


&lt;p&gt;       &amp;lt;dependencies&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;!-- 数据库连接池包 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.mchange&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;0.9.5-pre8&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;!-- 添加jstl依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;7.0&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加junit4依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;!-- 指定范围，在测试时才会加载 --&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加spring核心依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-oxm&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加mybatis依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${mybatis.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加mybatis/spring整合包依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.2.2&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加mysql驱动依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${mysql-driver.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;!-- 添加数据库连接池依赖 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;commons-dbcp&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;commons-dbcp&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.2.2&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加fastjson --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.1.41&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- 添加日志相关jar包 --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- log end --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;!-- 映入JSON --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;jackson-mapper-asl&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.9.13&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;2.8.0&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;2.8.0&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.9&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;!-- https://mvnrepository.com/artifact/com.github.abel533/ECharts --&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.github.abel533&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;ECharts&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;

&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;groupId&amp;gt;net.sf.jxls&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;artifactId&amp;gt;jxls-core&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;version&amp;gt;1.0.5&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;            &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;       &amp;lt;/dependencies&amp;gt;&lt;/p&gt;

&lt;p&gt;       &amp;lt;build&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;plugins&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;plugin&amp;gt;&lt;/p&gt;
&lt;p&gt;                            &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p&gt;                            &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p&gt;                            &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;                            &amp;lt;configuration&amp;gt;&lt;/p&gt;
&lt;p&gt;                                   &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;&lt;/p&gt;
&lt;p&gt;                                   &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;&lt;/p&gt;
&lt;p&gt;                            &amp;lt;/configuration&amp;gt;&lt;/p&gt;
&lt;p&gt;                     &amp;lt;/plugin&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;/plugins&amp;gt;&lt;/p&gt;
&lt;p&gt;              &amp;lt;finalName&amp;gt;ssm4&amp;lt;/finalName&amp;gt;&lt;/p&gt;
&lt;p&gt;       &amp;lt;/build&amp;gt;&lt;/p&gt;

&lt;h2&gt;2.1applicationContext.xml&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233246342-45116443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.1.1第一是要引入数据文件jdbc.properties:保存数据库连接参数的信息&lt;/h3&gt;
&lt;h3&gt;2.1.2第二配置数据源，这里配置了dbcp连接池&lt;/h3&gt;
&lt;h3&gt;2.1.3配置SqlSessionFactory,让spring自动生成管理，这里要引用数据源和mybatis的配置文件&lt;/h3&gt;
&lt;h3&gt;2.1.4配置Dao接口，class指向实现类全称&lt;/h3&gt;
&lt;h2&gt;2.2mybatis.xml配置&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233308148-1518556964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.1加载配置文件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233418028-1048162407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.3jdbc.porperties&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233523474-726180698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.4log4j.porperties&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233531657-445700484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;3.1项目结构&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233538558-159501797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.1.1UserDao接口&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233543634-1439223065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.1.2UserDaoImpl实现类（实现类要继承SqlSessionDaoSupport类）&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233548707-930688881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.1.3测试类&lt;/h3&gt;



&lt;h2&gt;4.1修改applicationContext.xml&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233601299-1235508790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(1)    第一种配置mapper,每个mapper都要配置一次，工程重复繁琐&lt;/p&gt;
&lt;p&gt;(2)    第二种批量配置mapper,只要指定basepackage的包，就会到这个下面去扫描，多个包用半角逗号隔开&lt;/p&gt;
&lt;h2&gt;4.2修改mybatis.xml&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233607744-881833563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(1)注释掉mapper文件的扫描&lt;/p&gt;

&lt;h2&gt;5.1UserMapper.java&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233629573-245442940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5.2UserMapper.xml&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233642027-1167078861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5.3测试&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233649501-744859623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.3.1加载applicationContext.xml文件&lt;/h3&gt;
&lt;h3&gt;5.3.2获取Mapper代理对象&lt;/h3&gt;
&lt;h3&gt;5.3.3使用Mapper的方法操作数据库&lt;/h3&gt;

&lt;h2&gt;6.1配置generator.xml配置文件&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233700953-1606617468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.2運行java代碼生成代碼&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233710162-534283889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意：file对应的位置是6.1配置文件的位置&lt;/p&gt;
&lt;h2&gt;6.3刷新工程&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233715334-695590575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6.3.1po包下的Example类是用于条件查询&lt;/h3&gt;
&lt;h3&gt;6.3.2测试&lt;/h3&gt;
&lt;h4&gt;6.3.2.1查询测试&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233722183-1930459273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）      一般的查询是一样的&lt;/p&gt;
&lt;p&gt;（2）      条件查询的步骤是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建example对象，&lt;/li&gt;
&lt;li&gt;生成criteria对象&lt;/li&gt;
&lt;li&gt;通过criteria对象拼凑条件&lt;/li&gt;
&lt;li&gt;通过mapper去调用相关的查询方法传入example对象&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;6.3.2.2更新测试&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1348264/201803/1348264-20180319233727821-1962018879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）      updateByPrimaryKey需要先查询才能更新&lt;/p&gt;
&lt;p&gt;（2）      updateByPrimaryKeySelective不需要先查询才能更新，一般用于批量更新&lt;/p&gt;

</description>
<pubDate>Mon, 19 Mar 2018 15:38:00 +0000</pubDate>
<dc:creator>江南小俊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jnxj/p/8605902.html</dc:identifier>
</item>
<item>
<title>asp.net-基础-20180319 - snake1118</title>
<link>http://www.cnblogs.com/snake1118/p/8605897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snake1118/p/8605897.html</guid>
<description>&lt;p&gt;建立动态web 。&lt;/p&gt;
&lt;p&gt;.net的一部分。&lt;/p&gt;
&lt;p&gt;HTML：超文本标记语言。WWW浏览器上文档的格式化语言。&lt;/p&gt;
&lt;p&gt;HTTP：超文本传输协议。WWW浏览器与服务器应用层通信协议。&lt;/p&gt;
&lt;p&gt;静态页面：不需要服务器额外代码处理的页面。纯html页面。&lt;/p&gt;
&lt;p&gt;动态页面：返回给浏览器之前服务器处理过的页面。&lt;/p&gt;
&lt;p&gt;asp.net发展史：2000年1.0，2003年1.1，2005年2.0&lt;/p&gt;
&lt;p&gt;asp.net特性：&lt;/p&gt;
&lt;p&gt;代码后置，页面脱离代码&lt;/p&gt;
&lt;p&gt;请求：request。&lt;/p&gt;
&lt;p&gt;--------------&lt;/p&gt;
&lt;p&gt;.net framework，包含CLR、BCL。&lt;/p&gt;
&lt;p&gt;CLR：公共语言运行库。&lt;/p&gt;
&lt;p&gt;----------------&lt;/p&gt;
&lt;p&gt;文件扩展名&lt;/p&gt;
&lt;p&gt;xml      xml文件&lt;/p&gt;
&lt;p&gt;html    html文件&lt;/p&gt;
&lt;p&gt;ascx   web用户控件&lt;/p&gt;
&lt;p&gt;master 母版页&lt;/p&gt;
&lt;p&gt;config  web配置文件&lt;/p&gt;
&lt;p&gt;asax    全局应用程序类&lt;/p&gt;
&lt;p&gt;asmx  web服务&lt;/p&gt;
&lt;p&gt;-------------&lt;/p&gt;
&lt;p&gt;页面指令&lt;/p&gt;
&lt;p&gt;&amp;lt;%@page%&amp;gt;　　　　&lt;/p&gt;
&lt;p&gt;&amp;lt;%@import  Namespace=&quot;Value&quot;%&amp;gt;&lt;/p&gt;
&lt;p&gt;---------------&lt;/p&gt;
&lt;p&gt;注释： &amp;lt;%%&amp;gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Mar 2018 15:37:00 +0000</pubDate>
<dc:creator>snake1118</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snake1118/p/8605897.html</dc:identifier>
</item>
<item>
<title>MySQL多数据源笔记5-ShardingJDBC实战 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/8605892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/8605892.html</guid>
<description>&lt;p&gt;Sharding-JDBC集分库分表、读写分离、分布式主键、柔性事务和数据治理与一身，提供一站式的解决分布式关系型数据库的解决方案。&lt;/p&gt;
&lt;p&gt;从2.x版本开始，Sharding-JDBC正式将包名、Maven坐标、码云仓库、Github仓库和官方网站统一为io.shardingjdbc。这意味着除了当当的无私奉献，我们也乐于采纳第三方公司的代码贡献。本次2.0.0的版本，由当当与数人云共同开发。&lt;/p&gt;
&lt;p&gt;Sharding-JDBC是一款基于JDBC的数据库中间件产品，对Java的应用程序无任何改造成本，只需配置分片规则即可无缝集成进遗留系统，使系统在数据访问层直接具有分片化和分布式治理的能力。&lt;/p&gt;
&lt;p&gt;Sharding-JDBC 1.x关注SQL兼容性、分库分表、读写分离、分布式主键、柔性事务等分片功能；Sharding-JDBC 2.x提供了全新的Orchestration模块，关注数据库和数据库访问层应用的治理。2.0.0在治理方面的主要更新是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;配置动态化。可以通过zookeeper或etcd作为注册中心动态修改数据源以及分片规则。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据治理。提供熔断数据库访问程序对数据库的访问和禁用从库的访问的能力。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跟踪系统支持。可以通过sky-walking等基于Opentracing协议的APM系统中查看Sharding-JDBC的调用链，并提供sky-walking的自动探针。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供Sharding-JDBC的spring-boot-starter。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过2.x提供的数据治理能力，sharding-jdbc的架构图是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319211142885-1841358355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边部分是&lt;strong&gt;部署架构图&lt;/strong&gt;，右边部分则是核心&lt;strong&gt;逻辑架构图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分片规则配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sharding-JDBC的分片策略配置是自定义的，因此可以通过编程的方式最大限度的灵活调整。它并不仅支持=运算符分片，可支持BETWEEN和IN的运算符分片，支持将一条逻辑SQL最终散落至多个数据节点。同时支持多分片键，&lt;/p&gt;
&lt;p&gt;例如：根据用户ID分库，订单ID分表这种分库分表结合的分片策略；或根据年分库，月份+用户区域ID分表这样的多片键分片。&lt;/p&gt;
&lt;p&gt;通过编程的方式定制分片规则虽然灵活，但配置起来略显繁琐。因此Sharding-JDBC又提供了&lt;strong&gt;In line表达式&lt;/strong&gt;编写分片策略的方式，用于配置集中化，以避免配置散落在配置文件和代码中的情况。此外，它还提供了定制化的Spring命名空间和YAML进一步简化配置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sharding-JDBC核心流程:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sharding-JDBC是一个具有分库分表功能的数据库中间件。它通过JDBC扩展 =&amp;gt; SQL解析 =&amp;gt; SQL路由 =&amp;gt; SQL改写 =&amp;gt; SQL执行 =&amp;gt; 结果归并的流程，&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;在SQL通过使用逻辑表，配合用户配置的分片规则，将对数据库访问的真实SQL完全屏蔽。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1JDBC扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　将JDBC接口中的Connection和Statement(PreparedStatement)的对应关系从一对一转换为一对多。因此一个逻辑SQL的执行，则有可能被拆分为多个执行结果集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.SQL解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　分为词法解析和语法解析。先通过词法解析将SQL拆分为一个个不可再分的单词。再使用语法解析器对SQL进行理解，并最终提炼出解析上下文。&lt;br/&gt;　　　　解析上下文包括表、选择项、排序项、分组项、聚合函数、分页信息、查询条件以及可能需要修改的占位符的标记。&lt;/p&gt;
&lt;p&gt;　　　　Sharding-JDBC支持各种连接、聚合、排序、分组以及分页的解析，并且可以有限度的支持子查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.SQL路由：&lt;/strong&gt;　　　&lt;/p&gt;
&lt;p&gt;　　　　根据解析上下文匹配用户配置的分片策略，并生成路由路径。目前支持分片路由、Hint路由、广播路由、单播路由以及阻断路由等方式。&lt;br/&gt;　　　　分片路由用于携带分片键的SQL路由，根据分片键的不同又可以划分为单片路由(分片操作符是等号)、多片路由(分片操作符是IN)和范围路由(分片操作符是BETWEEN)。&lt;br/&gt;　　　　Hint路由用于通过程序的方式注入路由最终目的地的方式路由，可用于分片信息不包含在SQL中的场景。&lt;br/&gt;　　　　广播路由用于SQL中不包含分片键的场景。根据SQL类型又可以划分为全库广播路由(SET AUTOCOMMIT=1)和全库表广播路由(DQL, DML, DDL)。&lt;br/&gt;　　　　单播路由用于获取某一真实表信息的场景，如DESCRIBE table_name。&lt;br/&gt;　　　　阻断路由用于屏蔽SQL对数据库的操作，如USE db_name，因为Sharding-JDBC仅有一个逻辑数据源，无需切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.SQL改写：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　将SQL改写为在真实数据库中可以正确执行的语句。SQL改写分为正确性改写和优化改写。&lt;br/&gt;　　　　正确性改写包括将逻辑表名称替换为真实表名称，将分页信息的启示取值和结束取值改写，增加为排序、分组和自增主键使用的补列，将AVG改写为SUM / COUNT等。&lt;br/&gt;　　　　优化改写则是能将SQL改写的更加适于在分布式的数据库中执行，如将仅有分组的SQL增加排序字段，以便于将分组归并从内存归并转化为流式归并。&lt;/p&gt;
&lt;p&gt;　　　　正确性改写包括将分表的逻辑表名称替换为真实表名称，修正分页信息和增加补列。举两个例子：　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;分页。假设每10条数据为一页，取第2页数据。在分片环境下获取LIMIT 10, 10，归并之后再根据排序条件取出前10条数据是不正确的结果。正确的做法是将分条件改写为LIMIT 0, 20，取出所有前两页数据，再结合排序条件计算出正确的数据。因此越是获取靠后数据，分页的效率就会越低。有很多方法可避免使用LIMIT进行分页。比如构建记录行记录数和行偏移量的二级索引，或使用上次分页数据结尾ID作为下次查询条件的分页方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　优化改写是1.5.x重点提升的部分，实现的功能比较零散，这里同样举两个例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.SQL执行：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　通过多线程执行器异步执行，但同一个物理数据源的不同分表的SQL会采用同一连接的同一线程，以保证其事务的完整性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　路由至真实数据源后，Sharding -JDBC将采用多线程并发执行SQL。它用3种执行引擎分别对应处理Statement，PreparedStatement和AddBatchPreparedStatement。&lt;/p&gt;
&lt;p&gt;　　　　Sharding-JDBC线程池放在一个名为ShardingContext的对象中，它的生命周期同ShardingDataSource保持一致。&lt;/p&gt;
&lt;p&gt;　　　　如果一个应用中创建了多个Sharding-JDBC的数据源，它们将持有不同的线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5.结果归并：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;将多个执行结果集归并以便于通过统一的JDBC接口输出。结果归并包括流式归并、内存归并和使用装饰者模式的追加归并这几种方式。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　流式归并用于简单查询、排序查询、分组查询以及排序和分组但排序项和分组项完全一致的场景，流式归并的结果集的遍历方式是通过每一次调用next方法取出，无需占用额外的内存。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　内存归并仅用于排序项和分组项不一致的场景，需要将结果集中的所有数据加载至内存处理，如果结果集过多，会占用大量内存。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　使用装饰者模式的追加归并用于分页，无论是简单查询、排序查询还是分组查询，包含分页的SQL都会经过分页的装饰器处理分页相关的结果归并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Sharding-JDBC支持的结果归并&lt;strong&gt;从功能上分为&lt;/strong&gt;遍历、排序、分组和分页4种类型，它们是组合而非互斥的关系。&lt;strong&gt;从结构划分&lt;/strong&gt;，可分为&lt;strong&gt;流式归并&lt;/strong&gt;、&lt;strong&gt;内存归并&lt;/strong&gt;和&lt;strong&gt;装饰者归并&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;流式归并&lt;/strong&gt;是将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。遍历和排序都是&lt;strong&gt;流式归并&lt;/strong&gt;，分组比较复杂，分为流式分组和内存分组。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;内存归并&lt;/strong&gt;则是需要将结果集的所有数据都遍历并存储在内存中，再通过内存归并后，将内存中的数据伪装成结果集返回。&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;　遍历类型最为简单&lt;/strong&gt;，只需将多结果集组成链表，遍历完成当前结果集后，将链表位置后移，继续遍历下一个结果集即可。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;排序类型稍微复杂&lt;/strong&gt;，由于ORDER BY的原因，每个结果集自身数据是有序的，因此只需要将结果集当前游标指向的值排序即可。Sharding-JDBC在排序类型归并时，将每个结果集的当前排序数据实现了比较器，并将其放入优先级队列。&lt;/p&gt;
&lt;p&gt;　　　　每次JDBC调用next时，将队列顶端的结果集出队并next，然后获取新的队列顶端的结果集供JDBC获取数据。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;分组类型最为复杂&lt;/strong&gt;，分组归并已经不属于OLTP范畴，而更面向OLAP，但由于遗留系统使用很多，因此Sharding-JDBC还是将其实现。分组归并分成流式分组归并和内存分组归并。流式分组归并节省内存，但必须要求排序和分组的数据保持一致。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;如果GROUPBY和ORDER BY的内容不一致，则必须使用内存分组归并&lt;/strong&gt;。由于数据不是按照分组需要的顺序取出，因此需要将结果集中的所有数据全部加载至内存。在SQL改写时提到的仅有GROUP BY的SQL，会优化增加ORDER BY语句，即使将内存分组归并优化为流式分组归并的提升。&lt;/p&gt;
&lt;p&gt;　　　　无论是流式分组还是内存分组，对聚合的处理都是一致的。聚合分为比较、累加和平均值3种类型。比较聚合包括MAX和MIN，只返回最大（小）结果。累加聚合包括SUM和COUNT，需要将结果累加后返回。平均值聚合则是通过SQL改写的SUM和COUNT计算，相关内容已在SQL改写涵盖，不再赘述。&lt;/p&gt;
&lt;p&gt;　　　　最后再聊一下&lt;strong&gt;装饰者归并&lt;/strong&gt;，&lt;strong&gt;他是对所有的结果集归并进行统一的功能增强，目前装饰者归并只有分页一种类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;上述的所有归并类型，都可能分页或不分页，因此可以通过装饰者模式来增加分页的能力。分页归并会将改写的LIMIT中，不需要获取的数据过滤掉&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;Sharding-JDBC的分页很容易产生误解，很多人认为分页会占用大量内存，因为Sharding-JDBC会因为分布式正确性的考量，将LIMIT 100000, 10改写为LIMIT 0, 　100010，产生Sharding-JDBC会将100010数据都加载到内存的错觉。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　通过上面分析可知，&lt;strong&gt;会全部加载到内存的只有内存分组归并这一种情况。其他情况都是通过流式获取结果集数据的方式，因此Sharding-JDBC会通过结果集的next方法将无需取出的数据全部跳过，并不会将其存入内存&lt;/strong&gt;。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式主键&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;传统数据库软件开发中，主键自动生成技术是基本需求。而各大数据库对于该需求也提供了相应的支持，比如MySQL的自增键。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　对于MySQL而言，分库分表之后，不同表生成全局唯一的Id是非常棘手的问题。因为同一个逻辑表内的不同实际表之间的自增键是无法互相感知的，&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　这样会造成重复Id的生成。我们当然可以通过约束表生成键的规则来达到数据的不重复，但是这需要引入额外的运维力量来解决重复性问题，并使框架缺乏扩展性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　目前有许多第三方解决方案可以完美解决这个问题，比如UUID等依靠特定算法自生成不重复键，或者通过引入Id生成服务等。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　但也正因为这种多样性导致了Sharding-JDBC如果强依赖于任何一种方案就会限制其自身的发展。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　基于以上的原因，最终采用了以JDBC接口来实现对于生成Id的访问，而将底层具体的Id生成实现分离出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　使用方法分为设置自动生成键和获取生成键两部分：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　设置自动生成键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　配置自增列,代码如下：&lt;/strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
TableRuleConfiguration tableRuleConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TableRuleConfiguration();
tableRuleConfig.setLogicTable(&lt;/span&gt;&quot;t_order&quot;&lt;span&gt;);
tableRuleConfig.setKeyGeneratorColumnName(&lt;/span&gt;&quot;order_id&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　设置Id生成器的实现类，该类必须实现io.shardingjdbc.core.keygen.KeyGenerator接口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　配置全局生成器(com.xx.xx.KeyGenerator)，代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ShardingRuleConfiguration shardingRuleConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShardingRuleConfiguration();
shardingRuleConfig.setDefaultKeyGeneratorClass(&lt;/span&gt;&quot;com.xx.xx.KeyGenerator&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;有时候我们希望部分表的Id生成器与全局Id生成器不同，比如t_order_item表希望使用com.xx.xx.OtherKeyGenerator来生成Id:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
TableRuleConfiguration tableRuleConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TableRuleConfiguration();
tableRuleConfig.setLogicTable(&lt;/span&gt;&quot;t_order&quot;&lt;span&gt;);
tableRuleConfig.setKeyGeneratorColumnName(&lt;/span&gt;&quot;order_id&quot;&lt;span&gt;);
tableRuleConfig.setKeyGeneratorClass(&lt;/span&gt;&quot;com.xx.xx.OtherKeyGenerator&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样t_order就使用com.xx.xx.KeyGenerator生成Id，而t_order_item使用com.xx.xx.OtherKeyGenerator生成Id。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取自动生成键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;通过JDBC提供的API来获取。对于Statement来说调用```statement.execute(&quot;INSERT ...&quot;, Statement.RETURN_GENERATED_KEYS)```&lt;/p&gt;
&lt;p&gt;　　来通知需要返回的生成的键值。对于PreparedStatement则是```connection.prepareStatement(&quot;INSERT ...&quot;, Statement.RETURN_GENERATED_KEYS)```&lt;/p&gt;
&lt;p&gt;　　调用```statement.getGeneratedKeys()```来获取键值的ResultSet。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认的分布式主键生成器:&lt;/strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　类名称：io.shardingjdbc.core.keygen.DefaultKeyGenerator&lt;/p&gt;
&lt;p&gt;　　该生成器采用snowflake算法实现，生成的数据为64bit的long型数据。&lt;br/&gt;　　在数据库中应该用大于等于64bit的数字类型的字段来保存该值，比如在MySQL中应该使用BIGINT。&lt;/p&gt;
&lt;p&gt;　　其二进制表示形式包含四部分，从高位到低位分表为：1bit符号位(为0)，41bit时间位，10bit工作进程位，12bit序列位。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;具体可以去看官方文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　分布式主键在这里单独提炼出一个章节，因为它是贯穿于Sharding-JDBC整个生命周期的。&lt;/p&gt;
&lt;p&gt;　　分布式主键最独立的部分是生成策略，Sharding-JDBC提供灵活的配置分布式主键生成策略方式。在分片规则配置模块可配置每个表的主键生成策略，默认使用snowflake。&lt;/p&gt;
&lt;p&gt;　　通过策略生成的分布式主键可以无缝的融入JDBC协议，它实现了Statement的getGeneratedKeys方法，将其返回改写后的Result和ResultMetaData，将Sharding-JDBC生成的分布式主键伪装为数据库生成的自增主键返回。&lt;/p&gt;
&lt;p&gt;　　SQL解析时，需要根据分布式主键配置策略判断是否在逻辑SQL中已包含主键列，如果未包含则需要将INSERTItems和INSERT Values的最后位置写入解析上下文。&lt;/p&gt;
&lt;p&gt;　　SQL改写时，将根据解析上下文中的位置改写SQL，增加未包含的主键列名称和值。如果是Statement则在INSERT Values后追加生成后的分布式主键；如果是PreparedStatement则在INSERT Values后追加？，并在传入的参数后追加生成后的分布式主键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;ShardingJDBC实战&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;首先去github上面下载官方提供的练习，github地址为：https://github.com/shardingjdbc  下载sharding-jdbc-example练习中的&lt;span class=&quot;final-path&quot;&gt;sharding-jdbc-spring-namespace-example/&lt;span class=&quot;final-path&quot;&gt;sharding-jdbc-spring-namespace-mybatis-example&lt;/span&gt;&lt;/span&gt;，sharding-jdbc-doc是官方文档。&lt;/p&gt;

&lt;p&gt;　　自己搭建一个SSM工程。以下只展示关键的配置和代码。&lt;/p&gt;
&lt;p&gt;　　jdbc.properties配置如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
jdbc_url_1=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/db_1?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc_url_2=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3307/db_2?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc_url_3=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3308/db_3?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc_username=&lt;span&gt;root
jdbc_password&lt;/span&gt;=root
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　spring-cfg.xml的配置，配置说明已经在配置文件注释说明好了。如下代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
       xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
       xmlns:sharding&lt;/span&gt;=&quot;http://shardingjdbc.io/schema/shardingjdbc/sharding&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-4.0.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-4.0.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx-4.0.xsd &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop&lt;/span&gt; &lt;span&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shardingjdbc.io/schema/shardingjdbc/sharding&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shardingjdbc.io/schema/shardingjdbc/sharding/sharding.xsd&quot;&amp;gt;&lt;/span&gt;


    &amp;lt;!--扫描注解生成bean--&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;!--包扫描--&amp;gt;
    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.coder520&quot;/&amp;gt;

    &amp;lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&amp;gt;

    &amp;lt;bean id=&quot;sqlSessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;/&amp;gt;
        &amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/coder520/**/**.xml&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
        &amp;lt;property name=&quot;basePackage&quot; value=&quot;com.coder520.*.dao&quot;/&amp;gt;
        &amp;lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--声明事务管理 采用注解方式--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--开启切面代理--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy/&amp;gt;
    

    &amp;lt;!--主数据库设置--&amp;gt;
    &amp;lt;bean id=&quot;ds_0&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&lt;span&gt;
          destroy&lt;/span&gt;-method=&quot;close&quot; init-method=&quot;init&quot;&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc_url_1}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc_username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--从数据库设置--&amp;gt;
    &amp;lt;bean id=&quot;ds_1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&lt;span&gt;
          destroy&lt;/span&gt;-method=&quot;close&quot; init-method=&quot;init&quot;&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc_url_2}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc_username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--从数据库设置--&amp;gt;
    &amp;lt;bean id=&quot;ds_2&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&lt;span&gt;
          destroy&lt;/span&gt;-method=&quot;close&quot; init-method=&quot;init&quot;&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc_url_3}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc_username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc_password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--分库策略,sharding-column这里根据user_id(这列属性不能是String,只能是整型)分库，precise-algorithm-class是分库算法，--&amp;gt;
    &amp;lt;sharding:standard-strategy id=&quot;databaseShardingStrategy&quot; sharding-column=&quot;user_id&quot;&lt;span&gt;
                                precise&lt;/span&gt;-algorithm-&lt;span&gt;class&lt;/span&gt;=&quot;com.coder520.sharding.PreciseModuloDatabaseShardingAlgorithm&quot;/&amp;gt;
    &amp;lt;!--分表策略，sharding-column这里根据order_id(这列属性不能是String,只能是整型)分表，precise-algorithm-class是分表算法--&amp;gt;
    &amp;lt;sharding:standard-strategy id=&quot;tableShardingStrategy&quot; sharding-column=&quot;order_id&quot;&lt;span&gt;
                                precise&lt;/span&gt;-algorithm-&lt;span&gt;class&lt;/span&gt;=&quot;com.coder520.sharding.PreciseModuloTableShardingAlgorithm&quot;/&amp;gt;

    &amp;lt;!--自己写shardingDataSource嵌入Spring里面--&amp;gt;
    &amp;lt;sharding:data-source id=&quot;shardingDataSource&quot;&amp;gt;
        &amp;lt;!--告诉shardingjdbc你所有库的名字,这里为什么要从0开始命名呢？因为shardingjdbc的分库分表策略是求余来分配的，比如user_id求余3有0，1，2，所以只能这样命名--&amp;gt;
        &amp;lt;sharding:sharding-rule data-source-names=&quot;ds_0,ds_1,ds_2&quot;&amp;gt;
            &amp;lt;sharding:table-rules&amp;gt;
                &amp;lt;!--ds_${0..2}.t_order_${0..2}，这里用到了In line表达式${0..2}，这里是用了笛卡尔乘积运算,比如ds_0.t_order_0 ds_0.t_order_1 ds_0.t_order_2--&amp;gt;
                &amp;lt;!--logic-table是逻辑表 actual-data-nodes是实际的数据源节点--&amp;gt;
                &amp;lt;!--generate-key-column生成主键列，这是一个全局序列号，是唯一的，这是shardingjdbc自动会帮我们生成的。避免我们自己自增造成id重复--&amp;gt;
                &amp;lt;sharding:table-rule logic-table=&quot;t_order&quot; actual-data-nodes=&quot;ds_${0..2}.t_order_${0..2}&quot;&lt;span&gt;
                                     database&lt;/span&gt;-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot;&lt;span&gt;
                                        generate&lt;/span&gt;-key-column=&quot;order_id&quot;/&amp;gt;
                &amp;lt;sharding:table-rule logic-table=&quot;t_order_item&quot; actual-data-nodes=&quot;ds_${0..2}.t_order_item_${0..2}&quot;&lt;span&gt;
                                     database&lt;/span&gt;-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot;&lt;span&gt;
                                        generate&lt;/span&gt;-key-column=&quot;order_item_id&quot;/&amp;gt;
            &amp;lt;/sharding:table-rules&amp;gt;
        &amp;lt;/sharding:sharding-rule&amp;gt;
    &amp;lt;/sharding:data-source&amp;gt;
    
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着在工程中自己建立一个包，把github上的两个分库分表的算法类复制进来，因为spring-cfg.xml中根据这两个类来分库分表的，我这里的包是com.coder520.sharding，&lt;/p&gt;
&lt;p&gt;分库算法类，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.sharding;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.shardingjdbc.core.api.algorithm.sharding.PreciseShardingValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.shardingjdbc.core.api.algorithm.sharding.standard.PreciseShardingAlgorithm;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PreciseModuloDatabaseShardingAlgorithm &lt;span&gt;implements&lt;/span&gt; PreciseShardingAlgorithm&amp;lt;Integer&amp;gt;&lt;span&gt; {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//Collection&amp;lt;String&amp;gt; availableTargetNames是我们在配置文件配置的数据源  PreciseShardingValue&amp;lt;Long&amp;gt; shardingValue是传进来配置文件逻辑表的逻辑表名和传进来user_id列名和值&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;@Override &lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String doSharding(&lt;span&gt;final&lt;/span&gt; Collection&amp;lt;String&amp;gt; availableTargetNames, &lt;span&gt;final&lt;/span&gt; PreciseShardingValue&amp;lt;Integer&amp;gt;&lt;span&gt; shardingValue) { &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String each : availableTargetNames) {&lt;br/&gt;　　　　　　　　//这里求余3是因为我这里在spring-cfg.xml中配置的三个数据库,这里的意思是将数据分到哪一个库中，比如user_id为51,则分配到第一个数据库中，其他数据库中没用信息&lt;br/&gt;&lt;/span&gt;　　　　　　　　if&lt;span&gt; (each.endsWith(shardingValue.getValue() % 3 + &quot;&quot;&lt;/span&gt;&lt;span&gt;)) { &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　return&lt;/span&gt;&lt;span&gt; each;&lt;br/&gt;　　　　　　　　} &lt;br/&gt;　　　　　} &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　throw&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException(); &lt;br/&gt;　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分表算法类代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.sharding;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.shardingjdbc.core.api.algorithm.sharding.PreciseShardingValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.shardingjdbc.core.api.algorithm.sharding.standard.PreciseShardingAlgorithm;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PreciseModuloTableShardingAlgorithm &lt;span&gt;implements&lt;/span&gt; PreciseShardingAlgorithm&amp;lt;Long&amp;gt;&lt;span&gt; {
    &lt;br/&gt;　　//&lt;/span&gt;Collection&amp;lt;String&amp;gt; availableTargetNames是我们在配置文件配置的数据源  PreciseShardingValue&amp;lt;Long&amp;gt; shardingValue是传进来配置文件逻辑表的逻辑表名和传进来user_id列名和值
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;@Override &lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String doSharding(&lt;span&gt;final&lt;/span&gt; Collection&amp;lt;String&amp;gt; availableTargetNames, &lt;span&gt;final&lt;/span&gt; PreciseShardingValue&amp;lt;Long&amp;gt;&lt;span&gt; shardingValue) { &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String each : availableTargetNames) {&lt;br/&gt;　　　　　　　　//这里求余3是因为我这里有三个库，分别是我们在spring-cfg.xml配置的
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (each.endsWith(shardingValue.getValue() % 3 + &quot;&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; each;
            }
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　springmvc.xml和web.xml省略。自己配置。&lt;/p&gt;

&lt;p&gt;　　接着使用github上面的下载下来的小demo来练习&lt;/p&gt;

&lt;p&gt;　　controller代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.order.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.service.DemoService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by cong on 2018/3/19.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DemoService demoService;

    @RequestMapping(&lt;/span&gt;&quot;/test&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        demoService.demo();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;service代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.order.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.dao.OrderItemRepository;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.dao.OrderRepository;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.entity.Order;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.entity.OrderItem;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoService {
    
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderRepository orderRepository;
    
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderItemRepository orderItemRepository;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo() {
        orderRepository.createIfNotExistsTable();
        orderItemRepository.createIfNotExistsTable();&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;entity和dao都是用github上的那个练习下载下来的的，如下：&lt;/p&gt;
&lt;p&gt;　　Order类：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String status;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getOrderId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOrderId(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderId =&lt;span&gt; orderId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getUserId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUserId(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userId =&lt;span&gt; userId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setStatus(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String status) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status =&lt;span&gt; status;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.format(&quot;order_id: %s, user_id: %s, status: %s&quot;&lt;span&gt;, orderId, userId, status);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OderItem类如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.order.entity;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderItem {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderItemId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String status;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getOrderItemId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderItemId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOrderItemId(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderItemId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderItemId =&lt;span&gt; orderItemId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getOrderId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOrderId(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderId =&lt;span&gt; orderId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getUserId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUserId(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userId =&lt;span&gt; userId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setStatus(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String status) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status =&lt;span&gt; status;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.format(&quot;order_item_id:%s, order_id: %s, user_id: %s, status: %s&quot;&lt;span&gt;, orderItemId, orderId, userId, status);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dao和Mapper.xml文件自己去找到那个下载好的DEMO哪里复制进来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319224011031-1940806622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意数据库表不用建立了，因为orderRepository.createIfNotExistsTable();orderItemRepository.createIfNotExistsTable();这里判断表存不存在，不存在自己会建立好的。但是db_1,db_2,db_3,这三个数据库必须建立好。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319224325912-184085569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 接着运行，可以看到每一个数据库表已经建立好了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319224407190-1766024258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接着进行插入测试，修改service的代码，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coder520.order.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.dao.OrderItemRepository;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.dao.OrderRepository;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.entity.Order;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.coder520.order.entity.OrderItem;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoService {
    
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderRepository orderRepository;
    
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderItemRepository orderItemRepository;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo() {

        List&lt;/span&gt;&amp;lt;Long&amp;gt; orderIds = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(10&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;1.Insert--------------&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            Order order &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order();
            order.setUserId(&lt;/span&gt;51&lt;span&gt;);
            order.setStatus(&lt;/span&gt;&quot;INSERT_TEST&quot;&lt;span&gt;);
            orderRepository.insert(order);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; orderId =&lt;span&gt; order.getOrderId();
            orderIds.add(orderId);
            
            OrderItem item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderItem();
            item.setOrderId(orderId);
            item.setUserId(&lt;/span&gt;51&lt;span&gt;);
            item.setStatus(&lt;/span&gt;&quot;INSERT_TEST&quot;&lt;span&gt;);
            orderItemRepository.insert(item);
        }
        System.out.println(orderItemRepository.selectAll());
        System.out.println(&lt;/span&gt;&quot;2.Delete--------------&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Long each : orderIds) {
            orderRepository.delete(each);
            orderItemRepository.delete(each);
        }
        System.out.println(orderItemRepository.selectAll());
        orderItemRepository.dropTable();
        orderRepository.dropTable();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 接着在启动，可以看到数据全部被分配到第一个数据库中，因为分局分库算法user_id为51%3=0如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319225910894-788852946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么是怎么个分库的呢？我们先把在代码中将user_id再设置成52。&lt;/p&gt;
&lt;p&gt;那么下面进行打断点查看分库分表的过程。分别在那两个分库分表策略打断点，如下：&lt;/p&gt;
&lt;p&gt;可以看到断点进来了，可以看到首先是找数据库，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319230420093-339000864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319230837938-2069889690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最终可以看到分配到最终的数据库，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319230948843-1236488588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着继续打断点，进到了分表策略这个类里面了&lt;/p&gt;
&lt;p&gt;这是传进来的是逻辑表名和分表的依据order_id，分表依据order_id跟3求余，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319231321016-925535307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后选中求余后的表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319231414335-2025749540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319231448818-611666463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里要注重说一点，each.endsWith是根据你数据源的尾号是否跟匹配的订单号求余后是否相等，相等了就说明被分配到这里了。比如ds_o和求余后0相等，&lt;/p&gt;
&lt;p&gt;最后我们可以看到数据不再分配到第一个数据库了，而是本配到第二个数据库了，因为52%3=1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180319232435372-2116571749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/8605892.html</dc:identifier>
</item>
</channel>
</rss>