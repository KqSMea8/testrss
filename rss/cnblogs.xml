<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>比特币所有权及隐私问题-非对称加密应用 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/7781029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/7781029.html</guid>
<description>&lt;p&gt;比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？&lt;br/&gt;如果你对这个问题还不是很明白，那就一起来看看吧。&lt;/p&gt;
&lt;h2 id=&quot;银行系统&quot;&gt;银行系统&lt;/h2&gt;
&lt;p&gt;我们先来回顾下现实的银行系统：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。&lt;/li&gt;
&lt;li&gt;进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同时银行会对账户信息进行保密（这点其实不能保证）。&lt;/p&gt;
&lt;h2 id=&quot;匿名账本&quot;&gt;匿名账本&lt;/h2&gt;
&lt;p&gt;那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？&lt;/p&gt;
&lt;p&gt;实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。&lt;br/&gt;转账记录如这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;付款地址&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;2A39CBa2390FDe&quot;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;收款地址&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;AAC9CBa239aFcc&quot;&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;金额&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;0.2btc&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来问题就变为了 谁有权用某个地址进行付款。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;地址与私钥&quot;&gt;地址与私钥&lt;/h2&gt;
&lt;p&gt;比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失）&lt;/p&gt;
&lt;p&gt;比特币地址和私钥是一个非对称的关系,私钥经过一序列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;地址： 2A39CBa2390FDe
私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal

Hash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal)))  -&amp;gt; 2A39CBa2390FDe&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还是上面交易的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;付款地址&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;2A39CBa2390FDe&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;收款地址&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;AAC9CBa239aFcc&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;金额&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;0.2btc&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有拥有地址2A39CBa2390FDe的私钥才能进行支付。&lt;/p&gt;
&lt;h2 id=&quot;非对称加密技术&quot;&gt;非对称加密技术&lt;/h2&gt;
&lt;p&gt;这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。&lt;/p&gt;
&lt;h3 id=&quot;对交易信息进行签名&quot;&gt;对交易信息进行签名&lt;/h3&gt;
&lt;p&gt;实际在签名之前，会先对交易信息进行Hash运算的到摘要信息，然后对摘要信息进行签名。过程大概是这样：&lt;br/&gt;1.对交易进行hash， 得到一个摘要信息（Hash值）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hash('
    {&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;,
    &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;,
    &quot;金额&quot;：&quot;0.2btc&quot;
    }') -&amp;gt; 8aDB23CDEA6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#参数1为交易摘要&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#参数2为私钥&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#返回签名信息&lt;/span&gt;
sign(&lt;span class=&quot;st&quot;&gt;&quot;8aDB23CDEA6&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;J78sknJhidhLIqdngalket&quot;&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;3cdferdadgadg&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;广播&quot;&gt;广播&lt;/h3&gt;
&lt;p&gt;在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。&lt;/p&gt;
&lt;p&gt;广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。&lt;/p&gt;
&lt;p&gt;广播的信息包含了交易原始信息和签名信息&lt;/p&gt;
&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;p&gt;其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。&lt;/p&gt;
&lt;p&gt;验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#参数1为签名信息&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#参数2为付款方地址&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#返回交易摘要&lt;/span&gt;
verify(&lt;span class=&quot;st&quot;&gt;&quot;3cdferdadgadg&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2A39CBa2390FDe&quot;&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;8aDB23CDEA6&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(verify(&lt;span class=&quot;st&quot;&gt;&quot;3cdferdadgadg&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2A39CBa2390FDe&quot;&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;hash&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'{&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;              &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;              &quot;金额&quot;：&quot;0.2btc&quot;}'&lt;/span&gt;)) :
    &lt;span class=&quot;co&quot;&gt;# 写入账本 &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 广播&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
   &lt;span class=&quot;co&quot;&gt;# donothing&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。&lt;/p&gt;
&lt;h3 id=&quot;补充说明&quot;&gt;补充说明&lt;/h3&gt;
&lt;p&gt;上面为了更好的理解，我对一些信息进行了简化。&lt;/p&gt;
&lt;p&gt;比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt; - 系统学习区块链，打造最好的区块链技术博客&lt;/p&gt;
</description>
<pubDate>Fri, 03 Nov 2017 15:16:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/7781029.html</dc:identifier>
</item>
<item>
<title>【唯星宠物】——CSS/BootStrap/Jquery爬坑之响应式首页 - 柳洁琼Elena</title>
<link>http://www.cnblogs.com/ljq66/p/7781026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljq66/p/7781026.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;唯星宠物产品官网，分为首页、子页和登录注册页三个页面，除网页内容设计与图片素材的部分使用网上的材料之外，其余内容呈现以及功能模块全部为自己重构。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;一、响应式轮播banner&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103201754076-636383348.jpg&quot; alt=&quot;&quot; width=&quot;657&quot; height=&quot;265&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;思路&lt;/strong&gt;：&lt;span&gt;使用BootStrap自带的广告轮播组件（Carousel）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;基本滑动效果    关键 → class=&quot;carousel&quot;  data-ride=&quot;carousel&quot; 调动js，让图片动起来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指定轮播时间     关键 → data-interval=“2000” 指定轮播时间为2s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;带方向按钮的轮播     关键 → href=“#Carousel的ID” 关联最外层，class=&quot;carousel-contrl left&quot; data-slide=&quot;prev&quot; 控制左（右）轮播，指向前（后）一个&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;带圆点导航的轮播    关键 →  data-target=&quot;#Carousel的ID&quot; 指定跳到哪个区域的轮播图，data-slide-to=&quot;0&quot; 点击这个圆点要跳到第几个图&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;banner&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;wode&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;carousel slide&quot;&lt;/span&gt;&lt;span&gt; data-ride&lt;/span&gt;&lt;span&gt;=&quot;carousel&quot;&lt;/span&gt;&lt;span&gt; data-interval&lt;/span&gt;&lt;span&gt;=&quot;2000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;carousel-inner&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item active&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/banner.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/banner.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/banner.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/banner.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;carousel-control left&quot;&lt;/span&gt;&lt;span&gt; data-slide&lt;/span&gt;&lt;span&gt;=&quot;prev&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;glyphicon glyphicon-chevron-left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;carousel-control right&quot;&lt;/span&gt;&lt;span&gt; data-slide&lt;/span&gt;&lt;span&gt;=&quot;next&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;glyphicon glyphicon-chevron-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;carousel-indicators&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; data-slide-to&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; data-slide-to&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; data-slide-to&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#wode&quot;&lt;/span&gt;&lt;span&gt; data-slide-to&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;二、CSS点击图片放大图片并显示遮罩&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103202853404-186382271.jpg&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103202908326-2059825369.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;利用:after、:hover伪类选择器结合display属性、transition属性和transform属性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;点击触发，不点击不触发  关键 →pic:after{display:block}点击图片触发显示遮罩层    li:hover img {transform：scale(1.2)}点击li触发图片变换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;放大  关键 → transition：0.3s  图片变换持续时间0.3s    transform：scale(1.2)   图片宽高都变换至原来1.2倍&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;.ppcp .container .tu_all ul li .pic&lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt;relative&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt;hidden&lt;/span&gt;;
}&lt;span&gt;
.ppcp .container .tu_all ul li .pic:after&lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
    content&lt;/span&gt;:&lt;span&gt; &quot;&quot;&lt;/span&gt;;&lt;span&gt;
    padding-bottom&lt;/span&gt;:&lt;span&gt; 50.4%&lt;/span&gt;;
}&lt;span&gt;
.ppcp .container .tu_all ul li img&lt;/span&gt;{&lt;span&gt;
    transition&lt;/span&gt;:&lt;span&gt; 0.3s&lt;/span&gt;;
}&lt;span&gt;
.ppcp .container .tu_all ul li:hover img&lt;/span&gt;{&lt;span&gt;
    transform&lt;/span&gt;:&lt;span&gt; scale(1.2)&lt;/span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;三、Jquery导航条模式触发事件&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103225932795-663104177.jpg&quot; alt=&quot;&quot; width=&quot;156&quot; height=&quot;308&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103225949763-1387878845.jpg&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;310&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;span&gt;触发另一个元素上的事件处理函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在页面加载后执行事件处理   关键 → 自调函数 $(function(){  });&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用Jquery的Id选择器函数，查找点击元素，触发点击事件，再找到处理元素，触发处理事件 关键 → 两层id查找嵌套  $('id名’).要触发的事件(function){};&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;导航栏 显示&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
$(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;'.nav_tu').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $(&lt;/span&gt;&quot;.nav_show&quot;&lt;span&gt;).fadeIn();
    })
    $(&lt;/span&gt;'.cha').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $(&lt;/span&gt;&quot;.nav_show&quot;&lt;span&gt;).fadeOut();
    })
    $(&lt;/span&gt;'.fang').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $(&lt;/span&gt;&quot;.text&quot;&lt;span&gt;).toggle();
    })
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;四、Jquery新闻纵向轮播&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103203600732-844375945.gif&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;473&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;使用一次性定时器&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;任务函数   关键 → 定义每次要执行的任务Task    &lt;/span&gt;&lt;/span&gt;&lt;span&gt; function gd(){ }&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;启动定时器   关键 → timer = setTimeout(Task，wait)    wait这里指定时器执行函数的间隔时间（s）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;停止等待定时器  关键 → clearInterval(timer)   与周期性定时器不同，这里不是停止定时器，而是停止再一次执行的等待&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最新资讯 新闻轮播 定时器&lt;/span&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; gd(){
         $(&lt;/span&gt;'.new_gd_nei').fadeOut(500&lt;span&gt;);
         $(&lt;/span&gt;'.new_gd_nei').fadeIn(500&lt;span&gt;);
     }
     setInterval(gd,&lt;/span&gt;1000&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; newsgd($item, $gder){
         setTimeout(newsgd,&lt;/span&gt;2000&lt;span&gt;,$item.next(),$gder);
         $item.slideUp(&lt;/span&gt;1000,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
             $item.appendTo($gder).show();
        });
     }
    newsgd($(&lt;/span&gt;'.gder li:first'),$('.gder'&lt;span&gt;));
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;五、Jquery带按钮轮播图&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103204507560-1911605230.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;思路：&lt;span&gt;触发另一个元素上的事件处理函数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Jquery的id选择器查找  关键 → 同上面导航条模式触发事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;得到li元素内的值   关键 → 定义变量&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;count=$(&quot;.lb_list a&quot;).length  保存li内a元素的元素个数，在通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var i=$(this).text()-1   得到li元素内的值（数字）查找对应值的元素，添加class属性，同时为相邻兄弟元素移除class属性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最新资讯  切换图片&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; time=n=0&lt;span&gt;,count;
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         count&lt;/span&gt;=$(&quot;.lb_list a&quot;&lt;span&gt;).length;
         $(&lt;/span&gt;&quot;.lb_list a:not(:first-child)&quot;&lt;span&gt;).hide();
         $(&lt;/span&gt;&quot;.lb_zi li&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i=$(&lt;span&gt;this&lt;/span&gt;).text()-1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到li元素内的值（数字）&lt;/span&gt;
                 n=&lt;span&gt;i;
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;gt;=count)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                 $(&lt;/span&gt;&quot;.lb_list li&quot;).filter(&quot;:visible&quot;).fadeOut(500).parent().children().eq(i).fadeIn(1000&lt;span&gt;);
                 $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).toggleClass(&quot;on&quot;&lt;span&gt;);
                 $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).siblings().removeAttr(&quot;class&quot;&lt;span&gt;);
         })
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;六、animation主体渐入效果&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;span&gt;使用animate.css动画库文件自带效果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;渐进式滚入效果   关键 → &lt;/span&gt;&lt;span&gt;class=&quot;animated rollIn&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;渐进式淡入效果   关键 → &lt;/span&gt;&lt;/span&gt;&lt;span&gt;class=&quot;animated bounceIn&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;渐进式左入效果   关键 → &lt;/span&gt;&lt;/span&gt;&lt;span&gt;class=&quot;zx_left animated fadeInLeft&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;渐进式右入效果   关键 → class=&quot;zx_right animated fadeInRight&quot;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;animated rollIn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;quan&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h5&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;企业文化&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h5&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;创新，是企业生存和发展的灵魂。企业只有创新才有发展，企而创新，因而卓越。技术创新、产品创新、服务创新。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot; animated bounceIn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;zi_div&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我的帅萌 我做主&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h5&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My handsome Meng I call the shots&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h5&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;七、Media手写首页栅格布局&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103205637904-805213578.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;839&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103205810076-746286762.png&quot; alt=&quot;&quot; width=&quot;135&quot; height=&quot;836&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244398/201711/1244398-20171103210051638-1125890769.png&quot; alt=&quot;&quot; width=&quot;63&quot; height=&quot;836&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;PC端&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;pad端&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;手机端&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;手动添加Madia Query根据不同的屏幕类型以及特性执行不同的CSS&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;超小屏幕xs（w&amp;lt;=767）手机端   关键 → madia (max-width=767px){}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;小型屏幕sm（768&amp;lt;=w&amp;lt;=991）pad端   关键 → madia (max-width=991px){}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;中型屏幕md（992&amp;lt;=w&amp;lt;=1199）PC端   关键 → madia (max-width=1199px){}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大型屏幕xs（w&amp;gt;=1200）分辨率比较大的PC端  &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@media(max-width:1300px) &lt;/span&gt;{&lt;span&gt;
    .zxzx .container .home_top a{
        font-size&lt;/span&gt;:&lt;span&gt; 26px&lt;/span&gt;;
    }&lt;span&gt;
}
@media(max-width:992px) &lt;/span&gt;{&lt;span&gt;
    .zxzx .container .home_top a{
        width&lt;/span&gt;:&lt;span&gt;20%&lt;/span&gt;;
    }&lt;span&gt;
}
@media(max-width:768px) &lt;/span&gt;{&lt;span&gt;
    .zxzx .container .home_top a{
        width&lt;/span&gt;:&lt;span&gt;24%&lt;/span&gt;;
    }&lt;span&gt;
}
@media(max-width:480px) &lt;/span&gt;{&lt;span&gt;
    .zxzx .container .home_top a{
        width&lt;/span&gt;:&lt;span&gt;37%&lt;/span&gt;;
    }&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;注：转载请注明出处&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 03 Nov 2017 15:15:00 +0000</pubDate>
<dc:creator>柳洁琼Elena</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljq66/p/7781026.html</dc:identifier>
</item>
<item>
<title>Python 抽象篇：面向对象之类的方法与属性 - gregory2017</title>
<link>http://www.cnblogs.com/gregoryli/p/7780913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/7780913.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;概览：&lt;br/&gt;类成员之字段：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-普通字段，保存在对象中，执行职能通过对象访问&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-静态字段，保存在类中，执行可以通过对象访问，也可以通过类访问&lt;/span&gt;&lt;br/&gt;&lt;span&gt;类成员之方法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-普通方法，保存在类中，由对象来调用，self-&amp;gt;对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-静态方法，保存在类中，由类直接调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-类方法，保存在类中，由类直接调用，cl-&amp;gt;s当前类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;应用场景：&lt;br/&gt;如果对象中需要保存一些值，执行某功能时，需要使用对象中的值--&amp;gt;普通方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不需要任何对象中的值--&amp;gt;静态方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;类成员之属性：property&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1.类成员之字段&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Province:
    country &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;静态字段，属于类，跟对象没有关系，从上之下执行&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name&lt;/span&gt;=name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;普通字段，属于对象,通过对象访问&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sef.country='中国'&lt;/span&gt;
&lt;span&gt;
henna&lt;/span&gt;=Province(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;河南&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
hebei&lt;/span&gt;=Province(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;河北&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hebei.country) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Province.country) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(hebei.name) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;河北&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态字段在内存中只保存一份&lt;/p&gt;
&lt;p&gt;普通字段在每个对象中都要保存一份&lt;/p&gt;
&lt;p&gt;应用场景： 通过类创建对象时，如果每个对象都具有相同的字段，那么就使用静态字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name,age):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self=z,name=greg,age=84&lt;/span&gt;
        self.n=&lt;span&gt;name
        self.a&lt;/span&gt;=&lt;span&gt;age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.n,self.a)
z&lt;/span&gt;=Bar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(z.a)
z.foo()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建方法&lt;/p&gt;
&lt;p&gt;    构造方法，__init__(self,arg)&lt;/p&gt;
&lt;p&gt;        obj = 类('a1')&lt;/p&gt;
&lt;p&gt; 　普通方法&lt;/p&gt;
&lt;p&gt;        obj = 类(‘xxx’)&lt;/p&gt;
&lt;p&gt;        obj.普通方法名()&lt;/p&gt;
&lt;p&gt;     构造方法不同于其它方法之处在于：当一个对象被创建时，会立即调用构造方法，而且可以继承。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; bar(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self是对象&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;__main__.Foo object at 0x000001E82A4D13C8&amp;gt;&lt;/span&gt;
&lt;span&gt;    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sta():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; stas(a1,a2):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;静态方法self不必须&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a1,a2)

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; classmd(cls):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;cls是类名&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classmd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(cls) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;class '__main__.Foo'&amp;gt;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;普通方法&lt;/span&gt;
obj=&lt;span&gt;Foo()
obj.bar() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;
Foo.bar(obj ) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;静态方法&lt;/span&gt;
Foo.sta() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
Foo.stas(1,2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1,2&lt;/span&gt;
Foo.classmd() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;classmd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通方法：&lt;span&gt;可以在实例化后直接调用，&lt;/span&gt;由对象调用；至少一个self参数；执行普通方法时，自动将调用该方法的对象赋值给self，&lt;span&gt;self.调用实例变量或类变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类复制给cls；&lt;span&gt;类方法和普通方法的区别是， 类方法只能访问类变量，不能访问实例变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;静态方法：由类调用；无默认参数；&lt;span&gt;不可以访问实例变量或类变量的，一个不能访问实例变量和类变量的方法，其实相当于跟类本身已经没什么关系了，它与类唯一的关联就是需要通过类名来调用这个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别将三个方法定义为对同一个属性：获取、修改、删除&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.name_list&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    @property &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;属性&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; per(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('124')&lt;/span&gt;
        &lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.name_list[0]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name_list)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123&lt;span&gt;

    @per.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; per(self,val):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(val)

    @per.deleter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; per(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)

obj&lt;/span&gt;=&lt;span&gt;Foo()
obj.bar() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;
r=obj.per &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
obj.per=345 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; obj.per &lt;span&gt;#&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;property的构造方法中有个四个参数，分别叫做：fget，fset，fdel ,doc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有参数，产生的属性既不可读，也不可写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有一个参数，说明是取值方法，产生的属性是只读的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个参数是方法名，调用 对象.属性 时自动触发执行方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法，用于删除特性的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息，即文档字符串&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2(self,v):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(v)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; per=property(fget=f1)#等同于下面三句&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; @property&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; def per(self):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     return 123&lt;/span&gt;
&lt;span&gt;
    per &lt;/span&gt;= property(fget=f1,fset=f2,fdel=f3,doc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj&lt;/span&gt;=&lt;span&gt;Foo()
ret&lt;/span&gt;=&lt;span&gt;obj.per
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
obj.per&lt;/span&gt;=12345
&lt;span&gt;del&lt;/span&gt;&lt;span&gt; obj.per
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.per.__doc__)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.类的私有（private）特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了让方法或者特性变为 私有（从外部无法访问），只要在它的名字前面加上双下划线即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;公有成员，在任何地方都能访问&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;私有成员，只有在类的内部才能方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Secretive:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__inaccessible&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你看不到我&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; accessible(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.&lt;/span&gt;&lt;span&gt;__inaccessible&lt;/span&gt;&lt;span&gt;()

s&lt;/span&gt;=&lt;span&gt;Secretive()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; s.__inaccessible() #AttributeError: 'Secretive' object has no attribute '__inaccessible'&lt;/span&gt;
&lt;span&gt;s.accessible()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码是：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 你看不到我&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;非要访问私有属性的话，可以通过 对象._类__属性名，比如Secretive._Secretive.__inaccessible&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;特殊成员&lt;/p&gt;
&lt;p&gt;__init__()  构造方法  类()自动执行&lt;/p&gt;
&lt;p&gt;__call__() 对象()    类()()自动执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj &lt;/span&gt;= Foo()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行 __init__&lt;/span&gt;
obj()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行 __call__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__str__             str()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,n,a):
        self.name&lt;/span&gt;=&lt;span&gt;n
        self.age&lt;/span&gt;=&lt;span&gt;a
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s-%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(self.name,self.age)
obj&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,89&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(str(obj)) str(obj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__int__             int(对象)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__int__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1111
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
obj&lt;/span&gt;=&lt;span&gt;Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj,type(obj))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;int,对象，自动执行对象的__init__方法，并将返回值赋值给int对象&lt;/span&gt;
&lt;span&gt;
r&lt;/span&gt;=&lt;span&gt;int(obj)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)
i&lt;/span&gt;=&lt;span&gt;str(obj)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__add__&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self, other):
        self&lt;/span&gt;=&lt;span&gt;obj1
        other&lt;/span&gt;=&lt;span&gt;obj2
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; return self.age+other.age#37 &amp;lt;class 'int'&amp;gt;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,99)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;__main__.Foo object at 0x0000017B7E2FC9B0&amp;gt; &amp;lt;class '__main__.Foo'&amp;gt;&lt;/span&gt;
&lt;span&gt;
obj1&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,19&lt;span&gt;)
obj2&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gregory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18&lt;span&gt;)
r&lt;/span&gt;=obj1+obj2&lt;span&gt;#&lt;/span&gt;&lt;span&gt;两个对象相加时，自动执行第一个对象的__add__，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 并且将第二个对象当做参数传递&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r,type(r))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__dict__ 将对象中封装的所有内容通过字典的形式返回&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s-%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name,self.age)

obj&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.name) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;
b=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__dict__&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;{'name': 'greg', 'age': 18}&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__dict__&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])&lt;span&gt;#&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__dict__&lt;/span&gt;[b])&lt;span&gt;#&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__getitem__切片（slice类型）或者索引,返回与所给键对应的值&lt;/p&gt;
&lt;p&gt;__setitem__，按一定的方式存储于key相关的value&lt;/p&gt;
&lt;p&gt;__delitem__，删除和key相关的键&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key, value)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key)

obj &lt;/span&gt;=&lt;span&gt; Foo()
result &lt;/span&gt;= obj[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动触发执行 __getitem__,输出__getitem__ k1&lt;/span&gt;
obj[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动触发执行 __setitem__，输出__setitem__ k2 greg&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; obj[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动触发执行 __delitem__，输出__delitem__ k1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__iter__&lt;/p&gt;
&lt;p&gt; # 如果类中有 __iter__ 方法，对象=》可迭代对象&lt;/p&gt;
&lt;p&gt;                # 对象.__iter__() 的返回值： 迭代器&lt;/p&gt;
&lt;p&gt;                # for 循环，迭代器，next&lt;/p&gt;
&lt;p&gt;                # for 循环，可迭代对象，对象.__iter__()，迭代器，next&lt;/p&gt;
&lt;p&gt;                # 1、执行li对象的类F类中的 __iter__方法，并获取其返回值&lt;/p&gt;
&lt;p&gt;                # 2、循环上一步中返回的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; iter([11,22,33&lt;span&gt;])

li&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果类中由__iter__方法，对象—》可迭代对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;执行li对象的类Foo类中的__iter__方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;循环上一步中的返回的对象&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__doc__&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;描述&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 描述类信息 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：描述&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;__module__ 和  __class__ &lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　__module__ 表示当前操作的对象在那个模块&lt;/p&gt;
&lt;p&gt;　　__class__     表示当前操作的对象的类是什么&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; A.B &lt;span&gt;import&lt;/span&gt;&lt;span&gt; C

obj &lt;/span&gt;=&lt;span&gt; C()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; obj.&lt;span&gt;__module__&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出A.B，即：输出模块&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; obj.&lt;span&gt;__class__&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出 A.B.C，即：输出类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__new__ 和 __metaclass__&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(123&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function(self):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(123&lt;span&gt;)

obj&lt;/span&gt;=&lt;span&gt;Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(obj))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;class '__main__.Foo'&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(type(Foo))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;class 'type'&amp;gt;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;obj对象是Foo类的一个实例，Foo类对象是 type 类的一个实例，即：Foo类对象 是通过type类的构造方法创建&lt;/span&gt;
&lt;span&gt;
Foo2&lt;/span&gt;=type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(object,),{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:function})&lt;span&gt;#&lt;/span&gt;&lt;span&gt;声明一个类&lt;/span&gt;
obj2=&lt;span&gt;Foo2()
obj2.func2()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;type第一个参数：类名,type第二个参数：当前类的基类,type第三个参数：类的成员&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_30940f4d-2ef7-4424-8274-f93d59759097&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_30940f4d-2ef7-4424-8274-f93d59759097&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_30940f4d-2ef7-4424-8274-f93d59759097&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;self.name)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     self.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     self.age =&lt;span&gt; age
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; Foo = type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(object,),{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:func,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; f = Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,22&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; f.func()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;加上构造方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 类 是由 type 类实例化产生&lt;/p&gt;
&lt;p&gt;那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？&lt;/p&gt;
&lt;p&gt;答：类中有一个属性 __metaclass__，其用来表示该类由 谁 来实例化创建，所以，我们可以为 __metaclass__ 设置一个type类的派生类，从而查看 类 创建的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self=Foo类 self永远是类名&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(123&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self=Foo&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(456&lt;span&gt;)
  &lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; Foo(object,metaclass=MyType):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Foo是MyType的对象&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        x&lt;/span&gt;=&lt;span&gt;cls
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

obj&lt;/span&gt;=Foo() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;加()是执行MyType的call方法,Foo里面要执行，要用call中的方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;call不会调用Foo中init方法&lt;br/&gt;结果：123&lt;br/&gt;　　　456&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1230529/201711/1230529-20171103223653670-449437732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Nov 2017 14:37:00 +0000</pubDate>
<dc:creator>gregory2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/7780913.html</dc:identifier>
</item>
<item>
<title>使用Identity Server 4建立Authorization Server (1) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7780559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7780559.html</guid>
<description>&lt;p&gt;预备知识: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7746496.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7746496.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文内容基本完全来自于Identity Server 4官方文档: &lt;a href=&quot;https://identityserver4.readthedocs.io/&quot; target=&quot;_blank&quot;&gt;https://identityserver4.readthedocs.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档很详细的.&lt;/p&gt;
&lt;p&gt;使用OAuth可以更安全, 这里我们的authorization server和web api 以及网站将分别独立运行. &lt;/p&gt;

&lt;p&gt;建立asp.net core 项目使用空模板.&lt;/p&gt;
&lt;p&gt;项目建立后, 运行方式改为使用控制台运行而不是IISExpress, 以便查看各种debug信息.&lt;/p&gt;
&lt;p&gt;打开launchSettings.json:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103202553232-751680261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;profiles&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;AuthServer&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:5000/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把IISExpress相关的内容删掉, 然后端口改为5000.&lt;/p&gt;
&lt;p&gt;Program.cs里的BuildWebHost也应该加上Url:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                &lt;span&gt;.UseUrls(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;http://0.0.0.0:5000&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实不加也好用.&lt;/p&gt;
&lt;p&gt;运行就会弹出控制台:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103203806685-546210662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开nuget, 搜索 identityserver4:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103203909623-1925166000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装即可.&lt;/p&gt;

&lt;p&gt;打开startup.cs, 编辑Configure方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.UseDeveloperExceptionPage();
            &lt;span&gt;app.UseIdentityServer();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是使用上面这个中间件. &lt;/p&gt;

&lt;p&gt;还是Startup.cs,编辑ConfigureServices方法:&lt;/p&gt;
&lt;p&gt;这里不仅要把IdentityServer注册到容器中, 还要至少对其配置三点内容:&lt;/p&gt;
&lt;p&gt;1. 哪些API可以使用这个authorization server.&lt;/p&gt;
&lt;p&gt;2. 那些客户端Client(应用)可以使用这个authorization server.&lt;/p&gt;
&lt;p&gt;3. 指定可以使用authorization server授权的用户.&lt;/p&gt;
&lt;p&gt;首先需要把上面这些做成一个配置文件:&lt;/p&gt;
&lt;p&gt;建立Configuration/InMemoryConfiguration.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AuthServer.Configuration
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InMemoryConfiguration
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; ApiResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;社交网络&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; Clients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                }
            };
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestUser&amp;gt;&lt;span&gt; Users()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mail@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ApiResources: 这里指定了name和display name, 以后api使用authorization server的时候, 这个name一定要一致, 否则就不好用的.&lt;/p&gt;
&lt;p&gt;Clients: Client的属性太多了, 这里就指定几个. 其中ClientSecrets是Client用来获取token用的. AllowedGrantType: 这里使用的是通过用户名密码和ClientCredentials来换取token的方式. ClientCredentials允许Client只使用ClientSecrets来获取token. 这比较适合那种没有用户参与的api动作. AllowedScopes: 这里只用socialnetwork&lt;/p&gt;
&lt;p&gt;Users: 这里的内存用户的类型是TestUser, 只适合学习和测试使用, 实际生产环境中还是需要使用数据库来存储用户信息的, 例如接下来会使用asp.net core identity. TestUser的SubjectId是唯一标识.&lt;/p&gt;
&lt;p&gt;然后回到StartUp的ConfigureServices:&lt;/p&gt;
&lt;p&gt;前一篇文章讲过, 我们需要对token进行签名, 这意味着identity server需要一对public和private key. 幸运的是, 我们可以告诉identity server在程序的运行时候对这项工作进行设定: AddDeveloperSigningCredential(), 它默认会存到硬盘上的, 所以每次重启服务不会破坏开发时的数据同步. 这个方法只适合用于identity server4在单个机器运行, 如果是production farm你得使用&lt;strong&gt;AddSigningCredential()&lt;/strong&gt;这个方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddTestUsers(InMemoryConfiguration.Users().ToList())
                .AddInMemoryClients(InMemoryConfiguration.Clients())
                .AddInMemoryApiResources(InMemoryConfiguration.ApiResources());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103211536451-252698004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没报错, 红线部分是内存配置版的一些解释.&lt;/p&gt;

&lt;p&gt;打开postman, 如果你无法安装postman, 也无法进入Chrome商店, 那么你可以买一个海外服务器, 使用shadowsocks服务器和客户端进行代理, 然后就可以访问google了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212308060-99230998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们发送一个错误的client_id, 然后得到的结果是: invalid_client. 控制台的信息如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212410732-1499650823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再发送一个正确的数据:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212451295-357921965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次获取到了token. 控制台信息如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212539826-833374693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于identity server我们设置的是 ResourceOwnerPasswordAndClientCredentials 这个GrantType, 所以使用用户名密码以及使用ClientCredentials都可以. 那我们把用户名和密码去掉, 只发送Client Credentials:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212852670-918059854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仍然获取到了token. 控制台上的信息与上一个稍有不同, 没有user相关的信息了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103212940357-2053287472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;证书可以通过几种渠道获得, 可以购买, 可以使用IIS生成, 也可以使用Openssl这样的工具生成证书. 我就使用openssl吧.&lt;/p&gt;
&lt;p&gt;去openssl的windows官网: &lt;a href=&quot;https://slproweb.com/products/Win32OpenSSL.html&quot; target=&quot;_blank&quot;&gt;https://slproweb.com/products/Win32OpenSSL.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载 1.1.0版: &lt;a href=&quot;https://slproweb.com/download/Win64OpenSSL-1_1_0f.exe&quot; target=&quot;_blank&quot;&gt;https://slproweb.com/download/Win64OpenSSL-1_1_0f.exe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装后, 打开命令行.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
openssl req -newkey rsa:2014 -nodes -keyout socialnetwork.key -x509 -days 365 -out socialnetwork.cer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的信息就不管了. 这个证书的有效期是365天, 命令参数里面设定的.&lt;/p&gt;
&lt;p&gt;这是生成的文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103213942451-1167764281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个证书和一个key, 然后我们需要给他们俩封装成一个文件, 以便identity server可以使用它们去正确的签名tokens. 这就需要使用另一个命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
openssl pkcs12 -export -&lt;span&gt;in&lt;/span&gt; socialnetwork.cer -inkey socialnetwork.key -out socialnetwork.pfx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103214305045-685308829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里发生了错误...那就使用管理员打开命令行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103214418435-276694526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码和确认密码后, 没问题了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103214514576-535023005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pfx就是我们需要的文件.&lt;/p&gt;
&lt;p&gt;然后修改一个Startup的ConfigureServices:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddIdentityServer()
                &lt;/span&gt;//&lt;span&gt; .AddDeveloperSigningCredential()
                &lt;span&gt;.AddSigningCredential(new X509Certificate2(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@&quot;D:\Projects\test\socialnetwork.pfx&quot;, &quot;password&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;))&lt;/span&gt;
                .AddTestUsers(InMemoryConfiguration.Users().ToList())
                .AddInMemoryClients(InMemoryConfiguration.Clients())
                .AddInMemoryApiResources(InMemoryConfiguration.ApiResources());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在运行程序的话, 啥也不显示. 那么接下来, 就&lt;/p&gt;

&lt;p&gt;Identity Server 4 提供了一套QuickStart UI : &lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/tree/release&quot; target=&quot;_blank&quot;&gt;https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/tree/release&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在项目根目录打开Powershell(可以在项目根目录, 按住shift, 点击右键的Powershell)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215221920-2109174083.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/IdentityServer/IdentityServer4.Quickstart.UI/release/get.ps1'))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就把UI下载到项目了.&lt;/p&gt;
&lt;p&gt;看看生成的文件, 很多:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215415795-1665430420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于有wwwroot下很多静态文件, 所以asp.net core 需要启用服务静态文件的功能: 修改Startup的Configure方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.UseDeveloperExceptionPage();
            app.UseIdentityServer();
            &lt;span&gt;app.UseStaticFiles();
            app.UseMvcWithDefaultRoute();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用静态文件, 并且使用了MVC.&lt;/p&gt;
&lt;p&gt;别忘了在ConfigureServices里面注册MVC:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddIdentityServer()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; .AddDeveloperSigningCredential()&lt;/span&gt;
                .AddSigningCredential(&lt;span&gt;new&lt;/span&gt; X509Certificate2(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\Projects\test\socialnetwork.pfx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bx@steel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .AddTestUsers(InMemoryConfiguration.Users().ToList())
                .AddInMemoryClients(InMemoryConfiguration.Clients())
                .AddInMemoryApiResources(InMemoryConfiguration.ApiResources());

            &lt;span&gt;services.AddMvc();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行一下试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215839076-919574482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215845591-158238076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215850154-1758327716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它现在已经具备了这些功能!&lt;/p&gt;
&lt;p&gt;使用TestUser也可以登陆成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171103215941685-1229808525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然这个UI可以根据情况自行定义.&lt;/p&gt;

</description>
<pubDate>Fri, 03 Nov 2017 14:01:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7780559.html</dc:identifier>
</item>
<item>
<title>【JAVA零基础入门系列】Day12 Java类的简单应用 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/7750768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/7750768.html</guid>
<description>&lt;p&gt;　　俗话说的好，实践出真知，所以除了理论知识掌握扎实以外，更重要的是要多加操练，这样才能掌握核心科技。&lt;/p&gt;
&lt;p&gt;　　今天我们就用刚学会的类来实践一下，目标便是完成上一篇中的剁手任务。&lt;/p&gt;
&lt;p&gt;　　我们的商品类已经准备好了，代码重新罗列一次，这里增加了一个重载方法，关于重载这里不过多介绍，以后会专门文章介绍，这里把它当成一个普通方法就好了，主要用来比较两个商品是否相等，如果对代码不熟悉的话可以再返回去看一下上一篇文章。&lt;/p&gt;
&lt;p&gt;　　这里顺便介绍一下Java注释的正确使用姿势。注释是插在源代码中间用于对代码进行说明的文字，不会被编译和执行。代码不仅仅是用来编译的，更是用来阅读的，因此写上足够多的注释是有必要的，这样可以保证自己在以后回过头来看自己写的破代码的时候写的是什么鬼，如果将自己写代码的思路也记录下来的话，那就更方便自己以后的对比提升了。&lt;/p&gt;
&lt;p&gt;　　Java中的注释方法主要有三种：&lt;/p&gt;
&lt;p&gt;　　1.单行注释，使用//&lt;/p&gt;
&lt;p&gt;　　2.多行注释，使用/* 代码 */&lt;/p&gt;
&lt;p&gt;　　3.文档注释，使用/** 代码 */ 这种格式是为了便于javadoc程序自动生成文档。这里先不做介绍，之后会又专门一篇来做讲解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*GOODS类&lt;br/&gt;主要用于记录商品信息，并提供商品信息的访问方法&lt;br/&gt;*/&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Goods{&lt;br/&gt;　　//实例域，用于存储商品信息
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String title=&quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; price=0.0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String link = &quot;&quot;&lt;span&gt;;&lt;br/&gt;　　&lt;br/&gt;　　//构造器1
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Goods(String aTitle,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aPrice,String aLink){
        title &lt;/span&gt;=&lt;span&gt; aTitle;
        price &lt;/span&gt;=&lt;span&gt; aPrice;
        link &lt;/span&gt;=&lt;span&gt; aLink;
    }
　　//构造器2
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Goods(String aTitle,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aPrice){
        title &lt;/span&gt;=&lt;span&gt; aTitle;
        price &lt;/span&gt;=&lt;span&gt; aPrice;
        link &lt;/span&gt;= &quot;www.baidu.com&quot;&lt;span&gt;;
    }
　　//构造器3
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Goods(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aPrice){
        price &lt;/span&gt;=&lt;span&gt; aPrice;
        title &lt;/span&gt;= &quot;Goods&quot;&lt;span&gt;;
        link &lt;/span&gt;= &quot;www.baidu.com&quot;&lt;span&gt;;
    }
　　//取商品标题
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTitle(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; title;
    }
　　//取商品价格
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getPrice(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }
　　//取商品链接
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLink() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; link;
    }
　　//设置商品标题
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTitle(String aTitle){
        title &lt;/span&gt;=&lt;span&gt; aTitle;
    }
　　//设置商品价格
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aPrice){
        price &lt;/span&gt;=&lt;span&gt; aPrice;
    }
　　//设置商品链接
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLink(String aLink){
        link &lt;/span&gt;=&lt;span&gt; aLink;
    }
　　//输出商品信息
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(){
        System.out.println(&lt;/span&gt;&quot;title:&quot;+title+&quot; price:&quot;+price+&quot; link:&quot;+&lt;span&gt;link);
    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　//重载equals判断方法&lt;br/&gt;　　@Override&lt;br/&gt;　　public boolean equals(Object obj) {&lt;br/&gt;　　 return super.equals(obj);&lt;br/&gt;　　}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样一注释，这个类的功能就很清晰了，人家一看就知道你要做什么瞎操作了，当然，如果每次使用类都要上类的源码查看的话，也确实不方便，所以才有了Javadoc这样的工具，这里因为还没有介绍，所以先不使用。&lt;/p&gt;
&lt;p&gt;　　接下来，我们需要一个购物车来存放商品。因为只需要管理一个购物车，所以预算类就先不写了，不然也有些太小题大做了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; pers.frank.test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cart类
 * 购物车类用于管理商品和预算信息
 * 提供添加商品，获取预算，修改预算等方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cart {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例域&lt;/span&gt;
    Goods[] goodsList = &lt;span&gt;new&lt;/span&gt; Goods[20];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商品列表，因为还没有介绍列表跟集合，所以先使用数组存储，先假设你不会买超过20件商品&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; goodsNum = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商品数量&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; budget = 0.0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预算&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; totalPrices = 0.0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前商品总价

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Cart(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aBudget){
        budget &lt;/span&gt;=&lt;span&gt; aBudget;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取商品总价&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getTotalPrices() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalPrices;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取预算&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBudget() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; budget;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改预算&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBudget(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; aBudget) {
        budget &lt;/span&gt;=&lt;span&gt; aBudget;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加商品,预算足够则返回真，不够则返回假&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; addGoods(Goods aGoods){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先判断预算&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(totalPrices + aGoods.getPrice() &amp;gt;&lt;span&gt; budget){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预算足够则添加
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组，寻找元素为null的位置&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(; i &amp;lt; goodsList.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(goodsList[i] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                goodsList[i] &lt;/span&gt;= &lt;span&gt;aGoods&lt;/span&gt;;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; goodsList.length)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        totalPrices &lt;/span&gt;= totalPrices +&lt;span&gt; aGoods.getPrice();
        goodsNum&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历输出购物车中的商品信息&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showGoodsList(){
        System.out.println(&lt;/span&gt;&quot;购物车内商品数量：&quot; + goodsNum + &quot; 商品总价：&quot; +&lt;span&gt; totalPrices);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;( Goods a: goodsList){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            a.print();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的代码没有太多需要介绍的东西，注释里已经写的很详细了。关于数据描述和使用的类已经构建好了，接下来只需要使用它们就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; budget = 20000;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预算&lt;/span&gt;
        Cart myCart = &lt;span&gt;new&lt;/span&gt; Cart(budget);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个购物车对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建商品对象数组&lt;/span&gt;
        Goods[] goodsList = &lt;span&gt;new&lt;/span&gt; Goods[3&lt;span&gt;];
        goodsList[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Goods(&quot;goodsA&quot;,10000,&quot;link1&quot;&lt;span&gt;);
        goodsList[&lt;/span&gt;1] = &lt;span&gt;new&lt;/span&gt; Goods(&quot;goodsB&quot;,6000,&quot;link2&quot;&lt;span&gt;);
        goodsList[&lt;/span&gt;2] = &lt;span&gt;new&lt;/span&gt; Goods(&quot;goodsC&quot;,6000,&quot;link3&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环添加商品&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; goodsList.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (myCart.addGoods(goodsList[i]) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加成功&lt;/span&gt;
                System.out.println(&quot;商品添加成功！标题：&quot; + goodsList[i].getTitle() + &quot; 价格：&quot; + goodsList[i].getPrice() + &quot; 链接：&quot;+&lt;span&gt; goodsList[i].getLink());
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加失败&lt;/span&gt;
                System.out.println(&quot;商品添加失败！当前预算：&quot; + myCart.getBudget() + &quot; 当前商品总价：&quot;+ myCart.getTotalPrices()+&quot; 要添加的商品价格：&quot; +&lt;span&gt; goodsList[i].getPrice());
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印购物车内所有商品信息&lt;/span&gt;
&lt;span&gt;        myCart.showGoodsList();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
商品添加成功！标题：goodsA 价格：10000.0&lt;span&gt; 链接：link1
商品添加成功！标题：goodsB 价格：&lt;/span&gt;6000.0&lt;span&gt; 链接：link2
商品添加失败！当前预算：&lt;/span&gt;20000.0 当前商品总价：16000.0 要添加的商品价格：6000.0&lt;span&gt;
购物车内商品数量：&lt;/span&gt;2 商品总价：16000.0&lt;span&gt;
title:goodsA price:&lt;/span&gt;10000.0&lt;span&gt; link:link1
title:goodsB price:&lt;/span&gt;6000.0 link:link2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们的类的简单应用就编写完成了，当然这个类并不完善，有些更复杂的概念还没有介绍，这里只是为了演示类的正确使用姿势而设计的，不要过于纠结于细节。&lt;/p&gt;
&lt;p&gt;　　我们可以看出，测试用的主要代码其实很少，因为我们把具体实现都封装在了类里，只需要按规则使用类中的方法就可以了。这就好比盖房子，不是直接用石头木材堆出来的，而是先加工成砖瓦门窗，然后再搭建。使用这些砖瓦门窗当然要比直接使用石头木材方便得多。使用类的便利性也在于此。我们把商品跟购物车类构建好之后，如果某些地方需要修改，只需要在相应的类中进行修改即可，只要对外提供的方法没有改变，那么调用这些代码的其他代码就不需要进行修改，这样就能降低代码的耦合度。&lt;/p&gt;
&lt;p&gt;　　至此，本篇就结束了，之后会介绍关于类的更多内容，欢迎大家继续关注！&lt;/p&gt;
</description>
<pubDate>Fri, 03 Nov 2017 13:57:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/7750768.html</dc:identifier>
</item>
<item>
<title>大师的小玩具——泛型精解 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/genericity.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/genericity.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;掌握Java的泛型，这一篇文章足够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字：泛型，Iterable接口，斐波那契数列，匿名内部类，枚举，反射，可变参数列表，Set&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般类和方法，要么只能使用基础类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制会对代码的束缚很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Java中，当你将一个基类作为一个方法的参数传入的时候，所有该基类的子类均可以作为参数，然而private构造器或者final修饰的类是不可被继承的，再加上Java的单继承特性，这种看上去的灵活性也有他的限制以及性能损耗。&lt;/li&gt;
&lt;li&gt;如果参数为一个接口，要比继承好的多，任何实现了该接口的类都能满足该方法，而一个类是可以实现多个接口的。可是，反过来想我们必须实现该接口的所有方法才可以作为参数，这也是一种限制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;泛型&quot;&gt;泛型&lt;/h2&gt;
&lt;p&gt;泛型实现了“参数化类型”的概念。&lt;/p&gt;
&lt;p&gt;泛型的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import algorithms.sort.QuickSort;

public class OldHolder {
    private Object a;

    public OldHolder(Object a) {
        this.a = a;
    }

    public void setA(Object a) {
        this.a = a;
    }

    public Object getA() {
        return a;
    }

    public static void main(String[] args) {
        OldHolder old = new OldHolder(new QuickSort());// 将OldHolder中的属性a赋值为QuickSort的实例
        old.setA(1);// 将a赋值为整型数字1
        old.setA(&quot;this is a value&quot;);// 将a赋值为String类型字符串
        System.out.println(old.getA());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;this is a value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，OldHolder类中的属性a被设置为Object类型。我们都知道在Java中，所有类型都是Object的子类，所以这里将a定义为Object，在使用时a先后被赋值为类实例，整型，字符串，可见作者并不确定a到底是用来干嘛的。这时候，引入泛型的表现就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import algorithms.sort.QuickSort;

public class NewHolder&amp;lt;T&amp;gt; {

    private T a;

    public NewHolder(T a) {
        this.a = a;
    }

    public void setA(T a) {
        this.a = a;
    }

    public T getA() {
        return a;
    }

    public static void main(String[] args) {
        NewHolder&amp;lt;Integer&amp;gt; n = new NewHolder&amp;lt;Integer&amp;gt;(100);// 使用的时候将泛型定义为整型，那么只能限制设置a为整型值
        n.setA(1);// 将a赋值为整型数字1
        System.out.println(n.getA());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在定义类的时候，不确定到底要使用什么类型的参数，就可以使用泛型来定义，等具体调用该类的时候，我们再指定类型来替换泛型。这就是泛型最简单的应用。&lt;/p&gt;
&lt;h3 id=&quot;元组泛型&quot;&gt;元组泛型&lt;/h3&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

public class TwoTuple&amp;lt;A, B&amp;gt; {
    public final A a;
    public final B b;

    public TwoTuple(A a, B b) {
        this.a = a;
        this.b = b;
    }

    @Override
    public String toString() {
        return a + &quot;__&amp;amp;&amp;amp;&amp;amp;__&quot; + b;
    }

    public static void main(String[] args) {
        TwoTuple&amp;lt;Integer, Integer&amp;gt; two = new TwoTuple&amp;lt;Integer, Integer&amp;gt;(110, 211);
        System.out.println(two);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;110__&amp;amp;&amp;amp;&amp;amp;__211&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以看出，类的泛型不仅仅可以定义一个，还可以定义两个，其实还可以定义三个，甚至更多，一次性定义多个对象不再困难。下面利用继承实现一个三个泛型的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

public class ThreeTuple&amp;lt;A, B, C&amp;gt; extends TwoTuple&amp;lt;A, B&amp;gt; {
    public final C c;

    public ThreeTuple(A a, B b, C c) {
        super(a, b);
        this.c = c;
    }

    @Override
    public String toString() {
        return a + &quot;__&amp;amp;&amp;amp;&amp;amp;__&quot; + b + &quot;__&amp;amp;&amp;amp;&amp;amp;__&quot; + c;
    }

    public static void main(String[] args) {
        ThreeTuple&amp;lt;Integer, Integer, Integer&amp;gt; three = new ThreeTuple&amp;lt;Integer, Integer, Integer&amp;gt;(110, 211, 985);
        System.out.println(three);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;110__&amp;amp;&amp;amp;&amp;amp;__211__&amp;amp;&amp;amp;&amp;amp;__985&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;栈类&quot;&gt;栈类&lt;/h3&gt;
&lt;p&gt;下面用LinkList，链表实现一个下推栈。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下推栈就是把一个瓶子扣过来，往里面塞硬币，最先塞进去的硬币排在最顶，最新塞进去的硬币排在瓶口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

public class LinkedStack&amp;lt;T&amp;gt; {
    private static class Node&amp;lt;U&amp;gt; {
        U item;
        Node&amp;lt;U&amp;gt; next;

        Node() {
            item = null;
            next = null;
        }

        Node(U item, Node&amp;lt;U&amp;gt; next) {
            this.item = item;
            this.next = next;
        }

        boolean end() {
            return item == null &amp;amp;&amp;amp; next == null;
        }

    }

    /**
     * top是倒过来的瓶口位置。top|..|..|..，在最左侧
     */
    private Node&amp;lt;T&amp;gt; top = new Node&amp;lt;T&amp;gt;();// 结尾哨兵sentinel，空结点，item和next均为null

    public void push(T item) {
        top = new Node&amp;lt;T&amp;gt;(item, top);
    }

    public T pop() {
        T result = top.item;
        if (!top.end())// top的item和next均为空的时候，说明top碰到了末端哨兵，下推栈已空。
            top = top.next;
        return result;
    }

    public static void main(String[] args) {
        LinkedStack&amp;lt;String&amp;gt; lss = new LinkedStack&amp;lt;String&amp;gt;();
        for (String s : &quot;This is a value&quot;.split(&quot; &quot;)) {
            lss.push(s);
        }
        String s;
        while ((s = lss.pop()) != null) {
            System.out.println(s);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;value&lt;br/&gt;a&lt;br/&gt;is&lt;br/&gt;This&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;首先创建一个静态类用来描述链表的结点。&lt;/li&gt;
&lt;li&gt;构建LinkedStack时创建了末端哨兵top。&lt;/li&gt;
&lt;li&gt;每次push，都会将top向左移动一位，将新结点插入top的右侧。&lt;/li&gt;
&lt;li&gt;每次pop，都是取出top的item，然后将top右移一位，直到top碰到末端哨兵。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;末端哨兵的功能：链表都会设置一个哨兵，因为链表是“邻居依赖”，因此设置一个哨兵作为边界，当链表触碰到哨兵时即停止前进，否则会有越界异常。因此单链表通常会有一个末端哨兵，而双链表则需要两头均设置一个哨兵，左哨兵和右哨兵。&lt;/p&gt;
&lt;h3 id=&quot;泛型应用代码训练-randomlist&quot;&gt;泛型应用：代码训练 RandomList&lt;/h3&gt;
&lt;p&gt;准备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个持有特定类型的List容器&lt;/li&gt;
&lt;li&gt;一个从该容器中随机获取该特定类型元素的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.*;

public class RandomList&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; storage = new ArrayList&amp;lt;T&amp;gt;();
    // new Random(long seed); Random是个伪随机，通过seed随机规则来生成随机数。
    // seed可以理解为random生成随机数的规则，如果seed相同，那么random生成的随机数也肯定一样。
    // 如果不指定seed，则每次生成随机数的seed不同，那么random每一次执行生成的随机数也不同，真的随机了。
    private Random random = new Random();

    public void add(T item) {
        storage.add(item);
    }

    public T select() {
        return storage.get(random.nextInt(storage.size()));
    }

    public static void main(String[] args) {
        RandomList&amp;lt;String&amp;gt; rlist = new RandomList&amp;lt;String&amp;gt;();
        for (String a : &quot;this is a value&quot;.split(&quot; &quot;)) {
            rlist.add(a);
        }
        for (int i = 0; i &amp;lt; rlist.storage.size(); i++) {
            System.out.println(rlist.select());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;a&lt;br/&gt;a&lt;br/&gt;is&lt;br/&gt;this&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用RandomList时，指定其泛型的具体类型，然后随机取出元素。&lt;/p&gt;
&lt;h3 id=&quot;泛型接口&quot;&gt;泛型接口&lt;/h3&gt;
&lt;p&gt;使用泛型来作为接口，我们采用一个生成器，它的功能是生产对象，类似与工厂模式，但是工厂模式一般是需要参数的，参数是有继承关系的，而我们采用泛型，生成器无需额外信息就知道如何创建对象。生成器一般有且只有一个方法，就是生产对象。我们还是实现一个随机生成对象的例子。&lt;br/&gt;代码如下，首先我们先创建一个继承关系的父类和其子类们：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

public class Juice {
    private static long counter = 0;
    private final long id = counter++;

    @Override
    public String toString() {
        return getClass().getSimpleName() + &quot;.....&quot; + id;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个基类，可以统计每一次通过该基类创建子类实例的次数，重写toString方法来输出自增id。然后定义其子类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

public class Apple extends Juice {}
public class Orange extends Juice {}
public class PineApple extends Juice {}
public class Pear extends Juice {}
public class Peach extends Juice {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了5个子类，然后开始我们的重头戏，创建生成器Generator：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.interfaceS;

public interface Generator&amp;lt;T&amp;gt; {
    T next();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个类很有用，把它放到你的工具类里面，日后随时会用到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.Random;

public class JuiceGenerator implements Generator&amp;lt;Juice&amp;gt; {

    private Class[] types = { Apple.class, Pear.class, Peach.class, PineApple.class, Orange.class };
    private Random random = new Random();

    @Override
    public Juice next() {
        try {
            return (Juice) types[random.nextInt(types.length)].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        JuiceGenerator gen = new JuiceGenerator();
        for (int i = 0; i &amp;lt; 5; i++)
            System.out.println(gen.next());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Peach.....0&lt;br/&gt;PineApple.....1&lt;br/&gt;Apple.....2&lt;br/&gt;Orange.....3&lt;br/&gt;Orange.....4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面引入Iterable接口，&lt;/p&gt;
&lt;h4 id=&quot;iterable接口&quot;&gt;1. Iterable接口&lt;/h4&gt;
&lt;p&gt;Iterable是一个接口，任何实现该接口的类都具备可迭代的功能，支持for each循环迭代。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现了Iterable接口，会要求实现其方法返回一个Iterator的实例。&lt;/li&gt;
&lt;li&gt;实现了该接口的类一定要在内部建立一个私有内部类去实现Iterator接口，并在上一层中返回该Iterator的实例。&lt;/li&gt;
&lt;li&gt;注意总结区分Iterable和Iterator接口。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package javaS.genericity.interfaceS;

import java.util.Iterator;
import java.util.Random;

/**
 * Generator, 对象生成器
 * 
 * @Iterable 实现了Iterable接口，该实现类就具备了可迭代的功能，支持for each迭代循环
 * 
 * @author Evsward
 *
 */
public class JuiceGenerator implements Generator&amp;lt;Juice&amp;gt;, Iterable&amp;lt;Juice&amp;gt; {
    // 存储所有果汁类的数组
    private Class[] types = { Apple.class, Grape.class, Orange.class, Peach.class, Pear.class };
    private Random random = new Random();

    @Override
    public Juice next() {
        try {
            // 根据下标随机选择子类实例，并强制转型为基类对象
            return (Juice) types[random.nextInt(types.length)].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // 实现Iterator接口的私有内部类，外界无法直接访问
    private class JuiceIterator implements Iterator&amp;lt;Juice&amp;gt; {
        // 传入数据长度，作为默认迭代次数（也可以在上层类中定义次数）
        // 也可以将其理解为“末端哨兵”，用来判断何时停止
        private int count = types.length;

        @Override
        public boolean hasNext() {
            return count &amp;gt; 0;
        }

        @Override
        public Juice next() {
            count--;
            return JuiceGenerator.this.next();
        }

    }

    @Override
    public Iterator&amp;lt;Juice&amp;gt; iterator() {
        return new JuiceIterator();
    }

    public static void main(String[] args) {
        // JuiceGenerator实现了Iterable接口，所以它可以在循环中使用
        for (Juice j : new JuiceGenerator()) {
            System.out.println(j);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Orange.....0&lt;br/&gt;Peach.....1&lt;br/&gt;Orange.....2&lt;br/&gt;Pear.....3&lt;br/&gt;Peach.....4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题：为什么不直接实现Iterator？&lt;/p&gt;
&lt;p&gt;通过代码观察可以发现，实现Iterable接口的方法每一次返回一个新的Iterator，而直接实现Iterator就需要设置当前迭代位置，这个当前迭代位置的值在该实现类作为参数传来传去的时候，会始终作为该实现类的私有属性存在内存里，那么依赖该属性的hasNext方法和next方法的结果将变得不可预知，这将为我们的程序造成困惑。&lt;/p&gt;
&lt;p&gt;Java容器中，所有的Collection子类会实现Iteratable接口以实现foreach功能，Iteratable接口的实现又依赖于实现了Iterator的内部类，有的容器类会有多个实现Iterator接口的内部类，通过返回不同的迭代器实现不同的迭代方式。如以上代码中JuiceIterator，这种迭代器可以做很多出来（例如前序迭代器，反向迭代器，随机迭代器等等），根据业务需要返回给类使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;override 方法iterator，可以让实现类默认拥有迭代的功能&lt;/li&gt;
&lt;li&gt;也可以定义多个Iterator，除了返给override iterator方法以外，我们还可以通过类的对象去显式地调用其他Iterator。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一句话总结就是，对于迭代器，我们只是将其当做工具，希望它每一次都是从头开始迭代，不要与上一次迭代发生关系，并且工具可以有很多种，让我们随意挑选。&lt;/p&gt;
&lt;h4 id=&quot;斐波那契数列&quot;&gt;2. 斐波那契数列&lt;/h4&gt;
&lt;p&gt;斐波那契数列就是从第2个数开始，每个数的大小为前两个数字之和。这里也通过泛型接口实现，依然实现我们上面的基本生成器Generator类。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.interfaceS;

/**
 * 用泛型接口实现斐波那契数列
 * 
 * @注意 实现泛型接口的时候就要指定泛型的具体类型了
 * @author Evsward
 *
 */
public class Fibonacci implements Generator&amp;lt;Integer&amp;gt; {
    private int count;// 定义一个自加器，用来当做斐波那契数列的线性增加的个数

    @Override
    public Integer next() {
        return fib(count++);// 斐波那契数列的线性增加个数
    }

    /**
     * 递归调用自己，每次的结果为前两个数之和
     * 
     * @param n
     * @return
     */
    private int fib(int n) {
        if (n &amp;lt; 2)
            return 1;
        return fib(n - 2) + fib(n - 1);
    }

    public static void main(String[] args) {
        Fibonacci fib = new Fibonacci();
        for (int i = 0; i &amp;lt; 10; i++)
            System.out.println(fib.next());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：基本类型无法作为泛型的类型参数，所以请先转为对应的对象类型再作为参数传入。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;递归，好像你站在两面相对的镜子中间随意看向其中一面镜子，由于两面镜子之间相互的反射作用，你会发现镜子中有无数个自己，这就是递归。——程杰《大话数据结构》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;编写一个实现了Iterable的斐波那契生成器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们不会去重写这个类，因为上面那个类也很有教学意义，我们只好采用创建一个适配器来做这件事情，关于适配器模式的知识请移步&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/adapter.html&quot;&gt;促和谐好干部——适配器模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.interfaceS;

import java.util.Iterator;

/**
 * 实现了Iterable接口的斐波那契生成器
 * 
 * @author Evsward
 *
 */
public class FibonacciGeneratorAdapter extends Fibonacci implements Iterable&amp;lt;Integer&amp;gt; {

    private int num;

    public FibonacciGeneratorAdapter() {
    }

    public FibonacciGeneratorAdapter(int num) {
        this.num = num;
    }

    @Override
    public Iterator&amp;lt;Integer&amp;gt; iterator() {
        return new Iterator&amp;lt;Integer&amp;gt;() {
            private int n = num;// 当前迭代元素下标

            @Override
            public boolean hasNext() {
                return n &amp;gt; 0;// 边界
            }

            @Override
            public Integer next() {
                n--;// 控制次数
                // 无需改变，直接引用基类的next方法。
                return FibonacciGeneratorAdapter.this.next();
            }
        };// 匿名内部类，结尾要带“;”
    }

    public static void main(String[] args) {
        // 用构造器来设置迭代次数
        for (int a : new FibonacciGeneratorAdapter(18))
            System.out.println(a);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;5&lt;br/&gt;8&lt;br/&gt;13&lt;br/&gt;21&lt;br/&gt;34&lt;br/&gt;55&lt;br/&gt;89&lt;br/&gt;144&lt;br/&gt;233&lt;br/&gt;377&lt;br/&gt;610&lt;br/&gt;987&lt;br/&gt;1597&lt;br/&gt;2584&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段代码有几个要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这里通过继承原有类Fibonacci来实现适配器模式，代码中直接复用基类的斐波那契数列的实现return FibonacciGeneratorAdapter.this.next();&lt;/li&gt;
&lt;li&gt;通过构造器来控制迭代次数，我们在构造函数中设置了迭代次数，并且在迭代器的hasNext方法中将该次数作为结束的判断。&lt;/li&gt;
&lt;li&gt;这一次并没有使用新建一个私有内部类来实现Iterator接口，而是采用了匿名内部类的方式，匿名内部类省去了我们对私有内部类的声明，匿名就是不需要为这个私有内部类取名字，直接返回的就是Iterator的匿名实现。注意，匿名内部类的结尾，大括号后面要有“;”。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;泛型方法&quot;&gt;泛型方法&lt;/h3&gt;
&lt;p&gt;上面介绍了泛型的简单定义，元组的使用，又介绍了泛型接口，这些都是针对整个类的，现在要介绍的是可以作用与单个方法上的泛型方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;泛型方法的使用就是在方法的返回值前面加上泛型参数即可。&lt;br/&gt;下面用一段代码简单说明：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

public class GenericMethods {
    public &amp;lt;T&amp;gt; void f(T x) {
        System.out.println(x.getClass().getName());
    }

    public static void main(String[] args) {
        GenericMethods gm = new GenericMethods();
        gm.f(1000000000000L);
        gm.f(23);
        gm.f(&quot;3&quot;);
        gm.f(3.4);
        gm.f('a');
        gm.f(gm);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.Long
java.lang.Integer
java.lang.String
java.lang.Double
java.lang.Character
javaS.genericity.methodS.GenericMethods&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学到了泛型方法，Java作者给出的建议是，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;无论何时，只要你能做到，你就应该尽量使用泛型方法。意思就是在泛型类和泛型方法之间，要选择泛型方法，因为这样会定位更加精准，可读性更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;泛型方法与泛型类的区别，以及优势：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;泛型类必须在类创建的时候就指定好具体类型来代替泛型&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;泛型方法不需要指定具体类型，就像调用正常方法那样去掉用就好了，因为编译器会为我们找出参数的类型，就像上面代码的输出，它甚至可以接受类对象本身作为其参数，如上面代码输出的最后一行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这称为参数类型推断（type argument inference）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当调用f(n)泛型方法时，传入了基本类型作为参数,&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自动打包机制，介入将基本类型包装为对应的对象，如“java.lang.Integer”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个自动打包机制甚至代替了我们很多时候的手写工作，好处众多，那就从现在开始，每次写代码的时候，将泛型方法放在你的优先级最高。&lt;/p&gt;
&lt;h4 id=&quot;参数类型推断&quot;&gt;1. 参数类型推断&lt;/h4&gt;
&lt;p&gt;上面介绍了那个Generator类，提到它不仅仅是学习中的教材，还是最佳的实践，应该将它放在你的工具类中，日后遇到对象创建工作均可以使用到它。下面，我要再写一段也很有用的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.util.*;

public class Container {
    public static &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; map() {
        return new HashMap&amp;lt;K, V&amp;gt;();
    }

    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; list() {
        return new ArrayList&amp;lt;T&amp;gt;();
    }

    public static &amp;lt;T&amp;gt; LinkedList&amp;lt;T&amp;gt; lList() {
        return new LinkedList&amp;lt;T&amp;gt;();
    }

    public static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; set() {
        return new HashSet&amp;lt;T&amp;gt;();
    }

    public static &amp;lt;T&amp;gt; Queue&amp;lt;T&amp;gt; queue() {
        return new LinkedList&amp;lt;T&amp;gt;();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没学过泛型之前，看到上面的代码，会有种不明觉厉的感觉，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“能写出类似以上代码的人，应该就是架构师吧”曾经弱弱的我如是想。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问：以上代码有什么用处呢？&lt;/p&gt;
&lt;p&gt;当我们要创建一个容器的时候，先写个复杂一点的：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Map&amp;lt;Animal, List&amp;lt;? extends Pet&amp;gt;&amp;gt; pet = new HashMap&amp;lt;Animal, List&amp;lt;? extends Pet&amp;gt;&amp;gt;();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这行代码很常见吧，参数类型那么长还要写两遍，会不会感觉有点烦，现在我们只要：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Map&amp;lt;Animal, List&amp;lt;? extends Pet&amp;gt;&amp;gt; pet = Container.map();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就可以了，参数类型只需要定义一遍，化解了还要再抄一遍参数类型的烦恼。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;@deprecated&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;类型推断只对已知参数类型有效，例如你可以传一个1，编译器会认出它是整型Integer对象，就会用Integer去代替原参数位置的泛型类型，但你不能寄希望于传入一个泛型参数让编译器去猜，它会报错的。( ∙̆ .̯ ∙̆ )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以接着上面的代码写：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;f(Container.map()); // 编译器会不理你的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，若你直接指明类型：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;f(Container.&amp;lt;Animal, List&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;以上内容已过时了，我使用的是jdk1.8，测试发现编译器并未报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        GenericMethods gm = new GenericMethods();
        Map pet = Container.map();
        gm.f(Container.map());
        gm.f(Container.&amp;lt;Sort, List&amp;lt;Grade&amp;gt;&amp;gt;map());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;java.util.HashMap
java.util.HashMap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出无论是未指定参数类型的Container.map()，还是显式地指定参数类型的，参数类型推断机制都发挥了效用。或许，未指定参数类型的map在之后可以指定，但是并不建议这么用。虽然编译器未报错，但这么写规规矩矩地不好么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Map&amp;lt;Sort, List&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;可变参数列表&quot;&gt;2. 可变参数列表&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可变参数列表就是参数的个数并不确定，用...来表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.util.ArrayList;...

public class GenericVarargs {
    /**
     * 通过泛型自己实现java.util.Array.asList()
     * 
     * @param args
     *            可变参数列表，数量并不确定
     * @return 将参数中不定数量的元素变成一个List
     */
    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; makeList(T... args) {
        List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;T&amp;gt;();
        for (T item : args)
            result.add(item);
        return result;
    }

    public static void main(String[] args) {
        System.out.println(makeList(1, 2, 4));
        System.out.println(makeList('a', 'b', 'c'));
        System.out.println(makeList(new QuickSort(), new SelectSort(), new InsertSort()));
        // 参数列表中也可以互相不是同一类型（但是这时编译器会报一个警告，告诉你参数不安全）
        // 因为编译器会将他们转为Object对象
        System.out.println(makeList(1, &quot;this&quot;, 4));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;[1, 2, 4]
[a, b, c]
[algorithms.sort.QuickSort@15db9742, algorithms.sort.SelectSort@6d06d69c, algorithms.sort.InsertSort@7852e922]
[1, this, 4]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，由于泛型的使用，配合可变参数列表，我们可以将任意类型的元素随意组合传入该方法转换成一个List，泛型的这个特性很强大。&lt;/p&gt;
&lt;h4 id=&quot;基于generator的泛型方法&quot;&gt;3. 基于Generator的泛型方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实例：将Generator创建的新元素填充进一个Collection的泛型方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个例子里面，由于我们对元素的类型并不预知，也可以说使用了泛型方法以后，我们能够支持多种类型的参数，这样该方法的功能更加强大。&lt;/p&gt;
&lt;p&gt;开始代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.util.ArrayList;...

public class Generators {
    /**
     * 将Generator生成的next元素填充进一个Collection中。
     * 
     * @param col
     *            目标Collection
     * @param gen
     *            元素生成器
     * @param n
     *            生成器工作的次数
     * @return
     */
    public static &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; fill(Collection&amp;lt;T&amp;gt; col, Generator&amp;lt;T&amp;gt; gen, int n) {
        for (int i = 0; i &amp;lt; n; i++)
            col.add(gen.next());
        return col;
    }

    public static void main(String[] args) {
        // 使用时要指定具体类型
        Collection&amp;lt;Juice&amp;gt; colJuice = Generators.fill(new ArrayList&amp;lt;Juice&amp;gt;(), new JuiceGenerator(), 5);
        Collection&amp;lt;Integer&amp;gt; fibonacci = Generators.fill(new ArrayList&amp;lt;Integer&amp;gt;(), new FibonacciGeneratorAdapter(), 10);
        for (Juice j : colJuice)
            System.out.println(j);
        for (Integer i : fibonacci)
            System.out.println(i);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Lemon.....0&lt;br/&gt;Orange.....1&lt;br/&gt;Orange.....2&lt;br/&gt;Pear.....3&lt;br/&gt;Grape.....4&lt;br/&gt;1&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;5&lt;br/&gt;8&lt;br/&gt;13&lt;br/&gt;21&lt;br/&gt;34&lt;br/&gt;55&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们传入了Juice集合的实例，以及Juice生成器（生成器中实现了Iterable接口）的实例，我们也可以传入整型对象集合的实例，以及斐波那契生成器（生成器中实现了Iterable接口）的实例。我们可以分别获得一个可迭代的元素类型为Juice和一个元素类型为Integer的Collection对象。&lt;/p&gt;
&lt;h3 id=&quot;通用generator&quot;&gt;通用Generator&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为任意带有默认构造器的类创建一个生成器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成器上面提过很多次，属于对象创建模式的范畴。我们下面要写的通用Generator可以为任意类创建一个生成器，只要该类满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显式编写了无参构造器&lt;/li&gt;
&lt;li&gt;该类为public的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个类有了生成器，就可以利用他不断快速方便地创建对象。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import javaS.genericity.interfaceS.Generator;
import javaS.genericity.interfaceS.Juice;
import javaS.genericity.interfaceS.Orange;

/**
 * 为任何类生成一个生成器
 *
 * @author Evsward
 *
 * @param &amp;lt;T&amp;gt;
 */
public class BasicGenerator&amp;lt;T&amp;gt; implements Generator&amp;lt;T&amp;gt; {

    private Class&amp;lt;T&amp;gt; type;

    public BasicGenerator() {
    }

    // 也可以直接显式调用此构造函数为对象类型创建一个默认生成器
    public BasicGenerator(Class&amp;lt;T&amp;gt; type) {
        this.type = type;
    }

    @Override
    public T next() {
        try {
            return type.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 对外提供一个静态方法，通过给定对象类型create一个默认生成器
     * 
     * @param type
     *            想要生成的类型
     * @set type 类必须为public，必须具备构造器
     * 
     * @return 一个默认生成器
     */
    public static &amp;lt;T&amp;gt; Generator&amp;lt;T&amp;gt; create(Class&amp;lt;T&amp;gt; type) {
        return new BasicGenerator&amp;lt;T&amp;gt;(type);
    }

    public static void main(String[] args) {
        // 从前创造多个类的对象的做法：
        Juice orange01 = new Orange();
        System.out.println(orange01);
        Juice orange02 = new Orange();
        System.out.println(orange02);
        Juice orange03 = new Orange();
        System.out.println(orange03);
        System.out.println(&quot;------------&quot;);
        // 吃了药以后，额不是，有了生成器以后，只需要设定要几个对象就循环几次，对象就全部创建出来了。
        Generator&amp;lt;Orange&amp;gt; gen01 = BasicGenerator.create(Orange.class);
        Generator&amp;lt;Orange&amp;gt; gen02 = new BasicGenerator&amp;lt;Orange&amp;gt;(Orange.class);
        for (int i = 0; i &amp;lt; 3; i++)
            System.out.println(&quot;gen-01-&quot; + gen01.next());
        for (int i = 0; i &amp;lt; 3; i++)
            System.out.println(&quot;gen-02-&quot; + gen02.next());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Orange.....0
Orange.....1
Orange.....2
------------
gen-01-Orange.....3
gen-01-Orange.....4
gen-01-Orange.....5
gen-02-Orange.....6
gen-02-Orange.....7
gen-02-Orange.....8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出，以及代码中的注释，我们可以对比出来使用生成器创建对象是非常方便的，而且该生成器是基于泛型的，对于类的类型的处理非常灵活。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;生成器Generator，类似于设计模式中的工厂模式，符合依赖倒转原则，里氏代换原则以及单一指责原则，避免了用new的方式去创建对象，解耦了对象和类之间的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们在工程实践中遇到需要多次创建类的对象的时候，可以采用BasicGenerator和Generator的结构，多多熟悉使用，增加我们的程序的灵活性。&lt;/p&gt;
&lt;h4 id=&quot;简化元组类&quot;&gt;1. 简化元组类&lt;/h4&gt;
&lt;p&gt;我们这一节主要描述的是泛型方法，上面我们提过尽量使用泛型方法，而不是泛型类，那么之前研究到的所有泛型类均有机会被泛型方法所改造。元组类就是可以优化的一种。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.util.ArrayList;...

public class Tuple {
    public static &amp;lt;A, B&amp;gt; TwoTuple&amp;lt;A, B&amp;gt; twoTuple(A a, B b) {
        return new TwoTuple&amp;lt;A, B&amp;gt;(a, b);
    }

    public static &amp;lt;A, B, C&amp;gt; ThreeTuple&amp;lt;A, B, C&amp;gt; twoTuple(A a, B b, C c) {
        return new ThreeTuple&amp;lt;A, B, C&amp;gt;(a, b, c);
    }

    public static void main(String[] args) {
        // 原来的方式
        TwoTuple&amp;lt;Sort, List&amp;lt;Integer&amp;gt;&amp;gt; two = new TwoTuple&amp;lt;Sort, List&amp;lt;Integer&amp;gt;&amp;gt;(new QuickSort(),
                new ArrayList&amp;lt;Integer&amp;gt;());
        // 现在的方式
        two = Tuple.twoTuple(new QuickSort(), new ArrayList&amp;lt;Integer&amp;gt;());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过直接调用方法去创建元组的对象。&lt;/p&gt;
&lt;h4 id=&quot;set容器中泛型的使用&quot;&gt;2. Set容器中泛型的使用&lt;/h4&gt;
&lt;p&gt;Set容器包含很多内置函数用来解决一些数学问题，加入了泛型以后，可以处理更多类型的参数。直接代码里面注释说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;

/**
 * Set通过使用泛型方法来封装Set的自有方法。
 * 
 * @author Evsward
 *
 */
public class SetSupply {
    // 求集合A、B的并集
    public static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; union(Set&amp;lt;T&amp;gt; setA, Set&amp;lt;T&amp;gt; setB) {
        Set&amp;lt;T&amp;gt; result = new HashSet&amp;lt;T&amp;gt;(setA);// 不要直接操作setA，请保持setA的纯真
        result.addAll(setB);
        return result;
    }

    // 求集合A、B的交集
    public static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; intersection(Set&amp;lt;T&amp;gt; setA, Set&amp;lt;T&amp;gt; setB) {
        Set&amp;lt;T&amp;gt; result = new HashSet&amp;lt;T&amp;gt;(setA);
        result.retainAll(setB);
        return result;
    }

    // 求集合A、B的差集
    public static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; difference(Set&amp;lt;T&amp;gt; setA, Set&amp;lt;T&amp;gt; setB) {
        Set&amp;lt;T&amp;gt; result = new HashSet&amp;lt;T&amp;gt;(setA);
        result.removeAll(setB);
        return result;
    }

    // 求集合A、B的并集-集合A、B的交集
    public static &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; complement(Set&amp;lt;T&amp;gt; setA, Set&amp;lt;T&amp;gt; setB) {
        return difference(union(setA, setB), intersection(setA, setB));
    }

    public static void main(String[] args) {
        Set&amp;lt;Colors&amp;gt; setA = EnumSet.range(Colors.Red, Colors.Orange);
        Set&amp;lt;Colors&amp;gt; setB = EnumSet.range(Colors.Black, Colors.Blue);
        System.out.println(SetSupply.union(setA, setB));
        System.out.println(SetSupply.intersection(setA, setB));
        System.out.println(SetSupply.difference(setA, setB));
        System.out.println(SetSupply.complement(setA, setB));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要直接操作参数传过来的集合本身，我们复制了一份set出来作为结果集合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Set容器中泛型的使用，利用枚举做一个实例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

public enum Colors {
    Red, Green, Black, White, Gray, Blue, Yellow, Purple, Pink, Orange
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;[Green, Gray, Blue, White, Pink, Purple, Red, Black, Orange, Yellow]
[Gray, Blue, White, Black]
[Green, Pink, Purple, Red, Orange, Yellow]
[Green, Pink, Purple, Red, Orange, Yellow]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，利用上面这个功能，我们来检查一下在jdk中Collection和Map的方法的差异：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity.methodS;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;

public class MethodDif {
    static Set&amp;lt;String&amp;gt; methods(Class&amp;lt;?&amp;gt; type) {
        Set&amp;lt;String&amp;gt; methodSets = new TreeSet&amp;lt;String&amp;gt;();
        for (Method m : type.getMethods())
            methodSets.add(m.getName());
        return methodSets;
    }

    static void interfaces(Class&amp;lt;?&amp;gt; type) {
        System.out.println(&quot;Interfaces in &quot; + type.getSimpleName() + &quot;: &quot;);
        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;String&amp;gt;();
        for (Class&amp;lt;?&amp;gt; c : type.getInterfaces())
            result.add(c.getSimpleName());
        System.out.println(result);
    }

    static Set&amp;lt;String&amp;gt; objectMethods = methods(Object.class);// 比较之前要先把根类Object的方法去除。

    static {
        objectMethods.add(&quot;clone&quot;);
    }

    static void difference(Class&amp;lt;?&amp;gt; setA, Class&amp;lt;?&amp;gt; setB) {
        System.out.println(setA.getSimpleName() + &quot;  &quot; + setB.getSimpleName() + &quot;, adds: &quot;);
        Set&amp;lt;String&amp;gt; comp = SetSupply.difference(methods(setA), methods(setB));
        comp.removeAll(objectMethods);
        System.out.println(comp);
        interfaces(setA);
    }

    public static void main(String[] args) {
        // System.out.println(&quot;Collection: &quot; + methods(Collection.class));
        // interfaces(Collection.class);
        // difference(Set.class, Collection.class);
        difference(Set.class, HashSet.class);
        difference(HashSet.class, Set.class);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过反射获得我们要比较的目标类所包含的方法名，并存入集合，然后调用之前写的那段比较Set的方法，进行查看两个类之间的方法区别。这里应用到了Java的反射机制。&lt;/p&gt;
&lt;h3 id=&quot;反射与泛型&quot;&gt;反射与泛型&lt;/h3&gt;
&lt;p&gt;现在，Class类是泛型的，例如，String.class 实际上是Class&amp;lt;String&amp;gt;类的唯一的对象，类型参数十分有用，这是因为它允许Class&amp;lt;T&amp;gt;方法的返回类型更加具有针对性，参照JDK中Class&amp;lt;T&amp;gt;源码可以看到这些类型参数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.Class&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;T newInstance() 返回默认构造器构造的一个新实例。免除了类型转换。&lt;/li&gt;
&lt;li&gt;T cast(Object obj) 如果obj为null或有可能转换成类型T，则返回obj；否则抛出BadCastException异常。&lt;/li&gt;
&lt;li&gt;T[] getEnumConstants() 如果T是枚举类型，则返回所有值组成的数组，否则返回null。&lt;/li&gt;
&lt;li&gt;Class&amp;lt;? super T&amp;gt; getSuperclass() 返回这个类的超类（由于java是单继承，每个子类最多只有一个父类）如果T不是一个类或T是Object类（Object类已经是根类了，它没有超类），则返回null。&lt;/li&gt;
&lt;li&gt;Constructor&lt;/li&gt;
&lt;li&gt;Constructor&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;java.lang.reflect.Constructor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的代码例子中，实现Iterable接口，返回迭代器的部分，已经引用到了匿名内部类的特性，没看到的同学可以去到那里再看一眼，然后回到这里继续分析，泛型在匿名内部类中的应用。前面我们有了Juice基类，可以输出每一次输出对象的id，同时它也有自己的JuiceGenerator，用来随机迭代输出众多子类对象。我们可以继续使用他们，同时再新创建一个冰激凌类，果汁搭配冰淇淋，听上去就要拉肚子的配方。下面看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import javaS.genericity.interfaceS.Generator;

/**
 * 泛型在匿名内部类中的应用
 * 
 * @author Evsward
 *
 */
public class IceCream {
    private static long counter = 0;
    private final long id = counter++;

    @Override
    public String toString() {
        return getClass().getSimpleName() + &quot;.....&quot; + id;
    }

    /**
     * 这里通过一个匿名内部类返回一个Generator
     * 
     * @return
     */
    public static Generator&amp;lt;IceCream&amp;gt; generator() {
        return new Generator&amp;lt;IceCream&amp;gt;() {
            public IceCream next() {
                return new IceCream();
            }
        };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随时记住复用我们之前的代码，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.List;
import java.util.Queue;
import java.util.Random;

import javaS.genericity.interfaceS.Generator;
import javaS.genericity.interfaceS.Juice;
import javaS.genericity.interfaceS.JuiceGenerator;
import javaS.genericity.methodS.Container;
import javaS.genericity.methodS.Generators;

/**
 * 泛型在匿名内部类中的应用
 * 
 * @author Evsward
 *
 */
public class IceCream {
    private static long counter = 0;
    private final long id = counter++;

    //构造器是private的，那么外部无法使用new来创建对象，必须使用Generator来创建。
    private IceCream() {
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + &quot;.....&quot; + id;
    }

    /**
     * 这里通过一个匿名内部类返回一个Generator
     * 
     * @return
     */
    public static Generator&amp;lt;IceCream&amp;gt; generator() {
        return new Generator&amp;lt;IceCream&amp;gt;() {
            public IceCream next() {
                return new IceCream();
            }
        };
    }

    // 随意输出一个结果，让IceCream与Juice建立一个联系。
    public static void match(IceCream i, Juice j) {
        System.out.println(i + &quot; matches &quot; + j);
    }

    public static void main(String[] args) {
        Random random = new Random();
        // 随时记住复用我们之前写好的工具类
        Queue&amp;lt;Juice&amp;gt; drinks = Container.queue();// 创建一个集合用来存果汁
        List&amp;lt;IceCream&amp;gt; ices = Container.list();// 创建一个集合用来存冰激凌
        // 两种方式的generator。
        Generators.fill(drinks, new JuiceGenerator(), 6);
        Generators.fill(ices, IceCream.generator(), 3);
        // 输出结果
        for (Juice j : drinks)
            match(ices.get(random.nextInt(ices.size())), j);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;IceCream.....1 matches Peach.....0
IceCream.....1 matches Orange.....1
IceCream.....2 matches Grape.....2
IceCream.....0 matches Orange.....3
IceCream.....1 matches Grape.....4
IceCream.....0 matches Lemon.....5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IceCream的构造器被指定为private，所以强制只能使用Generator来创建对象。我们复用了Container创建集合对象，复用了Generators的fill方法，将Generator创建出来的对象填充到一个集合中区。&lt;/p&gt;
&lt;h3 id=&quot;创建复杂模型&quot;&gt;创建复杂模型&lt;/h3&gt;
&lt;p&gt;我们来尝试创建一个复杂的容器，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.*;

public class TupleList&amp;lt;A, B, C&amp;gt; extends ArrayList&amp;lt;ThreeTuple&amp;lt;A, B, C&amp;gt;&amp;gt; {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;体内的恶魔在苏醒...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是貌似我们没有用过多代码就得到了一个安全稳定的负载结构，下面在Client端进行使用该集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import javaS.genericity.interfaceS.JuiceGenerator;
import javaS.genericity.interfaceS.Orange;

public class Client {
    public static void main(String[] args) {
        TupleList&amp;lt;Integer, Orange, IceCream&amp;gt; tl = new TupleList&amp;lt;Integer, Orange, IceCream&amp;gt;();
        // 我们创建对象的时候全都在复用以前的代码，这很好。
        ThreeTuple tt1 = new ThreeTuple(12, new Orange(), IceCream.generator().next());
        // hmmm，这很好。
        ThreeTuple tt2 = new ThreeTuple(3, new JuiceGenerator().next(), IceCream.generator().next());
        tl.add(tt1);
        tl.add(tt2);
        for (ThreeTuple&amp;lt;Integer, Orange, IceCream&amp;gt; a : tl)
            System.out.println(a);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;12__&amp;amp;&amp;amp;&amp;amp;__Orange.....0__&amp;amp;&amp;amp;&amp;amp;__IceCream.....0
3__&amp;amp;&amp;amp;&amp;amp;__Peach.....1__&amp;amp;&amp;amp;&amp;amp;__IceCream.....1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们是在虐自己么？这种复杂集合模型有什么用呢，下面来构建一个实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import javaS.genericity.interfaceS.Generator;
import javaS.genericity.methodS.BasicGenerator;

/**
 * 举个栗子：线程池中有线程组，线程组中有三个元素。
 * 
 * @author Evsward
 *
 */
public class ThreadPoolSG {
    private TupleList&amp;lt;Integer, Thread, String&amp;gt; threadPool = new TupleList&amp;lt;Integer, Thread, String&amp;gt;();

    private int countId;

    // 使用生成器来生成线程组
    private class ThreadTupleGenerator implements Generator {

        @Override
        public ThreeTuple&amp;lt;Integer, Thread, String&amp;gt; next() {
            return new ThreeTuple(countId++, new Thread(), &quot;xx&quot; + countId);
        }

    }

    /**
     * 外部只提供该方法生成指定数量的线程池
     * 
     * @param n
     *            指定线程池的大小
     * @return
     */
    public TupleList&amp;lt;Integer, Thread, String&amp;gt; getThreadPool(int n) {
        // 先清空
        for (int i = 0; i &amp;lt; threadPool.size(); i++)
            threadPool.remove(i);
        for (int i = 0; i &amp;lt; n; i++)
            threadPool.add(new ThreadTupleGenerator().next());
        return threadPool;
    }

    public static void main(String[] args) {
        ThreadPoolSG tpsg = new ThreadPoolSG();
        for (ThreeTuple&amp;lt;Integer, Thread, String&amp;gt; t : tpsg.getThreadPool(5))
            System.out.println(t);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;0__&amp;amp;&amp;amp;&amp;amp;__Thread[Thread-0,5,main]__&amp;amp;&amp;amp;&amp;amp;__xx1
1__&amp;amp;&amp;amp;&amp;amp;__Thread[Thread-1,5,main]__&amp;amp;&amp;amp;&amp;amp;__xx2
2__&amp;amp;&amp;amp;&amp;amp;__Thread[Thread-2,5,main]__&amp;amp;&amp;amp;&amp;amp;__xx3
3__&amp;amp;&amp;amp;&amp;amp;__Thread[Thread-3,5,main]__&amp;amp;&amp;amp;&amp;amp;__xx4
4__&amp;amp;&amp;amp;&amp;amp;__Thread[Thread-4,5,main]__&amp;amp;&amp;amp;&amp;amp;__xx5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我写这个线程池只是为了举例，以上代码并不具备实践意义，关于java多线程的基础知识我会另开一篇博文专门研究，这里知识为了说明复杂模型的应用场景，大家可以自由发挥。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总结：使用泛型元组可以轻松构建复杂集合模型，且他们是类型安全可管理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;看到这里，我想您已经很累了，后面的内容为选看，如果想了解和使用泛型，成为一个中级泛型程序员，那么以上内容已经足够，下面的内容可以定义为“提高篇”。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;你看上了一个姑娘，目之所及之处全是各种美好，相处起来却发现她也有自己的小缺点啊。任何事不要停留在幻想，去理性接受一个人的弱点，就像你钦羡她的成功一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;泛型的擦除变个魔术&quot;&gt;泛型的擦除——变个魔术&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.ArrayList;
import java.util.List;

public class Client {
    public static void main(String[] args) {
        List a1 = new ArrayList&amp;lt;String&amp;gt;();
        List a2 = new ArrayList&amp;lt;Integer&amp;gt;();
        System.out.println(a1 == a2);
        Class c1 = new ArrayList&amp;lt;String&amp;gt;().getClass();
        Class c2 = new ArrayList&amp;lt;Integer&amp;gt;().getClass();
        System.out.println(c1 == c2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我来猜猜输出的情况，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：false true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么是这样，我们很容易将ArrayList&amp;lt;String&amp;gt;和ArrayList&amp;lt;Integer&amp;gt;理解为不同的类型，为什么结果他们是相同的类型？我们进一步测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.*;

class Hey&amp;lt;YYYY, B, C, D&amp;gt; {
}

public class Client {
    public static void main(String[] args) {
        Class c1 = new ArrayList&amp;lt;String&amp;gt;().getClass();
        Class c2 = new ArrayList&amp;lt;Integer&amp;gt;().getClass();
        Class c5 = new HashSet&amp;lt;Integer&amp;gt;().getClass();
        Class c6 = new HashMap&amp;lt;Integer, String&amp;gt;().getClass();
        Class c7 = new Hey&amp;lt;Integer, String, Integer, String&amp;gt;().getClass();
        System.out.println(Arrays.toString(c1.getTypeParameters()));
        System.out.println(Arrays.toString(c2.getTypeParameters()));
        System.out.println(Arrays.toString(c5.getTypeParameters()));
        System.out.println(Arrays.toString(c6.getTypeParameters()));
        System.out.println(Arrays.toString(c7.getTypeParameters()));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;[E] [E] [E] [K, V] [YYYY, B, C, D]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jdk官方文档对Class.getTypeParameters()的解释是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Returns an array of TypeVariable objects that represent the type variables declared by the generic declaration represented by this GenericDeclaration object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是这个方法将返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。然而无论你泛型指定的类型是Integer也好，String也罢，输出的结果都是无含义的占位符而已，也就是说，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在泛型代码内部，无法获得任何有关泛型参数类型的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以ArrayList&amp;lt;String&amp;gt;和ArrayList&amp;lt;Integer&amp;gt;在运行上是相同的类型。这两种形式都被擦除成他们的原生类型，即List。&lt;/p&gt;
&lt;h3 id=&quot;探索泛型的底层原理类型的擦除机制&quot;&gt;探索泛型的底层原理，类型的擦除机制。&lt;/h3&gt;
&lt;p&gt;Java对对象的控制要大过C++，对象只能调用自己事先声明过的方法，对于陌生的方法，编译器并不会自动识别。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import algorithms.sort.QuickSort;

public class NewHolder&amp;lt;T&amp;gt; {

    private T a;

    public NewHolder(T a) {
        this.a = a;
    }

    public void aMethod(int[] arr) {
        a.sort(arr);// 报错了！！！The method sort() is undefined for the type T
        // 除非改成强制转为指定类型。那我们的NewHolder&amp;lt;T&amp;gt;类是否就失去了泛型的意义？
        ((NewHolder&amp;lt;QuickSort&amp;gt;) a).sort(arr);
    }

    public static void main(String[] args) {
        int[] a = { 12, 5, 66, 23 };
        // 使用的时候将泛型定义为整型，那么只能限制设置a为整型值
        NewHolder&amp;lt;QuickSort&amp;gt; n = new NewHolder&amp;lt;QuickSort&amp;gt;(new QuickSort());
        n.aMethod(a);// 我们期望能执行new QuickSort().sort(array)
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码在Java中编译都不会通过，但有意思的是在C++中是很正常的存在，NewHolder在自己的aMethod方法中用泛型T的对象来调用跟它完全陌生的sort方法，它怎么知道T的对象认识sort方法呢？如果NewHolder在使用时被指定为其他类型，例如NewHolder&amp;lt;Integer&amp;gt;，那么这个T的对象就是一个整型类型，无论如何Integer里面也不会有我们在QuickSort中自定义的sort方法的。Java之于C++是青出于蓝，泛型的思想也是源于C++，但是在java里落地生根，泛型的机制发生了变化，最大的变化就是Java的编译器需要预先指定泛型类的边界，以便告知编译器只能接受这个边界的类型，超越这个边界的类型在该泛型类中不予支持。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;泛型的边界，重用extends关键字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import algorithms.sort.QuickSort;
import algorithms.sort.Sort;

public class NewHolder&amp;lt;T extends Sort&amp;gt; {

    private T a;

    public NewHolder(T a) {
        this.a = a;
    }

    public void aMethod(int[] arr) {
        a.sort(arr);// 编译通过
    }

    /**
     * 如果想要通过泛型类的持有属性a来调用Sort中的其他方法，需要定义泛型类自己的方法来包含Sort的方法。
     * 
     * @provide 对外提供方法来调用Sort的内部方法
     * @param arr
     */
    public void show(int[] arr) {
        a.show(arr);// 编译通过
    }

    public static void main(String[] args) {
        int[] a = { 12, 5, 66, 23 };
        QuickSort q = new QuickSort();
        NewHolder&amp;lt;QuickSort&amp;gt; n = new NewHolder&amp;lt;QuickSort&amp;gt;(q);// 使用的时候将泛型定义为整型，那么只能限制设置a为整型值
        n.aMethod(a);// 我们期望能执行new QuickSort().sort(array)
        q.show(a);
        System.out.println(&quot;--------------------我是方法作用域的分界线--------------------&quot;);
        n.show(a);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;66
23
12
5
数组长度：4，执行交换次数：5
--------------------我是方法作用域的分界线--------------------
66
23
12
5
数组长度：4，执行交换次数：5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们通过&amp;lt;T extends Sort&amp;gt;的方式指定了泛型的边界，该泛型只接受Sort类型，当然了Sort的子类也都在这个范畴，因此合情合理可以调用Sort的内部方法了。&lt;/li&gt;
&lt;li&gt;我们正常的通过Sort的对象去调用其方法，也可以在泛型类中通过持有的泛型属性来调用，只要再定义一个泛型类自己的方法即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;泛型中关于类型的擦除，如果没有指定泛型的边界，擦除机制会将该泛型的所有类型都擦掉，最终泛型只沦落为一个占位符而已，就像上面提到过的那样。而如果定义了它的边界，擦除机制会将参数类型擦除到这个边界，就好像在类的声明中用Sort替换了T一样。&lt;/p&gt;
&lt;p&gt;问题：为什么不直接用&amp;lt;Sort&amp;gt;代替&amp;lt;T extends Sort&amp;gt;啊？非要搞出个泛型T，还要定义他的边界，其实效果不就跟直接将泛型指定为Sort来的方便吗？甚至，都不要搞泛型了，直接把持有对象属性T a改为Sort a不就完事了，泛型在这里真是多此一举啊。&lt;/p&gt;
&lt;p&gt;解答：只有当你希望使用的类型参数比某个具体类型（以及他的所有子类型）更加“泛化”时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，使用泛型边界通常要比直接类替换更加复杂。举个弱弱的例子，如果某个类有一个返回T的方法，那么泛型就有所帮助，因为它会返回确切的类型，而不是基类。（好吧，这也算数？？那我们平时总使用的List list = new ArrayList(); 如何解释啊？当然了，肯定会有希望获得具体类型对象而不是基类对象的场景，例如我只想使用子类特有的方法。。但是这样的话又会重蹈找不到方法的覆辙吧。）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个回答我自己都不满意。往下分析再看看吧，Java作者肯定比我聪明，会有更好的解答的，否则设计个泛型的边界有何用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;请给我一个合理的解释迁移兼容性&quot;&gt;1. 请给我一个合理的解释？迁移兼容性&lt;/h4&gt;
&lt;p&gt;首先重定向上面的疑虑，泛型边界不是Java作者专门设计的什么牛逼的语言特性，而是一个折中方案，整个折中方案的核心就是擦除机制，java爸爸们为了能让我们使用上新款“泛型”特性，也是做足了里子面子，想出擦除这么一个折中办法。&lt;/p&gt;
&lt;p&gt;下面用三寸不烂之舌谈谈历史问题，&lt;/p&gt;
&lt;p&gt;如果从Java诞生之时，就有泛型，那么泛型一定不会用类型擦除的方式实现，而是使用具体化，使类型参数保持为第一类实体，因此你就能够在类型参数上执行基于类型的语言操作和反射操作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;擦除减少了泛型的泛化行，泛型在Java中仍旧是有用的，只不过没有设想的那么有用，原因就是擦除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;泛型是java在5.0以后加入的特性&quot;&gt;2. 泛型是java在5.0以后加入的特性。&lt;/h4&gt;
&lt;p&gt;Java SE5之前，有大量的非泛型类库，之后我们热爱泛型的工程师们开始了泛化之路，但是之前的非泛化类库如何升级为泛化呢？这就需要“迁移兼容性”，将非泛化类库变为泛型时，不会破坏依赖于它的代码和应用程序。（任何一个有良心的组织或公司，都会让他们的系统向旧机兼容，ps3好像就不能玩耍ps4的游戏呢，幸好iphone5s还能安装IOS11）这个良心目标定下了以后，众多“最强大脑”们认为擦除是唯一可行的解决方案。通过允许非泛型代码与泛型代码共存，擦除使得这种向着泛型的迁移成为可能。&lt;/p&gt;
&lt;h4 id=&quot;擦除的问题&quot;&gt;3. 擦除的问题&lt;/h4&gt;
&lt;p&gt;由于上一节提到的那个崇高的动机，擦除的代价是显著的：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;泛型不能用于显式地引用运行时类型的操作之中（只能处于类型声明阶段），例如转型、instanceof和new表达式。因为所有关于参数的类型信息都丢失了，无论何时，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Fool&amp;lt;T&amp;gt;  {
    T a;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上去你在创建一个Fool的实例，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fool&amp;lt;Joke&amp;gt; f = new Fool&amp;lt;Joke&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;泛型语法也在强烈暗示：在整个类的各个地方，类型T都在被替换。但是事实并非如此，无论何时，当你在编写整个类的代码时，必须提醒自己：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No, it's just an Object!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;擦除和迁移兼容性意味着，泛型的使用并不是强制的，所以我们经常可以在使用那种没有指定泛型的子类时，经常会有warning出来，（我知道有些人对代码下面的黄色波浪线也很难容忍）这时通过一个注解：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;@SuppressWarings(&quot;unchecked&quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以不让这个warning出来扰乱你，但是作者仍旧好心提醒，请把这个注解放在离你warning代码最近的位置，而不是整个类上，这样可以避免忽略掉其他真正的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;而当你希望泛型参数不仅仅是个Object，就需要管理泛型的边界。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到的那个疑虑，不使用泛型直接使用类替换和使用泛型边界这两种效果是一样的，我们可以通过跟踪这两种代码在编译期间的字节码来对比发现，确实如我们所料字节码是相同的。&lt;/p&gt;
&lt;p&gt;擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点，这正是编译器在编译期执行对传入值的类型检查并插入传出值的转型代码（因为边界让泛型转型为具体类型）的地点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;边界就是发生动作的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;擦除的补偿&quot;&gt;4. 擦除的补偿&lt;/h4&gt;
&lt;p&gt;前面强调过，泛型不能显式地引用运行时类型的操作之中，换句话来讲，就是运行时，泛型一定被具体类型替代。任何试图运行泛型操作的举动都将被编译器视为违法。&lt;br/&gt;例如，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// T并没有指定具体类型，在编译器那里就是个占位符，没有任何类型的特征以及类型操作的能力
// 所以这一行代码直接报错。
T t = new T();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想创建类的实例，首先要确定类的类型，而泛型恰恰类型已被擦除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 判断arg是否是B的实例，还是那句话，要确定类的实例，首先这个类得“是个真的类”，泛型不是真的类
// 所以这一行直接报错。
if(arg instanceof B){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;综上所述，在java中，所有关于具体类型的操作，泛型都是做不了的。&lt;/p&gt;
&lt;p&gt;问：擦除这么大代价，我要是想实现上面那些功能，该如何补偿？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.ArrayList;
import java.util.Arrays;

public class Client&amp;lt;B&amp;gt; {
    B b;

    public Client(Class&amp;lt;B&amp;gt; arg) {
        try {
            b = arg.newInstance();
        } catch (InstantiationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Class c1 = new ArrayList&amp;lt;String&amp;gt;().getClass();
        Class c2 = new ArrayList&amp;lt;Integer&amp;gt;().getClass();
        Class c7 = new Client&amp;lt;String&amp;gt;(String.class).getClass();
        System.out.println(Arrays.toString(c1.getTypeParameters()));
        System.out.println(Arrays.toString(c2.getTypeParameters()));
        System.out.println(Arrays.toString(c7.getTypeParameters()));
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[E] [E] [B]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以采用工厂模式来创建泛型的实例，实际上在调用该工厂模式的时候，泛型已经被具体类型化了。&lt;/p&gt;
&lt;h3 id=&quot;泛型数组&quot;&gt;泛型数组&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;泛型数组一般使用ArrayList，例如我们常见的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Client&amp;lt;T&amp;gt; {
    List&amp;lt;T&amp;gt; array = new ArrayList&amp;lt;T&amp;gt;();// 看这里。。

    public void add(T x) {
        arr.add(x);
    }

    public static void main(String[] args) {
        Client&amp;lt;String&amp;gt; c = new Client&amp;lt;String&amp;gt;();
        c.add(&quot;hey,&quot;);
        c.add(&quot;yeah.&quot;);
        System.out.println(c.arr);
    
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[hey,, yeah.]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这将使你获得数组的行为，以及由泛型提供的编译期的类型安全。&lt;/p&gt;
&lt;h3 id=&quot;通配符&quot;&gt;通配符？&lt;/h3&gt;
&lt;h4 id=&quot;extends-superclass&quot;&gt;1. &amp;lt;? extends SuperClass&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.*;

import javaS.genericity.interfaceS.Juice;
import javaS.genericity.interfaceS.Lemon;

public class Client&amp;lt;T&amp;gt; {
    public static void main(String[] args) {
        List&amp;lt;? extends Juice&amp;gt; juice = new ArrayList&amp;lt;Lemon&amp;gt;();
        juice.add(null);// 实际上除了null以外，任何值都add不了，直接报错。。。
        Juice aha = juice.get(0);
        System.out.println(aha);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉自己是个逗逼。。。&lt;/p&gt;
&lt;p&gt;我为什么要写出这样的代码，WTF。好吧，蓄力分析一波，List&amp;lt;? extends Juice&amp;gt; 可以读作“具有任何从Juice继承过来的类型的列表”。但是我们知道泛型是假的类型，juice不是什么真正的Juice子类的实例列表，那好，我们在new后面指定了具体类型Lemon，继承自Juice。气力已尽，总之，在实践中可以不用泛型，但不要写出这样的代码。&lt;/p&gt;
&lt;h4 id=&quot;super-class&quot;&gt;2. &amp;lt;? super Class&amp;gt;&lt;/h4&gt;
&lt;p&gt;超类型通配符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.*;

import javaS.genericity.interfaceS.Lemon;

public class Client&amp;lt;T&amp;gt; {
    public static void main(String[] args) {
        List&amp;lt;? super Juice&amp;gt; juice = new ArrayList&amp;lt;Juice&amp;gt;();
        juice.add(new Lemon());
        juice.add(new Orange());
        juice.add(new Peach());
        for (Object aha : juice)
            System.out.println(aha);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Lemon.....0
Orange.....1
Peach.....2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译成功了，运行也成功了。但是? super Juice好像与Juice没有区别。“！！！我在做什么，我在哪里，我是谁！！！”&lt;/p&gt;
&lt;h4 id=&quot;section&quot;&gt;3. &amp;lt;?&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.ArrayList;
import java.util.List;

public class Client&amp;lt;T&amp;gt; {
    public static void main(String[] args) {
        List&amp;lt;?&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        list.add(&quot;afd&quot;);//报错，无论如何也add不进去，任何对象都不行。
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我决定要放弃这场逗逼之旅了。。。&lt;/p&gt;
&lt;h3 id=&quot;使用泛型的注意事项&quot;&gt;使用泛型的注意事项&lt;/h3&gt;
&lt;h4 id=&quot;任何基本类型都不能作为类型参数&quot;&gt;1. 任何基本类型都不能作为类型参数。&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不能创建类似ArrayList&amp;lt;int&amp;gt;的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一个类不能实现同一个泛型接口的两种变体&quot;&gt;2. 一个类不能实现同一个泛型接口的两种变体。&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import algorithms.sort.Sort;
import javaS.genericity.interfaceS.Juice;

interface ONE&amp;lt;A&amp;gt;{}
class TWO implements ONE&amp;lt;Sort&amp;gt;{}
public class Client&amp;lt;T&amp;gt; extends TWO implements ONE&amp;lt;Juice&amp;gt; {
// error: The interface ONE cannot be implemented more than once -
// with different arguments: ONE&amp;lt;Sort&amp;gt; and ONE&amp;lt;Juice&amp;gt;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;suppresswarning注解&quot;&gt;3. @SuppressWarning注解&lt;/h4&gt;
&lt;p&gt;用于去除泛型类型参数的转型或instanceof时发出的警告。&lt;/p&gt;
&lt;h4 id=&quot;重载泛型方法时&quot;&gt;4. 重载泛型方法时&lt;/h4&gt;
&lt;p&gt;注意不同的泛型命名最终都会被擦除成相同的占位符，所以实际类型会被打回原始类型List而跟泛型内容毫无关系，所以不要写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Client&amp;lt;A,B&amp;gt; {
    void f(List&amp;lt;A&amp;gt; list){}//报错
    void f(List&amp;lt;B&amp;gt; list){}//报错
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;报错信息：Erasure of method f(List&amp;lt;B&amp;gt;) is the same as another method in type Client&amp;lt;A,B&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是A和B不是真的类呢？我要是换个真的类是不是能好？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Client&amp;lt;String, Integer&amp;gt; {
    void f(List&amp;lt;String&amp;gt; list){}//报错
    void f(List&amp;lt;Integer&amp;gt; list){}//报错
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;报错信息：Erasure of method f(List&amp;lt;B&amp;gt;) is the same as another method in type Client&amp;lt;A,B&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;兄弟你想多了。&lt;/p&gt;
&lt;p&gt;总结：只要涉及到泛型参数的方法，不能重载。&lt;/p&gt;
&lt;h4 id=&quot;不能创建参数化类型的数组&quot;&gt;5. 不能创建参数化类型的数组&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt;[] a = new ArrayList&amp;lt;Integer&amp;gt;[10];//error:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;error:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- Cannot create a generic array of ArrayList\&amp;lt;Integer\&amp;gt;
- List is a raw type. References to generic type List\&amp;lt;E\&amp;gt; should be 
 parameterized&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，我突然突发奇想，想知道列表数组的写法，于是写了一段以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.genericity;

import java.util.ArrayList;
import java.util.List;

public class Client {
    public static void main(String[] args) {
        List[] a = new ArrayList[10];
        for (int i = 0; i &amp;lt; 5; i++) {
            List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
            list.add(6);
            a[i] = list;
        }
        for (List&amp;lt;Integer&amp;gt; k : a) {
            if (k == null)
                break;
            for (int c : k) {
                System.out.println(c);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;6&lt;br/&gt;6&lt;br/&gt;6&lt;br/&gt;6&lt;br/&gt;6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列表数组，意思就是一个数组中每个元素就是一个List对象，但是要注意，在具体给List赋值的时候，一定要指定类型了，获取这些List中的值的时候，也应该指定类型，否则将出现类型转换错误。所以这种写法并不灵活，且具有一定的类型错误的风险。&lt;/p&gt;
&lt;h4 id=&quot;泛型类的静态上下文中类型变量无效&quot;&gt;6. 泛型类的静态上下文中类型变量无效&lt;/h4&gt;
&lt;p&gt;换句话说，就是不能再静态域或方法中引用类型变量。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private static T t;// 报错：Cannot make a static reference to the non-static type T&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;哦对了还有一个逗比王中王&quot;&gt;7. 哦对了，还有一个逗比王中王&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;class SelfBounded&amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt; {}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写下这样的代码的人为什么不去当个科学家研究研究火箭啥的（你咋不上天）？&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;请忽略“提高篇”中探索泛型底层实现的内容，我们客观评价一下泛型的优点。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;不得不承认，泛型是我们需要的程序设计手段。使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类尤其有用，例如，ArrayList加泛型已经是我们习以为常的写法了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;泛型类、泛型方法、泛型接口在实践中都是很不错的应用，我们掌握了这一层就已经脱离了只会使用ArrayList&amp;lt;String&amp;gt;的初级泛型程序员而进化为可以自己去实现适合自己工作的泛型了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过学习泛型，我们巩固了迭代接口Iterable，Iterator，为自己积累了像Generator，Generators以及BasicGenerator这样的实用代码。我们还练习了并不常常敲的可变数量参数，以及斐波那契数列，匿名内部类，还有Set的使用，元组的使用，复杂模型的构建。收获是满满的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们深入了解了泛型的底层原理，体会了java作者们在设计泛型时的煎熬（一般人受不了），也体会了他们对泛型的期许。这使我成熟很多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;所有源码均在-evsward-github&quot;&gt;所有源码均在 &lt;a href=&quot;https://github.com/evsward/mainbase/tree/master/src/javaS/genericity&quot;&gt;Evsward github&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;Core Java Volume I --- Fundamentals&lt;/em&gt; (Ninth Edition)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Thinking in Java&lt;/em&gt; (Fourth Edition)&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 03 Nov 2017 13:56:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/genericity.html</dc:identifier>
</item>
<item>
<title>关于laravel5.5控制器方法参数依赖注入原理深度解析及问题修复 - 程序人生♨︎</title>
<link>http://www.cnblogs.com/springwind2006/p/7780524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springwind2006/p/7780524.html</guid>
<description>&lt;p&gt;　　在laravel5.5中，可以根据控制器方法的参数类型，自动注入一个实例化对象，极大提升了编程的效率，但是相比较与Java的SpringMVC框架，功能还是有所欠缺，使用起来还是不太方便，主要体现在方法参数的注入不完全是按照参数名称进行的，如果改变了传入参数的顺序会导致类型不匹配的错误。&lt;/p&gt;
&lt;h3&gt;一、控制器方法参数注入步骤设计&lt;/h3&gt;
&lt;p&gt;1、在/routes/web.php中添加路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Route::get('/diary/show/{diary}/{page?}','Diary\DiaryController@list');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、编写控制器文件DiaryController.php放到/app/Http/Controllers/Diary/路径下面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
namespace App\Http\Controllers\Diary;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; App\Http\Controllers\Controller;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DiaryController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Controller&lt;br/&gt;{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(\App\Diary &lt;span&gt;$diary&lt;/span&gt;,&lt;span&gt;$page&lt;/span&gt;=11&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;($diary-&amp;gt;title,&lt;span&gt;$page&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　} &lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、构建模型\App\Diary并安装到数据库（略）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
namespace App;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; Illuminate\Database\Eloquent\Model;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Diary &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Model
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;$table&lt;/span&gt;='diary'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$timestamps&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、访问控制器方法&lt;/p&gt;
&lt;p&gt;打开浏览器输入：“http://127.0.0.1//diary/show/4/12”&lt;/p&gt;
&lt;p&gt;此时输出数据表diary中id=4的title字段值和12&lt;/p&gt;

&lt;h3&gt;二、注入参数类型说明&lt;/h3&gt;
&lt;p&gt;说明：laravel会根据请求路由中匹配的{diary}和{page}变量和控制器方法中需要的方法参数类型，生成实例对象并注入到控制器方法中，&lt;/p&gt;
&lt;p&gt;针对不同的参数类型分三种情况：&lt;/p&gt;
&lt;p&gt;1、如果参数类型实现了UrlRoutable接口（即继承自Illuminate\Database\Eloquent\Model），则在模型对象对应的表中查找id值为路由中匹配参数值的那条记录，并构建模型对象；&lt;/p&gt;
&lt;p&gt;2、如果参数类型为自定义类型（没有实现UrlRoutable接口），则laravel会构建一个对象后注入；&lt;/p&gt;
&lt;p&gt;3、如果参数类型为基础数据类型，并且名称为路由参数中定义的名称，则从路由参数中获取值；&lt;/p&gt;
&lt;p&gt;4、如果参数类型为基础数据类型，但名称未在路由参数中定义，如果有默认值则使用默认值，否则系统提示错误。&lt;/p&gt;

&lt;h3&gt;三、目前注入参数存在的问题分析&lt;/h3&gt;
&lt;p&gt;参考java的Spring MVC框架，laravel的参数类型注入还存在缺陷，主要体现在不完全是按照参数名称进行注入。&lt;/p&gt;
&lt;p&gt;1、如果改变控制器参数的顺序，会出现参数类型传递错误，如将DiaryController控制的show方法的参数改变顺序，则会导致错误发生：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
namespace App\Http\Controllers\Diary;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; App\Http\Controllers\Controller;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DiaryController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(&lt;span&gt;$page&lt;/span&gt;,\App\Diary &lt;span&gt;$diary&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$diary&lt;/span&gt;-&amp;gt;title,&lt;span&gt;$page&lt;/span&gt;&lt;span&gt;); 
　　} 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、由于参数类型为基础数据类型（参见二（3）），并不是按照名称来注入的参数，因此将代码改为如下，同样会运行正常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
namespace App\Http\Controllers\Diary;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; App\Http\Controllers\Controller;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DiaryController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(\App\Diary &lt;span&gt;$diary,$pag&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$diary&lt;/span&gt;-&amp;gt;title,&lt;span&gt;$pag&lt;/span&gt;&lt;span&gt;); 
　　} 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、laravel5.5控制器方法参数注入源码剖析&lt;/h3&gt;
&lt;h4&gt;1、实现了UrlRoutable接口的参数类型由路由中间件Illuminate\Routing\Middleware\SubstituteBinding实现构建&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; handle(&lt;span&gt;$request&lt;/span&gt;, Closure &lt;span&gt;$next&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;router-&amp;gt;substituteBindings(&lt;span&gt;$route&lt;/span&gt; = &lt;span&gt;$request&lt;/span&gt;-&amp;gt;&lt;span&gt;route());
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;router-&amp;gt;substituteImplicitBindings(&lt;span&gt;$route&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$next&lt;/span&gt;(&lt;span&gt;$request&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Illuminate\Routing\Router的substituteImplicitBindings方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; substituteImplicitBindings(&lt;span&gt;$route&lt;/span&gt;&lt;span&gt;)
    {
        ImplicitRouteBinding&lt;/span&gt;::resolveForRoute(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;container, &lt;span&gt;$route&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Illuminate\Routing\ImplicitRouteBinding的resolveForRoute方法中实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolveForRoute(&lt;span&gt;$container&lt;/span&gt;, &lt;span&gt;$route&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从路由参数中获取参数值,$parameters为 ['diary':'4','page':'12']&lt;/span&gt;
        &lt;span&gt;$parameters&lt;/span&gt; = &lt;span&gt;$route&lt;/span&gt;-&amp;gt;&lt;span&gt;parameters();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取控制器的函数参数列表，此处传入UrlRoutable::class，只返回实现UrlRoutable接口的参数&lt;/span&gt;
        &lt;span&gt;$signatureParameters&lt;/span&gt; = &lt;span&gt;$route&lt;/span&gt;-&amp;gt;signatureParameters(UrlRoutable::&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$signatureParameters&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$parameter&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;$parameterName&lt;/span&gt; = &lt;span&gt;static&lt;/span&gt;::getParameterName(&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;name, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;$parameterValue&lt;/span&gt; = &lt;span&gt;$parameters&lt;/span&gt;[&lt;span&gt;$parameterName&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$parameterValue&lt;/span&gt;&lt;span&gt; instanceof UrlRoutable) {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建模型的实例（基础自Illuminate\Database\Eloquent\Model），此处为App\Diary&lt;/span&gt;
            &lt;span&gt;$instance&lt;/span&gt; = &lt;span&gt;$container&lt;/span&gt;-&amp;gt;make(&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;getClass()-&amp;gt;&lt;span&gt;name);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将参数值绑定到模型，参加Illuminate\Database\Eloquent\Model的resolveRouteBinding方法&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;$model&lt;/span&gt; = &lt;span&gt;$instance&lt;/span&gt;-&amp;gt;resolveRouteBinding(&lt;span&gt;$parameterValue&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ModelNotFoundException)-&amp;gt;setModel(&lt;span&gt;get_class&lt;/span&gt;(&lt;span&gt;$instance&lt;/span&gt;&lt;span&gt;));
            }&lt;br/&gt;　　　　　　　&lt;span&gt;&lt;strong&gt;//根据参数名称注入模型实例
            &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;$route&lt;/span&gt;-&amp;gt;setParameter(&lt;span&gt;$parameterName&lt;/span&gt;, &lt;span&gt;$model&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;附加说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此处调用$route对象（Illuminate\Routing\Route类型）setParameter方法，说明模型参数类型（见二（1））正是通过参数类型和参数名称同时匹配才注入模型实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2、其它类型的控制器参数在运行路由控制器时绑定&lt;/h4&gt;
&lt;p&gt;关键部分在Illuminate\Routing\ControllerDispatcher的dispatch方法中实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; dispatch(Route &lt;span&gt;$route&lt;/span&gt;, &lt;span&gt;$controller&lt;/span&gt;, &lt;span&gt;$method&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析控制器方法的参数&lt;/span&gt;
        &lt;span&gt;$parameters&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;resolveClassMethodDependencies(
            &lt;/span&gt;&lt;span&gt;$route&lt;/span&gt;-&amp;gt;parametersWithoutNulls(), &lt;span&gt;$controller&lt;/span&gt;, &lt;span&gt;$method&lt;/span&gt;&lt;span&gt;
        );
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;method_exists&lt;/span&gt;(&lt;span&gt;$controller&lt;/span&gt;, 'callAction'&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过Illuminate\Routing\Controller的callAction调用控制器方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$controller&lt;/span&gt;-&amp;gt;callAction(&lt;span&gt;$method&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接调用控制器方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$controller&lt;/span&gt;-&amp;gt;{&lt;span&gt;$method&lt;/span&gt;}(...&lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用resolveClassMethodDependencies方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolveMethodDependencies(&lt;span&gt;array&lt;/span&gt; &lt;span&gt;$parameters&lt;/span&gt;, ReflectionFunctionAbstract &lt;span&gt;$reflector&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$instanceCount&lt;/span&gt; = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$values&lt;/span&gt; = &lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过方法反射获取方法参数&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;getParameters() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$key&lt;/span&gt; =&amp;gt; &lt;span&gt;$parameter&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有默认值则返回默认值，如果是自定义方法则构建实例返回&lt;/span&gt;
            &lt;span&gt;$instance&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;transformDependency(
                &lt;/span&gt;&lt;span&gt;$parameter&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;
            );

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;is_null&lt;/span&gt;(&lt;span&gt;$instance&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;$instanceCount&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义类型（未实现UrlRoutable接口）的实例注入&lt;/span&gt;
                &lt;span&gt;$this&lt;/span&gt;-&amp;gt;spliceIntoParameters(&lt;span&gt;$parameters&lt;/span&gt;, &lt;span&gt;$key&lt;/span&gt;, &lt;span&gt;$instance&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;elseif&lt;/span&gt; (! &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$values&lt;/span&gt;[&lt;span&gt;$key&lt;/span&gt; - &lt;span&gt;$instanceCount&lt;/span&gt;]) &amp;amp;&amp;amp;
                      &lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;isDefaultValueAvailable()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未在路由参数中定义，但有默认值的参数注入&lt;/span&gt;
                &lt;span&gt;$this&lt;/span&gt;-&amp;gt;spliceIntoParameters(&lt;span&gt;$parameters&lt;/span&gt;, &lt;span&gt;$key&lt;/span&gt;, &lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;getDefaultValue());
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题总结说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;模型参数（见二（1））和&lt;/span&gt;名称在路由参数中定义的基础类型（见二（3））必须按照在路由中定义的顺序首先传入控制器方法，否则会出现类型不匹配的错误；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;自定义类型（见二（2））和名称未在路由参数中定义的基础类型参数（见二（4）），在控制器方法中按出现的顺序依次传入。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;五、问题修复&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;打开/vendor/laravel/framework/src/Illuminate/Routing/RouteDependencyResolverTrait.php文件，&lt;/p&gt;
&lt;p&gt;将resolveMethodDependencies方法修改为如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolveMethodDependencies(&lt;span&gt;array&lt;/span&gt; &lt;span&gt;$parameters&lt;/span&gt;,ReflectionFunctionAbstract &lt;span&gt;$reflector&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;$methodParameters&lt;/span&gt;=&lt;span&gt;[];
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;getParameters() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$key&lt;/span&gt;=&amp;gt;&lt;span&gt;$parameter&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;$name&lt;/span&gt;=&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;getName();
            &lt;/span&gt;&lt;span&gt;$instance&lt;/span&gt;=&lt;span&gt;$this&lt;/span&gt;-&amp;gt;transformDependency(&lt;span&gt;$parameter&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;is_null&lt;/span&gt;(&lt;span&gt;$instance&lt;/span&gt;&lt;span&gt;)){
                &lt;/span&gt;&lt;span&gt;$methodParameters&lt;/span&gt;[]=&lt;span&gt;$instance&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;elseif&lt;/span&gt;(!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$parameters&lt;/span&gt;[&lt;span&gt;$name&lt;/span&gt;]) &amp;amp;&amp;amp; &lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;isDefaultValueAvailable()){
                &lt;/span&gt;&lt;span&gt;$methodParameters&lt;/span&gt;[]=&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;getDefaultValue();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;$methodParameters&lt;/span&gt;[]=&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$parameters&lt;/span&gt;[&lt;span&gt;$name&lt;/span&gt;]) ? &lt;span&gt;$parameters&lt;/span&gt;[&lt;span&gt;$name&lt;/span&gt;] : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$methodParameters&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改之后完全按照名称和类型注入控制器方法参数，代码变得更简洁，功能也更强大了！&lt;/p&gt;
&lt;p&gt;如果参数没有在路由中定义并且未提供默认值，那么将以null注入。&lt;/p&gt;

</description>
<pubDate>Fri, 03 Nov 2017 13:11:00 +0000</pubDate>
<dc:creator>程序人生♨︎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/springwind2006/p/7780524.html</dc:identifier>
</item>
<item>
<title>伤不起的微信小程序 - 贝贝le</title>
<link>http://www.cnblogs.com/code-le/p/7594274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code-le/p/7594274.html</guid>
<description>&lt;p&gt;前段时间不是很忙，刚好公司需要开发一个微信小程序，于是我就入坑了（此坑还是有点深滴，请备好干粮）。&lt;/p&gt;
&lt;p&gt;我是一名iOS开发工程师，个人觉得入门开发小程序的话，需要基本的web前端知识，比如说：代码的书写格式，规范，标签以及样式的使用等，但作为一门如此新的开发语言，它也有自己的独特之处，就像我们的swift，融合了万家语言于一体，学好它就可以敲遍天下无敌手了（程序猿的毛病又犯了。。。）。它的外表看起来有点像传统的web开发，但它实质的开发思想又和我们的oc很像，比如它的 app.js、app.json、app.wxss 这三个全局文件的作用，还有数据绑定的开发模式。下面就说说自己的入坑经历吧，希望对大家有点点帮助。&lt;/p&gt;
&lt;p&gt;先说一些大家上手小程序时都会问到的问题：&lt;/p&gt;
&lt;p&gt;Q：小程序可以和现有的App 打通吗？&lt;br/&gt;A：小程序可以借助微信联合登录，和开发者已有的App 后台的用户数据进行打通，但不会支持小程序和App 直接的跳转。&lt;br/&gt;Q：微信已经有了订阅号、服务号、企业号，小程序和这三者有什么不同？&lt;br/&gt;A：小程序、订阅号、服务号、企业号是并行的体系。&lt;br/&gt;Q：小程序可以个人开发吗？&lt;br/&gt;A：小程序允许个人开发，只是个人开发是不能发布的，并且想在真机上看到的话，在创建小程序时就得填上你申请好的appid。&lt;br/&gt;Q：小程序需要付费吗？&lt;br/&gt;A：个人是不需要的，公司的需要一个被认证过的微信服务号，不需再付额外的费用（需要注意小程序申请时名字及icon的确认）。&lt;/p&gt;

&lt;p&gt;开始正题：重要的事情说n遍（认真看文档，仔细看文档，认真仔细看文档，虽然微信的官方文档写的不清不楚）。长度单位基本使用rpx（这是小程序特有的单位，可以理解为一个百分比），它是把屏幕宽分为750等份，所以我们在开发时，最好要求UI设计师提供750px宽度的图，然后在iPhone6上面开发。在这我们得注意一个点，模拟器上面的UI展示效果和真机上的有时还是有差别的，所以我们在模拟器上调试后好，一定要用不同真机看看效果，必要时可以根据不同机型稍作调整（苹果手机还好，如果是安卓手机，对于点点ui问题就没必要太纠结了。。。怕你会疯）。&lt;/p&gt;
&lt;p&gt;生命周期的注意：下面图片里的两个数组，它们的作用域都是本页面，但是它们的生命周期是不同的。dataList1的生命周期同小程序的生命周期，也就意味着你每次退出页面时，要在onUnload: function () {}函数中使之置空，要不会有数据的叠加发生（对于像BOOL值的判断也需注意）。dataList2的生命周期同本页的生命周期，所以不需要手动管理。全局属性或函数，请在app.js里申明，配合var app = getApp()使用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;生命周期&quot; src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103170406841-601891179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;小程序现在的入口有：微信客户端-发现-小程序；个人或群里分享（不支持盆友圈分享）；扫码进入。&lt;/p&gt;
&lt;p&gt;我们主要看看后面两种方法的实现，分享主要调用onShareAppMessage函数，请看下面的截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103170920841-741981519.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;p&gt;扫码请仔细看文档（https://mp.weixin.qq.com/debug/wxadoc/introduction/qrcode.html#二维码跳转规则），&lt;/p&gt;
&lt;p&gt;如何设置：后台-设置-开发设置-服务器域名-扫普通链接二维码打开小程序（如下图，左开发版，右线上版）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103170801310-1181217885.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;337&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103171107638-998925496.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要特别注意两点：在我们的小程序未上线时，一次最多只支持5个链接的使用。在使用链接生成二维码之前，要先去后台-设置-开发设置-服务器域名-request合法域名里，配置好链接域名。如果你的链接是带参数的，那么一定要注意，生成二维码时参数也必须一样。当我们的小程序上线后，就没有这么多限制了，只需设置规则及功能页面就可以了，这也就意味着我们&lt;span&gt;线上版生成的二维码里的参数可以随便改，达到扫不同的二维码，进入的界面里的数据都不一样的效果&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;好了，转发及二维码的生成我们都会了，现在来看看怎么在程序中怎么接收这些参数，然后去使用（看下图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103171953638-2025666962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意点：在onLoad函数中设置参数（options，自定义）接收，二维码链接内容会以&lt;span&gt;参数q&lt;span&gt;（只能用q去接收）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;形式带给页面，在onLoad事件中提取&quot;q&quot;参数并自行&lt;span&gt;UrlDecode一次&lt;/span&gt;，即可获取原二维码的完整内容。&lt;/p&gt;
&lt;p&gt;工具类的使用：常用的方法可以放在util.js里面，方便管理和使用。例如调用里面的网络请求方法：    &lt;/p&gt;
&lt;p&gt;var request = require('../../../utils/util.js')；  &lt;/p&gt;
&lt;p&gt;request.httpsGetRequest(url, dic, function (success) { }）；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module.exports = {
  formatTime: formatTime,
  getWindowWidth: getWindowWidth,
  getWindowHeight: getWindowHeight,
  showStyle: showStyle,
  useScanCode: useScanCode,
  httpsGetRequest: httpsGetRequest,
  httpsPostRequest: httpsPostRequest
}

function getWindowWidth() {
  var num = 0
  wx.getSystemInfo({
    success: function (res) {
      num = res.windowWidth
    }
  })
  return num;
}

function showStyle(title, content) {
  console.log('showStyle')
  wx.showModal({
    title: title,
    content: content,
    success: function (res) {
      if (res.confirm) {
        console.log('用户点击确定')
      } else {
        console.log('用户点击取消')
      }
    }
  })

}

//GET请求
function httpsGetRequest(req_url, req_obj, res_func) {
  var jsonUrl = {
    url: req_url,
    header: { &quot;Content-Type&quot;: &quot;application/json&quot; },
    method: &quot;GET&quot;,
    success: function (res) {
      typeof res_func == &quot;function&quot; &amp;amp;&amp;amp; res_func(res.data);
    }
  }

  if (req_obj) {
    jsonUrl.data = req_obj;
  }

  wx.request(jsonUrl);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于代码的管理及利用，我们也可以多使用模板（template），具体请参考（https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/template.html）。&lt;/p&gt;

&lt;p&gt;背景图（background-image:url（‘imageUrl’））的使用：可能刚开始是可以直接使用本地的图片的，但现在经过自己的测试，如果使用本地图片的话，必须先base64编码（http://base64.xpcha.com/indexie.php），然后把imageUrl换成你编码后的字符串，由于编码后的字符串不是一般的长，所以还是推荐使用网络图片作为背景图的资源。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分享到朋友圈&lt;/span&gt;：小程序虽然不能直接分享到朋友圈，但是并不是代表没有方法。既然我们可以通过扫码进入小程序，那也就意味着我们只要把二维码分享到朋友圈，别人长按识别后就可以达到目的了。但是我们如果只是转一个二维码在朋友圈的话，谁知道是什么内容，所以也就需要配些文字说明，个人感觉这样hen low，所以了，不如在二维码下加一个吸引人的背景图，并且在背景图上加以文字说明（作为一名程序猿，做了产品经理做的事，还给自己挖了个坑去实现。。。申明我不是处女座。。。）。想法很好，怎么去实现呢？&lt;/p&gt;
&lt;p&gt;方法一：让后台生成二维码图片，包括合成背景图，然后我们下载再保存到相册，用的api有，wx.downloadFile======wx.saveImageToPhotosAlbum。&lt;/p&gt;
&lt;p&gt;方法二：自己生成二维码并合成，需要用到canvas标签，至于合成图片，小程序是没有提供接口的，我们可以把要合成的背景图设为画布的背景图，这样就可以实现了。用的api有，&lt;/p&gt;
&lt;p&gt;wx.canvasToTempFilePath======wx.saveImageToPhotosAlbum。难点是怎么画二维码，小程序没有提供接口，请参照：http://blog.csdn.net/sinat_17775997/article/details/53608479。&lt;/p&gt;
&lt;p&gt;注意点：保存图片到相册需要用户的权限，所以需要处理好这块的逻辑，就像获取用户的基本信息一样；判断api是否可用，本人的微信版本6.5.6，在使用wx.saveImageToPhotosAlbum接口时就一直报错，后面才排查到是因为版本的问题。&lt;/p&gt;
&lt;p&gt;其实对于小程序的推广，除了这几点，我们还可以使用公众号里的模版消息进行推送，具体请自己去看公帐号开发文档。还有，好像订阅号的文章里也可以写上小程序的链接进行推广，这个本人暂时没试过，如果有小伙伴验证了，记得评论告诉小哥哥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/955413/201711/955413-20171103181008888-2031612932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后讲一下上线问题，上线时需要填一些相关信息，上面写的很严格（吓屎个把人），对于我们开发iOS的程序员来说，最怕的就是被拒-被拒-悲剧。。。实际是没那么严格的，比如功能页面及其说明，不怕，尽管填，拒了还是算你的。审核时间问题，第一次的话会久一点，两天左右，以后迭代就快了，5个小时左右（上班时间，其实晚上他们也有人审核的）。&lt;/p&gt;
&lt;p&gt;本人qq：763815972，欢迎一起交流。&lt;/p&gt;

</description>
<pubDate>Fri, 03 Nov 2017 10:41:00 +0000</pubDate>
<dc:creator>贝贝le</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code-le/p/7594274.html</dc:identifier>
</item>
<item>
<title>学习UML --用例图 - XavierCn</title>
<link>http://www.cnblogs.com/insist-zhongwen-blog/p/UML_Usecase.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/insist-zhongwen-blog/p/UML_Usecase.html</guid>
<description>&lt;p&gt;　　用例图用于描述系统提供的系列功能。使用用例图的主要目的是帮助开发团队以一种可视化的方式理解系统的功能需求。用例图对系统的实现不做任何说明，仅仅是系统功能的描述。&lt;/p&gt;
&lt;p&gt;　　用例图主要在需求分析阶段使用，用于描述系统实现的功能，方便与客户交流，保证系统需求的无二性。&lt;/p&gt;

&lt;p&gt;　　用例图有四部分用例，角色，系统边界，关系。&lt;/p&gt;
&lt;p&gt;　　1、角色&lt;/p&gt;
&lt;p&gt;　　与系统交互的一个实体。这个实体可以是用户、组织或者外部系统等。用一个小人表示。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103112110841-1801842145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、用例&lt;/p&gt;
&lt;p&gt;　　代表系统提供的一个服务或者系统提供的一个功能模块。个人理解就是系统对角色提供的服务（系统的一个功能或者多个功能组成的一个功能模块）。以一个椭圆表示，用例的名称放在椭　　圆的中间或者下面。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103112510107-444298877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　3、系统边界&lt;/p&gt;
&lt;p&gt;　　指系统与系统之间的界限。并把系统边界以外的同系统相关联的其他部分称为系统环境。系统边界用方框来表示，同时附上系统的名称，角色画在边界的外面，用例画在边界里面。因为系　　统边界的作用有时不是很明显，所以可以省略。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103115210920-1526291749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　4、关系&lt;/p&gt;
&lt;p&gt;　　用例图中涉及的关系有关联，泛化，包含，扩展。&lt;/p&gt;
&lt;p&gt;　　如下表所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103144125295-280876759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　a、关联&lt;/p&gt;
&lt;p&gt;　　表示角色和用例之间的通信，任何一方都可以发送和接收消息。&lt;/p&gt;
&lt;p&gt;　　【箭头指向】消息的接收方。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103170950466-1258422862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　b、泛化&lt;/p&gt;
&lt;p&gt;　　泛化可以理解为代码中的继承。父用例或者父角色具有一般性，子用例（或者子角色）具有特殊性。子用例（或者子角色）继承父用例（或者父角色）的行为、结构和关系。子用例（或者子角色）可以使用父用例（或者父角色）的部分行为，也可以重载它。父用例通常是抽象的。&lt;/p&gt;
&lt;p&gt;　　【箭头指向】父用例。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103170058560-771013562.png&quot; alt=&quot;&quot;/&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103170850373-1864844927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　c、包含&lt;/p&gt;
&lt;p&gt;　　包含是指一个用例包含另一个用例。一般用于将复杂的用例所表示的功能分解成若干个简单的用例或者将若干个用例的公共部分分离出来，使其成为可以复用的用例。&lt;/p&gt;
&lt;p&gt;　　【箭头指向】被包含的用例。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103161443154-1277803038.png&quot; alt=&quot;&quot;/&gt; 　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103174224248-2113258585.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;


&lt;p&gt;　　d、扩展&lt;/p&gt;
&lt;p&gt;　　扩展关系表示在一个用例对话流程中，可能会根据条件插入另外一个用例，前者称为基础用例，后者称为扩展用例。相当于为基础用例提供一个附加功能。&lt;/p&gt;
&lt;p&gt;　　【箭头指向】指向基础用例。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/958594/201711/958594-20171103165300982-1171007948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　系统中允许用户对用户查询的结果进行导出和打印，对于查询而言，能不能导出和打印查询结果都行一样的。导出、打印和查询是相互对立的，而且导出、打印为查询添加了新的行为。&lt;/p&gt;
&lt;p&gt;　　5、泛化、包含、扩展之间的关系&lt;/p&gt;
&lt;p&gt;　　条件性：泛化中的子用例和包含关系中被包含的用例呼无条件的发生，扩展关系中的扩展用例的发生是需要条件的。&lt;/p&gt;
&lt;p&gt;　　直接性：泛化中的子用例和扩展关系中的扩展用例为角色提供直接服务，而包含关系中被包含的用例为角色提供间接服务。&lt;/p&gt;
&lt;p&gt;　　对扩展关系而言，扩展用例不包含基础用例的内容，基础用例不包含扩展用例的内容。&lt;/p&gt;
&lt;p&gt;　　对泛化关系而言，子用例包含父用例的全部内容，包括父用例和其他用例和角色的关系。&lt;/p&gt;

&lt;p&gt;　　引用：&lt;/p&gt;
&lt;p&gt;　　https://baike.baidu.com/item/%E7%94%A8%E4%BE%8B%E5%9B%BE/9531932?fr=aladdin#1_3&lt;/p&gt;
&lt;p&gt;　　www.cnblogs.com/13062225wmx/p/5432356.html&lt;/p&gt;
&lt;p&gt;　　http://www.cnblogs.com/Yogurshine/archive/2013/01/14/2859248.html&lt;/p&gt;
</description>
<pubDate>Fri, 03 Nov 2017 09:59:00 +0000</pubDate>
<dc:creator>XavierCn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/insist-zhongwen-blog/p/UML_Usecase.html</dc:identifier>
</item>
<item>
<title>java8Stream原理深度解析 - Dorae</title>
<link>http://www.cnblogs.com/Dorae/p/7779246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dorae/p/7779246.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Author:Dorae&lt;br/&gt;Date:2017年11月2日19:10:39&lt;br/&gt;转载请注明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Dorae/p/7769868.html&quot;&gt;上一篇文章&lt;/a&gt;中简要介绍了Java8的函数式编程，而在Java8中另外一个比较大且非常重要的改动就是Stream。在这篇文章中，将会对流的实现原理进行深度，解析，具体关于如何使用，请参考《Java8函数式编程》。&lt;/p&gt;
&lt;h2 id=&quot;常用的流操作&quot;&gt;常用的流操作&lt;/h2&gt;
&lt;p&gt;在深入原理之前，我们有必要知道关于Stream的一些基础知识，关于Stream的操作分类，如表1-1所示。&lt;/p&gt;
&lt;p&gt;表1-1 Stream的常用操作分类(&lt;a href=&quot;http://www.cnblogs.com/CarpenterLee/p/6637118.html&quot;&gt;&lt;span&gt;表格引自这里&lt;/span&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103172932295-447576959.png&quot; alt=&quot;表1-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如表1-1中所示，&lt;strong&gt;Stream中的操作可以分为两大类&lt;/strong&gt;：中间操作与结束操作，中间操作只是对操作进行了记录，只有结束操作才会触发实际的计算（即惰性求值），这也是Stream在迭代大集合时高效的原因之一。中间操作又可以分为无状态（Stateless）操作与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响；后者是指该操作只有拿到所有元素之后才能继续下去。结束操作又可以分为短路与非短路操作，这个应该很好理解，前者是指遇到某些符合条件的元素就可以得到最终结果；而后者是指必须处理所有元素才能得到最终结果。&lt;/p&gt;
&lt;h2 id=&quot;原理探秘&quot;&gt;原理探秘&lt;/h2&gt;
&lt;p&gt;在探究Stream的执行原理之前，我们先看如下两段代码（本文将以code_1为例进行说明）：&lt;/p&gt;
&lt;p&gt;code_1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; list = Lists.newArrayList(
            &quot;bcd&quot;, &quot;cde&quot;, &quot;def&quot;, &quot;abc&quot;);
    List&amp;lt;String&amp;gt; result = list.stream()
            //.parallel()
            .filter(e -&amp;gt; e.length() &amp;gt;= 3)
            .map(e -&amp;gt; e.charAt(0))
            //.peek(System.out :: println)
            //.sorted()
            //.peek(e -&amp;gt; System.out.println(&quot;++++&quot; + e))
            .map(e -&amp;gt; String.valueOf(e))
            .collect(Collectors.toList());
    System.out.println(&quot;----------------------------&quot;);
    System.out.println(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;code_2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void targetMethod() {
    List&amp;lt;String&amp;gt; list = Lists.newArrayList(
            &quot;bcd&quot;, &quot;cde&quot;, &quot;def&quot;, &quot;abc&quot;);
    List&amp;lt;String&amp;gt; result = Lists.newArrayListWithCapacity(list.size());
    for (String str : list) {
        if (str.length() &amp;gt;= 3) {
            char e = str.charAt(0);
            String tempStr = String.valueOf(e);
            result.add(tempStr);
        }
    }
    System.out.println(&quot;----------------------------&quot;);
    System.out.println(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，在最终结果上而言，code_1与code_2是等价的。那么，Stream是怎么做的呢？显然不是每次操作都进行迭代，因为这对于执行时间与存储中间变量来说都将是噩梦。&lt;/p&gt;
&lt;h3 id=&quot;要解决的问题&quot;&gt;要解决的问题&lt;/h3&gt;
&lt;p&gt;显然，如果code_2只对集合迭代了一次，也就是说相当高效。那么这么做有没有弊端？有！模板代码、中间变量、不利于并行都是其存在的问题。但是按着code_2的思路可以知道&lt;strong&gt;有以下几个问题需要解决：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何记录每次操作？&lt;/li&gt;
&lt;li&gt;操作如何叠加？&lt;/li&gt;
&lt;li&gt;叠加后的操作如何执行？&lt;/li&gt;
&lt;li&gt;最后的结果如何存储？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;包结构分析&quot;&gt;包结构分析&lt;/h3&gt;
&lt;p&gt;那么Stream是如何解决的呢？所谓源码之下，无所遁形。那么，首先来看一下Stream包的结构（如图1-1所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173045560-391687911.png&quot; alt=&quot;图1-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-1 Stream包的结构示意图&lt;/p&gt;
&lt;p&gt;其中各个部分的主要功能为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主要是各种操作的工厂类、数据的存储结构以及收集器的工厂类等；&lt;/li&gt;
&lt;li&gt;主要用于Stream的惰性求值实现；&lt;/li&gt;
&lt;li&gt;Stream的并行计算框架；&lt;/li&gt;
&lt;li&gt;存储并行流的中间结果；&lt;/li&gt;
&lt;li&gt;终结操作的定义；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们单独把第二部分拎出来用于&lt;strong&gt;说明Stream的惰性求值实现&lt;/strong&gt;，如图1-2所示，Java8针对Int、long、double进行了优化，主要用于频繁的拆装箱。我们以引用类型进行介绍，在图中已经标为绿色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BaseStream规定了流的基本接口，比如iterator、spliterator、isParallel等；&lt;/li&gt;
&lt;li&gt;Stream中定义了map、filter、flatmap等用户关注的常用操作；&lt;/li&gt;
&lt;li&gt;PipelineHelper主要用于Stream执行过程中相关结构的构建；&lt;/li&gt;
&lt;li&gt;Head、StatelessOp、StatefulOp为ReferencePipeline中的内部类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173057638-812543936.png&quot; alt=&quot;图1-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-2&lt;/p&gt;
&lt;h3 id=&quot;操作如何记录&quot;&gt;&lt;span&gt;操作如何记录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关于操作如何记录，在JDK源码注释中多次用（操作）stage来标识用户的每一次操作，而通常情况下Stream的操作又需要一个回调函数，所以一个完整的操作是由数据来源、操作、回调函数组成的三元组来表示。而在具体实现中，使用实例化的ReferencePipeline来表示，即图1-2中的Head、StatelessOp、StatefulOp的实例。&lt;/p&gt;
&lt;p&gt;如code_3、code_4所示为调用stream.map()的关键的两个方法，在用户&lt;br/&gt;调用一系列操作后会形成如图1-3所示的双链表结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173110107-853854894.png&quot; alt=&quot;图1-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-3&lt;/p&gt;
&lt;p&gt;code_3(ReferencePipeline.map())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
@SuppressWarnings(&quot;unchecked&quot;)
public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super P_OUT, ? extends R&amp;gt; mapper) {
    Objects.requireNonNull(mapper);
    return new StatelessOp&amp;lt;P_OUT, R&amp;gt;(this, StreamShape.REFERENCE,
                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
        @Override
        Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
            return new Sink.ChainedReference&amp;lt;P_OUT, R&amp;gt;(sink) {
                @Override
                public void accept(P_OUT u) {
                    downstream.accept(mapper.apply(u));
                }
            };
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;code_4(AbstractPipeline.AbstractPipeline())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AbstractPipeline(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; previousStage, int opFlags) {
    if (previousStage.linkedOrConsumed)
        throw new IllegalStateException(MSG_STREAM_LINKED);
    previousStage.linkedOrConsumed = true;
    previousStage.nextStage = this;

    this.previousStage = previousStage;
    this.sourceOrOpFlags = opFlags &amp;amp; StreamOpFlag.OP_MASK;
    this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
    this.sourceStage = previousStage.sourceStage;
    if (opIsStateful())
        sourceStage.sourceAnyStateful = true;
    this.depth = previousStage.depth + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何叠加&quot;&gt;&lt;span&gt;如何叠加&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在上一步已经在stage中记录了每一步操作，此时并没有执行。但是stage只是保存了当前的操作，并不能确定下一个stage需要何种操作，何种数据，其实JDK为此定义了Sink接口，其中只有begin()、end()、cancellationRequested()、accept()四个接口（如表1-2所示，&lt;a href=&quot;http://www.cnblogs.com/CarpenterLee/p/6637118.html&quot;&gt;摘自这里&lt;/a&gt;），其中中间操作的子类中包含一个指向下游sink的指针。&lt;/p&gt;
&lt;p&gt;表1-2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173125435-248188539.png&quot; alt=&quot;表1-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在转向code_3，可以看出，在satge链中，每一步都包含了opWrapSink()。当调用终结操作时，将会触发code_5从最后一个stage（终结操作产生的satge）开始，递归产生图1-4所示的结构。&lt;/p&gt;
&lt;p&gt;code_5(AbstractPipeline.wrapSink())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
@SuppressWarnings(&quot;unchecked&quot;)
final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {
    Objects.requireNonNull(sink);

    for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {
        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
    }
    return (Sink&amp;lt;P_IN&amp;gt;) sink;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173139795-1933437050.png&quot; alt=&quot;图1-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-4&lt;/p&gt;
&lt;h3 id=&quot;如何执行&quot;&gt;&lt;span&gt;如何执行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;所有的操作已经形成了图1-4的结构，接下来就会触发code_6，此时结果就会产生对应的结果啦！&lt;/p&gt;
&lt;p&gt;code_6(AbstractPipelie.copyInto())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
    Objects.requireNonNull(wrappedSink);

    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
        wrappedSink.begin(spliterator.getExactSizeIfKnown());
        spliterator.forEachRemaining(wrappedSink);
        wrappedSink.end();
    }
    else {
        copyIntoWithCancel(wrappedSink, spliterator);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;并行原理&quot;&gt;并行原理&lt;/h2&gt;
&lt;p&gt;那么，Stream是如何并行执行的呢？其实产生stage链的过程和串行并没有区别，只是在最终执行时进行了相应的调整，我们将code_1改变为code_7&lt;/p&gt;
&lt;p&gt;code_7&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; list = Lists.newArrayList(
            &quot;bcd&quot;, &quot;cde&quot;, &quot;def&quot;, &quot;abc&quot;);
    List&amp;lt;String&amp;gt; result = list.stream()
            .parallel()
            .filter(e -&amp;gt; e.length() &amp;gt;= 3)
            //.map(e -&amp;gt; e.charAt(0))
            //.peek(System.out :: println)
            .sorted()
            //.peek(e -&amp;gt; System.out.println(&quot;++++&quot; + e))
            .map(e -&amp;gt; String.valueOf(e))
            .collect(Collectors.toList());
    System.out.println(&quot;----------------------------&quot;);
    System.out.println(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么最终产生的stage链与sink的结构如图1-5所示，因为此时stage链中有一个有状态操作（sorted()），也就是说在这里必须处理完所有元素才能进行下一步操作。那么此时无论是并行还是串行，此时都会产生两个sink链，也就是代表了两次迭代，才产生了最终结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173156529-1516176233.png&quot; alt=&quot;图1-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-5&lt;/p&gt;
&lt;p&gt;那么，究竟是如何并行的呢？其实当调用collect操作时会调用code_8，其中的evaluateParallel()如code_9所示。&lt;/p&gt;
&lt;p&gt;code_8(AbstractPipeline.evaluate())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
    assert getOutputShape() == terminalOp.inputShape();
    if (linkedOrConsumed)
        throw new IllegalStateException(MSG_STREAM_LINKED);
    linkedOrConsumed = true;

    return isParallel()
           ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
           : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;code_9(ReduceOp.evaluateParallel())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
    public &amp;lt;P_IN&amp;gt; R evaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,
                                     Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        return new ReduceTask&amp;lt;&amp;gt;(this, helper, spliterator).invoke().get();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实Stream的并行处理是基于ForkJoin框架的，相关类与接口的结构如图1-6所示。其中AbstractShortCircuitTask用于处理短路操作，其他相关操作类似，会产生对应的Task。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173209935-1093930872.png&quot; alt=&quot;图1-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-6&lt;/p&gt;
&lt;p&gt;关于code_8中获取源Spliterator，如code_10所示，&lt;/p&gt;
&lt;p&gt;code_10(AbstractPipeline.sourceSpliterator())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)
private Spliterator&amp;lt;?&amp;gt; sourceSpliterator(int terminalFlags) {
    Spliterator&amp;lt;?&amp;gt; spliterator = null;
    if (sourceStage.sourceSpliterator != null) {
        spliterator = sourceStage.sourceSpliterator;
        sourceStage.sourceSpliterator = null;
    }
    else if (sourceStage.sourceSupplier != null) {
        spliterator = (Spliterator&amp;lt;?&amp;gt;) sourceStage.sourceSupplier.get();
        sourceStage.sourceSupplier = null;
    }
    else {
        throw new IllegalStateException(MSG_CONSUMED);
    }

    if (isParallel() &amp;amp;&amp;amp; sourceStage.sourceAnyStateful) {
        //如果是并行流并且有stage包含stateful操作
        //那么就会依次遍历stage，直到遇到stateful stage时
        int depth = 1;
        for (@SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline u = sourceStage, p = sourceStage.nextStage, e = this;
             u != e;
             u = p, p = p.nextStage) {

            int thisOpFlags = p.sourceOrOpFlags;
            if (p.opIsStateful()) {
                depth = 0;

                if (StreamOpFlag.SHORT_CIRCUIT.isKnown(thisOpFlags)) {
                    //如果有短路操作，则去除相应标记
                    thisOpFlags = thisOpFlags &amp;amp; ~StreamOpFlag.IS_SHORT_CIRCUIT;
                }
                //尽量以惰性求值的方式进行操作
                spliterator = p.opEvaluateParallelLazy(u, spliterator);

                thisOpFlags = spliterator.hasCharacteristics(Spliterator.SIZED)
                        ? (thisOpFlags &amp;amp; ~StreamOpFlag.NOT_SIZED) | StreamOpFlag.IS_SIZED
                        : (thisOpFlags &amp;amp; ~StreamOpFlag.IS_SIZED) | StreamOpFlag.NOT_SIZED;
            }
            p.depth = depth++;
            p.combinedFlags = StreamOpFlag.combineOpFlags(thisOpFlags, u.combinedFlags);
        }
    }

    if (terminalFlags != 0)  {
        // Apply flags from the terminal operation to last pipeline stage
        combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);
    }

    return spliterator;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何并行执行&quot;&gt;&lt;span&gt;如何并行执行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关于各个task就行是如何并行执行，其实最终调用的是code_11所示，对应的流程如图1-7所示，其中交替fork子节点是为了缓和数据分片不均造成的性能退化。&lt;/p&gt;
&lt;p&gt;code_11(AbstractTask.compute())&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void compute() {
    Spliterator&amp;lt;P_IN&amp;gt; rs = spliterator, ls; // right, left spliterators
    long sizeEstimate = rs.estimateSize();
    long sizeThreshold = getTargetSize(sizeEstimate);
    boolean forkRight = false;
    @SuppressWarnings(&quot;unchecked&quot;) K task = (K) this;
    while (sizeEstimate &amp;gt; sizeThreshold &amp;amp;&amp;amp; (ls = rs.trySplit()) != null) {
        K leftChild, rightChild, taskToFork;
        task.leftChild  = leftChild = task.makeChild(ls);
        task.rightChild = rightChild = task.makeChild(rs);
        task.setPendingCount(1);
        if (forkRight) {
            forkRight = false;
            rs = ls;
            task = leftChild;
            taskToFork = rightChild;
        }
        else {
            forkRight = true;
            task = rightChild;
            taskToFork = leftChild;
        }
        taskToFork.fork();
        sizeEstimate = rs.estimateSize();
    }
    task.setLocalResult(task.doLeaf());
    task.tryComplete();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265052/201711/1265052-20171103173224029-964180427.png&quot; alt=&quot;图1-7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1-7&lt;/p&gt;
&lt;h2 id=&quot;影响并行流的因素&quot;&gt;影响并行流的因素&lt;/h2&gt;
&lt;p&gt;数据大小；源数据结构（分割越容易越好），arraylist、数组比较好，hashSet、treeSet次之，linked最差；装箱；核的数量（可使用）；单元处理开销（越大越好）&lt;/p&gt;
&lt;h2 id=&quot;建议&quot;&gt;建议：&lt;/h2&gt;
&lt;p&gt;终结操作以外的操作，尽量避免副作用，避免突变基于堆栈的引用，或者在执行过程中进行任何I/O；传递给流操作的数据源应该是互不干扰（避免修改数据源）。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要探究了Stream的实现原理，并没有涉及到具体的流操作的用法（读者可以参考《java8函数式编程》），并且给出了使用Stream的部分建议。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/CarpenterLee/p/6637118.html&quot;&gt;深入理解Java Stream流水线&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://colobu.com/2014/11/18/Java-8-Stream/&quot;&gt;Java 8 Stream探秘&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-java-streams-1-brian-goetz/index.html?ca=drs-&quot;&gt;java.util.stream 库简介&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Nov 2017 09:37:00 +0000</pubDate>
<dc:creator>Dorae</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dorae/p/7779246.html</dc:identifier>
</item>
</channel>
</rss>