<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Docker Swarm 中最重要的概念- 每天5分钟玩转 Docker 容器技术（94） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7845365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7845365.html</guid>
<description>&lt;p&gt;从主机的层面来看，Docker Swarm 管理的是 Docker Host 集群。所以先来讨论一个重要的概念 - 集群化（Clustering）。&lt;/p&gt;
&lt;p&gt;服务器集群由一组网络上相互连接的服务器组成，它们一起协同工作。一个集群和一堆服务器最显著的区别在于：&lt;/p&gt;
&lt;p&gt;集群能够像&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;strong&gt;单个&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;系统那样工作，同时提供高可用、负载均衡和并行处理。&lt;/p&gt;
&lt;p&gt;如果我们部署应用和服务时选择的是多个独立的服务器而非集群，资源的整体利用率则很难达到最优，因为我们无法提前知道如何分布这些应用才能达到资源利用的最大化。而且，应用使用资源的趋势是波动的，早上某些服务可能需要大量的内存，而下午使用量就降下来了。提前指定应用应该运行在哪个服务器上会丧失业务的弹性，当某个服务器宕机了，我们不得不手工将受影响的应用迁移到其他服务器上。&lt;/p&gt;
&lt;p&gt;实现集群化后我们的思维方式就必须改变了：不再考虑一个一个的服务器，而是将集群看做是一个整体。&lt;/p&gt;
&lt;p&gt;部署应用时，我们只考虑需要多少内存和 CPU，而不是考虑会使用那台服务器的内存和 CPU。我们不应该关心应用会被部署在哪里，我们关心的是运行这个应用需要哪些资源，然后将它部署到集群，集群管理程序（比如 Docker Swarm）会搞定这些细节。&lt;/p&gt;
&lt;p&gt;集群整体容量的调整是通过往集群中添加和删除主机节点实现的。但不管做怎样的操作，集群始终还是一个整体。&lt;/p&gt;
&lt;p&gt;本章，我们会创建 Docker Swarm 集群、部署应用、伸缩扩展应用，以及对应用执行滚动升级。&lt;/p&gt;
&lt;h3&gt;Docker Swarm Mode&lt;/h3&gt;
&lt;p&gt;Docker v1.12 是一个非常重要的版本，Docker 重新实现了集群的编排方式。在此之前，提供集群功能的 Docker Swarm 是一个单独的软件，而且依赖外部数据库（比如 Consul、etcd 或 Zookeeper）。&lt;/p&gt;
&lt;p&gt;从 v1.12 开始，Docker Swarm 的功能已经完全与 Docker Engine 集成，要管理集群，只需要启动 Swarm Mode。安装好 Docker，Swarm 就已经在那里了，服务发现也在那里了（不需要安装 Consul 等外部数据库）。&lt;/p&gt;
&lt;p&gt;相比 Kubernetes，用 Docker Swarm 创建集群非常简单，不需要额外安装任何软件，也不需要做任何额外的配置。很适合作为学习容器编排引擎的起点。&lt;/p&gt;
&lt;h3&gt;重要概念&lt;/h3&gt;
&lt;p&gt;在创建集群之前，先明确几个概念。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;swarm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;swarm 运行 Docker Engine 的多个主机组成的集群。&lt;/p&gt;
&lt;p&gt;从 v1.12 开始，集群管理和编排功能已经集成进 Docker Engine。当 Docker Engine 初始化了一个 swarm 或者加入到一个存在的 swarm 时，它就启动了 swarm mode。&lt;/p&gt;
&lt;p&gt;没启动 swarm mode 时，Docker 执行的是容器命令；运行 swarm mode 后，Docker 增加了编排 service 的能力。&lt;/p&gt;
&lt;p&gt;Docker 允许在同一个 Docker 主机上既运行 swarm service，又运行单独的容器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;node&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;swarm 中的每个 Docker Engine 都是一个 node，有两种类型的 node：&lt;strong&gt;manager&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;strong&gt;worker&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了向 swarm 中部署应用，我们需要在 manager node 上执行部署命令，manager node 会将部署任务拆解并分配给一个或多个 worker node 完成部署。&lt;/p&gt;
&lt;p&gt;manager node 负责执行编排和集群管理工作，保持并维护 swarm 处于期望的状态。swarm 中如果有多个 manager node，它们会自动协商并选举出一个 leader 执行编排任务。&lt;/p&gt;
&lt;p&gt;woker node 接受并执行由 manager node 派发的任务。默认配置下 manager node 同时也是一个 worker node，不过可以将其配置成 manager-only node，让其专职负责编排和集群管理工作。&lt;/p&gt;
&lt;p&gt;work node 会定期向 manager node 报告自己的状态和它正在执行的任务的状态，这样 manager 就可以维护整个集群的状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;service&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;service 定义了 worker node 上要执行的任务。swarm 的主要编排任务就是保证 service 处于期望的状态下。&lt;/p&gt;
&lt;p&gt;举一个 service 的例子：在 swarm 中启动一个 http 服务，使用的镜像是 httpd:latest，副本数为 3。&lt;/p&gt;
&lt;p&gt;manager node 负责创建这个 service，经过分析知道需要启动 3 个 httpd 容器，根据当前各 worker node 的状态将运行容器的任务分配下去，比如 worker1 上运行两个容器，worker2 上运行一个容器。&lt;/p&gt;
&lt;p&gt;运行了一段时间，worker2 突然宕机了，manager 监控到这个故障，于是立即在 worker3 上启动了一个新的 httpd 容器。&lt;/p&gt;
&lt;p&gt;这样就保证了 service 处于期望的三个副本状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下一节我们开始实践&lt;/span&gt; Docker Swarm。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 23:46:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7845365.html</dc:identifier>
</item>
<item>
<title>riot.js教程【四】Mixins、HTML内嵌表达式 - liulun</title>
<link>http://www.cnblogs.com/liulun/p/7831084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/7831084.html</guid>
<description>&lt;blockquote readability=&quot;0.35593220338983&quot;&gt;
&lt;p&gt;前文回顾&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7827072.html&quot;&gt;riot.js教程【三】访问DOM元素、使用jquery、mount输入参数、riotjs标签的生命周期；&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7681073.html&quot;&gt;riot.js教程【二】组件撰写准则、预处理器、标签样式和装配方法；&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7672876.html&quot;&gt;riot.js教程【一】简介；&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;共享mixins&quot;&gt;共享Mixins&lt;/h2&gt;
&lt;p&gt;混合开发可以使你很好的复用代码，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var OptsMixin = {
  // the `opts` argument is the option object received by the tag as well
  init: function(opts) {
    this.on('updated', function() { console.log('Updated!') })
  },

  getOpts: function() {
    return this.opts
  },

  setOpts: function(opts, update) {
    this.opts = opts
    if (!update) this.update()
    return this
  }
}

&amp;lt;my-tag&amp;gt;
  &amp;lt;h1&amp;gt;{ opts.title }&amp;lt;/h1&amp;gt;

  this.mixin(OptsMixin)
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个示例中，你给页面中所有的my-tag标签增加了两个实例方法&lt;/p&gt;
&lt;p&gt;getOpts和setOpts&lt;/p&gt;
&lt;p&gt;来看下面的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var my_tag_instance = riot.mount('my-tag')[0]

console.log(my_tag_instance.getOpts()) // will log out any opts that the tag has
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，init方法是一个特殊的方法，&lt;/p&gt;
&lt;p&gt;当一个riot标签加载一个mixin对象时，会执行init方法&lt;/p&gt;
&lt;p&gt;init方法不是标签的实例方法，它是不可访问的&lt;/p&gt;
&lt;p&gt;上面例子中，我们已经为my-tag设计了一个mixin对象OptsMixin，&lt;/p&gt;
&lt;p&gt;那么我们想为这个对象补充一个方法该如何做呢？如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function IdMixin() {
  this.getId = function() {
    return this._id
  }
}

var id_mixin_instance = new IdMixin()

&amp;lt;my-tag&amp;gt;
  &amp;lt;h1&amp;gt;{ opts.title }&amp;lt;/h1&amp;gt;

  this.mixin(OptsMixin, id_mixin_instance)
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以一个mixin对象可以是一个json对象，&lt;/p&gt;
&lt;p&gt;也可以是一个方法的实例&lt;/p&gt;
&lt;h2 id=&quot;全局的mixins&quot;&gt;全局的mixins&lt;/h2&gt;
&lt;p&gt;如果你需要为你所有的标签扩展方法&lt;/p&gt;
&lt;p&gt;你就可以使用全局mixins&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;riot.mixin(mixinObject)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与共享mixins不同，全局mixins会直接被所有的标签加载；&lt;/p&gt;
&lt;p&gt;要谨慎使用全局的mixins&lt;/p&gt;
&lt;h2 id=&quot;html内嵌表达式&quot;&gt;HTML内嵌表达式&lt;/h2&gt;
&lt;p&gt;可以在HTML内部嵌入用大括号包裹的JS表达式，&lt;/p&gt;
&lt;p&gt;大括号包裹的JS表达式既可以被用于文本标签，也可以被用于HTML属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h3 id={ /* attribute_expression */ }&amp;gt;
  { /* nested_expression */ }
&amp;lt;/h3&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面举几个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ title || 'Untitled' }
{ results ? 'ready' : 'loading' }
{ new Date() }
{ message.length &amp;gt; 140 &amp;amp;&amp;amp; 'Message is too long' }
{ Math.round(rating) }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使你的HTML标签保持clean&lt;/p&gt;
&lt;p&gt;建议原则是尽量使用简洁的JS表达式&lt;/p&gt;
&lt;p&gt;如果你的表达式演变的越来越复杂了&lt;/p&gt;
&lt;p&gt;那么考虑把表达式里的一些逻辑转义到update事件中去，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;my-tag&amp;gt;

  &amp;lt;!-- the `val` is calculated below .. --&amp;gt;
  &amp;lt;p&amp;gt;{ val }&amp;lt;/p&amp;gt;

  // ..on every update
  this.on('update', function() {
    this.val = some / complex * expression ^ here
  })
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML标签中，拥有布尔值的属性，比如checked, selected这类属性&lt;/p&gt;
&lt;p&gt;当表达式的值为false的时候，这些属性是不会添加到HTML标签中的&lt;/p&gt;
&lt;p&gt;下面两行代码是等价的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input checked={ null }&amp;gt;

&amp;lt;input&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;W3C规定，这类属性，就算你没给它设置值，只要他出现在HTML标签内，那么它就等价于给这类属性设置了true的值&lt;/p&gt;
&lt;p&gt;再来看下面这行代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p class={ foo: true, bar: 0, baz: new Date(), zorro: 'a value' }&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个标签的类名经过计算后是：foo baz zorro&lt;/p&gt;
&lt;p&gt;因为bar的值是0，0就是false，只有值是true的才会被应用到标签上&lt;/p&gt;
&lt;p&gt;这个特性不一定用于class，还可以用在别的地方&lt;/p&gt;
&lt;p&gt;你还可以直接这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;my-tag&amp;gt;
  &amp;lt;p class={ classes }&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;script&amp;gt;
    hasAnimation() {
      return true
    }

    this.randomNumber = 5

    this.classes = {
      foo: true,
      bar: false,
      number: '3 &amp;gt; randomNumber',
      animated: 'hasAnimation()', //注意：这里要写成字符串的形式
      baz: new Date(),
      zorro: 'a value'
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过计算后P的样式类有foo number animated baz zorro&lt;/p&gt;
&lt;p&gt;HTML标签的行内样式也可以写成类似这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;my-tag&amp;gt;
  &amp;lt;p style={ styles }&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;script&amp;gt;
    this.styles = {
      color: 'red',
      height: '10rem'
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;riotjs会自动把对象转换成描述样式的字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p style=&quot;color: red; height: 10rem&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何打印大括号到浏览器呢？可以用下面这种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;\\{ this is not evaluated \\} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你如果不喜欢用大括号来告诉riotjs哪行代码是你的表达式&lt;/p&gt;
&lt;p&gt;你可以通过配置改变这一点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;riot.settings.brackets = '${    }'
riot.settings.brackets = '\{\{    }}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，标注之间要用一个空格隔开&lt;/p&gt;
&lt;p&gt;riotjs的表达式，只能输出（渲染）纯文本的字符串值；&lt;/p&gt;
&lt;p&gt;不能输出（渲染）HTML的字符串值&lt;/p&gt;
&lt;p&gt;但是，你可以通过变通的方式完成这项工作，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;raw&amp;gt;
  &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;

  this.root.innerHTML = opts.content
&amp;lt;/raw&amp;gt;

&amp;lt;my-tag&amp;gt;
  &amp;lt;p&amp;gt;Here is some raw content: &amp;lt;raw content=&quot;{ html }&quot;/&amp;gt; &amp;lt;/p&amp;gt;

  this.html = 'Hello, &amp;lt;strong&amp;gt;world!&amp;lt;/strong&amp;gt;'
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这样做很容易受到跨站脚本攻击，千万不要加载不受你控制的数据；&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 23:29:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/7831084.html</dc:identifier>
</item>
<item>
<title>逆向实战第一讲,寻找OllyDbg调试工具的Bug并修复 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7848437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7848437.html</guid>
<description>&lt;p&gt;首先我们要知道这个OD的Bug是什么. 我们调试一个UNICODE的窗口,看下其窗口过程.&lt;/p&gt;
&lt;h2&gt;一丶查看OllyDbg 的Bug&lt;/h2&gt;
&lt;h3&gt;1.1spy++查看窗口,确定是一个Unicode窗口&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117010121265-626693024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.使用Olly附加&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117010428562-1871652330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Od附加之后,点击窗口,发现获取的值是错误的.所以判断Od的Bug是针对Unicode窗口,调用了Asi版本的API&lt;/p&gt;
&lt;h3&gt;3.解决思路&lt;/h3&gt;
&lt;p&gt;此时我们解决的时候,要Od调Od了. 而出现这个Bug的原因可能是API调用失败,我们发现,它在调用获得类的回调的时候出现错误&lt;/p&gt;
&lt;p&gt;所以可以快速定位这个API&lt;/p&gt;
&lt;p&gt;GetClassLongA&lt;/p&gt;
&lt;p&gt;GetClassLongW&lt;/p&gt;
&lt;h3&gt;4.定位此位置发先是否是调用错误&lt;/h3&gt;
&lt;p&gt;此时我们Od调OD,然后定位此API下断点,看看是否调用错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117011248296-1134961464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发先确实是调用A版本的.所以出现错误.&lt;/p&gt;
&lt;h2&gt;二丶解决OD Bug的两种方式&lt;/h2&gt;
&lt;h3&gt;1.1 API HOOK的方式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117011410796-2090378352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们执行到返回,在次API上面我们下HOOK 钩子,跳转到我们的代码执行,然后判断其是否是Unicode窗口还是 Asi窗口,根据不同我们调用不同的函数返回即可.&lt;/p&gt;
&lt;p&gt;此方法虽然可以解决但是有点麻烦.所以不采用&lt;/p&gt;
&lt;h3&gt;1.2 Dll劫持的方式&lt;/h3&gt;
&lt;p&gt;这个方法可以有效的劫持DLL,然后执行我们的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117012006140-201299901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以劫持一下这个DLL&lt;/p&gt;
&lt;p&gt;首先我们找到我们的劫持工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117012111109-1163401537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117012206906-1103587245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择它的DLL,然后选择转发函数,而后会生成一个CPP,此时我们只需要写一个DLL,这个DLL的CPP就是这个,和原DLL名字一样&lt;/p&gt;
&lt;p&gt;原DLL名字改为  DBGHELPOrg即可.&lt;/p&gt;
&lt;p&gt;在代码里面写入我们的代码&lt;/p&gt;
&lt;p&gt;1.首先在我们的转发里面定义函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117013623327-1600239125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面写上我们的代码&lt;/p&gt;
&lt;p&gt;2. 在程序加载的时候,启动我们的代码&lt;/p&gt;
&lt;p&gt;这里的启动会在load里面启动,所以在load里面写代码就可以了.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;

&lt;p&gt;思路:&lt;br/&gt;定位Call调用GetClasslongA的地方,跟进去之后会看到转发的IAT表,把里面的内容改为我们的就可以了.&lt;/p&gt;
&lt;p&gt;我们刚才已经定位到了调用GetClassLongA的地方,那么此时我们 F7 进去可以看到转发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117013947937-1701372257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到IAT表格的位置是 0050D858 ,那么把里面的地址改为我们的地址就可以了&lt;/p&gt;
&lt;p&gt;步骤:&lt;/p&gt;
&lt;p&gt;　　1.定义一个指针指向IAT表格&lt;/p&gt;
&lt;p&gt;　　2.修改内存保护属性&lt;/p&gt;
&lt;p&gt;　　3.把IAT表格里面的内容变成我们的函数地址&lt;/p&gt;
&lt;p&gt;　　4.还原内存保护属性.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117014614359-2030666610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要是中间一不,修改IAT表中的地址为我们的地址&lt;/p&gt;
&lt;p&gt;现在我们试一试看看是否成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117015002249-1914522109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功获取.&lt;/p&gt;

&lt;h3&gt;2.插件修改&lt;/h3&gt;
&lt;p&gt;对于上面来说有点基础的,细心的应该可以明白,做了这一切其实简单的就是&lt;/p&gt;
&lt;p&gt;1. 寻找API位置&lt;/p&gt;
&lt;p&gt;2. 跳转的地方下改为我们的函数地址&lt;/p&gt;
&lt;p&gt;3.我们的函数地址判断执行.&lt;/p&gt;
&lt;p&gt;但是上面说起来还是比较麻烦,我们自己写一个OllyDbg的插件解决这个Bug吧.&lt;/p&gt;
&lt;p&gt;首先使我们的插件,&lt;/p&gt;
&lt;p&gt;开发插件所必须有的2个导出函数&lt;/p&gt;
&lt;p&gt;ODBG_Plugindata　　　　这个函数里面是给插件名称的所以我们需要&lt;/p&gt;
&lt;p&gt;ODBG_Plugininit　　　　   这个函数是Od启动的时候调用的.(初始化数据)&lt;/p&gt;
&lt;p&gt;当然肯定会有释放的,这里不写了.&lt;/p&gt;
&lt;p&gt;写插件第一步&lt;/p&gt;
&lt;p&gt;　　建立一个DLL 工程,添加插件自带的头文件&lt;/p&gt;
&lt;p&gt;第二步,实现插件的接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117021649624-1679133517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步,拷贝我们以前的代码让插件初始化的时候去工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117021734187-828256795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;遇到的问题:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117021359156-1218071544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果提示这个问题,那么编译选项中,链接的时候假如这个 /j即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117021510031-342078767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 启动OD看看插件是否加载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171117022055484-205315929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常加载没有问题&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 18:22:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7848437.html</dc:identifier>
</item>
<item>
<title>TFS在项目中DevOps落地进程（下） - LeoLaw</title>
<link>http://www.cnblogs.com/leolaw/p/7847062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolaw/p/7847062.html</guid>
<description>&lt;p&gt;紧接上篇 &lt;a href=&quot;http://www.cnblogs.com/leolaw/p/7821335.html&quot; target=&quot;_blank&quot;&gt;TFS在项目中Devops落地进程（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再接着说TFS相关之前先插入一个番外篇，虽然跟TFS关系不大但跟DevOps关系很大，觉得有必要在此乱入一下。&lt;/p&gt;
&lt;h2&gt;番外篇--监控之Application Insights&lt;/h2&gt;
&lt;p&gt;我们之前并没有任何监控类产品（我指的是应用程序级别的），发生任何异常都是往数据库的表里insert个错误日志，all系统共用同一张错误表。&lt;/p&gt;
&lt;p&gt;这其实意味着我们当时的系统是：&lt;strong&gt;系统异常基本不关注（线上数据库开发肯定没法查对吧），关注的时候肯定都出事了&lt;/strong&gt;，对自己负责的系统的运行状态基本不了解，什么性能之类东西纯粹靠猜。&lt;/p&gt;
&lt;p&gt;然后我就希望我们能有办法获取到我们系统的各种状态，而此时在VS2015的时候整合在VS里的application insights引起了我的关注。&lt;/p&gt;
&lt;p&gt;简要介绍下application insights,是微软基于azure所推出的一款SAAS性质的APM(Application Performance Management,应用程序性能管理)服务，本人不会详细介绍这个，详情可参阅&lt;a href=&quot;https://azure.microsoft.com/zh-cn/services/application-insights/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后也感谢我大学年代曾经当过MSP（微软校园菁英）并透过这个拿到过Visual Studio Enterprise的订阅，然后里面附赠的每个月150美元额度的Azure费用，让我有条件可以先试用Application Insights。&lt;/p&gt;
&lt;p&gt;然后自己将自己负责的站点搭上Insights做了个小Demo展示了给老大看，然后老大也对此表示满意。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230718921-2106972961.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230719437-1361165305.png&quot; alt=&quot;image&quot; width=&quot;457&quot; height=&quot;445&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;(Application Insights的概览图)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在后续的一次PMO会上我将此拿出来进行了演示，也获得了CTO的认可和支持，然后终于可以将Application Insights投入到线上使用（当然此时用的是公司正式的账号而不是我那个150刀每月的测试号了）。&lt;/p&gt;
&lt;p&gt;但是有Insights投入初期其他小伙伴热情度并不高，大家还是觉得记数据库挺好的，直到后面发生了一件事…&lt;/p&gt;
&lt;p&gt;事情是这样的，那是一个要常规发布的夜晚，因为并没有数据库相关的修改，所以DBA已经下班了（要加班到夜里发布，DBA只是正常下班），然后某站点发布上去的时候报错了，然后对应的开发小伙伴不知道为什么，就知道出异常了。&lt;/p&gt;
&lt;p&gt;然后此时DBA不在，无法查线上数据库，然后就干着急，最后通过在代码里让异常本地写txt临时解决了发布上的问题，但这个问题完整暴露出记录数据库的不靠谱：万一DBA不在呢？毕竟如果没数据库内容的话总把DBA留下来的话其实也不合理，我们应该要从更长远和更科学的方案解决这个问题。&lt;/p&gt;
&lt;p&gt;至此后续我们所有项目加入Insights的进程就加快了，因为Insights里我们可以自主的查看到性能/请求/异常等各种数据了。&lt;/p&gt;
&lt;p&gt;另外有了Insights后我们开发自己第一次有了自己的程序运行数据，有时候我们也会针对Insights里的数据做一些对应的优化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230719921-607689985.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230720406-561131836.png&quot; alt=&quot;image&quot; width=&quot;648&quot; height=&quot;313&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图，这是一个通过城市Id获取城市名称的接口，原先调用量巨大（当时设置了50%采样率，所以实际调用量要比图中翻一倍）但是其实这个接口返回的内容可变性不高，然后让前端加了缓存后从原来至少10K以上每小时调用量下降到现在100多的调用量，而这些都是因为我们有了Insights之后才能进行的。&lt;/p&gt;
&lt;p&gt;所以说：&lt;strong&gt;优化不能靠猜，我们要用数据说话。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而Insights的Analysis功能/智能预警功能等特性也在实际中帮我们解决了不少问题。&lt;/p&gt;
&lt;p&gt;然后Insights也是可以跟TFS进行一定程度的整合的，其中主要包括自动发布的时候打上注解和在TFS的面板里查看Insights的信息&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230720921-531263069.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230721546-89277069.png&quot; alt=&quot;image&quot; width=&quot;586&quot; height=&quot;368&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;版本注解，有了这个我们可以从监控系统里知道什么时候上了预发布环境&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230721827-739512646.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230722249-834399410.png&quot; alt=&quot;image&quot; width=&quot;466&quot; height=&quot;160&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;可添加在TFS上的widget(新版本的，详情可参看&lt;/span&gt;&lt;/em&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/blog/vstsdashboardchartwidget/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;span&gt;Application Insights: VSTS dashboard chart widget now available&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;em&gt;&lt;span&gt;)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然后最近Insights里还有各种Preview的功能，比如新的Preview性能面板里能查看到95线/99线等，新的异常面板里还能给你分析出你异常的共同点之类的，Insights也一直在进步着。&lt;/p&gt;
&lt;p&gt;在定型监控系统的时候我们曾经议论过听云和是否自建服务端（当时确定了监控的SDK都是用Insights的，但是纠结于是否基于ELK自建服务端）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听云：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老实说从默认的图表来说，听云比Insights的图表更全面，但听云缺乏一个Insights里有的一个很重要功能，查询分析Analysis：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230722827-56581608.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723359-1979679627.png&quot; alt=&quot;image&quot; width=&quot;652&quot; height=&quot;366&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在Insights的Analysis里，可以通过一个长的很像Sql的一种语句，可以快速查询你想要的任何原始数据（精确到每一条）,此语句也能绘制图表，这个绝对是对程序员Friendly的一个功能&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;比方说出了异常，可能从运维层面更关注异常的趋势，而开发层面更关注的是具体的每一个异常，和每一个异常对应的每一个请求等，另外听云因为是服务器层面的监控无法在代码层面埋点，我们Insights里则埋了如果异常的话将错误请求的Body记录到Insights的Traces里，这样就算是Post/Put之类的请求报错我们也能拿到原始请求报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自建服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这个我觉得在我们现在连Redis啊队列啊这些更紧急的东西都没有落实的情况下在分出人力去搞这个，就担心做出来后就是个永恒的1.0版本，觉得类似这种东西除非说有专职负责这个的人/团队不然不应该自建，再说那个时候我们组已经用Insights好一段时间了（有接近1年了吧）习惯了上面各种高级特性，而原始版的ELK则呵呵哒（一个自个买的原始毛胚房VS一个租来的豪华精装房），当然如果有专职人员专门投入到上面基于ELK做定制开发我相信也肯定能做的跟Insights那样或者比Insights更好，但是，我们有更多更紧急的事不是么？&lt;/p&gt;
&lt;p&gt;不过倒是有一点是因为费用问题我们的Insights是使用了采样率的（就是说并不是收集全部而是部分收集），但是我们希望异常不要被采样，所以后面可能要基于ELK搞个Exceptionless来专门记录异常。&lt;/p&gt;

&lt;p&gt;另外Insights跟VS的整合也是棒棒哒，比如下面这样，直接告诉我哪个方法发生了异常，直接反映在CodeLens里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723640-452127040.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723968-1202539132.png&quot; alt=&quot;image&quot; width=&quot;592&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;第4篇--自行管理BuildAgent&lt;/h2&gt;
&lt;p&gt;原先整个TFS服务器的搭建和维护都在运维那边，那为什么要拿出这个来说呢？&lt;/p&gt;
&lt;p&gt;首先我们现在正处于一个快速发展的年代，什么框架啊每月总能冒出几个，技术各种日新月异，虽然绝大多数企业本着稳定至上的原则不会说总是用最新，但这不是固步自封，不思进取的借口，&lt;strong&gt;在一个“最新”变为”稳定“之后总要试着跳出舒适区步入现代化进程吧？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我们遇到的第一件事就是.Net版本升级,我们计划升级到.Net 4.6.2（原来是4.0到4.5.1不等），然后因为自动打包的原因所以要求Build Agent也要升级，然后原先运维部署配置的TFS是服务器+Build Agent放在同一个机器上的，搭载的是VS2015.&lt;/p&gt;
&lt;p&gt;然后除了4.6.2之外的话我们有个别类库项目使用上了.Net Core里全新的xproj格式来进行多target framework的开发，这也要求服务器上要有.Net Core的Sdk。&lt;/p&gt;
&lt;p&gt;在另外此时在讨论到代码质量审核，然后我们初定使用Sonarqube，而这个也要求Build Agent服务器要有Java的功能。&lt;/p&gt;
&lt;p&gt;基于上述原因外加后面我们技术部某神秘人物毛哥批了一批（2台）服务器（也就一般工作电脑）资源给我，后面还有CTO批了一台大服务器（真·服务器，当时可是嘻嘻哒的内心&lt;img class=&quot;wlEmoticon wlEmoticon-openmouthedsmile&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724265-1538565385.png&quot; alt=&quot;Open-mouthed smile&quot;/&gt;），然后我开始自己搭建Build Agent。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724562-1568226300.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724906-1414605862.png&quot; alt=&quot;image&quot; width=&quot;684&quot; height=&quot;234&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;当前我们组自行维护的4台Build Agent，承载了包括持续集成，自动打包，代码分析，自动测试等一系列任务&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230725624-396322728.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230726124-1428178777.png&quot; alt=&quot;image&quot; width=&quot;631&quot; height=&quot;380&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;装上了一堆现在要用或将来希望想用的功能，满足当前及其可预见的一段时间内的需求&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其实关于Build Agent主要觉得这个必须要能适应开发组的步伐，首先我们.Net 4.5-&amp;gt;.Net 4.6.2的时候，要求Build Agent要支持.Net 4.6.2或以上，之后我们有计划要上.Net Core（此时已经有基于.Net Core项目的Dll包了），而且之后.Net Core还有2.0版本（主要是NetStandard 2.0），所以我觉得这个Build Agent在我们组内的话我们能更好适配我们的前进步伐。&lt;/p&gt;
&lt;p&gt;现在我们的Build Agent里装的是Vs2017 17.3 + .Net 4.7 + .Net Core 2.0 + Docker 17.03.2-ee + CMake 3.9.1 + Python 3.6.2(x64) + JMeter 3.0 + F# 4.1 + Node.js 8.4(x64) + Java 1.8&lt;/p&gt;
&lt;p&gt;估计小半年内基本都能满足需求。&lt;/p&gt;

&lt;h2&gt;第5篇--自动代码质量检查&lt;/h2&gt;
&lt;p&gt;接着上篇说，我们有了自己的Build Agent，然后自动发布之类的基础功能也有了，于是我们就有更高层次的自动化追求了。&lt;/p&gt;
&lt;p&gt;首先就是自动化代码质量检查，在此先声明一点：&lt;strong&gt;任何自动化代码质量检查工具都不能代替人肉的Code Review，但能减少人肉Code Review的工作量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后在选型上我们选了Sonarqube，当然你们会问为什么选Sonarqube，说来惭愧其实我之前并不了解相关产品，然后在TFS商店里看到了这货然后才知道还能自动化代码检查…然后就去研究这货，发觉总体还可以（规则之类的啊，还有跨平台等），在跟我们技术部神秘人物毛哥上报下技术选型获得认证后就拍板开始干。&lt;/p&gt;
&lt;p&gt;通过自己手头有的服务器资源，搭建了个Sonarqube服务器，然后通过TFS的任务加上去&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230726515-1331298563.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230727015-1871075295.png&quot; alt=&quot;image&quot; width=&quot;514&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;一个带Sonarqube分析的编译过程，作为C#程序员看上去好像一个using的结构（开始-&amp;gt;释放)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230727624-2070712436.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230728171-432310209.png&quot; alt=&quot;image&quot; width=&quot;713&quot; height=&quot;347&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;某项目分析结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;好，然后代码分析质量有了，大家就能照着上面去“优化”代码了。&lt;/p&gt;
&lt;p&gt;慢着，我写了一段代码，因为水平问题我也不知道有没有咖喱，然后一提交，然后上面就留下了一个永恒的污点（有历史记录的），这样肯定很不爽，所以后面我们就纠结有没办法能够让代码在进入到Sonarqube系统之前先有个反馈。&lt;/p&gt;
&lt;p&gt;然后此时微软就发布了TFS2017，具体参考 &lt;a href=&quot;https://www.visualstudio.com/zh-cn/news/releasenotes/tfs2017-relnotes&quot; target=&quot;_blank&quot;&gt;TFS2017RTM Release Note&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中它引入了这么一个功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230728827-494870580.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230729421-200252370.png&quot; alt=&quot;image&quot; width=&quot;773&quot; height=&quot;395&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在拉取请求的时候显示Sonarqube的分析结果（直接定位到你代码上），且该分析结果不记录到Sonarqube服务器里&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;接着怂恿下老大出面让运维那边帮忙升个级。&lt;/p&gt;
&lt;p&gt;然后为了配合Sonarqube，那么每个项目在Pull Request的时候都要进行编译的过程（编译了Sonarqube才能分析），因此也顺带加上了阻止合并不能编译的代码这个额外附加项。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230729952-1936059889.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730124-726421654.png&quot; alt=&quot;image&quot; width=&quot;337&quot; height=&quot;189&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;同意一次Pull Request需要一个非本人外的其他人同意且要编译成功&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后审核人也能看到Sonarqube分析的结果就不用每行仔细看也能大概知道个所以然。&lt;/p&gt;
&lt;p&gt;当然实践过程中，看别人的代码发现不少什么超过3重if嵌套啊，类超过1000行啊这些，他们总说由于某些原因实在不好改的，那就只能忍了（你能怎么办呢，特别是多重if的往往都是各种业务条件判断复杂，然后自己也没空深入去看他们的业务），但自己项目要求要严格点，要严格控制不能出现任何形式的咖喱。&lt;/p&gt;
&lt;p&gt;另外在此吐槽一点：&lt;em&gt;TFS不能直接在Dashboard里浏览Sonarqube的结果，要看Sonarqube结果还要跳到Soanrqube里去，这不符合All in one的TFS理念啊，就没人想过弄个Widget什么的来解决解决这个问题？&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;第6章--自动测试&lt;/h2&gt;
&lt;p&gt;自动测试在这里想主要分2块来说，单元测试和集成测试。&lt;/p&gt;
&lt;p&gt;首先我觉得对于这2个概念尽管有很官方的说明但实践中很多人都有自己的理解，我简单说下我自己对上述2个词的理解和定义&lt;/p&gt;
&lt;p&gt;单元测试：在代码内部进行的不依赖外部环境（网络/数据库等）进行的对某个方法级的测试，特点是只能测试一小块逻辑,能模拟数据且运行较快（毫秒级），代码执行结果可预测。&lt;/p&gt;
&lt;p&gt;集成测试：可能是代码也可能是脚本依赖外部环境（网络/数据库等）进行的针对某个流程上的测试，特点是要造数据且运行较慢（至少是秒级），代码执行结果绝大多数情况下可预测（受外部因素影响不能100%可控）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单元测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要让代码可以被单元测试，首先代码先要是可测试的，要如何做到代码可测试呢？答案很简单，随便街上抓一个伪计算机专业的都能给出你正确答案：解耦。&lt;/p&gt;
&lt;p&gt;但是你要真的落实“解耦”到你的代码里，又往往是一个异常艰巨的任务（Talk is cheat, show me the code)。&lt;/p&gt;
&lt;p&gt;首先在我自己负责的项目里，完全使用依赖注入的形式重构了，另外抽象出了各种各样的接口，理论上要做到所有的”Service“都是可以”被替换”的。&lt;/p&gt;
&lt;p&gt;严格限制对static和new这2个关键字的使用（绝大多数情况下static或者new都意味着不可测试，当然static一个数据无关的方法比如Math.Min之类的或者new一个纯数据类这些例外）&lt;/p&gt;
&lt;p&gt;在自己一番折腾下，现在自己负责的项目单元测试覆盖率70%+，也算是一个自己比较满意的数字了（这个是Resharper收集的，它将单元测试项目本身也包含进去了的）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730437-2080294727.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730718-1669917387.png&quot; alt=&quot;image&quot; width=&quot;624&quot; height=&quot;123&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在单元测试的加持下，自己想重构代码什么的都能放开手去重构，有没有影响老逻辑？测试跑一下就知道了。&lt;/p&gt;
&lt;p&gt;而加新逻辑的时候也能知道会对原有流程造成怎么样的影响。&lt;/p&gt;
&lt;p&gt;总之有单元测试后，你会对你的代码更加倍有信心。关于单元测试看看日后是否专门开一篇文章来说说，里面也有大学问。&lt;/p&gt;
&lt;p&gt;上面说了那么多单元测试，那么它跟TFS有啥关系呢？测试写完了是吧？你怎么能确保它一定是有在跑呢？这时就可以将单元测试的运行整合在自动编译的流程里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731031-1300186720.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731359-1118110124.png&quot; alt=&quot;image&quot; width=&quot;687&quot; height=&quot;280&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;整合到编译流程里的单元测试，每次跑完后会报告结果，如果单元测试失败那么会阻止pull request&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731624-1763890394.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731921-1255536173.png&quot; alt=&quot;image&quot; width=&quot;489&quot; height=&quot;228&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在TFS主页的Dashboard里展示单元测试结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集成测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的集成测试现在主要是QA那边负责，QA那边有基于Jmeter来进行的测试，具体细节因为不是我负责所以我不是特别清楚，但是在Build Agent里装好Jmeter后（QA配置好了各种他们要的插件的版本）然后在自动发布的时候运行下就好了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732281-572402579.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732577-299425818.png&quot; alt=&quot;image&quot; width=&quot;526&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;运行QA他们指定的Jmeter，先从一个位置拷贝配置文件过来然后运行命令行，没错，从TFS角度去理解的话它只是去执行个命令行而已&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不过当前QA他们弄的Jmeter是运行后发一个结果邮件，如果能够将Jmeter的测试结果转变为TFS可接收的某种测试结果格式（什么JUnit或者Xunit之类的测试结果）展示到TFS上那就更好了（如果有会的人请赐教）&lt;/p&gt;
&lt;p&gt;在集成测试方面我自己也有一套基于代码的（当然现在主流都是基于脚本了）&lt;/p&gt;
&lt;p&gt;基于Specflow+xunit的方式我自己做了几个我旗下项目主流程的测试用例（就是那种一出问题QA就邮件出来：”测试环境挂拉“的那种）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732874-855166059.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733187-1108388083.png&quot; alt=&quot;image&quot; width=&quot;425&quot; height=&quot;297&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;基于Specflow的BDD形式的描述文档，尽可能弄的贴近业务层面&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733468-2093920120.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733827-593255059.png&quot; alt=&quot;image&quot; width=&quot;388&quot; height=&quot;353&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;描述文档背后对应的是若干代码&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734077-999020571.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734421-178698240.png&quot; alt=&quot;image&quot; width=&quot;418&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;目前我自己这套集成测试仅放在Demo环境（第一个测试环境）使用，主要是一旦发觉个风吹草动，立马还原代码…(逃…&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;关于集成测试按道理此处应有以Selenium为代表的UI自动化测试，不过我自己主要负责的是接口，然后让折腾UI的那位同事目前也只是处于演示级阶段还没正式投入使用，此处就不献丑了。&lt;/p&gt;
&lt;p&gt;当然TFS上还有管理手工测试等各种功能，不过由于QA组是基于Jira来管理任务所以并没使用。&lt;/p&gt;

&lt;h2&gt;第7章--引入NetCore的打包&lt;/h2&gt;
&lt;p&gt;尽管我们当前在经过一番折腾后全组项目目前已经统一到.Net 4.6.2，但短时间内也不会用上NetCore，但背后一直为了NetCore的迁移在默默准备着。&lt;/p&gt;
&lt;p&gt;主要是考虑到在NetCore 2.0后出了个NetStandard2.0，它跟NetCore 2.0以及.Net Framework 4.6.1是兼容的。&lt;/p&gt;
&lt;p&gt;那么我们现在项目代码的目标都是兼容Netstandard2.0（底层类库)，但之后真要迁移的时候就改个TargetFramework以及表现层稍微改下就好了（嗯，很丰满的理想）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说这篇呢主要是分享一个，我们现在TFS是2017Update2，在这个版本下你用常规方法是无法引用任何Netstandard2.0的包的（不信你们试试）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其本质是因为TFS2017Update2自带的Nuget还原工具是4.0版，而4.0是不支持NetStandard2.0，要4.3才可以，那难道我们在现有的TFS下（2018又没Release）就拿NetStandard没辙了？&lt;/p&gt;
&lt;p&gt;然后就找到了这篇文章&lt;a href=&quot;https://blogs.msdn.microsoft.com/devops/2017/09/29/using-the-latest-nuget-in-your-build/&quot; target=&quot;_blank&quot;&gt;Using the latest NuGet in your build&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章指引下，将它 &lt;a href=&quot;https://github.com/keithrob/tools/blob/master/vstsfetchnuget-min.ps1&quot; target=&quot;_blank&quot;&gt;那堆Powershell脚本&lt;/a&gt; 粘贴上去执行,下面参数写个4.3.0&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734749-1556676043.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734999-1764488419.png&quot; alt=&quot;image&quot; width=&quot;610&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后使用自定义的nuget&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230735609-1634736384.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230736124-208173853.png&quot; alt=&quot;image&quot; width=&quot;610&quot; height=&quot;289&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后就迎来了胜利的曙光&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230736546-1768023670.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230737109-603471690.png&quot; alt=&quot;image&quot; width=&quot;613&quot; height=&quot;286&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;第8章--我们基于TFS的小折腾&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任务管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然我司一直是基于Jira做任务管理的，不过因为Jira并不能直接跟TFS上的代码进行关联，所以我私自上是喜欢在TFS里建对应任务然后关联上去&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230737593-356761878.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230738202-476105337.png&quot; alt=&quot;image&quot; width=&quot;402&quot; height=&quot;246&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还能跟代码里结合起来&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230738781-1984439649.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230739390-619303554.png&quot; alt=&quot;image&quot; width=&quot;382&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在TFS里也能做可视化的关联查询&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230739890-318470525.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740124-2123804809.png&quot; alt=&quot;image&quot; width=&quot;380&quot; height=&quot;338&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动备份分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是最近折腾出来的小玩意&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740531-2000670103.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740859-386094877.png&quot; alt=&quot;image&quot; width=&quot;488&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Release里加上这个步骤（这是个插件提供的，&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=jabbera.git-tag-on-release-task&quot; target=&quot;_blank&quot;&gt;插件详情请点此处&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;然后在执行到对应发布步骤的时候就会自动将当前发布的代码拉一个分支出来，全自动的哟。&lt;/p&gt;

&lt;h2&gt;第9章—VNext&lt;/h2&gt;
&lt;p&gt;上面的大概就是我们现在折腾TFS的成果，但我们的道路远没结束，或者说，现在又处在某种程度上的开始。&lt;/p&gt;
&lt;p&gt;首先，Docker这个大趋势肯定之后或多或少都要涉足进去的（不过觉得先将诸如服务发现之类的前置条件先搞定在做这个）&lt;/p&gt;
&lt;p&gt;还有撇了下隔壁TFS2018的Release Note,这回引入了Wiki功能，回头可能可以直接在TFS上直接写上各种知识库文章了&lt;/p&gt;
&lt;p&gt;还有想整个OWASP ZAP然后跟TFS流程整合下来个自动渗透测试分析什么的，让我们自动化更上一层楼(if有空弄的话)。&lt;/p&gt;
&lt;p&gt;大概就是扯那么多了。&lt;/p&gt;
&lt;p&gt;The End。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 15:08:00 +0000</pubDate>
<dc:creator>LeoLaw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolaw/p/7847062.html</dc:identifier>
</item>
<item>
<title>Celery 源码解析五： 远程控制管理 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/remote-control-manager.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/remote-control-manager.html</guid>
<description>&lt;p&gt;今天要聊的话题可能被大家关注得不过，但是对于 Celery 来说确实很有用的功能，曾经我在工作中遇到这类情况，就是我们将所有的任务都放在同一个队列里面，然后有一天突然某个同学的代码写得不对，导致大量的耗时任务被同时塞进了消息队列里面，这就悲剧了，这直接导致了其他服务长时间不可用，例如发送登录短信验证码无法使用了，还有支付信息无法同步了等等，反正就是造成了一些不小的影响。&lt;/p&gt;
&lt;p&gt;当时我们的处理方式就很被动，只能手动连接上 MQ，然后把消息卸掉，其实也就手动将这些消息抛弃掉，从而让其他业务的消息可能正常运行。但是，这种方式也只适合当初作为少量流量的情况，对于搭建了大集群和大量任务的消息队列来说，这种方式是不可想象的，这么做是要死人的，不仅仅是被累垮，上头的口水都能把你淹了。所以，这个时候，我需要介绍一个 Celery 不太常被人使用的功能——远程控制。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;远程控制功能&lt;/h3&gt;
&lt;p&gt;其实 Celery 很早之前就存在控制命令，例如可以使用 Python shell 的 shell 命令，可以查看任务状态的 status 命令等等，但是这些命令都是本地的，不能让人觉得有意思，但是，这里有两个系列的命令很厉害，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inspect：主要用于查看 Celery 状态信息&lt;/li&gt;
&lt;li&gt;control：主要用于设置 Celery 状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，我在机器 A 运行着一个 Celery，机器 B 也运行着一个 Celery，机器 C &lt;strong&gt;没有运行&lt;/strong&gt; Celery，但是我可以在机器 C 上查询机器 A 或者机器 B 上的任务状态，甚至可以删除和停止任务，这些都是很简单可以实现的，但是本文不是讲解这些功能的文章，而是解析这些功能的文章，所以有兴趣的同学可以参考这份&lt;a href=&quot;http://docs.celeryproject.org/en/latest/userguide/monitoring.html#management-command-line-utilities-inspect-control&quot;&gt;官方文档&lt;/a&gt;继续了解。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;远程控制功能组件&lt;/h3&gt;
&lt;p&gt;要实现远程控制功能，我们需要从宏观上先看看 Celery 的设计思路，在 Celery 中，采用的是分布式的管理方式，其实没有太大秘密，就是每个节点之间都是通过广播/单播进行通信，从而达到协同效果，但是这过程还是有很多不好之处的，值得我们来思考一番。&lt;/p&gt;
&lt;p&gt;Celery 每个运行的实例都维护着一个 Control Node，其实就是一个可以接收/发送消息的对象，这个对象的封装是 &lt;code&gt;Kombu.pidbox.Mailbox.Node&lt;/code&gt;，我们就先来看看创建的实现吧。&lt;/p&gt;
&lt;p&gt;还是回到第一篇，在 Consumer 的 Blueprint 中，有一个叫做 Control 的 Bootstep，这个就是用于节点管理和通信的，我们来看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840515-1302394605.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其实代码还是比较简单的，有两个地方值得我们关注，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Line 25&lt;/strong&gt;：这里是构建了一个 Pidbox&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Line 26 - Line 28&lt;/strong&gt;：这个 Bootstep 的 start、stop 和 shutdown 方法都是使用的 box 的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以这个 Pidbox 是什么就很重要了，在我们看之前，不放看下上面的注释，也许会更容易一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223838812-147213621.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;虽然这里关系说得很明确了，但是我们还是有必要看看的，毕竟有可能里面有设置什么特殊的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839140-2103648824.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，确实还好，很诚实得就是用 Kombu 的 mailbox，但是 kombu 的 mailbox 是什么，可能很多人都没试过，我之前也没试过，后来试了一下，感觉还挺有意思的，注意，下面这段可能是现在互联网上公开的为数不多的可以运行得 Kombu Demo 示例，甚至于讲解。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;Kombu Mailbox&lt;/h3&gt;
&lt;p&gt;在 Kombu 中提供了 Mailbox 的实现，它的作用就是通过 Mailbox 我们可以实现不同实例之间的消息发送和处理，具体可以是&lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt;，这个在 Celery 中是作为 Control 的功能使用的，但是，在其他的模型里面，例如 Celery 试图实现但是没有实现的 Actor 模型里面也是可以用的。&lt;/p&gt;
&lt;p&gt;Anyway，下面还是讲讲 Kombu 中的 Mailbox 是怎么用的吧，当初找相关的资料费了老大力了，但是，并没有太大收获，所以自己总结了一番。在 Kombu 中，Mailbox 中只有一个概念，那就是 &lt;strong&gt;Node&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Node：每个 Node 都是一个实例，互相直接没有关联，可以完全独立，他们通过 mailbox 进行通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，为了测试，我们还会引入一个 &lt;strong&gt;client&lt;/strong&gt; 的概念，但是这个概念不是 Kombu 自己的，而是我为了演示效果添加进来的，所以现在我们应该有两个地方，分别是：&lt;strong&gt;Node&lt;/strong&gt; 和 &lt;strong&gt;Client&lt;/strong&gt;，其中可以认为 &lt;strong&gt;Node&lt;/strong&gt; 是 &lt;strong&gt;Server&lt;/strong&gt; 端，&lt;strong&gt;Client&lt;/strong&gt; 是触发端，你会发现，&lt;strong&gt;Client&lt;/strong&gt; 只是做了一件触发的工作，没有其他更多的事情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839171-1112446425.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这是 &lt;strong&gt;node&lt;/strong&gt; 的代码，你会发现它底层其实还是依赖于 Kombu 的 &lt;strong&gt;Connection&lt;/strong&gt;，所以可以看到依赖的还是我们 Celery 里面的 Broker，这点很重要。然后再看看我们是怎么触发的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839202-1327379571.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;可以发现这里非常简单，还是通过 &lt;strong&gt;Connection&lt;/strong&gt; 构建出 mailbox，有一点需要注意的就是，&lt;strong&gt;Broker&lt;/strong&gt; 要一致，不然你让他们怎么通信？执行这段代码，然后你就会在 node 上看到执行效果了，具体怎样，体验之后就明了。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;Celery 的远程控制&lt;/h3&gt;
&lt;p&gt;看过 Kombu 的实现例子之后，我们来看看 Celery 是怎么构建这些对象的，首先还是得从最开始的 control 开始说起，control 在 Celery 中也是有两处的，一处是 &lt;strong&gt;app/control.py&lt;/strong&gt;，另外一处就是：&lt;strong&gt;woker/control.py&lt;/strong&gt;，可以认为第一处的是对外的接口，而第二处的是初始化的入口，实现自然就是 Kombu 提供的了，这里只是用到他们而已。&lt;/p&gt;
&lt;p&gt;所以，现在来看，我们的目标很简单了，无非是看&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何初始化 mailbox 和 Node 的&lt;/li&gt;
&lt;li&gt;提供了那些对外接口可以使用的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面就这两个问题进行一一解答&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;mailbox 的初始化&lt;/h4&gt;
&lt;p&gt;故事是从 control 这个 Bootstep 开始说起，这是是初始化的起源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839124-1720768701.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这段代码我们前面已经见过了，同时我们也已经知道了 &lt;code&gt;self.box&lt;/code&gt; 是个啥了，但是，对于更进一步的 &lt;code&gt;c.app.control.mailbox.Node&lt;/code&gt; 中的 &lt;code&gt;c.app.control.mailbox&lt;/code&gt; 是啥还不知道，不妨来看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839140-1349789913.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，这里也很清晰，因为这个 control_cls 就是我们后面要看的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;control_cls = 'celery.app.control:Control'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以 Mailbox 也就是 Kombu 的 Mailbox 了，这里没做什么改动。除此之外，还有一个地方需要我们去关注的，那就是收到消息后怎么处理，这个得看到 Bootstep 的 &lt;code&gt;start&lt;/code&gt; 操作，这里是初始化过程中会被调用到的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839515-46113056.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 的第一句（&lt;strong&gt;Line 50&lt;/strong&gt;）没毛病，因为用的都是 Celery 的 &lt;strong&gt;Connection&lt;/strong&gt;，然后是第二句，这里我们根据之前的例子，已经很清楚会发生什么事情了，所以关键就是 &lt;strong&gt;Line 37&lt;/strong&gt; 中的 &lt;code&gt;on_message&lt;/code&gt;，每当有其他消息过来的时候，这里都是处理点。&lt;/p&gt;
&lt;p&gt;从 &lt;strong&gt;Line 42&lt;/strong&gt; 来看，Celery 还是甩锅给了 Kombu，但是这也不是啥问题，所以我们得找 Kombu 问清楚它是怎么处理的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839593-1796055321.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，这里一直有个叫 clock 的东西，我先不看，后面再说一下，先看看 dispatch 是如何处理的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839781-1791369437.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Line 99&lt;/strong&gt; 这里其实是通过是否有发送主体（&lt;strong&gt;参数传过来的 reply_to&lt;/strong&gt;）来判断是 &lt;strong&gt;单播&lt;/strong&gt; 还是 &lt;strong&gt;多播&lt;/strong&gt; 的消息，然后选择不同的处理方式，分别是 &lt;strong&gt;Line 118&lt;/strong&gt; 中的 &lt;code&gt;handle_call&lt;/code&gt; 用来处理 &lt;strong&gt;单播&lt;/strong&gt;，而 &lt;strong&gt;Line 121&lt;/strong&gt; 中的 &lt;code&gt;handler_cast&lt;/code&gt; 用来处理 &lt;strong&gt;多播&lt;/strong&gt;。这里有一个点，那就是 &lt;strong&gt;Line 116&lt;/strong&gt; 中的 &lt;code&gt;handlers&lt;/code&gt; 里面放置了所有注册的函数的信息，这个我们稍后会看到。&lt;/p&gt;
&lt;h4 id=&quot;toc_5&quot;&gt;接口的注册&lt;/h4&gt;
&lt;p&gt;前面说了，Celery 注册了很多管理接口给我们使用，我们就看看有那些注册接口以及这些接口是如何注册进去的，我们是否可以自定义管理接口。关于接口注册相关的代码，我们得走到 &lt;code&gt;celery/worker/control.py&lt;/code&gt; 中，现在进来看一看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840577-1196766256.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里有两个注册函数，其实也就是我们前面说过的对应的两类操作，分别是 &lt;strong&gt;查看&lt;/strong&gt; 和 &lt;strong&gt;设置&lt;/strong&gt; 类，然后也可以发现，其实注册就是往 Panel 这个 Dict 里头写入一些 key 和 value 对，然而，这里有两个 Dict 是需要我们关注的，他们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：key 就是名称，value 是处理函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;meta&lt;/code&gt;：key 是名称，value 是元数据，整个数据描述为：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839874-123764861.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，了解完这些我们就知道了&lt;strong&gt;远程命令的对象和处理函数的对应关系都放在 data 和 meta 里面&lt;/strong&gt;，这有什么用？回想一下之前 Mailbox 的构造函数的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839843-1225473291.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;注意看 &lt;strong&gt;Line 28&lt;/strong&gt;，用的就是这里的 data，然后就直接用来构造 Node 了，现在和前面的关系对应起来，了解了吧？&lt;/p&gt;
&lt;p&gt;下面我就找个复杂点的例子看看，是怎么讲一个函数注册进 data 这个 &lt;strong&gt;Dict&lt;/strong&gt; 里面的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840140-539668243.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个功能很明确了，在注释中已经提及了，但是，我们并不 care 它的功能，我们更多的是关注它是怎么发生的，在 &lt;strong&gt;Line 227&lt;/strong&gt; 这里就是调用注册函数进行注册，可以看到，args 分别对应到我们下面的几个命名参数，然后调用 &lt;code&gt;control_command&lt;/code&gt; 之后其实就是直接挂在 Dict 上了，没有其他操作，需要注意的是 &lt;strong&gt;Line 51&lt;/strong&gt; 的 &lt;code&gt;if args&lt;/code&gt; 这个条件，我在整个 Celery 中都没有看到有使用，所以应该这里是预留的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt;有一点值得注意的是，前面也有稍微提到，Celery 的分布式实现机制是&lt;strong&gt;广播&lt;/strong&gt;，所以我们在单机上发送的命令，只要没有指定主机，那么都是以广播的形式发送出去，所有的实例都将受到这个消息，然后根据消息处理本机的事务，所以我们在看代码的时候需要着重关注这一理念。&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;远程控制客户端&lt;/h3&gt;
&lt;p&gt;关于控制消息接收和处理的逻辑我们已经看完了，那么我们来看看我们在命令行中敲下命令的时候，这一切是怎么运行起来的。要看这些逻辑，我推荐的入口是：&lt;code&gt;celery/bin/control.py&lt;/code&gt;，这是一条典型的 Celery 命令类，这里的结构就比较复杂了，我不多说，直接看最后的结果，那就是调用的时候：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840202-250103633.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;可以发现这里很简单得就直接用一个 &lt;strong&gt;广播&lt;/strong&gt; 了事，还有比这更粗暴的么？&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 14:39:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/remote-control-manager.html</dc:identifier>
</item>
<item>
<title>通过两个小栗子来说说Java的sleep、wait、notify、notifyAll的用法 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/7846809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/7846809.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;线程是计算程序运行的最小载体，由于单个单核CPU的硬件水平发展到了一定的瓶颈期，因此就出现了多核多CPU的情况，直接就导致程序员多线程编程的复杂。由此可见线程对于高性能开发的重要性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么线程在计算机中有好几种状态，他们之间是怎么切换的？sleep和wait又有什么区别？notify和notifyAll怎么用？带着这些问题，我们来看看Java的线程吧！&lt;/p&gt;

&lt;p&gt;先来看看Thread类里面都有哪几种状态，在Thread.class中可以找到这个枚举，它定义了线程的相关状态:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116221041921-1954520922.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NEW 新建状态，线程创建且没有执行start方法时的状态&lt;/li&gt;
&lt;li&gt;RUNNABLE 可运行状态，线程已经启动，但是等待相应的资源（比如IO或者时间片切换）才能开始执行&lt;/li&gt;
&lt;li&gt;BLOCKED 阻塞状态，当遇到synchronized或者lock且没有取得相应的锁，就会进入这个状态&lt;/li&gt;
&lt;li&gt;WAITING 等待状态，当调用&lt;code&gt;Object.wait&lt;/code&gt;或者&lt;code&gt;Thread.join()&lt;/code&gt;且没有设置时间，在或者&lt;code&gt;LockSupport.park&lt;/code&gt;时，都会进入等待状态。&lt;/li&gt;
&lt;li&gt;TIMED_WAITING 计时等待，当调用&lt;code&gt;Thread.sleep()&lt;/code&gt;或者&lt;code&gt;Object.wait(xx)&lt;/code&gt;或者&lt;code&gt;Thread.join(xx)&lt;/code&gt;或者&lt;code&gt;LockSupport.parkNanos&lt;/code&gt;或者&lt;code&gt;LockSupport.partUntil&lt;/code&gt;时，进入该状态&lt;/li&gt;
&lt;li&gt;TERMINATED 终止状态，线程中断或者运行结束的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于wait方法是在Object上的，而sleep方法是在Thread上，当调用Thread.sleep时，并不能改变对象的状态，因此也不会释放锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116220938421-728584518.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这让我想起来我家的两个主子，一只泰迪一只美短，虽然他们两个是不同的物种，但是却有着相同的爱好，就是爱吃牛肉。偶尔给它们两个开荤，奈何只有一个食盆，每次只能一个主子吃肉。这就好比是两个线程，在争用同一个变量。如果使用thread.sleep，那么他们吃完后，不会释放锁等资源；如果使用wait，就会释放。&lt;/p&gt;
&lt;p&gt;详细的看一下下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.test.basic.thread;

public class AnimalEat {

    public static void main(String[] args) {
        System.out.println(&quot;盆里有20块肉&quot;);
        Animal animal = new Animal();
        try{
            Thread tidy = new Thread(animal,&quot;泰迪&quot;);
            Thread cat  = new Thread(animal,&quot;美短&quot;);
            tidy.start();
            cat.start();
        }catch (Exception e){
            e.printStackTrace();
        }
        System.out.println(&quot;盆里的肉吃完了！&quot;);
    }


}
class Animal implements Runnable {
    int count = 0;

    @Override
    public void run() {
        while(count &amp;lt; 20){
            synchronized (this){
                try {
                    System.out.println(Thread.currentThread().getName()+&quot;吃力第&quot;+count+&quot;块肉&quot;);
                    count++;
                    //Thread.sleep(100);
                    this.wait(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用this.wait(100)的时候，会输出下面的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;盆里有20块肉
泰迪吃力第0块肉
美短吃力第1块肉
盆里的肉吃完了！
泰迪吃力第2块肉
美短吃力第3块肉
泰迪吃力第4块肉
美短吃力第5块肉
泰迪吃力第6块肉
美短吃力第7块肉
泰迪吃力第8块肉
美短吃力第9块肉
泰迪吃力第10块肉
美短吃力第11块肉
美短吃力第12块肉
泰迪吃力第13块肉
美短吃力第14块肉
泰迪吃力第15块肉
美短吃力第16块肉
泰迪吃力第17块肉
美短吃力第18块肉
泰迪吃力第19块肉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，输出的信息并不是完美的交替，这是因为调用wait之后，并不一定马上时另一个线程执行，而是要根据CPU的时间分片轮转等其他的条件来定，轮到谁就看运气了。&lt;/p&gt;
&lt;p&gt;当使用Thread.sleep(100)的时候，可以得到下面的信息:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;盆里有20块肉
泰迪吃力第0块肉
盆里的肉吃完了！
泰迪吃力第1块肉
泰迪吃力第2块肉
泰迪吃力第3块肉
泰迪吃力第4块肉
泰迪吃力第5块肉
泰迪吃力第6块肉
泰迪吃力第7块肉
泰迪吃力第8块肉
泰迪吃力第9块肉
泰迪吃力第10块肉
泰迪吃力第11块肉
泰迪吃力第12块肉
泰迪吃力第13块肉
泰迪吃力第14块肉
泰迪吃力第15块肉
泰迪吃力第16块肉
泰迪吃力第17块肉
泰迪吃力第18块肉
美短吃力第19块肉
泰迪吃力第20块肉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意看最后面有一只美短。这是因为synchronized的代码同步时在while循环里面，因此最后一次两个主子都进入到了while里面，然后才开始等待相应的锁。这就导致第19次轮到了另一个主子。&lt;/p&gt;
&lt;p&gt;总结来说，sleep不会释放线程的锁,wait会释放线程的资源。&lt;/p&gt;

&lt;p&gt;wait、notify、notifyall这几个一般都一起使用。不过需要注意下面几个重要的点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用wait\notify\notifyall方法时，需要与锁或者synchronized搭配使用，不然会报错&lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt;，因为任何时刻，对象的控制权只能一个线程持有，因此调用wait等方法的时候，必须确保对其的控制权。&lt;/li&gt;
&lt;li&gt;如果对简单的对象调用wait等方法，如果对他们进行赋值也会报错，因为赋值相当于修改的原有的对象，因此如果有修改需求可以外面包装一层。&lt;/li&gt;
&lt;li&gt;notify可以唤醒一个在该对象上等待的线程，notifyAll可以唤醒所有等待的线程。&lt;/li&gt;
&lt;li&gt;wait(xxx) 可以挂起线程，并释放对象的资源，等计时结束后自动恢复；wait()则必须要其他线程调用notify或者notifyAll才能唤醒。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116220720359-2087847499.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个通俗点的例子，我记得在高中的时候，每天上午快放学的时候大家都很紧张——因为那个时候小饭馆正好播放一些港台剧，大家就总愿意抢电视机旁边的位置，所以每次快要中午放学的时候，大家都做好冲刺跑步的准备。&lt;/p&gt;
&lt;p&gt;但是有的老师总愿意压堂，搞的大家怨声载道。&lt;/p&gt;
&lt;p&gt;比如，下面这位老师有的时候会用notifyall通知大家集体放学；有的时候会检查背书，背好了，才能走。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.test.basic.thread;

public class School {
    private DingLing dingLing = new DingLing(false);

    class Teacher extends Thread{
        Teacher(String name){
            super(name);
        }
        @Override
        public void run() {
            //synchronized (dingLing){
                try {
                    dingLing.wait(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                dingLing.flag = true;

                System.out.println(&quot;放学啦&quot;);
                dingLing.notifyAll();

                /*for (int i = 0; i &amp;lt; 3; i++) {
                    System.out.println(&quot;放一个走吧&quot;);
                    dingLing.notify();
                    try {
                        dingLing.wait(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }*/
           // }
        }
    }
    class Student extends Thread{
        Student(String name){
            super(name);
        }
        @Override
        public void run(){
            synchronized (dingLing){
                while(!dingLing.flag){
                    System.out.println(Thread.currentThread().getName()+&quot;开始等待&quot;);
                    try {
                        dingLing.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName()+&quot;去吃饭啦&quot;);
            }
        }
    }

    public static void main(String[] args) {
        School school = new School();
        Teacher teacher  = school.new Teacher(&quot;老师&quot;);
        Student zhangsan = school.new Student(&quot;张三&quot;);
        Student lisi     = school.new Student(&quot;李四&quot;);
        Student wangwu   = school.new Student(&quot;王五&quot;);
        teacher.start();
        zhangsan.start();
        lisi.start();
        wangwu.start();
    }
}

class DingLing{
    Boolean flag = false;
    public DingLing(Boolean flag){
        this.flag = flag;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当老师统一喊放学的时候，即调用&lt;code&gt;dingLing.notifyAll();&lt;/code&gt;，会得到下面的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;张三开始等待
李四开始等待
王五开始等待
放学啦
王五去吃饭啦
李四去吃饭啦
张三去吃饭啦&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果检查背书，那么每次老师只会调用一次notify，让一个同学（线程）走（工作）,就会得到下面的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;张三开始等待
李四开始等待
王五开始等待
放一个走吧
张三去吃饭啦
放一个走吧
李四去吃饭啦
放一个走吧
王五去吃饭啦&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意的是，调用wait可以释放dingling的占用，这样才能让别的线程进行检查，如果改成Thread.sleep，有兴趣的童鞋就可以自己去看看效果啦！&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;最简单的实例说明wait、notify、notifyAll的使用方法：&lt;a href=&quot;http://longdick.iteye.com/blog/453615&quot; class=&quot;uri&quot;&gt;http://longdick.iteye.com/blog/453615&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java sleep和wait的区别：&lt;a href=&quot;http://www.jb51.net/article/113587.htm&quot; class=&quot;uri&quot;&gt;http://www.jb51.net/article/113587.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;sleep和wait解惑:&lt;a href=&quot;https://www.zhihu.com/question/23328075&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/23328075&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 16 Nov 2017 14:11:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/7846809.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（16）——产品分类管理 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/7846746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/7846746.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　产品分类管理的html页面之前忘记做了，这次附件里补上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了先上图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116211852812-643814092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从页面效果图来看，我们需要开发列表获取接口、添加接口、单条记录获取接口、编辑接口和删除接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于产品分类列表，我们将使用jqgrid前端表格框架，jqgrid与接口交互时，它会提交页面索引、页面大小、排序字段名以及顺序还是倒序排序这几个参数，而返回的结果也有格式约束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　返回格式要求：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　产品分类列表获取接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sort asc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         order_by = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出格式（前端使用jqgrid列表，需要指定输出格式）&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from product_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存总记录数量&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 0)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置分页大小&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         page_size = 10
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总页数&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断提交的页码是否超出范围&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面索引值&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; order_by:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合sql查询语句&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from product_class order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;           {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: order_by, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储记录&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(data, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这段代码有点长，从功能上可以分为四段，第一段是接收客户端提交的参数；第二段获取当前查询条件下有多少条记录数量；第三段是处理分页，并组合查询sql语句；第四段是提交查询请求，并返回结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　get方式提交，我们使用web_helper.get_query()函数获取参数值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体代码有详细注释，这里就不细说了，大家如果有不明白的地方留言或到群里问我。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　界面中的删除按钮对应的是删除接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @delete(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    删除指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断该分类是否已经被引用，是的话不能直接删除&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;select count(*) as total from product where product_class_id=%s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; %&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;and&lt;/span&gt; result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, -1) &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该分类已被引用，请清除对该分类的绑定后再来删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编辑记录&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;delete from product_class where id=%s returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     vars =&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在做删除前，需要判断一下这个分类是否已经被相关的产品引用绑定了，如果是的话，直接删除将会造成前端相关产品无法展示，所以需要做出提醒，让用户清除绑定后再进行删除操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　增改删操作都是对数据库的写操作，所以都使用db_helper.write()函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在postgresql数据库中，returning是一个非常棒非常好用的函数，它可以指定返回的字段，即进行增改删操作后，将这些记录的指定字段值返回给我们，我们可以通过检查返回值是否存在来判定是否执行成功。而且在进行条件操作时，它能返回我们想要的主键id值，方便我们进行我们想要的操作，比如删除nosql缓存对应值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　点击列表上面的添加按钮，会弹出一个小框，让用户输入新增记录值，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116214833077-1580065426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接口代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    新增记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'分类&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     is_enable = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否启用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加记录（使用returning这个函数能返回指定的字段值，这里要求返回新添加记录的自增id值）&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;insert into product_class (name, is_enable) values (%s, %s) returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     vars =&lt;span&gt; (name, is_enable)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result and result[0].get('id'):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　post方式提交，我们使用web_helper.get_form()函数获取参数值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编辑记录和添加记录一样，使用同一个窗口，但在接口上，它需要获取记录值和编辑后保存两个接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116213351702-1534679545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;select * from product_class where id = %s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; %&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, result[0])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; @put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    修改记录
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'分类&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     is_enable = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否启用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编辑记录&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;update product_class set name=%s, is_enable=%s where id=%s returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     vars =&lt;span&gt; (name, is_enable, id)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;and&lt;/span&gt; result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　暂时还没有朋友说看不明白，所以就不往细说了，大家看代码注释，有人不明白提出后我再补上吧（最近太忙了，所以更新可能会有点慢，大家耐心等一等，我们尽量抽空码完代码后更新上来的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　联系我们的前端代码与接口代码都在下载包中，大家自己比较一下自己处理的结果和我的是不是一样。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://pan.baidu.com/s/1c1236SC&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;本文对应的源码下载&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：AllEmpty&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;出处：http://www.cnblogs.com/EmptyFS/&lt;br/&gt;有兴趣的朋友可以加加python开发QQ群：669058475 ，大家一起探讨。大家有问题的话可以在群里发问，当然我平时工作也非常繁忙不一定会及时回复。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文为AllEmpty原创，欢迎转载，但未经同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 14:03:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/7846746.html</dc:identifier>
</item>
<item>
<title>Linux系列教程（二十）——Linux的shell概述以及如何执行脚本 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7819316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7819316.html</guid>
<description>&lt;p&gt;　　从这篇博客开始，我们将进入Linux的shell脚本的学习，这对于Linux学习爱好者而言是特别重要的一节，也是特别有意思的一节，shell 脚本就像我们知道的Java，php类似的编程语言一样，通过shell脚本，我们能完成很多有意思的应用程序。在学习中找到乐趣，这也是最重要的。&lt;/p&gt;
&lt;p&gt;　　本篇博客我们先给大家介绍一下什么是shell，以及bash的基本功能。&lt;/p&gt;
&lt;h3&gt;1、Shell 是什么？&lt;/h3&gt;
&lt;p&gt;　　和大家通常说的shell是一门编程语言的说法其实是不完全正确的。&lt;/p&gt;
&lt;p&gt;　　①、shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 shell 来启动、挂起、停止甚至是编写一些程序。&lt;/p&gt;
&lt;p&gt;　　　　比如，我们现在操作的界面就是shell，我们输入一些命令，通过shell 去翻译为机器语言，然后由硬件去执行这些命令。&lt;/p&gt;
&lt;p&gt;　　②、shell 是一个功能很强大的编程语言，它易编写、易调试，而且灵活性强。shell 是解释执行的脚本语言，在 shell 中可以直接调用 Linux 系统命令。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111151841388-2063112669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实windows类似于shell的就是它的图形交互界面，我们在windows系统中打开文件，删除文件等操作，就是向windows系统发送命令。&lt;/p&gt;

&lt;h3&gt;2、Shell 的分类&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152355966-1316017495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152406434-2142670219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152420028-1218779368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152458231-9424378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、查看Linux系统支持的 shell：/etc/shells&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152607809-2130666013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以在shell解释器中直接输入shell名称进行切换&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152752809-249220999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、echo 输出命令&lt;/h3&gt;
&lt;p&gt;　　这个命令如果学过Java的类似于 System.out.println()，如果学过C语言的类似于 printf()，在shell 当中语法形式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
echo 【选项】【输出内容】
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-e  表示支持反斜杠控制的字符转换，也就是转义字符。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111192744497-1540705727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　范例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111192954934-2079362484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、脚本执行方式&lt;/h3&gt;
&lt;p&gt;　　首先我们编写一个shell 脚本。通过 vi hello.sh，打开 hello.sh 文件，然后在文件中添加如下内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111193623763-538783684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　①、我们说Linux系统是不区分文件后缀名的，这里我们学习的是 bash,所以创建文件 hello.sh，后缀名最好加上.sh（虽然不加也没问题），便于我们识别。&lt;/p&gt;
&lt;p&gt;　　②、脚本的第一行 #!,这是一个约定的标记，它告诉系统这个脚本需要用什么解释器去执行，即使用哪一种 shell，所以学习 bash，第一行固定都是 #!/bin/bash。这是不能省略的。&lt;/p&gt;
&lt;p&gt;　　创建完毕之后，接下来执行该脚本，有如下两种方式：&lt;/p&gt;
&lt;h4&gt;　　①、作为可执行程序&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
cd /tmp                     #进入到脚本所在的目录
chmod +x ./hello.sh   #使得脚本具有可执行权限
./hello.sh                  #执行脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，一定要写成 ./hello.sh，而不是 hello.sh，运行其它二进制的程序也一样，直接写 hello.sh，linux 系统会去 PATH 里寻找有没有叫 hello.sh 的（这是后面会讲的环境变量的配置），而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 hello.sh 是会找不到命令的，要用 ./hello.sh 告诉系统说，就在当前目录找。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111194432044-121736781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　②、作为解释器参数&lt;/h4&gt;
&lt;p&gt;　　也就是直接运行解释器，其参数就是 shell 脚本的文件名，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/bin/sh hello.sh
或者
bash hello.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：这种方式执行脚本，并不需要第一行写上 #!/bin/bash。&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 13:28:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7819316.html</dc:identifier>
</item>
<item>
<title>《天书夜读：从汇编语言到windows内核编程》十一 用C++编写内核程序（c++对象反汇编剖析） - SChivas</title>
<link>http://www.cnblogs.com/SChivas/p/7846458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SChivas/p/7846458.html</guid>
<description>&lt;p&gt;1） C++的“高级”特性，是它的优点也是它的缺点，微软对于使用C++写内核程序即不推崇也不排斥，使用C++写驱动需注意：&lt;/p&gt;
&lt;p&gt;　　a）New等操作符不能直接使用，如果要使用，必须进行重载。&lt;/p&gt;
&lt;p&gt;　　b）标准C接口的声明，在包含头文件以及入口例程的前面要声明extern “C”&lt;/p&gt;
&lt;p&gt;　　c）类的静态成员函数的使用：在类内部声明一个静态函数作为分发函数Dispatch，这个静态函数当做普通的C函数调用，而C++声明的非静态函数调用该函数进行分配。&lt;/p&gt;
&lt;p&gt;　　这一部分读下来，其实大多不是和内核相关，而是了解C++语言的汇编代码。&lt;/p&gt;

&lt;p&gt;2）下面是一个实例的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;ntifs.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  TAG  'abcd'
&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;DRIVER_UNLOAD DriverUnload;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; DRIVER_INITIALIZE DriverEntry;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyDriver
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    MyDriver(PDRIVER_OBJECT driver);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可派生的Dispath虚函数（在DDK编译环境中可行）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;VS2005编译器环境定义可派生虚函数报错，这里采用重载方式去实现
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原因未知&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; NTSTATUS OnDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_UNSUCCESSFUL;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态成员，总是记录被唯一实例化的MyDriver指针&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; MyDriver *&lt;span&gt;d_my_driver;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态成员函数，用来做为dispatch函数使用&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NTSTATUS sDispatch(PDEVICE_OBJECT dev,PIRP irp);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    PDRIVER_OBJECT d_driver;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现代码&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; MyDriver *MyDriver::d_my_driver =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;MyDriver::MyDriver(PDRIVER_OBJECT driver):d_driver(driver)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    size_t i;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt;= IRP_MJ_MAXIMUM_FUNCTION ; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         driver-&amp;gt;MajorFunction[i] =&lt;span&gt; sDispatch;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     driver-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     d_my_driver = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态的分发函数的实现：调用虚函数，以便以后派生&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;NTSTATUS MyDriver::sDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; d_my_driver-&amp;gt;&lt;span&gt;OnDispatch(dev,irp);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     
&lt;span&gt;51&lt;/span&gt;     
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数size_t是必须外置的，编译器会自动用sizeof(clsName)求取长度并作为第一个参数&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(size_t size,POOL_TYPE pool_type,ULONG pool_tag)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     ASSERT((pool_type &amp;lt; MaxPoolType) &amp;amp;&amp;amp; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; size));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(size == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;     
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断级检查。分发级别和以上的级别只能分配非分页内存   &lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     ASSERT(pool_type ==  NonPagedPool ||(KeGetCurrentIrql() &amp;lt;&lt;span&gt; DISPATCH_LEVEL));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ExAllocatePoolWithTag(pool_type,static_cast&amp;lt;ULONG&amp;gt;&lt;span&gt;(size),pool_tag);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     
&lt;span&gt;63&lt;/span&gt;     
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己实现delete&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; pointer)  
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     ASSERT(NULL !=&lt;span&gt; pointer);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL !=&lt;span&gt; pointer)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        ExFreePool(pointer); 
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动实现delete[]操作&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;[](&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; pointer)  
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;{   
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     ASSERT(NULL !=&lt;span&gt; pointer);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL !=&lt;span&gt; pointer) 
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        ExFreePool(pointer);  
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个Unload函数值是为了让这个程序能动态卸载，方便调试&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;VOID DriverUnload(PDRIVER_OBJECT driver)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印一句&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;     KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CPP Driver is unloading...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;     
&lt;span&gt;87&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NTSTATUS DriverEntry(PDRIVER_OBJECT driver,PUNICODE_STRING reg)
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;     MyDriver::d_my_driver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(NonPagedPool, TAG) MyDriver(driver); 
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;     KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CPP Driver Test!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;     driver-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; MyDriver::d_my_driver;
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116202513265-2060930752.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3）选择WDK的“X86 check build enviroment”编译上述代码（如果没有虚函数，可用VS2005将项目属性中C/C++选项卡下的优化项选择为禁止，然后编译）。下面是DriverEnter函数的反汇编代码（用IDA反汇编，感觉比WIND32ASM好用，带可视化的图形模块），注意一些调用约定：其中的new与delete都在定义时指定为cdecl，而类一般为thiscall，其它默认函数为stdcall，在下一章中，还将使用fastcall调用约定：&lt;/p&gt;
&lt;p&gt;　　a）Stdcall：通常用于win32API中在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。stdcall的调用约定意味着：参数从右向左压入堆栈；函数自身修改堆栈；函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸（如常见的“_function@8”等格式）&lt;/p&gt;
&lt;p&gt;　　b）Cdecl：有的地方写成cdcall，即C语言调用约定，是C语言缺省的调用方式。Cdecl调用约定也是参数从右向左压入堆栈，但是函数本身不清理堆栈，由调用者来清理，由于这种特性，C语言调用约定允许函数参数个数是不定的。&lt;/p&gt;
&lt;p&gt;　　c）Thiscall：thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：参数从右向左入栈；如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈；对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。&lt;/p&gt;
&lt;p&gt;　　d） Fastcall：fastcall调用约定与stdcall调用几乎完全相同，唯一的区别是，前两个参数不被放入堆栈中传入，而是放入ecx与edx中，ecx保存第一个参数，而edx保存第二个参数，其它参数采用堆栈传递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116203021124-998196681.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;DriverEntry反汇编&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　第一：类的构造函数的调用代码是C++编译器自动生成的，构造函数对程序员来说不能自行调用，也不能定义返回值，但从汇编代码来看，这里是&lt;span&gt;返回了对象实例自身的指针&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　第二：var_4、var_C、P从分析上来看存放的都是同一个值，就是类实例的一个指针值。&lt;/p&gt;
&lt;p&gt;　　第三：driver-&amp;gt;DriverUnload = DriverUnload被书写了2次（入口函数中一次，构造函数中也写了一次），这个是我的失误，不过不影响代码的执行。在读汇编类似的代码时，可以查看DRIVER_OBJECT结构体具体内容来判断偏移34H到底是哪个域。&lt;/p&gt;
&lt;p&gt;　　第四：[ebp + p]这个局部变量完全没有定义的必要，debug版本反汇编虽然和最初的编写逻辑很对应，但是会发现很多的无用代码，而release版本经编译器优化以后模样大变，实际上看debug版本能了解语言特性，而看release版本才是比较实用的，因为没人会发布debug版本。&lt;/p&gt;

&lt;p&gt;4）构造函数反汇编：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116203551796-1781292151.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++构造函数反汇编&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　第一：&lt;span&gt;对象内存空间一开始存放的并不是数据成员，而是虚函数表（假如定义有虚函数）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第二：&lt;span&gt;对象内存空间在虚函数表之后存放的是数据成员，不包含静态的数据成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第三：&lt;span&gt;对象的静态数据成员并不在对象实例内存空间，而采用的全局变量来使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;5）虚函数派生反汇编，新增派生类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MySubDriver:&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDriver
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    MySubDriver(PDRIVER_OBJECT driver):MyDriver(driver){};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; NTSTATUS OnDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is the dispatch function of MySubDriver!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_UNSUCCESSFUL;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　改写DriverEntry下面一句：&lt;/p&gt;
&lt;p&gt;　　MyDriver::d_my_driver = new(NonPagedPool, TAG) MySubDriver(driver);&lt;/p&gt;
&lt;p&gt;　　派生类构造函数：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116204456281-1569769078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++子类构造函数反汇编&lt;/p&gt;

&lt;p&gt;　　第一：从此可解释，C++派生类的构造函数是从最原始的基类向子类来执行的&lt;/p&gt;
&lt;p&gt;　　第二：&lt;span&gt;填写虚函数地址表时，实际上执行的是覆盖。&lt;/span&gt;这里在基类中已经写入了基类的虚函数地址，然后当基类构造函数执行完毕以后，派生类会再次写入虚函数地址（如果派生类重写了虚函数，则该地址会覆盖基类的填写的虚函数地址，否则保留基类的虚函数）。&lt;/p&gt;
&lt;p&gt;　　第三：这是一个无用代码的说明，在标准现场保护完毕之后，调用基类的构造函数之前，应该只需要将传入参数driver压入栈，可是之前却还压入了ecx（也就是类实例this指针），从基类构造函数以及派生类构造函数后面的代码中可分析，这个压入的值并没有被使用，也没有再弹出。&lt;/p&gt;
&lt;p&gt;　　虚函数调用代码：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116204800843-276424862.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++虚函数调用反汇编&lt;/p&gt;

&lt;p&gt;　　关于虚函数的调用机制，还得看下所谓的虚函数地址表到底是怎么一回事：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116210007218-990611927.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++虚函数地址表&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　可见，&lt;span&gt;虚函数地址表实际上是一些常量指针值，这些常量指针值保存了各个虚函数的定义代码的地址值，构造函数在填写虚函数的时候，并没有直接写人虚函数的函数地址，而是写入的常量指针值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　那么，调用虚函数的汇编代码就解释得清楚了，首先从类实例中取得虚函数常量指针值到eax，再通过mov edx,[eax]将虚函数真正所在的地址放入edx，再call edx实行调用。&lt;/p&gt;
&lt;p&gt;　　第一：基类和派生类虚函数地址表各有一份，并不会覆盖，但是在&lt;span&gt;实例化一个类以后，这个实例的内存空间中，维持着一个虚函数地址表，这个表里面对应的是实际使用的虚函数地址&lt;/span&gt;（最初是原始基类的虚函数地址表，但随着之后各个类的派生，会随着虚函数的重定义而重新改写表中的数值）。&lt;/p&gt;
&lt;p&gt;　　第二：不同的编译器对虚函数地址的改写方式可能会有不同。&lt;/p&gt;
&lt;p&gt;　　第三：&lt;span&gt;对虚函数地址表的存在，为修改虚函数地址表来实现HOOK提供了可能&lt;/span&gt;。&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 13:05:00 +0000</pubDate>
<dc:creator>SChivas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SChivas/p/7846458.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（八十三）analytics:reportChart实现Dashboard(仪表盘)功能效果 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7845944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7845944.html</guid>
<description>&lt;p&gt;项目中经常会用到Report以及Dashboard来分析汇总数据，Dashboard可以指定view as user，如果针对不同的用户需要显示其允许查看的数据，比如  根据role hierarchy来显示数据，需要指定run as login user.但是dashboards runas the logged-in user是有数量的限制的，针对此种情况，就需要使用自定义实现Dashboard功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116191748015-263126549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用自定义操作可以通过apex class获取数据，在visualforce page上画不同组的chart，点击chart以后跳转到相关详情的report页面，但是这种情况无法处理funnel chart的情况，因为visualforce的api没有提供funnel chart样式的元素。&lt;/p&gt;
&lt;p&gt;这种情况下，比较偷懒的操作为在Report上使用Role Hierarchy进行限制来对数据进行获取，然后在Report中配置chart，使用aynalytics:reportChart传递需要显示的report ids进行展示，从而实现dashboard的效果。&lt;/p&gt;
&lt;p&gt; 功能：实现自定义Dashboard，Dashboard显示两个chart，分别为通过Type对Account进行分组以及通过State/Province对Account分组，每个用户只能看到当前用户以及下级的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.创建Report，此Report通过Type进行分组，developername为Account_Report_By_Type&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116200641843-1319418130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.创建Report，此Report通过State/Province进行分组，developername为Account_By_Billing_State_Province&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116201015874-921088245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.创建Dashboard,包含上面的两个Report，datasource也分别对应上面两个report。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116201102140-1124605470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作结束，现在需要通过程序来实现上面的Dashboard。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.AnalyticsReportChartController:用来获取上述两个report id，并放在reportIds&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; with sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnalyticsReportChartController {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Id&amp;gt;&lt;span&gt; reportIds{get;set;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnalyticsReportChartController() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         reportIds = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Id&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        reportIds.add(accountByTypeReportId);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        reportIds.add(accountByStateProvinceReportId);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Id accountByTypeReportId{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        get {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(accountByTypeReportId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Report rt = [select id from Report where DeveloperName = 'Account_Report_By_Type' limit 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 accountByTypeReportId =&lt;span&gt; rt.Id;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountByTypeReportId;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }set;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Id accountByStateProvinceReportId {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        get {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(accountByStateProvinceReportId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 Report rt = [select id from Report where DeveloperName = 'Account_By_Billing_State_Province' limit 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 accountByStateProvinceReportId =&lt;span&gt; rt.Id;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountByStateProvinceReportId;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }set;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.AnalyticsReportChart.page：实现展示两个report的chart，点击后跳转到相关的report中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:page &lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;=&quot;AnalyticsReportChartController&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:panelGrid &lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:outputPanel &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;reportPanel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:repeat &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!reportIds}&quot;&lt;/span&gt;&lt;span&gt; var&lt;/span&gt;&lt;span&gt;=&quot;report&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display: inline-block;width: 400px;height: 400px;vertical-align: top;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;analytics:reportChart &lt;/span&gt;&lt;span&gt;reportId&lt;/span&gt;&lt;span&gt;=&quot;{!report}&quot;&lt;/span&gt;&lt;span&gt; showRefreshButton&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;small&quot;&lt;/span&gt;&lt;span&gt; cacheResults&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;analytics:reportChart&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:repeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:outputPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:panelGrid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116202037952-1580319916.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;使用analytics:reportChart可以很方便的实现DashBoard的展示效果，但是此种方式仅限于Dashboard中的一个Chart对应一个Report，而不是一个Chart对应多个Report，如果出现一个Chart对应多个Report，需要创建成一对一的关系才能实现。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 12:27:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7845944.html</dc:identifier>
</item>
</channel>
</rss>