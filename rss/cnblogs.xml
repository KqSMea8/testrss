<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java网络编程-HTTP协议 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9746384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9746384.html</guid>
<description>&lt;p&gt;这篇文章暂时不研究HTTP底层的TCP/IP的握手和挥手过程，只从表面的交互流程分析HTTP协议。&lt;/p&gt;
&lt;p&gt;HTTP英文全称是Hypertext Transfer Protpcol，也就是超文本传输协议。HTTP是一个标准，定义了Web客户端如何与服务器对话以及数据如何从服务器传回到客户端。在日常开发和使用过程中，HTTP经常被认为是一种用于传输HTML文件和文件中内嵌的图片的协议或者手段，实际上HTTP是一种通用的网络数据传输格式，它的传输内容不仅仅局限于HTML文件或者图片，也可以用来传输Microsoft Word文档甚至是Windows的exe文件等等，所有可以用字节序列表示的数据都可以使用HTTP进行传输。&lt;/p&gt;
&lt;p&gt;HTTP通过TCP/IP进行数据传输，如果忽略底层的TCP协议的握手和挥手的细节，对于从客户端到服务器的每一个请求和请求的响应，在HTTP1.0有下面几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、默认情况下，客户端在端口80开启与服务器的一个TCP连接，当然也可以指定其他的端口。&lt;/li&gt;
&lt;li&gt;2、客户端向服务器发送消息，请求指定路径上的资源。一个HTTP请求包括一个首部，可选项包括一个空行和这次请求的数据。&lt;/li&gt;
&lt;li&gt;3、服务器向客户端发送响应。响应以响应码开头，接着是包含元数据的首部，可选项包括一个空行以及所请求的文档数据或者错误信息。&lt;/li&gt;
&lt;li&gt;4、服务器关闭TPC连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在HTTP1.1(目前最常用的就是HTTP1.1)以及以后的HTTP版本中，可以通过一个TCP连接连续发送多个请求和接收多个响应。也就是说，上面的1和4步骤中间的2和3步骤可以反复执行多次。另外，HTTP1.1中，请求数据和响应数据可以分块发送，提高了扩展性。&lt;/p&gt;

&lt;p&gt;HTTP中定义了多种请求方法，用于标识当次请求需要完成什么类型的操作，常用的HTTP请求方法有GET、HEAD、PUT、POST、PATCH、TRACE、OPTIONS、DELETE。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;通常用于请求服务器获取某个资源&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于GET，但是响应结果中不包含响应体，只包含协议信息和首部，通常用于测试资源是否存在或者是否被修改&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;客户端向服务器提交数据(支持HTML的表单数据)，可能会导致新的资源的建立或者已有资源的修改&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容(全部取代)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;客户端向服务器传送的数据取代指定的文档的内容(部分取代)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显客户端请求服务器的原始请求报文，用于&quot;回环&quot;诊断&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;请求服务器获取服务器支持的各种功能，可以询问服务器支持什么类型的HTTP方法，一般用于性能测试&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面说到的&quot;是否安全&quot;的选项是&quot;是&quot;，意味着使用该种HTTP请求方法不会发生任何数据的修改或者更新动作，也就是请求多次也不会影响到资源的状态。如果&quot;是否幂等&quot;的选项是&quot;是&quot;，意味着使用该HTTP请求方法请求多次HTTP调用，无论调用多少次，请求结果或者资源的状态是一样的(可以理解为只有首次调用是真正修改了资源的状态，从第二次调用开始后面的调用只获取到第一次调用的结果)。HTTP方法的安全性和幂等性是我们在设计HTTP接口时候需要重点考虑的两个因素。&lt;/p&gt;
&lt;p&gt;值得注意的是：上面提到的POST和PUT方法的功能可以理解为相同的，两者的主要区别在于POST不是幂等的，而PUT是幂等的。在目前的Web开发中，POST方法已经被滥用，一般很少人会使用PUT，除非是推崇RESTFUL风格编程。PUT方法和PATCH方法的功能类似，都是用客户端请求的数据去替换掉服务器中指定文档中的内容，不过PUT方法是全部替换，而PATCH方法是部分替换。&lt;/p&gt;
&lt;p&gt;PS：上面的方法只是HTTP协议中的请求方法的一些规范，没有硬性规定一定要遵循。&lt;/p&gt;

&lt;p&gt;JDK中常见的HTTP状态码可以在类java.net.HttpURLConnection中找到，总结一下如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;26&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;信息状态码。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;服务器准备接受请求主体，客户端发送请求主体；这允许客户端在请求发送大量数据之前询问服务器是否接受请求。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching Protocols&lt;/td&gt;
&lt;td&gt;服务器接受客户端在Upgrade首部字段中要求改变应用的协议请求，如从HTTP转换为WebSockets。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;表示请求成功。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;最常见的响应码，代表请求成功。如果请求方法是GET或者POST，所请求的数据与正常的首部都包含在响应体中。如果请求方法是HEAD，则只包含首部信息。&lt;/td&gt;
&lt;td&gt;HTTP_OK&lt;/td&gt;
&lt;td&gt;处理请求成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;服务器已经在响应体中指定的URL创建了对应的资源。客户端现在应当尝试加载该URL。这个响应码只在响应POST请求时发送。&lt;/td&gt;
&lt;td&gt;HTTP_CREATED&lt;/td&gt;
&lt;td&gt;创建成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;202&lt;/td&gt;
&lt;td&gt;Accepted&lt;/td&gt;
&lt;td&gt;表示请求已经被处理，但是处理尚未结束，所以不会返回任何响应数据。&lt;/td&gt;
&lt;td&gt;HTTP_ACCEPTED&lt;/td&gt;
&lt;td&gt;接受请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;203&lt;/td&gt;
&lt;td&gt;Non-Authoritative Information&lt;/td&gt;
&lt;td&gt;由缓存代理或者其他本地源返回资源的表示，不能保证是最新的。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_AUTHORITATIVE&lt;/td&gt;
&lt;td&gt;无权威的返回结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No Content&lt;/td&gt;
&lt;td&gt;服务器已经成功处理了该请求，但是没有信息发回给客户端。一般是由于服务器上的表单处理逻辑的问题，只接收数据不返回数据。&lt;/td&gt;
&lt;td&gt;HTTP_NO_CONTENT&lt;/td&gt;
&lt;td&gt;无返回内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;205&lt;/td&gt;
&lt;td&gt;Reset Content&lt;/td&gt;
&lt;td&gt;服务器已经成功处理了该请求，但是没有信息发回给客户端。客户端应该清除发送请求的表单信息。&lt;/td&gt;
&lt;td&gt;HTTP_RESET&lt;/td&gt;
&lt;td&gt;重置内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;服务器返回客户端请求的资源的部分内容，而不是整个文档。&lt;/td&gt;
&lt;td&gt;HTTP_PARTIAL&lt;/td&gt;
&lt;td&gt;部分内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;重定向。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;Multiple Choices&lt;/td&gt;
&lt;td&gt;服务器为所请求的文档提供一组不同的表示。&lt;/td&gt;
&lt;td&gt;HTTP_MULT_CHOICE&lt;/td&gt;
&lt;td&gt;多重选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;资源已经移动到一个新的URL。客户端应当自动加载这个URL的资源。&lt;/td&gt;
&lt;td&gt;HTTP_MOVE_PERM&lt;/td&gt;
&lt;td&gt;永久移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Moved Temporarity&lt;/td&gt;
&lt;td&gt;资源暂时移动到一个新的URL，但其位置在不久的将来还会再次改变。&lt;/td&gt;
&lt;td&gt;HTTP_MOVE_TEMP&lt;/td&gt;
&lt;td&gt;临时移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;客户端错误&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;客户端向服务器发出的请求使用了不正确的语法。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_REQUEST&lt;/td&gt;
&lt;td&gt;错误请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;访问这个URL需要身份验证，一般是用户名和口令。&lt;/td&gt;
&lt;td&gt;HTTP_UNAUTHORIZED&lt;/td&gt;
&lt;td&gt;未授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;服务器理解请求，但是有意拒绝进行处理。&lt;/td&gt;
&lt;td&gt;HTTP_FORBIDDEN&lt;/td&gt;
&lt;td&gt;禁止访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;最常见的错误响应，指示服务器找不到所请求的资源。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_FOUND&lt;/td&gt;
&lt;td&gt;未找到资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method Not Allowed&lt;/td&gt;
&lt;td&gt;请求方法不支持用于请求指定的资源。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_METHOD&lt;/td&gt;
&lt;td&gt;方法禁用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;406&lt;/td&gt;
&lt;td&gt;Not Acceptable&lt;/td&gt;
&lt;td&gt;所请求的资源不能以客户端希望的格式提供，客户端期望的格式由请求HTTP首部Accept字段指定。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_ACCEPTABLE&lt;/td&gt;
&lt;td&gt;不接受&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;服务端错误&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internale Server Error&lt;/td&gt;
&lt;td&gt;服务器内部异常。&lt;/td&gt;
&lt;td&gt;HTTP_SERVER_ERROR&lt;/td&gt;
&lt;td&gt;服务器异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;501&lt;/td&gt;
&lt;td&gt;Not Implemented&lt;/td&gt;
&lt;td&gt;服务器不具备完成请求的功能。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_IMPLEMENTED&lt;/td&gt;
&lt;td&gt;尚未实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;服务器作为网关或代理，从上游服务器收到无效响应。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_GATEWAY&lt;/td&gt;
&lt;td&gt;错误网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service Unavailable&lt;/td&gt;
&lt;td&gt;服务器暂时无法处理请求，可能是超负荷或者维护等原因。&lt;/td&gt;
&lt;td&gt;HTTP_UNAVAILABLE&lt;/td&gt;
&lt;td&gt;服务不可用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单概括如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应码100-199表示一个提供信息的响应。&lt;/li&gt;
&lt;li&gt;响应码200-299表示请求成功。&lt;/li&gt;
&lt;li&gt;响应码300-399表示重定向。&lt;/li&gt;
&lt;li&gt;响应码400-499表示一个客户端引发的错误。&lt;/li&gt;
&lt;li&gt;响应码500-599表示一个服务器引发的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单列举一些比较常用的首部以及它们的作用。&lt;/p&gt;
&lt;h2 id=&quot;user-agent&quot;&gt;User-Agent&lt;/h2&gt;
&lt;p&gt;User-Agent一般作为请求首部，用于告知服务器当前客户端使用的是什么浏览器，翻译过来就是用户代理，作用是允许服务器响应请求时候针对客户端用户代理的类型优化返回的数据或者文件。例如使用Chrome发送请求时，User-Agent如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;host&quot;&gt;Host&lt;/h2&gt;
&lt;p&gt;Host一般作为请求首部，用于指定接收该请求的服务器的主机名和端口号。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host: www.importnew.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;accept&quot;&gt;Accept&lt;/h2&gt;
&lt;p&gt;Accept一般作为请求首部，它的作用是告知服务器它可以使用或者想要什么已经不能使用或者不想要什么。下面是几个Accept首部以及它们的作用：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些字符集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些语言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Accept首部用于指定接收媒体类类型的时候，需要指定类型和子类型，这是因为媒体类型(MIME)本来就是按二级分类的，例如JPEG图像的媒体类型是image/jpeg，类型是image，子类型是jpeg。MIME已经定义了八种顶级的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;text/*表示人可读的文字。&lt;/li&gt;
&lt;li&gt;image/*表示图片。&lt;/li&gt;
&lt;li&gt;model/*表示3D模型，如VRML文件。&lt;/li&gt;
&lt;li&gt;audio/*表示音频。&lt;/li&gt;
&lt;li&gt;video/*表示多媒体图片、视频，也可能是音频。&lt;/li&gt;
&lt;li&gt;application/*表示二进制数据。&lt;/li&gt;
&lt;li&gt;message/*表示协议特定的信封，如Email消息和HTTP响应。&lt;/li&gt;
&lt;li&gt;muitipart/*表示多个文档和资源的容器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，如果客户端只接收JSON数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept: application/json&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;referer&quot;&gt;Referer&lt;/h2&gt;
&lt;p&gt;Referer一般作为请求首部，它提供了包含当前请求的URL的文档的URL，也就是当前请求的上一个来源的文档，一般用作防盗链。例如&lt;code&gt;www.baidu.com/search?name=doge&lt;/code&gt;，服务器在处理此请求的时候，需要判断Referer是否为&lt;code&gt;www.baidu.com&lt;/code&gt;，&lt;code&gt;www.baidu.com/search&lt;/code&gt;的上一个文档来源必须是&lt;code&gt;www.baidu.com&lt;/code&gt;，否则服务器应该拒绝该请求。&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie一般作为请求首部，客户端通过它向服务器传送一个或者多个令牌，原则上Cookie并不是安全的首部，Cookie的内容也会缓存在客户端。一般在Servlet应用中，Cookie是识别当前用户，实现持久会话的最佳方式。从过期时间分类来看，Cookie分为会话Cookie和持久Cookie，会话Cookie的过期时间比较短，持久Cookie的过期时间比较长或者不会过期，Cookie的过期策略等控制应该由服务端控制。由于Cookie是直接暴露在客户端，一般不能使用Cookie存放敏感的数据，需要存放敏感数据可以考虑使用数据加密处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cookie: uid=10086; domain=&quot;localhost&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;set-cookie&quot;&gt;Set-Cookie&lt;/h2&gt;
&lt;p&gt;Set-Cookie一般作为响应首部，和Cookie对应，表示服务器设置成功的Cookie。&lt;/p&gt;
&lt;h2 id=&quot;cache-control&quot;&gt;Cache-Control&lt;/h2&gt;
&lt;p&gt;Cache-Control一般作为请求首部，告知服务器对当前的请求的响应结果进行缓存相关操作。Cache-Control支持的值比较多，这里不展开细节，常见的如&lt;code&gt;no-cache&lt;/code&gt;表示在没有成功通过源站校验的情况下不得使用缓存，如&lt;code&gt;max-age&lt;/code&gt;表示响应结果需要缓存到指定的最大时间。&lt;/p&gt;
&lt;h2 id=&quot;content-type&quot;&gt;Content-Type&lt;/h2&gt;
&lt;p&gt;Content-Type是通用首部，可以作为请求首部或者响应首部，它的作用是告知服务器或者客户端当前请求或者响应结果的内容(媒体)类型。&lt;/p&gt;
&lt;h2 id=&quot;content-length&quot;&gt;Content-Length&lt;/h2&gt;
&lt;p&gt;Content-Length是通用首部，可以作为请求首部或者响应首部，它的作用是告知服务器或者客户端当前请求或者响应数据体的长度。&lt;/p&gt;
&lt;h2 id=&quot;content-encoding&quot;&gt;Content-Encoding&lt;/h2&gt;
&lt;p&gt;Content-Encoding一般作为响应首部，与Accept-Encoding对应，用于服务器告知客户端当前响应结果的内容编码。&lt;/p&gt;
&lt;h2 id=&quot;content-language&quot;&gt;Content-Language&lt;/h2&gt;
&lt;p&gt;Content-Language一般作为响应首部，与Accept-Language对应，用于服务器告知客户端当前响应结果的内容语言。&lt;/p&gt;
&lt;h2 id=&quot;connection&quot;&gt;Connection&lt;/h2&gt;
&lt;p&gt;Connection一般作为请求首部，表示是否需要持久连接。在HTTP1.1中，如果指定为Keep-Alive，可以提供持久连接，提高Socket的复用率从而降低多次连接的性能消耗。下面有一个小节专门介绍Keep-Alive。&lt;/p&gt;
&lt;h2 id=&quot;orgin&quot;&gt;Orgin&lt;/h2&gt;
&lt;p&gt;Origin一般作为请求首部，指明当前的请求是一个针对跨域资源共享的请求(该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Origin: http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;access-control-allow-origin&quot;&gt;Access-Control-Allow-Origin&lt;/h2&gt;
&lt;p&gt;Access-Control-Allow-Origin一般作为响应首部，和Origin对应，表示服务器允许的该跨域资源共享的请求来源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Origin: http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;server&quot;&gt;Server&lt;/h2&gt;
&lt;p&gt;Server一般作为响应首部，用于告知客户端服务器的相关信息。&lt;/p&gt;

&lt;p&gt;如果采用GET请求方法，只需要向远处服务器提供URL，URL中的路径和查询字符串就可以匹配到需要查询的资源。但是URL中无法提供详细的客户端信息。另外，像POST和PUT这些请求方法所携带的数据体有可能比较大，无法放在URL的查询字符串。因此HTTP需要请求体。HTTP请求体包括下面四个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、一个起始请求行，包括HTTP方法、路径、查询字符串以及HTTP版本。&lt;/li&gt;
&lt;li&gt;2、HTTP请求的首部。&lt;/li&gt;
&lt;li&gt;3、一个空行(两个连续的回车或者换行对)。&lt;/li&gt;
&lt;li&gt;4、请求数据体。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文字描述可能比较抽象，用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/http-1.png&quot; alt=&quot;http-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：space代表空格，\r\n代表换行。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /wp-admin/admin-ajax.php?postviews_id=23996&amp;amp;action=postviews&amp;amp;_=1538708851063 HTTP/1.1
Host: www.importnew.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Accept: */*
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36
Referer: http://www.importnew.com/23996.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9

postviews_id=23996&amp;amp;action=postviews&amp;amp;_=1538708851063&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;响应体和请求体的格式类似，主要是返回服务器的响应数据到客户端，包括服务器的一些信息和响应数据体。HTTP响应体主要包括下面的四个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、一个起始响应行，包括HTTP版本、状态码、状态码描述。&lt;/li&gt;
&lt;li&gt;2、HTTP响应的首部。&lt;/li&gt;
&lt;li&gt;3、一个空行(两个连续的回车或者换行对)。&lt;/li&gt;
&lt;li&gt;4、响应数据体。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文字描述可能比较抽象，用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/http-2.png&quot; alt=&quot;http-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：space代表空格，\r\n代表换行。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP/1.1 200 OK
Server: nginx
Date: Fri, 05 Oct 2018 03:07:37 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Keep-Alive: timeout=2
Vary: Accept-Encoding
X-Powered-By: PHP/5.3.3
X-Robots-Tag: noindex
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Content-Encoding: gzip

2995&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在使用HTTP1.0的时候会为每个请求打开一个新的TCP连接，实际上，这导致了一个典型Web会话中打开和关闭所有连接所花费的事件远远大于实际传输数据所消耗的时间，特别是响应结果包含很多小文档的会话。对于使用SSL或者TLS加密的HTTPS连接，这个问题更加严重，因为建立一个安全的Socket的握手过程远比建立常规的Socket需要更多的工作。&lt;/p&gt;
&lt;p&gt;在HTTP1.1和后面的版本中，服务器不必在返送响应之后就关闭连接。已经建立的连接可以保持打开，在同一个Socket上等待来自客户端的新请求。简单来说，就是可以在一个TCP连接上连续发送多个请求和连续进行多个请求的响应。&lt;/p&gt;
&lt;p&gt;客户端可以在HTTP请求首部中添加一个Connection请求头，指定值为Keep-Alive，这样就能实现Socket的重用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Connection: Keep-Alive&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP1.1或者之后的版本，Keep-Alive是默认开启的，不需要显式指定，如果需要关闭可以设置为close：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Connection: close&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦开启了Keep-Alive，服务器在关闭一个Socket连接之前，如果有新的客户端再次连接到服务器，那么就是重用Socket。在JDK中可以通过系统属性来控制如果使用HTTP的Keep-Alive：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http.keepAlive：默认值为true，默认开启HTTP的Keep-Alive。&lt;/li&gt;
&lt;li&gt;http.maxConnections：同时保持打开的Socket数量的最大值，默认值为5。&lt;/li&gt;
&lt;li&gt;http.keepAlive.remainingData：默认值为false，如果设置为true，则JDK在丢弃连接之后会完成剩余数据的清理。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.enableBuffering：默认值为false，如果设置为true，则尝试缓存400和500状态码的相对小的错误流，从而能释放连接以备后续使用。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.bufferSize：为缓存错误流的缓冲区的字节大小，默认值为4096字节，只有上一项为true的时候才有意义。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.timeout：默认值为300ms，读取错误流超时的毫秒数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多网站使用一些小文本串在连接之间存储持久的客户端状态，这些小文本串称为Cookie(中文翻译为：小甜点)。Cookie在请求和响应的首部从服务器传到客户端，再从客户端传回服务器，服务器使用Cookie来指示sessionID、购物车内容、登录凭据等。&lt;br/&gt;除了简单的&lt;code&gt;name=value&lt;/code&gt;对，Cookie可以有多个属性来控制它们的作用域,包括过期日期、路径、域、端口、版本和安全选项。&lt;/p&gt;
&lt;p&gt;JDK中java.net.CookieStore类提供了对Cookie的增删查操作，它的默认实现是java.net.InMemoryCookieStore，如果实现CookieStore，JDK中的Cookie默认是存放在内存中的。另外，java.net.CookieManager内部持有CookiePolicy和CookieStore，定义了一系列管理Cookie的方法，一般通过CookieManager操作Cookie，当然也可以通过实现CookieStore，覆盖默认的CookieManager来实现Cookie的自定义管理。&lt;/p&gt;

&lt;p&gt;(本文完 c-2-d e-20181005)&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:52:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>HTTP协议的定义 这篇文章暂时不研究HTTP底层的TCP/IP的握手和挥手过程，只从表面的交互流程分析HTTP协议。 HTTP英文全称是Hypertext Transfer Protpcol，也就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9746384.html</dc:identifier>
</item>
<item>
<title>koa源码解读 - 沧浪一剑</title>
<link>http://www.cnblogs.com/lightzone/p/9746334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lightzone/p/9746334.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;koa是有express原班人马打造的基于node.js的下一代web开发框架。koa 1.0使用generator实现异步，相比于回调简单和优雅和不少。koa团队并没有止步于koa 1.0， 随着node.js开始支持async/await，他们又马不停蹄的发布了koa 2.0，koa2完全使用Promise并配合async/await来实现异步，使得异步操作更臻完美。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一、快速开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;koa使用起来非常简单，安装好node.js后执行以下命令安装koa：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm init&lt;/p&gt;
&lt;p&gt;npm install --save koa&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个简单的Hello World程序开场,&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;//index.js&lt;/p&gt;
&lt;p&gt;const Koa = require('koa')&lt;/p&gt;
&lt;p&gt;const app = new Koa()&lt;/p&gt;

&lt;p&gt;app.use( async ctx  =&amp;gt; {&lt;/p&gt;
&lt;p&gt;ctx.body = 'Hello World'&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;

&lt;p&gt;app.listen(3000,()=&amp;gt;{&lt;/p&gt;
&lt;p&gt;console.log(&quot;server is running at 3000 port&quot;);&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令行执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;node index.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开浏览器查看http://localhost:3000就可以看到页面输出的 Hello World。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中间件 middleware&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Koa中使用 app.use()用来加载中间件，基本上Koa 所有的功能都是通过中间件实现的。&lt;/p&gt;

&lt;p&gt;中间件的设计非常巧妙，多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next函数。只要调用 next函数，就可以把执行权转交给下一个中间件，最里层的中间件执行完后有会把执行权返回给上一级调用的中间件。整个执行过程就像一个剥洋葱的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQxqlKeecNuAkxNic43wOrV6gEOegbhmR2Yboicpg2DEkhLgIOSRSQvIbkSIlKQBaVBgz6RAUIvGLByZhZasePiaw/640?wx_fmt=png&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9100418410041841&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比如你可以通过在所有中间件的顶端添加以下中间件来打印请求日志到控制台：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;app.use(async function (ctx, next) {&lt;/p&gt;
&lt;p&gt;let start = new Date()&lt;/p&gt;
&lt;p&gt;await next()&lt;/p&gt;
&lt;p&gt;let ms = new Date() - start&lt;/p&gt;
&lt;p&gt;console.log('%s %s - %s', ctx.method, ctx.url, ms)&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常用的中间件列表可以在这里找到： https://github.com/koajs/koa/wiki&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、koa源码解读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开项目根目录下的node_modules文件夹，打开并找到koa的文件夹，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cSOoQAk3WeLia3WMgNJQVlUmDiaOKpCH5CHWZjlRALyWIp1znlkGia9lyLqE3Iwa1Jia2LoM0s364YxGFAia2ort4YQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1.4368600682593857&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开lib文件夹，这里一共有4个文件，&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;application.js - koa主程序入口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;context.js - koa中间件参数ctx对象的封装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;request.js - request对象封装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;response.js - response对象封装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这里主要看下application.js，我这里摘取了主要功能相关的 代码如下：&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Shorthand for:&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  *    http.createServer(app.callback()).listen(...)&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @param {Mixed} ...&lt;/p&gt;
&lt;p&gt;  * @return {Server}&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;listen(...args) {&lt;/p&gt;
&lt;p&gt;debug('listen');&lt;/p&gt;
&lt;p&gt;const server = http.createServer(this.callback());&lt;/p&gt;
&lt;p&gt;return server.listen(...args);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Use the given middleware `fn`.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * Old-style middleware will be converted.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @param {Function} fn&lt;/p&gt;
&lt;p&gt;  * @return {Application} self&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;use(fn) {&lt;/p&gt;
&lt;p&gt;if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');&lt;/p&gt;
&lt;p&gt;if (isGeneratorFunction(fn)) {&lt;/p&gt;
&lt;p&gt;deprecate('Support for generators will be removed in v3. ' +&lt;/p&gt;
&lt;p&gt;'See the documentation for examples of how to convert old middleware ' +&lt;/p&gt;
&lt;p&gt;'https://github.com/koajs/koa/blob/master/docs/migration.md');&lt;/p&gt;
&lt;p&gt;fn = convert(fn);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;debug('use %s', fn._name || fn.name || '-');&lt;/p&gt;
&lt;p&gt;this.middleware.push(fn);&lt;/p&gt;
&lt;p&gt;return this;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Return a request handler callback&lt;/p&gt;
&lt;p&gt;  * for node's native http server.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @return {Function}&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;callback() {&lt;/p&gt;
&lt;p&gt;const fn = compose(this.middleware);&lt;/p&gt;

&lt;p&gt;if (!this.listenerCount('error')) this.on('error', this.onerror);&lt;/p&gt;

&lt;p&gt;const handleRequest = (req, res) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;const ctx = this.createContext(req, res);&lt;/p&gt;
&lt;p&gt;return this.handleRequest(ctx, fn);&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;return handleRequest;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Handle request in callback.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @api private&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;handleRequest(ctx, fnMiddleware) {&lt;/p&gt;
&lt;p&gt;const res = ctx.res;&lt;/p&gt;
&lt;p&gt;res.statusCode = 404;&lt;/p&gt;
&lt;p&gt;const onerror = err =&amp;gt; ctx.onerror(err);&lt;/p&gt;
&lt;p&gt;const handleResponse = () =&amp;gt; respond(ctx);&lt;/p&gt;
&lt;p&gt;onFinished(res, onerror);&lt;/p&gt;
&lt;p&gt;return fnMiddleware(ctx).then(handleResponse).catch(onerror);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;通过注释我们可以看出上面代码主要干的事情是初始化http服务对象并启动。我们注意到 callback()方法里面有这样一段代码 :&lt;/p&gt;
&lt;p&gt;const fn = compose(this.middleware);&lt;/p&gt;

&lt;p&gt;compose其实是Node模块koa-compose，它的作用是&lt;strong&gt;将多个中间件函数合并成一个大的中间件函数，然后调用这个中间件函数就可以依次执行添加的中间件函数，执行一系列的任务。遇到await next()时就停止当前中间件函数的执行并把执行权交个下一个中间件函数，最后next()执行完返回上一个中间件函数继续执行下面的代码。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它是用了什么黑魔法实现的呢？我们打开node_modules/koa-compose/index.js，代码如下 ：&lt;/p&gt;
&lt;p&gt;function compose(middleware) {&lt;/p&gt;
&lt;p&gt;    return function (context, next) {&lt;/p&gt;
&lt;p&gt;        // last called middleware #&lt;/p&gt;
&lt;p&gt;        let index = -1&lt;/p&gt;
&lt;p&gt;        return dispatch(0)&lt;/p&gt;
&lt;p&gt;        function dispatch(i) {&lt;/p&gt;
&lt;p&gt;            if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))&lt;/p&gt;
&lt;p&gt;            index = i&lt;/p&gt;
&lt;p&gt;            let fn = middleware[i]&lt;/p&gt;
&lt;p&gt;            if (i === middleware.length) fn = next&lt;/p&gt;
&lt;p&gt;            if (!fn) return Promise.resolve()&lt;/p&gt;
&lt;p&gt;            try {&lt;/p&gt;
&lt;p&gt;                return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));&lt;/p&gt;
&lt;p&gt;            } catch (err) {&lt;/p&gt;
&lt;p&gt;                return Promise.reject(err)&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;乍一看好难好复杂，没事，我们一步一步的来梳理一下。&lt;/p&gt;

&lt;p&gt;这个方法里面的核心就是dispatch函数（废话，整个compose方法就返回了一个函数）。没有办法简写，但是我们可以将dispatch函数类似递归的调用展开，以三个中间件为例：&lt;/p&gt;
&lt;p&gt;第一次，此时第一个中间件被调用，dispatch(0)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, next){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield next();&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;很明显这里的next指向dispatch(1)，那么就进入了第二个中间件；&lt;/p&gt;
&lt;p&gt;第二次，此时第二个中间件被调用，dispatch(1)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, 中间件2){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield Promise.resolve(function(context, next){&lt;/p&gt;
&lt;p&gt;        //中间件二第一部分代码&lt;/p&gt;
&lt;p&gt;        await/yield next();&lt;/p&gt;
&lt;p&gt;        //中间件二第二部分代码&lt;/p&gt;
&lt;p&gt;    }())&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;很明显这里的next指向dispatch(2)，那么就进入了第三个中间件；&lt;/p&gt;
&lt;p&gt;第三次，此时第二个中间件被调用，dispatch(2)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, 中间件2){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield Promise.resolve(function(context, 中间件3){&lt;/p&gt;
&lt;p&gt;        //中间件二第一部分代码&lt;/p&gt;
&lt;p&gt;        await/yield Promise(function(context){&lt;/p&gt;
&lt;p&gt;            //中间件三代码&lt;/p&gt;
&lt;p&gt;        }());&lt;/p&gt;
&lt;p&gt;        //中间件二第二部分代码&lt;/p&gt;
&lt;p&gt;    })&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;此时中间件三代码执行完毕，开始执行中间件二第二部分代码，执行完毕，开始执行中间一第二部分代码，执行完毕，所有中间件加载完毕。&lt;/p&gt;
&lt;p&gt;再举一个例子加深下理解。新建index.js并粘贴如下代码：&lt;/p&gt;
&lt;p&gt;const compose = require('koa-compose')&lt;/p&gt;

&lt;p&gt;const middleware1 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware1, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware1 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middleware2 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware2, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware2 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middleware3 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware3, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware3 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middlewares = compose([middleware1, middleware2, middleware3])&lt;/p&gt;
&lt;p&gt;console.dir(middlewares())&lt;/p&gt;

&lt;p&gt;在命令行输入node index.js执行，输出结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;here is in middleware1, before next:&lt;/p&gt;
&lt;p&gt;here is in middleware2, before next:&lt;/p&gt;
&lt;p&gt;here is in middleware3, before next:&lt;/p&gt;
&lt;p&gt;middleware3 end&lt;/p&gt;
&lt;p&gt;middleware2 end&lt;/p&gt;
&lt;p&gt;middleware1 end&lt;/p&gt;
&lt;p&gt;Promise { undefined }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到每个中间件都按照“剥洋葱”的流程一次执行。当我们初始化app对象并调用app.use()时，就是在不断往app.middleware数组里添加中间件函数，当调用app.listen()再执行组合出来的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-END-&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载请注明来源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫描下方二维码，或者搜索 &lt;span&gt;前端提高班&lt;/span&gt; 关注公众号，即可获取最新走心文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记得把我设为星标或置顶哦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cSOoQAk3WeLia3WMgNJQVlUmDiaOKpCH5CwWEXFC0h07iaBJbWUuaWiaC0IpLSHyDI6dje4TsOZhBzCHy9BN35AzKw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在公众号后台回复 &lt;span&gt;前端资源&lt;/span&gt; 即可获取最新前端开发资源&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:30:00 +0000</pubDate>
<dc:creator>沧浪一剑</dc:creator>
<og:description>koa是有express原班人马打造的基于node.js的下一代web开发框架。koa 1.0使用generator实现异步，相比于回调简单和优雅和不少。koa团队并没有止步于koa 1.0， 随着n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lightzone/p/9746334.html</dc:identifier>
</item>
<item>
<title>我是如何学习数据结构与算法的？ - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9746328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9746328.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;88.38125&quot;&gt;
&lt;p&gt;数据结构与算法的地位对于一个程序员来说不言而喻。今天这篇文章不是来劝你们学习数据结构与算法的，也不是来和你们说数据结构与算法有多重要。&lt;br/&gt;主要是最近几天后台有读者问我是如何学习数据结构与算法的，有没有什么捷径，是要看视频还是看书，去哪刷题等…..而且有些还是大三大四的，搞的我都替你们着急、担心…..&lt;br/&gt;所以我今天就分享下自己平时都是怎么学习的。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;学习算法的捷径就是多刷题&lt;/h4&gt;
&lt;p&gt;说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。&lt;br/&gt;但是，如果你是小白，也就是说，你连常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划这些都没学过，那么，我不建议你去刷题的。而是先去找本书先去学习这些，然后再去刷题。&lt;/p&gt;
&lt;p&gt;也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些基础包括：&lt;br/&gt;1、常见数据结构：链表、树(如二叉树)。&lt;br/&gt;2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。&lt;br/&gt;以上列出来的算是最基本的吧。就是说你刷题之前，要把这些过一遍再去刷题。如果你连这些最基本的都不知道的话，那么你再刷题的过程中，会很难受的，思路也会相对比较少。&lt;br/&gt;总之，千万不要急，先把这些基本的过一遍，力求理解，再去刷题。这些基础的数据结构与算法，我是在大一第二学期学的，我没看视频，我是通过看书学的，那时候看的书是：&lt;br/&gt;1、算法分析与分析基础：这本比较简单，推荐新手看。&lt;br/&gt;2、数据结构与算法分析—-C语言描述：代码用C写的，推荐看。&lt;br/&gt;3、挑战程序设计竞赛(第二版)：也是很不错的一本书，推荐看。&lt;br/&gt;具体可以看我的另外一篇文章，里面是介绍这几本书的：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ckhKXayxxxJHJotoaoWHDg&quot;&gt;算法与数据结构书籍与视频福利&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话，我那一学期的时间几乎都花在数据结构与算法上，但刷的题很少，只是书本上的一些例题。所以当我把这些基本的过一遍之后，再去一些网站刷题依旧非常菜。&lt;br/&gt;所以你们千万别指望以为自己把这些思想学完之后刷题会很牛，只有多刷题，只有多动手实践，你的灵敏度才会提高起来。&lt;br/&gt;在这里说一下前阵子有个非常火爆的专栏—-【数据结构与算法之美】&lt;/p&gt;
&lt;p&gt;我没买这个专栏，我想说的是，买了就一定要去看，千万别浪费。也千万不要觉得学完这个专栏你就会变的多牛逼，如果你只是跟着进度去学习这个专栏，自己没有花时间去刷题、去动手时间。那我可以保证，你学完之后还是那么菜。&lt;br/&gt;总结下：&lt;br/&gt;提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;追求完美&lt;/h4&gt;
&lt;p&gt;如何刷题？如何对待一道算法题？&lt;br/&gt;我觉得，在做题的时候，一定要&lt;strong&gt;追求完美&lt;/strong&gt;，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。&lt;br/&gt;算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。&lt;br/&gt;我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用&lt;strong&gt;暴力法&lt;/strong&gt;都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。&lt;br/&gt;衡量一道算法题的好坏无非就是&lt;strong&gt;时间复杂度&lt;/strong&gt;和&lt;strong&gt;空间复杂度&lt;/strong&gt;，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。&lt;br/&gt;我举道例题吧：&lt;br/&gt;&lt;strong&gt;问题：&lt;/strong&gt; 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;br/&gt;这道题我在以前的分章分析过，不懂的可以先看下之前写的：&lt;a href=&quot;https://mp.weixin.qq.com/s/_KRK7_Xtx11aSiXV5h6zIQ&quot;&gt;递归与动态规划—-基础篇1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1：&lt;/strong&gt;：暴力递归&lt;br/&gt;这道题不难，或许你会采取下面的做法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static int solve(int n){
    if(n == 1 || n == 2){
        return 1;
    }else if(n &amp;lt;= 0){
        return 0;
    }else{
        return solve(n-1) + solve(n-2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种做法的时间复杂度很高，指数级别了。但是如果你提交之后侥幸通过了，然后你就接着下一道题了，那么你就要好好想想了。&lt;br/&gt;&lt;strong&gt;方法二&lt;/strong&gt;：空间换时间&lt;br/&gt;&lt;strong&gt;力求完美&lt;/strong&gt;，我们可以考虑用空间换时间：这道题如何你去仔细想一想，会发现有很多是重复执行了。所以可以采取下面的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//用一个HashMap来保存已经计算过的状态
static Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap();
public static int solve(int n){
    if(n &amp;lt;= 0)return 0;
    else if(n &amp;lt;= 2){
        return 1;
    }else{//是否计算过
        if(map.containsKey(n)){
            return map.get(n);
        }else{
            int m = solve(n-1) + solve(n-2);
            map.put(n, m);
            return m;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，可以大大缩短时间。也就是说，当一道题你做了之后，发现时间复杂度很高，那么可以考虑下，是否有更好的方法，是否可以用空间换时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;：斐波那契数列&lt;br/&gt;实际上，我们可以把空间复杂度弄的更小，不需要HashMap来保存状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static int solve(int n){
    if(n &amp;lt;= 0)
       return 0;
    if(n &amp;lt;= 2){
        return 1;
    }

    int f1 = 0;
    int f2 = 1;
    int sum = 0;
    for(int i = 1; i&amp;lt;= n; i++){
        sum = f1 + f2;
        f1 = f2;
        f2 = sum;
    }
    return sum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：&lt;br/&gt;1、在刷题的时候，我们要力求完美。&lt;br/&gt;2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。&lt;br/&gt;3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;推荐一些刷题网站&lt;/h4&gt;
&lt;p&gt;我一般是在leetcode和牛客网刷题，感觉挺不错，题目难度不是很大。&lt;br/&gt;在牛客网那里，我主要刷剑指Offer,不过那里也有个在线刷leetcode，不过里面的题量比较少。牛客网刷题有个非常方便的地方就是有个讨论区，那里会有很多大佬分享他们的解题方法，不用我们去百度找题解。所以你做完后，实在想不出，可以很方便着去看别人是怎么做的。&lt;br/&gt;至于leetcode，也是大部分题目官方都有给出答案，也是个不错的刷题网站。你们可以两个挑选一个，或者两个都刷。&lt;br/&gt;当然，还有其他刷题的网站，不过，其他网站没刷过，不大清除如何。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;再说数据结构&lt;/h4&gt;
&lt;p&gt;前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习&lt;strong&gt;链表&lt;/strong&gt;和&lt;strong&gt;树(二叉堆)&lt;/strong&gt;，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：&lt;br/&gt;1、链表（如单向链表、双向链表）。&lt;br/&gt;2、树（如二叉树、平衡树、红黑树）。&lt;br/&gt;3、图（如最短路径的几种算法）。&lt;br/&gt;4、队列、栈、矩阵。&lt;br/&gt;对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。&lt;br/&gt;视频和书我以前有推荐过：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ckhKXayxxxJHJotoaoWHDg&quot;&gt;算法与数据结构书籍与视频福利&lt;/a&gt;&lt;br/&gt;例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;最最重要&lt;/h4&gt;
&lt;p&gt;动手去做，动手去做，动手去做。重要的话说三遍。&lt;br/&gt;千万不要找了一堆资源，订好了学习计划，我要留到某某天就来去做…..&lt;br/&gt;千万不要这样，而是当你激情来的时候，就马上去干，千万不要留到某个放假日啊什么鬼了，很多这种想法的人，最后会啥也没做的。&lt;br/&gt;也不要觉得要学习的有好多啊，不知道从哪学习起。我上面说了，可以先学习最基本的，然后刷题，刷题是一个需要长期坚持的事情，一年，两年。在刷题的过程中，可以穿插和学习其他数据结构。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;今天就说这么多，以上主要是我自己的学习方法，希望对你有所帮助。&lt;br/&gt;对了，我很久之前就建过一个交流群，不过该群还是挺安静的，我也很少提到，如果你想加入，公众号右下方有加入方式。你有什么问题，可以在群里提问，我看到的话，会尽量解答。&lt;br/&gt;最后说下我这个公众号(&lt;strong&gt;苦逼的码农&lt;/strong&gt;)，我主要写【计算机网络】、【数据结构与算法】、【Java】。一般90%都会是原创的，偶尔有些转载的文章，只会比我自己写的文章更好。&lt;br/&gt;一般我会一阵子更新这个模块、一阵子更新另一个模块的方式来写文章。&lt;br/&gt;如果你觉得有帮助，可以分享给更多的朋友哦，这便是对我最大的支持 。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本公众号（&lt;strong&gt;苦逼的码农&lt;/strong&gt;）专注于写【Java】、【计算机网络】、【数据结构与算法】，期待你加入交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>数据结构与算法的地位对于一个程序员来说不言而喻。今天这篇文章不是来劝你们学习数据结构与算法的，也不是来和你们说数据结构与算法有多重要。主要是最近几天后台有读者问我是如何学习数据结构与算法的，有没有什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9746328.html</dc:identifier>
</item>
<item>
<title>为什么JAVA对象需要实现序列化？ - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9746310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9746310.html</guid>
<description>&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;序列化是一种用来&lt;code&gt;处理对象流&lt;/code&gt;的机制。&lt;/p&gt;
&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所谓对象流：就是将对象的内容进行流化。可以对流化后的对象&lt;code&gt;进行读写操作&lt;/code&gt;，也可将流化后的对象&lt;code&gt;传输于网络&lt;/code&gt;之间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;序列化是为了解决在对对象流进行读写操作时所引发的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;序列化的实现：将需要被序列化的类实现&lt;code&gt;Serializable接口(标记接口)&lt;/code&gt;，该接口没有需要实现的方法，implements Serializable只是为了&lt;code&gt;标注&lt;/code&gt;该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象；接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么时候使用序列化呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一：对象序列化可以&lt;code&gt;实现分布式对象&lt;/code&gt;。&lt;br/&gt;主要应用例如：&lt;code&gt;RMI(即远程调用Remote Method Invocation)&lt;/code&gt;要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。&lt;/li&gt;
&lt;li&gt;二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。&lt;br/&gt;可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的&quot;&lt;strong&gt;深复制&lt;/strong&gt;&quot;，即&lt;code&gt;复制对象本身及引用的对象本身&lt;/code&gt;。序列化一个对象可能得到整个对象序列。&lt;/li&gt;
&lt;li&gt;三：序列化可以将内存中的类写入文件或数据库中。&lt;br/&gt;比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据&lt;code&gt;反序列化&lt;/code&gt;就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是&lt;code&gt;将一个已经实例化的类转成文件存储&lt;/code&gt;，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。&lt;/li&gt;
&lt;li&gt;四： 对象、文件、数据，有许多不同的格式，很难统一传输和保存。&lt;br/&gt;序列化以后就都是字节流了，无论原来是什么东西，都能&lt;code&gt;变成一样的东西&lt;/code&gt;，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因为JAVA中要将对象序列化为 &lt;code&gt;流的形式&lt;/code&gt; 进行传输。&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:21:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>序列化是一种用来处理对象流的机制。 所谓对象流：就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决在对对象流进行读写操作时所引发的问题。 序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9746310.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用表达式树创建URL - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9746274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9746274.html</guid>
<description>&lt;p&gt;当我们在ASP.NET Core中生成一个action的url会这样写：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var url=_urlHelper.Action(&quot;Index&quot;, &quot;Home&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的写法存在的问题在于我们传递了两个字符串类型的参数，而我们又无法避免对action和controller做重命名操作, 例如将index重命名为default, 你无法通过IDE在重命名action的过程中，将&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;_urlHelper.Action(&quot;Index&quot;, &quot;Home&quot;); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重构为&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;UrlHelper.Action(&quot;Default&quot;, &quot;Home&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们的目标是：设计出具有静态检查的API，让IDE提示出这个错误来，甚至是重命名时直接把相关代码都能重命名。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;设计出类似两组API:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var url = _urlHelper.Action((HomeController c) =&amp;gt; c.Index());
//期待输出 /home/index
var link = _urlHelper.Link((ProductController c) =&amp;gt; c.Details(10));
//期待输出 http://locahost/product/details/10&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设计api&quot;&gt;设计API&lt;/h2&gt;
&lt;p&gt;根据上面的需求，定义两组API:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static string Action&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action)
where TController : Controller
{
   //实现
}

public static string Link&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action,
string protocal = null, string host = null)
where TController : Controller
{
   //实现
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现api&quot;&gt;实现API&lt;/h2&gt;
&lt;p&gt;我们实际上最终还是要依赖ASP.NET Core提供的API：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var link = helper.Action(action: actionName, controller: 
controllerName, values: routes);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以问题变成了如何根据(HomeController c) =&amp;gt; c.Index()这样的表达式来解析出actionName, ControllerName以及routeValues。&lt;/p&gt;
&lt;h3 id=&quot;解析controllername&quot;&gt;1. 解析ControllerName&lt;/h3&gt;
&lt;p&gt;解析ControllerName比较简单粗暴，因为我们已经从表达式树中得到了HomeController这个类型，直接取&lt;code&gt;Home&lt;/code&gt;字符串即可：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static string GetControllerName(Type controllerType)
{
    var controllerName = controllerType.Name.EndsWith(&quot;Controller&quot;)
        ? controllerType.Name.Substring(0,
        controllerType.Name.Length - &quot;Controller&quot;.Length)
        : controllerType.Name;
    return controllerName;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析actionname&quot;&gt;2. 解析ActionName&lt;/h3&gt;
&lt;p&gt;由于表达式&lt;code&gt;(HomeController c) =&amp;gt; c.Index()&lt;/code&gt;是一个&lt;code&gt;MethodCallExpression&lt;/code&gt;类型，而Action的名字就是方法名：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static MethodCallExpression
GetMethodCallExpression&amp;lt;TController&amp;gt;(
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; actionSelector)
{
    var call = actionSelector.Body as MethodCallExpression;
    if (call == null)
    {
        throw new ArgumentException(&quot;You must call a method on &quot; +
        typeof(TController).Name, &quot;actionSelector&quot;);
    }
    
    return call;
}

var methodCallExpression = GetMethodCallExpression(action);
var actionName = methodCallExpression.Method.Name;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析routevalues&quot;&gt;3. 解析RouteValues&lt;/h3&gt;
&lt;p&gt;上面两步已经解析出了ControllerName和ActionName，也就是说通过上面的分析已经能完成下面的调用：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = helper.Action(action: &quot;index&quot;, controller: &quot;home&quot;, values: null);
//等价于
var url = _urlHelper.Action((HomeController c) =&amp;gt; c.Index());
//输出 /home/index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是考虑下面的Action：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[HttpGet,Route(&quot;product/{id}&quot;)]
public IActionResult Details(int id)
{
   //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Action期待传入一个int类型的id，也就是说你要通过这样的方式来生成url:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = helper.Action(action: &quot;details&quot;, controller: 
&quot;product&quot;, values: new { id = 10 });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以要想让我们的API正常工作，还需要生成一个object类型：new { id = 10 }。而这个object类型里面的属性正好可以来自于表达式树的方法调用参数：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = _urlHelper.Action((ProductController c) =&amp;gt; c.Details(10));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想生成这个匿名对象，需要遍历方法调用表达式的所有参数，分别解析出属性名，例如id; 以及值，例如10。最后再把解析出来的参数字典生成为dynamic类型的对象：&lt;br/&gt;如何解析表达式树请查看&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/&quot;&gt;expression-trees&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RouteValueExtractor
{
    public static object GetRouteValues(MethodCallExpression call)
    {
        var routes = new Dictionary&amp;lt;string, object&amp;gt;();

        var parameters = call.Method.GetParameters();
        var pairs = call.Arguments.Select((a, i) =&amp;gt; new
        {
            Argument = a,
            ParamName = parameters[i].Name
        });
        foreach (var item in pairs)
        {
            string name = item.ParamName;
            object value = GetValue(item.Argument);
            if (value != null)
            {
                var valueType = value.GetType();
                if (valueType.IsValueType)
                {
                    routes.Add(name, value);
                }
                else
                {
                    throw new NotSupportedException(&quot;Unsupported parameter type {0}&quot;);
                }

            }
        }

        return DictionaryToObject(routes);
    }

    private static object GetValue(Expression expression)
    {
        if (expression.NodeType == ExpressionType.Constant)
        {
            return ((ConstantExpression) expression).Value;
        }

        throw new NotSupportedException(&quot;Unsupported parameter expression&quot;);
    }

    private static dynamic DictionaryToObject(IDictionary&amp;lt;string, object&amp;gt; dictionary)
    {
        var expandoObj = new ExpandoObject();
        var expandoObjCollection = (ICollection&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;) expandoObj;

        foreach (var keyValuePair in dictionary)
        {
            expandoObjCollection.Add(keyValuePair);
        }

        dynamic eoDynamic = expandoObj;
        return eoDynamic;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个完整的API实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static string Action&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action)
where TController : Controller
{
    var controllerName = GetControllerName(typeof(TController));
    var methodCallExpression = GetMethodCallExpression(action);
    var actionName = methodCallExpression.Method.Name;

    var routes = RouteValueExtractor.GetRouteValues(methodCallExpression);

    var link = helper.Action(action: actionName, controller: 
    controllerName, values: routes);

    return link;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Oct 2018 15:17:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>当我们在ASP.NET Core中生成一个action的url会这样写： 这样的写法存在的问题在于我们传递了两个字符串类型的参数，而我们又无法避免对action和controller做重命名操作, 例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9746274.html</dc:identifier>
</item>
<item>
<title>JavaSE集合基础总览 - 秀常</title>
<link>http://www.cnblogs.com/byuc/p/9744060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byuc/p/9744060.html</guid>
<description>&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 举例部分Collections的算法排序，具体看API
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Collections {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         List l1 = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             l1.add(&quot;a&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         * 目前l1的值排序为： [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Collections.reverse(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逆序排序&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a9,a8,a7,a6,a5,a4,a3,a2,a1,a0]&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         Collections.shuffle(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机排序&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a1,a3,a8,a9,a4,a6,a5,a2,a0,a7]&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Collections.sort(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正序排序&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9]&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         System.out.println(Collections.binarySearch(l1, &quot;a5&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Oct 2018 15:09:00 +0000</pubDate>
<dc:creator>秀常</dc:creator>
<og:description>Java集合 Java集合，也称之为容器。基本上你写所有的Java程序，都必须要用到一个包。该API基本都位于java.util工具类包中，是JavaSE中的重中之重。简单可以总结为“1136”，分别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/byuc/p/9744060.html</dc:identifier>
</item>
<item>
<title>MIT-6.828  环境搭建 - 活在未来的人</title>
<link>http://www.cnblogs.com/gatsby123/p/9746193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/9746193.html</guid>
<description>&lt;p&gt;MIT 6.828是操作系统中最经典的一门课程。完成所有的lab就相当于完成了一个迷你的操作系统。我跟的是2018年的课程，课程首页在&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/schedule.html&quot; title=&quot;6.828课程官网&quot;&gt;6.828课程官网&lt;/a&gt;。当然所有资料都是英文的，所以难度也不低，这里推荐几本非常有用的参考书：《x86汇编语言-从实模式到保护模式》，《程序员的自我修养-链接、装载与库》，《深入理解计算机系统》，很多知识在这些书中都有提到，参考着看会有奇效。&lt;/p&gt;
&lt;h2 id=&quot;一段话概括&quot;&gt;一段话概括&lt;/h2&gt;
&lt;p&gt;本文主要讲解实验前的环境搭建，主要分为两个部分，一个是x86模拟器QEMU的安装，另一个是编译工具链。参考资料：&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labguide.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验环境&quot;&gt;实验环境&lt;/h2&gt;
&lt;p&gt;我的机子装的win10的系统，现在win10支持&lt;a href=&quot;https://baike.baidu.com/item/wsl/20359185?fr=aladdin&quot; title=&quot;WSL&quot;&gt;WSL&lt;/a&gt;，在windows上也能享受到原生linux一样的体验。我一般用&lt;a href=&quot;https://baike.baidu.com/item/Xshell/5659054?fr=aladdin&quot; title=&quot;Xshell&quot;&gt;Xshell&lt;/a&gt;登陆本地WSL，体验很不错。&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;前期准备&lt;/h2&gt;
&lt;p&gt;首先从官网clone实验的框架代码到本地：&lt;code&gt;git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;编译工具链&quot;&gt;编译工具链&lt;/h2&gt;
&lt;p&gt;编译工具链是一个工具集包括c编译器，汇编编译器，连接器。在命令行下执行&lt;code&gt;gcc -m32 -print-libgcc-file-name&lt;/code&gt;，如果输出&lt;code&gt;/usr/lib/gcc/i486-linux-gnu/version/libgcc.a 或 /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a&lt;/code&gt;就说明没有问题了。否则执行&lt;code&gt;sudo apt-get install -y build-essential gdb&lt;/code&gt;进行安装（Ubuntu系统下）。在64位的机器上还需要安装32位支持库&lt;code&gt;sudo apt-get install gcc-multilib&lt;/code&gt;否则后面make的时候可能会出现&quot;__udivdi3 not found&quot;的情况。&lt;/p&gt;
&lt;h2 id=&quot;qemu模拟器安装&quot;&gt;QEMU模拟器安装&lt;/h2&gt;
&lt;p&gt;QEMU是一款模拟器，按照&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labguide.html&quot;&gt;官方文档&lt;/a&gt;的提示我们需要从源码安装针对课程定制过的QEMU。步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;clone源码：git clone &lt;a href=&quot;https://github.com/mit-pdos/6.828-qemu.git&quot; class=&quot;uri&quot;&gt;https://github.com/mit-pdos/6.828-qemu.git&lt;/a&gt; qemu （或git clone &lt;a href=&quot;http://web.mit.edu/ccutler/www/qemu.git&quot; class=&quot;uri&quot;&gt;http://web.mit.edu/ccutler/www/qemu.git&lt;/a&gt; -b 6.828-2.3.0）&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;./configure --disable-kvm --target-list=&quot;i386-softmmu x86_64-softmmu&quot;&lt;/code&gt;。这一步可能会报错：
&lt;ol&gt;&lt;li&gt;问题1：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: Python not found. Use --python=/path/to/python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：添加&lt;code&gt;--python=python3&lt;/code&gt;，还是不行提示&lt;code&gt;Note that Python 3 or later is not yet supported&lt;/code&gt;。安装python2.7，然后使用&lt;code&gt;--python2.7&lt;/code&gt;选项&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题2：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: pkg-config binary 'pkg-config' not found&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：执行&lt;code&gt;apt-get install -y pkg-config&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题3：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: zlib check failed. Make sure to have the zlib libs and headers installed.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：执行&lt;code&gt;sudo apt-get install zlib1g-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题4：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: glib-2.12 gthread-2.0 is required to compile QEMU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：&lt;code&gt;sudo apt-get install libglib2.0-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题5：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: pixman &amp;gt;= 0.21.8 not present.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：&lt;code&gt;sudo apt-get install libpixman-1-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题6：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;vl.c: In function ‘main’: vl.c:2778:5: error: ‘g_mem_set_vtable’ is deprecated [-Werror=deprecated-declarations] g_mem_set_vtable(&amp;amp;mem_trace); ^ In file included from /usr/include/glib-2.0/glib/glist.h:32:0, from /usr/include/glib-2.0/glib/ghash.h:33, from /usr/include/glib-2.0/glib.h:50, from vl.c:59: /usr/include/glib-2.0/glib/gmem.h:357:7: note: declared here void g_mem_set_vtable (GMemVTable *vtable); ^ cc1: all warnings being treated as errors rules.mak:57: recipe for target 'vl.o' failed make: *** [vl.o] Error 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：QEMU源码根目录下的Makefile文件最后加上一行 QEMU_CFLAGS+=-w&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;。至此QEMU安装完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在lab源码根目录下执行make，如果看到&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499627/201810/1499627-20181005224752678-357941935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就说明编译成功了。然后执行make qume，看到如下信息就说明环境搭建好了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499627/201810/1499627-20181005224808107-1782243723.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 14:52:00 +0000</pubDate>
<dc:creator>活在未来的人</dc:creator>
<og:description>MIT 6.828是操作系统中最经典的一门课程。完成所有的lab就相当于完成了一个迷你的操作系统。我跟的是2018年的课程，课程首页在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/9746193.html</dc:identifier>
</item>
<item>
<title>设计模式——建造者模式 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前在家看两个小外甥玩轨道车，拆开包装，一堆小零件，兄弟两一个拼桥梁、弯道、路标，一个装车、搭立交、组装上下坡。不一会儿轨道就全拼好了，两兄弟用代表自己的车子在轨道上追逐，玩的很开心。我看了下轨道车包装，根据使用零件多少不同，组拼顺序不同，摆放不同可以创建不同的轨道和街道，有椭圆形的，上下立交式的，单层的……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;忽然想到用程序来表述玩轨道车的流程，如果用类图描述轨道车的玩法，可以简单表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005151722141-1784167619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分为两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红色为轨道车的各个部件，Road规定了轨道车可以有 坡度、弯道、桥梁、路标、汽车、立交这几个部分；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝色部分为建造不同的轨道，环形轨道（AnnularBuilder）和立交轨道（InterchangeBuilder）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Road为模板方法的变形形式，轨定轨道车的部件和各个部件的组装顺序，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Road {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;坡度&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; slope();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弯道&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; curve();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bridge();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路标&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; guide();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汽车&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; car();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立交&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interchange();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; create() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        Method[] methods &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().&lt;span&gt;getDeclaredMethods&lt;/span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String method : list) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; methods.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (methods[i].getName().equals(method)) {
                    methods[i].invoke(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setList(List&amp;lt;String&amp;gt;&lt;span&gt; methods){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; methods;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组装轨道车的部件实现方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TrackRoad &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Road {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;坡度&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; slope() {
        System.out.println(&lt;/span&gt;&quot;建造上下坡……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弯道&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; curve() {
        System.out.println(&lt;/span&gt;&quot;建造曲线车道……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bridge() {
        System.out.println(&lt;/span&gt;&quot;建造桥梁……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路标&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; guide() {
        System.out.println(&lt;/span&gt;&quot;放置公路路标……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汽车&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; car() {
        System.out.println(&lt;/span&gt;&quot;建造汽车……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立交&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interchange() {
        System.out.println(&lt;/span&gt;&quot;建造立交……&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽象创建轨道车类Builder定义了轨道车的组装部件和获取组装的轨道车&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Builder {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 不同部件的创建
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPart(List&amp;lt;String&amp;gt;&lt;span&gt; methods);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 建造轨道
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; TrackRoad buildRoad() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体轨道车玩法建造类（立交轨道车）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterchangeBuilder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Builder {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; TrackRoad road = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackRoad();
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPart(List&amp;lt;String&amp;gt;&lt;span&gt; methods) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.road.setList(methods);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad buildRoad() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.road;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想创建一个立交轨道，可以这么创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
InterchangeBuilder interchangeBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterchangeBuilder();
List&lt;/span&gt;&amp;lt;String&amp;gt; interMethods = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
interMethods.add(&lt;/span&gt;&quot;slope&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;bridge&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;guide&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;interchange&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;car&quot;&lt;span&gt;);
interchangeBuilder.setPart(interMethods);
interchangeBuilder.buildRoad().create();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;建造上下坡……&lt;br/&gt;建造桥梁……&lt;br/&gt;放置公路路标……&lt;br/&gt;建造立交……&lt;br/&gt;建造汽车……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;引入导演类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;坡度、弯道、桥梁、路标、汽车、立交不同组装方式可以构造不同的轨道，为了方便&lt;/span&gt;支持的很多不同的轨道，可以增加个导演类（Director）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005173408946-318885490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导演类封装立交轨道和环形轨道的实现，对外提供直接获取的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Director {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; steps = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; InterchangeBuilder interchangeBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterchangeBuilder();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AnnularBuilder annularBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnularBuilder();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad getInterchangeBuilder(){
        System.out.println(&lt;/span&gt;&quot;===========================建造立交车道===========================&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps.clear();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;slope&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;bridge&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;guide&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;interchange&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;car&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interchangeBuilder.setPart(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interchangeBuilder.buildRoad();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad getAnnularBuilder(){
        System.out.println(&lt;/span&gt;&quot;===========================建造曲线车道===========================&quot;&lt;span&gt;);&lt;br/&gt;　　　　 this.steps.clear();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;curve&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;bridge&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;guide&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;car&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.annularBuilder.setPart(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.annularBuilder.buildRoad();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端不关注如何实现，只需要拿来即用（可玩）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testDerictor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        Director director &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Director();
        director.getAnnularBuilder().create();

        director.getInterchangeBuilder().create();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实这就是建造者模式，由导演类决定如何构建具体的对象（产品）。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;建造者模式&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005144118361-1938243474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四要素&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;建造者模式中有以下4个角色：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Product产品类&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;通常是实现模板方法模式（有模板方法和基本方法的类），例子里的&lt;span&gt;TrackRoad（轨道）&lt;/span&gt;就属于产品类。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Builder抽象建造者&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;规范产品的组建，一般是抽象类，约定功能由子类去实现具体的建造方法，对应例子里的Builder。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;ConcreteBuilder具体建造者&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;实现抽象建造者的所有方法。例子里的InterchangeBuilder和AnnularBuilder就是具体轨道的建造者。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Director导演类&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;封装具体建造者，提供简单易用的构建产品类方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;封装性：将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者独立，容易扩展：增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;相同的方法，不同的执行顺序，产生不同的事件结果时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 05 Oct 2018 14:14:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>引言 之前在家看两个小外甥玩轨道车，拆开包装，一堆小零件，兄弟两一个拼桥梁、弯道、路标，一个装车、搭立交、组装上下坡。不一会儿轨道就全拼好了，两兄弟用代表自己的车子在轨道上追逐，玩的很开心。我看了下轨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</dc:identifier>
</item>
<item>
<title>浅谈移动端中的视口（viewport） - yuduxyz</title>
<link>http://www.cnblogs.com/yuduxyz/p/9745962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuduxyz/p/9745962.html</guid>
<description>&lt;p&gt;在 PC 端，视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。在 CSS 标准文档中，视口也被称为初始包含块，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度。&lt;/p&gt;
&lt;p&gt;而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。&lt;/p&gt;
&lt;p&gt;本文主要讨论移动端中的视口。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;1. 基本概念&lt;/h3&gt;
&lt;h4 id=&quot;两种像素&quot;&gt;1.1 两种像素&lt;/h4&gt;
&lt;p&gt;像素是计算机屏幕中显示特定颜色的最小区域。屏幕中的像素越多，同一范围内能看到的内容就越多。或者说，当设备尺寸相同时，像素越密集，画面就越精细。&lt;/p&gt;
&lt;p&gt;那么，当我们在 CSS 中为一个元素设置属性 &lt;code&gt;width: 250px;&lt;/code&gt; 时，会发生什么？这个元素的宽度究竟是多少像素呢？&lt;/p&gt;
&lt;p&gt;事实上，这里已经涉及了两种不同的像素：物理像素和 CSS 像素。&lt;/p&gt;
&lt;h5 id=&quot;物理像素设备像素device-pixels&quot;&gt;物理像素（设备像素，device pixels）&lt;/h5&gt;
&lt;p&gt;指的是设备屏幕的物理像素，任何设备的物理像素数量都是固定的。&lt;/p&gt;
&lt;h5 id=&quot;css-像素css-pixels&quot;&gt;CSS 像素（CSS pixels）&lt;/h5&gt;
&lt;p&gt;是 CSS 和 JS 中使用的一个抽象概念。它和物理像素之间的比例取决于屏幕的特性（是否为高密度）以及用户进行的缩放，由浏览器自行换算。&lt;/p&gt;
&lt;p&gt;在 Apple 的视网膜屏（Retina）中，每 4 个像素为一组，渲染出普通屏幕中一个像素显示区域内的图像，从而实现更为精细的显示效果。此时， 250px 的元素跨越了 500 个物理像素的宽度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/166435cbbd90a175?w=515&amp;amp;h=286&amp;amp;f=jpeg&amp;amp;s=24159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果用户进行了放大，那么一个 CSS 像素还将跨越更多的物理像素。&lt;/p&gt;
&lt;h4 id=&quot;三种视口&quot;&gt;1.2 三种视口&lt;/h4&gt;
&lt;p&gt;移动端浏览器通常宽度是 240px~640px，而大多数为 PC 端设计的网站宽度至少为 800px，如果仍以浏览器窗口作为视口的话，网站内容在手机上看起来会非常窄。&lt;/p&gt;
&lt;p&gt;因此，引入了布局视口、视觉视口和理想视口三个概念，使得移动端中的视口与浏览器宽度不再相关联。&lt;/p&gt;
&lt;h5 id=&quot;布局视口layout-viewport&quot;&gt;布局视口（layout viewport）&lt;/h5&gt;
&lt;p&gt;一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport），用于解决早期的页面在手机上显示的问题。iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页基本能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/166437dad52855dc?w=336&amp;amp;h=285&amp;amp;f=png&amp;amp;s=51213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;布局视口的宽度/高度可以通过 &lt;code&gt;document.documentElement.clientWidth / Height&lt;/code&gt; 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/166438178a342bba?w=1090&amp;amp;h=413&amp;amp;f=png&amp;amp;s=29912&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，默认的布局视口宽度为 980px。如果要显式设置布局视口，可以使用 HTML 中的 meta 标签：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=400&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/1664385fa84fc26d?w=1307&amp;amp;h=511&amp;amp;f=png&amp;amp;s=79210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。&lt;/p&gt;
&lt;h5 id=&quot;视觉视口visual-viewport&quot;&gt;视觉视口（visual viewport）&lt;/h5&gt;
&lt;p&gt;视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16643994a5a962cf?w=323&amp;amp;h=292&amp;amp;f=png&amp;amp;s=50158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视觉视口和缩放比例的关系为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前缩放值 = 理想视口宽度  / 视觉视口宽度&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，当用户放大时，视觉视口将会变小，CSS 像素将跨越更多的物理像素。&lt;/p&gt;
&lt;h5 id=&quot;理想视口ideal-viewport&quot;&gt;理想视口（ideal viewport）&lt;/h5&gt;
&lt;p&gt;布局视口的默认宽度并不是一个理想的宽度，于是 Apple 和其他浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。&lt;/p&gt;
&lt;p&gt;理想视口的值其实就是屏幕分辨率的值，它对应的像素叫做设备逻辑像素（device independent pixel, dip）。dip 和设备的物理像素无关，一个 dip 在任意像素密度的设备屏幕上都占据相同的空间。如果用户没有进行缩放，那么一个 CSS 像素就等于一个 dip。&lt;/p&gt;
&lt;p&gt;用下面的方法可以使布局视口与理想视口的宽度一致：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，这就是响应式布局的基础。&lt;/p&gt;
&lt;h3 id=&quot;视口的设置&quot;&gt;2. 视口的设置&lt;/h3&gt;
&lt;p&gt;我们可以使用视口元标签（viewport meta 标签）来进行布局视口的设置。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot;
    content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是每个属性的详细说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;取值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;正整数或device-width&lt;/td&gt;
&lt;td&gt;定义视口的宽度，单位为像素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;正整数或device-height&lt;/td&gt;
&lt;td&gt;定义视口的高度，单位为像素，一般不用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;initial-scale&lt;/td&gt;
&lt;td&gt;[0.0-10.0]&lt;/td&gt;
&lt;td&gt;定义初始缩放值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;minimum-scale&lt;/td&gt;
&lt;td&gt;[0.0-10.0]&lt;/td&gt;
&lt;td&gt;定义放大最大比例，它必须小于或等于maximum-scale设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;maximum-scale&lt;/td&gt;
&lt;td&gt;[0.0-10.0]&lt;/td&gt;
&lt;td&gt;定义缩小最小比例，它必须大于或等于minimum-scale设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;user-scalable&lt;/td&gt;
&lt;td&gt;yes / no&lt;/td&gt;
&lt;td&gt;定义是否允许用户手动缩放页面，默认值 yes&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有几点值得注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的&lt;/li&gt;
&lt;li&gt;当缩放比例为 100% 时，dip 宽度 = CSS 像素宽度 = 理想视口的宽度 = 布局视口的宽度&lt;/li&gt;
&lt;li&gt;单独设置 initial-scale 或 width 都会有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性&lt;/li&gt;
&lt;li&gt;即使设置了 user-scalable = no，在 Android Chrome 浏览器中也可以强制启用手动缩放&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一倍图二倍图三倍图&quot;&gt;3. 一倍图、二倍图、三倍图&lt;/h3&gt;
&lt;p&gt;MacBook Pro 视网膜屏（Retina）显示器硬件像素是 2880px * 1800px。当设置屏幕分辨率为 1920px * 1200px 的时候，理想视口的宽度值是 1920px， 那么 dip 的宽度值就是 1920px。其与理想视口宽度的比值为1.5（2880/1920），这个比值叫做设备像素比：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;逻辑像素宽度 * 设备像素比 = 物理像素宽度&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设备像素比可以通过 &lt;code&gt;window.devicePixelRatio&lt;/code&gt; 来获取，或者使用 CSS 中的 &lt;code&gt;device-pixel-ratio&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是常见的设备像素比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;普通密度桌面显示屏：&lt;code&gt;devicePixelRatio = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;高密度桌面显示屏(Mac Retina)：&lt;code&gt;devicePixelRatio = 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主流手机显示屏：&lt;code&gt;devicePixelRatio = 2 or 3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一张 100px * 100px 的图片，通过 CSS 设置其宽高：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;{
    width:100px;
    height:100px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在普通显示屏的电脑中打开是正常的，但假设在手机或 Retina 屏中打开，按照逻辑分辨率来渲染，他们的 &lt;code&gt;devicePixelRatio = 2&lt;/code&gt;，那么就相当于拿 4 个物理像素来描绘 1 个电子像素。这等于拿一个2倍的放大镜去看图片，图片就会变得模糊。&lt;/p&gt;
&lt;p&gt;这时，就需要使用 @2x 甚至 @3x 图来避免图片的失真。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后，本文仅涉及了移动端开发中视口的基本概念，具体细节可以参考 PPK 的大作&lt;a href=&quot;http://u.jd.com/hBKdGB&quot;&gt;《移动Web手册》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS：电子版可关注公众号《代码写完了》，发送&quot;ppk&quot;获取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/5/16643f242698ae46?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27063&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 13:31:00 +0000</pubDate>
<dc:creator>yuduxyz</dc:creator>
<og:description>在 PC 端，视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。在 CSS 标准文档中，视口也被称为初始包含块，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuduxyz/p/9745962.html</dc:identifier>
</item>
<item>
<title>TCP协议学习总结（下） - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/9743656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/9743656.html</guid>
<description>&lt;p&gt;&lt;span&gt;在前两边TCP学习总结中，也大概地学习了TCP的整个流程，但许多细节中的细节并没有详细学习，例如超时重传问题，每次瓶颈回归慢启动效率问题以及最大窗口限制问题等。本学习篇章最要针对这些细节中的细节进行学习。TCP的复杂很多时候就是细节太多了，需要考虑许多的场景并利用许多复杂的算法和启动异步线程定时处理这些问题，对于每一个连接，TCP管理4个不同的定时器，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、重传定时器使用于当希望收到另一端的确认；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、坚持定（persist）时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、保活（keepalive）定时器可检测到一个空闲连接的另一端何时崩溃或重启；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）、2MSL定时器测量一个连接处于TIME_WAIT状态的时间。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP的超时与重传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RTO（Retransmission TimeOut）算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP计算超时有一个叫做“指数退避”的算法，例如如果发送方在发送数据的时候，服务端突然关闭服务时，客户端是会根据初始超时时间开始一步步指数的增长超时重传时间，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004222221882-227721495.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上简单例子的第一次超时重传时间是1.5秒，第二次是3秒，第三次是6秒以此指数增长类推，直到最大超时时间64秒后就不再增长，直到9分钟（TCP实现中不可变）后客户端直接发送一个RST报文段断开连接。由于路由器和网络流量均会变化，因此TCP会跟踪这些变化并相应地改变其超时时间，所以超时的初始化时间不是固定的。它会根据报文段的往返时间（RTT）去评估，具体算法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;最初算法：R=αR+（1-α）M ；RTO=Rβ；&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;R：RTT估计器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;M：当前测量值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;α：是一个推荐值为0.9的平滑因子；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;β：是一个推荐值为2的时延离散因子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从以上算法可以看出，每个新估计的90%来自于前一个估计，而10%则取自新的测量。[Jacobson 1988]详细分析了在RTT变化范围很大时，使用这个方法无法跟上这种变化，从而引起不必要的重传。所以Jacobson建议除了被平滑的RTT估计器（R），所需要做的还有跟踪RTT的方差。在往返时间变化起伏很大时，基于均值和方差来计算RTO，将比作为均值的常数倍来计算RTO能提供更好的响应。正如Jacobson所描述的，均值偏差是对标准差的一种好的逼近，但却更容易进行计算（计算标准方差需要一个平方根）。这就引出了下面用于每个RTT测量M的公式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;Err=M-A&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;A←A+gErr&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;D←D+h（|Err|-D）&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;RTO=A+4D&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里的A是被平滑的RTT（均值的估计器），而D则是被平滑的均值偏差。Err是刚得到的测量结果与当前的RTT估计器之差。A和D均被用于计算下一个重传时间（RTO）。增量g起平均作用，取为1/8（0.125）。偏差的增益是h，取值为0.25.当RTT变化时，较大的偏差增益将使RTO快速上升。其实重传测量结果还会存在一个问题，就是发生重传时，然后收到一个确认，那么这个ACK是针对第一个分组还是针对第二个分组呢？这就是所谓的重传多义性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Karn算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里又涉及到一个新的算法，叫“Karn算法”。他规定，当一个超时和重传发生时，在重传数据的确认最后到达时，不能更新RTT估计器，因为我们并不知道ACK是针对哪一次传输。并且，由于数据被重传，RTO已经得到了一个指数退避，我们在下一次传输时使用这个退避后的RTO，对于一个没有被重传的报文段而言，除非收到了一个确认，否则不要计算新的RTO。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;拥塞避免算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该算法假定由于分组受到损坏引起丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时和接收到重复的确认（接收端强调我只接受到这个报文而已）。在上一学习总结中学到了一个叫“慢启动”的限流算法，也抛出了一个老是慢启动也不是办法的问题。拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。所以很多时候，在实际中这两个算法通常在一起实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口&lt;strong&gt;&lt;em&gt;cwnd&lt;/em&gt;&lt;/strong&gt;和一个慢启动门限&lt;strong&gt;&lt;em&gt;ssthresh&lt;/em&gt;&lt;/strong&gt;。这样得到的算法的工作过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、对于一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节（注意：这是最大窗口大小）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）、当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进程拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置一半的时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），然后专为执行拥塞避免。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004222419376-149990096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该例子当中，假定cwnd为32个报文段时就发生拥塞，于是设置shthresh为16个报文段，而cwnd为1个报文段。在时刻0发送了一个报文段，并假定在时刻1接收到它的ACK，此时cwnd为2。接着发送了2个报文段，并假定在时刻2接收到它的ACK，于是cwnd增加为4（对于每个ACK增加1次）。这种指数增加算法一直进行到时刻3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻开始，cwnd以线性方式增加，在每个往返时间内最多增加1个报文段。从例子可以看出，慢启动与拥塞避免算法的合并使用效果。那么它们的合作是如何避免每次都要重慢启动开始呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 快速重传与快速回复算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、当收到3个重复的ACK时（1~2个ACK无法确认是丢失），将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段，设置cwnd为ssthresh加上3倍的报文段大小（因为收到3个重复ACK）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、每次收到另一个重复ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复ACK之间的所有中间段报文的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说白了就是通过3次重复ACK确认报文的丢失而不是等待超时定时器溢出的确认，这样就避免了慢启动算法的激活，而从最低初始化拥塞窗口（1个报文段）起发送。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; TCP的坚持定时器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 上一篇学习总结中提到过通告窗口为0时发送方将停止发送数据的问题。为了避免发送方和接收方的死循环等待，发送方使用一个“坚持定时器（presist timer）”来周期性地向接收方查询，以便发现窗口是否已经增大。这些从发送方发出的报文段称为窗口查探（window probe）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004222532272-1723717481.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以看出，坚持定时器使用了普通的TCP指数退避。对于一个典型的局域网连接，首次超时时间算出来是1.5秒，第2次的超时时值增加一倍，为3秒，再下次乘以4为6秒，之后再乘以8为12秒等，但是坚持定时器总是在5~60秒之间。窗口探查包含一个字节的数据（以上例子序号为4098）。TCP总是允许发送已关闭窗口之后一个字节的数据。坚持状态与重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查（重传超时会持续9分钟），这些探查每隔60秒发送一次，这个过程将持续到或者窗口被打开或应用进程使用的连接被终止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上一篇总结当中同样提到了一个叫“糊涂窗口综合征”的问题。也就是说，接收方每出现哪怕1个字节的空闲窗口也会通告发送方，那么发送放就会立刻发送数据，但就会让发送方与接收方陷入“小分组”发送的死循环，从而会造成网络拥塞问题。该现象可以发生在两端的任何一端，接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通知），而发送方也可以发送少量数据（而不是等待其他的数据以便发送一个大的报文段）。可以在任何一端采取措施避免出现“糊涂窗口综合征”的现象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、接收方不通告窗口大小。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0）除非窗口可以增加一个报文段大小（也就是将要接受的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、发送方避免出现“糊涂窗口综合征”的措施只有以下条件之一满足时才发送数据：（a）可以发送一个满长度的报文段；（b）可以发送至少是接收方通告窗口大小一半的报文段；（c）能够发送手头的所有数据并且不希望接收ACK（也就是说，我们没有还未确认的数据）或该连接禁止了Nagle算法。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP的保活定时器 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;保活定时器主要是为服务器应用程序提供的，因为许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。但有一点需要注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;保活定时器并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由：（1）在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；（2）它们耗费不必要的带宽；（3）在按分组计费的情况下会在互联网上花掉更多的钱。然而，许多实现提供了保活定时器。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户主机必须处于以下4个状态之一：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两个小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应。并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭或终止连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、客户主机已经崩溃并已经重新启动。这是服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）、客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学习总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;本篇章主要针对TCP管理的4个定时器的介绍，包括超时重传定时器、坚持定时器、保活定时器，以及第一篇章介绍的2MSL的TIME_WAIT状态定时器。这些都是确保TCP可靠性的重要手段。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 13:13:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>在前两边TCP学习总结中，也大概地学习了TCP的整个流程，但许多细节中的细节并没有详细学习，例如超时重传问题，每次瓶颈回归慢启动效率问题以及最大窗口限制问题等。本学习篇章最要针对这些细节中的细节进行学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/9743656.html</dc:identifier>
</item>
</channel>
</rss>