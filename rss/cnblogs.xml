<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>滤波器——BoxBlur均值滤波及其快速实现 - Mr-Lee</title>
<link>http://www.cnblogs.com/shine-lee/p/9355066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shine-lee/p/9355066.html</guid>
<description>&lt;p&gt;在数字图像处理的语境里，图像一般是二维或三维的矩阵，卷积核（kernel）和滤波器（filter）通常指代同一事物，即&lt;strong&gt;对图像进行卷积或相关操作时使用的小矩阵&lt;/strong&gt;，尺寸通常较小，常见的有3*3、5*5、7*7等。卷积操作相当于对滤波器旋转180度后的相关操作，如下图所示，但很多滤波器是中心对称的，而且两者运算上可以等价，所以很多时候不太区分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180711/e54JaCig3k.png?imageslim&quot; alt=&quot;相关运算与卷积运算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计不同的滤波器，可以达到去噪（denoising）、平滑（smoothing）、模糊（blurring）、锐化（sharpening）、浮雕（embossing）、边缘检测（edge detection）等目的。在空域中直接进行卷积操作（滑动窗口），需要4层循环嵌套，复杂度达到&lt;span class=&quot;math inline&quot;&gt;\(O(m^2*n^2)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;为图像尺寸，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;为滤波器尺寸，随着图像或卷积尺寸增大，复杂度以平方快速增长，因此需要一些快速实现方式，尤其是在计算资源并不充足的嵌入式等端上。&lt;/p&gt;

&lt;p&gt;均值滤波器可能是最基本最常见的滤波器了，一个3*3的均值滤波器如1所示，使用该滤波器对图像进行滤波，相当于对图像中的每一个像素使用其周围的像素进行平均。均值滤波器用途广泛，除最直接的平滑操作外，还可近似实现其他滤波操作，比如&lt;strong&gt;带通滤波&lt;/strong&gt;和&lt;strong&gt;高斯平滑&lt;/strong&gt;等。因为均值滤波器在频域近似为一个低通滤波器，因此两个不同半径的均值滤波器滤波结果的差值可近似带通滤波器；根据&lt;a href=&quot;https://wiki2.org/en/Central_limit_theorem&quot;&gt;中心极限定理&lt;/a&gt;，多次Box Blur的结果可近似高斯平滑。&lt;strong&gt;应用得越广泛就越需要仔细优化，可以采用均值滤波器来近似实现其他滤波器的一个前提就是均值滤波可以更高效。&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{1}{9} \left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接实现四层循环的均值滤波复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(m^2*n^2)\)&lt;/span&gt;，可以利用均值滤波器所有权重都相同等性质实现快速滤波。&lt;/p&gt;
&lt;h2 id=&quot;行列分解实现&quot;&gt;行列分解实现&lt;/h2&gt;
&lt;p&gt;可将卷积核分解为列向量和行向量的相乘，如2所示，对图像进行2D的均值滤波，等价于先逐行进行平均然后逐列平均，复杂度可由&lt;span class=&quot;math inline&quot;&gt;\(O(m^2*n^2)\)&lt;/span&gt; 降至&lt;span class=&quot;math inline&quot;&gt;\(O(m^2*2n)\)&lt;/span&gt; 。这样实现的前提是卷积核可分解，换句话说，可分解的卷积核均可考虑这样优化，比如高斯滤波等。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{1}{9} \left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] = \frac{1}{3} \left[ \begin{matrix} 1 \\ 1 \\ 1 \end{matrix} \right] \cdot \frac{1}{3} \left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \\ \end{matrix} \right] \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;类队列实现&quot;&gt;类“队列”实现&lt;/h2&gt;
&lt;p&gt;行列分解后，相当于在行上和列上进行1D滑动窗口均值滤波。在1D窗口滑动过程中，相邻窗口有大量元素是重叠的，比如下图中，8、5、10和5、10、7其中5和10就是重叠的。整个滑动过程可以看成是不断进出“队列”的过程，窗口每向右移动1个像素，相当于最左侧的像素出队列，最右侧的像素进队列，当前像素的滤波结果为当前队列内元素之和然后平均，而前后一直驻留在队列中的元素则不需要重复加和，通过避免重复计算来实现提速。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180711/LcFi6gbJHK.png?imageslim&quot; alt=&quot;1D滑动窗口&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，计算第&lt;span class=&quot;math inline&quot;&gt;\(i+1\)&lt;/span&gt; 个窗口的和&lt;span class=&quot;math inline&quot;&gt;\(S[i+1]\)&lt;/span&gt;可以通过第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个窗口的和&lt;span class=&quot;math inline&quot;&gt;\(S[i]\)&lt;/span&gt;与最左&lt;span class=&quot;math inline&quot;&gt;\(x[i-r]\)&lt;/span&gt;最右&lt;span class=&quot;math inline&quot;&gt;\(x[i+r+1\)&lt;/span&gt;的元素得到，&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 为滤波器半径，如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[S[i+1] = S[i] + x[i+r+1] - x[i-r]\]&lt;/span&gt;&lt;br/&gt;这样，我们得到了与滤波器尺寸无关的算法，算法复杂度进一步降低至&lt;span class=&quot;math inline&quot;&gt;\(O(m^2)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;此外，我们也可考虑2D的滑动窗口，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180711/c121mKIk7L.gif&quot; alt=&quot;2D滑动窗口&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样利用相邻滑动窗口内的重叠元素，计算以元素&lt;span class=&quot;math inline&quot;&gt;\((i, j)\)&lt;/span&gt; 为中心的窗口元素之和&lt;span class=&quot;math inline&quot;&gt;\(S[i, j]\)&lt;/span&gt; 如下，其中&lt;span class=&quot;math inline&quot;&gt;\(C[i, j]\)&lt;/span&gt;为窗口内以&lt;span class=&quot;math inline&quot;&gt;\((i, j)\)&lt;/span&gt;为中心的半径为&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;的列和，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[S[i, j] = \sum_{k=-r}^{+r} C[i, j+k]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;窗口向右移动时，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[S[i, j+1] = S[i, j] + C[i, j+r+1] - C[i, j- r]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;窗口向下移动时，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[C[i+1, j] = C[i, j] + C[i+r+1, j] - C[i-r-1, j]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;滤波结果为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x'[i, j] = \frac{1}{(2r+1)^2} S[i, j]\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;积分图&quot;&gt;积分图&lt;/h2&gt;
&lt;p&gt;如果需要得到多个不同半径的均值滤波结果时，使用积分图（&lt;a href=&quot;https://wiki2.org/en/Summed-area_table&quot;&gt;Summed-area table&lt;/a&gt;）可能是个好办法。积分图中&lt;span class=&quot;math inline&quot;&gt;\((x, y)\)&lt;/span&gt; 位置&lt;span class=&quot;math inline&quot;&gt;\(I(x, y)\)&lt;/span&gt;的值等于原图中该位置左上角所有像素之和，累加和包不包含这个像素自身所在的行和列与具体实现有关，这里沿用&lt;a href=&quot;https://wiki2.org/en/Summed-area_table&quot;&gt;Wiki&lt;/a&gt;上的表述方式包含（&lt;a href=&quot;https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#integral&quot;&gt;Opencv为不包含&lt;/a&gt;），计算方式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[I(x, y) = \sum_{x'\le x, \ y' \le y}i(x', y')\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;积分图可通过单趟遍历快速实现，有了积分图就可以计算任意尺寸box内元素之和，仅需2次减法和1次加法常数次运算，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p48vt5kn0.bkt.clouddn.com/blog/180711/3A3cGmFiCJ.png?imageslim&quot; alt=&quot;积分图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，当需要不同尺寸均的值滤波结果时，使用积分图的运算时间是一样的。&lt;/p&gt;
&lt;h2 id=&quot;指令级优化&quot;&gt;指令级优化&lt;/h2&gt;
&lt;p&gt;除了以上优化方法，还可采用指令级优化。对每一个像素位置求均值是在该像素的邻域范围内进行的，同一行上的像素位于连续的内存区域，对像素施加的都是近乎相同的操作——加法或减法，因此时宜采用&lt;a href=&quot;https://wiki2.org/en/SIMD&quot;&gt;SIMD&lt;/a&gt;指令，如MMX、SSE、AVX、NEON等，同时载入多个数据、同时对多个数据进行相同的操作，一些实现方式可参见 参考资料，这里不再详述。&lt;strong&gt;需要注意的是，指令级的优化意味着兼容性、可扩展性的损失，如果代码尚未稳定，则不建议采用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这里简单分析下各种方法的优缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;类“队列”实现&lt;/strong&gt;：不能实现in-place操作，如果内存空间不足，可缓存一个窗口高度图像宽度的内存块，在缓存块操作后再写回原图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;积分图方法&lt;/strong&gt;：需要较大的内存来存储积分图，好处是积分图仅需求取一次，后面所有尺寸的Box Blur均可使用，而且求各处的滤波结果互不依赖，方便并行化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;基本上所有的优化方式的出发点都是减少不必要的重复计算，本文所介绍的几种方法在其他滤波操作的优化中也常被采用。&lt;/strong&gt;以上仅为算法思路介绍，具体实现时可能要进一步考虑内存访问的时间、边界处理等细节，不再赘述。&lt;/p&gt;

&lt;p&gt;个人博客地址：&lt;a href=&quot;https://blog.shinelee.me/2018-07-13-%E6%BB%A4%E6%B3%A2%E5%99%A8%E2%80%94%E2%80%94BoxBlur%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%8F%8A%E5%85%B6%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0.html&quot;&gt;滤波器——BoxBlur均值滤波及其快速实现&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 07:52:00 +0000</pubDate>
<dc:creator>Mr-Lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shine-lee/p/9355066.html</dc:identifier>
</item>
<item>
<title>Android 开发艺术探索读书笔记（一） - andorxor</title>
<link>http://www.cnblogs.com/andorxor/p/9354926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andorxor/p/9354926.html</guid>
<description>&lt;p&gt;之前断断续续地学了一些 Android 开发基础，也写过几个简单的 app，但都是特别简单的那种，还有很多知识学完了没有用过，现在已经忘得差不多了。最近找到一本书叫 Android 开发艺术探索（作者叫任玉刚，据说是百度的大牛），2015 年出版的，看完第一章后感觉不错，很适合我这种有点基础的人看，于是决定写个读书笔记，记录自己从书中学习到的知识。&lt;/p&gt;
&lt;h3&gt;第一章&lt;/h3&gt;
&lt;p&gt;本章主要介绍了 Activity 相关的一些内容。&lt;/p&gt;
&lt;h4&gt;1.1 Activity 的生命周期&lt;/h4&gt;
&lt;p&gt;正常情况下 Activity 的生命周期如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java&quot;&gt;// 1.表示 Activity 正在被创建
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}

// 2.表示 Activity 正在重新启动，当用户切换已经打开过的 Activity 时才会调用这个方法
@Override
protected void onRestart() {
    super.onRestart();
}

// 3.表示 Activity 正在被启动
@Override
protected void onStart() {
    super.onStart();
}

// 4.表示 Activity 已经可见
@Override
protected void onResume() {
    super.onResume();
}

// 5.表示 Activity 正在暂停
@Override
protected void onPause() {
    super.onPause();
}

// 6.表示 Activity 正在停止
@Override
protected void onStop() {
    super.onStop();
}

// 7.表示 Activity 正在销毁
@Override
protected void onDestroy() {
    super.onDestroy();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些特殊情况下，Activity 的生命周期可能会发生变化，比如屏幕旋转、内存不足等等，此时 Activity 会被销毁并重新创建，这种情况下会多出两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java&quot;&gt;// 在 onStop() 方法之前被调用
// 用来保存相关数据
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putInt(&quot;test&quot;, 123);
}

// 在 onStart() 方法后被调用
// 用来恢复数据，也可以在 onCreate() 方法中恢复，但要判断 savedInstanceState 是否为 null，这里就不需要
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    int value = savedInstanceState.getInt(&quot;test&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 如果我们不想系统重新创建 Activity，可以在 AndroidManifest.xml 中为 Activity 配置 configChanges 属性，此属性可以指定多个值（哎呀，无法插入 xml 代码好蛋疼）：&lt;/p&gt;
&lt;p&gt;&amp;lt;activity&lt;br/&gt;android:name=&quot;.MainActivity&quot;&lt;br/&gt;android:configChanges=&quot;orientation|locale|keyboard|keyboardHidden|screenSize&quot;&amp;gt;&lt;br/&gt;&amp;lt;intent-filter&amp;gt;&lt;br/&gt;&amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/intent-filter&amp;gt;&lt;br/&gt;&amp;lt;/activity&amp;gt;&lt;/p&gt;
&lt;p&gt;常用的就这么几个，分别表示屏幕旋转、本地设置改变（如切换语言）、键盘改变（如外接键盘）、键盘可访问性改变（显示或隐藏键盘）、屏幕尺寸改变（通常是因为屏幕旋转）。&lt;/p&gt;
&lt;p&gt;同时，如果指定了 configChanges 属性，当相关事件发生时，系统会调用 Activity 的如下生命周期方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java&quot;&gt;// 表示配置改变，可以根据需要做一些特殊处理
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    Log.d(&quot;TEST&quot;, &quot;onConfigurationChanged: &quot; + newConfig.orientation);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt; 1.2 Activity 的启动模式&lt;/h4&gt;
&lt;p&gt;Android 系统有一个 Activity 任务栈的概念，栈是一种后进先出的数据结构，那么任务栈中存放的 Activity 自然也是后进先出的。任务栈是 Android 系统管理 Activity 的方式，至于它的工作原理，这里暂时不做说明，我们主要关注的是 Activity 的启动模式。&lt;/p&gt;
&lt;p&gt;Activity 有四种启动模式，分别为：&lt;/p&gt;
&lt;p&gt;standard：标准模式，也是系统默认的启动模式，每次启动 Activity 都会创建一个实例，并执行相应的生命周期方法，每个 Activity 也都会被放入任务栈中；&lt;/p&gt;
&lt;p&gt;singleTop：栈顶复用模式，如果要启动的 Activity 已经位于栈顶，则复用它，此时就不会调用 onCreate() 和 onStart() 方法，取而代之的是调用 onNewIntent() 方法；&lt;/p&gt;
&lt;p&gt;singleTask：栈内复用模式，如果要启动的 Activity 在栈中存在，则复用它，生命周期方法同上，但此时系统会清空在任务栈中此 Activity 上面的所有其他 Activity（重点，拿小本本记下来）；&lt;/p&gt;
&lt;p&gt;singleInstance：单一实例模式，此种情况下，系统会为 Activity 创建一个单独的、独享的任务栈，如果要启动的 Activity 已经存在，则复用它，生命周期方法同上。&lt;/p&gt;
&lt;p&gt;说了这么多，那么如何为 Activity 指定启动模式呢？&lt;/p&gt;
&lt;p&gt;作者说了，有两种方法，第一种方法是在 AndroidManifest.xml 中配置：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&amp;lt;activity&lt;br/&gt;android:name=&quot;.MainActivity&quot;&lt;br/&gt;android:configChanges=&quot;orientation|locale|keyboard|keyboardHidden|screenSize&quot;&lt;br/&gt;android:launchMode=&quot;singleTop&quot;&amp;gt;&lt;br/&gt;&amp;lt;intent-filter&amp;gt;&lt;br/&gt;&amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;&lt;p&gt;&amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/intent-filter&amp;gt;&lt;br/&gt;&amp;lt;/activity&amp;gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;第二种方法是通过代码指定：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java&quot;&gt;private void testLaunchMode()
{
    Intent intent = new Intent(this, MainActivity.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    startActivity(intent);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 两种方法都可以指定 Activity 的启动模式，不过第一种方法不能设置 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种方法不能指定 singleInstance 模式，但第二种方式的优先级要高于第一种，实际使用中应该根据需要灵活选择。&lt;/p&gt;
&lt;p&gt;上面的代码中提到了 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP，这是 Android 系统预定义的两个常量，是 Activity 的 Flags。系统预定义了很多这样的标识位常量，下面介绍几个常用的标识位：&lt;/p&gt;
&lt;p&gt;FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 模式，效果和在 AndroidManifest.xml 中指定该模式相同；&lt;/p&gt;
&lt;p&gt;FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 模式，除此之外同上；&lt;/p&gt;
&lt;p&gt;FLAG_ACTIVITY_CLEAR_TOP：启动具有此标识位的 Activity，系统会清除与此 Activity 在同一栈中，且在其上面的所有 Activity，通常与 FLAG_ACTIVITY_NEW_TASK 配合使用；&lt;/p&gt;
&lt;p&gt;FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：表示要启动的 Activity 不在系统的最近任务列表中显示，效果同在 AndroidManifest.xml 中指定 android:excludeFromRecents=&quot;true&quot;。&lt;/p&gt;
&lt;p&gt;1.3 节主要讲的是  IntentFilter 的匹配规则，内容也不少，下次再写吧。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 07:39:00 +0000</pubDate>
<dc:creator>andorxor</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andorxor/p/9354926.html</dc:identifier>
</item>
<item>
<title>spring boot 监控处理方案 - zygfengyuwuzu</title>
<link>http://www.cnblogs.com/zhyg/p/9354952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhyg/p/9354952.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文需要有相关spring boot 或spring cloud 相关微服务框架的基础，如果您具备相关基础可以很容易的实现下述过程!!!!!!!&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　希望本文的所说对需要的您有所帮助&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从这里我们开始进入闲聊阶段。&lt;/p&gt;
&lt;p&gt;　　大家都知道 spring boot整合了很多很多的第三方框架，我们这里就简单讨论和使用 性能监控和JVM监控相关的东西。其他的本文不讨论虽然有些关联，所以开篇有说需要有相关spring boot框架基础说了这么多废话，下面真正进入主题。&lt;/p&gt;
&lt;p&gt;　　这里首先给大家看下整体的数据流程图，其中两条主线一条是接口或方法性能监控数据收集，还有一条是spring boot 微服务JVM相关指标数据采集，最后都汇总到InfluxDB时序数据库中在用数据展示工具Grafara进行数据展示或报警。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201807/560839-20180723140316653-1916510801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;〇、基础服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　基础服务比较多，其中包括RabbitMQ，Eureka注册中心，influxDB，Grafara（不知道这些东西 请百度或谷歌一下了解相关知识），下面简单说下各基础服务的功能：&lt;/p&gt;
&lt;p&gt;　　　　　　RabbitMQ 一款很流行的消息中间件，主要用它来收集spring boot应用监控性能相关信息，为什么是RabbitMQ而不是什么别的 kafka等等，因为测试方便性能也够用，spring boot整合的够完善。&lt;/p&gt;
&lt;p&gt;　　　　　　Eureka 注册中心，一般看过或用过spring cloud相关框架的都知道spring cloud注册中心主要推荐使用Eureka！至于为什么不做过多讨论不是本文主要讨论的关注点。本文主要用来同步和获取注册到注册中心的应用的相关信息。&lt;/p&gt;
&lt;p&gt;　　　　　　InfluxDB和Grafara为什么选这两个，其他方案如 ElasticSearch 、Logstash 、Kibana，ELK的组合等！原因很显然 influxDB是时序数据库数据的压缩比率比其他（ElasticSearch ）好的很多（当然本人没有实际测试过都是看一些文档）。同时InfluxDB使用SQL非常类似mysql等关系型数据库入门方便，Grafara工具可预警。等等！！！！！！！！！！！&lt;/p&gt;
&lt;p&gt;　　　　　　好了工具就简单介绍到这里，至于这些工具怎么部署搭建请搭建先自行找资料学习，还是因为不是本文重点介绍的内容，不深入讨论。如果有docker相关基础的童鞋可以直接下载个镜像启动起来做测试使用（本人就是使用docker启动的上面的基础应用（Eureka除外））&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、被监控的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　这里不多说被监控应用肯定是spring boot项目但是要引用一下相关包和相关注解以及修改相关配置文件&lt;/p&gt;
&lt;p&gt;　　　　包引用，这些包是必须引用的&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-sleuth-zipkin-stream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-stream-rabbit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　简单说下呢相关包的功能spring-cloud-starter-netflix-eureka-client用于注册中心使用的包，spring-cloud-starter-stream-rabbit 发送RabbitMQ相关包，spring-boot-starter-actuator发布监控相关rest接口包，&lt;/p&gt;
&lt;pre&gt;
　　　　　　spring-cloud-starter-hystrix熔断性能监控相关包。&lt;br/&gt;　　　　　　&lt;br/&gt;　　　　　　相关注解
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@EnableHystrix&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启性能监控&lt;/span&gt;
@RefreshScope&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新配置文件 与本章无关&lt;/span&gt;
&lt;span&gt;@EnableAutoConfiguration
@EnableFeignClients&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RPC调用与本章无关&lt;/span&gt;
&lt;span&gt;@RestController
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerTestApplication {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ServerTestApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ServerTestApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　配置文件相关&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_86a3d7ae-eeca-4ce9-bde0-2c496e1cc7ac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_86a3d7ae-eeca-4ce9-bde0-2c496e1cc7ac&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_86a3d7ae-eeca-4ce9-bde0-2c496e1cc7ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
hystrix.threadpool.default.coreSize: 100
spring:
  application:
    name: spring-cloud-server2-test
  rabbitmq:
    host: 10.10.12.21
    port: 5672
    username: user
    password: password

encrypt:
  failOnError: false
server:
  port: 8081
eureka:
  instance:
    appname: spring-cloud-server2-test
    prefer-ip-address: true
  client: 
    serviceUrl:
      defaultZone: http://IP:PORT/eureka/#注册中心地址
    eureka-server-total-connections-per-host: 500
endpoints:
  refresh:
    sensitive: false
  metrics:
    sensitive: false
  dump:
    sensitive: false
  auditevents:
    sensitive: false
  features:
    sensitive: false
  mappings:
    sensitive: false
  trace:
    sensitive: false
  autoconfig:
    sensitive: false
  loggers:
    sensitive: false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　简单解释一下endpoints下面相关配置，主要就是 原来这些路径是需要授权访问的，通过配置让这些路径接口不再是敏感的需要授权访问的接口这应我们就可以轻松的访问注册到注册中心的每个服务的响应的接口。这里插一句接口性能需要在方法上面加上如下类似相关注解，然后才会有相关性能数据输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　@Value(&quot;${name}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    @HystrixCommand(commandProperties &lt;/span&gt;=&lt;span&gt; {
            @HystrixProperty(name &lt;/span&gt;= &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;20000&quot;) }, threadPoolProperties =&lt;span&gt; {
                    @HystrixProperty(name &lt;/span&gt;= &quot;coreSize&quot;, value = &quot;64&quot;) }, threadPoolKey = &quot;test1&quot;&lt;span&gt;)
    @GetMapping(&lt;/span&gt;&quot;/testpro1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStringtest1(){
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　好了到这里你的应用基本上就具备相关性能输出的能力了。你可以访问
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201807/560839-20180723144041692-589444599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果是上图的接口 你的应用基本OK，为什么是基本因为你截图没有体现性能信息发送RabbitMQ的相关信息。这个需要看日志，加入你失败了评论区在讨论。我们先关注主线。&lt;/p&gt;
&lt;p&gt;　　好的spring boot 应用就先说道这里。开始下一主题&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　二、性能指标数据采集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　刚才访问http://IP:port/hystrix.stream这个显示出来的信息就是借口或方法性能相关信息的输出，如果上面都没有问题的话数据应该发送到了RabbitMQ上面了我们直接去RabbitMQ上面接收相关数据就可以了。&lt;/p&gt;
&lt;p&gt;　　　　性能指标数据的采集服务主要应用以下包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.github.miwurster/spring-data-influxdb &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.influxdb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;influxdb-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-autoconfigure&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　直接贴代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_58e7c447-119d-43ba-824d-5a86188d12df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58e7c447-119d-43ba-824d-5a86188d12df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58e7c447-119d-43ba-824d-5a86188d12df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; application;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(RabbitMQApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_11e1b07f-e001-4256-9b91-0eb0c12f5ef6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_11e1b07f-e001-4256-9b91-0eb0c12f5ef6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_11e1b07f-e001-4256-9b91-0eb0c12f5ef6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; application;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.Binding;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.BindingBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.Queue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.TopicExchange;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.connection.ConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.core.RabbitTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;    

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMQConfig {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String QUEUE_NAME = &quot;spring-boot-queue&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String EXCHANGE_NAME = &quot;springCloudHystrixStream&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String ROUTING_KEY = &quot;#&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建队列&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue queue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Queue(QUEUE_NAME);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 topic 类型的交换器&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TopicExchange exchange() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TopicExchange(EXCHANGE_NAME);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用路由键（routingKey）把队列（Queue）绑定到交换器（Exchange）&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Binding binding(Queue queue, TopicExchange exchange) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConnectionFactory connectionFactory() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq IP 端口号&lt;/span&gt;
        CachingConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; CachingConnectionFactory(&quot;IP&quot;, 5672&lt;span&gt;);
        connectionFactory.setUsername(&lt;/span&gt;&quot;user&quot;&lt;span&gt;);
        connectionFactory.setPassword(&lt;/span&gt;&quot;password&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionFactory;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RabbitTemplate(connectionFactory);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_0694b3c6-6429-491a-a6fe-58c3a33590c8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0694b3c6-6429-491a-a6fe-58c3a33590c8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0694b3c6-6429-491a-a6fe-58c3a33590c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; application;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.InfluxDB;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.InfluxDBFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.dto.Point;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.dto.Point.Builder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.dto.Query;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.influxdb.dto.QueryResult;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InfluxDBConnect {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String username;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String password;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密码&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String openurl;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接地址&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String database;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据库&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; InfluxDB influxDB;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InfluxDBConnect(String username, String password, String openurl, String database) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.openurl =&lt;span&gt; openurl;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.database =&lt;span&gt; database;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 连接时序数据库；获得InfluxDB *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; InfluxDB influxDbBuild() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (influxDB == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            influxDB &lt;/span&gt;=&lt;span&gt; InfluxDBFactory.connect(openurl, username, password);
            influxDB.createDatabase(database);

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; influxDB;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置数据保存策略 defalut 策略名 /database 数据库名/ 30d 数据保存时限30天/ 1 副本个数为1/ 结尾DEFAULT
     * 表示 设为默认的策略
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createRetentionPolicy() {
        String command &lt;/span&gt;= String.format(&quot;CREATE RETENTION POLICY \&quot;%s\&quot; ON \&quot;%s\&quot; DURATION %s REPLICATION %s DEFAULT&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;defalut&quot;, database, &quot;30d&quot;, 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.query(command);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; command
     *            查询语句
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QueryResult query(String command) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; influxDB.query(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(command, database));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measurement
     *            表
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; tags
     *            标签
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fields
     *            字段
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(String measurement, Map&amp;lt;String, String&amp;gt; tags, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; fields) {
        Builder builder &lt;/span&gt;=&lt;span&gt; Point.measurement(measurement);
        builder.time(((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)fields.get(&quot;currentTime&quot;))*1000000&lt;span&gt;, TimeUnit.NANOSECONDS);
        builder.tag(tags);
        builder.fields(fields);
        &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        influxDB.write(database, &quot;&quot;&lt;span&gt;, builder.build());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; command
     *            删除语句
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回错误信息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String deleteMeasurementData(String command) {
        QueryResult result &lt;/span&gt;= influxDB.query(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(command, database));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.getError();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建数据库
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dbName
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createDB(String dbName) {
        influxDB.createDatabase(dbName);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除数据库
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dbName
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteDB(String dbName) {
        influxDB.deleteDatabase(dbName);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOpenurl() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; openurl;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOpenurl(String openurl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.openurl =&lt;span&gt; openurl;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDatabase(String database) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.database =&lt;span&gt; database;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_6f23fc0e-ebd5-4931-a4f0-7915bf16a0df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6f23fc0e-ebd5-4931-a4f0-7915bf16a0df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6f23fc0e-ebd5-4931-a4f0-7915bf16a0df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; application;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InfluxDBConfiguration {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String username = &quot;admin&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String password = &quot;admin&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String openurl = &quot;http://IP:8086&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;InfluxDB连接地址&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String database = &quot;test_db&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库&lt;/span&gt;
&lt;span&gt;    
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InfluxDBConnect getInfluxDBConnect(){
        InfluxDBConnect influxDB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InfluxDBConnect(username, password, openurl, database);
        
        influxDB.influxDbBuild();
        
        influxDB.createRetentionPolicy();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; influxDB;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_f50a92cb-a0b2-4ea1-9632-0e9dca78301b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f50a92cb-a0b2-4ea1-9632-0e9dca78301b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f50a92cb-a0b2-4ea1-9632-0e9dca78301b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; application;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.databind.ObjectMapper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Consumer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ObjectMapper objectMapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper();

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InfluxDBConnect influxDB;

    @RabbitListener(queues &lt;/span&gt;=&lt;span&gt; RabbitMQConfig.QUEUE_NAME)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendToSubject(org.springframework.amqp.core.Message message) {

        String payload &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(message.getBody());
        logger.info(payload);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (payload.startsWith(&quot;\&quot;&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Legacy payload from an Angel client&lt;/span&gt;
            payload = payload.substring(1, payload.length() - 1&lt;span&gt;);
            payload &lt;/span&gt;= payload.replace(&quot;\\\&quot;&quot;, &quot;\&quot;&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (payload.startsWith(&quot;[&quot;&lt;span&gt;)) {
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                List&lt;/span&gt;&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = &lt;span&gt;this&lt;/span&gt;.objectMapper.readValue(payload, List.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map : list) {
                    sendMap(map);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map = &lt;span&gt;this&lt;/span&gt;.objectMapper.readValue(payload, Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                sendMap(map);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
            logger.error(&lt;/span&gt;&quot;Error receiving hystrix stream payload: &quot; +&lt;span&gt; payload, ex);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendMap(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; data =&lt;span&gt; getPayloadData(map);
        data.remove(&lt;/span&gt;&quot;latencyExecute&quot;&lt;span&gt;);
        data.remove(&lt;/span&gt;&quot;latencyTotal&quot;&lt;span&gt;);
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; tags = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        
        tags.put(&lt;/span&gt;&quot;type&quot;, data.get(&quot;type&quot;&lt;span&gt;).toString());
        tags.put(&lt;/span&gt;&quot;name&quot;, data.get(&quot;name&quot;&lt;span&gt;).toString());
        tags.put(&lt;/span&gt;&quot;instanceId&quot;, data.get(&quot;instanceId&quot;&lt;span&gt;).toString());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tags.put(&quot;group&quot;, data.get(&quot;group&quot;).toString());&lt;/span&gt;
&lt;span&gt;        
        
        influxDB.insert(&lt;/span&gt;&quot;testaaa&quot;&lt;span&gt;, tags, data);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (String key : data.keySet()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; logger.info(&quot;{}:{}&quot;,key,data.get(key));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getPayloadData(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; jsonMap) {
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; origin = (Map&amp;lt;String, Object&amp;gt;) jsonMap.get(&quot;origin&quot;&lt;span&gt;);
        String instanceId &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (origin.containsKey(&quot;id&quot;&lt;span&gt;)) {
            instanceId &lt;/span&gt;= origin.get(&quot;host&quot;) + &quot;:&quot; + origin.get(&quot;id&quot;&lt;span&gt;).toString();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.hasText(instanceId)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: instanceid template&lt;/span&gt;
            instanceId = origin.get(&quot;serviceId&quot;) + &quot;:&quot; + origin.get(&quot;host&quot;) + &quot;:&quot; + origin.get(&quot;port&quot;&lt;span&gt;);
        }
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; data = (Map&amp;lt;String, Object&amp;gt;) jsonMap.get(&quot;data&quot;&lt;span&gt;);
        data.put(&lt;/span&gt;&quot;instanceId&quot;&lt;span&gt;, instanceId);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里不多说，就是接收RabbitMQ信息然后保存到InfluxDB数据库中。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　三、JVM相关数据采集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　JVM相关数据采集非常简单主要思想就是定时轮训被监控服务的接口地址然后把返回信息插入到InfluxDB中&lt;/p&gt;
&lt;p&gt;　　　　服务引用的包不多说这个服务是需要注册到注册中心Eureka中的因为需要获取所有服务的监控信息。&lt;/p&gt;
&lt;p&gt;　　　　插入InfluxDB代码和上面基本类似只不过多了一个批量插入方法&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0f3a7c6d-a5ce-419a-8d6f-64017c7c52c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f3a7c6d-a5ce-419a-8d6f-64017c7c52c9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f3a7c6d-a5ce-419a-8d6f-64017c7c52c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zjs.collection;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.eureka.EnableEurekaClient;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@EnableEurekaClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApplictionCollection 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ApplictionCollection.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_0e1f27c7-18d1-4398-a6c2-d003ca3fcb81&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e1f27c7-18d1-4398-a6c2-d003ca3fcb81&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e1f27c7-18d1-4398-a6c2-d003ca3fcb81&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 批量插入
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; measurement
     *            表
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; tags
     *            标签
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fields
     *            字段
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; batchinsert(String measurement, Map&amp;lt;String, String&amp;gt; tags, List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;span&gt; fieldslist) {
        org.influxdb.dto.BatchPoints.Builder batchbuilder&lt;/span&gt;=&lt;span&gt;BatchPoints.database(database);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map : fieldslist) {
            Builder builder &lt;/span&gt;=&lt;span&gt; Point.measurement(measurement);
            tags.put(&lt;/span&gt;&quot;instanceId&quot;, map.get(&quot;instanceId&quot;&lt;span&gt;).toString());
            builder.time((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)map.get(&quot;currentTime&quot;&lt;span&gt;), TimeUnit.NANOSECONDS);
            builder.tag(tags);
            builder.fields(map);
            batchbuilder.point(builder.build());
        }
        
        System.out.println(batchbuilder.build().toString());
        
        influxDB.write(batchbuilder.build());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_2b377ce7-9297-4227-9e6a-3ecce283148f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b377ce7-9297-4227-9e6a-3ecce283148f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b377ce7-9297-4227-9e6a-3ecce283148f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zjs.collection;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ArrayBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.ServiceInstance;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.DiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.SimpleClientHttpRequestFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.EnableScheduling;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Scheduled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 获取微服务实例
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zyg
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
@SpringBootApplication
@EnableScheduling
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MicServerInstanceInfoHandle {

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(MicServerInstanceInfoHandle.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String pathtail = &quot;/metrics/mem.*|heap.*|threads.*|gc.*|nonheap.*|classes.*&quot;&lt;span&gt;;

    Map&lt;/span&gt;&amp;lt;String, String&amp;gt;&lt;span&gt; tags;

    ThreadPoolExecutor threadpool;

    @Autowired
    DiscoveryClient dc;

    @Autowired
    RestTemplate restTemplate;

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LinkedBlockingQueue&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; jsonMetrics = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(1000&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化实例 可以吧相关参数设置到配置文件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MicServerInstanceInfoHandle() {
        
        tags &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        threadpool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(4, 20, 60, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(100&lt;span&gt;));

    }

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InfluxDBConnect influxDB;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * metrics数据获取
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(fixedDelay &lt;/span&gt;= 2000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; metricsDataObtain() {
        logger.info(&lt;/span&gt;&quot;开始获取metrics数据&quot;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;String&amp;gt; servicelist =&lt;span&gt; dc.getServices();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String str : servicelist) {

            List&lt;/span&gt;&amp;lt;ServiceInstance&amp;gt; silist =&lt;span&gt; dc.getInstances(str);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ServiceInstance serviceInstance : silist) {
                threadpool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MetricsHandle(serviceInstance));
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将数据插入到influxdb数据库
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(fixedDelay &lt;/span&gt;= 5000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; metricsDataToInfluxDB() {
        logger.info(&lt;/span&gt;&quot;开始批量将metrics数据insert-influxdb&quot;&lt;span&gt;);
        ArrayList&lt;/span&gt;&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; metricslist = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        MicServerInstanceInfoHandle.jsonMetrics.drainTo(metricslist);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;metricslist.isEmpty()) {
            logger.info(&lt;/span&gt;&quot;批量插入条数:{}&quot;&lt;span&gt;, metricslist.size());
            influxDB.batchinsert(&lt;/span&gt;&quot;metrics&quot;&lt;span&gt;, tags, metricslist);
        }

        logger.info(&lt;/span&gt;&quot;结束批量metrics数据insert&quot;&lt;span&gt;);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate getRestTemplate() {
        RestTemplate restTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
        SimpleClientHttpRequestFactory achrf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleClientHttpRequestFactory();
        achrf.setConnectTimeout(&lt;/span&gt;10000&lt;span&gt;);
        achrf.setReadTimeout(&lt;/span&gt;10000&lt;span&gt;);
        restTemplate.setRequestFactory(achrf);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; restTemplate;

    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MetricsHandle &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServiceInstance serviceInstanc;
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MetricsHandle(ServiceInstance serviceInstance){
            serviceInstanc&lt;/span&gt;=&lt;span&gt;serviceInstance;
        }
        
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                
                logger.info(&lt;/span&gt;&quot;获取  {}:{}:{} 应用metrics数据&quot;&lt;span&gt;,serviceInstanc.getServiceId(),serviceInstanc.getHost(),serviceInstanc.getPort());
                
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; mapdata =&lt;span&gt; restTemplate
                        .getForObject(serviceInstanc.getUri().toString() &lt;/span&gt;+ pathtail, Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                mapdata.put(&lt;/span&gt;&quot;instanceId&quot;, serviceInstanc.getServiceId() + &quot;:&quot; + serviceInstanc.getHost() + &quot;:&quot;
                        +&lt;span&gt; serviceInstanc.getPort());
                mapdata.put(&lt;/span&gt;&quot;type&quot;, &quot;metrics&quot;&lt;span&gt;);
                mapdata.put(&lt;/span&gt;&quot;currentTime&quot;, System.currentTimeMillis() * 1000000&lt;span&gt;);
                MicServerInstanceInfoHandle.jsonMetrics.add(mapdata);

            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                logger.error(&lt;/span&gt;&quot;instanceId:{},host:{},port:{},path:{},exception:{}&quot;&lt;span&gt;, serviceInstanc.getServiceId(),
                        serviceInstanc.getHost(), serviceInstanc.getPort(), serviceInstanc.getUri(),
                        e.getMessage());
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里简单解释一下这句代码 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;final&lt;/span&gt; String pathtail = &quot;/metrics/mem.*|heap.*|threads.*|gc.*|nonheap.*|classes.*&quot;;&lt;/span&gt; ，metrics这个路径下的信息很多但是我们不是都需要所以我们需要有选择的获取这样节省流量和时间。上面关键类MicServerInstanceInfoHandle做了一个多线程访问主要应对注册中心有成百上千个服务的时候单线程可能轮序不过来，同时做了一个队列缓冲，批量插入到InfluxDB。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;四、结果展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201807/560839-20180723151322326-1834282240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如果你数据采集成功了就可以绘制出来上面的图形下面是对应的sql&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; mean(&quot;rollingCountFallbackSuccess&quot;), mean(&quot;rollingCountSuccess&quot;) &lt;span&gt;FROM&lt;/span&gt; &quot;testaaa&quot; &lt;span&gt;WHERE&lt;/span&gt; (&quot;instanceId&quot; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IP:spring-cloud-server1-test:8082&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &quot;type&quot; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HystrixCommand&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; $timeFilter &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; time($__interval) fill(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; mean(&quot;currentPoolSize&quot;) &lt;span&gt;FROM&lt;/span&gt; &quot;testaaa&quot; &lt;span&gt;WHERE&lt;/span&gt; (&quot;type&quot; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HystrixThreadPool&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &quot;instanceId&quot; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.10.12.51:spring-cloud-server1-test:8082&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; $timeFilter &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; time($__interval) fill(&lt;span&gt;null&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &quot;heap&quot;, &quot;heap.&lt;span&gt;committed&lt;/span&gt;&quot;, &quot;heap.used&quot;, &quot;mem&quot;, &quot;mem.free&quot;, &quot;nonheap&quot;, &quot;nonheap.&lt;span&gt;committed&lt;/span&gt;&quot;, &quot;nonheap.used&quot; &lt;span&gt;FROM&lt;/span&gt; &quot;metrics&quot; &lt;span&gt;WHERE&lt;/span&gt; (&quot;instanceId&quot; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SPRING-CLOUD-SERVER1-TEST:10.10.12.51:8082&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; $timeFilter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　好了到这里就基本结束了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;五、优化及设想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　上面的基础服务肯定都是需要高可用的，毋庸置疑都是需要学习的。如果有时间我也会向大家一一介绍，大家亦可以去搜索相关资料查看！&lt;/p&gt;
&lt;p&gt;　　　　可能有人问有一个叫telegraf的小插件直接就能收集相关数据进行聚合结果监控，&lt;/p&gt;
&lt;p&gt;　　　　其实我之前也是使用的telegraf这个小工具但是发现一个问题，&lt;/p&gt;
&lt;p&gt;　　　　就是每次被监控的应用重启的时候相关字段名就会变，&lt;/p&gt;
&lt;p&gt;　　　　因为他采集使用的是类实例的名字作为字段名，这应我们会很不方便，每次重启应用我们都要重新设置sql语句这样非常不友好，&lt;/p&gt;
&lt;p&gt;　　　　再次感觉收集数据编码难度不大所以自己就写了收集数据的代码！如果有哪位大神对telegraf比较了解可以解决上面我说的问题记得给我留言哦！在这里先感谢！&lt;/p&gt;
&lt;p&gt;　　　　有些地方是需要优化的，比如一些IP端口什么的都是可以放到配置文件里面的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　从spring boot到现在短短的2、3年时间就迅速变得火爆，知识体系也变得完善，开发成本越来越低，&lt;/p&gt;
&lt;p&gt;　　　　所以普及程度就越来越高，微服务虽然很好但是我们也要很好的善于运用，监控就是重要的一环，&lt;/p&gt;
&lt;p&gt;　　　　试想一下你的机房运行着成千上万的服务，稳定运行和及时发现有问题的服务是多么重要的一件事情！&lt;/p&gt;
&lt;p&gt;　　　　希望以上对大家有所帮助&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 07:36:00 +0000</pubDate>
<dc:creator>zygfengyuwuzu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhyg/p/9354952.html</dc:identifier>
</item>
<item>
<title>编写高质量代码:改善Java程序的151个建议 --[0~25] - 西北野狼</title>
<link>http://www.cnblogs.com/androidsuperman/p/9354912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/androidsuperman/p/9354912.html</guid>
<description>&lt;p&gt;编写高质量代码:改善Java程序的151个建议&lt;/p&gt;
&lt;h5 id=&quot;警惕自增的陷阱&quot;&gt;警惕自增的陷阱&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Client7 {
    public static void main(String[] args) {
        int count=0;
        for(int i=0; i&amp;lt;10;i++){
            count=count++;
        }
        System.out.println(&quot;count = &quot;+count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;count++是一个表达式，是由返回值的，它的返回值就是count自加前的值，Java对自加是这样处理的：首先把count的值(注意是值，不是引用)拷贝到一个临时变量区，然后对count变量+1，最后返回临时变量区的值。程序第一次循环处理步骤如下:&lt;/p&gt;
&lt;p&gt;JVM把count的值（其值是0）拷贝到临时变量区；&lt;br/&gt;count的值+1，这时候count的值是1；&lt;br/&gt;返回临时变量区的值，注意这个值是0，没修改过；&lt;br/&gt;返回值赋给count，此时count的值被重置为0.&lt;/p&gt;
&lt;p&gt;如下理解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static int mockAdd(int count) {
        // 先保存初始值
        int temp = count;
        // 做自增操作
        count = count + 1;
        // 返回原始值
        return temp;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;不要在本类中覆盖静态导入的变量和方法&quot;&gt;不要在本类中覆盖静态导入的变量和方法&lt;/h5&gt;
&lt;p&gt;编译器有一个&quot;最短路径&quot;原则:如果能够在本类中查找到相关的变量、常量、方法、就不会去其它包或父类、接口中查找，以确保本类中的属性、方法优先。&lt;br/&gt;因此，如果要变更一个被静态导入的方法，最好的办法是在原始类中重构，而不是在本类中覆盖.&lt;/p&gt;
&lt;h5 id=&quot;显示声明serialversionuid可以避免对象的不一致但尽量不要以这种方式向jvm撒谎&quot;&gt;显示声明serialVersionUID可以避免对象的不一致，但尽量不要以这种方式向JVM撒谎。&lt;/h5&gt;
&lt;h5 id=&quot;避免用序列化类在构造函数中为不变量赋值&quot;&gt;避免用序列化类在构造函数中为不变量赋值&lt;/h5&gt;
&lt;p&gt;反序列化时构造函数不会执行&lt;/p&gt;
&lt;p&gt;反序列化时final变量在以下情况下不会被重新赋值:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过构造函数为final变量赋值&lt;/li&gt;
&lt;li&gt;通过方法返回值为final变量赋值&lt;/li&gt;
&lt;li&gt;final修饰的属性不是基本类型&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;使用序列化类的私有方法巧妙解决部分属性持久化问题&quot;&gt;使用序列化类的私有方法巧妙解决部分属性持久化问题&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person implements Serializable {

    private static final long serialVersionUID = 9146176880143026279L;

    private String name;

    private transient Salary salary;

    public Person(String _name, Salary _salary) {
        this.name = _name;
        this.salary = _salary;
    }
    //序列化委托方法
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();
        oos.writeInt(salary.getBasePay());
    }
    //反序列化委托方法
    private void readObject(ObjectInputStream input)throws ClassNotFoundException, IOException {
        input.defaultReadObject();
        salary = new Salary(input.readInt(), 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;switch-语句里面break不可少&quot;&gt;switch 语句里面break不可少&lt;/h5&gt;
&lt;h5 id=&quot;慎用动态编译&quot;&gt;慎用动态编译&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;在框架中谨慎使用：比如要在struts中使用动态编译，动态实现一个类，它若继承自ActionSupport就希望它成为一个Action。能做到，但是debug很困难；再比如在Spring中，写一个动态类，要让它注入到Spring容器中，这是需要花费老大功夫的。&lt;/li&gt;
&lt;li&gt;不要在要求性能高的项目中使用：如果你在web界面上提供了一个功能，允许上传一个java文件然后运行，那就等于说:&quot;我的机器没有密码，大家都可以看看&quot;，这是非常典型的注入漏洞，只要上传一个恶意Java程序就可以让你所有的安全工作毁于一旦。&lt;/li&gt;
&lt;li&gt;记录动态编译过程：建议记录源文件，目标文件，编译过程，执行过程等日志，不仅仅是为了诊断，还是为了安全和审计，对Java项目来说，空中编译和运行时很不让人放心的，留下这些依据可以很好地优化程序。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;断言绝对不是鸡肋&quot;&gt;断言绝对不是鸡肋&lt;/h4&gt;
&lt;p&gt;什么情况下能够使用assert呢？一句话：按照正常的执行逻辑不可能到达的代码区域可以防止assert。具体分为三种情况：&lt;/p&gt;
&lt;p&gt;在私有方法中放置assert作为输入参数的校验：在私有方法中可以放置assert校验输入参数，因为私有方法的使用者是作者自己，私有的方法的调用者和被调用者是一种契约关系，或者说没有契约关系，期间的约束是靠作者自己控制的，因此加上assert可以更好地预防自己犯错，或者无意的程序犯错。&lt;br/&gt;流程控制中不可能到达的区域：这类似于Junit的fail方法，其标志性的意义就是，程序执行到这里就是错误的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void doSomething() {
        int i = 7;
        while (i &amp;gt; 7) {
            /* 业务处理 */
        }
        assert false : &quot;到达这里就表示错误&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;不要只替换一个类&quot;&gt;不要只替换一个类&lt;/h4&gt;
&lt;p&gt;对于final修饰的基本类型和String类型，编译器会认为它是稳定态的(Immutable Status)所以在编译时就直接把值编译到字节码中了，避免了在运行期引用（Run-time Reference），以提高代码的执行效率。对于我们的例子来说，Client类在编译时字节码中就写上了&quot;150&quot;,这个常量，而不是一个地址引用，因此无论你后续怎么修改常量类，只要不重新编译Client类，输出还是照旧。&lt;/p&gt;
&lt;p&gt;　　对于final修饰的类(即非基本类型)，编译器会认为它不是稳定态的（Mutable Status），编译时建立的则是引用关系（该类型也叫作Soft Final）。如果Client类引入的常量是一个类或实例，及时不重新编译也会输出最新值。&lt;/p&gt;
&lt;p&gt;发布应用系统时禁止使用类文件替换方式，整体WAR包发布才是万全之策。&lt;/p&gt;
&lt;h4 id=&quot;用偶判断不用奇判断&quot;&gt;用偶判断，不用奇判断&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; i % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用整数类型处理货币&quot;&gt;用整数类型处理货币&lt;/h4&gt;
&lt;p&gt;(1)、使用BigDecimal&lt;/p&gt;
&lt;p&gt;　　　　BigDecimal是专门为弥补浮点数无法精确计算的缺憾而设计的类，并且它本身也提供了加减乘除的常用数学算法。特别是与数据库Decimal类型的字段映射时，BigDecimal是最优的解决方案。&lt;/p&gt;
&lt;p&gt;(2)、使用整型&lt;/p&gt;
&lt;p&gt;　　　　把参与运算的值扩大100倍，并转为整型，然后在展现时再缩小100倍，这样处理的好处是计算简单，准确，一般在非金融行业(如零售行业)应用较多。此方法还会用于某些零售POS机，他们输入和输出的全部是整数，那运算就更简单了.&lt;/p&gt;
&lt;h4 id=&quot;基本类型转换时使用主动声明方式减少不必要的bug.&quot;&gt;基本类型转换时，使用主动声明方式减少不必要的Bug.&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long dis2 = LIGHT_SPEED * 60L * 8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　60L是一个长整型，乘出来的结果也是一个长整型的（此乃Java的基本转换规则，向数据范围大的方向转换，也就是加宽类型），在还没有超过int类型的范围时就已经转换为long型了，彻底解决了越界问题。在实际开发中，更通用的做法是主动声明类型转化(注意，不是强制类型转换)代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long dis2 = 1L * LIGHT_SPEED * 60L * 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　既然期望的结果是long型，那就让第一个参与的参数也是Long(1L)吧，也就说明&quot;嗨&quot;我已经是长整型了，你们都跟着我一块转为长整型吧。&lt;/p&gt;
&lt;h4 id=&quot;边界还是边界&quot;&gt;边界还是边界&lt;/h4&gt;
&lt;p&gt;int long 这些类型的最大值，最小值的边界处理&lt;/p&gt;
&lt;p&gt;银行家舍入(Banker's Round)的近似算法，其规则如下：&lt;/p&gt;
&lt;p&gt;舍去位的数值小于5时，直接舍去；&lt;br/&gt;舍去位的数值大于等于6时，进位后舍去；&lt;br/&gt;当舍去位的数值等于5时，分两种情况：5后面还有其它数字(非0)，则进位后舍去；若5后面是0(即5是最后一个数字)，则根据5前一位数的奇偶性来判断是否需要进位，奇数进位，偶数舍去。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.math.BigDecimal;
import java.math.RoundingMode;

public class Client25 {
    public static void main(String[] args) {
        // 存款
        BigDecimal d = new BigDecimal(888888);
        // 月利率，乘3计算季利率
        BigDecimal r = new BigDecimal(0.001875*3);
        //计算利息
        BigDecimal i =d.multiply(r).setScale(2,RoundingMode.HALF_EVEN);
        System.out.println(&quot;季利息是：&quot;+i);
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ROUND_UP：原理零方向舍入。向远离0的方向舍入，也就是说，向绝对值最大的方向舍入，只要舍弃位非0即进位。&lt;br/&gt;ROUND_DOWN：趋向0方向舍入。向0方向靠拢，也就是说，向绝对值最小的方向输入，注意：所有的位都舍弃，不存在进位情况。&lt;br/&gt;ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢，如果是正数，舍入行为类似于ROUND_UP；如果为负数，则舍入行为类似于ROUND_DOWN.注意：Math.round方法使用的即为此模式。&lt;br/&gt;ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢，如果是正数，则舍入行为类似ROUND_DOWN，如果是负数，舍入行为类似以ROUND_UP。&lt;br/&gt;HALF_UP：最近数字舍入(5舍)，这就是我们经典的四舍五入。&lt;br/&gt;HALF_DOWN：最近数字舍入(5舍)。在四舍五入中，5是进位的，在HALF_DOWN中却是舍弃不进位。&lt;br/&gt;HALF_EVEN：银行家算法&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 07:33:00 +0000</pubDate>
<dc:creator>西北野狼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/androidsuperman/p/9354912.html</dc:identifier>
</item>
<item>
<title>【RL-TCPnet网络教程】第9章    RL-TCPnet网络协议栈移植（uCOS-III） - 席萌0209</title>
<link>http://www.cnblogs.com/armfly/p/9354695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/9354695.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章教程为大家讲解RL-TCPnet网络协议栈的uCOS-III操作系统移植方式，学习了第6章讲解的底层驱动接口函数之后，移植就比较容易了，主要是添加库文件、配置文件和驱动文件即可。另外，RL-TCPnet移植到uCOS-III要重新配置RL-TCPnet的接口函数，以此来支持RL-TCPent多任务运行。使用RTX无需重新配置，因为默认情况下就是采用RTX的API函数配置的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章教程含STM32F407开发板和STM32F429开发板的移植。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.1  移植前准备工作说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.2  STM32F407移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.3  STM32F429移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.4  总结&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;9.1  移植前准备工作说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、学习本章节前，务必要优先学习第6章的底层驱动讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、RL-TCPnet只有库，没有源码。库分为两个版本，一个用于调试的版本TCPD_CM3.lib和一个正式版本TCP_CM3.lib，当前的例子统一使用调试版本。另外注意，虽然是CM3版本的，但可同时用于CM3和CM4内核的MCU，因为官方没有专门的CM4内核库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、测试时，请将网线接到路由器或者交换机上面测试，因为已经使能了DHCP，可以自动获取IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    而且使能了NetBIOS局域网域名，用户只需在电脑端ping armfly，就可以获得板子的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果要使用固定IP进行测试，请看第57章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、网口使用的是DM9161/9162（紧挨着9帧串口座的网口），而不是DM9000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、找一个简单的工程，最好是跑马灯之类的，越简单越好，我们就在这个简单的工程上面移植即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;9.2   STM32F407移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;9.2.1      RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的uCOS-III工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145348254-964600976.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们uCOS-III模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145355047-1730261885.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145402645-1767734986.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程，添加完毕后的效果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145415148-580807818.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_lib.c，Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145421758-165477938.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145428931-867804500.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.2.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145437845-1313786029.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145443113-382374788.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145451336-801185910.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145459448-520754346.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145506900-1314373255.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145513682-147712097.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.2.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145522838-587253042.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145529710-409309219.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.2.4     RL-TCPnet的多任务驱动接口函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要让RL-TCPnet支持多任务，就需要修改Net_lib.c文件。默认情况下，Net_lib.c文件是支持RTX操作系统的，现在要将其修改为支持uCOS-III，需要修改的几个地方如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加uCOS-III的头文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (__RTX)&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;os.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义信号量和互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)

 &lt;span&gt;static&lt;/span&gt; BSD_INFO bsd_scb[BSD_NUMSOCKS +&lt;span&gt; BSD_SRVSOCKS];

 #ifdef __RTX

   OS_MUTEX  bsd_mutex;

   OS_SEM    bsd_sem;

  &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __TRUE

 &lt;span&gt;#else&lt;/span&gt;

  &lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __FALSE

 &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建互斥信号量和信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- init_system -----------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; init_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_init ();

  icmp_init ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (UDP_ENABLE)&lt;span&gt;

  udp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_init ();

 &lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (BSD_GETHOSTEN)&lt;span&gt;

  bsd_init_host ();

 &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; NBNS_ENABLE)&lt;span&gt;

  nbns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_init ();

&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  arp_notify ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

 {

     OS_ERR err;

     OSMutexCreate(&lt;/span&gt;&amp;amp;&lt;span&gt;bsd_mutex,

                     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BSD Mutex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                      &lt;/span&gt;&amp;amp;&lt;span&gt;err);

                     

     OSSemCreate((OS_SEM    &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

                   (CPU_CHAR  &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BSD Sem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                   (OS_SEM_CTR )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                   (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统运行时，使用互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- run_system ------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; run_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Run configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  OS_ERR err;

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_run_local ();

  icmp_run_engine ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_run_host ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_run_agent ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，Socket挂起和恢复的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_suspend/resume ----------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_suspend (U8 *&lt;span&gt;tsk_id) {

     OS_ERR err;

    

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Suspend a socket owner task. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

  OSSemPend((OS_SEM &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

              (OS_TICK )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_OPT  )OS_OPT_PEND_BLOCKING,

              (CPU_TS  )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_ERR &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);  

    

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err); 

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bsd_resume (U8 tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Resume a task waiting for a socket event. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSSemPost((OS_SEM &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

             (OS_OPT  )OS_OPT_POST_1,

             (OS_ERR &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;strong&gt;使能BSD Socket的话，锁机制的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_lock/unlock -------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_lock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acquire mutex - Lock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err); 

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_unlock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Release mutex - Unlock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;9.2.5     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V5-1002_RL-TCPnet实验_工程移植模板（uCOS-III）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145604489-1003173568.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;uCOS-III&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task Start任务   ：启动任务，实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task TCPnet任务 ：RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task MspPro任务：消息处理，这里用作按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task UserIF任务 ：按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task COM任务  ：LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;139&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                       静态全局变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                                                          

&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskStartTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskStartStk[APP_CFG_TASK_START_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskTCPnetTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskTCPnetStk[APP_CFG_TASK_TCPnet_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskMsgProTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskMsgProStk[APP_CFG_TASK_MsgPro_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskCOMTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskCOMStk[APP_CFG_TASK_COM_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskUserIFTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskUserIFStk[APP_CFG_TASK_USER_IF_STK_SIZE];

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      函数声明

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskStart          (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskTCPnet         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskMsgPro         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskUserIF         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCOM             (&lt;span&gt;void&lt;/span&gt;      *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCreate         (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  DispTaskInfo          (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppObjCreate          (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  App_Printf (CPU_CHAR *&lt;span&gt;format, ...);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*******************************************************************************************************

*                               变量

*******************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  OS_SEM   AppPrintfSemp;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于printf互斥 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

OS_FLAG_GRP        FLAG_TCPnet;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    OS_ERR  err; 

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化uC/OS-III 内核 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSInit(&lt;/span&gt;&amp;amp;&lt;span&gt;err); 

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建一个启动任务（也就是主任务）。启动任务会创建所有的应用程序任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;AppTaskStartTCB,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务控制块地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;          

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_TASK_PTR   )AppTaskStart,      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动任务函数地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;,                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 传递给任务的参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_PRIO       )APP_CFG_TASK_START_PRIO, &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskStartStk[&lt;span&gt;0&lt;/span&gt;],     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈基地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK_SIZE  )APP_CFG_TASK_START_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈监测区，这里表示后10%作为监测区 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK_SIZE  )APP_CFG_TASK_START_STK_SIZE,      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈空间大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 本任务支持接受的最大消息数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置时间片 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈空间大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

        

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  定义如下：

                       OS_OPT_TASK_STK_CHK      使能检测任务栈，统计任务栈已用的和未用的

                       OS_OPT_TASK_STK_CLR      在创建任务时，清零任务栈

                       OS_OPT_TASK_SAVE_FP      如果CPU有浮点寄存器，则在任务切换时保存浮点寄存器的内容

                    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动多任务系统，控制权交给uC/OS-III &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSStart(&lt;/span&gt;&amp;amp;&lt;span&gt;err);                                              

   

    (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)&amp;amp;&lt;span&gt;err;

   

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskStart

*    功能说明: 这是一个启动任务，在多任务系统启动后，必须初始化滴答计数器。本任务主要实现RL-TCPnet的时间

*             基准更新。

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 2

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskStart (&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR      err;

 

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

    

     CPU_Init();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 此函数要优先调用，因为外设驱动中使用的us和ms延迟是基于此函数的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();  

     init_TcpNet ();&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     BSP_Tick_Init();

    

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; OS_CFG_STAT_TASK_EN &amp;gt; 0u&lt;span&gt;

     OSStatTaskCPUUsageInit(&lt;/span&gt;&amp;amp;&lt;span&gt;err);  

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

 

#ifdef CPU_CFG_INT_DIS_MEAS_EN

    CPU_IntDisMeasMaxCurReset();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

   

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    AppTaskCreate();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务间通信机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppObjCreate();   

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     { 

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

         OSTimeDly(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, OS_OPT_TIME_PERIODIC, &amp;amp;&lt;span&gt;err);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskTCPnet

*    功能说明: RL-TCPnet测试任务

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 3

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         TCPnetTest();

     }  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskMsgPro

*    功能说明: 消息处理，这里用按键检测

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 3

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err; 

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         bsp_KeyScan();

         OSTimeDly(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);     

     }  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskUserIF

*    功能说明: 按键消息处理

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 4

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err; 

     uint8_t ucKeyCode; &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键代码 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {       

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY1_BIT0,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                     (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);                   

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY2_BIT1,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                     (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY3_BIT2,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit20 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                      (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 摇杆的OK键按下 打印任务执行情况 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; JOY_DOWN_OK:            

                       DispTaskInfo();        

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;:                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         OSTimeDly(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCom

*    功能说明: LED闪烁

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 5

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCOM(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err;      

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {   

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

         OSTimeDly(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);

     }                                                                                                

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参：p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_ERR      err;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建MsgPro任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskTCPnetTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task TCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskTCPnet,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_TCPnet_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskTCPnetStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_TCPnet_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_TCPnet_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建MsgPro任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskMsgProTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task MspPro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskMsgPro,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_MsgPro_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskMsgProStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_MsgPro_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_MsgPro_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建USER IF任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskUserIFTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task UserIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskUserIF,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_USER_IF_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskUserIFStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_USER_IF_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_USER_IF_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建COM任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskCOMTCB,           

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task COM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskCOM,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_COM_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskCOMStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_COM_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_COM_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppObjCreate

*    功能说明: 创建任务通讯

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_ERR      err;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建信号量数值为1的时候可以实现互斥功能，也就是只有一个资源可以使用

        本例程是将串口1的打印函数作为保护的资源。防止串口打印的时候被其它任务抢占

        造成串口打印错乱。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSSemCreate((OS_SEM    &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppPrintfSemp,

                   (CPU_CHAR  &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppPrintfSemp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                   (OS_SEM_CTR )&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,

                   (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建事件标志组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSFlagCreate ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                  (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FLAG TCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                  (OS_FLAGS      )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                  (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: App_Printf

*    功能说明: 线程安全的printf方式                      

*    形    参: 同printf的参数。

*             在C中，当无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  App_Printf(CPU_CHAR *&lt;span&gt;format, ...)

{

    CPU_CHAR  buf_str[&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    va_list   v_args;

    OS_ERR    os_err;

 

 

    va_start(v_args, format);

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)vsnprintf((&lt;span&gt;char&lt;/span&gt;       *)&amp;amp;buf_str[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                   (size_t      ) &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf_str),

                   (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;) format,

                                  v_args);

    va_end(v_args);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 互斥操作 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSSemPend((OS_SEM  &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppPrintfSemp,

              (OS_TICK  )&lt;/span&gt;&lt;span&gt;0u&lt;/span&gt;&lt;span&gt;,

              (OS_OPT   )OS_OPT_PEND_BLOCKING,

              (CPU_TS  &lt;/span&gt;*)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_ERR  &lt;/span&gt;*)&amp;amp;&lt;span&gt;os_err);

 

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf_str);

 

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)OSSemPost((OS_SEM  *)&amp;amp;&lt;span&gt;AppPrintfSemp,

                   (OS_OPT   )OS_OPT_POST_1,

                   (OS_ERR  &lt;/span&gt;*)&amp;amp;&lt;span&gt;os_err);

 

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: DispTaskInfo

*    功能说明: 将uCOS-III任务信息通过串口打印出来

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DispTaskInfo(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_TCB      &lt;/span&gt;*p_tcb;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义一个任务控制块指针, TCB = TASK CONTROL BLOCK &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;float&lt;/span&gt; CPU = &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;;

     CPU_SR_ALLOC();

 

     CPU_CRITICAL_ENTER();

    p_tcb &lt;/span&gt;=&lt;span&gt; OSTaskDbgListPtr;

    CPU_CRITICAL_EXIT();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 打印标题 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 优先级 使用栈 剩余栈 百分比 利用率   任务名\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Prio   Used  Free   Per    CPU     Taskname\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 遍历任务控制块列表(TCB list)，打印所有的任务的优先级和名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt; (p_tcb != (OS_TCB *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         CPU &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)p_tcb-&amp;gt;CPUUsage / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

         App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   %2d  %5d  %5d   %02d%%   %5.2f%%   %s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;Prio,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;StkUsed,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;StkFree,

         (p_tcb&lt;/span&gt;-&amp;gt;StkUsed * &lt;span&gt;100&lt;/span&gt;) / (p_tcb-&amp;gt;StkUsed + p_tcb-&amp;gt;&lt;span&gt;StkFree),

         CPU,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;NamePtr);      

         

         CPU_CRITICAL_ENTER();

        p_tcb &lt;/span&gt;= p_tcb-&amp;gt;&lt;span&gt;DbgNextPtr;

        CPU_CRITICAL_EXIT();

     }

}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化硬件设备

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置NVIC优先级分组为Group4：可配置0-15级抢占式优先级，0级子优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

    

     bsp_InitUart();       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;        

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

          &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     OS_ERR       err;

     CPU_TS        ts;

     OS_FLAGS     xResult;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usMaxBlockTime = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

         xResult &lt;/span&gt;= OSFlagPend ((OS_FLAG_GRP  *)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                   (OS_FLAGS      )&lt;/span&gt;&lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;,

                                   (OS_TICK       )usMaxBlockTime,

                                   (OS_OPT        )OS_OPT_PEND_FLAG_SET_ANY &lt;/span&gt;+&lt;span&gt; OS_OPT_PEND_FLAG_CONSUME,

                                   (CPU_TS       &lt;/span&gt;*)&amp;amp;&lt;span&gt;ts,

                                   (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((err == OS_ERR_NONE)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (xResult)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，uCOS-III方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.2.6     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看你的网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F407开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145652144-1814044375.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145703669-279853075.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145709709-910453537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145716772-184914450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;9.3  STM32F429移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;9.3.1     RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的uCOS-III工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145742770-1387365692.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们uCOS-III模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145804623-155477477.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145810848-1589805200.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加完毕后的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145825456-2078913828.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_lib.c，Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上面新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145832149-249370930.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145838145-1316536929.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.3.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145844997-1273506330.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145851186-319030065.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145857215-1920625204.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145904292-337886829.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145909788-1899977855.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145914906-1584600023.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.3.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到如下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145929827-1642104461.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145941316-680406810.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.3.4     RL-TCPnet的多任务驱动接口函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要让RL-TCPnet支持多任务，就需要修改Net_lib.c文件。默认情况下，Net_lib.c文件是支持RTX操作系统的，现在要将其修改为支持uCOS-III，需要修改的几个地方如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加uCOS-III的头文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (__RTX)&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;os.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义信号量和互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)

 &lt;span&gt;static&lt;/span&gt; BSD_INFO bsd_scb[BSD_NUMSOCKS +&lt;span&gt; BSD_SRVSOCKS];

 #ifdef __RTX

   OS_MUTEX  bsd_mutex;

   OS_SEM    bsd_sem;

  &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __TRUE

 &lt;span&gt;#else&lt;/span&gt;

  &lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __FALSE

 &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建互斥信号量和信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- init_system -----------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; init_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_init ();

  icmp_init ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (UDP_ENABLE)&lt;span&gt;

  udp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_init ();

 &lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (BSD_GETHOSTEN)&lt;span&gt;

  bsd_init_host ();

 &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; NBNS_ENABLE)&lt;span&gt;

  nbns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_init ();

&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  arp_notify ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

 {

     OS_ERR err;

     OSMutexCreate(&lt;/span&gt;&amp;amp;&lt;span&gt;bsd_mutex,

                     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BSD Mutex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                      &lt;/span&gt;&amp;amp;&lt;span&gt;err);

                     

     OSSemCreate((OS_SEM    &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

                   (CPU_CHAR  &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BSD Sem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                   (OS_SEM_CTR )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                   (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统运行时，使用互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- run_system ------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; run_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Run configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  OS_ERR err;

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_run_local ();

  icmp_run_engine ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_run_host ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_run_agent ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，Socket挂起和恢复的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_suspend/resume ----------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_suspend (U8 *&lt;span&gt;tsk_id) {

     OS_ERR err;

    

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Suspend a socket owner task. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

  OSSemPend((OS_SEM &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

              (OS_TICK )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_OPT  )OS_OPT_PEND_BLOCKING,

              (CPU_TS  )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_ERR &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);  

    

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err); 

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bsd_resume (U8 tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Resume a task waiting for a socket event. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSSemPost((OS_SEM &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_sem,

             (OS_OPT  )OS_OPT_POST_1,

             (OS_ERR &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，锁机制的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_lock/unlock -------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_lock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acquire mutex - Lock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSMutexPend((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_TICK    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_OPT     )OS_OPT_PEND_BLOCKING,

                (CPU_TS     )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err); 

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_unlock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Release mutex - Unlock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  OS_ERR err;

    

  OSMutexPost((OS_MUTEX &lt;/span&gt;*)&amp;amp;&lt;span&gt;bsd_mutex,

                (OS_OPT     )OS_OPT_POST_1,

                (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3&gt;9.3.5     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V5-1002_RL-TCPnet实验_工程移植模板（uCOS-III）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723145956333-348418595.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;uCOS-III&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task Start任务   ：启动任务，实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task TCPnet任务 ：RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task MspPro任务：消息处理，这里用作按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task UserIF任务 ：按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Task COM任务  ：LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;139&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                       静态全局变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                                                          

&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskStartTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskStartStk[APP_CFG_TASK_START_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskTCPnetTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskTCPnetStk[APP_CFG_TASK_TCPnet_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskMsgProTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskMsgProStk[APP_CFG_TASK_MsgPro_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskCOMTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskCOMStk[APP_CFG_TASK_COM_STK_SIZE];

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  OS_TCB   AppTaskUserIFTCB;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;  CPU_STK  AppTaskUserIFStk[APP_CFG_TASK_USER_IF_STK_SIZE];

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      函数声明

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskStart          (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskTCPnet         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskMsgPro         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskUserIF         (&lt;span&gt;void&lt;/span&gt;     *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCOM             (&lt;span&gt;void&lt;/span&gt;      *&lt;span&gt;p_arg);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCreate         (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  DispTaskInfo          (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppObjCreate          (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  App_Printf (CPU_CHAR *&lt;span&gt;format, ...);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*******************************************************************************************************

*                               变量

*******************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  OS_SEM   AppPrintfSemp;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于printf互斥 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

OS_FLAG_GRP        FLAG_TCPnet;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    OS_ERR  err; 

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化uC/OS-III 内核 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSInit(&lt;/span&gt;&amp;amp;&lt;span&gt;err); 

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建一个启动任务（也就是主任务）。启动任务会创建所有的应用程序任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;AppTaskStartTCB,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务控制块地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;          

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_TASK_PTR   )AppTaskStart,      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动任务函数地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;,                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 传递给任务的参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_PRIO       )APP_CFG_TASK_START_PRIO, &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskStartStk[&lt;span&gt;0&lt;/span&gt;],     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈基地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK_SIZE  )APP_CFG_TASK_START_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈监测区，这里表示后10%作为监测区 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (CPU_STK_SIZE  )APP_CFG_TASK_START_STK_SIZE,      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈空间大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 本任务支持接受的最大消息数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置时间片 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 堆栈空间大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

        

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  定义如下：

                       OS_OPT_TASK_STK_CHK      使能检测任务栈，统计任务栈已用的和未用的

                       OS_OPT_TASK_STK_CLR      在创建任务时，清零任务栈

                       OS_OPT_TASK_SAVE_FP      如果CPU有浮点寄存器，则在任务切换时保存浮点寄存器的内容

                    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动多任务系统，控制权交给uC/OS-III &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSStart(&lt;/span&gt;&amp;amp;&lt;span&gt;err);                                               

   

    (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)&amp;amp;&lt;span&gt;err;

   

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskStart

*    功能说明: 这是一个启动任务，在多任务系统启动后，必须初始化滴答计数器。本任务主要实现RL-TCPnet的时间

*             基准更新。

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 2

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskStart (&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR      err;

 

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

    

     CPU_Init();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 此函数要优先调用，因为外设驱动中使用的us和ms延迟是基于此函数的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();  

     init_TcpNet ();&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     BSP_Tick_Init();

    

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; OS_CFG_STAT_TASK_EN &amp;gt; 0u&lt;span&gt;

     OSStatTaskCPUUsageInit(&lt;/span&gt;&amp;amp;&lt;span&gt;err);  

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

 

#ifdef CPU_CFG_INT_DIS_MEAS_EN

    CPU_IntDisMeasMaxCurReset();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

   

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    AppTaskCreate();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务间通信机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppObjCreate();   

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     { 

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

         OSTimeDly(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, OS_OPT_TIME_PERIODIC, &amp;amp;&lt;span&gt;err);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskTCPnet

*    功能说明: RL-TCPnet测试任务

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 3

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         TCPnetTest();

     }  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskMsgPro

*    功能说明: 消息处理，这里用按键检测

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 3

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err; 

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         bsp_KeyScan();

         OSTimeDly(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);     

     }  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskUserIF

*    功能说明: 按键消息处理

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 4

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err; 

     uint8_t ucKeyCode; &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键代码 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

          

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {       

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY1_BIT0,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                     (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);                   

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY2_BIT1,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                     (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       OSFlagPost ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                     (OS_FLAGS      )KEY3_BIT2,  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置bit20 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     (OS_OPT        )OS_OPT_POST_FLAG_SET,

                                     (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 摇杆的OK键按下 打印任务执行情况 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; JOY_DOWN_OK:            

                       DispTaskInfo();        

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;:                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         OSTimeDly(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCom

*    功能说明: LED闪烁

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

     优 先 级: 5

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCOM(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;p_arg)

{

     OS_ERR  err;      

    

     (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)p_arg;

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {   

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

         OSTimeDly(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;, OS_OPT_TIME_DLY, &amp;amp;&lt;span&gt;err);

     }                                                                                                

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参：p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_ERR      err;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建MsgPro任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskTCPnetTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task TCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskTCPnet,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_TCPnet_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskTCPnetStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_TCPnet_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_TCPnet_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建MsgPro任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskMsgProTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task MspPro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskMsgPro,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_MsgPro_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskMsgProStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_MsgPro_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_MsgPro_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

                    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建USER IF任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskUserIFTCB,            

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task UserIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskUserIF,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_USER_IF_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskUserIFStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_USER_IF_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_USER_IF_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************创建COM任务********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSTaskCreate((OS_TCB       &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppTaskCOMTCB,           

                 (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App Task COM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                 (OS_TASK_PTR   )AppTaskCOM,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_PRIO       )APP_CFG_TASK_COM_PRIO,

                 (CPU_STK      &lt;/span&gt;*)&amp;amp;AppTaskCOMStk[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                 (CPU_STK_SIZE  )APP_CFG_TASK_COM_STK_SIZE &lt;/span&gt;/ &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,

                 (CPU_STK_SIZE  )APP_CFG_TASK_COM_STK_SIZE,

                 (OS_MSG_QTY    )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_TICK       )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;         *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                 (OS_OPT        )(OS_OPT_TASK_STK_CHK &lt;/span&gt;|&lt;span&gt; OS_OPT_TASK_STK_CLR),

                 (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);  

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppObjCreate

*    功能说明: 创建任务通讯

*    形    参: p_arg 是在创建该任务时传递的形参

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_ERR      err;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建信号量数值为1的时候可以实现互斥功能，也就是只有一个资源可以使用

        本例程是将串口1的打印函数作为保护的资源。防止串口打印的时候被其它任务抢占

        造成串口打印错乱。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSSemCreate((OS_SEM    &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppPrintfSemp,

                   (CPU_CHAR  &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppPrintfSemp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                   (OS_SEM_CTR )&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,

                   (OS_ERR    &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建事件标志组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     OSFlagCreate ((OS_FLAG_GRP  &lt;/span&gt;*)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                  (CPU_CHAR     &lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FLAG TCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                  (OS_FLAGS      )&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

                  (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: App_Printf

*    功能说明: 线程安全的printf方式                      

*    形    参: 同printf的参数。

*             在C中，当无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  App_Printf(CPU_CHAR *&lt;span&gt;format, ...)

{

    CPU_CHAR  buf_str[&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    va_list   v_args;

    OS_ERR    os_err;

 

 

    va_start(v_args, format);

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)vsnprintf((&lt;span&gt;char&lt;/span&gt;       *)&amp;amp;buf_str[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                   (size_t      ) &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf_str),

                   (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;) format,

                                  v_args);

    va_end(v_args);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 互斥操作 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    OSSemPend((OS_SEM  &lt;/span&gt;*)&amp;amp;&lt;span&gt;AppPrintfSemp,

              (OS_TICK  )&lt;/span&gt;&lt;span&gt;0u&lt;/span&gt;&lt;span&gt;,

              (OS_OPT   )OS_OPT_PEND_BLOCKING,

              (CPU_TS  &lt;/span&gt;*)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

              (OS_ERR  &lt;/span&gt;*)&amp;amp;&lt;span&gt;os_err);

 

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf_str);

 

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)OSSemPost((OS_SEM  *)&amp;amp;&lt;span&gt;AppPrintfSemp,

                   (OS_OPT   )OS_OPT_POST_1,

                   (OS_ERR  &lt;/span&gt;*)&amp;amp;&lt;span&gt;os_err);

 

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: DispTaskInfo

*    功能说明: 将uCOS-III任务信息通过串口打印出来

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DispTaskInfo(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_TCB      &lt;/span&gt;*p_tcb;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义一个任务控制块指针, TCB = TASK CONTROL BLOCK &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;float&lt;/span&gt; CPU = &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;;

     CPU_SR_ALLOC();

 

     CPU_CRITICAL_ENTER();

    p_tcb &lt;/span&gt;=&lt;span&gt; OSTaskDbgListPtr;

    CPU_CRITICAL_EXIT();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 打印标题 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 优先级 使用栈 剩余栈 百分比 利用率   任务名\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Prio   Used  Free   Per    CPU     Taskname\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 遍历任务控制块列表(TCB list)，打印所有的任务的优先级和名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt; (p_tcb != (OS_TCB *)&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         CPU &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)p_tcb-&amp;gt;CPUUsage / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

         App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   %2d  %5d  %5d   %02d%%   %5.2f%%   %s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;Prio,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;StkUsed,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;StkFree,

         (p_tcb&lt;/span&gt;-&amp;gt;StkUsed * &lt;span&gt;100&lt;/span&gt;) / (p_tcb-&amp;gt;StkUsed + p_tcb-&amp;gt;&lt;span&gt;StkFree),

         CPU,

         p_tcb&lt;/span&gt;-&amp;gt;&lt;span&gt;NamePtr);      

         

         CPU_CRITICAL_ENTER();

        p_tcb &lt;/span&gt;= p_tcb-&amp;gt;&lt;span&gt;DbgNextPtr;

        CPU_CRITICAL_EXIT();

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

    

     SystemCoreClockUpdate();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 根据PLL配置更新系统时钟频率变量 SystemCoreClock &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量（必须在 bsp_InitTimer() 之前调用） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_InitExtIO();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; FMC总线上扩展了32位输出IO, 操作LED等外设必须初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

          &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     OS_ERR       err;

     CPU_TS        ts;

     OS_FLAGS     xResult;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usMaxBlockTime = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

         xResult &lt;/span&gt;= OSFlagPend ((OS_FLAG_GRP  *)&amp;amp;&lt;span&gt;FLAG_TCPnet,

                                   (OS_FLAGS      )&lt;/span&gt;&lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;,

                                   (OS_TICK       )usMaxBlockTime,

                                   (OS_OPT        )OS_OPT_PEND_FLAG_SET_ANY &lt;/span&gt;+&lt;span&gt; OS_OPT_PEND_FLAG_CONSUME,

                                   (CPU_TS       &lt;/span&gt;*)&amp;amp;&lt;span&gt;ts,

                                   (OS_ERR       &lt;/span&gt;*)&amp;amp;&lt;span&gt;err);

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((err == OS_ERR_NONE)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (xResult)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，uCOS-III方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.3.6     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看你的网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F429开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723150012985-1242824915.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723150018648-1668955688.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723150024340-1863739008.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180723150029630-1928083942.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;9.4  总结&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本章节为大家讲解了RL-TCPnet网络协议栈的uCOS-III操作系统移植方法，移植相对比较简单。另一个重要内容是Net_Config.c配置向导文件的说明，这个比较重要，初学者要好好熟悉下。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Jul 2018 07:02:00 +0000</pubDate>
<dc:creator>席萌0209</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/9354695.html</dc:identifier>
</item>
<item>
<title>数据分析与机器学习之线性回归与逻辑回归(六) - 诚实善良小郎君</title>
<link>http://www.cnblogs.com/why957/p/9354600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/why957/p/9354600.html</guid>
<description>&lt;h4 id=&quot;一-机器学习分类&quot;&gt;一 机器学习分类&lt;/h4&gt;
&lt;ul&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;有监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;strong&gt;1 概述:&lt;/strong&gt; 主要用于决策支持，它利用有&lt;strong&gt;标识&lt;/strong&gt;的历史数据进行训练，以实现对新数据的表示的预测&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 分类:&lt;/strong&gt; 分类计数预测的数据对象是&lt;strong&gt;离散&lt;/strong&gt;的。如短信是否为垃圾短信，用户是否喜欢电子产品&lt;/p&gt;
&lt;p&gt;​ 比如: &lt;strong&gt;K近邻、朴素贝叶斯、决策树、SVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 回归:&lt;/strong&gt; 回归技术预测的数据对象是&lt;strong&gt;连续&lt;/strong&gt;值, 例如温度变化或时间变化。包括一元回归和多元回&lt;/p&gt;
&lt;p&gt;​ 归，线性回归和非线性回归: 例如 &lt;strong&gt;线性回归、逻辑回归、岭回归&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;无监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;1 概述&lt;/strong&gt;: 数据无标识, 主要用于知识发现，在历史数据中发现隐藏的模式或内在结构&lt;/p&gt;
&lt;p&gt;2 &lt;strong&gt;聚类&lt;/strong&gt;: 聚类算法用于在数据中寻找隐藏的模式或分组。例如: K-means&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;半监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;1 概述&lt;/strong&gt;: 在半监督学习方式下，&lt;strong&gt;训练数据有部分被标识&lt;/strong&gt;，&lt;strong&gt;部分没有被标识&lt;/strong&gt;，这种模型首先需要学习数据的内在结构，以便合理的组织数据来进行预测。算法上，包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行&lt;strong&gt;建模&lt;/strong&gt;，在此基础上再对标识的数据进行&lt;strong&gt;预测&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二-线性回归数学原理&quot;&gt;二 线性回归数学原理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC1%E9%A1%B5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E6%8F%90%E5%8F%96_%E7%AC%AC3%E9%A1%B5_%E7%AC%AC1%E9%A1%B5.png&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta^T: 特征权重的转置, \theta原本表示一维列矩阵,转置为一维行矩阵,X是一维列矩阵,此时\theta^T x代表行乘列的数值 \]&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;回归问题误差原理及公式推导&quot;&gt;回归问题误差原理及公式推导&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC4%E9%A1%B5.png&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta^Tx^{(i)} 表示预测值, y^{(i)}表示真实值,两者之间存在误差\epsilon^{(i)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(\theta) 似然函数: \theta^Tx^{(i)}要想越接近与y^{(i)},代表求和概率P应该越大越好 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵求导过程省略,公式太多,都是笔记本上推导的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性回归代码实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#导包
import matplotlib.pyplot as plt
import numpy as np
from sklearn import datasets  #导入数据集
%matplotlib inline&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构造线性回归类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#构造类
class LinearRegression():
    #初始化
    def __init__(self):
        self.w = None
    
    #进行训练
    def fit(self,X,y):
        print(X.shape)  #(422, 1)
        X = np.insert(X,0,1,axis=1)  #在列中新增x0 = 1的操作类似插入数据
        print(X.shape)  #(422, 2)
        print(X)
        X_ = np.linalg.inv(X.T.dot(X)) #x的转置dot(x)再取逆操作 
        self.w = X_.dot(X.T).dot(y) #再dot(x的转置)dot(y)
        
    #进行预测
    def predict(self,X):
        X = np.insert(X,0,1,axis=1)
        y_pred = X.dot(self.w)
        return y_pred&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;预测值与测试值平方求均值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#将预测与预测值power2次方
def mean_squared_error(y_true,y_pred):
    mse = np.mean(np.power(y_true-y_pred,2))
    return mse&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主函数执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def main():
    #生成训练/测试数据
    diabetes = datasets.load_diabetes()
    X = diabetes.data[:,np.newaxis,2]
    print(X.shape)  #(442, 1)
    x_train,x_test = X[:-20],X[-20:]
    y_train,y_test = diabetes.target[:-20],diabetes.target[-20:]
    
    #线性回归数据导入:训练 预测
    clf = LinearRegression()
    clf.fit(x_train,y_train)
    y_pred = clf.predict(x_test)
    print(mean_squared_error(y_test,y_pred))
    
    #绘制图形
    plt.scatter(x_test[:,0],y_test,color='black')
    plt.plot(x_test[:,0],y_pred,color='blue',linewidth=3)
    plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三-逻辑斯蒂回归&quot;&gt;三 逻辑斯蒂回归&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC15%E9%A1%B5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC16%E9%A1%B5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑斯蒂原理代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib.pyplot as plt
import pandas as pd
pga = pd.read_csv('../Desktop/pga.csv')

#数据标准归一化处理
pga.distance = (pga.distance - pga.distance.mean()) / pga.distance.std()
pga.accuracy = (pga.accuracy - pga.accuracy.mean()) / pga.accuracy.std()
pga.head()

plt.scatter(pga.distance,pga.accuracy)
plt.xlabel('distance')
plt.ylabel('accurancy')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标函数的构建&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ h_\theta(x) = \theta x + \theta_0 预测函数 \]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#目标函数(损失函数)
def cost(theta0,theta1,x,y):
    J=0
    m = len(x)
    for i in range(m):
        h = theta1*x[i] + theta0  #对应公式 h(x)值
        J += (h-y[i])**2  #目标函数 J = (h(x) - y)**2
    J /= (2*m)
    return J
print(cost(0,1,pga.distance,pga.accuracy))  #1.599438422599817

theta0 = 100
theta1s = np.linspace(-3,2,100)
costs = []
for theta1 in theta1s:
    costs.append(cost(theta0,theta1,pga.distance,pga.accuracy))
print(theta1s.shape)  #(100,)
plt.plot(theta1s,costs)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下里我们采用&lt;strong&gt;梯度下降法&lt;/strong&gt;原理解析这类问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC12%E9%A1%B5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/why957/1247798/o_2-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95_%E7%AC%AC13%E9%A1%B5.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#梯度下降解决问题
import numpy as np
from mpl_toolkits.mplot3d.axes3d import Axes3D  #导入3D包
import matplotlib.pyplot as plt
%matplotlib inline

theta0s = np.linspace(-2,2,100)
theta1s = np.linspace(-2,2,100)
COST = np.empty(shape=(100,100))  #空白填充(100,100)的数组
print(COST.shape)  #(100, 100)

TOS,TIS = np.meshgrid(theta0s,theta1s)
print(TOS.shape,TIS.shape)  #  (100, 100) (100, 100)

#将标准归一化的数据替换新的数组并绘制
for i in range(100):
    for j in range(100):
        COST[i,j] = cost(TOS[0,i],TIS[j,0],pga.distance,pga.accuracy)
print(COST.shape)  #(100, 100)

fig2 = plt.figure()
ax = fig2.gca(projection='3d')
ax.plot_surface(X=TOS,Y=TIS,Z=COST)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#梯度下降实现原理:  对theta1与theta0进行求偏导值
#对theta1值进行求偏导值
def partial_cost_theta1(theta0,theta1,x,y):
    h = theta0 + theta1*x  #预测函数
    diff = (h-y) *x   # 对theta1进行求偏导  (h(x) - y) * x
    partial = diff.sum()/(x.shape[0])  #进行求和并除以样本数量
    return partial
partial1 = partial_cost_theta1(0,5,pga.distance,pga.accuracy)
print(partial1)

#对theta0进行求偏导值
def partial_cost_theta0(theta0,theta1,x,y):
    h = theta0 + theta1*x   #预测函数
    diff = (h-y)      #对theta0求偏导  (h(x) - y)
    partial = diff.sum() / (x.shape[0])  #进行求和并除以样本数量
    return partial

partial0 = partial_cost_theta0(1,1,pga.distance,pga.accuracy)
print(partial0)

#输出
5.5791338540719
1.0000000000000104&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;strong&gt;梯度下降迭代更新值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#梯度下降迭代更新值  alpha=0.1代表默认步长
def gradient_descent(x,y,alpha=0.1,theta0=0,theta1=0):
    max_epochs = 1000   #迭代次数1000  
    counter = 0
    c = cost(theta1,theta0,pga.distance,pga.accuracy)
    costs = [c]
    convergence_thres = 0.00001  #定义下降趋势设置临界值精度
    cprev = c+ 10
    theta0s = [theta0]
    theta1s = [theta1]
    #判断目标函数值大于临界精度或者小于迭代次数,继续迭代
    while (np.abs(cprev-c) &amp;gt; convergence_thres) and (counter &amp;lt; max_epochs):
        cprev = c
        update0 = alpha*partial_cost_theta0(theta0,theta1,x,y)  #alpha乘以 theta0求的偏导值
        update1 = alpha*partial_cost_theta1(theta0,theta1,x,y)  #alpha乘以 theta1求的偏导值
        #更新theta值,梯度下降
        theta0 -= update0
        theta1 -= update1
        #添加到列表中
        theta0s.append(theta0)
        theta1s.append(theta1)
        #计算新的cost值
        c = cost(theta0,theta1,pga.distance,pga.accuracy)
        costs.append(c)
        counter += 1
    return {'theta0':theta0,'theta1':theta1,'costs':costs}

#实现当迭代次数越多,计算的目标函数cost值越低并趋于平缓,从而实现找到目标函数趋近的最低值
print('theta1=',gradient_descent(pga.distance,pga.accuracy)['theta1'])
descend = gradient_descent(pga.distance,pga.accuracy,alpha=0.01)
plt.scatter(range(len(descend['costs'])),descend['costs'])
plt.xlabel('costs_len')
plt.ylabel('costs')
plt.show()

#输出
theta1= -0.5984131176478865&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 06:49:00 +0000</pubDate>
<dc:creator>诚实善良小郎君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/why957/p/9354600.html</dc:identifier>
</item>
<item>
<title>配置Mysql Group Replication遇到的问题笔记 - EmrysChe</title>
<link>http://www.cnblogs.com/emrysche/p/9354472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/emrysche/p/9354472.html</guid>
<description>&lt;h2 id=&quot;一&quot;&gt;一&lt;/h2&gt;
&lt;p&gt;在配置第一台服务器&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;START GROUP_REPLICATION;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后出现以下问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERROR 3092 (HY000): The server is not configured properly to be an active member of the group. Please see more details on error log.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现，本机无法ping通，修改/etc/sysconfig/network-scripts/ifcfg-eth0（eth0为你上网用的网卡），设置好本机ip、子网掩码、网关，之后重启network就行&lt;/p&gt;
&lt;h2 id=&quot;二第二台服务器一直处于recovering状态&quot;&gt;二、第二台服务器一直处于RECOVERING状态&lt;/h2&gt;
&lt;p&gt;这个问题比较复杂，很有可能是因为出现一些错误情况导致服务器之间连接不成功，一般MySQL会尝试连接10次，之后后起的服务器会处于ERROR状态。&lt;/p&gt;
&lt;p&gt;一旦一个实例进入ERROR状态，该实例super_read_only选项被设置为ON。要离开ERROR 状态，必须手动配置实例super_read_only=OFF。&lt;/p&gt;
&lt;h3 id=&quot;情况1&quot;&gt;情况1：&lt;/h3&gt;
&lt;p&gt;防火墙和selinux没关，这是小问题，关掉就行。&lt;/p&gt;
&lt;h3 id=&quot;情况2&quot;&gt;情况2：&lt;/h3&gt;
&lt;p&gt;两台服务器主机名相同，mysql无法通过DNS找到对应服务器。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;在my.cnf文件中设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;report-host=192.168.50.22 #后面跟的ip是本机的ip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者取消掉mysql通过DNS查找服务器的策略，当然，也可以修改hosts文件，方法网上可以找到的。当然，最好是设置report-host。&lt;br/&gt;还有server_id每台服务器一定要不同。&lt;/p&gt;
&lt;h3 id=&quot;情况3&quot;&gt;情况3：&lt;/h3&gt;
&lt;p&gt;查看mysql日志，发现两台服务器直接一直在尝试连接，一直连接不上。尝试10次之后，变成ERROR状态。&lt;/p&gt;
&lt;p&gt;VM Ware的锅，概率不高。&lt;/p&gt;
&lt;p&gt;然后我运气不好，碰到了，折磨了我一个星期，网上根本找不到解决方法，最后换成VirtualBox就好了，实际生产环境应该不会有这么坑爹的问题，大概是VM Ware虚拟机网络通信机制的问题，猜测可能还有防火墙，同事用VM Ware做成功了，大概是版本问题或者其他的，具体原因查不出来。&lt;/p&gt;
&lt;p&gt;我后来在用一个纯净的基本没有自配的服务的centos镜像在VM Ware下装机，连网卡都启动不来后才猜出来的，然后毅然下了个VirtualBox，重新配，就没问题了。&lt;/p&gt;
&lt;p&gt;初步觉得可能是管理员权限的原因，VM Ware和Win 10都该背锅。&lt;/p&gt;
&lt;h3 id=&quot;情况4&quot;&gt;情况4：&lt;/h3&gt;
&lt;p&gt;加载的sql查询文件语法不兼容组复制，例如建表没有主键，创建的带返回值的函数没有声明DETERMINISTIC之类的，查MySQL日志大概能查出来。&lt;/p&gt;
&lt;h2 id=&quot;三&quot;&gt;三&lt;/h2&gt;
&lt;p&gt;如果用虚拟机模拟组复制，那么，最好不要直接克隆一台已经配置好的虚拟机，至少，不能克隆已经初始化了mysql的虚拟机，不然会造成两台服务器的MEMBER_ID相同，导致两台服务器无法找到对方。&lt;/p&gt;
&lt;h2 id=&quot;四自增量&quot;&gt;四、自增量&lt;/h2&gt;
&lt;p&gt;如果在数据库内使用到了自增的字段，最好在/etc/my.cnf中添加auto_increment_increment、auto_increment_offset两个参数，防止发生事务冲突（MGR其实本身就有防止自增量事务冲突的能力，运用了GROUP_REPLICATION_AUTO_INCREMENT_INCREMENT这个参数，但如果不去手动设置，自增量的间隔会非常奇怪）。&lt;/p&gt;
&lt;p&gt;auto_increment_increment为自增量的间隔，auto_increment_offset为自增量的初始位置。&lt;/p&gt;
&lt;p&gt;从官网查到的文档上，建议最好为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;auto_increment_increment=n（组内成员数）
auto_increment_offset=server_id(这里的server_id最好为1,2,3这样的自增量,且每台都不同)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样肯定能解决事务冲突的问题，但是，这样，为了让自增量每次都是+1，必须得DB1插表，然后DB2，接着DB3...如果一直是DB1(或者任意一台组内的服务器)插表，会导致自增量每次是+n。如果有强迫症，会很难受...&lt;/p&gt;
&lt;p&gt;网上也有这么做的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;auto_increment_increment=1
auto_increment_offset=2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们做MGR的时候也试过，还试过auto_increment_offset等于其他大于1的值，基本上自增量每次都是+1，也没有出现事务冲突，凑合着是可以用的，但逻辑上有点奇怪，不知道会不会有隐藏的问题。&lt;/p&gt;
&lt;p&gt;至于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;auto_increment_increment=1
auto_increment_offset=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的做法，肯定是哪位老哥用官网上的做法写的DB1示例后，被人各种无脑Ctrl+C、Ctrl+V之后的做法。&lt;/p&gt;
&lt;p&gt;这样会导致每次自增的间隔为7，不论在哪台服务器上。&lt;/p&gt;
&lt;p&gt;至于为什么会这样，貌似是GROUP_REPLICATION_AUTO_INCREMENT_INCREMENT这个参数默认是7，而MGR默认的规避自增量导致的事务冲突的方式中auto_increment_increment=GROUP_REPLICATION_AUTO_INCREMENT_INCREMENT。&lt;/p&gt;
&lt;p&gt;这样做，还不如用官方提出的设计。&lt;/p&gt;
&lt;p&gt;现在，我们在公司里，用的是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# auto_increment_increment=1
auto_increment_offset=9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里auto_increment_increment参数被我们注释掉了，在测试的时候基本也没出问题，不知道到时候到生产环境会怎样。&lt;/p&gt;
&lt;p&gt;自增字段的大小依赖于group replication组中成员的多少。&lt;/p&gt;
&lt;p&gt;auto_increment_offset值，最好是大于等于组内成员数，如果段的大小等于组内成员的数量，则所有的自增值都会被使用。&lt;/p&gt;
&lt;p&gt;auto_increment_offset值小于组内成员数，我们有试过，不过不知道是我们测试的虚拟机数量太少，还是情况考虑的不周，暂时没什么问题，不过以防万一，还是不要这么操作。&lt;/p&gt;
&lt;p&gt;关于组复制设置自增量间隔，推荐可以看：&lt;/p&gt;
&lt;blockquote readability=&quot;3.1348314606742&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/worklog/task/?id=8445&quot;&gt;WL#8445: Group Replication: Auto-increment configuration/handling&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.51cto.com/fengfeng688/1941341&quot;&gt;笨小孩的dba之路-MySQL group replication介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有自行Google，至于百度就算了，没什么用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;五设置read_only&quot;&gt;五、设置read_only&lt;/h2&gt;
&lt;p&gt;因为以默认的方式（不设置loose-group_replication_single_primary_mode=FALSE）启动组复制时后起服务器没用写的权限，所以要在MySQL shell上输入&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;set global read_only=0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，最好在服务器ONLINE之后再执行，不然，同步会出现问题。&lt;/p&gt;
&lt;p&gt;查看日志/var/log/mysqld.log，大量出现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ERROR] Plugin group_replication reported: 'Transaction cannot be executed while Group Replication is recovering. Try again when the server is ONLINE.'
[ERROR] Run function 'before_commit' in plugin 'group_replication' failed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这样依然有概率能ONLINE，不过比较浪费时间，而且也有很大概率失败。&lt;/p&gt;
&lt;p&gt;所有生产环境最好不要在服务器RECOVERING时设置read_only=0。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 06:27:00 +0000</pubDate>
<dc:creator>EmrysChe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/emrysche/p/9354472.html</dc:identifier>
</item>
<item>
<title>玩玩小程序：使用 WebApi 交互打造原生的微信小程序 - 图灵小书架 - 反骨仔</title>
<link>http://www.cnblogs.com/liqingwen/p/9339504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqingwen/p/9339504.html</guid>
<description>
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;源码地址&lt;/li&gt;
&lt;li&gt;扫一扫体验&lt;/li&gt;
&lt;li&gt;代码分析&lt;/li&gt;
&lt;li&gt;其它相关信息&lt;span&gt;（互联网搜集）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;　　定时抓取图灵社区官网的首页、最热、推荐和最新等栏目的相关图书信息进行展示，并且可以下载相关的 PDF 进行查阅...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723111243125-1922774595.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723111248530-997519674.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723111254220-220470113.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723111300119-340534228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要功能&lt;/p&gt;

&lt;h2&gt;源码地址&lt;/h2&gt;
&lt;p&gt;　　源码地址1：&lt;a href=&quot;https://github.com/liqingwen2015/ituring_small_bookshelf&quot; target=&quot;_blank&quot;&gt;https://github.com/liqingwen2015/ituring_small_bookshelf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　源码地址2：&lt;a href=&quot;https://gitee.com/liqingwen/ituring_small_bookshelf&quot; target=&quot;_blank&quot;&gt;https://gitee.com/liqingwen/ituring_small_bookshelf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　使用说明：&lt;/p&gt;
&lt;ol class=&quot;task-list&quot;&gt;&lt;li&gt;打开微信开发者工具；&lt;/li&gt;
&lt;li&gt;路径引入 src 文件夹；&lt;/li&gt;
&lt;li&gt;输入 APPID 和文件名即可；&lt;/li&gt;
&lt;li&gt;本地不需要配置服务器地址，自动连接 API 接口资源；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　不过使用  git，我有一个这样的担忧：用了5年GIT，原来分支合并是这样协作的。假设团队3个人。 领导开创一个分支。 我和另外一个同事在领导的分支下创建一个新分支。 然后 我们各自开发。 有新功能就 去拉取 并将领导的分支合并到自己的分支。 这样，我改的东西，和同事改的不会冲突。最后，GIT 导出我们的差异，通过 QQ 传给领导。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;-- 引用 https://my.oschina.net/lcsoft/tweet/17666900&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;扫一扫体验&lt;/h2&gt;
&lt;p&gt;　　可以通过小程序（已上线）二维码扫一扫，也可以在小程序中搜一下【图灵小书架】进行体验：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723112542924-1729487678.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723112554925-1105304115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　它真的非常小（轻量、快、占用内存小），接近 10 个页面所占用的空间大小（代码+图片等）才100KB+。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723113241546-1171348057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;代码分析&lt;/h2&gt;
&lt;h3&gt;结构简析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723113845230-37767913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　config 文件夹（可选）：存放配置信息；&lt;/p&gt;
&lt;p&gt;　　images 文件夹（可选）：存放图片；&lt;/p&gt;
&lt;p&gt;　　pages 文件夹：存放每个页面信息；&lt;/p&gt;
&lt;p&gt;　　utils 文件夹（可选）：工具类存放；&lt;/p&gt;
&lt;p&gt;　　app.js：项目的入口文件，如包含程序生命周期定义（页面初始化、页面渲染完成、页面显示、页面隐藏和页面关闭等）；&lt;/p&gt;
&lt;p&gt;　　app.json：全局配置文件，如页面路径， tabBar（导航、图标和选中样式等）；&lt;/p&gt;
&lt;p&gt;　　app.wxss：全局样式配置文件，如每个页面可以重用的样式；&lt;/p&gt;
&lt;p&gt;　　project.config.json：程序的配置文件，如项目名称、微信开发工具配置（是否校验合法域名、是否压缩和样式自动补全等）；&lt;/p&gt;

&lt;p&gt;　　为了方便统一管理 api 请求的地址，我统一在 config/config.js 中配置 api 的请求地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const key = require('const.js'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务器域名&lt;/span&gt;
const baseUrl =&lt;span&gt; key.urlPrefix.server;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;const baseUrl = key.urlPrefix.local;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取首页的图书&lt;/span&gt;
const getBooksOfIndex = baseUrl + 'books/v1/index'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图书列表&lt;/span&gt;
const getBooksByShowType = baseUrl + 'books/v1/list'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图书&lt;/span&gt;
const getBook = baseUrl + 'books/v1/detail'&lt;span&gt;;

const saveUserInfo &lt;/span&gt;= baseUrl + 'account/v1/save'&lt;span&gt;;

const submitComment &lt;/span&gt;= baseUrl + 'comment/v1/submit'&lt;span&gt;;

const getComments &lt;/span&gt;= baseUrl + 'comment/v1/list'&lt;span&gt;;

module.exports &lt;/span&gt;=&lt;span&gt; {
    getBooksOfIndex: getBooksOfIndex,
    getBooksByShowType: getBooksByShowType,
    getBook: getBook,
    saveUserInfo: saveUserInfo,
    submitComment: submitComment,
    getComments: getComments
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　同时，也把一些静态 const 变量统一存放在 config/const.js 中，方便管理和维护：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Key 名&lt;/span&gt;
module.exports =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户标识&lt;/span&gt;
    wxUserId: 'WxUserId'&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 登录标识&lt;/span&gt;
    loginFlag: 'LoginFlag'&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图标&lt;/span&gt;
&lt;span&gt;    icon: {
        success: &lt;/span&gt;'success'&lt;span&gt;,
        loading: &lt;/span&gt;'loading'&lt;span&gt;,
        none: &lt;/span&gt;'none'&lt;span&gt;
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; url 前缀&lt;/span&gt;
&lt;span&gt;    urlPrefix: {
        server: &lt;/span&gt;'https://api.nidie.com.cn/api/', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
        local: 'http://localhost:57196/api/', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地&lt;/span&gt;
        test: 'http://localhost:57196/api/', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
        file: 'https://download.nidie.com.cn/', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;
        image: 'http://www.ituring.com.cn/' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片&lt;/span&gt;
&lt;span&gt;    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Pages 文件夹简析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180723125030415-2024064574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里通过 detail （图书详情页）文件夹进行解析，从图中可以看到的文件夹中包含：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;.json 后缀的 JSON 配置文件&lt;/li&gt;
&lt;li&gt;.wxml 后缀的 WXML 模板文件&lt;/li&gt;
&lt;li&gt;.wxss 后缀的 WXSS 样式文件&lt;/li&gt;
&lt;li&gt;.js 后缀的 JS 脚本逻辑文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　detail.wxml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{showLoading}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;donut-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;donut&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-container bg-white&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-image&quot;&lt;/span&gt;&lt;span&gt; mode&lt;/span&gt;&lt;span&gt;=&quot;scaleToFill&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{book.imageUrl}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-desc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-main-text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{book.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{book.author}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;book-text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;￥ {{book.price}} 元&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;loading-container&quot;&lt;/span&gt;&lt;span&gt; wx:if&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{downloading}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;progress &lt;/span&gt;&lt;span&gt;percent&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{downloadPercent}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; stroke-width&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; activeColor&lt;/span&gt;&lt;span&gt;=&quot;#1aad19&quot;&lt;/span&gt;&lt;span&gt; backgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#cdcdcd&quot;&lt;/span&gt;&lt;span&gt; show-info &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;comment-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;comment-title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;========== 简介 ==========&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;comment-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;comment-placeholder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{book.intro}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; bottom button &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fixed-bottom block-full-width flex-container bg-white&quot;&lt;/span&gt;&lt;span&gt; wx:if&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{isAllowDownload}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;full-button&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;primary&quot;&lt;/span&gt;&lt;span&gt; catchtap&lt;/span&gt;&lt;span&gt;=&quot;download&quot;&lt;/span&gt;&lt;span&gt; data-id&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{bookInfo.id}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; data-name&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{{bookInfo.name}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                随书下载&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;font-size:26rpx; color:gray&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;（已存在，则立即打开）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该文件非常像我们所学过的 html 结构，只不过标签替换为了小程序自己包装的语义标签而已。&lt;/p&gt;

&lt;p&gt;　　detail.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取服务器接口地址&lt;/span&gt;
const api = require('../../config/config.js'&lt;span&gt;);
const key &lt;/span&gt;= require('../../config/const.js'&lt;span&gt;);
const http &lt;/span&gt;= require('../../utils/http.js'&lt;span&gt;);
const file &lt;/span&gt;= require('../../utils/file.js'&lt;span&gt;);
const cache &lt;/span&gt;= require('../../utils/cache.js'&lt;span&gt;);
const tip &lt;/span&gt;= require('../../utils/tip.js'&lt;span&gt;);

Page({
    data: {
        bookIsBuy: &lt;/span&gt;0&lt;span&gt;,
        downloading: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        book: {},
        id: &lt;/span&gt;''&lt;span&gt;,
        showLoading: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        isAllowDownload: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否允许下载&lt;/span&gt;
        isDownloading: &lt;span&gt;false&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下载中标识&lt;/span&gt;
&lt;span&gt;    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取书籍&lt;/span&gt;
    getBook: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (id) {
        let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        let key &lt;/span&gt;=&lt;span&gt; `Book_${id}`;
        let val &lt;/span&gt;=&lt;span&gt; cache.getSync(key);
        let obj &lt;/span&gt;=&lt;span&gt; {
            showLoading: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (val) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val.pdfUrl &amp;amp;&amp;amp; val.pdfUrl.trim() !== ''&lt;span&gt;) {
                obj.isAllowDownload &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            obj.book &lt;/span&gt;=&lt;span&gt; val;
            that.setData(obj);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        http.get(api.getBook &lt;/span&gt;+ `/${id}`, function (data) {
            &lt;span&gt;if&lt;/span&gt; (data.pdfUrl &amp;amp;&amp;amp; data.pdfUrl.trim() !== ''&lt;span&gt;) {
                obj.isAllowDownload &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            obj.book &lt;/span&gt;=&lt;span&gt; data;
            that.setData(obj);

            cache.set(key, data);
        });
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下载&lt;/span&gt;
    download: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (that.data.isDownloading) {
            tip.showToast(&lt;/span&gt;'下载中，请稍安勿躁！！！'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
  
        let cachekey &lt;/span&gt;=&lt;span&gt; `Book_PDF_${that.data.id}`;
        let path &lt;/span&gt;=&lt;span&gt; cache.getSync(cachekey);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;path) {
            that.setData({
                isDownloading: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            });

            let pdfUrl &lt;/span&gt;= that.data.book.pdfUrl.split(','&lt;span&gt;);
            
            http.downloadFile(key.urlPrefix.file &lt;/span&gt;+ pdfUrl[0&lt;span&gt;],
                &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (filePath) {
                    file.openDocument(filePath);
                    cache.set(cachekey, filePath);
                },
                &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    that.setData({
                        isDownloading: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    });
                });

            tip.showToast(&lt;/span&gt;'已经开始下载，下载完毕后将自动打开，请稍后！！！'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        file.openDocument(path);
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 生命周期函数--监听页面加载
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    onLoad: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (options) {
        let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        let id &lt;/span&gt;=&lt;span&gt; options.id;

        that.getBook(id);
        that.setData({
            id: id
        });
    },
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　里面的语法类似 VUE，WXML 中的动态数据均来自对应 Page 的 data，因为我把很多自己封装的方法单独放到 utils 文件夹和 config 文件夹中，在希望调用对应的方法时需要使用 require 函数将其引入，小程序有许多丰富的 API，代码中就使用了如下载、请求 json 数组、提示弹出框和 localStorage 缓存等 API（含同步、异步）。&lt;/p&gt;

&lt;p&gt;　　detail.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;详情页&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里只是对应导航头文字进行了修改而已。&lt;/p&gt;

&lt;p&gt;　　detail.wxss 样式文件，并没有太多可以说的，按照自己的 css 样式进行编写就好了。&lt;/p&gt;

&lt;h2&gt;其它相关信息&lt;span&gt;（互联网搜集）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　PC 的 IDE、苹果 IOS 和安卓 Android，它们的运行环境是存在差异，意味着不是所有提供的 API 都可以完全兼容。&lt;/p&gt;
&lt;p&gt;　　见 &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/details.html#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%B7%AE%E5%BC%82&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/details.html#运行环境差异&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180720070526153-1281914122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;小程序 - MINA 框架&lt;/h3&gt;
&lt;p&gt;　　微信团队为小程序提供的框架命名为MINA应用框架。MINA框架通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供一整套JavaScript API，让开发者能够非常方便地使用微信客户端提供的各种基础功能与能力，快速构建一个应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180720070728265-488639298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;小程序 - 启动运行机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180720071122817-1564943288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;小程序 - 生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201807/711762-20180720071448346-678700117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Jul 2018 05:44:00 +0000</pubDate>
<dc:creator>反骨仔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqingwen/p/9339504.html</dc:identifier>
</item>
<item>
<title>面试 12：玩转 Java 快速排序 - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/9354159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/9354159.html</guid>
<description>&lt;p&gt;终于轮到我们排序算法中的王牌登场了。&lt;/p&gt;
&lt;p&gt;快速排序由于排序效率在同为 O(nlogn) 的几种排序方法中效率最高，因此经常被采用。再加上快速排序思想——分治法也确实非常实用，所以 在各大厂的面试习题中，快排总是最耀眼的那个。要是你会的排序算法中没有快速排序，我想你还是偷偷去学好它，再去向大厂砸简历。&lt;/p&gt;
&lt;p&gt;事实上，在我们的诸多高级语言中，都能找到它的某种实现版本，那我们 Java 自然不能在此缺席。&lt;/p&gt;
&lt;p&gt;总的来说，默写排序代码是南尘非常不推荐的，撇开快排的代码不是那么容易默写，即使你能默写快排代码，也总会因为面试官稍微的变种面试导致你惶恐不安。&lt;/p&gt;
&lt;p&gt;所以我们的面试系列自然不能少了这位王牌选手。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;280&quot; data-height=&quot;214&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-f8fc6fea8acde483.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/280&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-f8fc6fea8acde483.gif&quot; data-original-width=&quot;280&quot; data-original-height=&quot;214&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;93016&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图片来自于维基百科&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;基本思想&lt;/h2&gt;
&lt;p&gt;快速排序使用分治法策略来把一个序列分为两个子序列，基本步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先从序列中取出一个数作为基准数；&lt;/li&gt;
&lt;li&gt;分区过程：将把这个数大的数全部放到它的右边，小于或者等于它的数全放到它的左边；&lt;/li&gt;
&lt;li&gt;递归地对左右子序列进行不走2，直到各区间只有一个数。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;200&quot; data-height=&quot;244&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-4172ac826b42ca1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-4172ac826b42ca1f.png&quot; data-original-width=&quot;200&quot; data-original-height=&quot;244&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;12528&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图片来自于网络&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虽然快排算法的策略是分治法，但分治法这三个字显然无法很好的概括快排的全部不走，因此借用 CSDN 神人 MoreWindows 的定义说明为：挖坑填数 + 分治法。&lt;/p&gt;
&lt;p&gt;似乎还是不太好理解，我们这里就直接借用 MoreWindows 大佬的例子说明。&lt;/p&gt;
&lt;p&gt;以一个数组作为示例，取区间第一个数为基准数。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;72&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;83&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;初始时，i = 0; j = 9; temp = a[i] = 72&lt;/p&gt;
&lt;p&gt;由于已经将 a[0] 中的数保存到 temp 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。&lt;/p&gt;
&lt;p&gt;从 j 开始向前找一个比 temp 小或等于 temp 的数。当 j = 8，符合条件，将 a[8] 挖出再填到上一个坑 a[0] 中。&lt;/p&gt;
&lt;p&gt;a[0] = a[8]; i++; 这样一个坑 a[0] 就被搞定了，但又形成了一个新坑 a[8]，这怎么办了？简单，再找数字来填 a[8] 这个坑。这次从i开始向后找一个大于 temp 的数，当 i = 3，符合条件，将 a[3] 挖出再填到上一个坑中 a[8] = a[3]; j--;&lt;/p&gt;
&lt;p&gt;数组变为：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;83&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;i = 3; j = 7; temp = 72&lt;/p&gt;
&lt;p&gt;再重复上面的步骤，先从后向前找，再从前向后找。&lt;/p&gt;
&lt;p&gt;从 j 开始向前找，当 j = 5，符合条件，将 a[5] 挖出填到上一个坑中，a[3] = a[5]; i++;&lt;/p&gt;
&lt;p&gt;从i开始向后找，当 i = 5 时，由于 i==j 退出。&lt;/p&gt;
&lt;p&gt;此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将 temp 填入 a[5]。&lt;/p&gt;
&lt;p&gt;数组变为：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;td&gt;83&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看出 a[5] 前面的数字都小于它，a[5] 后面的数字都大于它。因此再对 a[0…4] 和 a[6…9] 这二个子区间重复上述步骤就可以了。&lt;/p&gt;
&lt;p&gt;对挖坑填数进行总结&lt;/p&gt;
&lt;p&gt;1．i = L; j = R; 将基准数挖出形成第一个坑 a[i]。&lt;/p&gt;
&lt;p&gt;2．j-- 由后向前找比它小的数，找到后挖出此数填前一个坑 a[i] 中。&lt;/p&gt;
&lt;p&gt;3．i++ 由前向后找比它大的数，找到后也挖出此数填到前一个坑 a[j] 中。&lt;/p&gt;
&lt;p&gt;4．再重复执行 2，3 二步，直到 i==j，将基准数填入 a[i] 中。&lt;/p&gt;
&lt;p&gt;有了这样的分析，我们明显能写出下面的代码：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Test09 {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;printArr&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] arr) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int anArr : arr) {
            System.out.print(anArr + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;);
        }
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;partition&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] arr, &lt;span class=&quot;hljs-keyword&quot;&gt;int left, &lt;span class=&quot;hljs-keyword&quot;&gt;int right) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int temp = arr[left];
        &lt;span class=&quot;hljs-keyword&quot;&gt;while (right &amp;gt; left) {
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们不妨尝试来对这个算法进行一下时间复杂度的分析：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;最好情况&lt;/p&gt;
&lt;p&gt;在最好的情况下，每次我们进行一次分区，我们会把一个序列刚好分为几近相等的两个子序列，这个情况也我们每次递归调用的是时候也就刚好处理一半大小的子序列。这看起来其实就是一个完全二叉树，树的深度为 O(logn)，所以我们需要做 O(logn) 次嵌套调用。但是在同一层次结构的两个程序调用中，不会处理为原来数列的相同部分。因此，程序调用的每一层次结构总共全部需要 O(n) 的时间。所以这个算法在最好情况下的时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;p&gt;事实上，我们并不需要如此精确的分区：即使我们每个基准值把元素分开为 99% 在一边和 1% 在另一边。调用的深度仍然限制在 100logn，所以全部运行时间依然是 O(nlogn)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;最坏情况&lt;/p&gt;
&lt;p&gt;事实上，我们总不能保证上面的理想情况。试想一下，假设每次分区后都出现子序列的长度一个为 1 一个为 n-1，那真是糟糕透顶。这一定会导致我们的表达式变成：&lt;/p&gt;
&lt;p&gt;T(n) = O(n) + T(1) + T(n-1) = O(n) + T(n-1)&lt;/p&gt;
&lt;p&gt;这和插入排序和选择排序的关系式真是如出一辙，所以我们的最坏情况是 O(n²)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;找到更好的基准数&lt;/h2&gt;
&lt;p&gt;上面对时间复杂度进行了简要分析，可见我们的时间复杂度和我们的基准数的选择密不可分。基准数选好了，把序列每次都能分为几近相等的两份，我们的快排就跟着吃香喝辣；但一旦选择的基准数很差，那我们的快排也就跟着穷困潦倒。&lt;/p&gt;
&lt;p&gt;所以大家就各显神通，出现了各种选择基准数的方式。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;固定基准数&lt;/p&gt;
&lt;p&gt;上面的那种算法，就是一种固定基准数的方式。如果输入的序列是随机的，处理时间还相对比较能接受。但如果数组已经有序，用上面的方式显然非常不好，因为每次划分都只能使待排序序列长度减一。这真是糟糕透了，快排沦为冒泡排序，时间复杂度为 O(n²)。因此，使用第一个元素作为基准数是非常糟糕的，我们应该立即放弃这种想法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;随机基准数&lt;/p&gt;
&lt;p&gt;这是一种相对安全的策略。由于基准数的位置是随机的，那么产生的分割也不会总是出现劣质的分割。但在数组所有数字完全相等的时候，仍然会是最坏情况。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到 O(nlogn) 的期望时间复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;三数取中&lt;/p&gt;
&lt;p&gt;虽然随机基准数方法选取方式减少了出现不好分割的几率，但是最坏情况下还是 O(n²)。为了缓解这个尴尬的气氛，就引入了「三数取中」这样的基准数选取方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;三数取中法实现&lt;/h2&gt;
&lt;p&gt;我们不妨来分析一下「三数取中」这个方式。我们最佳的划分是将待排序的序列氛围等长的子序列，最佳的状态我们可以使用序列中间的值，也就是第 n/2 个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约 5% 的比较次数。&lt;/p&gt;
&lt;p&gt;我们来看看代码是怎么实现的。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Test09 {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] arr, &lt;span class=&quot;hljs-keyword&quot;&gt;int i, &lt;span class=&quot;hljs-keyword&quot;&gt;int j) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;printArr&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] arr) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int anArr : arr) {
            System.out.print(anArr + &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;);
        }
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;partition&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] arr, &lt;span class=&quot;hljs-keyword&quot;&gt;int left, &lt;span class=&quot;hljs-keyword&quot;&gt;int right) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于篇幅关系，今天我们的讲解暂且就到这里。&lt;/p&gt;
&lt;p&gt;话说 Java 官方是怎么实现的呢？我们明天不妨直接到 JDK 里面一探究竟。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 05:25:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/9354159.html</dc:identifier>
</item>
<item>
<title>图解：HTTP 范围请求，助力断点续传、多线程下载的核心原理 - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/http_range.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/http_range.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21bd4b0ce?w=1350&amp;amp;h=900&amp;amp;f=jpeg&amp;amp;s=97055&quot;/&gt;&lt;/p&gt;
&lt;p&gt;题图：by Charles Loyer&lt;/p&gt;

&lt;p&gt;Hi，大家好，我是承香墨影！&lt;/p&gt;
&lt;p&gt;HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文，而报文又是由报文头（Header）和实体组成。大多数 HTTP 协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。&lt;/p&gt;
&lt;p&gt;本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 HTTP 协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。&lt;/p&gt;
&lt;p&gt;HTTP 协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;“这里写了建议零售价 2 元...”&lt;/p&gt;
&lt;p&gt;“哦，不接受建议！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文本是本系列的第五篇，前四篇传送门：&lt;/p&gt;
&lt;p&gt;今天再来介绍一下 HTTP 的范围请求。范围请求主要是针对较大的文件的请求或者上传，可以仅操作它的某一段。&lt;/p&gt;
&lt;p&gt;一个比较常见的场景，就是断点续传/下载，在网络情况不好的时候，可以在断开连接以后，仅继续获取部分内容。例如在网上下载软件，已经下载了 95% 了，此时网络断了，如果不支持范围请求，那就只有被迫重头开始下载。但是如果有范围请求的加持，就只需要下载最后 5% 的资源，避免重新下载。&lt;/p&gt;
&lt;p&gt;另一个场景就是多线程下载，对大型文件，开启多个线程，每个线程下载其中的某一段，最后下载完成之后，在本地拼接成一个完整的文件，可以更有效的利用资源。&lt;/p&gt;
&lt;p&gt;这算是两个比较常见的场景，接下来我们来看看范围请求的 HTTP 协议支持的技术细节。&lt;/p&gt;
&lt;h2 id=&quot;二http-的范围请求&quot;&gt;二、HTTP 的范围请求&lt;/h2&gt;
&lt;h3 id=&quot;是否支持范围请求&quot;&gt;2.1 是否支持范围请求&lt;/h3&gt;
&lt;p&gt;HTTP 本身是一种无状态的“松散”协议，而在经历了很多版本的迭代之后，只在 HTTP/1.1（RFC2616） 之上，才支持范围请求。所以如果客户端或者服务端两端的某一端低于 HTTP/1.1，我们就不应该使用范围请求的功能。&lt;/p&gt;
&lt;p&gt;而在 HTTP/1.1 中，很明确的声明了一个响应头部 &lt;code&gt;Access-Ranges&lt;/code&gt; 来标记是否支持范围请求，它只有一个可选参数 &lt;code&gt;bytes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21bc23dd6?w=285&amp;amp;h=131&amp;amp;f=jpeg&amp;amp;s=11760&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如这里给了一个 MP4 的响应头，可以看到它是有 &lt;code&gt;Accept-Ranges:bytes&lt;/code&gt; 来标记的，有此标记标识当前资源支持范围请求。&lt;/p&gt;
&lt;h3 id=&quot;使用范围请求&quot;&gt;2.2 使用范围请求&lt;/h3&gt;
&lt;p&gt;如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。&lt;/p&gt;
&lt;p&gt;所有的文件最终都是存储在磁盘或者内存中的字节，对于待操作的文件可以将其以字节为单位分割。这样只需要 HTTP 支持请求该文件从 n 到 n+x 这个范围内的资源，就可以实现范围请求了。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 中定义了一个 Ranges 的请求头，来指定请求实体的范围。它的范围取值是在 &lt;code&gt;0 - Content-Length&lt;/code&gt; 之间，使用 &lt;code&gt;-&lt;/code&gt; 分割。。&lt;/p&gt;
&lt;p&gt;例如已经下载了 1000 bytes 的资源内容，想接着继续下载之后的资源内容，只要在 HTTP 请求头部，增加 &lt;code&gt;Ranges:bytes=1000-&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;Range 还有几种不同的方式来限定范围，可以根据需要灵活定制：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; 500-1000：指定开始和结束的范围，一般用于多线程下载。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; 500- ：指定开始区间，一直传递到结束。这个就比较适用于断点续传、或者在线播放等等。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; -500：无开始区间，只意思是需要最后 500 bytes 的内容实体。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; 100-300,1000-3000：指定多个范围，这种方式使用的场景很少，了解一下就好了。&lt;/p&gt;
&lt;p&gt;HTTP 协议是一种双边协商的协议，既然请求头部已经确定是使用 Ranges 了，还有响应头部中，也需要使用 &lt;code&gt;Content-Ragne&lt;/code&gt; 这个响应头来标记响应的实体内容范围。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Range&lt;/code&gt; 的格式也很清晰，首先标记它的单位是 bytes 然后标记当前传递的内容实体范围和总长度。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;Content-Range: bytes 100-999/1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，会传递 100 ~ 999 范围的内容实体，而该资源文件的总大小是 1000 bytes。并且此时的 HTTP 响应状态码为 &lt;code&gt;206 Partial Content&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;6.9255319148936&quot;&gt;
&lt;p&gt;HTTP &lt;strong&gt;206 Partial Content&lt;/strong&gt; 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; 首部指定的。&lt;/p&gt;
&lt;p&gt;有关 206 状态码的解释可以参考：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以一个正常的流程应该如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21cc0c6b8?w=465&amp;amp;h=427&amp;amp;f=jpeg&amp;amp;s=28277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里的每个 HTTP 事务中的响应头里，都是会包含 &lt;code&gt;Content-Length&lt;/code&gt; 的，只是它包含的是当前范围请求响应的内容实体长度，而非此资源完整的长度。&lt;/p&gt;
&lt;p&gt;到这里基本上算是讲清楚 HTTP 范围请求的正确流程了，接下来看看一些特殊的情况。&lt;/p&gt;
&lt;h3 id=&quot;资源变化&quot;&gt;2.3 资源变化&lt;/h3&gt;
&lt;p&gt;当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会遇见它又重头开始下载的情况。&lt;/p&gt;
&lt;p&gt;这看似是 HTTP 的范围请求失效了，但是实际上并不一定如此，很可能是因为请求的资源，在请求的这个过程中，发生了改变。&lt;/p&gt;
&lt;p&gt;假如你下载的过程中，下载的源资源文件发生了变化，但是 URL 没有改变，此时文件长度可能已经变化了（这是非常容易发现的），极端情况下就算没有长度没有变化，你再继续下载，很可能最终下载完成之后，无法将下载的内容拼接成我们需要的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21b98de34?w=455&amp;amp;h=300&amp;amp;f=jpeg&amp;amp;s=21705&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们需要从服务器上下载某个资源，一定要预防此资源可能发生的变动。在之前讲 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485517&amp;amp;idx=1&amp;amp;sn=3edffef8db15d92c26072d85df1cc5a8&amp;amp;chksm=9785116ca0f2987a4ccf77339800873d092c1bded522d50fcf03aec98a9f51b23355e28aa3b7#rd&quot;&gt;HTTP 缓存&lt;/a&gt;的时候讲到，在 HTTP 协议中，可以通过 ETag 或者 Last-Modified 来标识当前资源是否变化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ETag：当前文件的一个验证令牌指纹，用于标识文件的唯一性。&lt;/li&gt;
&lt;li&gt;Last-Modified：标记当前文件最后被修改的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 HTTP 的范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在 &lt;code&gt;If-Range&lt;/code&gt; 这个请求报文头中即可。&lt;code&gt;If-Range&lt;/code&gt; 使用 &lt;code&gt;ETag&lt;/code&gt; 或者 &lt;code&gt;Last-Modified&lt;/code&gt; 两个参数任意一个，原样填入即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21ccaf693?w=495&amp;amp;h=428&amp;amp;f=jpeg&amp;amp;s=31648&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，如果两次操作的都是同一个资源文件，就会继续返回 206 状态码，开始后续的操作，反之则会返回 200 状态码，表示文件发生改变，要从头下载。&lt;/p&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;If-Range&lt;/code&gt; 需要和 &lt;code&gt;Range&lt;/code&gt; 配合起来使用，否则会被服务端忽略。&lt;/p&gt;
&lt;p&gt;再额外提一点，如果客户端请求报文头中，对 Range 填入的范围错误，会返回 416 状态码。&lt;/p&gt;
&lt;blockquote readability=&quot;7.5301507537688&quot;&gt;
&lt;p&gt;HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。&lt;/p&gt;
&lt;p&gt;有关 416 状态码，可以参考：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/416&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/416&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三范围请求的例子&quot;&gt;三、范围请求的例子&lt;/h2&gt;
&lt;h3 id=&quot;用-chrome-播放一个适配&quot;&gt;3.1 用 Chrome 播放一个适配&lt;/h3&gt;
&lt;p&gt;前面介绍的概念，很多技术点其实描述的都是某一个请求片段，接下来我们以一个实际的例子来说明范围请求的具体细节。&lt;/p&gt;
&lt;p&gt;在这个例子中，我找了一个视频的播放地址，直接在 Chrome 中进行播放。正常播放之后，再随手拖动视频进度，之后无操作让其自动播放一段时间，来看看 HTTP 的事务报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b21ba6917d?w=1306&amp;amp;h=320&amp;amp;f=jpeg&amp;amp;s=64259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单描述一下情况，自然播放的时候，会首先想资源的 URL 发送请求，返回 200 的响应码，可以判断出当前资源支持 &lt;code&gt;Accept-Ranges&lt;/code&gt;，接下来会去使用 &lt;code&gt;Range&lt;/code&gt; 发送范围请求，得到的响应码就是 206，并返回对应范围的实体内容。而在每次拖动进度的时候，都会去重新发送一个范围请求，依照拖动的进度来计算请求范围。此处不存在资源被修改的情况，所以不会出现重新请求下载的情况。&lt;/p&gt;
&lt;p&gt;就不一个一个对 HTTP 事务截图了，大概抽象了一下流程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b24948a9a2?w=526&amp;amp;h=633&amp;amp;f=jpeg&amp;amp;s=56704&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，一次资源下载其实包含了很多次的请求过程，我们需要站在全局的角度来看到它。&lt;/p&gt;
&lt;h2 id=&quot;四范围请求小结&quot;&gt;四、范围请求小结&lt;/h2&gt;
&lt;p&gt;到这里我们就已经把 HTTP 范围请求的整个流程都说明清楚了。&lt;/p&gt;
&lt;p&gt;再重新整理一下关键点：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; HTTP 范围请求，需要 HTTP/1.1 及之上支持，如果双端某一段低于此版本，则认为不支持。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; 通过响应头中的 &lt;code&gt;Accept-Ranges&lt;/code&gt; 来确定是否支持范围请求。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; 通过在请求头中添加 &lt;code&gt;Range&lt;/code&gt; 这个请求头，来指定请求的内容实体的字节范围。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; 在响应头中，通过 &lt;code&gt;Content-Range&lt;/code&gt; 来标识当前返回的内容实体范围，并使用 Content-Length 来标识当前返回的内容实体范围长度。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;5.&lt;/em&gt; 在请求过程中，可以通过 &lt;code&gt;If-Range&lt;/code&gt; 来区分资源文件是否变动，它的值来自 ETag 或者 Last-Modifled。如果资源文件有改动，会重新走下载流程。&lt;/p&gt;
&lt;p&gt;再配一张流程图，就更清晰了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b2496d71af?w=721&amp;amp;h=922&amp;amp;f=jpeg&amp;amp;s=98429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此 HTTP 范围请求的所有关键技术点，就已经讲解清楚。范围请求被用在诸如：断点续传、多线程下载等场景下，大部分 CDN 上的资源都是支持范围请求的，具体你能在什么场景下应用，就看你的想象力了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有什么更多的想法，欢迎留言讨论。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485544&amp;amp;idx=1&amp;amp;sn=8f9818a46f8c659398e5d8ab422ded5d&amp;amp;chksm=97851149a0f2985faa0bae6fd6c2140972988e6c6beb8f1d05b3f0d07c998fdd6dbe554d27f4#rd&quot;&gt;Android P 适配经验&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485538&amp;amp;idx=1&amp;amp;sn=5306e397df145bf71a9efbad54f8ca66&amp;amp;chksm=97851143a0f29855ea859d480347009ed32f07408277ab6a6071dc6483c282ee38766adf87f5#rd&quot;&gt;技术创业选择清单&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485535&amp;amp;idx=1&amp;amp;sn=2e9f9113de8b84429e19ee12b69f3336&amp;amp;chksm=9785117ea0f298683c0a56d016711633f7b8b86d7570f8ffbe9216ae5f175ea5fa53471e55c4#rd&quot;&gt;HTTP传输编码&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485529&amp;amp;idx=1&amp;amp;sn=d9c12c1f914bfa3fd8b30608b1cf6ac0&amp;amp;chksm=97851178a0f2986e59cd4792579493551c857646ee9a048f36baa954f665772e5f80efec1261#rd&quot;&gt;什么正在消耗你？&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485524&amp;amp;idx=1&amp;amp;sn=183b34cfd87f2a6fddc43187dc6fa72f&amp;amp;chksm=97851175a0f29863245fe35a402e801cf9fb8f6864acd3e546473aded4b18dd4538154403f79#rd&quot;&gt;HTTP 内容编码&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485517&amp;amp;idx=1&amp;amp;sn=3edffef8db15d92c26072d85df1cc5a8&amp;amp;chksm=9785116ca0f2987a4ccf77339800873d092c1bded522d50fcf03aec98a9f51b23355e28aa3b7#rd&quot;&gt;图解 HTTP 缓存&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485552&amp;amp;idx=1&amp;amp;sn=b0dac83247dd955b3ccaed42cdfd16e3&amp;amp;chksm=97851151a0f29847f1b354e7f058fdaf43d0b89eb976a72559e471a21a39909dad0b337679a5#rd&quot;&gt;聊聊 HTTP 的 Cookie&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485510&amp;amp;idx=1&amp;amp;sn=5be673f99e2d83e4b49ee46010734b10&amp;amp;chksm=97851167a0f298718284006a8ea3ad0cebdec2a46123332ae78908e142e408dd0ed04623cd68#rd&quot;&gt;辅助模式实战&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485501&amp;amp;idx=1&amp;amp;sn=795005d17c6e37e6de0adcc4c3500685&amp;amp;chksm=9785111ca0f2980a46bb3e1f40aebd096740065cd84a8f4169467d825616a2020d3a1ead0638#rd&quot;&gt;Accessibility 辅助模式&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485501&amp;amp;idx=1&amp;amp;sn=795005d17c6e37e6de0adcc4c3500685&amp;amp;chksm=9785111ca0f2980a46bb3e1f40aebd096740065cd84a8f4169467d825616a2020d3a1ead0638#rd&quot;&gt;小程序 Flex 布局&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485458&amp;amp;idx=1&amp;amp;sn=b05bac624d798d435db88725a896c10e&amp;amp;chksm=97851133a0f29825747b682e9e6c8dc7c39d3f85bfc66a009f38e33c7b4734fe1e7867d48d2b#rd&quot;&gt;好的 PR 让你更靠谱&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485455&amp;amp;idx=1&amp;amp;sn=dd47da7ca827bec354b30c53e03970f3&amp;amp;chksm=9785112ea0f298380f54d2a9784110e59ad5534622fa456f1ede5cf28f90fa128b343c4a0ac0#rd&quot;&gt;密码管理之道&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/23/164c57b246fca74e?w=1000&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=27637&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Jul 2018 05:11:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/http_range.html</dc:identifier>
</item>
</channel>
</rss>