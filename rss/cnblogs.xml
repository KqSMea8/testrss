<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>fiddler抓包简介 - 大鑫鑫</title>
<link>http://www.cnblogs.com/fuxinxin/p/9554665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fuxinxin/p/9554665.html</guid>
<description>&lt;p&gt;&lt;span&gt;Fiddler抓包简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理：fiddler是通过改写HTTP代理，客户端和服务器进行交互时，数据会从他那里通过，来监控和截取数据。我是这样理解的，如果不对，欢迎指正。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152349832-386361604.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要抓到数据包，首先要开启抓包功能，在File菜单下面有一个capture traffic选项，开启后左下角会显示图标（反之，关闭后则不显示该图标），也可以直接点击图标来开启/关闭抓包功能。Fiddler打开的时候，他就自动给浏览器设置了代理，你关闭的时候他就把代理给还原了。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152414635-1713810601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fiddler的菜单栏，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152436568-125407105.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;21&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;#&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;抓取HTTP Request的顺序编号&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Result&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;HTTP状态码，如500、505、404等&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Protocol&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求使用的协议，如HTTP/HTTPS/FTP等（请求协议）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Host&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求地址的主机名（服务器地址）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;URL&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求资源的位置（做接口测试的路径）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Body&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;该请求的大小&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Caching&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求的缓存过期时间或者缓存控制值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求响应的类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Process&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;发送此请求的进程：进程ID&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Comments&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;允许用户为此回话添加备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;Custom&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;允许用户设置自定义值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;图标&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154350108-1997819091.png&quot; alt=&quot;&quot; width=&quot;13&quot; height=&quot;26&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求已经发往服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154850569-1113552159.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;已从服务器下载响应结果&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154850570-880529259.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求从断点处暂停&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154850612-1606677389.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应从断点处暂停&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154902982-1905237025.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154909932-324853391.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求使用 HTTP 的 POST 方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154920272-784656983.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829154930153-2098321773.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 HTML 格式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155129655-1283993457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一张图片&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155157092-1446109895.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是脚本格式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155206291-631488026.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 CSS 格式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155214292-1692279919.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 XML 格式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155325152-718369916.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 JSON 格式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155334696-78139489.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一个音频文件&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155343170-777370836.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一个视频文件&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155351119-2074162087.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一个 SilverLight&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155358553-536151093.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一个 FLASH&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155407339-2024114181.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是一个字体&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155416321-1603162359.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;普通响应成功&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155424600-233366576.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 HTTP/300、301、302、303 或 307 重定向&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155530286-1743109704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应是 HTTP/304（无变更）：使用缓存文件&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155537305-617694079.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;响应需要客户端证书验证&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155545713-1445892848.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;服务端错误&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;178&quot;&gt;
&lt;p class=&quot;p&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829155554122-1550316440.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;630&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;会话被客户端、Fiddler 或者服务端终止&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;session不同图标和不同颜色的含义，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152603689-1734738191.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;默认颜色的含义如下:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152631145-1402947682.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、Statistics 请求的性能数据分析:&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;点击某个请求，就可以看到Statistics关于HTTP请求的性能以及数据分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152652144-381337197.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152747824-1037671889.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;2、Inspectors 查看数据内容:&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Inspectors是用于查看会话的内容，上半部分是请求的内容（入参），下半部分是响应的内容（出参）：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152820671-1056651935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、AutoResponder 允许拦截指定规则的请求：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;允许你拦截指定规则的求情，并返回本地资源或Fiddler资源，从而代替服务器响应。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这个玩意有很多匹配规则，如：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;a. 字符串匹配（默认）：只要包含指定字符串（不区分大小写），全部认为是匹配&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;b. 正则表达式匹配：以“regex:”开头，使用正则表达式来匹配，这个是区分大小写的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;4、Composer 自定义请求发送服务器：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Parsed模式下你只需要提供简单的URLS地址即可（如下图，也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152934739-982140332.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5、Filters 请求过滤规则&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Fiters 是过滤请求用的，左边的窗口不断的更新，当你想看你系统的请求的时候，你刷新一下浏览器，一大片不知道哪来请求，看着碍眼，它还一直刷新你的屏幕。这个时候通过过滤规则来过滤掉那些不想看到的请求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829152953424-1290862174.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;勾选左上角的Use Filters开启过滤器，这里有两个最常用的过滤条件：Zone和Host&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;a、Zone 指定只显示内网（Intranet）或互联网（Internet）的内容：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829153003599-320103046.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;b、Host 指定显示某个域名下的会话：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829153012192-2020032419.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;如果框框为黄色（如图），表示修改未生效，点击红圈里的文字即可&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6、Timeline 请求响应时间&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;在左侧会话窗口点击一个或多个（同时按下 Ctrl 键），Timeline 便会显示指定内容从服务端传输到客户端的时间：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379557/201808/1379557-20180829153022684-1941327038.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;参考自：https://www.cnblogs.com/yyhh/p/5140852.html&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;抓包教程传送门：https://www.cnblogs.com/fuxinxin/p/9146693.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 07:33:00 +0000</pubDate>
<dc:creator>大鑫鑫</dc:creator>
<og:description>Fiddler抓包简介 原理：fiddler是通过改写HTTP代理，客户端和服务器进行交互时，数据会从他那里通过，来监控和截取数据。我是这样理解的，如果不对，欢迎指正。如下图： 如果想要抓到数据包，首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fuxinxin/p/9554665.html</dc:identifier>
</item>
<item>
<title>利用ZYNQ SOC快速打开算法验证通路（4）——AXI DMA使用解析及环路测试 - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/9554097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/9554097.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****************************************************************************
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;* Copyright (C) 2010 - 2016 Xilinx, Inc.  All rights reserved.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;* Permission is hereby granted, free of charge, to any person obtaining a copy
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;* of this software and associated documentation files (the &quot;Software&quot;), to deal
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;* in the Software without restriction, including without limitation the rights
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;* copies of the Software, and to permit persons to whom the Software is
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;* furnished to do so, subject to the following conditions:
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;* The above copyright notice and this permission notice shall be included in
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;* all copies or substantial portions of the Software.
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;* Use of the Software is limited solely to applications:
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;* (a) running on a Xilinx device, or
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;* (b) that interact with a Xilinx device through a bus or interconnect.
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;* SOFTWARE.
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;* Except as contained in this notice, the name of the Xilinx shall not be used
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;* in advertising or otherwise to promote the sale, use or other dealings in
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;* this Software without prior written authorization from Xilinx.
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt; * @file xaxidma_example_simple_intr.c
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt; * This file demonstrates how to use the xaxidma driver on the Xilinx AXI
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt; * DMA core (AXIDMA) to transfer packets.in interrupt mode when the AXIDMA core
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt; * is configured in simple mode
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt; * This code assumes a loopback hardware widget is connected to the AXI DMA
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt; * core for data packet loopback.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt; * To see the debug print, you need a Uart16550 or uartlite in your system,
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt; * and please set &quot;-DDEBUG&quot; in your compiler options. You need to rebuild your
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt; * software executable.
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt; * Make sure that MEMORY_BASE is defined properly as per the HW system. The
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt; * h/w system built in Area mode has a maximum DDR memory limit of 64MB. In
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt; * throughput mode, it is 512MB.  These limits are need to ensured for
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt; * proper operation of this code.
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt; * &amp;lt;pre&amp;gt;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt; * MODIFICATION HISTORY:
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt; * Ver   Who  Date     Changes
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt; * ----- ---- -------- -------------------------------------------------------
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt; * 4.00a rkv  02/22/11 New example created for simple DMA, this example is for
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt; *                  simple DMA,Added interrupt support for Zynq.
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt; * 4.00a srt  08/04/11 Changed a typo in the RxIntrHandler, changed
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt; *               XAXIDMA_DMA_TO_DEVICE to XAXIDMA_DEVICE_TO_DMA
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt; * 5.00a srt  03/06/12 Added Flushing and Invalidation of Caches to fix CRs
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt; *               648103, 648701.
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt; *               Added V7 DDR Base Address to fix CR 649405.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt; * 6.00a srt  03/27/12 Changed API calls to support MCDMA driver.
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt; * 7.00a srt  06/18/12 API calls are reverted back for backward compatibility.
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt; * 7.01a srt  11/02/12 Buffer sizes (Tx and Rx) are modified to meet maximum
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt; *               DDR memory limit of the h/w system built with Area mode
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt; * 7.02a srt  03/01/13 Updated DDR base address for IPI designs (CR 703656).
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt; * 9.1   adk  01/07/16 Updated DDR base address for Ultrascale (CR 799532) and
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt; *               removed the defines for S6/V6.
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt; * 9.2   vak  15/04/16 Fixed compilation warnings in the example
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt; * &amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt; * ***************************************************************************
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**************************** Include Files ********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xaxidma.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xparameters.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xil_exception.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xdebug.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;#ifdef XPAR_UARTNS550_0_BASEADDR
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xuartns550_l.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; to use uartns550 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;  #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xintc.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;  #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xscugic.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************************* Constant Definitions ****************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt; * Device hardware build related constants.
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DMA_DEV_ID        XPAR_AXIDMA_0_DEVICE_ID
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#ifdef XPAR_AXI_7SDDR_0_S_AXI_BASEADDR
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DDR_BASE_ADDR        XPAR_AXI_7SDDR_0_S_AXI_BASEADDR
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; XPAR_MIG7SERIES_0_BASEADDR
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DDR_BASE_ADDR    XPAR_MIG7SERIES_0_BASEADDR
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; XPAR_MIG_0_BASEADDR
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DDR_BASE_ADDR    XPAR_MIG_0_BASEADDR
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; XPAR_PSU_DDR_0_S_AXI_BASEADDR
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DDR_BASE_ADDR    XPAR_PSU_DDR_0_S_AXI_BASEADDR
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;#ifndef DDR_BASE_ADDR
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;#warning&lt;/span&gt; CHECK FOR THE VALID DDR ADDRESS IN XPARAMETERS.H, \
&lt;span&gt;117&lt;/span&gt;         DEFAULT SET TO &lt;span&gt;0x01000000&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MEM_BASE_ADDR        0x01000000
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MEM_BASE_ADDR        (DDR_BASE_ADDR + 0x1000000)
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RX_INTR_ID        XPAR_INTC_0_AXIDMA_0_S2MM_INTROUT_VEC_ID
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TX_INTR_ID        XPAR_INTC_0_AXIDMA_0_MM2S_INTROUT_VEC_ID
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RX_INTR_ID        XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TX_INTR_ID        XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TX_BUFFER_BASE        (MEM_BASE_ADDR + 0x00100000)
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RX_BUFFER_BASE        (MEM_BASE_ADDR + 0x00300000)
&lt;span&gt;133&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RX_BUFFER_HIGH        (MEM_BASE_ADDR + 0x004FFFFF)
&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INTC_DEVICE_ID          XPAR_INTC_0_DEVICE_ID
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INTC_DEVICE_ID          XPAR_SCUGIC_SINGLE_DEVICE_ID
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;  &lt;span&gt;#define&lt;/span&gt; INTC        XIntc
&lt;span&gt;143&lt;/span&gt;  &lt;span&gt;#define&lt;/span&gt; INTC_HANDLER    XIntc_InterruptHandler
&lt;span&gt;144&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;  &lt;span&gt;#define&lt;/span&gt; INTC        XScuGic
&lt;span&gt;146&lt;/span&gt;  &lt;span&gt;#define&lt;/span&gt; INTC_HANDLER    XScuGic_InterruptHandler
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Timeout loop counter for reset
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; RESET_TIMEOUT_COUNTER    10000
&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TEST_START_VALUE    0xC
&lt;span&gt;155&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; &lt;span&gt; * Buffer and Buffer Descriptor related constant definition
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MAX_PKT_LEN        0x100
&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; NUMBER_OF_TRANSFERS    10
&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The interrupt coalescing threshold and delay timer threshold
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt; * Valid range is 1 to 255
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt; * We set the coalescing threshold to be the total number of packets.
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt; * The receive side will only get one completion interrupt for this example.
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt; 
&lt;span&gt;169&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************************** Type Definitions ******************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**************** Macros (Inline Functions) Definitions ********************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************************* Function Prototypes *****************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;#ifndef DEBUG
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; xil_printf(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;format, ...);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt; &lt;span&gt;#ifdef XPAR_UARTNS550_0_BASEADDR
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Uart550_Setup(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CheckData(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Length, u8 StartValue);
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TxIntrHandler(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Callback);
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RxIntrHandler(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Callback);
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetupIntrSystem(INTC *&lt;span&gt; IntcInstancePtr,
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                XAxiDma *&lt;span&gt; AxiDmaPtr, u16 TxIntrId, u16 RxIntrId);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DisableIntrSystem(INTC *&lt;span&gt; IntcInstancePtr,
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                    u16 TxIntrId, u16 RxIntrId);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; 
&lt;span&gt;196&lt;/span&gt; 
&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************************* Variable Definitions ****************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt; &lt;span&gt; * Device instance definitions
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; 
&lt;span&gt;203&lt;/span&gt; 
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XAxiDma AxiDma;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Instance of the XAxiDma &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; INTC Intc;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Instance of the Interrupt Controller &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt; &lt;span&gt; * Flags interrupt handlers use to notify the application context the events.
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TxDone;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; RxDone;
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Error;
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; 
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;* Main function
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;* This function is the main entry of the interrupt test. It does the following:
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;*    Set up the output terminal if UART16550 is in the hardware build
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;*    Initialize the DMA engine
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;*    Set up Tx and Rx channels
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;*    Set up the interrupt system for the Tx and Rx interrupts
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;*    Submit a transfer
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;*    Wait for the transfer to finish
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;*    Check transfer status
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;*    Disable Tx and Rx interrupts
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;*    Print test status and exit
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;* @param    None
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;* @return
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;*        - XST_SUCCESS if example finishes successfully
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;*        - XST_FAILURE if example fails.
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;240&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;     XAxiDma_Config *&lt;span&gt;Config;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; Tries =&lt;span&gt; NUMBER_OF_TRANSFERS;
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Index;
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;     u8 *&lt;span&gt;TxBufferPtr;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;     u8 *&lt;span&gt;RxBufferPtr;
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt;    u8 Value;
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; 
&lt;span&gt;250&lt;/span&gt;     TxBufferPtr = (u8 *&lt;span&gt;)TX_BUFFER_BASE ;
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;     RxBufferPtr = (u8 *&lt;span&gt;)RX_BUFFER_BASE;
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initial setup for Uart16550 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;253&lt;/span&gt; &lt;span&gt;#ifdef XPAR_UARTNS550_0_BASEADDR
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; 
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;    Uart550_Setup();
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; 
&lt;span&gt;257&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; 
&lt;span&gt;259&lt;/span&gt;     xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--- Entering main() --- \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;     Config =&lt;span&gt; XAxiDma_LookupConfig(DMA_DEV_ID);
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Config) {
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No config found for %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, DMA_DEV_ID);
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; 
&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize DMA engine &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt;     Status = XAxiDma_CfgInitialize(&amp;amp;&lt;span&gt;AxiDma, Config);
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; 
&lt;span&gt;271&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Initialization failed %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Status);
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; 
&lt;span&gt;276&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(XAxiDma_HasSg(&amp;amp;&lt;span&gt;AxiDma)){
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Device configured as SG mode \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 
&lt;span&gt;281&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Set up Interrupt system  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;282&lt;/span&gt;     Status = SetupIntrSystem(&amp;amp;Intc, &amp;amp;&lt;span&gt;AxiDma, TX_INTR_ID, RX_INTR_ID);
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt; 
&lt;span&gt;285&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed intr setup\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; 
&lt;span&gt;289&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Disable all interrupts before setup &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;290&lt;/span&gt; 
&lt;span&gt;291&lt;/span&gt;     XAxiDma_IntrDisable(&amp;amp;&lt;span&gt;AxiDma, XAXIDMA_IRQ_ALL_MASK,
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;                        XAXIDMA_DMA_TO_DEVICE);
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; 
&lt;span&gt;294&lt;/span&gt;     XAxiDma_IntrDisable(&amp;amp;&lt;span&gt;AxiDma, XAXIDMA_IRQ_ALL_MASK,
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;                XAXIDMA_DEVICE_TO_DMA);
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; 
&lt;span&gt;297&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Enable all interrupts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;298&lt;/span&gt;     XAxiDma_IntrEnable(&amp;amp;&lt;span&gt;AxiDma, XAXIDMA_IRQ_ALL_MASK,
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;                            XAXIDMA_DMA_TO_DEVICE);
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; 
&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt;     XAxiDma_IntrEnable(&amp;amp;&lt;span&gt;AxiDma, XAXIDMA_IRQ_ALL_MASK,
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt; &lt;span&gt;                            XAXIDMA_DEVICE_TO_DMA);
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt; 
&lt;span&gt;305&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize flags before start transfer test  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;306&lt;/span&gt;     TxDone = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;     RxDone = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;     Error = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; 
&lt;span&gt;310&lt;/span&gt;     Value =&lt;span&gt; TEST_START_VALUE;
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; 
&lt;span&gt;312&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(Index = &lt;span&gt;0&lt;/span&gt;; Index &amp;lt; MAX_PKT_LEN; Index ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt;             TxBufferPtr[Index] =&lt;span&gt; Value;
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; 
&lt;span&gt;315&lt;/span&gt;             Value = (Value + &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; 
&lt;span&gt;318&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Flush the SrcBuffer before the DMA transfer, in case the Data Cache
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; &lt;span&gt;     * is enabled
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;321&lt;/span&gt; &lt;span&gt;    Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, MAX_PKT_LEN);
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; &lt;span&gt;#ifdef __aarch64__
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; &lt;span&gt;    Xil_DCacheFlushRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN);
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;325&lt;/span&gt; 
&lt;span&gt;326&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Send a packet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;327&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(Index = &lt;span&gt;0&lt;/span&gt;; Index &amp;lt; Tries; Index ++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt; 
&lt;span&gt;329&lt;/span&gt;         Status = XAxiDma_SimpleTransfer(&amp;amp;&lt;span&gt;AxiDma,(UINTPTR) RxBufferPtr,
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt; &lt;span&gt;                    MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA);
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; 
&lt;span&gt;332&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; 
&lt;span&gt;336&lt;/span&gt;         Status = XAxiDma_SimpleTransfer(&amp;amp;&lt;span&gt;AxiDma,(UINTPTR) TxBufferPtr,
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;                    MAX_PKT_LEN, XAXIDMA_DMA_TO_DEVICE);
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; 
&lt;span&gt;339&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; 
&lt;span&gt;343&lt;/span&gt; 
&lt;span&gt;344&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;345&lt;/span&gt; &lt;span&gt;         * Wait TX done and RX done
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;347&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!TxDone &amp;amp;&amp;amp; !RxDone &amp;amp;&amp;amp; !&lt;span&gt;Error) {
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NOP &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;349&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; 
&lt;span&gt;351&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Error) {
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt;             xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed test transmit%s done, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;353&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receive%s done\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TxDone? &lt;span&gt;&quot;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; not&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt;                             RxDone? &lt;span&gt;&quot;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; not&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt; 
&lt;span&gt;356&lt;/span&gt;             &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; Done;
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; 
&lt;span&gt;358&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt; 
&lt;span&gt;360&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;361&lt;/span&gt; &lt;span&gt;         * Test finished, check data
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;363&lt;/span&gt;         Status = CheckData(MAX_PKT_LEN, &lt;span&gt;0xC&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt;             xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data check failed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt;             &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; Done;
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt; 
&lt;span&gt;370&lt;/span&gt; 
&lt;span&gt;371&lt;/span&gt;     xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AXI DMA interrupt example test passed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; 
&lt;span&gt;373&lt;/span&gt; 
&lt;span&gt;374&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Disable TX and RX Ring interrupts and return success &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;375&lt;/span&gt; 
&lt;span&gt;376&lt;/span&gt;     DisableIntrSystem(&amp;amp;&lt;span&gt;Intc, TX_INTR_ID, RX_INTR_ID);
&lt;/span&gt;&lt;span&gt;377&lt;/span&gt; 
&lt;span&gt;378&lt;/span&gt; &lt;span&gt;Done:
&lt;/span&gt;&lt;span&gt;379&lt;/span&gt;     xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--- Exiting main() --- \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; 
&lt;span&gt;381&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_SUCCESS;
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt; 
&lt;span&gt;384&lt;/span&gt; &lt;span&gt;#ifdef XPAR_UARTNS550_0_BASEADDR
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;386&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;387&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt; &lt;span&gt;* Uart16550 setup routine, need to set baudrate to 9600 and data bits to 8
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt; &lt;span&gt;* @param    None
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt; &lt;span&gt;* @return    None
&lt;/span&gt;&lt;span&gt;393&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;397&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Uart550_Setup(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt; 
&lt;span&gt;400&lt;/span&gt; &lt;span&gt;    XUartNs550_SetBaud(XPAR_UARTNS550_0_BASEADDR,
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt;             XPAR_XUARTNS550_CLOCK_HZ, &lt;span&gt;9600&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt; 
&lt;span&gt;403&lt;/span&gt; &lt;span&gt;    XUartNs550_SetLineControlReg(XPAR_UARTNS550_0_BASEADDR,
&lt;/span&gt;&lt;span&gt;404&lt;/span&gt; &lt;span&gt;            XUN_LCR_8_DATA_BITS);
&lt;/span&gt;&lt;span&gt;405&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;407&lt;/span&gt; 
&lt;span&gt;408&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;409&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;410&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt; &lt;span&gt;* This function checks data buffer after the DMA transfer is finished.
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt; &lt;span&gt;* We use the static tx/rx buffers.
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt; &lt;span&gt;* @param    Length is the length to check
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; &lt;span&gt;* @param    StartValue is the starting value of the first byte
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt; &lt;span&gt;* @return
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt; &lt;span&gt;*        - XST_SUCCESS if validation is successful
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt; &lt;span&gt;*        - XST_FAILURE if validation is failure.
&lt;/span&gt;&lt;span&gt;421&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;424&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;425&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CheckData(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Length, u8 StartValue)
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;427&lt;/span&gt;     u8 *&lt;span&gt;RxPacket;
&lt;/span&gt;&lt;span&gt;428&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; Index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt; &lt;span&gt;    u8 Value;
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt; 
&lt;span&gt;431&lt;/span&gt;     RxPacket = (u8 *&lt;span&gt;) RX_BUFFER_BASE;
&lt;/span&gt;&lt;span&gt;432&lt;/span&gt;     Value =&lt;span&gt; StartValue;
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt; 
&lt;span&gt;434&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Invalidate the DestBuffer before receiving the data, in case the
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; &lt;span&gt;     * Data Cache is enabled
&lt;/span&gt;&lt;span&gt;436&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;437&lt;/span&gt; &lt;span&gt;#ifndef __aarch64__
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt; &lt;span&gt;    Xil_DCacheInvalidateRange((u32)RxPacket, Length);
&lt;/span&gt;&lt;span&gt;439&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;440&lt;/span&gt; 
&lt;span&gt;441&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(Index = &lt;span&gt;0&lt;/span&gt;; Index &amp;lt; Length; Index++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (RxPacket[Index] !=&lt;span&gt; Value) {
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;             xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data error %d: %x/%x\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt; &lt;span&gt;                Index, RxPacket[Index], Value);
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt; 
&lt;span&gt;446&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt;         Value = (Value + &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; 
&lt;span&gt;451&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_SUCCESS;
&lt;/span&gt;&lt;span&gt;452&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;453&lt;/span&gt; 
&lt;span&gt;454&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;455&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;456&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt; &lt;span&gt;* This is the DMA TX Interrupt handler function.
&lt;/span&gt;&lt;span&gt;458&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;459&lt;/span&gt; &lt;span&gt;* It gets the interrupt status from the hardware, acknowledges it, and if any
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt; &lt;span&gt;* error happens, it resets the hardware. Otherwise, if a completion interrupt
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt; &lt;span&gt;* is present, then sets the TxDone.flag
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt; &lt;span&gt;* @param    Callback is a pointer to TX channel of the DMA engine.
&lt;/span&gt;&lt;span&gt;464&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt; &lt;span&gt;* @return    None.
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;469&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;470&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TxIntrHandler(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Callback)
&lt;/span&gt;&lt;span&gt;471&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;472&lt;/span&gt; 
&lt;span&gt;473&lt;/span&gt; &lt;span&gt;    u32 IrqStatus;
&lt;/span&gt;&lt;span&gt;474&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TimeOut;
&lt;/span&gt;&lt;span&gt;475&lt;/span&gt;     XAxiDma *AxiDmaInst = (XAxiDma *&lt;span&gt;)Callback;
&lt;/span&gt;&lt;span&gt;476&lt;/span&gt; 
&lt;span&gt;477&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Read pending interrupts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;478&lt;/span&gt;     IrqStatus =&lt;span&gt; XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DMA_TO_DEVICE);
&lt;/span&gt;&lt;span&gt;479&lt;/span&gt; 
&lt;span&gt;480&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acknowledge pending interrupts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;481&lt;/span&gt; 
&lt;span&gt;482&lt;/span&gt; 
&lt;span&gt;483&lt;/span&gt; &lt;span&gt;    XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DMA_TO_DEVICE);
&lt;/span&gt;&lt;span&gt;484&lt;/span&gt; 
&lt;span&gt;485&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;486&lt;/span&gt; &lt;span&gt;     * If no interrupt is asserted, we do not do anything
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;488&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!(IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_ALL_MASK)) {
&lt;/span&gt;&lt;span&gt;489&lt;/span&gt; 
&lt;span&gt;490&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;491&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt; 
&lt;span&gt;493&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;494&lt;/span&gt; &lt;span&gt;     * If error interrupt is asserted, raise error flag, reset the
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt; &lt;span&gt;     * hardware to recover from the error, and return with no further
&lt;/span&gt;&lt;span&gt;496&lt;/span&gt; &lt;span&gt;     * processing.
&lt;/span&gt;&lt;span&gt;497&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;498&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_ERROR_MASK)) {
&lt;/span&gt;&lt;span&gt;499&lt;/span&gt; 
&lt;span&gt;500&lt;/span&gt;         Error = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;501&lt;/span&gt; 
&lt;span&gt;502&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;503&lt;/span&gt; &lt;span&gt;         * Reset should never fail for transmit channel
&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;505&lt;/span&gt; &lt;span&gt;        XAxiDma_Reset(AxiDmaInst);
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt; 
&lt;span&gt;507&lt;/span&gt;         TimeOut =&lt;span&gt; RESET_TIMEOUT_COUNTER;
&lt;/span&gt;&lt;span&gt;508&lt;/span&gt; 
&lt;span&gt;509&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (TimeOut) {
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (XAxiDma_ResetIsDone(AxiDmaInst)) {
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt; 
&lt;span&gt;514&lt;/span&gt;             TimeOut -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt; 
&lt;span&gt;517&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt; 
&lt;span&gt;520&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;521&lt;/span&gt; &lt;span&gt;     * If Completion interrupt is asserted, then set the TxDone flag
&lt;/span&gt;&lt;span&gt;522&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;523&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_IOC_MASK)) {
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt; 
&lt;span&gt;525&lt;/span&gt;         TxDone = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;527&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;528&lt;/span&gt; 
&lt;span&gt;529&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;530&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;531&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;532&lt;/span&gt; &lt;span&gt;* This is the DMA RX interrupt handler function
&lt;/span&gt;&lt;span&gt;533&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;534&lt;/span&gt; &lt;span&gt;* It gets the interrupt status from the hardware, acknowledges it, and if any
&lt;/span&gt;&lt;span&gt;535&lt;/span&gt; &lt;span&gt;* error happens, it resets the hardware. Otherwise, if a completion interrupt
&lt;/span&gt;&lt;span&gt;536&lt;/span&gt; &lt;span&gt;* is present, then it sets the RxDone flag.
&lt;/span&gt;&lt;span&gt;537&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;* @param    Callback is a pointer to RX channel of the DMA engine.
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt; &lt;span&gt;* @return    None.
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;542&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;543&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;544&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;545&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RxIntrHandler(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;Callback)
&lt;/span&gt;&lt;span&gt;546&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt; &lt;span&gt;    u32 IrqStatus;
&lt;/span&gt;&lt;span&gt;548&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TimeOut;
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt;     XAxiDma *AxiDmaInst = (XAxiDma *&lt;span&gt;)Callback;
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt; 
&lt;span&gt;551&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Read pending interrupts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;552&lt;/span&gt;     IrqStatus =&lt;span&gt; XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA);
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt; 
&lt;span&gt;554&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acknowledge pending interrupts &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;555&lt;/span&gt; &lt;span&gt;    XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA);
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt; 
&lt;span&gt;557&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;558&lt;/span&gt; &lt;span&gt;     * If no interrupt is asserted, we do not do anything
&lt;/span&gt;&lt;span&gt;559&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;560&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!(IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_ALL_MASK)) {
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; 
&lt;span&gt;564&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;565&lt;/span&gt; &lt;span&gt;     * If error interrupt is asserted, raise error flag, reset the
&lt;/span&gt;&lt;span&gt;566&lt;/span&gt; &lt;span&gt;     * hardware to recover from the error, and return with no further
&lt;/span&gt;&lt;span&gt;567&lt;/span&gt; &lt;span&gt;     * processing.
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;569&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_ERROR_MASK)) {
&lt;/span&gt;&lt;span&gt;570&lt;/span&gt; 
&lt;span&gt;571&lt;/span&gt;         Error = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;572&lt;/span&gt; 
&lt;span&gt;573&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Reset could fail and hang
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt; &lt;span&gt;         * NEED a way to handle this or do not call it??
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;576&lt;/span&gt; &lt;span&gt;        XAxiDma_Reset(AxiDmaInst);
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt; 
&lt;span&gt;578&lt;/span&gt;         TimeOut =&lt;span&gt; RESET_TIMEOUT_COUNTER;
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt; 
&lt;span&gt;580&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (TimeOut) {
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(XAxiDma_ResetIsDone(AxiDmaInst)) {
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;583&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;584&lt;/span&gt; 
&lt;span&gt;585&lt;/span&gt;             TimeOut -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt; 
&lt;span&gt;588&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt; 
&lt;span&gt;591&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;592&lt;/span&gt; &lt;span&gt;     * If completion interrupt is asserted, then set RxDone flag
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;594&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((IrqStatus &amp;amp;&lt;span&gt; XAXIDMA_IRQ_IOC_MASK)) {
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt; 
&lt;span&gt;596&lt;/span&gt;         RxDone = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;597&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt; 
&lt;span&gt;600&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;601&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;602&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;603&lt;/span&gt; &lt;span&gt;* This function setups the interrupt system so interrupts can occur for the
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;* DMA, it assumes INTC component exists in the hardware system.
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt; &lt;span&gt;* @param    IntcInstancePtr is a pointer to the instance of the INTC.
&lt;/span&gt;&lt;span&gt;607&lt;/span&gt; &lt;span&gt;* @param    AxiDmaPtr is a pointer to the instance of the DMA engine
&lt;/span&gt;&lt;span&gt;608&lt;/span&gt; &lt;span&gt;* @param    TxIntrId is the TX channel Interrupt ID.
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt; &lt;span&gt;* @param    RxIntrId is the RX channel Interrupt ID.
&lt;/span&gt;&lt;span&gt;610&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt; &lt;span&gt;* @return
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt; &lt;span&gt;*        - XST_SUCCESS if successful,
&lt;/span&gt;&lt;span&gt;613&lt;/span&gt; &lt;span&gt;*        - XST_FAILURE.if not succesful
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;615&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;617&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;618&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetupIntrSystem(INTC *&lt;span&gt; IntcInstancePtr,
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt;                XAxiDma *&lt;span&gt; AxiDmaPtr, u16 TxIntrId, u16 RxIntrId)
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt; 
&lt;span&gt;623&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt; 
&lt;span&gt;625&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize the interrupt controller and connect the ISRs &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;626&lt;/span&gt;     Status =&lt;span&gt; XIntc_Initialize(IntcInstancePtr, INTC_DEVICE_ID);
&lt;/span&gt;&lt;span&gt;627&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt; 
&lt;span&gt;629&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed init intc\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;630&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;631&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt; 
&lt;span&gt;633&lt;/span&gt;     Status =&lt;span&gt; XIntc_Connect(IntcInstancePtr, TxIntrId,
&lt;/span&gt;&lt;span&gt;634&lt;/span&gt; &lt;span&gt;                   (XInterruptHandler) TxIntrHandler, AxiDmaPtr);
&lt;/span&gt;&lt;span&gt;635&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt; 
&lt;span&gt;637&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed tx connect intc\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;638&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt; 
&lt;span&gt;641&lt;/span&gt;     Status =&lt;span&gt; XIntc_Connect(IntcInstancePtr, RxIntrId,
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt; &lt;span&gt;                   (XInterruptHandler) RxIntrHandler, AxiDmaPtr);
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt; 
&lt;span&gt;645&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed rx connect intc\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;647&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt; 
&lt;span&gt;649&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Start the interrupt controller &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;650&lt;/span&gt;     Status =&lt;span&gt; XIntc_Start(IntcInstancePtr, XIN_REAL_MODE);
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt; 
&lt;span&gt;653&lt;/span&gt;         xil_printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed to start intc\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;654&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;656&lt;/span&gt; 
&lt;span&gt;657&lt;/span&gt; &lt;span&gt;    XIntc_Enable(IntcInstancePtr, TxIntrId);
&lt;/span&gt;&lt;span&gt;658&lt;/span&gt; &lt;span&gt;    XIntc_Enable(IntcInstancePtr, RxIntrId);
&lt;/span&gt;&lt;span&gt;659&lt;/span&gt; 
&lt;span&gt;660&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;661&lt;/span&gt; 
&lt;span&gt;662&lt;/span&gt;     XScuGic_Config *&lt;span&gt;IntcConfig;
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt; 
&lt;span&gt;664&lt;/span&gt; 
&lt;span&gt;665&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;666&lt;/span&gt; &lt;span&gt;     * Initialize the interrupt controller driver so that it is ready to
&lt;/span&gt;&lt;span&gt;667&lt;/span&gt; &lt;span&gt;     * use.
&lt;/span&gt;&lt;span&gt;668&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;669&lt;/span&gt;     IntcConfig =&lt;span&gt; XScuGic_LookupConfig(INTC_DEVICE_ID);
&lt;/span&gt;&lt;span&gt;670&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; IntcConfig) {
&lt;/span&gt;&lt;span&gt;671&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;672&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;673&lt;/span&gt; 
&lt;span&gt;674&lt;/span&gt;     Status =&lt;span&gt; XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig,
&lt;/span&gt;&lt;span&gt;675&lt;/span&gt;                     IntcConfig-&amp;gt;&lt;span&gt;CpuBaseAddress);
&lt;/span&gt;&lt;span&gt;676&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;677&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;678&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;679&lt;/span&gt; 
&lt;span&gt;680&lt;/span&gt; 
&lt;span&gt;681&lt;/span&gt;     XScuGic_SetPriorityTriggerType(IntcInstancePtr, TxIntrId, &lt;span&gt;0xA0&lt;/span&gt;, &lt;span&gt;0x3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;682&lt;/span&gt; 
&lt;span&gt;683&lt;/span&gt;     XScuGic_SetPriorityTriggerType(IntcInstancePtr, RxIntrId, &lt;span&gt;0xA0&lt;/span&gt;, &lt;span&gt;0x3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;684&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;685&lt;/span&gt; &lt;span&gt;     * Connect the device driver handler that will be called when an
&lt;/span&gt;&lt;span&gt;686&lt;/span&gt; &lt;span&gt;     * interrupt for the device occurs, the handler defined above performs
&lt;/span&gt;&lt;span&gt;687&lt;/span&gt; &lt;span&gt;     * the specific interrupt processing for the device.
&lt;/span&gt;&lt;span&gt;688&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;689&lt;/span&gt;     Status =&lt;span&gt; XScuGic_Connect(IntcInstancePtr, TxIntrId,
&lt;/span&gt;&lt;span&gt;690&lt;/span&gt; &lt;span&gt;                (Xil_InterruptHandler)TxIntrHandler,
&lt;/span&gt;&lt;span&gt;691&lt;/span&gt; &lt;span&gt;                AxiDmaPtr);
&lt;/span&gt;&lt;span&gt;692&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;693&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status;
&lt;/span&gt;&lt;span&gt;694&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;695&lt;/span&gt; 
&lt;span&gt;696&lt;/span&gt;     Status =&lt;span&gt; XScuGic_Connect(IntcInstancePtr, RxIntrId,
&lt;/span&gt;&lt;span&gt;697&lt;/span&gt; &lt;span&gt;                (Xil_InterruptHandler)RxIntrHandler,
&lt;/span&gt;&lt;span&gt;698&lt;/span&gt; &lt;span&gt;                AxiDmaPtr);
&lt;/span&gt;&lt;span&gt;699&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Status !=&lt;span&gt; XST_SUCCESS) {
&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status;
&lt;/span&gt;&lt;span&gt;701&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;702&lt;/span&gt; 
&lt;span&gt;703&lt;/span&gt; &lt;span&gt;    XScuGic_Enable(IntcInstancePtr, TxIntrId);
&lt;/span&gt;&lt;span&gt;704&lt;/span&gt; &lt;span&gt;    XScuGic_Enable(IntcInstancePtr, RxIntrId);
&lt;/span&gt;&lt;span&gt;705&lt;/span&gt; 
&lt;span&gt;706&lt;/span&gt; 
&lt;span&gt;707&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;708&lt;/span&gt; 
&lt;span&gt;709&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Enable interrupts from the hardware &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;710&lt;/span&gt; 
&lt;span&gt;711&lt;/span&gt; &lt;span&gt;    Xil_ExceptionInit();
&lt;/span&gt;&lt;span&gt;712&lt;/span&gt; &lt;span&gt;    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
&lt;/span&gt;&lt;span&gt;713&lt;/span&gt; &lt;span&gt;            (Xil_ExceptionHandler)INTC_HANDLER,
&lt;/span&gt;&lt;span&gt;714&lt;/span&gt;             (&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)IntcInstancePtr);
&lt;/span&gt;&lt;span&gt;715&lt;/span&gt; 
&lt;span&gt;716&lt;/span&gt; &lt;span&gt;    Xil_ExceptionEnable();
&lt;/span&gt;&lt;span&gt;717&lt;/span&gt; 
&lt;span&gt;718&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_SUCCESS;
&lt;/span&gt;&lt;span&gt;719&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;720&lt;/span&gt; 
&lt;span&gt;721&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;722&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;723&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;724&lt;/span&gt; &lt;span&gt;* This function disables the interrupts for DMA engine.
&lt;/span&gt;&lt;span&gt;725&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;726&lt;/span&gt; &lt;span&gt;* @param    IntcInstancePtr is the pointer to the INTC component instance
&lt;/span&gt;&lt;span&gt;727&lt;/span&gt; &lt;span&gt;* @param    TxIntrId is interrupt ID associated w/ DMA TX channel
&lt;/span&gt;&lt;span&gt;728&lt;/span&gt; &lt;span&gt;* @param    RxIntrId is interrupt ID associated w/ DMA RX channel
&lt;/span&gt;&lt;span&gt;729&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;730&lt;/span&gt; &lt;span&gt;* @return    None.
&lt;/span&gt;&lt;span&gt;731&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;732&lt;/span&gt; &lt;span&gt;* @note        None.
&lt;/span&gt;&lt;span&gt;733&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;734&lt;/span&gt; &lt;span&gt;*****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;735&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DisableIntrSystem(INTC *&lt;span&gt; IntcInstancePtr,
&lt;/span&gt;&lt;span&gt;736&lt;/span&gt; &lt;span&gt;                    u16 TxIntrId, u16 RxIntrId)
&lt;/span&gt;&lt;span&gt;737&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;738&lt;/span&gt; &lt;span&gt;#ifdef XPAR_INTC_0_DEVICE_ID
&lt;/span&gt;&lt;span&gt;739&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Disconnect the interrupts for the DMA TX and RX channels &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;740&lt;/span&gt; &lt;span&gt;    XIntc_Disconnect(IntcInstancePtr, TxIntrId);
&lt;/span&gt;&lt;span&gt;741&lt;/span&gt; &lt;span&gt;    XIntc_Disconnect(IntcInstancePtr, RxIntrId);
&lt;/span&gt;&lt;span&gt;742&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;743&lt;/span&gt; &lt;span&gt;    XScuGic_Disconnect(IntcInstancePtr, TxIntrId);
&lt;/span&gt;&lt;span&gt;744&lt;/span&gt; &lt;span&gt;    XScuGic_Disconnect(IntcInstancePtr, RxIntrId);
&lt;/span&gt;&lt;span&gt;745&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;746&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Wed, 29 Aug 2018 07:32:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<og:description>一、AXI DMA介绍 本篇博文讲述AXI DMA的一些使用总结，硬件IP子系统搭建与SDK C代码封装参考米联客ZYNQ教程。若想让ZYNQ的PS与PL两部分高速数据传输，需要利用PS的HP（高性能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/9554097.html</dc:identifier>
</item>
<item>
<title>前两天做项目遇到了sqlserver最大连接数 Max Pool Size 的问题 - 张子浩</title>
<link>http://www.cnblogs.com/iWaitYou/p/9554117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iWaitYou/p/9554117.html</guid>
<description>&lt;p&gt;前言：出现这种问题使因为程序对connection的回收出现了问题,是因为你的代码出出现了过多new connection(),这种情况还是你的代码问题,如果不想把问题归根于程序,那你就可以改变config连接字符串.&lt;/p&gt;
&lt;p&gt;在sqlserver中查看链接的Sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; sysprocesses &lt;span&gt;where&lt;/span&gt; dbid= db_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据库名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在项目中未指明Connectionstring的max pool 的大小,默认是100, 理论最大为32767,如果项目对这个数据库的链接超过了最大限制,则会让后面的链接进行等待,等待时间为15s.&lt;/p&gt;
&lt;p&gt;说明：也就是在connectionString中如果未指定max pool size的值，则max pool size=100，当访问人员同时连接数据库的数量为101人时，则等待SqlConnection.ConnectionTimeout设置的时间（默认是15 秒）后，还是没有可用的Connection则会出现上面的错误。&lt;/p&gt;
&lt;p&gt;但如果超过了这个时间则会报错，报错详情如下：&lt;/p&gt;
&lt;p&gt;中文错误：&lt;/p&gt;
&lt;p&gt;超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。&lt;/p&gt;
&lt;p&gt;英文错误：&lt;/p&gt;
&lt;p&gt;Timeout expired.  The timeout period elapsed prior to obtaining a connection from the pool.  This may have occurred because all pooled connections were in use and max pool size was reached. &lt;/p&gt;

&lt;div align=&quot;left&quot; readability=&quot;12&quot;&gt;解决办法：
&lt;p&gt;1.在访问数据库的页面上使用数据缓存，如果页面的数据不是经常更新（几分钟更新一次）的话，使用Cache对象可以不用访问数据库而使用缓存中的内容，那么可以大大减少连接数量。           &lt;/p&gt;
&lt;p&gt;2.可以在WEB.config 里面修改连接字符串中的Max Pool Size = N;来动态扩大连接池中的连接最大数量。&lt;/p&gt;
&lt;/div&gt;
&lt;div align=&quot;left&quot; readability=&quot;22.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=192.168.1.123; Port=3336; uid=root; pwd=root;database=Userdata;pooling=true;min pool size=5;max pool size=512;connect timeout = 20; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库Connection Pool 连接池是什么？&lt;/p&gt;
&lt;p&gt;每当程序需要读写数据库的时候。Connection.Open()会使用ConnectionString连接到数据库，数据库会为程序建立 一个连接，并且保持打开状态，此后程序就可以使用T-SQL语句来查询/更新数据库。当执行到Connection.Close()后，数据库就会关闭当 前的连接。&lt;/p&gt;

&lt;p&gt;但是如果我的程序需要不定时的打开和关闭连接，（比如说 ASP.Net 或是 Web Service ），例如当Http Request发送到服务器的时候、，我们需要打开Connection 然后使用Select* from Table 返回一个DataTable/DataSet给客户端/浏览器，然后关闭当前的Connection。那每次都Open/Close Connection 如此的频繁操作对于整个系统无疑就成了一种浪费。&lt;/p&gt;

&lt;p&gt;ADO.Net Team就给出了一个比较好地解决方法。将先前的Connection保存起来，当下一次需要打开连接的时候就将先前的Connection 交给下一个连接。这就是Connection Pool。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 29 Aug 2018 07:32:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>前言：出现这种问题使因为程序对connection的回收出现了问题,是因为你的代码出出现了过多new connection(),这种情况还是你的代码问题,如果不想把问题归根于程序,那你就可以改变con</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iWaitYou/p/9554117.html</dc:identifier>
</item>
<item>
<title>【中间件】Redis 实战之主从复制、高可用、分布式 - Never、C</title>
<link>http://www.cnblogs.com/neverc/p/9554498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neverc/p/9554498.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;li&gt;主从复制&lt;/li&gt;
&lt;li&gt;高可用 Redis-Sentinel
&lt;ul&gt;&lt;li&gt;.NET Core开发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分布式 Redis-Cluster&lt;/li&gt;
&lt;li&gt;配置说明&lt;/li&gt;
&lt;li&gt;常见问题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本节内容基于 CentOS 7.4.1708，Redis 3.2.12 环境实验。&lt;/p&gt;
&lt;p&gt;Redis 是一个开源的高性能键值对数据库。&lt;/p&gt;
&lt;p&gt;安装：&lt;code&gt;yum install -y redis&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能 Key-Value 服务器&lt;/li&gt;
&lt;li&gt;多种数据结构&lt;/li&gt;
&lt;li&gt;丰富功能
&lt;ul&gt;&lt;li&gt;缓存(get|set)&lt;/li&gt;
&lt;li&gt;计数器(incre)&lt;/li&gt;
&lt;li&gt;消息队列(publish|subcrib)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;高可用(v2.8 redis-sentinel)&lt;/li&gt;
&lt;li&gt;分布式(v3.0 redis-cluster)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可执行文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis-server：服务端&lt;/li&gt;
&lt;li&gt;redis-cli：客户端&lt;/li&gt;
&lt;li&gt;redis-benchmark：性能测试工具&lt;/li&gt;
&lt;li&gt;redis-check-aof：aof修复工具&lt;/li&gt;
&lt;li&gt;redis-check-dump：rdb修复工具&lt;/li&gt;
&lt;li&gt;redis-sentinel：sentinel服务端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最简启动：默认配置直接启动redis-server&lt;/li&gt;
&lt;li&gt;动态参数启动：命令行指定配置启动redis-server&lt;/li&gt;
&lt;li&gt;配置文件启动(推荐)：指定配置文件启动redis-server&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动验证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ps -ef|grep redis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli -h locahost -p 6379 ping&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于 redis 是单线程的，推荐在一台多核CPU机器上部署多个 redis 实例充分发挥。&lt;/p&gt;
&lt;h2 id=&quot;持久化&quot;&gt;持久化&lt;/h2&gt;
&lt;p&gt;redis 持久化支持2种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RDB：快照方式，相当于 MySQL 中的 dump&lt;/li&gt;
&lt;li&gt;AOF：写日志方式，相当于 MySQL 中的 binlog，推荐使用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当同时开启 RDB 和 AOF 的时候，redis启动的时候会读取 AOF 还原数据。&lt;/li&gt;
&lt;li&gt;推荐：关闭 RDB 持久化机制,开启 AOF&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;rdb&quot;&gt;RDB&lt;/h3&gt;
&lt;p&gt;RDB是什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RDB方式的持久化是通过快照(snapshortting)完成的，当符合一定条件时Redis会自动将内存中所有数据完整的压缩存储到硬盘上。&lt;/li&gt;
&lt;li&gt;RDB开启条件由2个参数 时间 和 改动次数构成。如：save 900 1&lt;/li&gt;
&lt;li&gt;RDB文件由2个参数 dir 和 dbfilename 分别指定目录 和 文件名&lt;/li&gt;
&lt;li&gt;RDB方式是Redis默认的持久化方式。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;触发命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;save 命令(阻塞)&lt;/li&gt;
&lt;li&gt;bgsave 命令(fork过程阻塞)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主要触发方式:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动触发规则(内部调用bgsave，不推荐开启)&lt;/li&gt;
&lt;li&gt;全量复制(内部调用bgsave)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行 save 或 bgsave 命令&lt;/li&gt;
&lt;li&gt;生成新的 rdb 文件，如：temp-36985.rdb&lt;/li&gt;
&lt;li&gt;覆盖 rdb 文件，如：dump-6379.rdb&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动速度快&lt;/li&gt;
&lt;li&gt;占用空间小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;容易丢失数据&lt;/li&gt;
&lt;li&gt;时间复杂度O(n)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关闭RDB方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli config set save &quot;&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;RDB并不能真正的关闭，在主从复制时主从都会生成RDB文件&lt;/p&gt;
&lt;h3 id=&quot;aof&quot;&gt;AOF&lt;/h3&gt;
&lt;p&gt;AOF是什么:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AOF是纯文本文件，会记录 Redis 的每次改动命令(不记录查询)。&lt;/li&gt;
&lt;li&gt;AOF开启条件：appendonly yes&lt;/li&gt;
&lt;li&gt;AOF文件由2个参数 dir 和 appendfilename 分别指定目录 和 文件名&lt;/li&gt;
&lt;li&gt;AOF方式 默认情况下Redis并没有开启。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于每次改动都会记录，产生2个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每次改动都写入硬盘，普通硬盘只能承受几百次qps。通过写入策略来调整&lt;/li&gt;
&lt;li&gt;对同1个key执行几次操作就记录几次，冗余量特别大。通过 aof 文件重写来调整&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AOF文件有3种写入策略：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;always(每次写入都会fsync同步到硬盘)&lt;/li&gt;
&lt;li&gt;everysec(默认，1s写1次)&lt;/li&gt;
&lt;li&gt;no(并非不写，交给系统控制预计30s写1次)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AOF重写：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重写方式
&lt;ol&gt;&lt;li&gt;手动执行 bgrewriteaof 命令&lt;/li&gt;
&lt;li&gt;自动触发规则(通过指定最小aof文件和aof增长率来自动内部调用 bgrewriteaof)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;过程
&lt;ol&gt;&lt;li&gt;fork 出子进程&lt;/li&gt;
&lt;li&gt;子进程执行 bgrewriteaof 命令&lt;/li&gt;
&lt;li&gt;父进程将新接收的命令，同时写到 aof 文件和 aof_rewrite_buffer文件中。(在 aof 重写时，可配置关闭aof写入)&lt;/li&gt;
&lt;li&gt;子进程将 aof_rewrite_buffer 文件追加到新 aof 文件中。&lt;/li&gt;
&lt;li&gt;覆盖旧的 aof 文件&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;采用 everysec 方式，最多可能丢失 2s 的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;主从复制&quot;&gt;主从复制&lt;/h2&gt;
&lt;p&gt;为什么需要主从复制：&lt;/p&gt;
&lt;p&gt;通过持久化保证 Redis 在服务器重启的情况下数据也不会丢失。但数据在一台服务器上，如果服务器的硬盘坏了,也会导致数据丢失。为了避免单点故障，Redis 提供了主从复制高可用方案。&lt;/p&gt;
&lt;p&gt;主从复制结构：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;1个 master 可以有多个 slave&lt;/li&gt;
&lt;li&gt;1个 slave 只能有1个 master&lt;/li&gt;
&lt;li&gt;数据流向单向 master -&amp;gt; slave&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;开启复制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令：&lt;code&gt;--slaveof ip port&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置：&lt;code&gt;slaveof ip port&lt;/code&gt;(默认配置都是master)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关闭复制：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slaveof no one&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;复制类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全量复制(首次 或者 网络断开时间比较长)&lt;/li&gt;
&lt;li&gt;部分复制(在网络抖动一定范围的情况下,v2.8以上可配置复制缓存区repl-backlog-size)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;全量复制过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slave 节点 发起 psync runid offset：&lt;code&gt;psync ? -1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master 节点 返回 fullresync runid offset&lt;/li&gt;
&lt;li&gt;master 节点 bgsave 保存当前数据到 rdb&lt;/li&gt;
&lt;li&gt;master 节点 在此期间接收到新的数据存储到 buffer 中&lt;/li&gt;
&lt;li&gt;master 节点 send RDB、send buffer&lt;/li&gt;
&lt;li&gt;slave 节点 flush old data&lt;/li&gt;
&lt;li&gt;slave 节点 load RDB、load buffer&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在master重启(master 的run_id更新)和slave重启(slave 的run_id丢失)时都会发生全量复制,通过 info server 可以查看run_id。&lt;/p&gt;
&lt;p&gt;部分复制过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slave 节点 发起 psync runid offset&lt;/li&gt;
&lt;li&gt;master 节点 确认 runid 和 offset没问题后，发送增量数据&lt;/li&gt;
&lt;li&gt;slave 节点 接收同步数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当全量复制完成 或 网络抖动一定范围 时，master 相当于 slave 的 client 进行增量更新数据。&lt;/p&gt;
&lt;h2 id=&quot;redis-sentinel&quot;&gt;Redis Sentinel&lt;/h2&gt;
&lt;p&gt;Redis-Sentinel是什么？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案&lt;/li&gt;
&lt;li&gt;Redis-Sentinel本身也是一个独立运行的进程，它能监控多个 master-slave 集群，发现 master宕机 后能进行自动故障转移。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;sentinel工作原理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备多个Redis Sentinel节点(建议至少3个节点，避免单点故障)&lt;/li&gt;
&lt;li&gt;多个 Sentinel 节点发现并确认 master 主观下线&lt;/li&gt;
&lt;li&gt;超过 quorum 个 sentinel 判定确认 客观下线&lt;/li&gt;
&lt;li&gt;选出 1个 sentinel 节点作为领导&lt;/li&gt;
&lt;li&gt;选出 1个 slave 节点作为 master&lt;/li&gt;
&lt;li&gt;切换 slave 节点的 master 为新的 master&lt;/li&gt;
&lt;li&gt;通知 client 主从变化&lt;/li&gt;
&lt;li&gt;等待故障的 master 复活成为新的 slave&lt;/li&gt;
&lt;li&gt;Client 不直接连接 Redis 节点，应该连接 Sentinel 节点获取 Redis Info&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2种下线判定：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;sdown(subjectively down,主观下线)：每个 sentinel 判定 redis 节点下线。&lt;/li&gt;
&lt;li&gt;odown(objectively down,客观下线)：超过 quorum 个 sentinel 判定 redis 节点下线。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;启动方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;redis-sentinel /path/to/sentinel.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-server /path/to/sentinel.conf --sentinel&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;三个定时任务：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个 Sentinel 节点每秒通过 redis 的 &lt;code&gt;__sentinel__:hello&lt;/code&gt; 发布一条消息,宣布自己的存在。同时也订阅来确定其他的 Sentinel 节点。&lt;/li&gt;
&lt;li&gt;每个 Sentinel 节点每秒对其他 redis 节点执行 ping。确定是否下线。&lt;/li&gt;
&lt;li&gt;每个 Sentinel 节点每10秒 对 master 和 slave 执行 info，确定 slaves。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置模拟：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置 Redis 开启主从复制&lt;/li&gt;
&lt;li&gt;配置 Sentinel 监控主节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;echo &quot;停止当前所有redis-server + redis-sentinel&quot;;
ps -x | grep redis | grep -v grep | awk '{print $1}' | xargs -r kill
echo &quot;生成并启动3个 redis 配置&quot;;
for port in 6379 6380 6381 ;do
echo -e &quot;daemonize yes\nport $port\npidfile /var/run/redis-$port.pid\nlogfile /var/log/redis/redis-$port.log\n&quot; &amp;gt; /etc/redis/redis-$port.conf
if [ $port != 6379 ];then
    echo &quot;slaveof 127.0.0.1 6379&quot; &amp;gt;&amp;gt; /etc/redis/redis-$port.conf
fi
redis-server /etc/redis/redis-$port.conf
done
echo &quot;生成并启动3个 redis-sentinel 配置&quot;;
for port in 26379 26380 26381 ;do
echo -e &quot;daemonize yes\nport $port\ndir /tmp\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 3000\nsentinel parallel-syncs mymaster 1\nsentinel failover-timeout mymaster 60000\nlogfile /var/log/redis/sentinel-$port.log\n&quot; &amp;gt; /etc/redis/redis-sentinel-$port.conf
redis-sentinel /etc/redis/redis-sentinel-$port.conf
done
echo &quot;结束&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的channel：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;+switch-master：切换主节点&lt;/li&gt;
&lt;li&gt;+convert-to-slave：切换从节点&lt;/li&gt;
&lt;li&gt;+sdown：主观下线&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.NET Core环境开发：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet add package StackExchange.Redis&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var options = new ConfigurationOptions()
{
    CommandMap = CommandMap.Sentinel,
    EndPoints = { { &quot;192.168.0.51&quot;, 26379}, {&quot;192.168.0.51&quot;, 26381}, {&quot;192.168.0.51&quot;, 26380} },
    AllowAdmin = true,
    TieBreaker = &quot;&quot;,
    ServiceName = &quot;mymaster&quot;,
    SyncTimeout = 5000
};

var sentinelConn = ConnectionMultiplexer.Connect(options);
var master = sentinelConn.GetServer(&quot;192.168.0.51&quot;,26381).SentinelGetMasterAddressByName(&quot;mymaster&quot;);
// ...
var conn = ConnectionMultiplexer.Connect(master);
sentinelConn.GetSubscriber().Subscribe(&quot;+switch-master&quot;, (channel, message) =&amp;gt;
{
    // mymaster 192.168.0.51 6380 192.168.0.51 6381
    Console.WriteLine((string)message);
    // ...
    conn = ConnectionMultiplexer.Connect(ip);
    conn.GetDatabase().StringSet(&quot;hello&quot;,&quot;故障切换后值&quot;);
});
sentinelConn.GetSubscriber().Subscribe(&quot;+convert-to-slave&quot;, (channel, message) =&amp;gt;
{
    // slave 192.168.0.51:6379 192.168.0.51 6379 @ mymaster 192.168.0.51 6380
    Console.WriteLine((string)message);
});

conn.GetDatabase().StringSet(&quot;hello&quot;,&quot;原始值&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有Sentinel和Redis不能在同一个节点&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;redis-cluster&quot;&gt;Redis Cluster&lt;/h2&gt;
&lt;p&gt;实际上大部分场景下，Redis Sentinel已经足够好。请根据实际情况采用 Redis Cluster。&lt;/p&gt;
&lt;p&gt;Redis Cluster 采用虚拟槽分区方式(16384个虚拟槽)。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要更高的qps(超过 10w/s)&lt;/li&gt;
&lt;li&gt;需要更高的数据量(超过 500G)&lt;/li&gt;
&lt;li&gt;需要更高的带宽(超过 1000M)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;redis-cli -h localhost -p 6382 cluster info&lt;/code&gt;：查看集群基本信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli -h localhost -p 6382 cluster slots&lt;/code&gt;：查看集群slot信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli -h localhost -p 6382 cluster nodes&lt;/code&gt;：查看集群node信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli -c&lt;/code&gt;：move自动跳转执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yum install -y redis-trib&lt;/code&gt;：官方提供了基于 ruby 的工具方便部署&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;搭建 Cluster 过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置&lt;br/&gt;&lt;code&gt;cluster-enabled:yes&lt;/code&gt;&lt;br/&gt;&lt;code&gt;cluster-node-timeout 15000&lt;/code&gt;&lt;br/&gt;&lt;code&gt;cluster-require-full-coverage no&lt;/code&gt;&lt;br/&gt;&lt;code&gt;cluster-config-file node-${port}.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;meet&lt;br/&gt;&lt;code&gt;redis-cli cluster meet ip port&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分配槽(0-16383)&lt;br/&gt;&lt;code&gt;redis-cli cluster addslots {0....5461}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分配主从(node-id)&lt;br/&gt;&lt;code&gt;redis-cli cluster replicate {nodeid}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;redis-cli 搭建：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;echo &quot;停止当前所有redis-server + redis-sentinel&quot;;
mkdir /etc/redis
ps -x | grep redis | grep -v grep | awk '{print $1}' | xargs -r kill
sleep 1
echo &quot;启动6个 redis + meet&quot;;
for port in 7000 7001 7002 7003 7004 7005;do
echo -e &quot;daemonize yes\nport $port\npidfile /var/run/redis-$port.pid\nlogfile /var/log/redis/redis-$port.log\ncluster-enabled yes\ncluster-config-file nodes-$port.conf\ncluster-require-full-coverage no&quot; &amp;gt; /etc/redis/redis-$port.conf
redis-server /etc/redis/redis-$port.conf
done

for port in 7000 7001 7002 7003 7004 7005;do
    redis-cli -p $port FLUSHALL
    redis-cli -p $port cluster reset soft
    if [ $port != 7000 ];then
        redis-cli -p 7000 cluster meet 127.0.0.1 $port
    fi
done
sleep 1

echo &quot;分配 16383 槽&quot;;
redis-cli -p 7000 cluster addslots {0..5461}
redis-cli -p 7001 cluster addslots {5462..10922}
redis-cli -p 7002 cluster addslots {10922..16383}

echo &quot;配置 replication&quot;
redis-cli -p 7003 cluster replicate `redis-cli -p 7000 cluster nodes | grep myself | awk '{print $1}'`
redis-cli -p 7004 cluster replicate `redis-cli -p 7001 cluster nodes | grep myself | awk '{print $1}'`
redis-cli -p 7005 cluster replicate `redis-cli -p 7002 cluster nodes | grep myself | awk '{print $1}'`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;redis-trib搭建：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备节点&lt;/li&gt;
&lt;li&gt;使用redis-trib搭建&lt;br/&gt;&lt;code&gt;redis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;redis-trib create 会自动meet、addslots、replicate。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;查看去除注释的配置：&lt;code&gt;cat /etc/redis.conf | grep -v '^#' | grep -v '^$'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置配置：&lt;code&gt;config set key value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查询所有配置：&lt;code&gt;config get *&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础配置&quot;&gt;基础配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;daemonize&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes(docker环境例外)&lt;/td&gt;
&lt;td&gt;是否以守护进程方式启动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;6379&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;redis服务监听端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pidfile&lt;/td&gt;
&lt;td&gt;/var/run/redis.pid&lt;/td&gt;
&lt;td&gt;/var/run/redis-{port}.pid&lt;/td&gt;
&lt;td&gt;pid文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;logfile&lt;/td&gt;
&lt;td&gt;/var/log/redis/redis.log&lt;/td&gt;
&lt;td&gt;/var/log/redis/redis-{port}.log&lt;/td&gt;
&lt;td&gt;日志文件名：redis工作时产生的日志。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dir&lt;/td&gt;
&lt;td&gt;/var/lib/redis&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;rdb文件和aof文件目录。推荐使用大文件目录。(不指定则为当前目录)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;protected-mode&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;限制为127.0.0.1访问。启用条件：没有bindIP 和 没有设置密码&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;rdb配置&quot;&gt;RDB配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dbfilename&lt;/td&gt;
&lt;td&gt;dump.rdb&lt;/td&gt;
&lt;td&gt;dump-{port}.rdb&lt;/td&gt;
&lt;td&gt;rdb文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;rdbcompression&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;压缩格式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;stop-writes-on-bgsave-error&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;出现错误时，停止新的写入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;rdbchecksum&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;数据完整性校验&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;aof配置&quot;&gt;AOF配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;appendonly&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;是否开启 aof 模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;appendfilename&lt;/td&gt;
&lt;td&gt;&quot;appendonly.aof&quot;&lt;/td&gt;
&lt;td&gt;&quot;appendonly-{port}.aof&quot;&lt;/td&gt;
&lt;td&gt;aof文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;appendfsync&lt;/td&gt;
&lt;td&gt;everysec&lt;/td&gt;
&lt;td&gt;everysec&lt;/td&gt;
&lt;td&gt;fsync方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;no-appendfsync-on-rewrite&lt;/td&gt;
&lt;td&gt;no(安全)&lt;/td&gt;
&lt;td&gt;yes(高性能)&lt;/td&gt;
&lt;td&gt;在 aof 重写时，是否停止fsync&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;auto-aof-rewrite-min-size&lt;/td&gt;
&lt;td&gt;64mb&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;aof文件重写的最小大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;auto-aof-rewrite-percentage&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;aof文件增长率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aof-load-truncated&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;当 aof 文件不完整的时候，将完整的部分加载&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;主从复制配置&quot;&gt;主从复制配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;slowlog-max-len&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;慢查询队列长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;slowlog-log-slow-than&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;1000(qps1w)&lt;/td&gt;
&lt;td&gt;慢查询阈值(单位：微秒)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;slaveof&lt;/td&gt;
&lt;td&gt;ip port&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;主从复制配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;slave-read-only&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;从节点只读&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;repl-backlog-size&lt;/td&gt;
&lt;td&gt;1048576&lt;/td&gt;
&lt;td&gt;10M&lt;/td&gt;
&lt;td&gt;复制缓存区，可以再原有基础上稍微增加&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;sentinel配置&quot;&gt;Sentinel配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;daemonize&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;是否以守护进程方式启动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;26379&lt;/td&gt;
&lt;td&gt;{port}&lt;/td&gt;
&lt;td&gt;sentinel监听端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dir&lt;/td&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;工作目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;sentinel monitor&lt;/td&gt;
&lt;td&gt;mymaster 127.0.0.1 6379 2&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;odown(objectively down,客观下线)规则：masterName ip port quorum&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;sentinel down-after-milliseconds&lt;/td&gt;
&lt;td&gt;mymaster 30000&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;sdown(subjectively down,主观下线)规则：masterName timeout(单位：毫秒)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;sentinel parallel-syncs&lt;/td&gt;
&lt;td&gt;mymaster 1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;并发同步数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sentinel failover-timeout&lt;/td&gt;
&lt;td&gt;mymaster 180000&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;多长时间内不再故障转移(单位：毫秒)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;logfile&lt;/td&gt;
&lt;td&gt;/var/log/redis/sentinel.log&lt;/td&gt;
&lt;td&gt;/var/log/redis/sentinel-{port}.log&lt;/td&gt;
&lt;td&gt;日志文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;cluster配置&quot;&gt;Cluster配置&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;cluster-enabled&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;开启cluster模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cluster-node-timeout&lt;/td&gt;
&lt;td&gt;15000&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;故障转移时间，主观下线超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;cluster-config-file&lt;/td&gt;
&lt;td&gt;nodes-{port}.conf&lt;/td&gt;
&lt;td&gt;cluster配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cluster-require-full-coverage&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;cluster 所有节点全部在线才提供服务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;h3 id=&quot;redis是单线程吗为什么这么快&quot;&gt;redis是单线程吗？为什么这么快？&lt;/h3&gt;
&lt;p&gt;redis其实不是单线程(fsync,bgsave)，一次只能执行一条命令。&lt;/p&gt;
&lt;h3 id=&quot;慢查询&quot;&gt;慢查询&lt;/h3&gt;
&lt;p&gt;查询慢查询队列：&lt;code&gt;slowlog get&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;客户端请求的生命周期：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;排队&lt;/li&gt;
&lt;li&gt;执行命令&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;慢查询发送在第三个阶段(执行命令),客户端超时不一定是慢查询。&lt;/p&gt;
&lt;h3 id=&quot;fork&quot;&gt;fork&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;fork本身是同步操作&lt;/li&gt;
&lt;li&gt;内存越大耗时越长&lt;/li&gt;
&lt;li&gt;info:latest_fork_usec&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;规避全量复制&quot;&gt;规避全量复制&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首次全量复制：不可避免&lt;/li&gt;
&lt;li&gt;runid 不匹配：故障转移&lt;/li&gt;
&lt;li&gt;复制缓冲区不足：配置&lt;code&gt;repl_backlog_size&lt;/code&gt;调整大&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;KEYS pattern ：查询keys&lt;/li&gt;
&lt;li&gt;DBSIZE ：查询所有键的数量&lt;/li&gt;
&lt;li&gt;EXISTS key ：查询指定key是否存在&lt;/li&gt;
&lt;li&gt;TYPE key ：查询key的类型&lt;/li&gt;
&lt;li&gt;DEL key ：删除指定key&lt;/li&gt;
&lt;li&gt;INFO ：查看server 信息如：INFO memory&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;INFO 信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;used_memory redis 当前使用的内存总量&lt;/li&gt;
&lt;li&gt;used_memory_rss redis 当前使用的内存总量(包含内存碎片)&lt;/li&gt;
&lt;li&gt;used_memory_peak redis 使用的内存总量峰值&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 29 Aug 2018 07:16:00 +0000</pubDate>
<dc:creator>Never、C</dc:creator>
<og:description>目录 简介 持久化 主从复制 高可用 Redis Sentinel .NET Core开发 分布式 Redis Cluster 配置说明 常见问题 简介 本节内容基于 CentOS 7.4.1708，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neverc/p/9554498.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离【 .NET Core2.0 +Vue2.0 】框架之十一 || AOP自定义筛选，Redis入门 11.1 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9554210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9554210.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;先说下一个窝心的问题，求大神帮忙，如何在Task异步编程中，使用Redis存、取Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;泛型，&lt;strong&gt;有偿帮助&lt;/strong&gt;，这里谢谢，文末有详细问题说明，可以留言或者私信都可以。&lt;/p&gt;
&lt;p&gt;当然我也会一直思考，大家持续关注本帖，如果我想到好办法，会及时更新，并通知大家。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　书说上文《&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9547574.html&quot; target=&quot;_blank&quot;&gt;从壹开始前后端分离【 .NET Core2.0 Api + Vue 2.0 + AOP + 分布式】框架之十 || AOP面向切面编程浅解析：简单日志记录 + 服务切面缓存&lt;/a&gt;》，昨天咱们说到了AOP面向切面编程，简单的举出了两个栗子，不知道大家有什么想法呢，不知道是否与传统的缓存的使用有做对比了么？&lt;/p&gt;
&lt;p&gt;　　传统的缓存是在Controller中，将获取到的数据手动处理，然后当另一个controller中又使用的时候，还是Get，Set相关操作，当然如果小项目，有两三个缓存还好，如果是特别多的接口调用，面向Service服务层还是很有必要的，不需要额外写多余代码，只需要正常调取Service层的接口就行，AOP结合Autofac注入，会自动的查找，然后返回数据，不继续往下走Repository仓储了。&lt;/p&gt;
&lt;p&gt;　　昨天我发布文章后，有一个网友提除了一个问题，他想的很好，就是如果面向到了Service层，那BaseService中的CURD等基本方法都被注入了，这样会造成太多的代理类，不仅没有必要，甚至还有问题，比如把Update也缓存了，这个就不是很好了，嗯，我也发现了这个问题，所以需要给AOP增加验证特性，只针对Service服务层中特定的常使用的方法数据进行缓存等。这样既能保证切面缓存的高效性，又能手动控制，不知道大家有没有其他的好办法，如果有的话，欢迎留言，或者加群咱们一起讨论，一起解决平时的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829125953789-1789100216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1、在解决方案中添加新项目Blog.Core.Common，然后在该Common类库中添加 特性文件夹 和 特性实体类，以后特性就在这里&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;//CachingAttribute&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这个Attribute就是使用时候的验证，把它添加到要缓存数据的方法中，即可完成缓存的操作。注意是对Method验证有效
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [AttributeUsage(AttributeTargets.Method, Inherited = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CachingAttribute : Attribute
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存绝对过期时间&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AbsoluteExpiration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、添加Common程序集引用，然后修改缓存AOP类方法 BlogCacheAOP=》Intercept，简单对方法的方法进行判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;//qCachingAttribute 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Intercept方法是拦截的关键所在，也是IInterceptor接口中的唯一定义&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Intercept(IInvocation invocation)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method = invocation.MethodInvocationTarget ??&lt;span&gt; invocation.Method;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对当前方法的特性验证&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; qCachingAttribute = method.GetCustomAttributes(&lt;span&gt;true&lt;/span&gt;).FirstOrDefault(x =&amp;gt; x.GetType() == &lt;span&gt;typeof&lt;/span&gt;(CachingAttribute)) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CachingAttribute;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (qCachingAttribute != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取自定义缓存键&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; cacheKey =&lt;span&gt; CustomCacheKey(invocation);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据key获取相应的缓存值&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; cacheValue =&lt;span&gt; _cache.Get(cacheKey);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cacheValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前获取到的缓存值，赋值给当前执行方法&lt;/span&gt;
                    invocation.ReturnValue =&lt;span&gt; cacheValue;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去执行当前的方法&lt;/span&gt;
&lt;span&gt;                invocation.Proceed();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入缓存&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(cacheKey))
                {
                    _cache.Set(cacheKey, invocation.ReturnValue);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                invocation.Proceed();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接执行被拦截方法&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见在&lt;strong&gt;invocation&lt;/strong&gt;参数中，包含了几乎所有的方法，大家可以深入研究下，获取到自己需要的数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、在制定的Service层中的某些类的某些方法上增加特性（一定是方法，不懂的可以看定义特性的时候AttributeTargets.Method）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  　　　 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取博客列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        [Caching(AbsoluteExpiration = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)]//增加特性
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;BlogArticle&amp;gt;&amp;gt;&lt;span&gt; getBlogs()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bloglist = &lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID &amp;gt; &lt;span&gt;0&lt;/span&gt;, a =&amp;gt;&lt;span&gt; a.bID);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bloglist;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、运行项目，打断点，就可以看到，普通的Query或者CURD等都不继续缓存了，只有咱们特定的 getBlogs()方法，带有缓存特性的才可以&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829132646167-1784225478.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、当然，这里还有一个小问题，就是所有的方法还是走的切面，只是增加了过滤验证，大家也可以直接把那些需要的注入，不需要的干脆不注入容器，我之所以需要都经过的目的，就是想把它和日志结合，用来记录Service层的每一个请求，包括CURD的调用情况。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;　　我个人有一个理解，关于Session或Cache等，在普通单服务器的项目中，很简单，有自己的生命周期等，想获取Session就获取，想拿啥就拿傻，但是在大型的分布式集群中，有可能这一秒的点击的页面和下一秒的都不在一个服务器上，对不对！想想如果普通的办法，怎么保证session的一致性，怎么获取相同的缓存数据，怎么有效的进行消息队列传递？&lt;/p&gt;
&lt;p&gt;　　这个时候就用到了Redis，这些内容，网上已经到处都是，但是还是做下记录吧&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。它内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/p&gt;
&lt;p&gt;也就是说，缓存服务器如果意外重启了，数据还都在，嗯！这就是它的强大之处，不仅在内存高吞吐，还能持久化。&lt;/p&gt;
&lt;p&gt;Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。&lt;/p&gt;
&lt;p&gt;Redis也是可以做为消息队列的，与之相同功能比较优秀的就是Kafka&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis还是有自身的缺点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Redis只能存储key/value类型，虽然value的类型可以有多种，但是对于关联性的记录查询，没有Sqlserver、Oracle、Mysql等关系数据库方便。&lt;br/&gt;Redis内存数据写入硬盘有一定的时间间隔，在这个间隔内数据可能会丢失，虽然后续会介绍各种模式来保证数据丢失的可能性，但是依然会有可能，所以对数据有严格要求的不建议使用Redis做为数据库。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1.下载最新版redis，选择.msi安装版本，或者.zip免安装&lt;/strong&gt; （我这里是.msi安装）&lt;/p&gt;
&lt;blockquote readability=&quot;1.1538461538462&quot;&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/MicrosoftArchive/redis/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/MicrosoftArchive/redis/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829133549751-1391645421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2.双击执行.msi文件，一路next，中间有一个需要注册服务，因为如果不注册的话，把启动的Dos窗口关闭的话，Redis就中断连接了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829133853665-335325859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.如果你是免安装的，需要执行以下语句&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;启动命令：redis-server.exe redis.windows.conf&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注册服务命令：redis-server.exe --service-install redis.windows.conf&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;去服务列表查询服务，可以看到redis服务默认没有开启，开启redis服务（可以设置为开机自动启动）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829134123112-873392173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果你对.net 获取app.config或者web.config得心应手的话，在.net core中就稍显吃力，因为不支持直接对Configuration的操作&lt;/p&gt;
&lt;p&gt;前几篇文章中有一个网友说了这样的方法，在Starup.cs中的ConfigureServices方法中，添加&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Blog.Core.Repository.BaseDBConfig.ConnectionString = Configuration.GetSection(&quot;AppSettings:SqlServerConnection&quot;).Value;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然这是可行的，只不过，如果配置的数据很多，比如这样的，那就不好写了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IncludeScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户配置信息&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSettings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Redis缓存&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCaching&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库配置&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServerConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server=.;Database=WMBlogDB;User ID=sa;Password=123;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProviderName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Data.SqlClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-08-28&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，我受到他的启发，简单做了下处理，大家看看是否可行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0、将上面代码添加到appsettings.json文件中&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、在Blog.Core.Common类库中，新建Helper文件夹，新建Appsettings.cs操作类，然后引用 Microsoft.Extensions.Configuration.Json 的Nuget包&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; appsettings.json操作类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Appsettings
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Appsettings()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReloadOnChange = true 当appsettings.json被修改时重新加载&lt;/span&gt;
            Configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; JsonConfigurationSource { Path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ReloadOnChange = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; })
            .Build();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 封装要操作的字符
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sections&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; app(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] sections)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sections.Length; i++&lt;span&gt;)
                {
                    val &lt;/span&gt;+= sections[i] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Configuration[val.TrimEnd(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)];
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            }

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、如何使用呢，直接引用类库，传递想要的参数就行&lt;/strong&gt;（这里对参数是有顺序要求的，这个顺序就是json文件中的层级）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取博客列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetBlogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;BlogArticle&amp;gt;&amp;gt;&lt;span&gt; GetBlogs()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connect=Appsettings.app(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSettings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCaching&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照层级的顺序，依次写出来&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; blogArticleServices.getBlogs();
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、注意：！！把appsettings.json文件添加到bin生成文件中！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果直接运行，会报错，提示没有权限，&lt;/p&gt;
&lt;p&gt;操作：右键appsettings.json =》 属性 =》 Advanced =》 复制到输出文件夹 =》 永远复制 =》应用，保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829140307260-1038230774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、这个时候运行项目，就可以看到结果了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829140522317-279558508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1、在Blog.Core.Common的Helper文件夹中，添加SerializeHelper.cs 对象序列化操作，以后再扩展&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SerializeHelper
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 序列化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;item&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Serialize(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; item)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jsonString =&lt;span&gt; JsonConvert.SerializeObject(item);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetBytes(jsonString);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 反序列化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TEntity Deserialize&amp;lt;TEntity&amp;gt;(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(TEntity);
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jsonString =&lt;span&gt; Encoding.UTF8.GetString(value);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;TEntity&amp;gt;&lt;span&gt;(jsonString);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、在Blog.Core.Common类库中，新建Redis文件夹，并新建IRedisCacheManager接口和RedisCacheManager类，并引用Nuget包StackExchange.Redis&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRedisCacheManager
    {
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        TEntity Get&amp;lt;TEntity&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, TimeSpan cacheTime);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否存在&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Clear();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为在开发的过程中，通过ConnectionMultiplexer频繁的连接关闭服务，是很占内存资源的，所以我们使用单例模式来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCacheManager : IRedisCacheManager
    {
       
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; redisConnenctionString;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; ConnectionMultiplexer redisConnection;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; redisConnectionLock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisCacheManager()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; redisConfiguration = Appsettings.app(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSettings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCaching&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取连接字符串&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(redisConfiguration))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis config is empty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(redisConfiguration));
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisConnenctionString =&lt;span&gt; redisConfiguration;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisConnection =&lt;span&gt; GetRedisConnection();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 核心代码，获取连接实例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过双if 夹lock的方式，实现单例模式
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ConnectionMultiplexer GetRedisConnection()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经连接实例，直接返回&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.redisConnection != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redisConnection.IsConnected)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redisConnection;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁，防止异步编程中，出现单例无效的问题&lt;/span&gt;
            &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (redisConnectionLock)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.redisConnection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放redis连接&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redisConnection.Dispose();
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisConnection =&lt;span&gt; ConnectionMultiplexer.Connect(redisConnenctionString);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redisConnection;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清除
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Clear()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; endPoint &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetRedisConnection().GetEndPoints())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetRedisConnection().GetServer(endPoint);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; server.Keys())
                {
                    redisConnection.GetDatabase().KeyDelete(key);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 判断是否存在
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisConnection.GetDatabase().KeyExists(key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; TEntity Get&amp;lt;TEntity&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; redisConnection.GetDatabase().StringGet(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (value.HasValue)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要用的反序列化，将Redis存储的Byte[]，进行反序列化&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; SerializeHelper.Deserialize&amp;lt;TEntity&amp;gt;&lt;span&gt;(value);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(TEntity);
            }
        }
     
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            redisConnection.GetDatabase().KeyDelete(key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cacheTime&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, TimeSpan cacheTime)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化，将object值生成RedisValue&lt;/span&gt;
&lt;span&gt;                redisConnection.GetDatabase().StringSet(key, SerializeHelper.Serialize(value), cacheTime);
            }
        }


        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码还是很简单的，网上都有很多资源，就是普通的添加，获取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、将redis接口和类 在ConfigureServices中 进行注入，（注意是构造函数注入）然后在controller中添加代码测试&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;services.AddScoped&amp;lt;IRedisCacheManager, RedisCacheManager&amp;gt;();&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        IAdvertisementServices advertisementServices;
        IBlogArticleServices blogArticleServices;
        IRedisCacheManager redisCacheManager;//Reids缓存

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;advertisementServices&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;blogArticleServices&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;redisCacheManager&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BlogController(IAdvertisementServices advertisementServices, IBlogArticleServices blogArticleServices, IRedisCacheManager redisCacheManager)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.advertisementServices =&lt;span&gt; advertisementServices;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.blogArticleServices =&lt;span&gt; blogArticleServices;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisCacheManager =&lt;span&gt; redisCacheManager;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　　　 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取博客列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetBlogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;BlogArticle&amp;gt;&amp;gt;&lt;span&gt; GetBlogs()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connect=Appsettings.app(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSettings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RedisCaching&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照层级的顺序，依次写出来&lt;/span&gt;
&lt;span&gt;
            List&lt;/span&gt;&amp;lt;BlogArticle&amp;gt; blogArticleList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;BlogArticle&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (redisCacheManager.Get&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis.Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                blogArticleList &lt;/span&gt;= redisCacheManager.Get&amp;lt;List&amp;lt;BlogArticle&amp;gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis.Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                blogArticleList &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; blogArticleServices..Query(d =&amp;gt; d.bID &amp;gt; 5);
                redisCacheManager.Set(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis.Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, blogArticleList, TimeSpan.FromHours(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; blogArticleList;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829143341284-303805261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、运行，执行Redis缓存，看到结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180829143610110-1913281780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 今天的讲解就到里了，是不是有一种草草收场的感觉，是的！本来后来应该最后一节。细心的你应该发现了，我们是在controller进行测试，Redis缓存的是List泛型，但是呢，AOP切面缓存还是基于内存缓存，昨天我本想合并下，奈何AOP切面是通过异步编程，获取到的Task的List泛型，在Redis中需要序列化，鄙人表示不是很懂，希望看到的大神帮忙解决下，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如何把异步返回的Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;结果，缓存到Redis，并能通过泛型取出来，有偿服务。感谢！&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt; &lt;a href=&quot;https://github.com/anjoy8/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/Blog.Core&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 06:45:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>大神留步 先说下一个窝心的问题，求大神帮忙，如何在Task异步编程中，使用Redis存、取Task&lt;List&lt;T&gt;&gt;泛型，有偿帮助，这里谢谢，文末有详细问题说明，可以留言或者私</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9554210.html</dc:identifier>
</item>
<item>
<title>MySQL InnoDB配置统计信息 - DB-Engineer</title>
<link>http://www.cnblogs.com/wanbin/p/9554091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanbin/p/9554091.html</guid>
<description>
&lt;p&gt;本文档介绍如何为InnoDB表配置持久性和非持久性统计信息。&lt;/p&gt;
&lt;p&gt;持久化统计信息在服务器重新启动时保持不变，从而使执行计划和查询性能更加稳定。持久化统计信息还提供了控制和灵活性以及这些额外的好处：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以使用&lt;span&gt;&lt;code&gt;innodb_stats_auto_recalc&lt;/code&gt;&lt;/span&gt;配置选项来控制在对表进行实质性更改后是否自动更新统计信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以将&lt;span&gt;&lt;code&gt;STATS_PERSISTENT&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;STATS_AUTO_RECALC&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;STATS_SAMPLE_PAGES&lt;/code&gt;&lt;/span&gt;子句与&lt;span&gt;CREATE TABLE&lt;/span&gt;和&lt;span&gt;ALTER TABLE&lt;/span&gt;语句一起使用，以配置各个表的优化程序统计信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以在&lt;span&gt;&lt;code&gt;mysql.innodb_table_stats&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;mysql.innodb_index_stats&lt;/code&gt;&lt;/span&gt;表中查询优化程序统计信息数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以查看&lt;span&gt;&lt;code&gt;mysql.innodb_table_stats&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;mysql.innodb_index_stats&lt;/code&gt;&lt;/span&gt;表的&lt;span&gt;last_update&lt;/span&gt;列，以查看最后一次更新统计信息的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在不需要修改数据库的情况下，可以手动修改&lt;span&gt;&lt;code&gt;mysql.innodb_table_stats&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;mysql.innodb_index_stats&lt;/code&gt;&lt;/span&gt;表，以强制执行特定的执行计划或测试备用执行计划。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;默认情况下启用持久优化程序统计信息功能&lt;span&gt;&lt;code&gt;innodb_stats_persistent = ON&lt;/code&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;非持久化统计信息在每次重新启动服务器和其他一些操作后清除，并在下一个表访问时重新计算。因此，在重新计算统计数据时可能会产生不同的估计值，从而导致执行计划中的不同选择和查询性能的变化。&lt;/p&gt;
&lt;p&gt;本文档还提供了有关估计&lt;code&gt;ANALYZE TABLE&lt;/code&gt;复杂性的信息，这在尝试实现精确统计信息和ANALYZE TABLE执行时间之间的平衡时可能很有用。&lt;/p&gt;
&lt;h2 id=&quot;wow0&quot;&gt;1. 配置持久化（Persistent）统计信息参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_persistent&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：是否启用持久化统计信息功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：ON&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;持久化统计信息功能通过将统计信息存储到磁盘并使其在服务器重新启动期间保持不变来提高执行计划的稳定性，以便优化器更有可能每次为给定查询做出一致的选择。&lt;/p&gt;
&lt;p&gt;当&lt;span&gt;&lt;code&gt;innodb_stats_persistent = ON&lt;/code&gt;&lt;/span&gt;或使用&lt;span&gt;&lt;code&gt;STATS_PERSISTENT = 1&lt;/code&gt;&lt;/span&gt;创建或更改单个表时，统计信息将持久保存到磁盘。&lt;span&gt;&lt;code&gt;innodb_stats_persistent&lt;/code&gt;&lt;/span&gt;默认启用。&lt;/p&gt;
&lt;p&gt;要恢复使用非持久化统计信息，可以使用&lt;span&gt;&lt;code&gt;ALTER TABLE tbl_name STATS_PERSISTENT = 0&lt;/code&gt;&lt;/span&gt;语句修改表。&lt;/p&gt;
&lt;h3 id=&quot;wow1&quot;&gt;1.1 配置自动触发更新统计信息参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_auto_recalc&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：是否自动触发更新统计信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;触发阈值&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;表修改时，确认变化的数据是否超过10%，超过自动收集统计信息&lt;/li&gt;
&lt;li&gt;表，索引统计信息是持久化存储&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：ON&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于自动统计信息重新计算（发生在后台）是异步，在运行影响超过&lt;span&gt;10％&lt;/span&gt;的表的DML操作时（即使&lt;span&gt;&lt;code&gt;innodb_stats_auto_recalc&lt;/code&gt;&lt;/span&gt;启用后），可能不会立即重新计算统计信息 。在某些情况下，统计重新计算可能会延迟几秒钟(&lt;span&gt;10s&lt;/span&gt;)。如果在更改表的重要部分之后立即需要最新统计信息，请运行ANALYZE TABLE以启动统计信息的同步（前台）重新计算。&lt;/p&gt;
&lt;p&gt;如果禁用了&lt;span&gt;&lt;code&gt;innodb_stats_auto_recalc&lt;/code&gt;&lt;/span&gt;，请在对索引列进行实质性更改后，通过为每个适用的表发出&lt;span&gt;&lt;code&gt;ANALYZE TABLE&lt;/code&gt;&lt;/span&gt;语句来确保统计信息的准确性。&lt;/p&gt;
&lt;p&gt;在表上添加索引或者添加删除索引中的列时，将自动计算索引统计信息并将其添加到&lt;span&gt;innodb_index_stats&lt;/span&gt;表，不受&lt;span&gt;innodb_stats_auto_recalc&lt;/span&gt;的值影响。&lt;/p&gt;
&lt;h3 id=&quot;wow2&quot;&gt;1.2 配置每张表的统计参数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;innodb_stats_persistent&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;innodb_stats_auto_recalc&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;innodb_stats_persistent_sample_pages&lt;/code&gt;&lt;/span&gt;是全局配置选项。&lt;/p&gt;
&lt;p&gt;若要覆盖这些系统范围的设置并为各个表配置统计信息参数，可以在&lt;span&gt;&lt;code&gt;CREATE TABLE&lt;/code&gt;或&lt;code&gt;ALTER TABLE&lt;/code&gt;语句中定义&lt;code&gt;STATS_PERSISTENT&lt;/code&gt;，&lt;code&gt;STATS_AUTO_RECALC&lt;/code&gt;和&lt;code&gt;STATS_SAMPLE_PAGES&lt;/code&gt;&lt;/span&gt;子句。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;STATS_PERSISTENT&lt;/strong&gt;&lt;br/&gt;指定是否为InnoDB表启用持久统计信息。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt;：表示表的持久统计信息设置由&lt;span&gt;&lt;code&gt;innodb_stats_persistent&lt;/code&gt;&lt;/span&gt;配置选项确定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt;：表示启用表的持久统计信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0&lt;/strong&gt;：关闭此功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;STATS_AUTO_RECALC&lt;/strong&gt;&lt;br/&gt;指定是否自动重新计算InnoDB表的持久统计信息。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt;：表示表的持久统计信息设置由&lt;span&gt;innodb_stats_auto_recalc&lt;/span&gt;配置选项确定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt;：表示表中10％的数据发生更改时将重新计算统计信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0&lt;/strong&gt;：禁用自动重新计算此表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;STATS_SAMPLE_PAGES&lt;/strong&gt;&lt;br/&gt;指定在估计索引列的基数和其他统计信息时要采样的索引页数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t1` (
`id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; auto_increment,
`data` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;&lt;span&gt;),
`date` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;  (`id`),
&lt;/span&gt;&lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt; `DATE_IX` (`date`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;InnoDB,
  STATS_PERSISTENT&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  STATS_AUTO_RECALC&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  STATS_SAMPLE_PAGES&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;wow3&quot;&gt;1.3 配置InnoDB优化器统计信息的采样页数参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_persistent_sample_pages&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：配置持久化统计信息采样的页数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：20&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在什么情况下需要修改此参数呢：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;统计信息不够准确，优化器选择次优计划&lt;/strong&gt;&lt;br/&gt;如果确定统计信息不够准确，则应增加&lt;span&gt;&lt;code&gt;innodb_stats_persistent_sample_pages&lt;/code&gt;&lt;/span&gt;的值，直到统计估计值足够准确。但是，过多地增加&lt;span&gt;innodb_stats_persistent_sample_pages&lt;/span&gt;可能会导致&lt;span&gt;ANALYZE TABLE&lt;/span&gt;运行缓慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ANALYZE TABLE太慢&lt;/strong&gt;&lt;br/&gt;在这种情况下，应减少&lt;span&gt;innodb_stats_persistent_sample_pages&lt;/span&gt;，直到&lt;span&gt;ANALYZE TABLE&lt;/span&gt;执行时间可以接受。但是，过多地降低该值可能会导致生成不准确的统计信息和次优查询执行计划的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow4&quot;&gt;1.4 包含&lt;code&gt;Delete-marked&lt;/code&gt;的记录参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_include_delete_marked&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：在MySQL 5.7.16中引入的此参数，默认为不启用，表示在未提交的事务有&lt;code&gt;从表中删除行&lt;/code&gt;，则InnoDB在收集统计信息时，将会排除这些&lt;code&gt;delete_marked&lt;/code&gt;行。这可能会导致除&lt;code&gt;READ UNCOMMITTED&lt;/code&gt;之外的事务隔离级别的事务，运行的不是最佳的执行计划。&lt;br/&gt;为了避免这种情况，可以启用&lt;span&gt;&lt;code&gt;innodb_stats_include_delete_marked&lt;/code&gt;&lt;/span&gt;以确保在计算持久化统计信息时InnoDB包含&lt;code&gt;Delete-marked&lt;/code&gt;记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：OFF&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow5&quot;&gt;1.5 InnoDB持久化统计表&lt;/h3&gt;
&lt;p&gt;持久化统计信息功能依赖于mysql数据库中的内部表，名为&lt;span&gt;&lt;code&gt;innodb_table_stats&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;innodb_index_stats&lt;/code&gt;&lt;/span&gt;。&lt;br/&gt;这些表在所有安装，升级和源代码构建过程中自动设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysql.innodb_table_stats&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+---------------------+------+-----+-------------------+-----------------------------+--------------------------&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Field                    &lt;span&gt;|&lt;/span&gt; Type                &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Null&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Key&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Default&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt; Extra                       &lt;span&gt;|&lt;/span&gt;&lt;span&gt;注释                      
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+---------------------+------+-----+-------------------+-----------------------------+--------------------------&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; database_name            &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)         &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt;数据库名称                
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; table_name               &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;199&lt;/span&gt;)        &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt;表名，分区名或子分区名    
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; last_update              &lt;span&gt;|&lt;/span&gt; &lt;span&gt;timestamp&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt;最后一次更新统计信息时间  
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; n_rows                   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) unsigned &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt;表中的行数                
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; clustered_index_size     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) unsigned &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt;主键索引大小（单位page）  
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; sum_of_other_index_sizes &lt;span&gt;|&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) unsigned &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt;其他索引总大小（单位page）
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------+---------------------+------+-----+-------------------+-----------------------------+--------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;mysql.innodb_index_stats&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+---------------------+------+-----+-------------------+-----------------------------+----------------------------&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; Field            &lt;span&gt;|&lt;/span&gt; Type                &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Null&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Key&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Default&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt; Extra                       &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 注释                       
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+---------------------+------+-----+-------------------+-----------------------------+----------------------------&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; database_name    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)         &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 数据库名称                           
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; table_name       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;199&lt;/span&gt;)        &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 表名，分区名或子分区名                          
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; index_name       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)         &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 索引名称                         
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; last_update      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;timestamp&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 最后一次更新统计信息的时间
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; stat_name        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)         &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt; PRI &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 统计信息的名称，其值在stat_value列中报告                         
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; stat_value       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) unsigned &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 在stat_name列中命名的统计信息的值                         
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; sample_size      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) unsigned &lt;span&gt;|&lt;/span&gt; YES  &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 在stat_value列中提供的估计值的页面采样数                           
&lt;/span&gt;&lt;span&gt;|&lt;/span&gt; stat_description &lt;span&gt;|&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;1024&lt;/span&gt;)       &lt;span&gt;|&lt;/span&gt; NO   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;              &lt;span&gt;|&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt;&lt;span&gt; 在stat_name列中命名的统计信息的描述                           
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------------+---------------------+------+-----+-------------------+-----------------------------+----------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;strong&gt;start_name:&lt;/strong&gt;

        为size时         ：此时stat_value显示索引的page数量。

        为n_leaf_pages时 ：此时stat_value显示叶子节点的数量。

        为n_diff_pfxNN时 ：显示索引字段上唯一值的数量&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;【注意】：&lt;/p&gt;
&lt;p&gt;innodb_table_stats和innodb_index_stats表是普通表，可以手动更新。&lt;br/&gt;如果手动更新统计信息，请发出&lt;code&gt;FLUSH TABLE tbl_name&lt;/code&gt;命令以使MySQL重新加载更新的统计信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;wow6&quot;&gt;1.6 InnoDB持久化统计表示例&lt;/h3&gt;
&lt;p&gt;创建表t1包含主索引（列a，b）二级索引（列c，d）和唯一索引（列e，f）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; t1 (
a &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;, b &lt;span&gt;INT&lt;/span&gt;, c &lt;span&gt;INT&lt;/span&gt;, d &lt;span&gt;INT&lt;/span&gt;, e &lt;span&gt;INT&lt;/span&gt;, f &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (a, b), &lt;span&gt;KEY&lt;/span&gt; i1 (c, d), &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; i2uniq (e, f)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;插入5行数据后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t1 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t1 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;102&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t1 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;103&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t1 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;104&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t1 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;105&lt;/span&gt;&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; t1;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-+---+------+------+------+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; a &lt;span&gt;|&lt;/span&gt; b &lt;span&gt;|&lt;/span&gt; c    &lt;span&gt;|&lt;/span&gt; d    &lt;span&gt;|&lt;/span&gt; e    &lt;span&gt;|&lt;/span&gt; f    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-+---+------+------+------+------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;11&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;100&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;101&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;11&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;200&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;102&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;11&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;100&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;103&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;12&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;200&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;104&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;12&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;100&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;105&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-+---+------+------+------+------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要立即更新统计信息，请运行&lt;code&gt;ANALYZE TABLE&lt;/code&gt;。（如果启用了innodb_stats_auto_recalc，则假定已达到更改的表行的10％阈值，则会在几秒钟内自动更新统计信息）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; ANALYZE &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; t1;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+---------+----------+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; Op      &lt;span&gt;|&lt;/span&gt; Msg_type &lt;span&gt;|&lt;/span&gt; Msg_text &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+---------+----------+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test.t1 &lt;span&gt;|&lt;/span&gt; analyze &lt;span&gt;|&lt;/span&gt; status   &lt;span&gt;|&lt;/span&gt; OK       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+---------+----------+----------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.02&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表最后一次收集统计信息时间为&lt;code&gt;2018-08-29 11:10:03&lt;/code&gt;,表的行数为 5，主键索引大小为 1page，其他索引的总大小为 2 page。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; mysql.innodb_table_stats t &lt;span&gt;where&lt;/span&gt; t.database_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; t.table_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\G
&lt;/span&gt;&lt;span&gt;***************************&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;. row &lt;span&gt;***************************&lt;/span&gt;&lt;span&gt;
           database_name: test
              table_name: t1
             last_update: &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;&lt;span&gt;
                  n_rows: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
    clustered_index_size: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
sum_of_other_index_sizes: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;innodb_index_stats&lt;/code&gt;表包含每个索引的多行。 innodb_index_stats表中的每一行都提供与特定索引统计信息相关的数据，该统计信息在stat_name列中命名并在stat_description列中进行了描述。 例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; mysql.innodb_index_stats t &lt;span&gt;where&lt;/span&gt; t.database_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; t.table_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; database_name &lt;span&gt;|&lt;/span&gt; table_name &lt;span&gt;|&lt;/span&gt; index_name &lt;span&gt;|&lt;/span&gt; last_update         &lt;span&gt;|&lt;/span&gt; stat_name    &lt;span&gt;|&lt;/span&gt; stat_value &lt;span&gt;|&lt;/span&gt; sample_size &lt;span&gt;|&lt;/span&gt; stat_description                  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; a                                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; a,b                               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_leaf_pages &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; leaf pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; size         &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; c                                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; c,d                               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx03 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; c,d,a                             &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx04 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; c,d,a,b                           &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_leaf_pages &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; leaf pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; size         &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i2uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; e                                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i2uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;           &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; e,f                               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i2uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_leaf_pages &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; leaf pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; test          &lt;span&gt;|&lt;/span&gt; t1         &lt;span&gt;|&lt;/span&gt; i2uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; size         &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;        &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; pages &lt;span&gt;in&lt;/span&gt; the &lt;span&gt;index&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;stat_name&lt;/code&gt;列显示以下类型的统计信息&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;span&gt;&lt;strong&gt;&lt;code&gt;stat_name = size&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;，则stat_value列显示索引中的总大小（单位page）。&lt;/li&gt;
&lt;li&gt;如果&lt;span&gt;&lt;strong&gt;&lt;code&gt;stat_name = n_leaf_pages&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;，则stat_value列显示索引中的叶子页数。&lt;/li&gt;
&lt;li&gt;如果&lt;span&gt;&lt;strong&gt;stat_name = n_diff_pfx01&lt;/strong&gt;&lt;/span&gt;，stat_value列显示索引第一列中的不同值的数量。 当 &lt;code&gt;stat_name = n_diff_pfx02&lt;/code&gt;，stat_value列显示索引前两列中的不同值的数量，依此类推。 此外，在stat_name = n_diff_pfxNN的情况下，stat_description列显示了计算的索引列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;进一步说明基数数据的&lt;code&gt;n_diff_pfxNN&lt;/code&gt;统计量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;表t1使用主索引（列a，b），辅助索引（列c，d）和唯一索引（列e，f）。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;对于二级索引（i1），有四个n_diff％行&lt;/strong&gt;&lt;br/&gt;对于二级索引（i1），有四个n_diff％行。 仅为辅助索引（c，d）定义了两列，但是辅助索引有四个n_diff％行，因为InnoDB使用主键为所有非唯一索引添加后缀。&lt;/p&gt;
&lt;ul readability=&quot;17&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i1&lt;/code&gt;和&lt;code&gt;stat_name = n_diff_pfx01&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为1，表示索引的第一列（列c）中存在单个不同的值。通过查看表t1中列c中的数据来确认列c中的不同值的数量，其中存在单个不同的值：（10）。计数列（c）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i1和stat_name = n_diff_pfx02&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为2，表示索引（c，d）的前两列中有两个不同的值。通过查看表t1中列c和d中的数据来确认列c和d中的不同值的数量，其中存在两个不同的值：（10,11）和（10,12）。计数列（c，d）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i1和stat_name = n_diff_pfx03&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为2，表示索引的前三列中有两个不同的值（c，d，a）。通过查看表c1中的列c，d和a中的数据来确认列c，d和a中的不同值的数量，其中有两个不同的值：（10,11,1）和（10， 12,1）。计数列（c，d，a）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i1和stat_name = n_diff_pfx04&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为5，表示索引的四列中有五个不同的值（c，d，a，b）。通过查看表t1中列c，d，a和b中的数据来确认列c，d，a和b中的不同值的数量，其中有五个不同的值：(10,11,1,1)，(10,11,1,2)，(10,11,1,3)，(10,12,1,4)和(10,12,1,5)。计数列（c，d，a，b）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;对于唯一索引（i2uniq），有两个n_diff％行&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i2uniq和stat_name = n_diff_pfx01&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为2，表示索引的第一列中有两个不同的值（列e）。 通过查看表t1中的列e中的数据来确认列e中的不同值的数量，其中存在两个不同的值：（100）和（200）。 计数列（e）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;index_name = i2uniq和stat_name = n_diff_pfx02&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;stat_value为5，表示索引的两列中有五个不同的值（e，f）。 通过查看表t1中的列e和f中的数据来确认列e和f中的不同值的数量，其中存在五个不同的值：（100,101），（200,102），（100,103），（200,104）和（100105）。 计数列（e，f）显示在结果集的stat_description列中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow7&quot;&gt;1.7 使用innodb_index_stats表查询索引大小&lt;/h3&gt;
&lt;p&gt;可以使用innodb_index_stats表查询表，分区或子分区的索引大小，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUM&lt;/span&gt;&lt;span&gt;(stat_value)                      pages,
       index_name,
       &lt;/span&gt;&lt;span&gt;SUM&lt;/span&gt;(stat_value) &lt;span&gt;*&lt;/span&gt; &lt;span&gt;@@innodb_page_size&lt;/span&gt;&lt;span&gt; size
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; mysql.innodb_index_stats
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; database_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; stat_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; index_name;

&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+------------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; pages &lt;span&gt;|&lt;/span&gt; index_name &lt;span&gt;|&lt;/span&gt; size  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+------------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;16384&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; i1         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;16384&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; i2uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;16384&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+------------+-------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于分区或子分区，可以使用修改的WHERE子句的相同查询来查询索引大小。&lt;br/&gt;例如，以下查询检索表t1的分区的索引大小：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUM&lt;/span&gt;&lt;span&gt;(stat_value)                      pages,
       index_name,
       &lt;/span&gt;&lt;span&gt;SUM&lt;/span&gt;(stat_value) &lt;span&gt;*&lt;/span&gt; &lt;span&gt;@@innodb_page_size&lt;/span&gt;&lt;span&gt; size
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; mysql.innodb_index_stats
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; table_name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;t1#P%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; stat_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; index_name;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;wow8&quot;&gt;2. 配置非持久化（Non-Persistent）统计信息参数&lt;/h2&gt;
&lt;p&gt;当&lt;span&gt;&lt;code&gt;innodb_stats_persistent = OFF&lt;/code&gt;&lt;/span&gt;或使用&lt;span&gt;&lt;code&gt;STATS_PERSISTENT = 0&lt;/code&gt;&lt;/span&gt;创建或更改单张表时，统计信息不会保留到磁盘。 相反，统计信息存储在内存中，并在服务器关闭时丢失。 某些业务和某些条件下也会定期更新统计数据。&lt;/p&gt;
&lt;p&gt;从MySQL 5.6.6开始，默认情况下，统计信息会持久保存到磁盘，由&lt;span&gt;&lt;code&gt;innodb_stats_persistent&lt;/code&gt;&lt;/span&gt;配置选项启用。&lt;/p&gt;
&lt;h3 id=&quot;wow9&quot;&gt;2.1 优化器统计信息更新&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_on_metadata&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：表示是否InnoDB在（如&lt;span&gt;SHOW TABLE STATUS&lt;/span&gt;）或访问&lt;span&gt;INFORMATION_SCHEMA.TABLES&lt;/span&gt;或&lt;span&gt;INFORMATION_SCHEMA.STATISTICS&lt;/span&gt;）操作期间更新统计信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：OFF&lt;br/&gt;保留禁用的设置可以提高具有大量表或索引的模式的访问速度。它还可以提高涉及InnoDB表的查询的执行计划的稳定性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果启用此参数，在以下情况下更新非持久化统计信息：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;
&lt;p&gt;运行&lt;span&gt;&lt;code&gt;ANALYZE TABLE&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7.5&quot;&gt;
&lt;p&gt;运行&lt;span&gt;&lt;code&gt;SHOW TABLE STATUS&lt;/code&gt;，&lt;code&gt;SHOW INDEX&lt;/code&gt;&lt;/span&gt;或查询&lt;span&gt;&lt;code&gt;INFORMATION_SCHEMA.TABLES&lt;/code&gt;&lt;/span&gt;或&lt;span&gt;&lt;code&gt;INFORMATION_SCHEMA.STATISTICS&lt;/code&gt;&lt;/span&gt;表并启用&lt;span&gt;&lt;code&gt;innodb_stats_on_metadata&lt;/code&gt;&lt;/span&gt;选项。&lt;/p&gt;
&lt;p&gt;默认情况下，在MySQL 5.6.6中启用持久化统计信息时，&lt;span&gt;&lt;code&gt;innodb_stats_on_metadata&lt;/code&gt;&lt;/span&gt;的默认设置已更改为&lt;code&gt;OFF&lt;/code&gt;。 启用&lt;span&gt;&lt;code&gt;innodb_stats_on_metadata&lt;/code&gt;&lt;/span&gt;可能会降低大表或索引的访问速度，并降低涉及InnoDB表的查询的执行计划的稳定性。 使用SET语句全局配置innodb_stats_on_metadata。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; GLOBAL innodb_stats_on_metadata&lt;span&gt;=&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;【注意】&lt;br/&gt;&lt;strong&gt;innodb_stats_on_metadata&lt;/strong&gt;仅在统计信息配置为非持久化时（禁用innodb_stats_persistent时）适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;默认设置，在mysql客户端启用&lt;span&gt;&lt;code&gt;--auto-rehash&lt;/code&gt;&lt;/span&gt;选项的。 &lt;span&gt;&lt;code&gt;auto-rehash&lt;/code&gt;&lt;/span&gt;选项会导致打开所有InnoDB表，并且open table操作会导致重新计算统计信息。&lt;br/&gt;要改善mysql客户端的启动时间并更新统计信息，可以使用&lt;span&gt;--disable-auto-rehash&lt;/span&gt;选项关闭自动重新连接。 auto-rehash功能可以为交互式用户自动完成数据库，表和列名称的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开一张表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自上次更新统计信息以来，InnoDB检测到表中1/16数据已被修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow10&quot;&gt;2.2 配置采样页数参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;innodb_stats_transient_sample_pages&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数含义&lt;/strong&gt;：表示每次随机采样页的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认值&lt;/strong&gt;：8&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当&lt;span&gt;&lt;code&gt;innodb_stats_persistent = 0&lt;/code&gt;&lt;/span&gt;时，&lt;span&gt;&lt;code&gt;innodb_stats_transient_sample_pages&lt;/code&gt;&lt;/span&gt;的值会影响所有InnoDB表和索引的索引采样。更改索引样本大小时，请注意以下潜在的重大影响：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;像1或2这样的小值可能导致基数估计不准确。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;增加&lt;span&gt;&lt;code&gt;innodb_stats_transient_sample_pages&lt;/code&gt;&lt;/span&gt;值可能需要更多磁盘读取。远大于8（例如，100）的值可能导致打开表或执行SHOW TABLE STATUS所花费的时间显着减慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;优化器可能会根据索引选择性的不同估计选择非常不同的查询计划。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;wow11&quot;&gt;3. Analyze Table复杂性度&lt;/h2&gt;
&lt;p&gt;InnoDB表的ANALYZE TABLE复杂性度决于：&lt;/p&gt;
&lt;p&gt;使用这些参数，估计ANALYZE TABLE复杂性度近似公式为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;innodb_stats_persistent_sample_pages * 表中索引列的数量 * 分区数&lt;/code&gt;&lt;/span&gt;, 通常，结果值越大，ANALYZE InnoDB TABLE的执行时间越长。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;【注意】&lt;br/&gt;&lt;span&gt;&lt;code&gt;innodb_stats_persistent_sample_pages&lt;/code&gt;&lt;/span&gt;定义在全局级别采样的页数。 要设置单个表的采样页数，请使用带有CREATE TABLE或ALTER TABLE的&lt;code&gt;STATS_SAMPLE_PAGES&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;如果&lt;span&gt;&lt;code&gt;innodb_stats_persistent = OFF&lt;/code&gt;&lt;/span&gt;，则采样的页数由&lt;span&gt;&lt;code&gt;innodb_stats_transient_sample_pages&lt;/code&gt;&lt;/span&gt;定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有关估计ANALYZE TABLE复杂性的更深入方法，请考虑以下示例。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;code&gt;Big O&lt;/code&gt;&lt;/a&gt;表示法中，ANALYZE TABLE复杂度描述为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;O(n_sample
  &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; (n_cols_in_uniq_i
     &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; n_cols_in_non_uniq_i
     &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; n_cols_in_pk &lt;span&gt;*&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; n_non_uniq_i))
  &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; n_part)
&lt;/pre&gt;&lt;/div&gt;

&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_sample是采样的页数（由innodb_stats_persistent_sample_pages定义）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_uniq_i是所有唯一索引中所有列的总数（不包括主键列）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_non_uniq_i是所有非唯一索引中所有列的总数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_pk是主键中的列数（如果未定义主键，InnoDB在内部创建单列主键）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_non_uniq_i是表中非唯一索引的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_part是分区数。 如果未定义分区，则该表被视为单个分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，创建下面的表（表t），它有一个主键（2列），一个唯一索引（2列）和两个非唯一索引（每个2列）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; t (
  a &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  b &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  c &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  d &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  e &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  f &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  g &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  h &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (a, b),
  &lt;/span&gt;&lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; i1uniq (c, d),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; i2nonuniq (e, f),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; i3nonuniq (g, h)
);
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; t.index_name,
       t.last_update,
       t.stat_name,
       t.stat_description
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; mysql.innodb_index_stats t
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;     t.database_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
      &lt;span&gt;AND&lt;/span&gt; t.table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
      &lt;span&gt;AND&lt;/span&gt; t.stat_name &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n_diff_pfx%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------+---------------------+--------------+------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; index_name &lt;span&gt;|&lt;/span&gt; last_update         &lt;span&gt;|&lt;/span&gt; stat_name    &lt;span&gt;|&lt;/span&gt; stat_description &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------+---------------------+--------------+------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt; a                &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt; a,b              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i1uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt; c                &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i1uniq     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt; c,d              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i2nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt; e                &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i2nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt; e,f              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i2nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx03 &lt;span&gt;|&lt;/span&gt; e,f,a            &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i2nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx04 &lt;span&gt;|&lt;/span&gt; e,f,a,b          &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i3nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx01 &lt;span&gt;|&lt;/span&gt; g                &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i3nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx02 &lt;span&gt;|&lt;/span&gt; g,h              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i3nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx03 &lt;span&gt;|&lt;/span&gt; g,h,a            &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; i3nonuniq  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;38&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; n_diff_pfx04 &lt;span&gt;|&lt;/span&gt; g,h,a,b          &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------+---------------------+--------------+------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据上面显示的索引统计数据和表定义，可以确定以下值：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_uniq_i，所有唯一索引中不包括主键列的所有列的总数为&lt;code&gt;2&lt;/code&gt;（c和d）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_non_uniq_i，所有非唯一索引中所有列的总数，为&lt;code&gt;4&lt;/code&gt;（e，f，g和h）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_cols_in_pk，主键中的列数为&lt;code&gt;2&lt;/code&gt;（a和b）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_non_uniq_i，表中非唯一索引的数量是&lt;code&gt;2&lt;/code&gt;（i2nonuniq和i3nonuniq））&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;n_part，分区数，是&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据公式计算扫描的叶页数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;O(n_sample
  &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; (n_cols_in_uniq_i
     &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; n_cols_in_non_uniq_i
     &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; n_cols_in_pk &lt;span&gt;*&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; n_non_uniq_i))
  &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; n_part)

innodb_stats_persistent_sample_pages &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;
n_cols_in_uniq_i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
n_cols_in_non_uniq_i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
n_cols_in_pk &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
n_non_uniq_i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
n_part &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
&lt;br/&gt;估计表t读取 &lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; （&lt;span&gt;2&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;（&lt;span&gt;1&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;） &lt;span&gt;*&lt;/span&gt; &lt;span&gt;16384&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; 3932160字节，大约4M。
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 29 Aug 2018 06:29:00 +0000</pubDate>
<dc:creator>DB-Engineer</dc:creator>
<og:description>MySQL InnoDB配置统计信息 1. 配置持久化（Persistent）统计信息参数 1.1 配置自动触发更新统计信息参数 1.2 配置每张表的统计参数 1.3 配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanbin/p/9554091.html</dc:identifier>
</item>
<item>
<title>RestSharp使用说明 - 眼圈黑黑</title>
<link>http://www.cnblogs.com/heiyanquan/p/9554068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heiyanquan/p/9554068.html</guid>
<description>&lt;p&gt;翻译自：https://github.com/restsharp/RestSharp/wiki，转载请注明。&lt;/p&gt;
&lt;h2 id=&quot;一新手入门&quot;&gt;一、新手入门&lt;/h2&gt;
&lt;p&gt;如果只有少量一次性请求需要封装为API，则可以如下使用RestSharp ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using RestSharp;
using RestSharp.Authenticators;

var client = new RestClient();
client.BaseUrl = new Uri(&quot;http://twitter.com&quot;);
client.Authenticator = new HttpBasicAuthenticator(&quot;username&quot;, &quot;password&quot;);

var request = new RestRequest();
request.Resource = &quot;statuses/friends_timeline.xml&quot;;

IRestResponse response = client.Execute(request);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IRestResponse 接口中包含了所有远程服务返回的信息，可以访问头信息（header）数据内容（content）、HTTP状态等。建议使用泛型将返回结果自动反序列化为.NET实体类。&lt;/p&gt;
&lt;p&gt;关于错误处理：&lt;/p&gt;
&lt;p&gt;如果发生了网络传输错误（网络瘫痪，DNS查找失败等），RestResponse.ResponseStatus 将会置为Error ，否则RestResponse.ResponseStatus的值为Completed 。如果API返回404，ResponseStatus 仍然是Completed 。如果需要访问返回的HTTP状态码，则需要查看RestResponse.StatusCode 的值，Status  属性是请求完成的标识，独立于API错误处理。&lt;/p&gt;
&lt;h2 id=&quot;二推荐用法&quot;&gt;二、推荐用法&lt;/h2&gt;
&lt;p&gt;RestSharp适合作为API代理类实现的基础，下面是 Twilio类库中的一些使用示例：&lt;/p&gt;
&lt;p&gt;创建一个包含API代理实现的类，声明一个执行方法当作所有请求的入口。这个执行方法允许设置常用参数和其它跨请求共享设置（例如认证），因为每一个请求都需要帐户ID和密钥，所以在建立新的代理实例时都需要传递这两个值。需要注意的是执行过程中不会抛出异常，但是可以在ErrorException 中访问到异常信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// TwilioApi.cs
public class TwilioApi {
    const string BaseUrl = &quot;https://api.twilio.com/2008-08-01&quot;;

    readonly string _accountSid;
    readonly string _secretKey;

    public TwilioApi(string accountSid, string secretKey) {
        _accountSid = accountSid;
        _secretKey = secretKey;
    }

    public T Execute&amp;lt;T&amp;gt;(RestRequest request) where T : new()
    {
        var client = new RestClient();
        client.BaseUrl = new System.Uri(BaseUrl);
        client.Authenticator = new HttpBasicAuthenticator(_accountSid, _secretKey);
        request.AddParameter(&quot;AccountSid&quot;, _accountSid, ParameterType.UrlSegment); // used on every request
        var response = client.Execute&amp;lt;T&amp;gt;(request);

        if (response.ErrorException != null)
        {
            const string message = &quot;Error retrieving response.  Check inner details for more info.&quot;;
            var twilioException = new ApplicationException(message, response.ErrorException);
            throw twilioException;
        }
        return response.Data;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，定义一个实体类来映射API返回的数据，再定义一个方法用来访问API同时获取返回的Call资源的具体信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Call.cs
public class Call
{
    public string Sid { get; set; }
    public DateTime DateCreated { get; set; }
    public DateTime DateUpdated { get; set; }
    public string CallSegmentSid { get; set; }
    public string AccountSid { get; set; }
    public string Called { get; set; }
    public string Caller { get; set; }
    public string PhoneNumberSid { get; set; }
    public int Status { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public int Duration { get; set; }
    public decimal Price { get; set; }
    public int Flags { get; set; }
}

// TwilioApi.cs, method of TwilioApi class
public Call GetCall(string callSid) 
{
    var request = new RestRequest();
    request.Resource = &quot;Accounts/{AccountSid}/Calls/{CallSid}&quot;;
    request.RootElement = &quot;Call&quot;;

    request.AddParameter(&quot;CallSid&quot;, callSid, ParameterType.UrlSegment);

    return Execute&amp;lt;Call&amp;gt;(request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一些神奇之处是RestSharp 需要关心而我们不必关注：&lt;/p&gt;
&lt;p&gt;1、API返回的XML数据被默认XmlDeserializer 检测到，同时反序列化为Call对象。&lt;/p&gt;
&lt;p&gt;2、默认RestRequest 对应HTTP中的GET 请求，可以通过设置RestRequest  的Method属性或者在创建请求实例时通过构造函数指定Method  类型来改变请求类型。&lt;/p&gt;
&lt;p&gt;3、UrlSegment  类型参数会根据Resource 属性值中匹配的名称标签将值注入到URL中，AccountSid  在 TwilioApi.Execute  赋值，对于每一个请求它都是相同的。&lt;/p&gt;
&lt;p&gt;4、我们指定了从哪里开始反序列化的根元素名称，在本例中，返回的XML形如 ，因为Response元素不包含与我们定义的实体模型相关的任何信息，所以从元素树的下一个节点开始反序列化（Call节点）。&lt;/p&gt;
&lt;p&gt;我们还可以定义POST（和 PUT/DELETE/HEAD/OPTIONS ）请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// TwilioApi.cs, method of TwilioApi class
public Call InitiateOutboundCall(CallOptions options) 
{
    Require.Argument(&quot;Caller&quot;, options.Caller);
    Require.Argument(&quot;Called&quot;, options.Called);
    Require.Argument(&quot;Url&quot;, options.Url);

    var request = new RestRequest(Method.POST);
    request.Resource = &quot;Accounts/{AccountSid}/Calls&quot;;
    request.RootElement = &quot;Calls&quot;;

    request.AddParameter(&quot;Caller&quot;, options.Caller);
    request.AddParameter(&quot;Called&quot;, options.Called);
    request.AddParameter(&quot;Url&quot;, options.Url);

    if (options.Method.HasValue) request.AddParameter(&quot;Method&quot;, options.Method);
    if (options.SendDigits.HasValue()) request.AddParameter(&quot;SendDigits&quot;, options.SendDigits);
    if (options.IfMachine.HasValue) request.AddParameter(&quot;IfMachine&quot;, options.IfMachine.Value);
    if (options.Timeout.HasValue) request.AddParameter(&quot;Timeout&quot;, options.Timeout.Value);

    return Execute&amp;lt;Call&amp;gt;(request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本示例同样证明RestSharp是一个轻量级验证助手，可以在请求前先校验提交的参数值是否有效。&lt;/p&gt;
&lt;p&gt;示例中通过AddParameter  方法添加的参数值将通过标准编码格式提交，类似于通过网页提交的表单。如果是GET形式的请求(GET/DELETE/OPTIONS/HEAD) ，参数值将通过查询字符串提交，AddParameter() 方法也可以添加头信息和cookie 参数。将一个对象的所有属性作为参数时，使用AddObject() 方法。上传一个文件时用 AddFile() 方法（请求会以多种编码格式发送），当请求中包含请求体时（例如XML或者JSON），用AddBody()方法。&lt;/p&gt;
&lt;h2 id=&quot;三其它应用示例&quot;&gt;三、其它应用示例&lt;/h2&gt;
&lt;p&gt;下面的示例演示了用流（stream）代替内存缓冲请求内容，这在请求大量数据同时需要立刻写入磁盘的场景下非常有用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string tempFile = Path.GetTempFileName();
using (var writer = File.OpenWrite(tempFile))
{
    var client = new RestClient(baseUrl);
    var request = new RestRequest(&quot;Assets/LargeFile.7z&quot;);
    request.ResponseWriter = (responseStream) =&amp;gt; responseStream.CopyTo(writer);
    var response = client.DownloadData(request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四反序列化&quot;&gt;四、反序列化&lt;/h2&gt;
&lt;p&gt;RestSharp拥有处理XML和JSON的反序列化器，当收到响应时，RestClient通过服务器返回的Content Type 选择适合的反序列化器。默认设置可以通过自定义设置的Content Type覆盖，支持的Content Type如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application/json - JsonDeserializer&lt;/li&gt;
&lt;li&gt;application/xml - XmlDeserializer&lt;/li&gt;
&lt;li&gt;text/json - JsonDeserializer&lt;/li&gt;
&lt;li&gt;text/xml - XmlDeserializer&lt;/li&gt;
&lt;li&gt;*+json - JsonDeserializer (content types using a Structured Suffix Syntax specifying JSON)&lt;/li&gt;
&lt;li&gt;*+xml - XmlDeserializer (content types using a Structured Suffix Syntax specifying XML)&lt;/li&gt;
&lt;li&gt;@*@ - XmlDeserializer (all other content types not specified)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;默认的反序列化器尝试解除必须解析XML或者JSON的痛苦，通过映射CLR实体类来实现。实体类定义了如何反序列化返回的数据。RestSharp不再采用遍历返回的数据，再从实体类中查找匹配的属性的方式反序列化数据，而是把实体类当作起点，循环遍历可访问的可写属性，同时在返回的数据中查找相应的元素。&lt;/p&gt;
&lt;p&gt;注意：默认的反序列化器不支持 DataAnnotation/DataMember ，如果要使用，必须实现和注册自己的IDeserializer ，IDeserializer 是包装了与实体类中属性兼容的反序列化库。&lt;/p&gt;
&lt;p&gt;例如下面的XML和JSON：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Person&amp;gt;
    &amp;lt;Name&amp;gt;John&amp;lt;/Name&amp;gt;
    &amp;lt;Id&amp;gt;28&amp;lt;/Id&amp;gt;
&amp;lt;/Person&amp;gt;

{
    &quot;Name&quot;: &quot;John&quot;,
    &quot;Id&quot;: 28
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;映射相同的实体类Person:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person 
{
    public string Name { get; set; }
    public int Id { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支持的属性类型数据类型&quot;&gt;支持的属性类型（数据类型）：&lt;/h3&gt;
&lt;h4 id=&quot;xmldeserializer&quot;&gt;XmlDeserializer：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Primitives (int, short, long, etc)&lt;/li&gt;
&lt;li&gt;Decimal&lt;/li&gt;
&lt;li&gt;DateTime&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Guid&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Nested classes&lt;/li&gt;
&lt;li&gt;Nullable versions of the above listed types&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;jsondeserializer&quot;&gt;JsonDeserializer&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Primitives&lt;/li&gt;
&lt;li&gt;Decimal&lt;/li&gt;
&lt;li&gt;DateTime&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Guid&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Dictionary&amp;lt;T1, T2&amp;gt;&lt;/li&gt;
&lt;li&gt;Nested classes&lt;/li&gt;
&lt;li&gt;Nullable versions of the above listed types&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;名称匹配&quot;&gt;名称匹配：&lt;/h3&gt;
&lt;h4 id=&quot;xmldeserializer-1&quot;&gt;XmlDeserializer&lt;/h4&gt;
&lt;p&gt;当查找匹配元素时，默认的XML反序列化器查找元素和特性遵循以下顺序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;元素和名称绝对匹配&lt;/li&gt;
&lt;li&gt;元素和名称的小写匹配&lt;/li&gt;
&lt;li&gt;元素和名称的骆驼命名匹配&lt;/li&gt;
&lt;li&gt;元素和名称去掉下划线和破折号匹配&lt;/li&gt;
&lt;li&gt;特性和名称绝对匹配&lt;/li&gt;
&lt;li&gt;特性和名称的小写匹配&lt;/li&gt;
&lt;li&gt;特性和名称的骆驼命名匹配&lt;/li&gt;
&lt;li&gt;特性和名称去掉下划线和破折号匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用@DeserializeAs@ 特性来更改将在属性中查找的名称，如果要将属性的命名与XML中的名称同，这一点将非常有用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[DeserializeAs(Name = &quot;forecast_information&quot;)]
public ForecastInformation Forecast { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一种返回元素值的特殊情况，示例如下：&lt;/p&gt;
&lt;p&gt;如果返回的XML数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Response&amp;gt;Hello world&amp;lt;/Response&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有办法用c#的类直接描述&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Response 
{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要一些东西来保存返回的元素值，在本例中，添加一个Value属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Response
{
     public string Value { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsondeserializer-1&quot;&gt;JsonDeserializer&lt;/h4&gt;
&lt;p&gt;当为匹配元素查找数据时，默认的JSON反序列化器在查找元素时将遵循以下顺序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与名称绝对匹配&lt;/li&gt;
&lt;li&gt;与名称骆驼命名匹配&lt;/li&gt;
&lt;li&gt;与名称小写匹配&lt;/li&gt;
&lt;li&gt;与名称加了下划线匹配 (e.g. ProductId -&amp;gt; Product_Id)&lt;/li&gt;
&lt;li&gt;与名称加了下划线小写形式匹配 (e.g. Product_id -&amp;gt; product_id)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;XML反序列化器可以通过设置属性的DeserializeAs  特性来改变如何与JSON的键映射。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[DeserializeAs(Name = &quot;forecast_information&quot;)]
public ForecastInformation Forecast { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合处理listdictionary&quot;&gt;集合处理（List/Dictionary）&lt;/h3&gt;
&lt;h4 id=&quot;xmldeserializer-2&quot;&gt;XmlDeserializer&lt;/h4&gt;
&lt;p&gt;处理两种不同形式的集合：内联和嵌套&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;InlineListSample&amp;gt;
    &amp;lt;image src=&quot;1.gif&quot;&amp;gt;value1&amp;lt;/image&amp;gt;
    &amp;lt;image src=&quot;2.gif&quot;&amp;gt;value2&amp;lt;/image&amp;gt;
    &amp;lt;image src=&quot;3.gif&quot;&amp;gt;value3&amp;lt;/image&amp;gt;
    &amp;lt;image src=&quot;4.gif&quot;&amp;gt;value4&amp;lt;/image&amp;gt;
&amp;lt;/InlineListSample&amp;gt;

&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;NestedListSample&amp;gt;
   &amp;lt;images&amp;gt;
      &amp;lt;image src=&quot;1.gif&quot;&amp;gt;value1&amp;lt;/image&amp;gt;
      &amp;lt;image src=&quot;2.gif&quot;&amp;gt;value2&amp;lt;/image&amp;gt;
      &amp;lt;image src=&quot;3.gif&quot;&amp;gt;value3&amp;lt;/image&amp;gt;
      &amp;lt;image src=&quot;4.gif&quot;&amp;gt;value4&amp;lt;/image&amp;gt;
    &amp;lt;/images&amp;gt;
&amp;lt;/NestedListSample&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的c#形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ListSample
{
    public List&amp;lt;Image&amp;gt; Images { get; set; }
}
    
public class Image
{
    public string Src { get; set; }
    public string Value { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在同一份文档中两种元素结构恰巧同时存在，优先级按此顺序：parented/nested/regular 。&lt;/p&gt;
&lt;h4 id=&quot;jsondeserializer-2&quot;&gt;JsonDeserializer&lt;/h4&gt;
&lt;p&gt;在映射JSON数组和字典时，RestSharp支持集合（List）和字典（Dictionary&amp;lt;string, T&amp;gt; ）&lt;/p&gt;
&lt;h3 id=&quot;日期处理&quot;&gt;日期处理&lt;/h3&gt;
&lt;h4 id=&quot;xmldeserializer-3&quot;&gt;XmlDeserializer&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果RestRequest.DateFormat已经指定了返回值的格式，则返回值使用指定格式字符串解析。&lt;/li&gt;
&lt;li&gt;如果 RestRequest.DateFormat 没有指定, 用DateTime.Parse计算元素值. 如果该方法无法处理当前格式, 则需要改变属性类型为String然后再进行处理 。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;jsondeserializer-3&quot;&gt;JsonDeserializer&lt;/h4&gt;
&lt;p&gt;如果没有通过RestRequest.DateFormat指定日期格式，RestSharp尝试用以下格式字符转来反序列化DateTime类型的属性（顺序如下）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;u&quot;&lt;/li&gt;
&lt;li&gt;&quot;s&quot;&lt;/li&gt;
&lt;li&gt;&quot;yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'&quot;&lt;/li&gt;
&lt;li&gt;&quot;yyyy-MM-ddTHH:mm:ssZ&quot;&lt;/li&gt;
&lt;li&gt;&quot;yyyy-MM-dd HH:mm:ssZ&quot;&lt;/li&gt;
&lt;li&gt;&quot;yyyy-MM-ddTHH:mm:ss&quot;&lt;/li&gt;
&lt;li&gt;&quot;yyyy-MM-ddTHH:mm:sszzzzzz&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JsonSerializer  默认支持以下JSON日期格式，如果指定了具体的RestRequest.DateFormat ，则默认被忽略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ISO - 1910-09-25T09:30:25Z&lt;/li&gt;
&lt;li&gt;Javascript Date Objects - new Date(-1870352975000)&lt;/li&gt;
&lt;li&gt;Unix Timestamps - 1435206458&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于JS日期对象，在JS纪元时间基础上加毫秒级的时间间隔，根据指定的时区调整。&lt;/p&gt;
&lt;h3 id=&quot;自定义&quot;&gt;自定义&lt;/h3&gt;
&lt;h4 id=&quot;重写默认反序列化器&quot;&gt;重写默认反序列化器&lt;/h4&gt;
&lt;p&gt;可以通过如下步骤重写自己的反序列化器处理返回的数据内：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个类同时实现IDeserializer接口。&lt;/li&gt;
&lt;li&gt;用RestClient.AddHandler(contentType, IDeserializer)方法注册handler并关联content类型，如果此content类型已经被注册过，则会被指定的刚刚指定的handker重写，可以通过 RestClient.ClearHandlers()方法移除所有注册的handler，或者通过RestClient.RemoveHandler(contentType)移除某一个handler。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;重写默认的序列化器&quot;&gt;重写默认的序列化器&lt;/h4&gt;
&lt;p&gt;当使用XML或者JSON格式数据作为请求体时，可以使用自己实现的ISerializer  ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var request = new RestRequest();
request.RequestFormat = DataFormat.Xml;
request.XmlSerializer = new SuperXmlSerializer(); // implements ISerializer
request.AddBody(person); // object serialized to XML using your custom serializer;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重写jsonserializationstrategy&quot;&gt;重写JsonSerializationStrategy&lt;/h4&gt;
&lt;p&gt;序列化过程中，尝试支持c#和JSOM间不同投影策略将会陷入麻烦，重写MapClrMemberNameToJsonFieldName 将会有帮助：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SnakeJsonSerializerStrategy : PocoJsonSerializerStrategy
{
    protected override string MapClrMemberNameToJsonFieldName(string clrPropertyName)
    {
        //PascalCase to snake_case
        return string.Concat(clrPropertyName.Select((x, i) =&amp;gt; i &amp;gt; 0 &amp;amp;&amp;amp; char.IsUpper(x) ? &quot;_&quot; + char.ToLower(x).ToString() : x.ToString()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在代码中使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SimpleJson.CurrentJsonSerializerStrategy = new SnakeJsonSerializerStrategy();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五认证&quot;&gt;五、认证&lt;/h2&gt;
&lt;p&gt;RestSharp包含HTTP认证，可以通过IAuthenticator  完成自己的实现同时用RestClient注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var client = new RestClient();
client.Authenticator = new SuperAuthenticator(); // implements IAuthenticator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用RestClient.Execute 或 RestClient.Execute&lt;/p&gt;
&lt;h3 id=&quot;使用simpleauthenticator&quot;&gt;使用SimpleAuthenticator&lt;/h3&gt;
&lt;p&gt;SimpleAuthenticator 允许把用户名和密码当作GET 或 POST参数传递，具体取决于所使用的请求方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var client = new RestClient(&quot;http://example.com&quot;);
client.Authenticator = new SimpleAuthenticator(&quot;username&quot;, &quot;foo&quot;, &quot;password&quot;, &quot;bar&quot;);

var request = new RestRequest(&quot;resource&quot;, Method.GET);
client.Execute(request);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求生成的URL应该是如下形式：http://example.com/resource?username=foo&amp;amp;password=bar&lt;/p&gt;
&lt;p&gt;上述请求如果使用PUT或者POST请求时，将会以编码表单形式提交值。&lt;/p&gt;
&lt;h2 id=&quot;六restrequest的参数类型&quot;&gt;六、RestRequest的参数类型&lt;/h2&gt;
&lt;p&gt;新建了RestRequest 后，可以为它添加参数，下面是5种当前支持的参数类型以及其在使用默认IHttp实现下的特性描述。&lt;/p&gt;
&lt;h3 id=&quot;cookie&quot;&gt;Cookie&lt;/h3&gt;
&lt;p&gt;添加到cookies  列表的参数将会随着请求被单独发送，Cookie名称是参数的名称，值则是传递的参数的值（.ToString ）。&lt;/p&gt;

&lt;p&gt;添加作为 HTTP header 的参数会随着请求被单独发送，Header名称是参数的名称，Header值则是传递的参数的值。&lt;/p&gt;
&lt;p&gt;注意有些受限制的headers表现不同或者会被忽略，可以在Http.cs中的_restrictedHeaderActions  字典中查看它们的特性。&lt;/p&gt;
&lt;h3 id=&quot;getorpost&quot;&gt;GetOrPost&lt;/h3&gt;
&lt;p&gt;如果执行GET请求，RestSharp将会追加参数到URL中，形式如下：“url?name1=value1&amp;amp;name2=value2” ；&lt;/p&gt;
&lt;p&gt;如果是POST或者是PUT请求，则取决于请求中是否有文件，如果没有，则参数以请求体发送，形如“name1=value1&amp;amp;name2=value2” ，将会以application/x-www-form-urlencoded格式发送，基于不同的请求方法会有不同的表现。&lt;/p&gt;
&lt;p&gt;两种情形下，参数名称和值都会自动被url编码。&lt;/p&gt;
&lt;p&gt;如果请求中有文件，RestSharp将会发送multipart/form-data 形式的请求，发送的参数将会形如以下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Content-Disposition: form-data; name=&quot;parameterName&quot;

ParameterValue&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;urlsegment&quot;&gt;UrlSegment&lt;/h3&gt;
&lt;p&gt;不同于GetOrPost ，这种参数类型在RequestUrl 中用占位符代替值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var request = new RestRequest(&quot;health/{entity}/status&quot;);
request.AddParameter(&quot;entity&quot;, &quot;s2&quot;, ParameterType.UrlSegment);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行请求时，RestSharp将尝试用参数名称匹配占位符，匹配成功后则用参数值代替占位符，上面的代码结果是：“health/s2/status”  。&lt;/p&gt;
&lt;h3 id=&quot;requestbody&quot;&gt;RequestBody&lt;/h3&gt;
&lt;p&gt;如果设置了这个参数，参数值会以请求的body方式传递。请求只能接收一个RequestBody  参数（第一个）。&lt;/p&gt;
&lt;p&gt;参数名称将被用作请求的Content-Type header 。&lt;/p&gt;
&lt;p&gt;RequestBody  参数对于GET或者HEAD  是无效的，它们不需要发送请求体。&lt;/p&gt;
&lt;p&gt;如果同时还有GetOrPost  参数，则该参数将重写RequestBody  ——RestSharp  不会合并这些参数，但会抛弃RequestBody  参数。&lt;/p&gt;
&lt;h3 id=&quot;querystring&quot;&gt;QueryString&lt;/h3&gt;
&lt;p&gt;类似于GetOrPost ，除此之外，它总是用如下形式追加参数到URL：“url?name1=value1&amp;amp;name2=value2” ，不管是什么类型的请求方法。&lt;/p&gt;
&lt;h2 id=&quot;七缓存&quot;&gt;七、缓存&lt;/h2&gt;
&lt;h3 id=&quot;自动缓存管理&quot;&gt;自动缓存管理&lt;/h3&gt;
&lt;p&gt;RestSharp 102.4 +版本支持所有IRestClient 实例的请求共享同一个System.Net.CookieContainer 管理，通过这种方式，responses 设置或没设置缓存在后续的请求中都会使用，为了共享CookieContainer ，在创建RestClient 时设置属性即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var client = new RestClient(&quot;http://server/&quot;);
client.CookieContainer = new System.Net.CookieContainer();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八跨平台支持&quot;&gt;八、跨平台支持&lt;/h2&gt;
&lt;p&gt;RestSharp包含2个版本的lib：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;.NET Framework 4.5.2&lt;/li&gt;
&lt;li&gt;.NET Standard 2.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;意味着可以在以下平台应用RestSharp：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows using .NET Framework&lt;/li&gt;
&lt;li&gt;Windows using .NET Core&lt;/li&gt;
&lt;li&gt;Linux or Mac using Mono&lt;/li&gt;
&lt;li&gt;Linux or Mac using .NET Core&lt;/li&gt;
&lt;li&gt;Any other platform that supports Mono 5 or .NET Core 2&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 29 Aug 2018 06:26:00 +0000</pubDate>
<dc:creator>眼圈黑黑</dc:creator>
<og:description>翻译自：https://github.com/restsharp/RestSharp/wiki，转载请注明。 一、新手入门 如果只有少量一次性请求需要封装为API，则可以如下使用RestSharp ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heiyanquan/p/9554068.html</dc:identifier>
</item>
<item>
<title>微软认知服务应用秘籍 – 君子动口不动手 - UniversalAIPlatform</title>
<link>http://www.cnblogs.com/ms-uap/p/9551234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ms-uap/p/9551234.html</guid>
<description>&lt;p&gt;&lt;span&gt;科技的不断发展带动着人们生活质量不断的提升，其中一方面就体现在日常家庭生活中，智能设备层出不穷，给人们的生活带来了很大的便利。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以电视为例，几十年前的电视还是按钮式的，每次换台还要跑到电视跟前；后来使用遥控器控制成为了主流，人们可以舒服的窝在沙发里看电视；再后来随着互联网及移动通信技术的发展，电视、机顶盒、空调等，都可以在手机上进行控制，再也不用几个遥控器之间来回倒腾了，还不耽误刷微博；近年来随着人工智能的发展，语音识别、合成技术日趋成熟，家电已经可以理解语音指令，能够按照人类的交流方式进行人机交互了，人们只需要动嘴说说话就可以完成各种操控。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种智能家居的典型场景如下图所示，以智能音箱为核心，所有设备通过WiFi与智能音箱连接并可以接受智能音箱的控制指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人们可以和音箱打招呼，音箱能够自然的回答问好；也可以询问天气，音箱能够自动根据当前位置搜索并回答未来一天的天气；还可以直接对着音箱说一声&quot;把灯关掉&quot;，音箱应该能够控制关掉灯，或者主动询问&quot;要关哪个灯&quot;，在得到明确指令后再执行指定的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221039707-1225692787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文将借助微软认知服务中的多个服务实现一个简单的智能家居应用，来模拟一个语音控制开关灯的场景，期望能给予大家一些启示，并期望大家可以利用更多的微软认知服务扩展出更多炫酷实用的功能。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这一节我们看一下语音控制开关的流程是怎样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从场景上来看很简单，人直接说&quot;开灯&quot;，灯就可以打开，当然说&quot;请把灯打开&quot;，灯也应该能够打开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于传统的程序员来说，实现起来主要的难点在于如何让程序理解人类说的话，尤其是用户一般都是用很自然的语言去说，用户的习惯不一样，语法结构也不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这个难点，这里我们将借助微软认知服务里的语音转文本服务和语言理解服务来赋予程序理解人类说话的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要做到这些，主要分三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，借助语音转文本服务，将用户的语音输入识别成对应的文字，比如&quot;开灯&quot;、&quot;请把灯打开&quot;等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，借助语言理解服务来将自然语言转为程序可以理解的意图。不管用户是说&quot;开灯&quot;还是&quot;请把灯打开&quot;，语言理解服务都可以识别出用户的意图是打开(TurnOn)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，按照识别出的用户的意图去控制灯打开或关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221040372-1263303418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;语音转文本服务提供将音频流转录为文本的能力，微软的语音转文本服务采用了和微软小娜相同的技术。应用程序借助此服务可以轻松地将声音转录为文字，之后可以直接显示或做更进一步的使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语音服务提供SDK和REST API两种使用方式。使用SDK可以将服务更方便的集成到应用程序中，并且可以提供额外的功能，如实时的中间转录结果、静默一段时间自动停止、转录超长的音频等。目前提供的SDK有.Net、C/C++、Java版本，如果使用其它编程语言，可以考虑更通用的REST API方式，但是不能提供SDK中所有的功能。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;在线体验&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;语音转文本服务的在线体验地址是&lt;a href=&quot;https://azure.microsoft.com/zh-cn/services/cognitive-services/speech-to-text/&quot;&gt;https://azure.microsoft.com/zh-cn/services/cognitive-services/speech-to-text/&lt;/a&gt;，可以先通过此页面对该服务有个初步的认识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果设备有麦克风，可以点击开始录音，然后对着麦克风说话，查看语音转文本的效果；如果没有麦克风，也可以点击下方的两个示例体验一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到网页在录音的过程中，同时显示语音转文本的中间结果，并按照最新播放的内容不断纠正旧文本、显示新文本，最终给出了一个最佳的文本结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221041167-794869267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;申请试用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;后面要在程序中调用语音转文本服务，必须要有服务密钥才可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;试用密钥的有效期是 30 天，每月 5000 个事务，每分钟 20 个。每个账号只能申请一次试用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;申请步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;打开申请试用页面：&lt;a href=&quot;https://azure.microsoft.com/zh-cn/try/cognitive-services/?api=speech-services&quot;&gt;https://azure.microsoft.com/zh-cn/try/cognitive-services/?api=speech-services&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;找到语音服务，点击右侧的获取API密钥&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221041613-1019666813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;在弹出页面点击来宾7天试用下面的开始使用(不用管这里显示的7天，语音服务现在还是预览版，有30天的试用期，申请完成后显示30天)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221042129-18386926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;span&gt;在服务条款页面勾选同意，选择国家/地区为中国，下一步&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221042551-2087111908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;span&gt;选择要使用的账号，笔者这里选择Microsoft&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221043309-1000461145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;span&gt;登录后可以看到密钥申请成功，如下图所示&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221044666-486808939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意图中重点标出的部分，一个是终结点中westus，这个是当前密钥可使用的区域，试用密钥都是westus；另一个是下面的密钥1和密钥2。区域和密钥稍后在后面程序代码中要用到，大家可以单独记下来或者保持该网页不要关闭，方便后续使用。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;在Azure中申请使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上面30天的试用密钥过期后如果想继续免费使用该服务，还可以到Azure门户中申请密钥，前提是首先要有Azure账户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还没有Azure账户，可以免费注册一个。打开免费注册页面，&lt;a href=&quot;https://azure.microsoft.com/zh-cn/free/ai/&quot;&gt;https://azure.microsoft.com/zh-cn/free/ai/&lt;/a&gt;，点击免费开始，然后按提示一步步补充完整注册信息。注册过程中需要验证手机号及信用卡，而且会看到1美元的预付款，不过不用担心，这1美元只是用来验证信用卡是否可用，会在几天后返还。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了Azure账户后，打开Azure门户网站，&lt;a href=&quot;https://portal.azure.com/&quot;&gt;https://portal.azure.com/&lt;/a&gt;，点击创建资源，搜索找到Speech(预览)，按提示一步步创建，就可以得到对应的密钥。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;语言理解服务，Language Understanding Intelligence Service，简称LUIS。后面文中使用LUIS来代替语言理解服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LUIS提供在线的API服务，可以将用户输入的自然语言描述的文本，转换成为计算机能够直接使用的结构化的信息，这样应用程序就可以借助LUIS理解人类自然语言的输入。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;在线体验&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;LUIS的在线体验场景是&lt;a href=&quot;https://azure.microsoft.com/zh-cn/services/cognitive-services/language-understanding-intelligent-service/&quot;&gt;https://azure.microsoft.com/zh-cn/services/cognitive-services/language-understanding-intelligent-service/&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开网页后，可以看到如下图所示的示例。可以选择一条指令来观察灯光的变化，也可以通过输入自定的指令文本来控制灯光，可以试试自己习惯的语法，看能否正确的控制灯光变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221045615-536475855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;基本术语&lt;/h2&gt;
&lt;h3&gt;LUIS应用程序&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在使用LUIS的过程中，我们最初会接触到app这个词，这里的app是指LUIS应用程序。一个LUIS应用程序其实对应的就是一个语言理解模型。通常情况下，一个LUIS应用程序（即一个模型），是用来解决一个特定域（主题）内的语言理解问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，对于旅行相关的主题，如预订机票、酒店等，可以创建一个LUIS应用程序，而对于购物相关的主题，如搜索商品、下单，可以再创建另外一个LUIS应用程序。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;意图(Intent)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;意图(Intent)，表示用户想要执行的任务或操作。比如询问天气、预订机票等，都是意图，在控制开关灯的例子中，开灯和关灯就是意图。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;实体(Entity)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;实体(Entity)，想当于上面意图中的参数。比如对象、时间、地点等，都可以标记为实体。举个例子，帮我预定明天北京飞往西雅图的飞机，这里用到了三个实体：明天、北京、西雅图，分别表示了时间、始发地、目的地三个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，实体在不同的意图之间是可以共享的。举个例子，明天天气怎么样，这个语句的意图是询问天气，而明天是其中的一个实体，表示时间参数，和上一个例子中的实体是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;语句(Utterance)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;语句(Utterance)，是LUIS应用需要处理的用户的输入。在训练时提供的语句应该是尽可能包含不同的说话方式或不同的语法的，这样训练出来的结果会更好一些。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;定制语言理解服务&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;LUIS提供一些预先构建好的域、实体及意图，覆盖了比较全的场景。一种常见的做法是添加预构建的内容，然后迭代完成自定义的模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这里的演示的场景比较简单，直接动手从头定制一个语音控制开关灯需要用到的LUIS应用程序。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;登录LUIS&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;打开LUIS网站&lt;a href=&quot;https://www.luis.ai&quot;&gt;https://www.luis.ai&lt;/a&gt;，并登录对应的微软账号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221047733-1539637057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是第一次登录，网站还会请求访问对应账号的一些信息，点Yes继续。网站首次加载较慢，需要耐心等待，必要的时候可以刷新重新再次加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果页面跳转到了欢迎页面&lt;a href=&quot;https://www.luis.ai/welcome&quot;&gt;https://www.luis.ai/welcome&lt;/a&gt;，可以翻到页面最下方，点击Create LUIS app，然后在下一个页面补充缺失的信息，将Country设为China，并勾选I agree条款，然后点击Continue。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221048669-1196949592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221049324-1458879116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直到看到My Apps页面，才算登录完成，如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221049712-1291201056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;创建LUIS应用&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;点击Create new app，创建一个新的LUIS应用。注意，Culture要选择Chinese，Name随意，这里使用LightControl。然后点击Done完成创建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221050167-93369100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;添加意图&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创建完LUIS应用程序后会直接进入Intents页面，也可以通过点击左侧的Intents进入。然后点Create new intent创建一个新的意图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221050582-1111737705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在弹出窗中输入意图的名称，这里使用TurnOn表示开灯的意图，完成后点击Done。注意这里意图的名称在后面程序中会用到，拼写及大小写要保持前后一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221050989-1940198485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成后会进入TurnOn意图的设置页面，可以在输入框中输入不同的语句，然后回车就可添加到语句列表中。这里添加了4条语句：打开、开灯、请开灯、把灯打开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221051378-58011060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击左侧Intents回到意图页面，然后重复上面的步骤，添加TurnOff意图表示关灯，并添加4条语句：关闭、关灯、请关灯、关闭灯泡。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;添加实体&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;意图是必需的，而实体不是必需的。可以根据具体的场景来决定是否添加实体，比如有需要控制客厅灯和卧室灯两个灯，应该定义个实体来标记房间是客厅还是卧室，而不是使用多个意图分别控制不同的灯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LUIS支持多种类型的实体来应对各种复杂的情况，包括简单实体、列表实体、正则表达式、复合实体等，这里不详细展开，有兴趣的可以参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/cognitive-services/luis/luis-concept-entity-types&quot;&gt;https://docs.microsoft.com/zh-cn/azure/cognitive-services/luis/luis-concept-entity-types&lt;/a&gt;里的介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们下面的例子中只控制一个灯，这里就不添加实体了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;训练&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;添加完意图和实体后就可以训练了，可以看到右上角有个带红点的Train按钮，点击就可以直接训练。训练速度非常快，几秒种之后看到红点变成绿点就表示训练完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221051777-1954293092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;点击右上角的Test，会滑出Test侧边栏，在输入框中输入测试语句并回车，可以看到对应的意图及得分。这里使用的测试语句是请帮我把灯打开，可以看到识别到的意图是TurnOn，得分是0.86，意图正确且比较接近1，结果还不错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221052125-1889567918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;发布&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;点击顶部的PUBLISH进入发布页面，在页面中点击Publish按钮就直接发布了。发布成功后可以看到右侧的版本号及发布时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221052573-1231643504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将页面翻到底部可以找到服务发布后的区域、密钥和终结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221053280-942665335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要注意这里的终结点是以q=结尾的，需要在终结点的最后拼上要测试的语句，比如请帮我把灯打开，得到一个完整的链接，然后再从浏览器里打开，就可以看到识别后的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;识别结果是以JSON格式返回的，其中topScoringIntent是最匹配的意图，我们后面要用到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221053731-289225433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;迭代&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;LUIS应用在发布后可以继续改进数据，添加新语句或意图或实体，然后再训练，再发布。在这样的周期中反复迭代，最终达到最佳的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221054706-1690463886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上一步发布的终结点最后拼上一个新的语句&quot;北京天气怎么样&quot;，然后在浏览器进行测试，可以发现最终topScoringIntent是TurnOff，这显然是不对的，而且得分只有0.14，和其它几个意图的得分差不多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221055073-2068210113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要对模型改进一下，再进行一次迭代。回到LUIS的意图页面，我们可以看到这里有一个None意图，这是创建完LUIS应用程序后自带的一个意图，可以直接打开该意图的页面，在其中添加一条语句无关语句，比如&quot;北京天气怎么样&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221055478-885929391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还一种做法是通过审查终结点上得到的语句来改进模型。点击左侧的Review endpoint utterances，进入审查页面，可以看到我们刚才在终结点上查询的语句，我们可以把&quot;北京天气怎么样&quot;右侧的Aligned Intent改为None，然后点击右侧的对勾，此时，该语句就会被自动加到了None意图中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221056980-605408065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后再次训练、发布，再使用之前的终结点查询&quot;北京天气怎么样&quot;，可以看到结果正确，topScoringIntent是None意图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221057802-1895426720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tips：最佳实践是None意图中语句的数量应占总语句数量的10%~20%。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;查看应用程序ID&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;点击SETTINGS进入应用程序设置页面就可以看到Application ID，某些情况下会用到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221058433-1860182301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;密钥管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果要在程序中调用LUIS服务，必须要有密钥。LUIS 中有两种密钥：创作密钥和终结点密钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创作密钥是在首次登录LUIS时自动分配的，终结点密钥是在Azure门户申请的。终结点密钥不是必需的，可以在下面的示例中继续使用创作密钥。但是创作密钥的免费配额要比终结点密钥低得多，所以还是建议在LUIS应用程序发布后，申请一个终结点密钥并分配给LUIS应用程序供外部调用。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;创作密钥&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创作密钥是在登录LUIS时自动创建的免费密钥，创建的多个LUIS应用程序使用同一个密钥，且每月只能调用1千次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创作密钥的值可以在User settings中找到，点击右上账户名出现下拉菜单，再点击Settings，就可以看到创作密钥：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221059164-691708318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以在发布页面的终结点处看到创作密钥：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221059637-1367718703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;终结点密钥&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;终结点密钥是在Azure门户中申请的密钥，申请的免费密钥的配额是月1万次调用，每秒最多5次调用，远大于创作密钥的配额。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;终结点密钥的申请方法和前面介绍的在Azure门户中申请语音服务密钥的方法类似，在创建资源时搜索LUIS即可找到Language Understanding服务，按步骤创建个免费密钥即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们换一种申请方式，在Visual Studio中借助Tools for AI来申请密钥。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;确保已安装Visual Studio 2017并安装了Tools for AI扩展。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　如果没有安装，请参考&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9123033.html&quot;&gt;AI应用开发实战 - 从零开始配置环境&lt;/a&gt;中Windows下开发环境搭建的第1节安装VS和第5节安装Tools for AI插件。&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;确保Visual Studio中登录了对应的微软账号。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　如果没有登录，可以在Visual Studio的右上角看到登录按钮，点击后按步骤登录。&lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;确保可以看到Azure订阅&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　在视图菜单中，选择Cloud Explorer，如下图点击账户管理，确保可以刷出你的订阅，如果没有刷出，请尝试重启Visual Studio并稍后再试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221100340-1092372209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;span&gt;创建认知服务&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　在视图菜单中，选择服务器资源管理器，找到AI工具，在Azure认知服务上点右键，创建新认知服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221100737-2007576823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　选择已有的订阅，新申请的账户通常会有个名为免费试用的订阅。选择一个已有的资源组，如果没有资源组，需要在Azure上先创建一个。API类型选择LUIS。服务名可以随便起，这里使用LUIS。位置可以先东亚，East Asia。定价申请免费的，直接选F0。点击确定来创建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221101163-1914739559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建成功后可以在Azure认知服务下看到名为LUIS的服务，右键选择管理密钥，就可以看到申请的密钥1和密钥2。新申请的密钥需要几分钟的部署时，之后才可以使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221101623-1069725175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;分配密钥&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;新申请的终结点密钥需要分配到LUIS应用程序中才可以使用对应的终结点进行查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到LUIS的发布页面，翻到最下面的Resources and Keys，切换到Asia Regions，点击Add Key按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221102026-330705664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在弹出的Assign a key to your app对话框中，依次选择刚才使用的订阅和创建的密钥，点击Add Key按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221102462-1673951738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到Resoures and Keys中Asia Regions下出现了终结点密钥和使用该密钥的终结点地址。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;程序的源代码在&lt;a href=&quot;https://github.com/mslichao/LightControl301&quot;&gt;https://github.com/mslichao/LightControl301&lt;/a&gt;，将源代码下载到本地后，用Visual Studio 2017打开解决方案文件LightControl\LightControl.sln。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;界面设计&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在解决方案资源管理器中找到Form1.cs，双击打开对应的设计界面，如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221102937-470355344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左侧是一个图片控件，可以显示灯打开时和关闭时的图片，来模拟真实的开关灯操作。在解决方案资源管理器中可以看到LightOn.png和LightOff.png两张图片，用来显示灯处在不同的状态下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右侧是一个文本框，用来显示一些日志，比如语音转文本过程中的中间结果、最终结果以及识别出的意图等信息。通过日志，我们可以看到语音服务和LUIS是否已正常连接并正常工作，如果出现异常，也会在这里显示异常信息，方便对问题进行排查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Form窗体上点右键，查看代码，打开该窗体的代码页面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先，在构造函数中，控件初始化完成后，让图片控件显示一张关闭着的灯的图片：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
{
    InitializeComponent();
    pictureBox1.Load(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightOff.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后，封装要用到的一些界面操作，例如，在右侧文本框中追加日志输出，模拟打开灯，关闭灯等：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] parameters)
{
    MakesureRunInUI(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parameters.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            message &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(message + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, parameters);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            message &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        textBox1.AppendText(message);
    });
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OpenLight()
{
    MakesureRunInUI(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        pictureBox1.Load(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightOn.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CloseLight()
{
    MakesureRunInUI(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        pictureBox1.Load(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightOff.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MakesureRunInUI(Action action)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (InvokeRequired)
    {
        MethodInvoker method &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodInvoker(action);
        Invoke(action, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        action();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;集成语音服务SDK和语言理解服务SDK&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这个代码示例中，我们用语音服务SDK来处理音频转文本，用语言理解服务SDK来提取文本中的意图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先添加SDK的引用。切换到解决方案资源管理器，在LightControl下的引用上点右键，选择管理NuGet程序包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221103720-241817968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在打开的NuGet包管理器中，依次搜索并安装下面3个引用：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Microsoft.CognitiveServices.Speech&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Newtonsoft.Json&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Microsoft.Azure.CognitiveServices.Language.LUIS.Runtime&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;然后回到Form1.cs的代码编辑页面，引用命名空间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.CognitiveServices.Speech;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; Microsoft.Azure.CognitiveServices.Language.LUIS.Runtime;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后配置两个服务用到的密钥、区域及终结点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文前面申请到的语音服务的30天试用密钥是6d04e77c6c6f4a02a9cf942f6419ffaf，区域是westus。前面定制的LUIS应用程序的ID是130e348f-d131-41d1-96b2-a29d42cc1d96，密钥这里示例先用创作者密钥58c57e08c8d540a4aa2196588eb69f8a，终结点字符串比较长，但是LUIS SDK中只需配置到域名即可，不需要后面的路径，所以这里的终结点是https://westus.api.cognitive.microsoft.com&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置语音服务密钥及区域&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; speechKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6d04e77c6c6f4a02a9cf942f6419ffaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; speechRegion = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;westus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置语言理解服务终结点、密钥、应用程序ID&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; luisEndpoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://westus.api.cognitive.microsoft.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; luisKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;58c57e08c8d540a4aa2196588eb69f8a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; luisAppId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;130e348f-d131-41d1-96b2-a29d42cc1d96&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后初始化SDK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加成员变量语音识别器和意图预测器，并在Form1_Load函数中初始化，挂载对应的事件处理函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tips：Form1_Load函数需通过在Form窗体设计界面直接双击窗体的标题栏来添加。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语音识别器&lt;/span&gt;
&lt;span&gt;SpeechRecognizer recognizer;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 意图预测器&lt;/span&gt;
&lt;span&gt;Prediction intentPrediction;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        SpeechFactory speechFactory &lt;/span&gt;=&lt;span&gt; SpeechFactory.FromSubscription(speechKey, speechRegion);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置识别中文&lt;/span&gt;
        recognizer = speechFactory.CreateSpeechRecognizer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 挂载识别中的事件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到中间结果&lt;/span&gt;
        recognizer.IntermediateResultReceived +=&lt;span&gt; Recognizer_IntermediateResultReceived;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到最终结果&lt;/span&gt;
        recognizer.FinalResultReceived +=&lt;span&gt; Recognizer_FinalResultReceived;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发生错误&lt;/span&gt;
        recognizer.RecognitionErrorRaised +=&lt;span&gt; Recognizer_RecognitionErrorRaised;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动语音识别器，开始持续监听音频输入&lt;/span&gt;
&lt;span&gt;        recognizer.StartContinuousRecognitionAsync();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置意图预测器&lt;/span&gt;
        LUISRuntimeClient client = &lt;span&gt;new&lt;/span&gt; LUISRuntimeClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApiKeyServiceClientCredentials(luisKey));
        client.Endpoint &lt;/span&gt;=&lt;span&gt; luisEndpoint;
        intentPrediction &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Prediction(client);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
    {
        Log(ex.Message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后补充完整几个事件处理函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语音转文本时会不断的接收到中间结果，这里把中间结果输出到日志窗口中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 识别过程中的中间结果&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Recognizer_IntermediateResultReceived(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, SpeechRecognitionResultEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(e.Result.Text))
    {
        Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中间结果: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Result.Text);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;识别出现错误的时候，也把错误信息输出到日志窗口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出错时的处理&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Recognizer_RecognitionErrorRaised(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RecognitionErrorEventArgs e)
{
    Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;识别错误: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.FailureReason);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;静默几秒后，SDK会认为语音结束，此时返回语音转文本的最终结果。这里拿到结果后，在日志窗口中显示最终结果，并进一步处理文本结果&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得音频分析后的文本内容&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Recognizer_FinalResultReceived(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, SpeechRecognitionResultEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(e.Result.Text))
    {
        Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最终结果: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Result.Text);
        ProcessSttResultAsync(e.Result.Text);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;添加处理文本的函数，这里从文本中获取意图，然后根据意图的值，来执行开灯或关灯操作&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProcessSttResultAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用语言理解服务取得用户意图&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; intent = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; GetIntentAsync(text);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照意图控制灯&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(intent))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (intent.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TurnOn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.OrdinalIgnoreCase))
        {
            OpenLight();
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (intent.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TurnOff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.OrdinalIgnoreCase))
        {
            CloseLight();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后，添加对LUIS SDK的调用，可以从文本中获取意图&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetIntentAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text)
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; intentPrediction.ResolveAsync(luisAppId, text);
        Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;意图: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + result.TopScoringIntent.Intent + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n得分: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + result.TopScoringIntent.Score + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.TopScoringIntent.Intent;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
    {
        Log(ex.Message);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;编译运行，并对着麦克风说出指令，就可以看到对应的效果了。同时我们可以看到语音转文本的中间结果在不断变化，说明服务端会根据后续接收到的音频不断进行调整，最终返回一个最佳的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/700062/201808/700062-20180828221104326-1202022751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;本文通过介绍语音转文本服务及语言理解服务，并将两个服务集成在一个程序中完成了个模拟的智能家居应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回头看一下我们的场景非常简单，这里提出一些改进作为习题供大家练习：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;现在只能控制一个灯，可以考虑控制更多的灯，客厅灯，卧室灯，等等，可以考虑在LUIS中增加实体来实现这个目标。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果每次开灯或关灯时，智能家居都可以用人类的语音反馈给人&quot;灯已打开&quot;、&quot;已经把灯关上了&quot;，这样的话可以得到更好的体验。微软认知服务也提供了文本转语音的服务，在不久的将来还会支持开发者定义自己的语音字体，可以定制自己喜欢的声音，使得用户的体验更好。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现了多个灯的控制及语音反馈以后，还可以考虑让智能家居应用支持多轮对话。比如，当人说开灯的时候，智能家居可以询问&quot;要打开哪里的灯&quot;，并按照后续补充的指令打开对应的灯。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当然还可以举出更多的场景使得智能家居更完美，大家可以充分种用微软提供的认知服务，考虑并设计自己的智能家居应用。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 04:13:00 +0000</pubDate>
<dc:creator>UniversalAIPlatform</dc:creator>
<og:description>概述 科技的不断发展带动着人们生活质量不断的提升，其中一方面就体现在日常家庭生活中，智能设备层出不穷，给人们的生活带来了很大的便利。 以电视为例，几十年前的电视还是按钮式的，每次换台还要跑到电视跟前；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ms-uap/p/9551234.html</dc:identifier>
</item>
<item>
<title>人工智能会伤害人类吗？怎样控制他们？ - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9553401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9553401.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.551724137931&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1079528?fromSource=waitui&quot;&gt;人工智能资讯小编&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/1556?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;长文预警：&lt;/strong&gt; 在本文中，我们将训练一个在训练期间完全加密的神经网络（在未加密的数据上进行训练）。这将为神经网络带来两个有益的特性：首先，神经网络的智能可以受到更好的保护以免被他人盗取，消除了在不安全环境下训练的有价值的AI被其他智能盗取的风险；其次，网络可以&lt;strong&gt;只作加密的预测&lt;/strong&gt;（这意味着在没有密钥的情况下，外界无法理解接受预测，从而网络对外界不会产生影响）。这在用户和超人工智能间建立了一个非常有价值的不对等权力。试想，如果AI是经过同态加密处理的，那么从AI的角度来看，&lt;strong&gt;整个外部世界也是同态加密过的&lt;/strong&gt;。而人类可以控制密钥从而决定是解锁AI自身（在外部世界发布）还是只解码AI作出的决策（似乎显得更安全）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 如果你对训练加密的神经网络感兴趣，可以参考&lt;a href=&quot;https://github.com/OpenMined/PySyft&quot;&gt;OpenMined的PySyft库&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;超级智能&quot;&gt;超级智能&lt;/h2&gt;
&lt;p&gt;很多人担心超人工智能总有一天会选择伤害人类。之前，史蒂芬·霍金曾呼吁建立一个&lt;a href=&quot;https://futurism.com/stephen-hawking-finally-revealed-his-plan-for-preventing-an-ai-apocalypse/&quot;&gt;新的世界“政府”&lt;/a&gt;来管理我们给予人工智能的能力以免其毁灭人类。这个陈述是很大胆的，我认为它反映了科学界以至全世界共同关心的问题。在本文中，我将用一些玩具性质的代码来演示针对这个问题的潜在技术解决方案。&lt;/p&gt;
&lt;p&gt;我们的目标很朴实。我们像发明一个可以让AI变得极度聪明（聪明到可以治愈癌症，解决全球饥饿问题）的技术，不过前提是这样的智能是在人类的控制下的，即它的应用是受限的。无止境地学习固然是好的，但是知识的无限制应用却有着潜在的危险。&lt;/p&gt;
&lt;p&gt;为了阐述这一观点，我将首先快速讲解两个振奋人心的研究领域：深度学习和同态加密。&lt;/p&gt;
&lt;h2 id=&quot;第1部分什么是深度学习&quot;&gt;第1部分：什么是深度学习？&lt;/h2&gt;
&lt;p&gt;深度学习可以理解为人工智能的一套自动化工具，主要借助与神经网络。作为计算机科学的领域之一，深度学习在很多智能任务的完成质量上超越了之前的技术，这促使了AI技术的繁荣。在这一背景下，在击败世界围棋冠军的&lt;a href=&quot;https://deepmind.com/research/alphago/&quot;&gt;DeepMind的AlphaGo&lt;/a&gt;中深度学习也扮演了重要角色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt; 神经网络是怎样学习的呢？&lt;/p&gt;
&lt;p&gt;神经网络基于输入进行预测。它通过不断地试验来高效地做到这一点。这个过程从一个预测开始（起初很大情况下是随机的），之后通过接受到的“误差信号”来判断它的预测是高了还是低了（通常预测的输出为概率值）。在经过很多次尝试之后，网络开始具有了辨识能力。关于神经网络工作的具体细节，可以参阅&lt;a href=&quot;http://iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;A Neural Network in 11 Lines of Python&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里的重点是上面提到的误差信号。如果说网络不知道自己的预测的水平如何，它就无法进行学习，，要牢记这一点。&lt;/p&gt;
&lt;h2 id=&quot;第2部分什么是同态加密&quot;&gt;第2部分：什么是同态加密？&lt;/h2&gt;
&lt;p&gt;顾名思义，&lt;a href=&quot;https://www.wired.com/2014/11/hacker-lexicon-homomorphic-encryption/&quot;&gt;同态加密&lt;/a&gt;是一种加密形式。在不对称的情况下，可以用“公钥”将明文转化为乱码。关键的一点是，你可以用对应的“私钥”将加密后的文本再次解码为原始的明文。但是只有在你有“私钥”的情况下你才可以解码混淆后的明文（理论上）。&lt;/p&gt;
&lt;p&gt;同态加密只是一种特殊的加密方式。它支持某些用户在不具有原有信息读权限的情况下对加密信息进行修改操作。举个例子来说，加密的数字信息可以在不解码的情况下进行乘法和加法操作。下面给出一个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/6ya1a47q7q.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在同态加密的方案越来越多，每个方案都有着不同的特性。不过这还是一个成长中的领域，还有很多关键的问题仍待解决，我们后面会再回到这个问题上讨论。&lt;/p&gt;
&lt;p&gt;现在我们先延续上面的内容进行讲解，从上图可以看出我们可以在经过同态加密的数据上进行乘法和加法操作。此外由于公钥可以进行单向加密，这使得我们可以用加密的数字和未加密的数字进行相应操作（对未加密的数据进行单向加密），正如上图中的 2 * Cypher 一样。（一些加密算法甚至不需要这样做，我们后面再谈）&lt;/p&gt;
&lt;h2 id=&quot;第三部分我们可以把两者结合使用吗&quot;&gt;第三部分：我们可以把两者结合使用吗？&lt;/h2&gt;
&lt;p&gt;深度学习和同态加密最常见的结合场景主要体现再数据隐私方面。事实证明，当数据经过同态加密之后，虽然不能够读取其中的信息，但是你仍然可以保持数据中大部分感兴趣的统计学结构。这使得人们可以在加密数据上训练模型（&lt;a href=&quot;https://arxiv.org/abs/1412.6181&quot;&gt;CryptoNets&lt;/a&gt;）。此外，初创对冲基金会&lt;a href=&quot;https://medium.com/numerai/encrypted-data-for-efficient-markets-fffbe9743ba8&quot;&gt;Numer.ai&lt;/a&gt;加密了昂贵，专有的数据来提供给任何人训练机器学习模型来预测股票市场。通常来说，他们是不能这样做的，因为这构成了珍贵/私密数据的泄漏（而常规的加密手段又会使模型训练变得不可能）。&lt;/p&gt;
&lt;p&gt;不过，本文要做的是一个反向的过程，即对神经网络进行加密并在解码的数据上进行训练。&lt;/p&gt;
&lt;p&gt;一个大型神经网络从整体上看复杂度是惊人的，但是将它们分解之后也只是一些简单操作的重复而已。事实上，许多先进的神经网络通常只需要以下操作来创建：&lt;/p&gt;
&lt;p&gt;既然这样，我们在技术上是否可以加密同态神经网络本身吗？事实证明我们可以通过一些近似做到这一点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加法 - 开箱即用&lt;/li&gt;
&lt;li&gt;乘法 - 开箱即用&lt;/li&gt;
&lt;li&gt;除法 - 开箱即用？ - 乘 (1 / 被乘数) 即可&lt;/li&gt;
&lt;li&gt;减法 - 开箱即用？ - 加一个负数即可&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mathworld.wolfram.com/SigmoidFunction.html&quot;&gt;Sigmoid&lt;/a&gt; - 嗯...也许有点难&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicTangent.html&quot;&gt;Tanh&lt;/a&gt; - 嗯...也许有点难&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;指数&lt;/a&gt; - 嗯...也许有点难&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来我们可以很轻松地完成除法和减法，但是完成一些复杂函数则比完成加法和乘法操作困难的多。为了对深度神经网络进行同态加密，我们需要一些“秘密配方”。&lt;/p&gt;
&lt;h2 id=&quot;第四部分泰勒级数展开&quot;&gt;第四部分：泰勒级数展开&lt;/h2&gt;
&lt;p&gt;可能你还记得高中或者大学里这部分的内容：&lt;a href=&quot;https://en.wikipedia.org/wiki/Taylor_series&quot;&gt;泰勒级数&lt;/a&gt;允许我们使用无限项的加减乘除操作的组合来计算非线性函数。这个方法完美地解决了我们的问题！（除了需要无限项这一点）。幸运的是，如果你只能计算泰勒展开式的前几项，你也可以得到一个近似的函数。下卖弄给出了一些常用函数的泰勒级数（&lt;a href=&quot;http://hyperphysics.phy-astr.gsu.edu/hbase/tayser.html&quot;&gt;来源&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/z6mevy1ygk.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中有指数函数！可以看到展开式只是一些加减乘除操作，这是我们可以完成的。同样地，我们可以像下图所示一样用Python实现我们需要的sigmoid函数的泰勒展开式（其展开式可以在&lt;a href=&quot;http://mathworld.wolfram.com/SigmoidFunction.html&quot;&gt;Wolfram Alpha&lt;/a&gt;查阅）。我们可以只取前面的部分项来观察近似结果和实际结果的差距。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

def sigmoid_exact(x):
  return 1 / (1 + np.exp(-x))

# using taylor series
def sigmoid_approximation(x):
  return (1 / 2) + (x / 4) - (x**3 / 48) + (x**5 / 480)

for lil_number in [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:
  
  print(&quot;\nInput:&quot; + str(lil_number))
  print(&quot;Exact Sigmoid:&quot; + str(sigmoid_exact(lil_number)))
  print(&quot;Approx Sigmoid:&quot; + str(sigmoid_approximation(lil_number)))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Input:0.1
Exact Sigmoid:0.524979187479
Approx Sigmoid:0.5249791875

Input:0.2
Exact Sigmoid:0.549833997312
Approx Sigmoid:0.549834

Input:0.3
Exact Sigmoid:0.574442516812
Approx Sigmoid:0.5744425625

Input:0.4
Exact Sigmoid:0.598687660112
Approx Sigmoid:0.598688

Input:0.5
Exact Sigmoid:0.622459331202
Approx Sigmoid:0.6224609375

Input:0.6
Exact Sigmoid:0.645656306226
Approx Sigmoid:0.645662

Input:0.7
Exact Sigmoid:0.668187772168
Approx Sigmoid:0.6682043125

Input:0.8
Exact Sigmoid:0.689974481128
Approx Sigmoid:0.690016

Input:0.9
Exact Sigmoid:0.710949502625
Approx Sigmoid:0.7110426875

Input:1.0
Exact Sigmoid:0.73105857863
Approx Sigmoid:0.73125&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果可以看到，我们只取前四项时的计算结果就已经很接近无穷项的计算结果了。完成了复杂函数的问题之后，下面我们来选择一个同态加密算法。&lt;/p&gt;
&lt;h2 id=&quot;第5部分选择加密算法&quot;&gt;第5部分：选择加密算法&lt;/h2&gt;
&lt;p&gt;同态加密是一个相对较新的领域，其里程碑事件是2009年克雷格·金特里（Craig Gentry）发明了&lt;a href=&quot;https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf&quot;&gt;第一个完全同态加密算法&lt;/a&gt;。这个发现为后来的研究者提供了立足点。这一领域大部分振奋人心的研究是围绕实现同态加密的图灵完全的计算机展开的。相应地，人们需要寻求一个有效且安全的同态加密算法方案，可以根据任意的计算输入去完成相应的逻辑门操作。人们普遍的希望是可以将工作安全地移植到云上并且不用担心发送的数据被发送者以外的人监听。这是一个非常酷的想法，也取得了很大进展。&lt;/p&gt;
&lt;p&gt;但是还有一个缺陷，就是大多数完全同态加密算法在普通计算机上通常是非常慢的（不实用）。这引发了另一个有趣的研究方向，即只做部分同态加密的运算从而减小运算量。这种方案降低了灵活程度但提升了运算速度，是计算中常用的折衷手段。&lt;/p&gt;
&lt;p&gt;我们从这一点出发寻找加密算法。理论上我们需要的是一个在浮点运算的同态加密方案（但我们本文更多以整数为例），为什么不是二进制呢？二进制加密固然可行，但是它不仅要求完全同态加密方案的灵活性（性能损失），还需要我们去管理二进制表示和数学操作中的逻辑操作。相比之下，没有那么强大的针对浮点数定制的HE算法更为合适。&lt;/p&gt;
&lt;p&gt;尽管我们确定了这个限制条件，但是还有很多的算法以供选择。这里有一些具有我们喜欢的特性的流行算法：&lt;/p&gt;
&lt;p&gt;以上方案中的最优方案应当是YASHE或FV。YASHE被应用与流行的CryptoNets（加密网络）算法当中，对浮点操作的支持很好。但是这个方法很复杂，为了使本文更加简单有趣，我们选择了稍逊一筹的方案（基于整数向量的高效同态加密，&lt;a href=&quot;https://eprint.iacr.org/2016/775.pdf&quot;&gt;安全性要差一点&lt;/a&gt;）。但是，你要注意即使你读本文时出现了新的同态加密算法，但是本文中的整数/浮点数加法和乘法同态加密的实现方案是通用的。我希望通过本文可以提高你对同态加密算法应用的理解以便开发出更多的同态加密算法去优化深度学习。&lt;/p&gt;
&lt;p&gt;这个加密算法&lt;a href=&quot;https://courses.csail.mit.edu/6.857/2015/files/yu-lai-payor.pdf&quot;&gt;Yu, Lai, and Paylor的工作&lt;/a&gt;里也有一节专门提及，还有相应的&lt;a href=&quot;https://github.com/jamespayor/vector-homomorphic-encryption&quot;&gt;代码实现&lt;/a&gt;，核心代码位于&lt;code&gt;vhe.cpp&lt;/code&gt;当中。下面我们将用Python实现相应的接口并做相应讲解。你也可以选择更高层面的实现方式或者移植到其他语言或场景下，因为这套实现方案是通用的（通用的函数名称，变量名等等）。&lt;/p&gt;
&lt;h2 id=&quot;第6部分python中的同态加密&quot;&gt;第6部分：Python中的同态加密&lt;/h2&gt;
&lt;p&gt;首先介绍一下同态加密中的术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;明文：&lt;/strong&gt; 未加密的数据。这也被称为“信息”(message)。在我们的例子中，这将是代表我们神经网络的数值的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密文：&lt;/strong&gt; 加密后的数据。我们在密文做的数学操作会改变底层的明文，最初的图示也提到了这一点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公钥：&lt;/strong&gt; 伪随机数序列，任何人可以用它加密数据。公钥可以被传播，因为拿到的人只能用它来加密数据（理论上）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私钥/密钥：&lt;/strong&gt; 伪随机数序列，允许您解密通过公钥加密的数据。私钥不应该分享给他人，否则你加密的数据就会被他人解码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上是使用中可以移动的组件。在不同的同态加密算法中，会有一些标准变量，本文中有以下标准变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;S：&lt;/strong&gt; 代表密钥/私钥的矩阵，你需要用它来解密信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M：&lt;/strong&gt; 公钥。你会用它来加密东西，并执行数学运算。虽然一些算法中所有的数学运算都不需要公钥，但是公钥的使用还是相当广泛。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;c：&lt;/strong&gt; 加密数据矢量，“密文”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x：&lt;/strong&gt; 对应于你的信息，或者说你的“明文”。有些论文使用变量“m”代替。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;w :&lt;/strong&gt; 用于给我们的输入信息&lt;strong&gt;x&lt;/strong&gt;重新分配权重的常量值。（使其总是更大或更小一点）。我们使用这个变量来帮助调整信噪比。使信号“变大”使得它在任何给定的操作中不易受到噪声的影响。但是，如果数据太大，则会增加我们完全损坏数据的可能性。这是一个折衷后的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;/&lt;strong&gt;e&lt;/strong&gt;：通常指随机噪声。在某些情况下，公钥加密的数据在加密之前被混入了噪声。混入的噪声使解密变得困难。但这也使的相同的明文在使用相同的公钥时可以产生不同的密文，这增加了密文被破解的难度。请注意，根据算法和实现，&lt;strong&gt;E/e&lt;/strong&gt;可以是矢量或矩阵。在其他情况下，它也可能是指操作累积的噪声。稍后我们会进一步讨论。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与许多数学论文一样，大写字母对应于矩阵，小写字母对应于矢量，斜体小写字母对应于标量。同态加密有四种我们关心的操作：公钥/私钥对生成，单向加密，解密和数学运算。我们先从解密开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/1go5k0x83p.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/3chxk7oph9.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的公式描述了私钥&lt;strong&gt;S&lt;/strong&gt;和我们的“明文”&lt;strong&gt;x&lt;/strong&gt;之间的一般关系。下面的公式告诉了我们如何使用私钥来解密数据。注意下面的式子，&lt;strong&gt;e&lt;/strong&gt;去哪了？其实从原理上来说同态加密引入噪声的目的就是使人们在没有私钥的情况下很难解密我们的数据，但是如果你拥有密钥，噪声又显得很小以至于等于或小于舍入误差。下面公式中特殊的括号表示其中的计算结果四舍五入至最近的整数。其他的加密算法可以选择不同的舍入方式。取模运算符更是无处不在,加密的过程实际上就是生成一个满足上述等式的&lt;strong&gt;c&lt;/strong&gt;。如果&lt;strong&gt;S&lt;/strong&gt;是一个随机矩阵，&lt;strong&gt;c&lt;/strong&gt;将很难被解密。简而言之，非对称情况下，生成加密密钥只需要找到私钥的逆即可。我们用Python代码来演示以下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

def generate_key(w,m,n):
    S = (np.random.rand(m,n) * w / (2 ** 16)) # proving max(S) &amp;lt; w
    return S

def encrypt(x,S,m,n,w):
    assert len(x) == len(S)
    
    e = (np.random.rand(m)) # proving max(e) &amp;lt; w / 2
    c = np.linalg.inv(S).dot((w * x) + e)
    return c

def decrypt(c,S,w):
    return (S.dot(c) / w).astype('int')

def get_c_star(c,m,l):
    c_star = np.zeros(l * m,dtype='int')
    for i in range(m):
        b = np.array(list(np.binary_repr(np.abs(c[i]))),dtype='int')
        if(c[i] &amp;lt; 0):
            b *= -1
        c_star[(i * l) + (l-len(b)): (i+1) * l] += b
    return c_star

def get_S_star(S,m,n,l):
    S_star = list()
    for i in range(l):
        S_star.append(S*2**(l-i-1))
    S_star = np.array(S_star).transpose(1,2,0).reshape(m,n*l)
    return S_star


x = np.array([0,1,2,5])

m = len(x)
n = m
w = 16
S = generate_key(w,m,n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我在iPython notebook中运行这个代码后执行了以下操作（图示有相应的输出）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/v8zy24qhy5.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关键的是下面两个操作的结果，可以看到我们对明文做的基本算术操作改变了密文底层代表的明文。很优雅的操作，不是吗？&lt;/p&gt;
&lt;h2 id=&quot;第7部分优化加密过程&quot;&gt;第7部分：优化加密过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/1go5k0x83p.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/3chxk7oph9.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入:&lt;/strong&gt; 我们再次审视一下解密的公式,如果密钥S为单位矩阵，那么密文c就只是重新加权后的明文混入一定的噪声而已,只要具有一定量的样本就可以发现。如果这段文字你不理解的话，你需要搜索一下“单位矩阵”相关的知识再回来阅读，否则下面的内容理解起来会很吃力。&lt;/p&gt;
&lt;p&gt;上面的例子告诉了我们加密发生的过程。这项技术的发明者并没有同时确定一对独立的“公钥”和”私钥“，而是提出了“密钥转换”技术,借助这一技术可以将私钥S转换为S'。更具体地说，这种密钥转换技术生成了可以将未加密的数据(单位矩阵作为密钥)转换为加密后的数据（随机生成的，难以被猜到的密钥）的矩阵M，M就是我们的公钥！&lt;/p&gt;
&lt;p&gt;上面一段包含的信息很多，我们再梳理一遍：&lt;/p&gt;
&lt;h4 id=&quot;这里发生了什么...&quot;&gt;这里发生了什么...&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;根据上面给定的两个公式，如果密钥是单位矩阵，则信息未加密。&lt;/li&gt;
&lt;li&gt;根据上面给定的两个公式，如果密钥是一个随机矩阵，则生成的信息是加密的。&lt;/li&gt;
&lt;li&gt;我们可以创建一个矩阵M，将密钥从一种形式更改为另一种形式。&lt;/li&gt;
&lt;li&gt;当矩阵M从单位矩阵转换为随机矩阵密钥时，它通过扩展完成了信息的单向加密。&lt;/li&gt;
&lt;li&gt;因为M扮演着“单向加密”的角色，所以我们称之为“公钥”，并且可以像公钥一样分发它，因为它并不能解密代码。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到此我们不做更深的讲解，下面我们看一下这个过程如何在Python中完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

def generate_key(w,m,n):
    S = (np.random.rand(m,n) * w / (2 ** 16)) # proving max(S) &amp;lt; w
    return S

def encrypt(x,S,m,n,w):
    assert len(x) == len(S)
    
    e = (np.random.rand(m)) # proving max(e) &amp;lt; w / 2
    c = np.linalg.inv(S).dot((w * x) + e)
    return c

def decrypt(c,S,w):
    return (S.dot(c) / w).astype('int')

def get_c_star(c,m,l):
    c_star = np.zeros(l * m,dtype='int')
    for i in range(m):
        b = np.array(list(np.binary_repr(np.abs(c[i]))),dtype='int')
        if(c[i] &amp;lt; 0):
            b *= -1
        c_star[(i * l) + (l-len(b)): (i+1) * l] += b
    return c_star

def switch_key(c,S,m,n,T):
    l = int(np.ceil(np.log2(np.max(np.abs(c)))))
    c_star = get_c_star(c,m,l)
    S_star = get_S_star(S,m,n,l)
    n_prime = n + 1
    

    S_prime = np.concatenate((np.eye(m),T.T),0).T
    A = (np.random.rand(n_prime - m, n*l) * 10).astype('int')
    E = (1 * np.random.rand(S_star.shape[0],S_star.shape[1])).astype('int')
    M = np.concatenate(((S_star - T.dot(A) + E),A),0)
    c_prime = M.dot(c_star)
    return c_prime,S_prime

def get_S_star(S,m,n,l):
    S_star = list()
    for i in range(l):
        S_star.append(S*2**(l-i-1))
    S_star = np.array(S_star).transpose(1,2,0).reshape(m,n*l)
    return S_star

def get_T(n):
    n_prime = n + 1
    T = (10 * np.random.rand(n,n_prime - n)).astype('int')
    return T

def encrypt_via_switch(x,w,m,n,T):
    c,S = switch_key(x*w,np.eye(m),m,n,T)
    return c,S

x = np.array([0,1,2,5])

m = len(x)
n = m
w = 16
S = generate_key(w,m,n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/410635/dgkemv074n.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法主要是让密钥S大多数情况下为单位矩阵，然后再用一个随机向量T和它结合在一起。虽然说T拥有了密钥所有的必要信息，但是我们还需要创建一个与S行列相同的矩阵来完成这个工作。&lt;/p&gt;
&lt;h2 id=&quot;第8部分建立异或神经网络&quot;&gt;第8部分：建立异或神经网络&lt;/h2&gt;
&lt;p&gt;现在我们已经知道了如何对信息进行加密和解密（并实现了基本的加法和乘法）,是时候扩展剩余的操作来实现一个简单的XOR神经网络了。虽然从技术上来说神经网络只是一系列简单操作的集合，但为了方便我们需要将一些常用的组合操作封装为函数。下面我会描述我们需要的操作以及我们实现这些操作使用的一些高级技巧，然后会列出相关的代码实现。如果想了解更多细节可以参阅&lt;a href=&quot;https://courses.csail.mit.edu/6.857/2015/files/yu-lai-payor.pdf&quot;&gt;Angel Yu, Wai Lok Lai, James Payor的研究&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;浮点数：&lt;/strong&gt; 我们将通过简单地将浮点数放大为整数来实现。这样即时输入为浮点数我们也可以作为整数处理。比方说，我们选择的放大倍数为1000。放大前0.2 &lt;em&gt;0.5 = 0.1。放大后为200&lt;/em&gt; 500 = 100000.注意我们进行两次乘法运算之后必须缩放2次，即100000 /（1000 * 1000）= 0.1。这是一个你需要习惯的技巧。由于同态加密方案最后会舍入到最近的整数，所以放大也可以帮助你控制网络的精度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矢量矩阵乘法：&lt;/strong&gt; 这是我们要完成的基本功能。事实上，将一个密钥转换为另一个密钥的M矩阵的过程实际上就是一种线性变换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点积：&lt;/strong&gt; 在正确的上下文环境中，上面的线性变换也可以写作点积。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sigmoid：&lt;/strong&gt; 由于我们可以做矢量矩阵乘法，我们可以借助足够的乘式来评估拟合任意多项式。由于我们知道sigmoid的泰勒级数多项式，我们可以拟合一个近似的sigmoid函数！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩阵元乘法：&lt;/strong&gt; 这个操作的效率极低。我们必须做一个向量矩阵乘法或一系列的点积。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外积：&lt;/strong&gt; 我们可以通过矩阵的裁剪和外积来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先声明这里可能还有其它更有效的方法来实现以上操作，但是为了不破坏当前的同态加密方案我只好使用了论文中提供的函数（实现sigmoid可用的扩展）。现在让我们看看如何在Python中完成它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def sigmoid(layer_2_c):
    out_rows = list()
    for position in range(len(layer_2_c)-1):

        M_position = M_onehot[len(layer_2_c)-2][0]

        layer_2_index_c = innerProd(layer_2_c,v_onehot[len(layer_2_c)-2][position],M_position,l) / scaling_factor

        x = layer_2_index_c
        x2 = innerProd(x,x,M_position,l) / scaling_factor
        x3 = innerProd(x,x2,M_position,l) / scaling_factor
        x5 = innerProd(x3,x2,M_position,l) / scaling_factor
        x7 = innerProd(x5,x2,M_position,l) / scaling_factor

        xs = copy.deepcopy(v_onehot[5][0])
        xs[1] = x[0]
        xs[2] = x2[0]
        xs[3] = x3[0]
        xs[4] = x5[0]
        xs[5] = x7[0]

        out = mat_mul_forward(xs,H_sigmoid[0:1],scaling_factor)
        out_rows.append(out)
    return transpose(out_rows)[0]

def load_linear_transformation(syn0_text,scaling_factor = 1000):
    syn0_text *= scaling_factor
    return linearTransformClient(syn0_text.T,getSecretKey(T_keys[len(syn0_text)-1]),T_keys[len(syn0_text)-1],l)

def outer_product(x,y):
    flip = False
    if(len(x) &amp;lt; len(y)):
        flip = True
        tmp = x
        x = y
        y = tmp
        
    y_matrix = list()

    for i in range(len(x)-1):
        y_matrix.append(y)

    y_matrix_transpose = transpose(y_matrix)

    outer_result = list()
    for i in range(len(x)-1):
        outer_result.append(mat_mul_forward(x * onehot[len(x)-1][i],y_matrix_transpose,scaling_factor))
    
    if(flip):
        return transpose(outer_result)
    
    return outer_result

def mat_mul_forward(layer_1,syn1,scaling_factor):
    
    input_dim = len(layer_1)
    output_dim = len(syn1)

    buff = np.zeros(max(output_dim+1,input_dim+1))
    buff[0:len(layer_1)] = layer_1
    layer_1_c = buff
    
    syn1_c = list()
    for i in range(len(syn1)):
        buff = np.zeros(max(output_dim+1,input_dim+1))
        buff[0:len(syn1[i])] = syn1[i]
        syn1_c.append(buff)
    
    layer_2 = innerProd(syn1_c[0],layer_1_c,M_onehot[len(layer_1_c) - 2][0],l) / float(scaling_factor)
    for i in range(len(syn1)-1):
        layer_2 += innerProd(syn1_c[i+1],layer_1_c,M_onehot[len(layer_1_c) - 2][i+1],l) / float(scaling_factor)
    return layer_2[0:output_dim+1]

def elementwise_vector_mult(x,y,scaling_factor):
    
    y =[y]
    
    one_minus_layer_1 = transpose(y)

    outer_result = list()
    for i in range(len(x)-1):
        outer_result.append(mat_mul_forward(x * onehot[len(x)-1][i],y,scaling_factor))
        
    return transpose(outer_result)[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一点没有提到，就是为了节省时间我预先计算了几个密钥，矢量，矩阵并存储了起来。其中包含了矩阵元全为1的矩阵，不定长的One-hot编码向量等等。这为上面提到的裁剪操作以及其他简单操作提供了很大的便利。例如sigmoid函数的导数是sigmoid(x) * (1 - sigmoid(x))。因此预先计算这些值是很有帮助的。下面给出相应代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# HAPPENS ON SECURE SERVER

l = 100
w = 2 ** 25

aBound = 10
tBound = 10
eBound = 10

max_dim = 10

scaling_factor = 1000

# keys
T_keys = list()
for i in range(max_dim):
    T_keys.append(np.random.rand(i+1,1))

# 单向加密转换
M_keys = list()
for i in range(max_dim):
    M_keys.append(innerProdClient(T_keys[i],l))

M_onehot = list()
for h in range(max_dim):
    i = h+1
    buffered_eyes = list()
    for row in np.eye(i+1):
        buffer = np.ones(i+1)
        buffer[0:i+1] = row
        buffered_eyes.append((M_keys[i-1].T * buffer).T)
    M_onehot.append(buffered_eyes)
    
c_ones = list()
for i in range(max_dim):
    c_ones.append(encrypt(T_keys[i],np.ones(i+1), w, l).astype('int'))
    
v_onehot = list()
onehot = list()
for i in range(max_dim):
    eyes = list()
    eyes_txt = list()
    for eye in np.eye(i+1):
        eyes_txt.append(eye)
        eyes.append(one_way_encrypt_vector(eye,scaling_factor))
    v_onehot.append(eyes)
    onehot.append(eyes_txt)

H_sigmoid_txt = np.zeros((5,5))

H_sigmoid_txt[0][0] = 0.5
H_sigmoid_txt[0][1] = 0.25
H_sigmoid_txt[0][2] = -1/48.0
H_sigmoid_txt[0][3] = 1/480.0
H_sigmoid_txt[0][4] = -17/80640.0

H_sigmoid = list()
for row in H_sigmoid_txt:
    H_sigmoid.append(one_way_encrypt_vector(row))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果仔细观察的话，你会发现H_sigmoid矩阵正是我们估计sigmoid函数时需要用到的矩阵。:)最后，我们用下面的代码来训练我们的神经网络。如果你对神经网络的概念还不清楚，可以自行搜索或者查阅作者的博文&lt;a href=&quot;http://yehe.isd.com/column/iamtrask.github.io/2015/07/12/basic-python-network/&quot;&gt;A Neural Network in 11 Lines of Python&lt;/a&gt;，这里的异或神经网络基本上是参考这篇文章的，只是根据上面的加密操作函数做了相应替换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;np.random.seed(1234)

input_dataset = [[],[0],[1],[0,1]]
output_dataset = [[0],[1],[1],[0]]

input_dim = 3
hidden_dim = 4
output_dim = 1
alpha = 0.015

# 利用公钥实现单向加密
y = list()
for i in range(4):
    y.append(one_way_encrypt_vector(output_dataset[i],scaling_factor))

# 生成权重值
syn0_t = (np.random.randn(input_dim,hidden_dim) * 0.2) - 0.1
syn1_t = (np.random.randn(output_dim,hidden_dim) * 0.2) - 0.1

# 单向加密权重值
syn1 = list()
for row in syn1_t:
    syn1.append(one_way_encrypt_vector(row,scaling_factor).astype('int64'))

syn0 = list()
for row in syn0_t:
    syn0.append(one_way_encrypt_vector(row,scaling_factor).astype('int64'))


# 开始训练
for iter in range(1000):
    
    decrypted_error = 0
    encrypted_error = 0
    for row_i in range(4):

        if(row_i == 0):
            layer_1 = sigmoid(syn0[0])
        elif(row_i == 1):
            layer_1 = sigmoid((syn0[0] + syn0[1])/2.0)
        elif(row_i == 2):
            layer_1 = sigmoid((syn0[0] + syn0[2])/2.0)
        else:
            layer_1 = sigmoid((syn0[0] + syn0[1] + syn0[2])/3.0)

        layer_2 = (innerProd(syn1[0],layer_1,M_onehot[len(layer_1) - 2][0],l) / float(scaling_factor))[0:2]

        layer_2_delta = add_vectors(layer_2,-y[row_i])

        syn1_trans = transpose(syn1)

        one_minus_layer_1 = [(scaling_factor * c_ones[len(layer_1) - 2]) - layer_1]
        sigmoid_delta = elementwise_vector_mult(layer_1,one_minus_layer_1[0],scaling_factor)
        layer_1_delta_nosig = mat_mul_forward(layer_2_delta,syn1_trans,1).astype('int64')
        layer_1_delta = elementwise_vector_mult(layer_1_delta_nosig,sigmoid_delta,scaling_factor) * alpha

        syn1_delta = np.array(outer_product(layer_2_delta,layer_1)).astype('int64')

        syn1[0] -= np.array(syn1_delta[0]* alpha).astype('int64')

        syn0[0] -= (layer_1_delta).astype('int64')

        if(row_i == 1):
            syn0[1] -= (layer_1_delta).astype('int64')
        elif(row_i == 2):
            syn0[2] -= (layer_1_delta).astype('int64')
        elif(row_i == 3):
            syn0[1] -= (layer_1_delta).astype('int64')
            syn0[2] -= (layer_1_delta).astype('int64')


        # 为了监视训练情况，下面我将解码损失值
        # 如果当前环境并不安全，我会将加密后的损失值发送至安全的地方解码
        encrypted_error += int(np.sum(np.abs(layer_2_delta)) / scaling_factor)
        decrypted_error += np.sum(np.abs(s_decrypt(layer_2_delta).astype('float')/scaling_factor))

    
    sys.stdout.write(&quot;\r Iter:&quot; + str(iter) + &quot; Encrypted Loss:&quot; + str(encrypted_error) +  &quot; Decrypted Loss:&quot; + str(decrypted_error) + &quot; Alpha:&quot; + str(alpha))
    
    # 使输出更美观
    if(iter % 10 == 0):
        print()
    
    # 加密误差达到指定值后停止训练
    if(encrypted_error &amp;lt; 25000000):
        break
        
print(&quot;\nFinal Prediction:&quot;)

for row_i in range(4):

    if(row_i == 0):
        layer_1 = sigmoid(syn0[0])
    elif(row_i == 1):
        layer_1 = sigmoid((syn0[0] + syn0[1])/2.0)
    elif(row_i == 2):
        layer_1 = sigmoid((syn0[0] + syn0[2])/2.0)
    else:
        layer_1 = sigmoid((syn0[0] + syn0[1] + syn0[2])/3.0)

    layer_2 = (innerProd(syn1[0],layer_1,M_onehot[len(layer_1) - 2][0],l) / float(scaling_factor))[0:2]
    print(&quot;True Pred:&quot; + str(output_dataset[row_i]) + &quot; Encrypted Prediction:&quot; + str(layer_2) + &quot; Decrypted Prediction:&quot; + str(s_decrypt(layer_2) / scaling_factor))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; Iter:0 Encrypted Loss:84890656 Decrypted Loss:2.529 Alpha:0.015
 Iter:10 Encrypted Loss:69494197 Decrypted Loss:2.071 Alpha:0.015
 Iter:20 Encrypted Loss:64017850 Decrypted Loss:1.907 Alpha:0.015
 Iter:30 Encrypted Loss:62367015 Decrypted Loss:1.858 Alpha:0.015
 Iter:40 Encrypted Loss:61874493 Decrypted Loss:1.843 Alpha:0.015
 Iter:50 Encrypted Loss:61399244 Decrypted Loss:1.829 Alpha:0.015
 Iter:60 Encrypted Loss:60788581 Decrypted Loss:1.811 Alpha:0.015
 Iter:70 Encrypted Loss:60327357 Decrypted Loss:1.797 Alpha:0.015
 Iter:80 Encrypted Loss:59939426 Decrypted Loss:1.786 Alpha:0.015
 Iter:90 Encrypted Loss:59628769 Decrypted Loss:1.778 Alpha:0.015
 Iter:100 Encrypted Loss:59373621 Decrypted Loss:1.769 Alpha:0.015
 Iter:110 Encrypted Loss:59148014 Decrypted Loss:1.763 Alpha:0.015
 Iter:120 Encrypted Loss:58934571 Decrypted Loss:1.757 Alpha:0.015
 Iter:130 Encrypted Loss:58724873 Decrypted Loss:1.75 Alpha:0.0155
 Iter:140 Encrypted Loss:58516008 Decrypted Loss:1.744 Alpha:0.015
 Iter:150 Encrypted Loss:58307663 Decrypted Loss:1.739 Alpha:0.015
 Iter:160 Encrypted Loss:58102049 Decrypted Loss:1.732 Alpha:0.015
 Iter:170 Encrypted Loss:57863091 Decrypted Loss:1.725 Alpha:0.015
 Iter:180 Encrypted Loss:55470158 Decrypted Loss:1.653 Alpha:0.015
 Iter:190 Encrypted Loss:54650383 Decrypted Loss:1.629 Alpha:0.015
 Iter:200 Encrypted Loss:53838756 Decrypted Loss:1.605 Alpha:0.015
 Iter:210 Encrypted Loss:51684722 Decrypted Loss:1.541 Alpha:0.015
 Iter:220 Encrypted Loss:54408709 Decrypted Loss:1.621 Alpha:0.015
 Iter:230 Encrypted Loss:54946198 Decrypted Loss:1.638 Alpha:0.015
 Iter:240 Encrypted Loss:54668472 Decrypted Loss:1.63 Alpha:0.0155
 Iter:250 Encrypted Loss:55444008 Decrypted Loss:1.653 Alpha:0.015
 Iter:260 Encrypted Loss:54094286 Decrypted Loss:1.612 Alpha:0.015
 Iter:270 Encrypted Loss:51251831 Decrypted Loss:1.528 Alpha:0.015
 Iter:276 Encrypted Loss:24543890 Decrypted Loss:0.732 Alpha:0.015
 Final Prediction:
True Pred:[0] Encrypted Prediction:[-3761423723.0718255 0.0] Decrypted Prediction:[-0.112]
True Pred:[1] Encrypted Prediction:[24204806753.166267 0.0] Decrypted Prediction:[ 0.721]
True Pred:[1] Encrypted Prediction:[23090462896.17028 0.0] Decrypted Prediction:[ 0.688]
True Pred:[0] Encrypted Prediction:[1748380342.4553354 0.0] Decrypted Prediction:[ 0.052]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是我训练这个网络时得到的输出。因为加密噪声和低精度的问题模型调优会更困难一些，同时模型的训练也很慢，这是由于加密和解密操作的开销。虽然我也想做一些更简单的样例，但是从我们的主题和概念出发，首先要保证的是方案的安全性。&lt;/p&gt;
&lt;h3 id=&quot;重点&quot;&gt;重点：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;网络的权重全部是加密的。&lt;/li&gt;
&lt;li&gt;训练数据是未加密的。&lt;/li&gt;
&lt;li&gt;在训练之后，网络可以被解密以提高性能或二次训练（或切换到不同的加密密钥）。&lt;/li&gt;
&lt;li&gt;训练损失和输出的预测都是加密的值。我们必须解码它们才能解释网络的行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第9部分情感分类&quot;&gt;第9部分：情感分类&lt;/h2&gt;
&lt;p&gt;为了提供一些更真实的场景，这里提供了基于优达学城的纳米学位中的网络实现的情感分类网络，网络是在IMDB的评价上训练的。你可以在&lt;a href=&quot;https://github.com/iamtrask/iamtrask.github.io/blob/master/notebooks/VHE%252B-%252BSentiment%252BClassification.ipynb&quot;&gt;这里&lt;/a&gt;找到完整的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import time
import sys
import numpy as np

# 让我们调整之前的网络来适配这个问题
class SentimentNetwork:
    def __init__(self, reviews,labels,min_count = 10,polarity_cutoff = 0.1,hidden_nodes = 8, learning_rate = 0.1):
       
        np.random.seed(1234)
    
        self.pre_process_data(reviews, polarity_cutoff, min_count)
        
        self.init_network(len(self.review_vocab),hidden_nodes, 1, learning_rate)
        
        
    def pre_process_data(self,reviews, polarity_cutoff,min_count):
        
        print(&quot;Pre-processing data...&quot;)
        
        positive_counts = Counter()
        negative_counts = Counter()
        total_counts = Counter()

        for i in range(len(reviews)):
            if(labels[i] == 'POSITIVE'):
                for word in reviews[i].split(&quot; &quot;):
                    positive_counts[word] += 1
                    total_counts[word] += 1
            else:
                for word in reviews[i].split(&quot; &quot;):
                    negative_counts[word] += 1
                    total_counts[word] += 1

        pos_neg_ratios = Counter()

        for term,cnt in list(total_counts.most_common()):
            if(cnt &amp;gt;= 50):
                pos_neg_ratio = positive_counts[term] / float(negative_counts[term]+1)
                pos_neg_ratios[term] = pos_neg_ratio

        for word,ratio in pos_neg_ratios.most_common():
            if(ratio &amp;gt; 1):
                pos_neg_ratios[word] = np.log(ratio)
            else:
                pos_neg_ratios[word] = -np.log((1 / (ratio + 0.01)))
        
        review_vocab = set()
        for review in reviews:
            for word in review.split(&quot; &quot;):
                if(total_counts[word] &amp;gt; min_count):
                    if(word in pos_neg_ratios.keys()):
                        if((pos_neg_ratios[word] &amp;gt;= polarity_cutoff) or (pos_neg_ratios[word] &amp;lt;= -polarity_cutoff)):
                            review_vocab.add(word)
                    else:
                        review_vocab.add(word)
        self.review_vocab = list(review_vocab)
        
        label_vocab = set()
        for label in labels:
            label_vocab.add(label)
        
        self.label_vocab = list(label_vocab)
        
        self.review_vocab_size = len(self.review_vocab)
        self.label_vocab_size = len(self.label_vocab)
        
        self.word2index = {}
        for i, word in enumerate(self.review_vocab):
            self.word2index[word] = i
        
        self.label2index = {}
        for i, label in enumerate(self.label_vocab):
            self.label2index[label] = i
         
        
    def init_network(self, input_nodes, hidden_nodes, output_nodes, learning_rate):
        # 设置输入层，隐藏层和输出层的节点数
        self.input_nodes = input_nodes
        self.hidden_nodes = hidden_nodes
        self.output_nodes = output_nodes

        print(&quot;Initializing Weights...&quot;)
        self.weights_0_1_t = np.zeros((self.input_nodes,self.hidden_nodes))
    
        self.weights_1_2_t = np.random.normal(0.0, self.output_nodes**-0.5, 
                                                (self.hidden_nodes, self.output_nodes))
        
        print(&quot;Encrypting Weights...&quot;)
        self.weights_0_1 = list()
        for i,row in enumerate(self.weights_0_1_t):
            sys.stdout.write(&quot;\rEncrypting Weights from Layer 0 to Layer 1:&quot; + str(float((i+1) * 100) / len(self.weights_0_1_t))[0:4] + &quot;% done&quot;)
            self.weights_0_1.append(one_way_encrypt_vector(row,scaling_factor).astype('int64'))
        print(&quot;&quot;)
        
        self.weights_1_2 = list()
        for i,row in enumerate(self.weights_1_2_t):
            sys.stdout.write(&quot;\rEncrypting Weights from Layer 1 to Layer 2:&quot; + str(float((i+1) * 100) / len(self.weights_1_2_t))[0:4] + &quot;% done&quot;)
            self.weights_1_2.append(one_way_encrypt_vector(row,scaling_factor).astype('int64'))           
        self.weights_1_2 = transpose(self.weights_1_2)
        
        self.learning_rate = learning_rate
        
        self.layer_0 = np.zeros((1,input_nodes))
        self.layer_1 = np.zeros((1,hidden_nodes))
        
    def sigmoid(self,x):
        return 1 / (1 + np.exp(-x))
    
    
    def sigmoid_output_2_derivative(self,output):
        return output * (1 - output)
    
    def update_input_layer(self,review):

        # 清除之前的转台，将每层中的值置为0
        self.layer_0 *= 0
        for word in review.split(&quot; &quot;):
            self.layer_0[0][self.word2index[word]] = 1

    def get_target_for_label(self,label):
        if(label == 'POSITIVE'):
            return 1
        else:
            return 0
        
    def train(self, training_reviews_raw, training_labels):

        training_reviews = list()
        for review in training_reviews_raw:
            indices = set()
            for word in review.split(&quot; &quot;):
                if(word in self.word2index.keys()):
                    indices.add(self.word2index[word])
            training_reviews.append(list(indices))

        layer_1 = np.zeros_like(self.weights_0_1[0])

        start = time.time()
        correct_so_far = 0
        total_pred = 0.5
        for i in range(len(training_reviews_raw)):
            review_indices = training_reviews[i]
            label = training_labels[i]

            layer_1 *= 0
            for index in review_indices:
                layer_1 += self.weights_0_1[index]
            layer_1 = layer_1 / float(len(review_indices))
            layer_1 = layer_1.astype('int64') # round to nearest integer

            layer_2 = sigmoid(innerProd(layer_1,self.weights_1_2[0],M_onehot[len(layer_1) - 2][1],l) / float(scaling_factor))[0:2]

            if(label == 'POSITIVE'):
                layer_2_delta = layer_2 - (c_ones[len(layer_2) - 2] * scaling_factor)
            else:
                layer_2_delta = layer_2

            weights_1_2_trans = transpose(self.weights_1_2)
            layer_1_delta = mat_mul_forward(layer_2_delta,weights_1_2_trans,scaling_factor).astype('int64')

            self.weights_1_2 -= np.array(outer_product(layer_2_delta,layer_1))  * self.learning_rate

            for index in review_indices:
                self.weights_0_1[index] -= (layer_1_delta * self.learning_rate).astype('int64')

            # 我们希望这里同时可以进行解密以便我们观察网络训练情况
            total_pred += (s_decrypt(layer_2)[0] / scaling_factor)
            if((s_decrypt(layer_2)[0] / scaling_factor) &amp;gt;= (total_pred / float(i+2)) and label == 'POSITIVE'):
                correct_so_far += 1
            if((s_decrypt(layer_2)[0] / scaling_factor) &amp;lt; (total_pred / float(i+2)) and label == 'NEGATIVE'):
                correct_so_far += 1

            reviews_per_second = i / float(time.time() - start)

            sys.stdout.write(&quot;\rProgress:&quot; + str(100 * i/float(len(training_reviews_raw)))[:4] + &quot;% Speed(reviews/sec):&quot; + str(reviews_per_second)[0:5] + &quot; #Correct:&quot; + str(correct_so_far) + &quot; #Trained:&quot; + str(i+1) + &quot; Training Accuracy:&quot; + str(correct_so_far * 100 / float(i+1))[:4] + &quot;%&quot;)
            if(i % 100 == 0):
                print(i)

    
    def test(self, testing_reviews, testing_labels):
        
        correct = 0
        
        start = time.time()
        
        for i in range(len(testing_reviews)):
            pred = self.run(testing_reviews[i])
            if(pred == testing_labels[i]):
                correct += 1
            
            reviews_per_second = i / float(time.time() - start)
            
            sys.stdout.write(&quot;\rProgress:&quot; + str(100 * i/float(len(testing_reviews)))[:4] \
                             + &quot;% Speed(reviews/sec):&quot; + str(reviews_per_second)[0:5] \
                            + &quot;% #Correct:&quot; + str(correct) + &quot; #Tested:&quot; + str(i+1) + &quot; Testing Accuracy:&quot; + str(correct * 100 / float(i+1))[:4] + &quot;%&quot;)
    
    def run(self, review):
        
        # 输入层


        # 隐藏层
        self.layer_1 *= 0
        unique_indices = set()
        for word in review.lower().split(&quot; &quot;):
            if word in self.word2index.keys():
                unique_indices.add(self.word2index[word])
        for index in unique_indices:
            self.layer_1 += self.weights_0_1[index]
        
        # 输出层
        layer_2 = self.sigmoid(self.layer_1.dot(self.weights_1_2))
        
        if(layer_2[0] &amp;gt;= 0.5):
            return &quot;POSITIVE&quot;
        else:
            return &quot;NEGATIVE&quot;        &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Progress:0.0% Speed(reviews/sec):0.0 #Correct:1 #Trained:1 Training Accuracy:100.%0
Progress:0.41% Speed(reviews/sec):1.978 #Correct:66 #Trained:101 Training Accuracy:65.3%100
Progress:0.83% Speed(reviews/sec):2.014 #Correct:131 #Trained:201 Training Accuracy:65.1%200
Progress:1.25% Speed(reviews/sec):2.011 #Correct:203 #Trained:301 Training Accuracy:67.4%300
Progress:1.66% Speed(reviews/sec):2.003 #Correct:276 #Trained:401 Training Accuracy:68.8%400
Progress:2.08% Speed(reviews/sec):2.007 #Correct:348 #Trained:501 Training Accuracy:69.4%500
Progress:2.5% Speed(reviews/sec):2.015 #Correct:420 #Trained:601 Training Accuracy:69.8%600
Progress:2.91% Speed(reviews/sec):1.974 #Correct:497 #Trained:701 Training Accuracy:70.8%700
Progress:3.33% Speed(reviews/sec):1.973 #Correct:581 #Trained:801 Training Accuracy:72.5%800
Progress:3.75% Speed(reviews/sec):1.976 #Correct:666 #Trained:901 Training Accuracy:73.9%900
Progress:4.16% Speed(reviews/sec):1.983 #Correct:751 #Trained:1001 Training Accuracy:75.0%1000
Progress:4.33% Speed(reviews/sec):1.940 #Correct:788 #Trained:1042 Training Accuracy:75.6%&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第10部分数据加密的优势&quot;&gt;第10部分：数据加密的优势&lt;/h2&gt;
&lt;p&gt;与本文类似的一种实现方式是让网络在加密数据上进行训练并输出加密的预测值。这是一个很好的想法，但是仍有一些缺陷。首先，加密的数据意味着这些数据对于没有私钥的人来说是没有任何意义的这使得个人来源的数据无法在相同的深度学习网络上训练。但是大多数的商业应用又有这个需求，需要汇总消费者的数据。从理论上讲我们希望每个消费者有属于自己的一份私钥，但同态加密要求所有人共用一份私钥。&lt;/p&gt;
&lt;p&gt;但是，加密网络就不会受到这种限制了。&lt;/p&gt;
&lt;p&gt;用上面的方法，首先你经过一段时间训练得到了一个合格的神经网络，然后加密之后将公钥发送给A(A可以用他的数据继续训练网络一段时间），之后你拿回神经网络,用不同的密钥再次加密之后发给B方,B同样可以用他的数据训练网络。由于网络本身是加密的，你可以拥有网络智能的完全控制权.A和B无法知道他们用的是不是相同的网络，一切过程都是在他们看不到或者无法使用网络的前提下进行的。由此你可以保持对神经网络知识产权的控制，每个用户又可以保持自身数据的隐私性。&lt;/p&gt;
&lt;h2 id=&quot;第11部分未来的工作&quot;&gt;第11部分：未来的工作&lt;/h2&gt;
&lt;p&gt;会有更加安全更加快速的同态加密算法。我认为将工作移植到YASHE会是一个正确的选择。也许一个框架更适合用户使用进行加密,因为经过了系统的复杂抽象。大体来说,要使这些想法达到生产级的水平，同态加密必须要更快一点。不过这方面的进展也很迅速，我相信不久的将来就可以实现。&lt;/p&gt;
&lt;h2 id=&quot;第12部分潜在应用&quot;&gt;第12部分：潜在应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;去中心化的AI：&lt;/strong&gt; 公司可以直接在现场部署模型进行训练或使用而无需担心网络被盗取的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保护消费者隐私：&lt;/strong&gt; 上面提到的应用为用户掌控自己的数据提供了可能性,他们可以&quot;选择加入&quot;某些网络的训练而不是把自己的数据全部发送至某地。公司也无法利用网络下方对知识产权造成的风险来拒绝这一要求。数据是有着强大的力量，但它应当回归到用户手中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受控的超级智能：&lt;/strong&gt; 网络可以变得很聪明，但是只要它没有私钥，它做的预测就无法对外界造成影响。&lt;/p&gt;
&lt;blockquote readability=&quot;0.45985401459854&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/139359?fromSource=waitui&quot;&gt;如何使用人工智能合成人声？&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1180619?fromSource=waitui&quot;&gt;多个场景中的AI落地实践&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1179201?fromSource=waitui&quot;&gt;AI学院 | 人工智能基本知识概览&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1171675?fromSource=waitui&quot;&gt;人工智能，天使还是魔鬼&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1023?fromSource=waitui&quot;&gt;云学院 · 课程推荐 | 腾讯专项技术测试组长，结合8年经验为你细说冷热分离法则&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1043113?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://zhuanlan.zhihu.com/%20https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 03:42:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9553401.html</dc:identifier>
</item>
<item>
<title>你们都在用IntelliJ IDEA吗？或许你们需要看一下这篇博文 - Dawnzhang</title>
<link>http://www.cnblogs.com/clwydjgs/p/9390488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clwydjgs/p/9390488.html</guid>
<description>&lt;h2&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以前一直用的elipce，如今入坑IntelliJ IDEA，没想到啊。深深的爱上了它，强大到无所不能；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;&quot;工欲善其事必先利其器&quot;，IntelliJ IDEA作为一个非常好用的工具，他的神奇之处真的很多很多，掌握了这款idea的技巧之后，开发效率至少提升两倍以上，而且对一些英语不好的学习者也是非常友好，这篇文章详细的介绍了常用快捷键以及一些非常实用的小工具，感兴趣的小伙伴们赶快来学习；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;熟练掌握这些操作，编码速度与质量一定能得到一个质的飞跃；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;l&quot;&gt;一、视图查看&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+F12 查看file，method结构图、类继承机构图&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;不知道方法结构，Ctrl+F12一下，方法，参数，返回值，一清二楚的展现出来）&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+shift+Alt+U   查看maven依赖，类图&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　使用maven做项目时，依赖往往非常多，在配置依赖的文件中只需要Ctrl+shift+Alt+U，所有依赖都以拓扑图的方式展现出来，所有的关系和位置都能找到；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如下图（抱歉，项目依赖太多，具体的依赖需要放大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201808/1416523-20180829104206470-1225609821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类图：我们阅读源码的时候，想知道各个类之间的关系怎么办，Ctrl+shift+Alt+U，所有依赖都以拓扑图的方式展现出来，所有的关系和位置都能找到，以ArrayList为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201808/1416523-20180829105011225-1869001438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  Ctrl＋Alt+H   查看方法调用层次；&lt;/p&gt;
&lt;h3 class=&quot;l&quot;&gt;&lt;span&gt;二、定位&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;l&quot;&gt;&lt;span&gt;1.项目之间的跳转&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Alt+[　　跳转到下一个项目&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Alt+]　　跳转到上一个项目&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;l&quot;&gt;&lt;span&gt;2.文件之间的跳转&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+E　　 定位到最近浏览过的文件 &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Shift+E　　最近更改的文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Shift+Click　　可以关闭文件&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;l&quot;&gt;&lt;span&gt;3.位置的跳转&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Shift+Backspace　　 跳转上一次修改的地方&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Alt+B　　跳转到方法实现处&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Shift+左箭头　　上一个浏览的地方&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Shift+右箭头　　下一个浏览的地方&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;l&quot;&gt;&lt;span&gt;4.其他的跳转&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+H　　显示类结构图（类的继承层次）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ctrl+Q　　显示注释文档&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Alt+1　　快速打开或隐藏工程面板&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Alt+left/right　　切换代码视图&lt;/span&gt;&lt;br/&gt;&lt;span&gt;F2 或 Shift+F2　　高亮错误或警告快速定位&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Tab　　代码标签输入完成后，按 Tab，生成代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ctrl+Shift+F7　　高亮显示所有该文本，按 Esc 高亮消失&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;l&quot;&gt;&lt;span&gt;5.搜索&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl＋N　　快速搜索类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ctrl＋Shift＋N　　快速搜索文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl＋Alt+Shift＋N　　快速搜索函数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt; 三个里面都有Include non-porjecct items选项,勾选则表示非当前文件中的jar里面所有的类也会被查找；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730120221063-733339271.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;Ctrl+Shift+F　　快速搜索字符串&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;l&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730141352386-1143727543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; Alt+F1　　查找代码所在位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Alt+F3　　逐个往下查找相同文本，并高亮显示&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6.光标移动和选中&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;Ctrl＋Alt+Shift＋J 选中所有相应的目标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Alt+Up/Down　　在方法间快速移动定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ctrl+Shift+Up/Down　　向上/下移动语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;Ctrl+Up/Down　　光标中转到第一行或最后一行下&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;Ctrl+B/Ctrl+Click　　快速打开光标处的类或方法（跳转到定义处）&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、Alt+Enter&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;虽然只用一个组合按键，但是它的作用非常大&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.提供代码提示&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730153331600-501127149.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码报错只要alt+Enter一下，他就为我们提供了好了解决方案；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.自动创建函数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730153443205-1881173220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要写好函数名称，Alt+Enter一下，它就能帮我们自动创建好函数；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3.list replace&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;写完一个list用for遍历；Alt+Enter一下，他就告诉你还有更好的重构方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730154308256-1211402324.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回车它就能帮你重构好；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4.实现接口&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当我们需要实现接口的时候，只需要在接口的名称上Alt+Enter就能做到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730173208361-1962442572.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5.单词拼写&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;程序员好多都英语不好，Alt+Enter简直是他们的福音；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们拿不准一个单词拼写对不对的时候不放，Alt+Enter一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730173722491-761301538.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回车以后它能把相似的单词都列出来，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730173832542-745350719.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们只需要找到对的那个就ok，是不是很好用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;6.导包&lt;/h4&gt;
&lt;p&gt;当你需要使用某个包时，只需要把光标移动到想导包的名称上，Alt+Enter导入完成；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四、live Templates（模板）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730145906021-2048816036.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是定义了大量的模板，只用敲出小小的几个字母提示，就可以回车使用模板生成大量的代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家也可以在这里把常用的代码定义成模板，像main方法，for循环等等，方便快捷；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如public static final int可以定义成下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730151356394-1451017761.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不会自定义的点击查看：&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.imooc.com/video/16219&quot; target=&quot;_blank&quot;&gt;创建模板的教程&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;em&gt;五、postfix&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730151906834-1854712840.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;大家在写代码的时候，写完代码会用点来提示我们，例如，100. 敲完回车会生成一个for循环，用到的就是postfix，这是一种比 live Templates还快的小助手，当然它也是不可编辑的，里面定义了大量常见的函数和模板，熟练使用能提高我们很多的编码效率；&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;例如：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730153813690-2764368.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回车以后结果如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;  List&amp;lt;String&amp;gt; strings = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; strings.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             
&lt;span&gt;4&lt;/span&gt;         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;六、重构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;Shift+F6  重命名&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;所有的文件，类名，函数名，属性名都可以重命名，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得点赞的是，只要你使用Shift+F6重命名，所有使用过这个名称的地方都会跟着改变；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数的重构&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+F6 重构函数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当你需要重构方法时，无论是增加参数，修改返回值，还是更改函数实现，只需要Ctrl+F6，就可以把所有用到此函数的地方一起重构，界面如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730180908165-1883410403.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;七、抽取&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730182532496-85823209.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.抽取变量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730181722077-1608407271.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似于图中这样，很多地方都用到了“aaaaaa”这个字符串，很明显我们把“aaaaaa”抽取出来会更好；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对着它Ctrl+Alt+v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416523/201807/1416523-20180730182006124-1675460259.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们按照自己的需求，选择抽取一个还是抽取所有；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+Alt+C    抽取静态变量  &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+Alt+F    抽取成员变量  &lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用方法和抽取变量类似&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+Alt+P　　抽取方法参数&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;Ctrl+Alt+M　　抽取方法　　&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当一个方法长度过长的时候，只需要把代码分离成多个模块，选中各个模块只要Ctrl+Alt+M就能抽取为一个新的方法，我们只需要引用就好；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt; 其他的一些小技巧：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.每次写完代码都  Ctrl＋Alt+L 一下，代码美观又符合规范；&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;IntelliJ IDEA的功能真的是强大到爆裂，这只是总结了很少的一部分，欢迎大家在评论区补充；&lt;/h2&gt;

&lt;p&gt;相关文章：&lt;/p&gt;



</description>
<pubDate>Wed, 29 Aug 2018 03:30:00 +0000</pubDate>
<dc:creator>Dawnzhang</dc:creator>
<og:description>写在前面 以前一直用的elipce，如今入坑IntelliJ IDEA，没想到啊。深深的爱上了它，强大到无所不能； &quot;工欲善其事必先利其器&quot;，IntelliJ IDEA作为一个非常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clwydjgs/p/9390488.html</dc:identifier>
</item>
</channel>
</rss>