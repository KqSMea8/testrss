<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS开发——iOS国际化 APP内语言切换 - FrankieZ</title>
<link>http://www.cnblogs.com/FrankieZ/p/8552830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FrankieZ/p/8552830.html</guid>
<description>&lt;p&gt;最近一个一直在迭代的老项目收到一份新的开发需求，项目需要做国际化适配，简体中文+英文。由于项目中采用了storyboard和纯代码两种布局方式，所以国际化也要同时实现。上网查了些资料，实现了更改系统语言后，修改app内语言的问题。具体国际化方式可以参考下文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/88c1b65e3ddb&quot; target=&quot;_blank&quot;&gt;3分钟实现iOS语言本地化/国际化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章讲的比较详细，很容易实现。&lt;/p&gt;
&lt;p&gt;这个需求实现后不久，产品又给我提了一个需求，让我要在app内实现语言切换。还好之前的国际化也做了些准备，不慌不慌。&lt;/p&gt;
&lt;p&gt;接下来就是方案的选定，通过广泛查阅资料，得出两个备选方案：&lt;/p&gt;
&lt;p&gt;方案一：在原国际化版本的基础上做修改，在info.plist文件中新增key=&quot;appLanguage&quot;的键值对，保存用户设定的语言类别。通过切换语言类别来改变语言。（例子：微信）&lt;/p&gt;
&lt;p&gt;优点：之前有国际化操作的基础，执行起来并不复杂。&lt;/p&gt;
&lt;p&gt;缺点：切换完语言后，需要重新创建app keywindow的跟控制器，会有个跳转的过程，用户体验不好。&lt;/p&gt;
&lt;p&gt;方案二：切换语言后，发送通知，每个控制器收到通知后，更改语言。（例子：新浪微博）&lt;/p&gt;
&lt;p&gt;优点：很自然的切换语言，选择语言后即可切换，不需要重置根控制器，用户体验好。&lt;/p&gt;
&lt;p&gt;缺点：每个控制器都得注册接收通知，工作量太大，而且storyboard也得单独处理。&lt;/p&gt;
&lt;p&gt;综合两个方案的优缺点，我们选择方案一。&lt;/p&gt;
&lt;p&gt;中英切换，就是让App根据自身设置的语言去读取对应的国际化文件。在NSUserDefault中有一个字段：&quot;AppleLanguages&quot;，这个字段就是负责存储App语言的字段，默认这个字段会根据系统语言去变动，中文系统他就存储中文，英文系统就存储英文。&lt;/p&gt;
&lt;p&gt;废话少说，切换语言的过程上代：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NTVLocalized.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; NSString * &lt;span&gt;const&lt;/span&gt; AppLanguage = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;appLanguage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NTVLocalized : NSObject
&lt;/span&gt;+ (NTVLocalized *&lt;span&gt;)sharedInstance;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化多语言功能&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initLanguage;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前语言&lt;/span&gt;
- (NSString *&lt;span&gt;)currentLanguage;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要转换的语言&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为系统语言&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)systemLanguage;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NTVLocalized.m&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NTVLocalized.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NTVLocalized
&lt;/span&gt;+ (NTVLocalized *&lt;span&gt;)sharedInstance {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; NTVLocalized *instance =&lt;span&gt; nil;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        instance &lt;/span&gt;=&lt;span&gt; [[NTVLocalized alloc] init];
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initLanguage{
    NSString &lt;/span&gt;*language=&lt;span&gt;[self currentLanguage];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (language.length&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;自设置语言:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,language);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        [self systemLanguage];
    }
}

&lt;/span&gt;- (NSString *&lt;span&gt;)currentLanguage{
    NSString &lt;/span&gt;*language=&lt;span&gt;[[NSUserDefaults standardUserDefaults]objectForKey:AppLanguage];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; language;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language{
    [[NSUserDefaults standardUserDefaults] setObject:language forKey:AppLanguage];
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)systemLanguage{
    NSString &lt;/span&gt;*languageCode = [[NSUserDefaults standardUserDefaults] objectForKey:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;AppleLanguages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;系统语言:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,languageCode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;([languageCode hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]){
        languageCode &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简体中文&lt;/span&gt;
    }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;([languageCode hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]){
        languageCode &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;英语&lt;/span&gt;
&lt;span&gt;    }
    [self setLanguage:languageCode];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当语言设置完成后，需要重新设置keywindow的rootViewController才可以实现语言的切换。&lt;br/&gt;然而这样设置后，我们发现只有NSLocalizedString(key, comment)设置的语言才能正常显示我们需要的语言，storyBoard和xib配置的页面语言不跟着切换。&lt;br/&gt;设置AppleLanguages字段的话，只会在下次启动App才会生效，在App启动后就已经生成了一个Bundle，里面识别好了对应着AppleLanguages的国际化文件，在App运行期间设置这个字段，是不生效的，所以我们去修改这个Bundle，写一个NSBundle的扩展。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NSBundle+language.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NSBundle (language)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置语言&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NSBundle+language.m&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NSBundle+language.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; _bundle = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BundleEx : NSBundle

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; BundleEx

&lt;/span&gt;- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *&lt;span&gt;)tableName {
    NSBundle &lt;/span&gt;*bundle = objc_getAssociatedObject(self, &amp;amp;&lt;span&gt;_bundle);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bundle ?&lt;span&gt; [bundle localizedStringForKey:key value:value table:tableName] : [super localizedStringForKey:key value:value table:tableName];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSBundle (Language)

&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        object_setClass([NSBundle mainBundle], [BundleEx &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;]);
    });
    
    objc_setAssociatedObject([NSBundle mainBundle], &lt;/span&gt;&amp;amp;_bundle, language ? [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:language ofType:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;lproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新写一下设置语言的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language{
    [NSBundle setLanguage:language];
    [[NSUserDefaults standardUserDefaults] setObject:language forKey:AppLanguage];
    [[NSUserDefaults standardUserDefaults] synchronize];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上所述，只是修改appleLanguage，在不重启应用的情况下，不能修改语言。所以我们选择修改bundle的方法。&lt;br/&gt;代码在github上可以下载到：&lt;br/&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FFrankiezZZ%2FNTVLocalized&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/FrankiezZZ/NTVLocalized&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎各位小伙伴加入iOS交流群：140147825&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:36:00 +0000</pubDate>
<dc:creator>FrankieZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FrankieZ/p/8552830.html</dc:identifier>
</item>
<item>
<title>.NET Core使用skiasharp文字头像生成方案（基于docker发布） - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8519980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8519980.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前.NET Core下面针对于图像处理的库微软并没有集成，在.NET FrameWork下我们已经习惯使用System.Drawing类库做简单的图像处理，到了.NET Core下一脸懵逼的我，只能百度+谷歌看看有没啥解决方案，好在网上资料也多，.NET Core下的图像处理还是有些开源库的，我目前使用的其中一个：&lt;a href=&quot;https://github.com/mono/SkiaSharp&quot; target=&quot;_blank&quot;&gt;SkiaSharp&lt;/a&gt;，介绍反正大家自己网上找找都有，下面就用该库实现一个文字头像的小功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、简单的设计要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于输入的名字得解析（中文、英文）&lt;/li&gt;
&lt;li&gt;图片背景色随机会换&lt;/li&gt;
&lt;li&gt;文字要居中（废话，不居中不是丑爆了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三、具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、解析姓名信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ResolveName(String imageText)
        {
            imageText.Replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除路径不支持的信息&lt;/span&gt;
            imageText = imageText.Trim(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除空格信息&lt;/span&gt;
            String temp2 = imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据第一位的数据判断是走英文规则还是中文规则，都不是的话就是取前两位&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (RegexLib.IsChineseCharacter(temp2))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UserName = UserName.Trim(' ');&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt; &amp;amp; imageText.Length &amp;lt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(imageText.Length - &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (RegexLib.IsEnglishCharacter(temp2))
            {
                String[] temp1 &lt;/span&gt;= imageText.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp1.Length == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= (temp1[&lt;span&gt;0&lt;/span&gt;].Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + temp1[&lt;span&gt;1&lt;/span&gt;].Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)).ToUpper();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                    {
                        imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;).ToUpper();
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
            }
            imageName &lt;/span&gt;=&lt;span&gt; imageText;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imageName;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、根据文字生成图片&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] Create()
        {
            String name &lt;/span&gt;= imageName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            SKBitmap bmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SKBitmap(&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;);
            String str &lt;/span&gt;=&lt;span&gt; imageName;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (SKCanvas canvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKCanvas(bmp))
            {

                Random r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = r.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
                canvas.DrawColor(colors[num]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; colors是图片背景颜色集合，这里代码就不贴出来了，随机找一个&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (SKPaint sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKPaint())
                {
                    sKPaint.Color &lt;/span&gt;= SKColors.White;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体颜色&lt;/span&gt;
                    sKPaint.TextSize = &lt;span&gt;39&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;
                    sKPaint.IsAntialias = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启抗锯齿&lt;/span&gt;
                    sKPaint.Typeface = SkiaSharp.SKTypeface.FromFamilyName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, SKTypefaceStyle.Bold);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体&lt;/span&gt;
                    SKRect size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKRect();
                    sKPaint.MeasureText(str, &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt; size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算文字宽度以及高度&lt;/span&gt;
                    &lt;span&gt;float&lt;/span&gt; temp = (&lt;span&gt;128&lt;/span&gt; - size.Size.Width) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; temp1 = (&lt;span&gt;128&lt;/span&gt; - size.Size.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    canvas.DrawText(str, temp, temp1 &lt;/span&gt;- size.Top, sKPaint);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画文字&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存成图片文件&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (SKImage img =&lt;span&gt; SKImage.FromBitmap(bmp))
                {
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (SKData p = img.Encode(SKEncodedImageFormat.Jpeg, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;))
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.ToArray();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using (var stream = File.Create(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;photoImage&quot;, name)))
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    stream.Write(p.ToArray(), 0, p.ToArray().Length);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return stream;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我这边只是得到的是byte[]数组，如果需要转成stream或者保存成文件，方法都有，找找肯定都可以找到的，我就不放出来了，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;三、docker发布的坑&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;坑1：IIS下可以，docker下报错的坑爹问题&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于skiasharp在windows跟linux下使用的依赖库是不同的，如果都按照以前的方式部署，在docker里就会出现&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;code&gt;&lt;span&gt;The type initializer for 'SkiaSharp.SKImageInfo' threw an exception&quot;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;&lt;code&gt;,原因是linux下skiasharp依赖libSkiaSharp.so，而如果系统中没有libSkiaSharp.so，就会报这个错，目前我最简单的操作就是找到这个文件扔在skiasharp的目录下，然后就可以了&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;坑2：中文字体不识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于docker内部没有中文字体，SO，当要输出中文的时候就狗带了，如下图，所及解决办法那也就是把字体拷贝到docker内部中去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180312232413401-1144236284.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;下面提供我自己使用的Dockerfile，具体Dockerfile怎么用，那就只能大家自己百度百度（ps：其实真实原因是我自己这方面也是弱鸡- -，怕误导大家），我的环境是CentOS7.3的环境&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#基于 `microsoft/dotnet:latest&lt;span&gt;` 来构建我们的镜像
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; microsoft/dotnet:latest

#拷贝项目publish文件夹中的所有文件到 docker容器中的publish文件夹中  
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /publish /publish/


#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LANG C.UTF-8&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LANGUAGE C.UTF-8&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LC_ALL C.UTF-8
&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYH.TTC /usr/share/fonts/dejavu
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYHL.TTC /usr/share/fonts/dejavu
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYHBD.TTC /usr/share/fonts/dejavu

#更换软件源为国内的软件源
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot;&lt;span&gt; &amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list
#&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get update &amp;amp;&amp;amp; apt-get install -y libfontconfig1 &amp;amp;&amp;amp; apt-get install -y fontconfig
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get update &amp;amp;&amp;amp;  apt-get install -y fontconfig

#设置工作目录为 `/publish` 文件夹，即容器启动默认的文件夹
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /publish

#设置Docker容器对外暴露5000端口
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 5000&lt;span&gt;

#使用`dotnet WebApplication1.dll`来运行应用程序

&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt; [&quot;dotnet&quot;, &quot;WebApplication1.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　上张成功的图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180312232658971-1091860202.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;587&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　&lt;a href=&quot;https://pan.baidu.com/s/1pDEk1ToAtCtPJ83YwHKqsw&quot; target=&quot;_blank&quot;&gt;最后DEMO地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;docker是个好东西，只是我太弱鸡，大概需要花更多的时间去学习吧，程序员可能真的得&lt;strong&gt;活到老学到老！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;PS:以上的只是我自己摸索出来的，如果大家有更好的实现方式欢迎讨论，谢谢观看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　最后熊本熊镇随笔，该死的K8S，该死的docker！！！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180311204856835-1835894165.jpg&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;512&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关（最近被互联网架构搞的死去活来- -）&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，如有问题， 可站内留言联系.&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8519980.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（五）WPF依赖属性 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8552795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8552795.html</guid>
<description>&lt;p&gt;      在.NET中有事件也有属性，WPF中加入了路由事件，也加入了依赖属性。最近在写项目时还不知道WPF依赖属性是干什么用的，在使用依赖项属性的时候我都以为是在用.NET中的属性，但是确实上不是的，通过阅读文章和看WPF的书籍已经了解了WPF的依赖属性的使用，我们今天就来看看为什么WPF中要加入依赖属性？&lt;/p&gt;

&lt;p&gt;一、什么是依赖属性&lt;/p&gt;
&lt;p&gt;       WPF中的依赖属性有别于.NET中的属性，因为在WPF中有几个很重要的特征都是需要依赖项属性的支持，例如数据绑定，动画，样式设置等。WPF绝大多数属性都是依赖项属性，只不过它是用了普通的.NET属性过程进行了包装，通过这种包装，就可以像使用属性一样使用依赖项属性了，在后面会说一下怎么通过这种方式包装的。这就使用了旧技术来包装新技术的设计理念就不会干扰.NET。WPF中的依赖属性主要有以下三个优点：&lt;/p&gt;
&lt;p&gt;    1、依赖属性加入了属性变化通知、限制、验证等功能。这样可以使我们更方便地实现应用，同时大大减少了代码量。&lt;/p&gt;
&lt;p&gt;    2、节约内存：在WinForm中，每个UI控件的属性都赋予了初始值，这样每个相同的控件在内存中都会保存一份初始值。而WPF依赖属性很好地解决了这个问题，它内部实现使用哈希表存储机制，对多个相同控件的相同属性的值都只保存一份。&lt;/p&gt;
&lt;p&gt;      3、支持多种提供对象：可以通过多种方式来设置依赖属性的值。可以配合表达式、样式和绑定来对依赖属性设置值。&lt;/p&gt;

&lt;p&gt;     刚才我们一直在说属性，先来看看属性是什么吧。先创建一个类Person，里面有name属性。&lt;/p&gt;
&lt;p&gt;public class Person&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;       public string name{set;get;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;上面就是创建好的属性，看着是不是很简单。属性的创建就是这么简单，在我们想要使用这个类的地方初始化就能用。&lt;/p&gt;
&lt;p&gt;       既然说WPF中绝大多数的属性都是依赖项属性，我看了一下依赖属性怎么进行创建。&lt;/p&gt;
&lt;p&gt;        1、依赖属性的所在类型继承自DependencyObject类。&lt;/p&gt;
&lt;p&gt;        2、使用public static 声明一个DependencyProperty的变量，该变量就是真正的依赖属性。&lt;/p&gt;
&lt;p&gt;        3、类型的静态构造函数中通过Register方法完成依赖属性的元数据注册。&lt;/p&gt;
&lt;p&gt;        4、提供依赖属性的包装属性，通过这个属性来完成对依赖属性的读写操作。&lt;/p&gt;
&lt;p&gt;创建代码如下：&lt;/p&gt;
&lt;p&gt;//依赖属性必须在依赖对象DependencyObject&lt;/p&gt;
&lt;p&gt;Public class Person : DependencyObject &lt;/p&gt;
&lt;p&gt;{ &lt;/p&gt;
&lt;p&gt;    //CLR属性包装器，使得依赖属性NameProperty在外部能够像普通属性那样使用 &lt;/p&gt;
&lt;p&gt;    public string Name &lt;/p&gt;
&lt;p&gt;    { &lt;/p&gt;
&lt;p&gt;        get { return (string)GetValue(NameProperty); } &lt;/p&gt;
&lt;p&gt;        set { SetValue(NameProperty, value); } &lt;/p&gt;
&lt;p&gt;    } &lt;/p&gt;

&lt;p&gt; //依赖属性必须为static readonly&lt;/p&gt;
&lt;p&gt;//DependencyProperty.Register 参数说明&lt;/p&gt;
&lt;p&gt;//第一个参数是string类型的，是属性名。&lt;/p&gt;
&lt;p&gt;//第二个参数是这个依赖项属性的类型。&lt;/p&gt;
&lt;p&gt;//第三个参数是这个拥有这个依赖项属性的类型。&lt;/p&gt;
&lt;p&gt;//第四个参数是具有附加属性设置的FramWorkPropertyMetadata对象。&lt;/p&gt;
&lt;p&gt;    public static readonly DependencyProperty NameProperty = &lt;/p&gt;
&lt;p&gt;        DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Person), new PropertyMetadata(&quot;DefaultName&quot;)); &lt;/p&gt;

&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;      从上面代码可以看出，依赖属性是通过调用DependencyObject的GetValue和SetValue来对依赖属性进行读写的。它使用哈希表来进行存储的，对应的Key就是属性的HashCode值，而值（Value）则是注册的DependencyPropery；而C#中的属性是类私有字段的封装，可以通过对该字段进行操作来对属性进行读写。属性是字段的包装，WPF中使用属性对依赖属性进行包装。&lt;/p&gt;

&lt;p&gt;二、依赖属性的优先级&lt;/p&gt;
&lt;p&gt;       WPF 属性系统提供一种强大的方法，使得依赖属性的值由多种因素决定，从而实现诸如实时属性验证、后期绑定以及向相关属性发出有关其他属性值发生更改的通知等功能。 用来确定依赖属性值的确切顺序和逻辑相当复杂。 了解此顺序有助于避免不必要的属性设置，并且还有可能澄清混淆，使你正确了解为何某些影响或预测依赖属性值的尝试最终却没有得出所期望的值。依赖属性可以在多个位置“设置”,界面代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232459435-767291659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       本地属性集在设置时具有最高优先级，动画值和强制除外。 如果在本地设置某个值，你可以期待该值优先得到应用，甚至期待其优先级高于任何样式或控件模板。 在上面示例中，此处Background本地设置为红色。 因此，即使它是隐式样式，否则将会应用于该作用域中的该类型的所有元素，在此作用域中定义的样式不是最高优先级给予Background属性及其值。 如果从该 Button 实例中删除本地值红色，样式将获得优先级，而按钮将从该样式中获得 Background 值。 在该样式中，触发器具有优先级，因此当鼠标位于按钮上时，按钮为蓝色，其他情况下则为绿色。&lt;/p&gt;
&lt;p&gt;       下面的图是在网上找的依赖属性优先级列表图，大家后面再使用属性时可以留意一下优先级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232508531-1425020068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;三、依赖属性的继承&lt;/p&gt;
&lt;p&gt;      依赖属性的继承是WPF属性系统的一项功能。 属性值继承使元素树中的子元素可以从父元素获取特定属性的值，并继承该值，就如同它是在最近的父元素中任意位置设置的一样。 父元素可能也已通过属性值继承获得了其值，因此系统有可能一直递归到页面根。 属性值继承不是默认属性系统行为；属性必须用特定的元数据设置来建立，以便使该属性对子元素启动属性值继承。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232520800-92459507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        看到上面图片你可能已经发现了问题：StatusBar没有显式设置FontSize值，但它的字体大小没有继承Window.FontSize的值，而是保持了系统的默认值。导致这样的问题是因为并不是所有元素都支持属性值继承的，如StatusBar、Tooptip和Menu控件。另外，StatusBar等控件截获了从父元素继承来的属性，并且该属性也不会影响StatusBar控件的子元素。例如，如果我们在StatusBar中添加一个Button。那么这个Button的FontSize属性也不会发生改变，其值为默认值。&lt;/p&gt;
&lt;p&gt;四、自定义依赖属性    &lt;/p&gt;
&lt;p&gt;       如果想要依赖属性继承，我们可以进行自定义依赖属性继承属性值。&lt;/p&gt;
&lt;p&gt;自定义属性步骤：&lt;/p&gt;
&lt;p&gt;1、创建派生类CustomStackPanl&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232528313-993976264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建派生类CustomButton&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232536233-1086736460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、在window控件中引入命名空间&lt;/p&gt;
&lt;p&gt;   xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;&lt;/p&gt;
&lt;p&gt;3、在页面添加Button&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232544789-1078521248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232551908-289486033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;五、依赖属性验证和强制功能&lt;/p&gt;
&lt;p&gt;        在写代码是都会考虑可能发生的错误。在定义属性时，也需要考虑错误设置属性的可能性。对于传统.NET属性，可以在属性的设置器中进行属性值的验证，不满足条件的值可以抛出异常。但对于依赖属性来说，这种方法不合适，因为依赖属性通过SetValue方法来直接设置其值的。然而WPF有其代替的方式，WPF中提供了两种方法来用于验证依赖属性的值。&lt;/p&gt;
&lt;p&gt;       1、ValidateValueCallback:该回调函数可以接受或拒绝新值。该值可作为DependencyProperty.Register方法的一个参数。&lt;/p&gt;
&lt;p&gt;       2、CoerceValueCallback:该回调函数可将新值强制修改为可被接受的值。例如某个依赖属性工作年龄的值范围是25到55，在该回调函数中，可以对设置的值进行强制修改，对于不满足条件的值，强制修改为满足条件的值。如当设置为负值时，可强制修改为0。该回调函数PropertyMetadata构造函数参数进行传递。&lt;/p&gt;


</description>
<pubDate>Mon, 12 Mar 2018 15:28:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8552795.html</dc:identifier>
</item>
<item>
<title>SpringMVC 注解式开发 - hoje</title>
<link>http://www.cnblogs.com/hoje/p/8542532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoje/p/8542532.html</guid>
<description>&lt;p&gt;    SpringMVC的注解式开发是指，处理器是基于注解的类的开发。对于每一个定义的处理器，无需再配置文件中逐个注册，只需在代码中通过对类与方法的注解，便可完成注册。即注解替换是配置文件中对于处理器的注册部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、第一个注解式开发程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310172921640-742590810.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;%@page isELIgnored=&quot;false&quot; %&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 5&lt;/span&gt;   &amp;lt;head&amp;gt; 
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;title&amp;gt;welcome page&amp;lt;/title&amp;gt;
&lt;span&gt; 7&lt;/span&gt;   &amp;lt;/head&amp;gt;
&lt;span&gt; 8&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt;   &amp;lt;body&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ${message}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &amp;lt;/body&amp;gt;
&lt;span&gt;12&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;welcome.xml&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; @Controller &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前类是一个处理器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyController  {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;      @RequestMapping(&quot;/my.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView handleRequest(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         mv.addObject(&quot;message&quot;,&quot;hello SpringMVC World!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyController&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt; 3&lt;/span&gt;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt;         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
&lt;span&gt; 5&lt;/span&gt;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
&lt;span&gt; 6&lt;/span&gt;         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt; 7&lt;/span&gt;         xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;span&gt; 8&lt;/span&gt;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
&lt;span&gt; 9&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;  &amp;lt;!--   注册组件扫描器 --&amp;gt;
&lt;span&gt;19&lt;/span&gt;    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.jmu.handlers&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;springmvc.xml&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;   &amp;lt;display-name&amp;gt;01-springmvc-primary&amp;lt;/display-name&amp;gt;
&lt;span&gt; 4&lt;/span&gt;   &amp;lt;servlet&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;init-param&amp;gt;
&lt;span&gt; 8&lt;/span&gt;       &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
&lt;span&gt; 9&lt;/span&gt;       &amp;lt;param-value&amp;gt;classpath:springMVC.xml&amp;lt;/param-value&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/init-param&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&lt;span&gt;12&lt;/span&gt;   &amp;lt;/servlet&amp;gt;
&lt;span&gt;13&lt;/span&gt;   &amp;lt;servlet-mapping&amp;gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;url-pattern&amp;gt;*.&lt;span&gt;do&lt;/span&gt;&amp;lt;/url-pattern&amp;gt;
&lt;span&gt;16&lt;/span&gt;   &amp;lt;/servlet-mapping&amp;gt;
&lt;span&gt;17&lt;/span&gt;   &amp;lt;welcome-file-list&amp;gt;
&lt;span&gt;18&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
&lt;span&gt;19&lt;/span&gt;   &amp;lt;/welcome-file-list&amp;gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;/web-app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;web.xml&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173213702-1020286407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、处理器的请求映射规则的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）对请求URI的命名空间的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; A、一个处理器定义多个处理方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173911610-1522647593.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173918924-895773311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Controller &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前类是一个处理器&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyController{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;      @RequestMapping({&quot;/my.do&quot;,&quot;hello.do&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView doFirst(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         mv.addObject(&quot;message&quot;,&quot;执行doFirst()方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      @RequestMapping(&quot;/second.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView Second(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;              HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;          ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;          mv.addObject(&quot;message&quot;,&quot;执行doSecond()方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;          mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyController&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310181014647-1770111334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310182434471-489199689.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310182543886-362621368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)请求URI中通配符的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310191858345-1859824804.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3） 对请求提交方式的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312230811961-1083346134.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     @RequestMapping(value={&quot;/my.do&quot;,&quot;hello.do&quot;},method=RequestMethod.POST)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)对于请求中携带参数的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312232335365-218257387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312232357843-1940473335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:27:00 +0000</pubDate>
<dc:creator>hoje</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoje/p/8542532.html</dc:identifier>
</item>
<item>
<title>跨域请求的常用方式及解释 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8545462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8545462.html</guid>
<description>&lt;p&gt;首先基于安全的原因，浏览器是存在&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/JavaScript%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&quot;&gt;同源策略&lt;/a&gt;这个机制的，&lt;span&gt;同源策略阻止从一个域加载的脚本去获取另一个域上的文档属性。&lt;/span&gt;也就是说，受到请求的 URL 的域必须与当前 Web 页面的域相同。这意味着浏览器隔离来自不同源的内容，以防止它们之间的操作。&lt;/p&gt;
&lt;p&gt;js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要协议、域名、端口有任何一个不同，都被当作是不同的域。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;下面介绍几种常用的跨域请求方式&lt;/h2&gt;
&lt;p&gt;默认端口为：8080&lt;/p&gt;
&lt;h4&gt;一、利用jQuery获取jsonp&lt;/h4&gt;
&lt;h4&gt;JSONP的原理与实现思路&lt;/h4&gt;
&lt;p&gt;1）Web页面调用js文件，可跨域。扩展：&lt;span&gt;但凡有src属性的标签都具有跨域能力。&lt;/span&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
2）跨域服务器 动态生成数据 并存入js文件(通常json后缀)，供客户端调用。&lt;br data-filtered=&quot;filtered&quot;/&gt;
3）为了便于客户端使用数据，形成一个非正式传输协议，称为JSONP。&lt;span&gt;该协议重点是允许用户传递一个callback参数给服务器&lt;/span&gt;，然后服务器返回数据时 &lt;span&gt;将此callback参数作为函数名包裹住JSON数据&lt;/span&gt;，使得客户端可以随意定制自己的函数来自动处理返回数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 1.1如果我们不用跨域请求的写法的话：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312081219802-2131253364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2使用跨越请求的写法，最简单的就是设置dataType:jsonp：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jsonp指定服务器返回的数据类型为jsonp格式，可以看发起的请求路径，自动带了一个callback=xxx，xxx是jquery随机生成的一个回调函数名称。&lt;/p&gt;
&lt;p&gt;这里的success默认success()作为回调函数。数据返回到前端后，&lt;span&gt;就是success(result)的形式，因为是script脚本，所以自动调用success函数，而result就是success的参数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
       &lt;span&gt; dataType: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'jsonp'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)　　　　　　//后端代码
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String say(@RequestParam(&quot;callback&quot;&lt;span&gt;) String callback){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;callback前端传过来的回调函数名称

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了&lt;/span&gt;
        result = callback + &quot;(&quot; + result + &quot;)&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312082110792-150046606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1.3jsonpCallback&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用回调函数的时候，先调用了指定的showData，然后再调用了success。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        dataType: &lt;/span&gt;'jsonp'&lt;span&gt;,　　　&lt;span&gt;//指定服务器返回的数据类型&lt;/span&gt;　
        &lt;span&gt;jsonpCallback: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'showData'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,　　　&lt;span&gt;　//指定回调函数名称&lt;/span&gt;&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showData(data) {
    console.log(&lt;/span&gt;&quot;show&quot;+&lt;span&gt;data);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1.4jsonp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，比如{jsonp:'onJsonPLoad'}会导致将&quot;onJsonPLoad=?&quot;传给服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        dataType: &lt;/span&gt;'jsonp'&lt;span&gt;,
        jsonpCallback: &lt;/span&gt;'showData'&lt;span&gt;,
        &lt;span&gt;jsonp: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'sendParam'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,　　&lt;span&gt;//指定参数名称&lt;/span&gt;&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showData(data) {
    console.log(data);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定jsonp后，后端也要改变：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String say(@RequestParam(&lt;span&gt;&quot;sendParam&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;) String sendParam&lt;/span&gt;){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sendParam前端传过来的回调函数名称

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了&lt;/span&gt;
        result = sendParam + &quot;(&quot; + result + &quot;)&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312203459273-943117953.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1.5jsonp方式不支持POST方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;二、设置CORS头“Access-Control-Allow-Origin”&lt;/h4&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt; CORS的原理：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;     CORS定义一种跨域访问的机制，可以让AJAX实现跨域访问。CORS 允许一个域上的网络应用向另一个域提交跨域 AJAX 请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。&lt;/p&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;40.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(HttpServletRequest request, HttpServletResponse response){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应头&lt;/span&gt;
        &lt;span&gt;response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);　　//当前我设置的header为“*”，任意一个请求过来之后服务端我们都可以进行处理&amp;amp;响应&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　// 指定特定域名可以访问
     　 &lt;span&gt;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:localhost:8080/&quot;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312221546665-1940436512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;三、iframe+&lt;strong&gt;&lt;strong&gt;window.postMessage&lt;/strong&gt;实现跨域&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;script、image、iframe的src都不受同源策略的影响。所以我们可以借助这一特点，实现跨域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;postMessage(data,origin)方法接受两个参数&lt;/p&gt;
&lt;p&gt; 1.&lt;strong&gt;data&lt;/strong&gt;:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;origin&lt;/strong&gt;：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为&quot;*&quot;，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ifr&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:8081/girl/b.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ifr = document.getElementById(&quot;ifr&quot;&lt;span&gt;);
    ifr.contentWindow.postMessage(&lt;/span&gt;&quot;crsf&quot;,&quot;http://localhost:8081&quot;&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;接收消息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;b&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
window.addEventListener('message', function(event){&lt;br/&gt;console.log('origin: '+event.origin);　　　　//origin: http://localhost:8080&lt;br/&gt;console.log('data: '+event.data);　　　　　　//data: crsf&lt;br/&gt;console.log(event.source);&lt;br/&gt;// 回发数据&lt;br/&gt;event.source.postMessage('hello world', event.origin);&lt;br/&gt;});
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有几个重要属性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;origin&lt;/strong&gt;：发送消息窗口的源（协议+主机+端口号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：顾名思义，是传递来的message&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;source&lt;/strong&gt;：发送消息的窗口对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样就可以接收跨域的消息了，我们还可以发送消息回去。&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 12 Mar 2018 14:57:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8545462.html</dc:identifier>
</item>
<item>
<title>打造MacOS版“XShell” - mantou叔叔</title>
<link>http://www.cnblogs.com/mantoudev/p/8552613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantoudev/p/8552613.html</guid>
<description>&lt;p&gt;XShell作为一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。作为server端开发，几乎是必备工具了。&lt;/p&gt;
&lt;p&gt;很多刚切换到MacOS环境下的萌新都会面临一个尴尬的问题：XShell并没有提供MacOS版本，在NetSarang（XShell的爸爸）&lt;a href=&quot;https://www.netsarang.com/forum/xshell/1350/Xshell_for_OS_X&quot;&gt;论坛里&lt;/a&gt;群众们也已经向官方呐喊很多年了，却迟迟不见NetSarang有MacOS版本的消息。这对于已经使用习惯Xshell的开发同学无疑是个噩梦。&lt;/p&gt;
&lt;p&gt;记得我刚切到MacOS环境的时候，也是到处查有没有XShell的替代产品，更多的却看到的都是类似的回答：&lt;/p&gt;
&lt;p&gt;现在看看简直是觉得这些误导MacOS萌新回答都应该浸猪笼啊，MacOS自带的Terminal虽然具备ssh的功能，但是也非常不好用，根本满足不了我们高效工作的日常。&lt;/p&gt;
&lt;p&gt;下面开始介绍Mac终端的应该有的正确姿势。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/logo2x.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iTerm2作为MacOS下Terminal的替代品，支持MacOS v10.10 及以上版本。作为MacOS下最好用的终端应用，Iterm2具备以下特性：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分屏&lt;br/&gt;Iterm2可以把一个Tab分成多个窗口，每个窗口显示一个不同的会话。可以垂直、水平的创建任意数量的窗格。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;标签变色&lt;br/&gt;Iterm2的标签颜色会变化，以指示该tab当前状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;智能选中&lt;br/&gt;在iTerm2中，双击选中，三击选中整行，四击智能选中（规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在iTerm2中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动补齐&lt;br/&gt;iTerm2可以自动补齐命令，输入若干字符，按&lt;code&gt;⌘+;&lt;/code&gt;弹出自动补齐窗口，列出曾经使用过的命令。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/autocomplete.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;历史记录&lt;br/&gt;iTerm2也可以查询历史记录，按&lt;code&gt;⌘+shift+h&lt;/code&gt;弹出历史记录窗口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/pastehistory.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tab搜索&lt;br/&gt;按&lt;code&gt;⌘+option+e&lt;/code&gt;全屏展示所有tab，并可以进行搜索。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/expose.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高亮当前鼠标位置&lt;br/&gt;当我们一个标签页中窗口开的太多的时候，会有找不到鼠标指针的情况，按&lt;code&gt;⌘+/&lt;/code&gt;可以高亮鼠标位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/12/ExLxH.md.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有更多特性请查看&lt;a href=&quot;http://www.iterm2.com/features.html&quot;&gt;iTerm2官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Xshell非常的方便好用的是因为它能保存你所有的ssh登录帐号信息。MAC下并没有xshell，有些也提供这样的功能，但效果都不好。iTerm2是很好的终端，但却不能很好的支持多profiles，当要管理的机器较多时，就比较麻烦了。好在它有profiles设置，只是不能保存ssh登录帐号及密码，它还提供了加载profiles时执行外部命令的功能，因此，这里就可以使用sshpass来帮它执行。&lt;/p&gt;
&lt;h2 id=&quot;安装sshpass&quot;&gt;3.1 安装sshpass&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://sourceforge.net/projects/sshpass/files/&quot; class=&quot;uri&quot;&gt;http://sourceforge.net/projects/sshpass/files/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压后，进入sshpass目录，执行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./configure
$ make
$ make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sshpass -h&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置密码&quot;&gt;3.2 配置密码&lt;/h2&gt;
&lt;p&gt;让sshpass使用ssh密码，需要先将密码保存在一个文件里，再通过sshpass读文件来获取密码，iTerm2就可以通过这样的命令来登录主机，密码文件很简单，取一个好名字，把密码写进去就可以了，没有别的任何东西，如，在用户目录的sshpass目录建一个名为pass的文件，里面写上主机密码：123456，文件地址为：/Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/&amp;lt;密码文件&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;配置iterm2&quot;&gt;3.3 配置iTerm2&lt;/h2&gt;
&lt;p&gt;打开iTerm2 - Preferences - Profiles&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/12/Ex8rR.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加一个新的profile，其它没什么好配置的，主要是在General的command中选择使用command，命令就是sshpass的执行命令，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/bin/sshpass -f /Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/pwd1_file ssh -p22 root@192.168.100.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;/usr/local/bin/sshpass&lt;/code&gt;是sshpass执行文件的路径，如果按默认情况安装，它肯定会出现在这个位置上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 是告诉sshpass加载文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;/Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/pwd1_file&lt;/code&gt;就是要加载的文件，即前面建的密码文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ssh -p22 root@192.168.100.1&lt;/code&gt;是说用ssh链接，端口22，root帐号和IP地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;保存后，选择该profile，就可以实际ssh登录。只是如果是本机第一次登录，是不会成功的，因为ssh登录需要你yes确认，会写文件到hosts里，所以第一次会直接失败，再来一次或是先在终端里用ssh &lt;a href=&quot;mailto:root@ip来登录一次&quot;&gt;root@ip来登录一次&lt;/a&gt;，就可以了。&lt;/p&gt;
&lt;p&gt;这样，新建多个profile，就可以实现管理登录了。&lt;/p&gt;
&lt;p&gt;在实际使用过程中，iTerm配合oh-my-zsh能实现更加炫酷的功能，在后续博客中继续讲解oh-my-zsh的配置。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;br/&gt;[1] iTerm2 Feature：&lt;br/&gt;&lt;a href=&quot;http://www.iterm2.com/features.html&quot; class=&quot;uri&quot;&gt;http://www.iterm2.com/features.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 14:54:00 +0000</pubDate>
<dc:creator>mantou叔叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantoudev/p/8552613.html</dc:identifier>
</item>
<item>
<title>一个老王开枪案例带你一步一步领略程序开发的魅力 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　我身边的很多同学都认为学计算机专业的人，代码写的好很正常，认为自己不是学计算机专业的，不会写代码很正常，或者这么说，觉得会写代码是一种天赋。其实不然，我们现在必须要清楚当代社会的局势，当代社会朝着信息化的方向快速的发展，AI的时代即将到来，不会写代码的大学生是不是很low了？何况新加坡总统李显龙写代码都溜得飞起来，作为一个总统都会写代码，我们又何尝不要去学呢？几乎所有专业都有开设编程课程，这是一种思维的体操，把写代码当作一种娱乐也未尝不可？&lt;/p&gt;
&lt;p&gt;　　不要认为写代码是件很难的事情，没有人一出生就什么都会，天才也是要靠勤奋的吖！&lt;/p&gt;
&lt;p&gt;　　有些同学说，代码很长很难理解，看不懂。其实不管做什么事，你只要有耐心，肯钻研，多学多做多问，一切问题都能迎刃而解。&lt;/p&gt;
&lt;p&gt;　　下面我将从实际案例出发，带你体验程序开发独有的魅力，让你爱上编程！！！&lt;/p&gt;
&lt;h2&gt;二、案例及剖析&lt;/h2&gt;
&lt;p&gt;　　老王和隔壁的老宋是对老冤家，有一天老王回家，发现隔壁老宋和他妻子在家，多年的恩怨爆发了，老王跑到柜子里拿着一把枪直奔房间，老王开枪把隔壁老宋打死了，第二天老王就去公安局自首了。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201803/1100338-20180312222003986-195317406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可能有些同学会觉得这个故事很奇葩，很扯淡，emmmmm，反正都是编的故事，就不要在意这么多细节了hhhh，我们需要做的就是用程序来描述下老王开枪打死隔壁老宋这一过程&lt;/p&gt;
&lt;p&gt;　　有同学就会有疑问，不就是老婆跟别人跑了然后拿枪打死那个第三者嘛，这有什么好稀奇的？诶诶诶，计算机应该怎么去理解呢，我们应该怎么去设计这一过程呢？&lt;/p&gt;
&lt;p&gt;　　我们把这一过程概括为以下阶段：&lt;/p&gt;
&lt;p&gt; 　　#1. 创建老王对象&lt;/p&gt;
&lt;p&gt; 　　#2. 创建一个枪对象&lt;/p&gt;
&lt;p&gt;　　 #3. 创建一个弹夹对象&lt;/p&gt;
&lt;p&gt; 　　#4. 创建一些子弹&lt;/p&gt;
&lt;p&gt; 　　#5. 创建一个隔壁老宋&lt;/p&gt;
&lt;p&gt;　　 #6. 老王把子弹安装到弹夹中&lt;/p&gt;
&lt;p&gt; 　　#7. 老王把弹夹安装到枪中&lt;/p&gt;
&lt;p&gt; 　　#8. 老王拿枪&lt;/p&gt;
&lt;p&gt;　　 #9. 老王开枪打隔壁老宋&lt;/p&gt;
&lt;p&gt;这就是程序化的设计思想，到这里，大家是不是对这种程序化的思想多少了解了些呢？&lt;/p&gt;
&lt;p&gt;我们可以继续来看，要实现这一过程，我们将用到当前的主流语言Python来实现，具体过程如下：&lt;/p&gt;
&lt;p&gt;首先，我们先写出基本的框架：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用来控制整个程序的流程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1. 创建老王对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 创建一个枪对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 创建一个弹夹对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4. 创建一些子弹&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5. 创建一个敌人&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;6. 老王把子弹安装到弹夹中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7. 老王把弹夹安装到枪中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 老王拿枪&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;9. 老王开枪打敌人&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义一个main函数，用来控制整个程序的流程&lt;/p&gt;
&lt;p&gt;__name__ 是当前模块名，当模块被直接运行时模块名为 __main__ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。&lt;/p&gt;
&lt;p&gt;第一步，我们需要创建一个老王对象，我们可以这么去写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
laowang = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时需要调用到一个Person类，于是我们就需要去创建一个Person类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;人的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们传入了一个参数为老王，于是我们需要定义一个name的形参&lt;/p&gt;
&lt;p&gt;接着第二步，我们需要创建一个枪对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ak47 = Gun(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AK47&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们用到了一个Gun的类，并且传入了一个实参AK47，于是我们需要去创建一个这样的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gun(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步，我们需要创建一个弹夹对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dan_jia = Danjia(20)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们设置弹夹装的子弹数为20&lt;/p&gt;
&lt;p&gt;此时我们调用到了一个Danjia的类，我们继续去创建这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Danjia(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹夹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传入的参数max_num用来记录弹夹的最大容量&lt;/p&gt;
&lt;p&gt;第四步，我们需要去创建一些子弹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zi_dan = Zidan(10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，我们设置子弹数为10&lt;/p&gt;
&lt;p&gt;并且我们还需要创建一个Zidan的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zidan(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;子弹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, sha_shang_li):
        super(Zidan, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.sha_shang_li &lt;/span&gt;= sha_shang_li&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这颗子弹的威力&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们设置了子弹的威力参数，用sha_shang_li参数表示&lt;/p&gt;
&lt;p&gt;到现在为止，我们把所有对象都创建完了&lt;/p&gt;
&lt;p&gt;接下来我们需要对行为进行模拟&lt;/p&gt;
&lt;p&gt;我们来到第五步，我们需要设计出老王把子弹安装到弹夹中这一过程&lt;/p&gt;
&lt;p&gt;我们用中文进行模拟：&lt;/p&gt;
&lt;p&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/span&gt;
    laowang.anzhuang_zidan(dan_jia, zi_dan)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了一个anzhuang_zidan这一方法，结合实际生活，安装子弹这一过程是人来完成的，所以我们在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_zidan(self, dan_jia_temp, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把子弹装到弹夹中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.保存子弹(子弹)&lt;/span&gt;
        dan_jia_temp.baocun_zidan(zi_dan_temp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们需要弹夹去保存子弹，此时我们需要在弹夹中定义baocun_zidan这一方法，这一方法当然是在Danjia类中进行定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_zidan(self, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将这颗子弹保存&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.zidan_list.append(zi_dan_temp)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为了能够保存子弹，我们定义了一个列表zidan_list用来记录所有的子弹的引用，所以我们在Danjia类中进行初始化操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
        self.zidan_list = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录所有的子弹的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第五步到这里就实现完成了&lt;/p&gt;
&lt;p&gt;接着第六步老王把弹夹安装到枪中&lt;/p&gt;
&lt;p&gt;我们用更形象的语言来进行描述：&lt;/p&gt;
&lt;p&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/span&gt;
    laowang.anzhuang_danjia(ak47, dan_jia)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了一个anzhuang_danjia这一方法，结合实际生活，安装弹夹这一过程也是由人来完成的，所以我们在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_danjia(self, gun_temp, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把弹夹安装到枪中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.保存弹夹(弹夹)&lt;/span&gt;
        gun_temp.baocun_danjia(dan_jia_temp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们传入了两个参数gun_temp和dan_jia_temp，我们创建了一个gun_temp.baocun_danjia方法，用来保存弹夹，所以在Gun中，我们需要定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_danjia(self, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用一个属性来保存这个弹夹对象的引用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.danjia &lt;/span&gt;= dan_jia_temp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而对Gun类，我们需要进行初始化操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
        self.danjia = None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹对象的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们需要测试弹夹信息和枪的信息&lt;/p&gt;
&lt;p&gt;我们需要在弹夹中定义如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹的信息为:%d/%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(len(self.zidan_list), self.max_num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记录子弹的剩余数/子弹的最大容量&lt;/p&gt;
&lt;p&gt;而测试枪信息，我们在枪这一类中定义了如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.danjia:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.danjia)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s,这把枪中没有弹夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(self.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此我们测试完成了如上所有操作&lt;/p&gt;
&lt;p&gt;第七步老王拿枪，我们可以写出如下语句：&lt;/p&gt;
&lt;p&gt;老王.拿枪(枪)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.拿枪(枪)&lt;/span&gt;
    laowang.naqiang(ak47)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了naqiang这一方法，我们知道，只有人才会拿枪啊，所以我们需要在Person类中定义一个naqiang的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; naqiang(self, gun_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;拿起一把枪&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.gun &lt;/span&gt;= gun_temp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要去测试一下测试老王对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(laowang)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要测试一对象，我们需要定义些人的属性，比如hp，所以我们在Person类中进行初始化的添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gun &lt;/span&gt;= None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来保存枪对象的引用&lt;/span&gt;
        self.hp = 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开始进行一个测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.gun:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为:%d, 他有枪 %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp, self.gun)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为%d, 他没有枪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(self.name, self.hp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此我们完成了测试阶段&lt;/p&gt;
&lt;p&gt;第八步，我们去创建一个敌人&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 创建一个敌人&lt;/span&gt;
    gebi_laosong = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;隔壁老宋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(gebi_laosong)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再通过第九步，老王开枪打敌人&lt;/p&gt;
&lt;p&gt;我们可以写出如下语句：&lt;/p&gt;
&lt;p&gt;老王.扣扳机(隔壁老宋)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.扣扳机(隔壁老宋)&lt;/span&gt;
&lt;span&gt;    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(laowang)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们定义了一个kou_ban_ji的方法，通过调用这个方法，达到敌人hp减少的目的&lt;/p&gt;
&lt;p&gt;所以我们需要在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; kou_ban_ji(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让枪发射子弹去打敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.开火(敌人)&lt;/span&gt;
&lt;span&gt;
        self.gun.fire(diren)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且在此方法中又加定义了一个开枪的方法，而通过枪才能打出子弹，所以在Gun中定义了此方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fire(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先从弹夹中取子弹&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.弹出一发子弹()&lt;/span&gt;
        zidan_temp =&lt;span&gt; self.danjia.tanchu_zidan()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;让这个子弹去伤害敌人&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; zidan_temp:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子弹.打中敌人(敌人)&lt;/span&gt;
&lt;span&gt;            zidan_temp.dazhong(diren)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹中没有子弹了。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且我们进行了子弹数测试&lt;/p&gt;
&lt;p&gt;子弹要从弹夹中弹出去，我们继续在Danjia中定义tanchu_zidan方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tanchu_zidan(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹出最上面的那颗子弹&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.zidan_list:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.zidan_list.pop()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且子弹打中人会让人掉hp，所以我们需要在子弹中定义一个dazhong方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dazhong(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让敌人掉血&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;敌人.掉血(一颗子弹的威力)&lt;/span&gt;
&lt;span&gt;        diren.xiao_xue(self.sha_shang_li)
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;人会掉hp，继续在Person类中定义xiao_xue方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; xiao_xue(self, sha_shang_li):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据杀伤力，掉相应的血量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.hp &lt;/span&gt;-= sha_shang_li
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，通过测试，我们已经完成了整个流程的设计和开发，虽然很简单的一个问题，但是在程序设计阶段，每一步骤都是紧密相连的，这就是作为一个程序狗每天需要面对的问题，看起来很冗长，其实思路并不复杂，一个不懂程序的人都能看懂的执行步骤，我希望越来越多的人能够喜欢编程，我们国家缺的就是这种人才，只要每个人多贡献出自己的一份力量，AI的到来将离我们更近一步！！！&lt;/p&gt;
&lt;p&gt;附上以上所提到的源码，我进行了汇总，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;人的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gun &lt;/span&gt;= None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来保存枪对象的引用&lt;/span&gt;
        self.hp = 100

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_zidan(self, dan_jia_temp, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把子弹装到弹夹中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.保存子弹(子弹)&lt;/span&gt;
&lt;span&gt;        dan_jia_temp.baocun_zidan(zi_dan_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_danjia(self, gun_temp, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把弹夹安装到枪中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.保存弹夹(弹夹)&lt;/span&gt;
&lt;span&gt;        gun_temp.baocun_danjia(dan_jia_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; naqiang(self, gun_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;拿起一把枪&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.gun &lt;/span&gt;=&lt;span&gt; gun_temp

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.gun:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为:%d, 他有枪 %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp, self.gun)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.hp&amp;gt;&lt;span&gt;0:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为%d, 他没有枪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 已挂....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;self.name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; kou_ban_ji(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让枪发射子弹去打敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.开火(敌人)&lt;/span&gt;
&lt;span&gt;
        self.gun.fire(diren)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xiao_xue(self, sha_shang_li):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据杀伤力，掉相应的血量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.hp &lt;/span&gt;-=&lt;span&gt; sha_shang_li

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gun(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
        self.danjia = None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹对象的引用&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_danjia(self, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用一个属性来保存这个弹夹对象的引用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.danjia &lt;/span&gt;=&lt;span&gt; dan_jia_temp

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.danjia:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.danjia)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s,这把枪中没有弹夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fire(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先从弹夹中取子弹&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.弹出一发子弹()&lt;/span&gt;
        zidan_temp =&lt;span&gt; self.danjia.tanchu_zidan()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;让这个子弹去伤害敌人&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; zidan_temp:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子弹.打中敌人(敌人)&lt;/span&gt;
&lt;span&gt;            zidan_temp.dazhong(diren)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹中没有子弹了。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Danjia(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹夹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
        self.zidan_list = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录所有的子弹的引用&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_zidan(self, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将这颗子弹保存&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.zidan_list.append(zi_dan_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹的信息为:%d/%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(len(self.zidan_list), self.max_num)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tanchu_zidan(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹出最上面的那颗子弹&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.zidan_list:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.zidan_list.pop()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zidan(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;子弹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, sha_shang_li):
        super(Zidan, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.sha_shang_li &lt;/span&gt;= sha_shang_li&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这颗子弹的威力&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dazhong(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让敌人掉血&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;敌人.掉血(一颗子弹的威力)&lt;/span&gt;
&lt;span&gt;        diren.xiao_xue(self.sha_shang_li)
        

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用来控制整个程序的流程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1. 创建老王对象&lt;/span&gt;
    laowang = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 创建一个枪对象&lt;/span&gt;
    ak47 = Gun(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AK47&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 创建一个弹夹对象&lt;/span&gt;
    dan_jia = Danjia(20&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4. 创建一些子弹&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(15&lt;span&gt;):
        zi_dan &lt;/span&gt;= Zidan(10&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5. 老王把子弹安装到弹夹中&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/span&gt;
&lt;span&gt;        laowang.anzhuang_zidan(dan_jia, zi_dan)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6. 老王把弹夹安装到枪中&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/span&gt;
&lt;span&gt;    laowang.anzhuang_danjia(ak47, dan_jia)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试弹夹的信息&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(dan_jia)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试枪的信息&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ak47)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7. 老王拿枪&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.拿枪(枪)&lt;/span&gt;
&lt;span&gt;    laowang.naqiang(ak47)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试老王对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 创建一个敌人&lt;/span&gt;
    gebi_laosong = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;隔壁老宋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;9. 老王开枪打敌人&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.扣扳机(隔壁老宋)&lt;/span&gt;
&lt;span&gt;    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Mar 2018 14:51:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</dc:identifier>
</item>
<item>
<title>Django使用Celery异步任务队列 - MyStitch</title>
<link>http://www.cnblogs.com/StitchSun/p/8552488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StitchSun/p/8552488.html</guid>
<description>&lt;p&gt;Celery是异步任务队列，可以独立于主进程运行，在主进程退出后，也不影响队列中的任务执行。&lt;/p&gt;
&lt;p&gt;任务执行异常退出，重新启动后，会继续执行队列中的其他任务，同时可以缓存停止期间接收的工作任务，这个功能依赖于消息队列（MQ、Redis）。&lt;/p&gt;

&lt;h2&gt;1.1  Celery原理&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312220551760-1854792439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Celery的&lt;a title=&quot;大型网站架构知识库&quot; href=&quot;http://lib.csdn.net/base/architecture&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;架构&lt;/strong&gt;&lt;/a&gt;由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息中间件：Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，&lt;strong&gt;RabbitMQ&lt;/strong&gt;, &lt;a title=&quot;Redis知识库&quot; href=&quot;http://lib.csdn.net/base/redis&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/a&gt;, &lt;a title=&quot;MongoDB知识库&quot; href=&quot;http://lib.csdn.net/base/mongodb&quot; target=&quot;_blank&quot;&gt;MongoDB&lt;/a&gt; (experimental), Amazon SQS (experimental),CouchDB (experimental), SQLAlchemy (experimental),Django ORM (experimental), IronMQ。推荐使用：RabbitMQ、Redis作为消息队列。&lt;/li&gt;
&lt;li&gt;任务执行单元：Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。&lt;/li&gt;
&lt;li&gt;任务结果存储：Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, Redis，memcached, MongoDB，SQLAlchemy, Django ORM，Apache Cassandra, IronCache&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1.2     Celery适用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异步任务处理：例如给注册用户发送短消息或者确认邮件任务。&lt;/li&gt;
&lt;li&gt;大型任务：执行时间较长的任务，例如视频和图片处理，添加水印和转码等，需要执行任务时间长。&lt;/li&gt;
&lt;li&gt;定时执行的任务：支持任务的定时执行和设定时间执行。例如性能压测定时执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2.1     环境准备&lt;/h2&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;软件名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;版本号&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Centos 6.5（64bit）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;操作系统&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;3.5.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Django&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;1.10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Web框架&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Celery&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;4.0.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;异步任务队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Redis&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;2.4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;2.2     Celery安装&lt;/h2&gt;
&lt;p&gt;使用方法介绍：&lt;/p&gt;
&lt;p&gt;Celery的运行依赖消息队列，使用时需要安装redis或者rabbit。&lt;/p&gt;
&lt;p&gt;这里我们使用Redis。安装redis库:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo yum install redis
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动redis:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo service redis start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装celery库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo pip install celery==4.0.2
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3.1     编写任务&lt;/h2&gt;
&lt;p&gt;创建task.py文件&lt;/p&gt;
&lt;p&gt;说明：这里初始Celery实例时就加载了配置，使用的redis作为消息队列和存储任务结果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221014875-1701772480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行celery：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ celery -A task worker --loglevel=info
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;看到下面的打印，说明celery成功运行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221155056-676879418.png&quot; alt=&quot;&quot; width=&quot;915&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2     调用任务&lt;/h2&gt;
&lt;p&gt; 直接打开python交互命令行&lt;/p&gt;
&lt;p&gt; 执行下面代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221331437-644889172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以celery的窗口看到任务的执行信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221504903-2055971304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;任务执行状态监控和获取结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221553984-2135758219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;3.3     任务调用方法总结&lt;/h2&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;p&gt;delay和apply_async ，delay方法是apply_async简化版。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
add.delay(2, 2&lt;span&gt;)
add.apply_async((&lt;/span&gt;2, 2&lt;span&gt;))
add.apply_async((&lt;/span&gt;2, 2), queue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lopri&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;delay方法是apply_async简化版本。&lt;/p&gt;
&lt;p&gt;apply_async方法是可以带非常多的配置参数，包括指定队列等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Queue 指定队列名称，可以把不同任务分配到不同的队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.4     任务状态&lt;/h2&gt;
&lt;p&gt;每个任务有三种状态：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PENDING -&amp;gt; STARTED -&amp;gt; SUCCESS
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;任务查询状态：&lt;/p&gt;

&lt;p&gt;来查询任务的状态&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222001109-17549582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;上面简单介绍了celery异步任务的基本方法，结合我们实际的应用，我们需要与Django一起使用，下面介绍如何与Django结合。&lt;/p&gt;
&lt;h2&gt;4.1     与Django集成方法&lt;/h2&gt;
&lt;p&gt;与Django集成有两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Django 1.8 以上版本：与Celery 4.0版本集成&lt;/li&gt;
&lt;li&gt;Django 1.8 以下版本：与Celery3.1版本集成，使用django-celery库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我们介绍celery4.0 和django 1.8以上版本集成方法。&lt;/p&gt;
&lt;h2&gt;4.2     创建项目文件&lt;/h2&gt;
&lt;p&gt;创建一个项目：名字叫做proj&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- proj/
  - proj/&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
  &lt;/span&gt;- proj/&lt;span&gt;settings.py
  &lt;/span&gt;- proj/&lt;span&gt;urls.py
  &lt;/span&gt;- proj/&lt;span&gt;wsgi.py
&lt;/span&gt;- manage.py
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;创建一个新的文件：&lt;cite&gt;proj/proj/mycelery.py&lt;/cite&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; celery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Celery
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; set the default Django settings module for the 'celery' program.&lt;/span&gt;
os.environ.setdefault(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DJANGO_SETTINGS_MODULE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proj.settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
app &lt;/span&gt;= Celery(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Using a string here means the worker don't have to serialize&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the configuration object to child processes.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; - namespace='CELERY' means all celery-related configuration keys&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   should have a `CELERY_` prefix.&lt;/span&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Load task modules from all registered Django app configs.&lt;/span&gt;
app.autodiscover_tasks()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在proj/proj/__init__.py:添加&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; This will make sure the app is always imported when&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Django starts so that shared_task will use this app.&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; .mycelery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; app as celery_app
 
&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt; = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;celery_app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;4.3     配置Celery&lt;/h2&gt;
&lt;p&gt;我们在mycelery.py文件中说明celery的配置文件在settings.py中，并且是以CELERY开头。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;pre&gt;
   
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;在settings.py文件中添加celery配置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222151591-828225624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们的配置是使用redis作为消息队列，消息的代理和结果都是用redis，任务的序列化使用json格式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重要：redis：//127.0.0.1:6379/0这个说明使用的redis的0号队列，如果有多个celery任务都使用同一个队列，则会造成任务混乱。最好是celery实例单独使用一个队列。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.4     创建APP&lt;/h2&gt;
&lt;p&gt;创建Django的App，名称为celery_task，在app目录下创建tasks.py文件。&lt;/p&gt;
&lt;p&gt;完成后目录结构为：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── celery_task
│   ├── admin.py
│   ├── apps.py
│   ├── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── migrations
│   │   └── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── models.py
│   ├── tasks.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── manage.py
├── proj
│   ├── celery.py
│   ├── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── templates&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;4.5     编写task任务&lt;/h2&gt;
&lt;p&gt;编辑任务文件&lt;/p&gt;

&lt;p&gt;在tasks.py文件中添加下面代码&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your tasks here&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; celery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; shared_task&lt;br/&gt;@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y
 
@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mul(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; y
 
@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xsum(numbers):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum(numbers)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;启动celery:&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery worker -l info
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;说明：proj&lt;/em&gt;&lt;em&gt;为模块名称，mycelery&lt;/em&gt;&lt;em&gt;为celery&lt;/em&gt;&lt;em&gt;的实例所在的文件。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;启动成功打印：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222350827-358781690.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.6     在views中调用任务&lt;/h2&gt;
&lt;p&gt;在views中编写接口，实现两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;触发任务，然后返回任务的结果和任务ID&lt;/li&gt;
&lt;li&gt;根据任务ID查询任务状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222426345-1185482453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;启动django。&lt;/p&gt;
&lt;p&gt;新开一个会话启动celery；启动命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery –A proj.mycelery worker –l info
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问&lt;a href=&quot;http://127.0.0.1:8000/add&quot;&gt;http://127.0.0.1:8000/add&lt;/a&gt;，可以看到返回的结果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222906755-1720415155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在celery运行的页面，可以看到下面输出：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222927285-298528985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.7     在views中查询任务状态&lt;/h2&gt;
&lt;p&gt;有的时候任务执行时间较长，需要查询任务是否执行完成，可以根据任务的id来查询任务状态，根据状态进行下一步操作。&lt;/p&gt;
&lt;p&gt;可以看到任务的状态为：SUCCESS&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223045426-680539475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Celery作为异步任务队列，我们可以按照我们设置的时间，定时的执行一些任务，例如每日数据库备份，日志转存等。&lt;/p&gt;
&lt;p&gt;Celery的定时任务配置非常简单：&lt;/p&gt;
&lt;p&gt;定时任务的配置依然在setting.py文件中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：如果觉得celery&lt;/em&gt;&lt;em&gt;的数据配置文件和Django&lt;/em&gt;&lt;em&gt;的都在setting.py&lt;/em&gt;&lt;em&gt;一个文件中不方便，可以分拆出来，只需要在mycelery.py&lt;/em&gt;&lt;em&gt;的文件中指明即可。&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:yoursettingsfile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.1     任务间隔运行&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每30秒调用task.add&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timedelta

CELERY_BEAT_SCHEDULE &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add-every-30-seconds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tasks.add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: timedelta(seconds=30&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (16, 16&lt;span&gt;)
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.2     定时执行&lt;/h2&gt;
&lt;p&gt;定时每天早上7：30分运行。&lt;/p&gt;
&lt;p&gt;注意：设置任务时间时注意时间格式，UTC时间或者本地时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;crontab任务&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每天7:30调用task.add&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; celery.schedules &lt;span&gt;import&lt;/span&gt;&lt;span&gt; crontab

CELERY_BEAT_SCHEDULE &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Executes every Monday morning at 7:30 A.M&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add-every-monday-morning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tasks.add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: crontab(hour=7, minute=30&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (16, 16&lt;span&gt;),
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.3     定时任务启动&lt;/h2&gt;
&lt;p&gt;配置了定时任务，除了worker进程外，还需要启动一个beat进程。&lt;/p&gt;
&lt;p&gt;Beat进程的作用就相当于一个定时任务，根据配置来执行对应的任务。&lt;/p&gt;
&lt;h3&gt;5.3.1  启动beat进程&lt;/h3&gt;
&lt;p&gt;命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery beat -l info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223328256-792553965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.3.2  启动worker进程&lt;/h3&gt;
&lt;p&gt;Worker进程启动和前面启动命令一样。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery –A proj.mycelery worker –l info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223445916-928268073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Celery任务支持多样的运行模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持动态指定并发数 --autoscale=10,3 (always keep 3 processes, but grow to 10 if necessary).&lt;/li&gt;
&lt;li&gt;支持链式任务&lt;/li&gt;
&lt;li&gt;支持Group任务&lt;/li&gt;
&lt;li&gt;支持任务不同优先级&lt;/li&gt;
&lt;li&gt;支持指定任务队列&lt;/li&gt;
&lt;li&gt;支持使用eventlet模式运行worker&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：指定并发数为1000&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery worker -c 1000
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这些可以根据使用的深入自行了解和学习。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p&gt;Celery官网：&lt;/p&gt;
&lt;p&gt;http://docs.celeryproject.org/en/latest/index.html&lt;/p&gt;
&lt;p&gt;Celery与Django：&lt;/p&gt;
&lt;p&gt;http://docs.celeryproject.org/en/latest/getting-started/next-steps.html#next-steps&lt;/p&gt;
&lt;p&gt;celery定时任务：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sicofield/article/details/50937338&quot;&gt;http://blog.csdn.net/sicofield/article/details/50937338&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 14:41:00 +0000</pubDate>
<dc:creator>MyStitch</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StitchSun/p/8552488.html</dc:identifier>
</item>
<item>
<title>C#多线程编程（6）--线程安全2 互锁构造Interlocked - JAZzzzzzzz</title>
<link>http://www.cnblogs.com/jazzpop/p/8547880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jazzpop/p/8547880.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在线程安全1中，我介绍了线程同步的意义和一种实现线程同步的方法：volatile。volatile关键字属于原子操作的一种，若对一个关键字使用volatile，很多时候会显得很“浪费”，因为只有在并发访问的情况下才需要“易变”读写，单线程访问时并不需要。在命名空间System.Threading命名空间中提供了InterLock类，该类中提供了一些原子方法。本文来介绍如何使用这些方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;　　互锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　在抢占式系统中，一个线程在执行到任何阶段都有可能被其他线程“打断”，原子操作能够保证该操作不被其他线程打断，其他线程的“打断”只可能发生在该操作的之前或之后。InterLock类中的方法就是”原子“式的，最常用的方法有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterLock{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return (++location)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Increment(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; location);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return(--location)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Decrement(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; location);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return(location += value)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，也可能是负数，从而实现减法运算。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; location, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int old = location; location = value; return old;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Exchange(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; location, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;old = location1;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if(location1 = comparand) location1 = value;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return old;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareExchange(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; location1,
           &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; comparand);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　《CLR via C#》的作者在书中说他喜欢Interlocked中的方法，因为它不但很快，而且不会阻塞线程。为了验证InterLock真的很快，我们对变量进行一百万次的写，与Volatile.Write()来进行对比，看看是否真的快。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
     TestInterLock();
     Console.ReadLine();
 }
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestInterLock(){
     Stopwatch sw &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
         v&lt;/span&gt;++&lt;span&gt;;
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;volatile write 1000000 times takes:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sw.ElapsedMilliseconds);
     sw &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
         Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; n);
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterLock write 1000000 times takes:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sw.ElapsedMilliseconds);
     n &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     sw &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
         n&lt;/span&gt;++&lt;span&gt;;
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n++ write 1000000 times takes:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sw.ElapsedMilliseconds);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;volatile write 1000000 times takes:2&lt;/p&gt;
&lt;p&gt;InterLock write 1000000 times takes:8&lt;/p&gt;
&lt;p&gt;n++ write 1000000 times takes:2&lt;/p&gt;
&lt;p&gt;　　我运行了好几次，结果会有些出入，但是大部分的结果都是volatile的写入速度和原生的n++的速度是一样的。InterLock也确实如Jeffrey Richter所说，很快，只是没有volatile关键字修饰的变量的读写快。这是在非并发情况下，下面来看一下并发情况下是否还是很快。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestInterLock1(){
    Stopwatch sw &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
    Task[] t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
            Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; n);
    }), &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt; { 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
            Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; n);}) };
    Task[] t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
            v&lt;/span&gt;++&lt;span&gt;;
    }), &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt; { 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; i++&lt;span&gt;)
            v&lt;/span&gt;++&lt;span&gt;;}) };
    Task.WhenAll(t1)
        .ContinueWith(t &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;volatile write 2000000 times takes:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sw.ElapsedMilliseconds));
    Task.WhenAll(t2)
        .ContinueWith(t &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterLock write 2000000 times takes:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sw.ElapsedMilliseconds));
    t2[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Start();
    t1[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Start();
    t1[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Start();
    t2[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Start();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先看运行结果，&lt;/p&gt;
&lt;p&gt;volatile write 2000000 times takes:94&lt;br/&gt;InterLock write 2000000 times takes:101&lt;/p&gt;
&lt;p&gt;　　多次运行，运行时间会有不同，但是在并发情况下，volatile的写入和InterLock的写入速度几乎相同。上述代码写的如此丑陋，而不是直接写Task.Run()，是为了保证初始化部分都运行完成后，再Start()，且两个任务的先后顺序进行了打乱，最大限度减少误差。可以看到并发情况下，volatile和InterLock几乎一样，且在InterLock中的方法要比Volatile的功能要全，但是在串行时，Volatile的性能要比InterLock要好。结论是，若只对变量读写，没有替换或者其他复杂操作时，可以使用volatile关键字，但是一些复杂操作，需要原子操作时，就得使用InterLock中的方法了，如果使用volatile关键字修饰的变量来进行交换的话，很难保证原子性，只有引入锁才能保证线程同步。且InterLock中提供了几个重载方法，能够接受object类型，还有泛型版本。&lt;/p&gt;
&lt;p&gt;可以利用InterLock来实现一个简单的自旋锁，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SimpleSpinLock{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_Lock;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Enter(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt; m_Lock, &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处可以添加黑科技&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Leave(){
        Volatile.Write(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt; m_Lock, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是如何使用SimpleSpinLock的例子&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Simple{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SimpleSpinLock m_lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleSpinLock();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AccessResource(){
        m_lock.Enter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行某些程序，只有一个线程可以进入这里&lt;/span&gt;
&lt;span&gt;        m_lock.Leave();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个简单的自旋锁在一个线程调用Enter()时，其他线程在调用m_lock.Enter()方法时，if (Interlocked.Exchange(ref m_lock, 1) == 0)会失败，因为该方法会将m_lock和1交换，并返回旧值，在已有线程调用m_lock.Enter()时，m_lock的旧值是1，因此该方法会在whle(true)处自旋，不断尝试获得锁。该锁的问题是，该线程没有被阻塞（挂起），而是一直在占用CPU资源，其他需要CPU资源的线程无法运行（可以在while内，我加注释的地方，加入”黑科技“来尝试解决此问题。其思路是在线程自旋的过程中，立刻交出CPU资源，可通过调用Thread.Sleep(0)或者Thread.Yield()来实现。尝试获得锁的线程交出时间片，这样当前获得锁的线程能够有更多的资源来运行程序，从而运行结束并交出锁，具体细节在这里不展开）。因此，自旋锁只适合那些运行非常快的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Interlocked Anything 模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Interlocked中全部是原子性操作，那是否提供了一个方法，该方法可以接受一个委托，保证该委托在运行时是原子的。答案是没有，但是可以利用Interlocked.CompareExchange来自己实现一个。我们先来看一下利用CompareExchange来实现原子性的Maximum方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Maximum(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; target, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentValue =&lt;span&gt; target, startValue, desireValue;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
        startValue &lt;/span&gt;=&lt;span&gt; currentValue;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以在此处添加任何想要保证“原子性”的操作，此处是求最大值。&lt;/span&gt;
        desireValue =&lt;span&gt; Math.Max(startValue, value);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，此处有可能被其他线程抢占，也有可能target的值被修改，因此if()语句会出问题，要使用Interlocked的方法。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (startValue = target) target = desireValue;&lt;/span&gt;
        currentValue = Interlocked.CompareExchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; target, desireValue, startValue);
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若在此时target已被修改，则重新计算最大值&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (startValue !=&lt;span&gt; currentValue);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentValue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此方法的思路是：从CPU将target的值读到寄存器中，到计算最大值结束，期间的任何时间target都有可能被其他线程修改。因此保证原子性就被转换成保证计算最大值时，target的值没有变过，如果变过，就重新计算。因此，在最开始的时候，startValue=currentValue，currentValue是开始计算时target的值。然后求得最大值，并保存到desireValue中。注意，此时target有可能被修改，因此调用CompareExchange方法，该方法会将target与startValue比较，如果此时两值相等，那相当于我之前说的，target从开始到最后没有改变，那么这个最大值是准确的，并将target的旧值付给currentValue，最后如果startValue==currentValue，则计算完成，否则继续循环。&lt;/p&gt;
&lt;p&gt;　　《CLR via C#》的作者Jeff很喜欢上面的方法，他在实际开发中，都是使用上面的方法，并对其进行了包装，使之能够支持Interlocked Anything。其原理就是在desireValue=Math.Max()处替换成其他方法，只要在返回结果时保证旧值和最开始读取的值一致就可以。我们来看一下他的封装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Morpher&amp;lt;TResult, &lt;span&gt;in&lt;/span&gt; TArgument&amp;gt;(&lt;span&gt;int&lt;/span&gt; startValue, TArgument argument, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TResult result);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TResult Morph&amp;lt;TResult, TArgumen&amp;gt;(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; target, TArgumen argumen, Morpher&amp;lt;TResult, TArgumen&amp;gt;&lt;span&gt; morpher){
    TResult mophorResult;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentValue =&lt;span&gt; target, desireValue, startValue;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
        startValue &lt;/span&gt;=&lt;span&gt; currentValue;
        desireValue &lt;/span&gt;= morpher(startValue, argumen, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; mophorResult);
        currentValue &lt;/span&gt;= Interlocked.CompareExchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; target, desireValue, startValue);
    } 
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (currentValue !=&lt;span&gt; startValue);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mophorResult;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说实话，我并不能非常好了理解这个封装，并不是不能理解做法，而是不能确定此方法到底能不能实现效果，那我们来测试一下。测试的基本思路是对一个变量执行1000次的result+=10。分别是不带线程同步的和利用Morph方法对result+=10的方法进行互锁，保证其原子性。我省去了Morpher和Morph的声明部分。之所以要在DelayAdd和DelayAdd1方法中调用ThreadSleep(20)，是为了模拟当在运行较长的方法时，Morph方法是否还能够保证该方法运行的原子性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
    Test(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TestAction(Add), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Test(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TestAction(MorphAdd), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MorphAdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.ReadLine();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DelayAdd1的变种，使之能够符合Morpher的签名&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DelayAdd(&lt;span&gt;int&lt;/span&gt; startValue, &lt;span&gt;int&lt;/span&gt; argument, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result){
    Thread.Sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    result &lt;/span&gt;= startValue +&lt;span&gt; argument;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelayAdd1(&lt;span&gt;int&lt;/span&gt; argument, &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result){
    Thread.Sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    result &lt;/span&gt;+=&lt;span&gt; argument;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试的不具有线程同步的方法。&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result){
    DelayAdd1(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;ref&lt;/span&gt;&lt;span&gt; result);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具有线程同步的方法。&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MorphAdd(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result){
    Morph(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt; result, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Morpher&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(DelayAdd));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要测试的委托签名&lt;/span&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestAction(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; result);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公共测试方法&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test(TestAction action, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; actionName){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tList = &lt;span&gt;new&lt;/span&gt; Task[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
        tList[i] &lt;/span&gt;= Task.Run(() =&amp;gt;&lt;span&gt;
        {
            action(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; result);
        });
    Task.WhenAll(tList).GetAwaiter().OnCompleted(
        () &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}, Result is {1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, actionName, result));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行，得到的结果是：&lt;/p&gt;
&lt;p&gt;Add, Result is 8440&lt;br/&gt;MorphAdd, Result is 10000&lt;/p&gt;
&lt;p&gt;运行1000次result += 10，普通的Add不能够得到正确结果，但是MorphAdd可以。这是因为在1000次的Add中，某几个Add是同时调用的，result+=10在同一时间调用了多次，因此有156次的Add因为并行而被吞噬了。值得注意的是，MorphAdd方法因为需要线程同步，因此执行时间要慢很多。但是这些付出是值得的，因为这保证了结果的正确。&lt;/p&gt;
&lt;p&gt;　　上述例子证明了Morph方法能够保证委托的原子性，且该方法既不会阻塞线程也不会长时间的自旋，推荐大家在实际中使用该方法。&lt;/p&gt;
&lt;p&gt;　　本文中，我先介绍了Interlocked类中较常用的方法，以及Interlocked.Increment()方法与volatile关键字的对比，结论是虽然将变量设置为所有读写都是“易变的”看起来很浪费，但是该关键字能够保证在单线程时几乎没有性能损失，大部分情况下和原生的读写是一样的速度，且volatile比Interlocked类中提供的写要快2-4倍，但是在并发状态下其性能和volatile关键字是没有差别的。之后我介绍了用Interlocked类中的方法来实现简单的自旋锁，该锁的优点是在非竟态情况下非常快，但是在竟态情况下，未获得锁的线程会一直处于自旋状态，白白浪费CPU。最后介绍了《CLR via C#》书中提到的Interlocked Anything的方法（文中其他的知识点大多也是提取自《CLR via C#》），并测试了该方法确实可以保证委托的原子性，且不会阻塞线程，没有锁，不会造成死锁。至此线程同步中互锁构造就讲完了，后面我会给大家介绍内核构造的信号量和其他锁。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 13:43:00 +0000</pubDate>
<dc:creator>JAZzzzzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jazzpop/p/8547880.html</dc:identifier>
</item>
<item>
<title>[.NET]使用十年股价对比各种序列化技术 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/Serialize.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/Serialize.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;上一家公司有搞股票，当时很任性地直接从服务器读取一个股票10年份的股价（还有各种指标）在客户端的图表上显示，而且因为是桌面客户端，传输的数据也是简单粗暴地使用Soap序列化。获取报价的接口大概如下，通过symbol、beginDate和endDate三个参数获取股票某个时间段的股价：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; IEnumerable&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;LoadStockPrices&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; symbol,DateTime beginDate,DateTime endDate)
{
    &lt;span class=&quot;co&quot;&gt;//some code&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后来用Xamarin.Forms做了移动客户端，在手机上就不敢这么任性了，移动端不仅对流量比较敏感，而且显示这么多数据也不现实，于是限制为不可以获取这么长时间的股价，选择一种新的序列化方式也被提上了日程。不过当时我也快离职了所以没关心这件事。&lt;br/&gt;上周看到这篇问文章：&lt;a href=&quot;https://www.cnblogs.com/asxinyu/p/dotnet_stock_data_design.html&quot;&gt;【开源】C#.NET股票历史数据采集，【附18年历史数据和源代码】&lt;/a&gt;，一时兴起就试试用各种常用的序列化技术实现以前的需求。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;2. 数据结构&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;[Serializable]
[ProtoContract]
[DataContract]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; StockPrice
{
    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; ClosePrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DateTime Date { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; HighPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; LowPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; OpenPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; PrvClosePrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; Symbol { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; Turnover { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; Volume { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是股价的数据结构，包含股票代号、日期、OHLC、前收市价(PreClosePice)，成交额(Turnover)和成交量(Volume)，这里我已经把序列化要用到的Attribute加上了。&lt;/p&gt;
&lt;p&gt;测试数据使用長和(00001)2003年开始10年的股价，共2717条数据。为了方便测试已经把它们从数据库导出到文本文档。其实大小也就200K而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/38937/201803/38937-20180312143457263-1405370169.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;各种序列化技术&quot;&gt;3. 各种序列化技术&lt;/h2&gt;
&lt;p&gt;在.NET中要执行序列化有很多可以考虑的东西，如网络传输、安全性、.NET Remoting的远程对象等内容。但这里单纯只考虑序列化本身。&lt;/p&gt;
&lt;h3 id=&quot;二进制序列化&quot;&gt;3.1 二进制序列化&lt;/h3&gt;
&lt;p&gt;二进制序列化将对象的公共字段和私有字段以及类（包括含有该类的程序集）的名称都转换成字节流，对该对象进行反序列化时，将创建原始对象的准确克隆。除了.NET可序列化的类型，其它类型要想序列化，最简单的方法是使用 SerializableAttribute 对其进行标记。&lt;/p&gt;
&lt;p&gt;.NET中使用BinaryFormatter实现二进制序列化，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt; instance)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        IFormatter formatter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BinaryFormatter&lt;/span&gt;();
        formatter.&lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(stream, instance);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}


&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        IFormatter formatter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BinaryFormatter&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; target = formatter.&lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(stream);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; target &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; List&amp;lt;StockPrice&amp;gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;BinarySerializer&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;117&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;242,460&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;xml&quot;&gt;3.2 XML&lt;/h3&gt;
&lt;p&gt;XML序列化将对象的公共字段和属性或者方法的参数及返回值转换（序列化）为符合特定 XML架构定义语言 (XSD) 文档的 XML 流。由于 XML 是开放式的标准，因此可以根据需要由任何应用程序处理 XML流，而与平台无关。&lt;/p&gt;
&lt;p&gt;.NET中执行Xml序列化可以使用XmlSerializer：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt; instance)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; serializer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;Xml&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Serialization&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;XmlSerializer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt;));
        serializer.&lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(stream, instance);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; serializer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;Xml&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Serialization&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;XmlSerializer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt;));
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; target = serializer.&lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(stream);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; target &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; List&amp;lt;StockPrice&amp;gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下，因为XML格式为了有较好的可读性引入了一些冗余的文本信息，所以体积膨胀了不少：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;XmlSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;133&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;26&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;922,900&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;soap&quot;&gt;3.3 SOAP&lt;/h3&gt;
&lt;p&gt;XML 序列化还可用于将对象序列化为符合 SOAP 规范的 XML 流。 SOAP 是一种基于 XML 的协议，它是专门为使用 XML 来传输过程调用而设计的，熟悉WCF的应该不会对SOAP感到陌生。&lt;/p&gt;
&lt;p&gt;.NET中使用SoapFormatter实现序列化，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt; instance)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        IFormatter formatter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SoapFormatter&lt;/span&gt;();
        formatter.&lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(stream, instance.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        IFormatter formatter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SoapFormatter&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; target = formatter.&lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(stream);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (target &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; StockPrice[]).&lt;span class=&quot;fu&quot;&gt;ToList&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下，由于它本身的特性，体积膨胀得更可怕了（我记得WCF默认就是使用SOAP？）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SoapSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;105&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;123&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2,858,416&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;json&quot;&gt;3.4 JSON&lt;/h3&gt;
&lt;p&gt;JSON（JavaScript Object Notation）是一种由道格拉斯·克罗克福特构想和设计、轻量级的资料交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。&lt;/p&gt;
&lt;p&gt;虽然.NET提供了DataContractJsonSerializer，但Json.NET更受欢迎，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt; instance)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; serializer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DataContractJsonSerializer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt;));
        serializer.&lt;span class=&quot;fu&quot;&gt;WriteObject&lt;/span&gt;(stream, instance);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; serializer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DataContractJsonSerializer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt;));
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; target = serializer.&lt;span class=&quot;fu&quot;&gt;ReadObject&lt;/span&gt;(stream);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; target &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; List&amp;lt;StockPrice&amp;gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下，JSON的体积比XML小很多：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JsonSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;40&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;60&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;504,320&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;protobuf&quot;&gt;3.5 Protobuf&lt;/h3&gt;
&lt;p&gt;其实一开始我和我的同事就清楚用Protobuf最好。&lt;/p&gt;
&lt;p&gt;Protocol Buffers 是 Google提供的数据序列化机制。它性能高，压缩效率好，但是为了提高性能，Protobuf采用了二进制格式进行编码，导致可读性较差。&lt;/p&gt;
&lt;p&gt;使用protobuf-net需要将序列化的对象使用ProtoContractAttribute和ProtoMemberAttribute进行标记。序列化和反序列化代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(List&amp;lt;StockPrice&amp;gt; instance)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        Serializer.&lt;span class=&quot;fu&quot;&gt;Serialize&lt;/span&gt;(stream, instance);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPrice&amp;gt; &lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Serializer.&lt;span class=&quot;fu&quot;&gt;Deserialize&lt;/span&gt;&amp;lt;List&amp;lt;StockPrice&amp;gt;&amp;gt;(stream);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果十分优秀：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;93&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;18&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;211,926&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;结果对比&quot;&gt;3.6 结果对比&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;BinarySerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;117&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;242,460&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;XmlSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;133&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;26&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;922,900&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SoapSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;105&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;123&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2,858,416&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JsonSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;40&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;60&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;504,320&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;93&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;18&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;211,926&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将上述方案的结果列出来对比，Protobuf序列化后体积最少。不过即使是Protobuf，压缩后的数据仍然比文本文档的200K还大，那还不如直接传输这个文本文档。&lt;/p&gt;
&lt;h2 id=&quot;优化数据结构&quot;&gt;4. 优化数据结构&lt;/h2&gt;
&lt;p&gt;其实传输的数据结构上有很大的优化空间。&lt;/p&gt;
&lt;p&gt;首先是股票代号Symbol，前面提到获取股价的接口大概是这样：&lt;code&gt;IEnumerable LoadStockPrices(string symbol,DateTime beginDate,DateTime endDate)&lt;/code&gt;。既然都知道要获取的股票代号，StockPrice中Symbol这个属性完全就是多余的。&lt;/p&gt;
&lt;p&gt;其次是OHLC和PreClosePrice，港股（不记得其它Market是不是这样）的报价肯定是4位有效数字(如95.05和102.4)，用float精度也够了，不必用 double。&lt;/p&gt;
&lt;p&gt;最后是Date，反正只需要知道日期，不必知道时分秒，直接用与1970-01-01相差的天数作为存储应该就可以了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; DateTime _beginDate = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DateTime&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1970&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DateTime Date
{
    get =&amp;gt; _beginDate.&lt;span class=&quot;fu&quot;&gt;AddDays&lt;/span&gt;(DaysFrom1970);
    set =&amp;gt; DaysFrom1970 = (&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;) Math.&lt;span class=&quot;fu&quot;&gt;Floor&lt;/span&gt;((value - _beginDate).&lt;span class=&quot;fu&quot;&gt;TotalDays&lt;/span&gt;);
}

[&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)]
[DataMember]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; DaysFrom1970 { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要以为Volume可以改为int，有些仙股有时会有几十亿的成交量，超过int的最大值2147483647（顺便一提Int32的最大值是2的31次方减1，有时面试会考）。&lt;/p&gt;
&lt;p&gt;这样修改后的类结构如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;[Serializable]
[ProtoContract]
[DataContract]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; StockPriceSlim
{
    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; ClosePrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; DateTime _beginDate = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DateTime&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1970&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DateTime Date
    {
        get =&amp;gt; _beginDate.&lt;span class=&quot;fu&quot;&gt;AddDays&lt;/span&gt;(DaysFrom1970);
        set =&amp;gt; DaysFrom1970 = (&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;) Math.&lt;span class=&quot;fu&quot;&gt;Floor&lt;/span&gt;((value - _beginDate).&lt;span class=&quot;fu&quot;&gt;TotalDays&lt;/span&gt;);
    }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; DaysFrom1970 { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; HighPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; LowPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; OpenPrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; PrvClosePrice { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; Turnover { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }

    [&lt;span class=&quot;fu&quot;&gt;ProtoMember&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)]
    [DataMember]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; Volume { &lt;span class=&quot;kw&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列化的体积大幅减少：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;BinarySerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;141,930&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;XmlSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;42&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;977,248&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SoapSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;48&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;89&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2,586,720&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JsonSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;17&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;33&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;411,942&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;130,416&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其实之所以有这么大的优化空间，一来是因为传输的对象本身就是ORM生成的对象没针对网络传输做优化，二来各个券商的数据源差不多都是这样传输数据的，最后，本来这个接口是给桌面客户端用的根本就懒得考虑传输数据的大小。&lt;/p&gt;
&lt;h2 id=&quot;自定义的序列化&quot;&gt;5. 自定义的序列化&lt;/h2&gt;
&lt;p&gt;由于股票的数据结构相对稳定，而且这个接口不需要通用性，可以自己实现序列化。StockPriceSlim所有属性加起来是38个字节，测试数据是2717条报价，共103246字节，少于Protobuf的130416字节。要达到每个报价只存储38个字节，只需将每个属性的值填入固定的位置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;SerializeSlim&lt;/span&gt;(List&amp;lt;StockPriceSlim&amp;gt; instance)
{
    &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; List&amp;lt;&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; (var item &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; instance)
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;DaysFrom1970&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;OpenPrice&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;HighPrice&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;LowPrice&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;ClosePrice&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;PrvClosePrice&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;Volume&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);

        bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;(item.&lt;span class=&quot;fu&quot;&gt;Turnover&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
}


&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPriceSlim&amp;gt; &lt;span class=&quot;fu&quot;&gt;DeserializeSlim&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; List&amp;lt;StockPriceSlim&amp;gt;();
    &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (index &amp;lt; source.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;)
        {
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; price = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;StockPriceSlim&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)];
            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;));
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; days = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToInt16&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;DaysFrom1970&lt;/span&gt; = days;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)];
            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;));
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;OpenPrice&lt;/span&gt; = value;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;));
            value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;HighPrice&lt;/span&gt; = value;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;));
            value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;LowPrice&lt;/span&gt; = value;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;));
            value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;ClosePrice&lt;/span&gt; = value;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;));
            value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;PrvClosePrice&lt;/span&gt; = value;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;)];
            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;));
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; volume = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToDouble&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;Volume&lt;/span&gt; = volume;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;)];
            stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;));
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; turnover = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToDouble&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            price.&lt;span class=&quot;fu&quot;&gt;Turnover&lt;/span&gt; = turnover;
            index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;

            result.&lt;span class=&quot;fu&quot;&gt;Add&lt;/span&gt;(price);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CustomSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这种方式不仅序列化后的体积最小，而且序列化和反序列化的速度都十分优秀，不过代码十分难看而且没有扩展性。尝试用反射改进一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;SerializeSlim&lt;/span&gt;(List&amp;lt;StockPriceSlim&amp;gt; instance)
{
    &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; List&amp;lt;&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;&amp;gt;();
    &lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; (var item &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; instance)
        &lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; (var property &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(StockPriceSlim).&lt;span class=&quot;fu&quot;&gt;GetProperties&lt;/span&gt;())
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;GetCustomAttribute&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(DataMemberAttribute)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;

            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; value = property.&lt;span class=&quot;fu&quot;&gt;GetValue&lt;/span&gt;(item);
            &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;))
                bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)value);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;))
                bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)value);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;))
                bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)value);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;))
                bytes = BitConverter.&lt;span class=&quot;fu&quot;&gt;GetBytes&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;)value);
            result.&lt;span class=&quot;fu&quot;&gt;AddRange&lt;/span&gt;(bytes);
        }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; List&amp;lt;StockPriceSlim&amp;gt; &lt;span class=&quot;fu&quot;&gt;DeserializeSlim&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; stream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; List&amp;lt;StockPriceSlim&amp;gt;();
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (index &amp;lt; source.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;)
        {
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; price = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;StockPriceSlim&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; (var property &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(StockPriceSlim).&lt;span class=&quot;fu&quot;&gt;GetProperties&lt;/span&gt;())
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;GetCustomAttribute&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(DataMemberAttribute)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;

                &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                &lt;span class=&quot;dt&quot;&gt;object&lt;/span&gt; value = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;))
                {
                    bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)];
                    stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;);
                    value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToInt32&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;))
                {
                    bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)];
                    stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;);
                    value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToInt16&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;))
                {
                    bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)];
                    stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;);
                    value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToSingle&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (property.&lt;span class=&quot;fu&quot;&gt;PropertyType&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;))
                {
                    bytes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;)];
                    stream.&lt;span class=&quot;fu&quot;&gt;Read&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;);
                    value = BitConverter.&lt;span class=&quot;fu&quot;&gt;ToDouble&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
                }

                property.&lt;span class=&quot;fu&quot;&gt;SetValue&lt;/span&gt;(price, value);
                index += bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;;
            }


            result.&lt;span class=&quot;fu&quot;&gt;Add&lt;/span&gt;(price);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ReflectionSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;413&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;431&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;好像好了一些，但性能大幅下降。我好像记得有人说过.NET会将反射缓存让我不必担心反射带来的性能问题，看来我的理解有出入。索性自己缓存些反射结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;PropertyInfo&amp;gt; _properties;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ExtendReflectionSerializer&lt;/span&gt;()
{
    _properties = &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(StockPriceSlim).&lt;span class=&quot;fu&quot;&gt;GetProperties&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;Where&lt;/span&gt;(p =&amp;gt; p.&lt;span class=&quot;fu&quot;&gt;GetCustomAttribute&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(DataMemberAttribute)) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;ToList&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ExtendReflectionSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这样改进后性能还可以接受。&lt;/p&gt;
&lt;h2 id=&quot;最后试试压缩&quot;&gt;6. 最后试试压缩&lt;/h2&gt;
&lt;p&gt;最后试试在序列化的基础上再随便压缩一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;SerializeWithZip&lt;/span&gt;(List&amp;lt;StockPriceSlim&amp;gt; instance)
{
    &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; bytes = &lt;span class=&quot;fu&quot;&gt;SerializeSlim&lt;/span&gt;(instance);

    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; memoryStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
    {
        &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; deflateStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeflateStream&lt;/span&gt;(memoryStream, CompressionLevel.&lt;span class=&quot;fu&quot;&gt;Fastest&lt;/span&gt;))
        {
            deflateStream.&lt;span class=&quot;fu&quot;&gt;Write&lt;/span&gt;(bytes, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, bytes.&lt;span class=&quot;fu&quot;&gt;Length&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; memoryStream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;StockPriceSlim&amp;gt; &lt;span class=&quot;fu&quot;&gt;DeserializeWithZip&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] source)
{
    &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; originalFileStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;(source))
    {
        &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; memoryStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MemoryStream&lt;/span&gt;())
        {
            &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; decompressionStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeflateStream&lt;/span&gt;(originalFileStream, CompressionMode.&lt;span class=&quot;fu&quot;&gt;Decompress&lt;/span&gt;))
            {
                decompressionStream.&lt;span class=&quot;fu&quot;&gt;CopyTo&lt;/span&gt;(memoryStream);
            }
            &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; bytes = memoryStream.&lt;span class=&quot;fu&quot;&gt;ToArray&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeserializeSlim&lt;/span&gt;(bytes);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果看来不错：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;BinarySerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;141,930&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;22&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;72,954&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;XmlSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;42&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;977,248&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;28&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;108,839&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SoapSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;48&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;89&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2,586,720&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;61&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;87&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;140,391&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JsonSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;17&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;33&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;411,942&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;35&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;90,125&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;130,416&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;65,644&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CustomSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;57,697&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ReflectionSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;413&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;431&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;401&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;376&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;59,285&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ExtendReflectionSerializer&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;103,246&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;13&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;14&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;59,285&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;结语&quot;&gt;7. 结语&lt;/h2&gt;
&lt;p&gt;满足了好奇心，顺便复习了一下各种序列化的方式。&lt;/p&gt;
&lt;p&gt;因为原来的需求就很单一，没有测试各种数据量下的对比。&lt;/p&gt;
&lt;p&gt;虽然Protobuf十分优秀，但在本地存储序列化文件时为了可读性我通常都会选择XML或JSON。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;8. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/serialization/binary-serialization&quot;&gt;二进制序列化&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/serialization/xml-and-soap-serialization&quot;&gt;XML 和 SOAP 序列化&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.newtonsoft.com/json&quot;&gt;Json.NET&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/google/protobuf&quot;&gt;Protocol Buffers - Google's data interchange format&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;9. 源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DinoChan/StockDataSample&quot;&gt;StockDataSample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 12:59:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dino623/p/Serialize.html</dc:identifier>
</item>
</channel>
</rss>