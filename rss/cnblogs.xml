<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>快速了解聚集索引与非聚集索引 - tomkluas</title>
<link>http://www.cnblogs.com/tomkluas/p/8504768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tomkluas/p/8504768.html</guid>
<description>&lt;h2&gt;一、数据库访问方式有两种&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　1、表扫描&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;从表的物理起点开始浏览表中的每一行，如果筛选条件，则包含在结果集中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;2、&lt;strong&gt;索引&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;使用B树查找数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、索引分类&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;先解释下几个概念&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;堆&lt;/span&gt;：没有聚集索引的表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;聚集表&lt;/span&gt;：含有聚集索引的表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;B树&lt;/span&gt;：平衡树，试图提供一种一致的、成本相对较低的方法，以找到一条特定的信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　索引分为3种， 如何理解呢？ 新建一张operlog表示例，没加主键（创建主键会默认创建一个唯一聚集索引）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;operlog&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;operdate&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;oper&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　&lt;span&gt;1、聚集索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　 &lt;span&gt;以下为创建聚集索引：　　&lt;span&gt;Operlog_id为聚集索引&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建了聚集索引&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;CLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; Operlog_id &lt;span&gt;ON&lt;/span&gt; dbo.operlog(id)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每个表中只能有一个聚集索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;页节点存放的是真正数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;新数据按着他在聚集索引里正确的物理顺序插入&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;　　&lt;strong&gt;&lt;span&gt;2、非聚集索引&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）堆上的非聚集索引&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 以下为创建对上的聚集索引： 　　&lt;span&gt;Operlog_oper为非聚集索引&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建了非聚集索引（只有此语句）&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;NONCLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; Operlog_oper &lt;span&gt;ON&lt;/span&gt; dbo.operlog(oper)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　特点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;页节点存放的是数据指针（RID：由特定行的区段、页、行偏移量组成）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有可能出现多次访问同一个数据页，导致查询慢（不过也可能数据页被内存缓存了，速度不一定慢）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2）聚集索引上的非聚集索引（或称聚集表上的非聚集索引） &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 以下为创建聚集表上的非聚集索引：　　Operlog_id为聚集索引，&lt;span&gt;Operlog_oper为聚集表上的非聚集索引&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建了聚集索引&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;CLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; Operlog_id &lt;span&gt;ON&lt;/span&gt;&lt;span&gt; dbo.operlog(id)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建了聚集表上的非聚集索引&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;NONCLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; Operlog_oper &lt;span&gt;ON&lt;/span&gt; dbo.operlog(oper)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　   &lt;span&gt;特点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;页节点存放的是聚集键，在找到节点后仍要继续按聚集索引查找&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果以此索引查找，可能会比&lt;strong&gt;&quot;堆上的非聚集索引&quot;&lt;/strong&gt;查找还慢，因为他多了一步按聚集索引查找，如果数据量大的话，会比&lt;strong&gt;&quot;堆上的非聚集索&quot;&lt;/strong&gt;引多很多开销&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;三、详细介绍&lt;/h2&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、聚集索引&lt;/span&gt;&lt;/strong&gt;： 数据叶节点就是真正数据，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/464031/201803/464031-20180304135720670-811376052.png&quot; alt=&quot;&quot; width=&quot;744&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;2、堆上的非聚集索引&lt;/strong&gt;&lt;/span&gt;：叶节点存储的不是真正的数据，而是指向数据的指针，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/464031/201803/464031-20180304140117354-1845994712.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;3、聚集表上的非聚集索引&lt;/strong&gt;&lt;/span&gt;：叶节点存储的不是真实数据，也不是数据的指针，而是聚集键，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/464031/201803/464031-20180304140545162-1963326221.png&quot; alt=&quot;&quot; width=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、如何选择什么时候用什么样的索引？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;索引不是万能的！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;如果经常做增加修改，尽量少用索引，因为增加会导致重建索引，修改是先删除后增加索引，都会增加开销&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非聚集索引：列的唯一值百分比越高越好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;聚集索引：每个表只有一个，所以尽量在表创建时确定好，以防后期修改维护麻烦&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用Sql Server Profiler分析&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　本文参考《sql server 2008高级程序设计》，如有错误，敬请指正！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Mar 2018 07:17:00 +0000</pubDate>
<dc:creator>tomkluas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tomkluas/p/8504768.html</dc:identifier>
</item>
<item>
<title>.NET微服务架构及API网关 - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/8504602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/8504602.html</guid>
<description>&lt;h2 id=&quot;magicdomid2&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-CAH9dshDs7kGkr43&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;一、MSA简介&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;magicdomid3&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-E4Ow2Uj6qjBEaTUN&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;1.1、MSA是什么&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;微服务架构MSA是Microservice Architecture的简称，它是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相通讯、互相配合，为用户提供最终价值。&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;它与SOA之间的区别如下：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid5&quot; class=&quot;gutter-author-3423802 table-div locate lineguid-4LBYxuQ8R3thtYoy&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;div class=&quot;iframe-container&quot;&gt;&lt;br/&gt;&lt;div class=&quot;shadow-table&quot;&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;SOA实现&lt;/td&gt;
&lt;td&gt;微服务架构实现&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;企业级，自顶向下开展实施&lt;/td&gt;
&lt;td&gt;团队级，自底向上开展实施&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;粒度大：服务由多个子系统组成&lt;/td&gt;
&lt;td&gt;粒度细：一个系统被拆分成多个服务，且服务的定义更加清晰&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;重ESB：企业服务总线，集中式的服务架构&lt;/td&gt;
&lt;td&gt;轻网关：无集中式总线，松散的服务架构&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;开发过程复杂&lt;/td&gt;
&lt;td&gt;易开发：减少了企业ESB开发的复杂性，与敏捷开发的思想高度结合在一起&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;单块架构系统，相互依赖，部署复杂&lt;/td&gt;
&lt;td&gt;服务能被独立部署&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;magicdomid6&quot; class=&quot;gutter-author-3423802 locate lineguid-2PVY4ZuGg6eAEoqS&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-4&quot;&gt;&lt;span&gt;1.2、我们的MSA框架&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;我们的&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;微服务框架MsaFx.dll&lt;span class=&quot;author-3423802&quot;&gt;是个基于ServiceStack 4.0.60包装实现的.NET Web Services框架，而ServiceStack本身支持通用的轻量级协议和Metadata。&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;MsaFx&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;与普通&lt;span class=&quot;author-3423802&quot;&gt;Web S&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;ervices框架如WCF相比，主要优势如下&lt;span class=&quot;author-3423802 b&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;高性能：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;性能好、速度快。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;支持跨平台运行：&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;基于M&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;saFx&lt;span class=&quot;author-3423802&quot;&gt;开发出的Web Services既能够运行在Windows环境中，又能够运行在支持Mono的Linux环境中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;支持多协议：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;如&lt;span class=&quot;author-3423802&quot;&gt;JSON格式的也支持XSD。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;4、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;更加Web化：&lt;/strong&gt;RESTful。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;5、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;服务端实现与客户端实现的完全解耦：&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;MSA基于消息的设计，使得服务端的API改变并不会破坏现有的客户端，达到服务端实现与客户端实现完全解耦的目的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;6、  &lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;MSA API可视化说明文档便于你调试。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;7、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;易学：&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;使用MSA进行开发和维护服务所需的技术和时间投入要小很多。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;8、  &lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;易用：&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;简化了REST以及WCF SOAP风格的Web Services的开发过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid16&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-gr0AwzQ40biwomB7&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;1.3、MSA框架实现架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;MSA服务端的架构请见下图的第一张图，MSA的HTTP客户端架构请见下图的第二张图。MSA的内部是建立在原生的ASP.NET IHttpHandler之上实现的，支持JSON、XML、JSV、HTML、Message Pack、ProtoBuf、CSV等消息格式。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid18&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-seRcBl91WBjHwf85&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304144853552-355661799.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;MSA服务端的架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid21&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-NaBRSr0J1kRIzzpr&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304144942004-171669313.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 upload-image img-irjyMUnePxlRB9a1 image-width-1212 image-height-535&quot;&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;MSA HTTP Client的架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid23&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-Y8htgI19AprorUL6&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;二、MSA框架的使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;magicdomid24&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-cModOY7YwZuMPRxS&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、服务托管&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;服务端的服务对外提供服务前，必须先要把服务端给托管起来。MSA提供了通过IIS、Self-Host等多种形式把服务端给托管起来，宿主环境可以是控制台应用或Windows Service或ASP.NET Web应用或ASP.NET MVC应用。提供的MSA Demo的宿主环境用的是ASP.NET Web应用。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid26&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-OKndnfvLOQjBlcgE&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;2、 路由&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;A、MSA自身提供的默认路由是：/[xml|json|html|jsv|csv]/[reply|oneway]/[Request DTO名] [(?query参数1={值}&amp;amp;query参数2={值}&amp;amp;......&amp;amp;query参数n={值})]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;B、创建自定义路由，其创建方法是：使用RouteAttribute或在宿主环境中配置。提供的MSA Demo采用的是在&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;宿主环境中配置路由这种方式&lt;span class=&quot;author-3423802&quot;&gt;来创建自定义路由。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid29&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-MryyQGK736IVXjsa&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;3、如何验证请求参数的合法性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;如果你需要在提交请求参数前，验证请求参数是否必填或是否合法，那么验证逻辑必须写在继承自MSA的AbstractValidator&amp;lt;TRequest&amp;gt;的类里（参考例子请见MSA Demo的OrderValidator.cs），然后在宿主环境中进行开启验证的配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-vEa5S9CgKEUA4gXH&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Plugins.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValidationFeature()); 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; container.RegisterValidator(&lt;span&gt;typeof&lt;/span&gt;(OrderValidator));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;magicdomid33&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-fBwZmIEIkT39ONaZ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;4、服务&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;创建MSA服务时，必须继承来自MSA的Service类。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid35&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-yxv23eSkuN9aflmn&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;5、MSA内置的客户端&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;5.1、&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;MSA内置了一些便捷访问的客户端，这些对象都实现了&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;IServiceClien&lt;span class=&quot;author-3423802&quot;&gt;t接口，其中支持REST的客户端还都实现了IRestClient接口。这些客户端对象包括：JsonServiceClient、JsvServiceClient、XmlServiceClient、MsgPackServiceClient、ProtoBufServiceClient、Soap11ServiceClient、Soap12ServiceClient等。从名称可以看出，这几种不同之处在于支持的序列化和反序列化格式不同。因为它们实现的是相同的接口，所以它们的用法相同，也可以相互替换。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;MSA Demo中用到了JsonServiceClient和ProtoBufServiceClient这两种客户端，其中当用到ProtoBufServiceClient客户端时，你还需要完成如下工作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;a、  除了需要引用MSA.dll外，还需要引用protobuf-net.dll。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;b、  需要在宿主环境中进行如下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-nEyH1g2akkMmOoj5&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Plugins.Add(&lt;span&gt;new&lt;/span&gt; ProtoBufFormat());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;c、必须分别给Request DTO对象和Response DTO对象的各属性标上[DataMember(Order = {0})]特性，具体写法请见MSA Demo的ProductRequestDTO.cs和ProductResponseDTO.cs。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt;5.2、&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;MSA内置的客户端提供Get、Send、Post、Put、Delete等方法。查询数据一般用Get方法，新增操作一般用Post方法，更新操作一般用Put方法，删除操作一般用Delete方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;这些方法都有重载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;以下是Get方法的其中一个签名：&lt;span class=&quot;author-3423802&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-tfZHpBTIoBrjawDN&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; TResponse Get&amp;lt;TResponse&amp;gt;(IReturn&amp;lt;TResponse&amp;gt; requestDto);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;magicdomid47&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-oVVlaLZrpKSrqQAA&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;6、MSA API可视化说明文档自动生成的实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;在宿主环境中加如下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-gXPByhNViFS0tl9E&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Plugins.Add(&lt;span&gt;new&lt;/span&gt; SwaggerFeature());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;如果需要在MSA API可视化说明文档中能够看到各请求参数、响应的含义说明，那么需要为Request DTO、Response DTO对象的各属性标上ApiMember，代码参考如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderRequest : IReturn&amp;lt;OrderResponse&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    [ApiMember(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;订单ID号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, IsRequired = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    [ApiMember(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CustomerName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, IsRequired = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CustomerName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;......&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;    [ApiMember(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderItemList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;订购的产品列表&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, IsRequired = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;OrderItem&amp;gt; OrderItemList { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;运行结果如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid62&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-HE50ke2Jex4dtpz5&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145008542-522805694.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;在MSA API可视化说明文档中显示各请求参数、响应的含义说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid64&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-0YBoOp48wusKTlUl&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;7、运行结果       &lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid65&quot; class=&quot;gutter-author-3423802 locate lineguid-2Xv5VC8NJ7XuELni text-indent&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;先运行托管应用（如MSA Demo中ServiceHost项目），出现下图所示的Metadata页。然后再运行客户端来调用微服务；也可通过浏览器查看数据，网址输入格式如：&lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-3kmLgMu4KuR6k17N url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;http://&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;localhost:34833&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-iz41CGSkmQkidbQh url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;/&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;orders&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-mkUhnsXQD71kbLSs url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;/1.html?CustomerName&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;=客户_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=201&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-ZE3CEBFSZZy8X5ln url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;7&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;-0&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-FMbKvQb6nQ1wzWtU url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;8&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/orders/1.html?CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;-21&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt; 10:58:48.230&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;，或：  &lt;span class=&quot;author-3423802 link-block url-tpix2kIC62zO2TlR url&quot;&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;http://&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-qi30HFBhNJkzv36b url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;l&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;ocalhost:34833&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-ySyN6sjPhsjfhWIl url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;=客户_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=201&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-WbBYJIhXLhNR6M4K url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;7&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;-0&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b link-block url-2v3WEG0nE26ADaiB url url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;8&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b url&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://localhost:34833/html/reply/GetOrderRequest?Id=1&amp;amp;CustomerName=%E5%AE%A2%E6%88%B7_1&amp;amp;IsTakeAway=true&amp;amp;StatusCode=1&amp;amp;CreatedDate=2017-08-21&quot;&gt;-21&lt;/a&gt;&lt;/strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;&lt;strong&gt; 10:58:48.230&lt;/strong&gt;&lt;span class=&quot;author-3423802&quot;&gt;，其中，第1个网址格式规则就是MSA Demo中在宿主环境中所配的自定义路由规则，第2个网址格式规则就是由MSA提供的默认路由规则。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;       单击&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;下图所示Metadata页&lt;span class=&quot;author-3423802&quot;&gt;中的【MSA API UI】后，进入下图所示的MSA API可视化说明文档界面，开发人员可以通过这份由MSA自动生成的说明文档进行调试，十分方便。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid67&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-8aHbhBihK5RxK0C8&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145025000-850556805.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;Metadata页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div id=&quot;magicdomid70&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-0aSLYqrY7gkJXLtB&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145038679-1112553372.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt; &lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;MSA API可视化说明文档界面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid72&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-naTgX5Gqg7EMbp6O&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;三、微服务治理&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;在我们自主开发的框架&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;管理系统中，进行接口注册，请见下图。其中，规定内部服务访问名的命名规范是：/{***Service}/方法名，如/OrderService/CreateOrder；规定外部服务访问名OpenApiName的命名规范是：{各产品线的缩写英文名}方法名，如FltCreateOrder，其中Flt表示国内机票业务的缩写英文名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid74&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-6Hs6ChmhSBFTFpTy&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145053634-1211881767.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;MSA接口注册页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid76&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-GzsfH3pvyhecY1vH&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;四、微服务网关&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;&lt;span&gt;API Gateway&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;magicdomid77&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-BkvMDRZlIiix69lM&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;4.1、API Gateway的简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;API Gateway风格的核心理念是使用一个轻量级的消息网关作为所有客户端的主入口，并且在 API Gateway层面上实现通用的非功能性需求。如下图所示：所有的服务通过API 网关来暴露，这是所有客户端访问的唯一入口；如果一个服务要访问另一个服务，也要通过这个网关。 &lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid79&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-LoK7XZd0NmVBRY9i&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145106673-1852731941.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;所有服务通过一个API网关来暴露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;一旦API网关允许客户端消费一个受管理的API，那么我们就可以以受管理的API形式使用它来暴露这个微服务所实现的业务逻辑。API网关以NIO、IOCP来连接内部受管理的API，以实现API网关的高并发。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid82&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-eMrnBo8hWVuAwOOJ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;4.2、&lt;/span&gt;&lt;span class=&quot;author-3423802&quot;&gt;API Gateway的优点&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid83&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-Z3YpjalDGZiO6Xel&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145120945-1308090262.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid84&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-VfDJVeO4OYzQHXzH&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;网络隔离：微服务部署在了内网，通过API Gateway开放给PartnerAPI、WebAPI或MobileAPI。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid85&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-NtdEf4aTeszedjZo&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;在网关层面的轻量级消息路由和转换。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid86&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-Lkv4KskrPRwBeTtY&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;在网关层面对存在的微服务提供必要的抽象。例如，网关可以选择对不同的用户暴露不同的API。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid87&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-bSjogWZWYKBrcdy7&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;一个中心的地方提供非功能性的能力，这些能力可复用， 比如超时、限流、熔断、监控、日志记录等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid88&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-VhEF4szYfKN7nSzk&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;通过适用API网关模式，微服务可以变得更加轻量，因为非功能性需求都在网关上实现了。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid89&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-tYp92DTYbL1rIWu9&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;统一安全管控。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid90&quot; class=&quot;gutter-author-3423802 line-left heading-1 locate lineguid-fz34auYsMxEZGP7g&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;4.3、API Gateway的架构&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid91&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-LOlt6NCNYNZb2HIl&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145136785-256395872.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid92&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-WOWkHNYmVL5J07Cg&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;4.4、API Gateway的功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;API Gateway主要实现以下功能：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;1、路由映射：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;外部服务访问名映射到对应的内部服务访问名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;2、权限验证：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;包括针对客户角色的访问授权验证、针对客户的访问授权验证、IP黑名单验证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;3、超时处理：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;当API网关调用的内部服务响应时间超过了在自主开发的API网关后台管理子系统中所设置的允许最长的超时时间时，API网关会立即停止调用，并返回相关消息给你。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;4、限流控制：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;当你通过API网关调用内部服务的频率达到在某个阈值时，API网关会立即做断开链路处理。过了时间后，链路会自动闭合回去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;5、熔断处理：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;熔断处理对避免无谓的资源消耗特别有用，当通过API网关调用的内部服务出现异常的频率达到某个阈值时，那么API网关会做临时熔断处理即临时断开链路，暂时停止你对那个内部服务的调用。临时熔断后，过了一段时间后，链路会自动闭合回去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;strong&gt;6、日志信息记录：&lt;/strong&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;会记录客户IP、客户请求参数、返回结果、异常信息等信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid100&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-8CS3BC8Ks1kaNkZP&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;4.5、API Gateway的使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;在使用API Gateway之前，需要先配置网关参数。网关参数的配置是在自主开发的API网关后台管理子系统中进行：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid102&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-le9yLYKEoR3T3lbm&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1099513/201803/1099513-20180304145152503-976704464.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;在自主开发的API网关后台管理子系统中配置网关参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid104&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-t73JlzDsPs2IOvEz&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;五、Demo下载及&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;更多资料 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;



&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Mar 2018 06:52:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-arch-system/p/8504602.html</dc:identifier>
</item>
<item>
<title>KV型内存数据库Redis - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/8504662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/8504662.html</guid>
<description>&lt;p&gt;Redis是开源的高性能内存Key-Value数据库, 可以提供事务和持久化支持, 并提供了TTL(time to life)服务。&lt;/p&gt;
&lt;p&gt;Redis采用单线程数据操作+非阻塞IO的模型，非阻塞IO提供了较高的IO性能，单线程操作保证了单条指令的原子性。&lt;/p&gt;
&lt;p&gt;Redis使用简单灵活性能优异，常被用作缓存，分布式锁或者消息队列。&lt;/p&gt;
&lt;p&gt;非特殊说明， 本文以Redis 3.0为标准进行介绍。&lt;/p&gt;
&lt;p&gt;Ubuntu系统可以用包管理器安装Redis服务:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install redis-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并安装客户端:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install redis-tools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入Redis客户端&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;登录远程Redis服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli -h host -p port -a password&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，在Redis中若key或field不存在则会作为空集合处理(写操作会将先初始化为空集合)不会抛出错误，若key指向了其它类型则会出现错误。&lt;/p&gt;
&lt;p&gt;Redis中的线性集合(list和zset)的下标以0为底，且支持负数下标。即0指向第一个元素，1指向第二个元素，-1指向最后一个元素，-2指向倒数第二个元素。&lt;/p&gt;
&lt;p&gt;线性集合通常用start和stop参数表示一个子序列，序列为闭区间即包含start和stop指向的元素(这点与很多编程语言不同)。&lt;/p&gt;
&lt;h2 id=&quot;string&quot;&gt;string&lt;/h2&gt;
&lt;p&gt;string是Redis中的基本类型。 除了增删改查之外，Redis提供了STRLEN,APPEND等简单字符串操作。&lt;/p&gt;
&lt;p&gt;Redis没有专用的整数类型，所以key内储存的string可以被解释为十进制64位有符号整数进行计算。&lt;/p&gt;
&lt;p&gt;字符串也可以解释为双精度浮点数，在作为浮点数时计算结果时最大保留17位小数，自动去除小数部分尾随的0，必要时还会将浮点数改为整数(比如3.0会被保存成3)。 浮点数可以使用像&lt;code&gt;2.0e7&lt;/code&gt;、&lt;code&gt;3e5&lt;/code&gt;、&lt;code&gt;90e-2&lt;/code&gt;这样的指数符号来表示。&lt;/p&gt;
&lt;p&gt;string的算术操作可以让我们方便的实现锁和计数器等功能。&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;SET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SET key value [EX seconds] [PX milliseconds] [NX|XX]
SET one 1
SET one 1 XX
SET two 2 NX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将key指向字符串值value，若不存在key则新建键值对，若key存在默认情况下会覆盖旧值，无视旧值的类型。&lt;/p&gt;
&lt;p&gt;SET设置成功会返回OK， 失败会返回nil。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET key value NX&lt;/code&gt;只有在key不存在时才会设置，若key已存在则不进行任何操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET key value XX&lt;/code&gt;只有key存在时才会设置， 若key不存在则不进行任何操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET key value EX second&lt;/code&gt;: 设置键的过期时间为 second 秒。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET key value PX millisecond&lt;/code&gt;: 设置键的过期时间为 millisecond 毫秒。&lt;/p&gt;
&lt;p&gt;因为SET命令可以通过参数来实现SETNX、SETEX和PSETEX三个命令的效果，Redis官方称可能在将来的版本中废弃并最终移除SETNX、SETEX和PSETEX这三个命令。&lt;/p&gt;
&lt;h3 id=&quot;get&quot;&gt;GET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;GET key
GET one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回key所关联的字符串值，若key不存在返回nil, 若key指向其它数据类型则会返回一个错误信息。&lt;/p&gt;
&lt;h3 id=&quot;mget&quot;&gt;MGET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;MGET key [key key ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回所有(一个或多个)给定key的值。若其中有某个key不存在或指向其它类型，那么这个key返回nil。&lt;/p&gt;
&lt;h3 id=&quot;mset&quot;&gt;MSET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;MSET key value [key value ...]
MSET one 1 two 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时设置一个或多个key-value对, 如果某个给定key已经存在，那么MSET会用新值覆盖原来的旧值。该命令不会返回错误信息，总是返回OK。&lt;/p&gt;
&lt;p&gt;和其它指令一样，该操作是原子性的。&lt;/p&gt;
&lt;h3 id=&quot;msetnx&quot;&gt;MSETNX&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;MSETNX key value [key value ...]
MSET one 1 two 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时设置一个或多个key-value对, 如果某个给定key已经存在，那么&lt;code&gt;MSETNX&lt;/code&gt;不会设置任何一个key-value。&lt;/p&gt;
&lt;p&gt;该操作是原子性的，要么全部设置要么全不被设置。&lt;/p&gt;
&lt;h3 id=&quot;type&quot;&gt;TYPE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;TYPE key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回key指向的类型:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;none: key不存在&lt;/li&gt;
&lt;li&gt;string: 字符串&lt;/li&gt;
&lt;li&gt;list: 列表&lt;/li&gt;
&lt;li&gt;set: 集合&lt;/li&gt;
&lt;li&gt;zset: 有序集&lt;/li&gt;
&lt;li&gt;hash: 哈希表&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;incrdecr&quot;&gt;INCR，DECR&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;INCR key
DECR key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;INCR命令将key中储存的数字值增1, 若key不存在则先被初始化为0，然后再执行操作。 返回操作后key指向的值。&lt;/p&gt;
&lt;p&gt;若值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。&lt;/p&gt;
&lt;p&gt;类似地有DECR命令，用于将存储的数字减1。&lt;/p&gt;
&lt;h3 id=&quot;incrbydecrby&quot;&gt;INCRBY，DECRBY&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;INCRBY key value
INCRBY count 2
DECRBY count 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将key所储存的值加上增量value, 返回操作后的值。value可以为0或负值。&lt;/p&gt;
&lt;p&gt;若值包含错误的类型，或字符串类型的值不能表示为整数，那么返回一个错误。&lt;/p&gt;
&lt;p&gt;类似地有DECRBY用于将存储的数字减去给定值。&lt;/p&gt;
&lt;h3 id=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;INCRBYFLOAT key value
INCRBYFLOAT one 1.23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将key所储存的值加上浮点增量value, 返回操作后的值。value可以为0或负值。&lt;/p&gt;
&lt;p&gt;若值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。&lt;/p&gt;
&lt;p&gt;目前版本的Redis中没有DECRBYFLOAT指令，可以使用加负数进行减运算。&lt;/p&gt;
&lt;h2 id=&quot;key&quot;&gt;key&lt;/h2&gt;
&lt;p&gt;本节介绍对key通用的操作。&lt;/p&gt;
&lt;h3 id=&quot;del&quot;&gt;DEL&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;DEL key [key ...]
DEL one two&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除给定的一个或多个key, 不存在的key将会忽略返回被删除的key的数量。&lt;/p&gt;
&lt;h3 id=&quot;keys&quot;&gt;KEYS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;KEYS pattern
KEYS *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找所有符合给定模式pattern的key:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;KEYS *&lt;/code&gt;: 匹配数据库中所有key 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KEYS h?llo&lt;/code&gt;: 匹配hello，hallo 和 hxllo 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KEYS h*llo&lt;/code&gt;: 匹配 hllo 和 heeeeello 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KEYS h[ae]llo&lt;/code&gt;: 匹配 hello 和 hallo，但不匹配 hillo 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;exists&quot;&gt;EXISTS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;EXISTS key
EXISTS one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查给定key是否存在, 若存在返回 1，否则返回 0。&lt;/p&gt;
&lt;h3 id=&quot;rename&quot;&gt;RENAME&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;RENAME key newkey
RENAME one ONE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将key改名为newkey, 当newkey已经存在时，RENAME命令将覆盖旧值。成功时返回OK，失败时返回一个错误。&lt;/p&gt;
&lt;p&gt;当key和newkey相同，或者key不存在时，返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;renamenx&quot;&gt;RENAMENX&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;RENAMENX key newkey
RENAMENX one ONE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当newkey不存在时， 将key改名为newkey。成功时返回1，若newkey已存在返回0。&lt;/p&gt;
&lt;h3 id=&quot;expire&quot;&gt;EXPIRE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;EXPIRE key seconds
EXPIRE one 1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为给定key设置生存时间(TTL)，当key过期时(生存时间为0)，它会被自动删除。&lt;/p&gt;
&lt;p&gt;使用SET命令等覆盖一个键值对将会移除TTL, 但是INCR，LPUSH， HSET等命令不会修改生存时间。&lt;/p&gt;
&lt;p&gt;RENAME命令不会修改生存时间，若&lt;code&gt;RENAME key key2&lt;/code&gt;命令使得key覆盖了带有TTL的key2, 那么新的key2的生存时间设置和原来的key相同。&lt;/p&gt;
&lt;p&gt;PEXPIRE命令和EXPIRE命令的作用类似，但是它以毫秒为单位设置key的生存时间。&lt;/p&gt;
&lt;h3 id=&quot;expireat&quot;&gt;EXPIREAT&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;EXPIREAT key timestamp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EXPIREAT的作用和EXPIRE类似，都用于为key设置生存时间。&lt;/p&gt;
&lt;p&gt;不同在于EXPIREAT命令接受的时间参数是UNIX时间戳。&lt;/p&gt;
&lt;p&gt;PEXPIREAT和EXPIREAT命令类似，但它的参数是以毫秒为单位的unix时间戳。&lt;/p&gt;
&lt;h3 id=&quot;ttl&quot;&gt;TTL&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;TTL key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以秒为单位，返回给定 key 的剩余生存时间，当key不存在时，返回-2， 当key存在但没有设置剩余生存时间时，返回-1。&lt;/p&gt;
&lt;p&gt;PTTL命令类似于TTL命令，但它以毫秒为单位返回key的剩余生存时间。&lt;/p&gt;
&lt;h3 id=&quot;persist&quot;&gt;PERSIST&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;PERSIST key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移除给定key的生存时间设置，使其成为永久的key。&lt;/p&gt;
&lt;p&gt;当生存时间移除成功时，返回1。如果key不存在或key没有设置生存时间，返回0。&lt;/p&gt;
&lt;h2 id=&quot;list&quot;&gt;list&lt;/h2&gt;
&lt;p&gt;列表(list)是一个线性容器，可以根据下标访问元素。&lt;/p&gt;
&lt;p&gt;Redis中list的元素只能是字符串，不支持其它类型。&lt;/p&gt;
&lt;h3 id=&quot;lpush&quot;&gt;LPUSH&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LPUSH key value1 value2 
LPUSH arr a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个或多个值value插入到列表key的头部(左侧)，返回操作后列表的长度。&lt;/p&gt;
&lt;p&gt;如果key不存在，将会创建一个空列表并执行LPUSH操作，当key存在但不是列表类型时，返回一个错误。&lt;/p&gt;
&lt;p&gt;对空列表&lt;code&gt;arr&lt;/code&gt;执行&lt;code&gt;LPUSH arr a b c&lt;/code&gt;指令后，&lt;code&gt;arr&lt;/code&gt;的内容为&lt;code&gt;c b a&lt;/code&gt;。相当于原子性的执行了&lt;code&gt;LPUSH arr a&lt;/code&gt;, &lt;code&gt;LPUSH arr b&lt;/code&gt;, &lt;code&gt;LPUSH arr c&lt;/code&gt;三条指令。&lt;/p&gt;
&lt;h3 id=&quot;rpush&quot;&gt;RPUSH&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;RPUSH key value1 value2
RPUSH arr a b c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个或多个值value插入到列表key的尾部(左侧)，返回操作后列表的长度。&lt;/p&gt;
&lt;p&gt;如果key不存在，将会创建一个空列表并执行RPUSH操作，当key存在但不是列表类型时，返回一个错误。&lt;/p&gt;
&lt;p&gt;对空列表&lt;code&gt;arr&lt;/code&gt;执行&lt;code&gt;RPUSH arr a b c&lt;/code&gt;指令后，&lt;code&gt;arr&lt;/code&gt;的内容为&lt;code&gt;a b c&lt;/code&gt;。相当于原子性的执行了&lt;code&gt;RPUSH arr a&lt;/code&gt;, &lt;code&gt;RPUSH arr b&lt;/code&gt;, &lt;code&gt;RPUSH arr c&lt;/code&gt;三条指令。&lt;/p&gt;
&lt;h3 id=&quot;llen&quot;&gt;LLEN&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LLEN key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回列表的长度，若key不存在返回0， 若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;lrange&quot;&gt;LRANGE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LRANGE key start stop
LRANGE arr 0 -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回列表key中指定区间内的元素，区间以偏移量start和stop指定。&lt;/p&gt;
&lt;p&gt;下标以0为底，即0表示列表中的第一个元素， 1表示第二个元素。也可以使用负数下标，-1表示最后一个元素， -2表示倒数第二个元素。&lt;/p&gt;
&lt;p&gt;stop下标也在LRANGE命令的取值范围之内(闭区间)，&lt;code&gt;LRANGE arr 0 2&lt;/code&gt;会返回下标为0，1，2的三个元素。&lt;/p&gt;
&lt;p&gt;超出范围的下标值不会引起错误，如果start比列表的最大下标还要大那么返回一个空列表，如果stop下标比最大下标还要大，stop的值将被设为最大下标。&lt;/p&gt;
&lt;h3 id=&quot;lindex&quot;&gt;LINDEX&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LINDEX key index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回列表key中，下标为index的元素。若index超出范围或者key指向空列表(key不存在)则会返回nil, 若key指向其它类型则返回错误。&lt;/p&gt;
&lt;p&gt;下标以0为底，即0表示列表中的第一个元素， 1表示第二个元素。也可以使用负数下标，-1表示最后一个元素， -2表示倒数第二个元素。&lt;/p&gt;
&lt;h3 id=&quot;linsert&quot;&gt;LINSERT&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LINSERT key BEFORE|AFTER pivot value
RPUSH arr &quot;World&quot;
LINSERT arr BEFORE &quot;World&quot; &quot;HELLO&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将值value插入到列表key中，位于值pivot之前或之后。当pivot不存在于列表key时，不执行任何操作。当key不存在时，key被视为空列表，不执行任何操作。&lt;/p&gt;
&lt;p&gt;如果命令执行成功，返回插入操作完成之后列表的长度。如果没有找到pivot返回-1，如果key不存在或为空列表，返回0。&lt;/p&gt;
&lt;h3 id=&quot;lrem&quot;&gt;LREM&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LREM key count value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据参数count的值，移除列表中与参数value相等的元素，返回被移除元素的数量。&lt;/p&gt;
&lt;p&gt;count的值可以是以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;count &amp;gt; 0: 从表头开始向表尾搜索，移除与value相等的元素，数量为count。&lt;/li&gt;
&lt;li&gt;count &amp;lt; 0: 从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值。&lt;/li&gt;
&lt;li&gt;count = 0: 移除表中所有与value相等的值。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ltrim&quot;&gt;LTRIM&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LTRIM key start stop&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除, start和stop指定区间的规则与LRANGE相同。&lt;/p&gt;
&lt;p&gt;若删除成功或key不存在则返回OK，若key指向其它类型则返回错误。&lt;/p&gt;
&lt;h3 id=&quot;lset&quot;&gt;LSET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LSET key index value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将列表key中下标为index的元素的值设置为value，下标以0为底，可以使用负数下标。&lt;/p&gt;
&lt;p&gt;当index参数超出范围，或对一个空列表(key不存在或指向其它类型)进行LSET时，返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;lpop-rpop&quot;&gt;LPOP, RPOP&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LPOP key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移除并返回列表key的头元素, key不存在时返回nil。key指向其它类型时返回错误。&lt;/p&gt;
&lt;p&gt;类似地有&lt;code&gt;RPOP&lt;/code&gt;命令，移除并返回列表key的尾元素。&lt;/p&gt;
&lt;h2 id=&quot;set-1&quot;&gt;set&lt;/h2&gt;
&lt;p&gt;集合(set)是一种无序容器，不存在重复元素，可以用于判断元素是否存在或者进行交并差运算。&lt;/p&gt;
&lt;p&gt;Redis中集合的元素类型只能是字符串，不支持其它类型。&lt;/p&gt;
&lt;h3 id=&quot;sadd&quot;&gt;SADD&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SADD key member [member ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个或多个member元素加入到集合key当中，返回添加到集合中新元素的数量，已经存在于集合的元素将被忽略。&lt;/p&gt;
&lt;p&gt;若key不存在先初始化一个空集合然后添加成员，若key指向了非集合类型则会产生错误。&lt;/p&gt;
&lt;h3 id=&quot;sscard&quot;&gt;SSCARD&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SSCARD key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回集合中元素的数量，key不存在时返回0，key指向其它类型时返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;smembers&quot;&gt;SMEMBERS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SMEMBERS key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回key指向的集合中的所有成员，若key不存在返回空集，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;sismember&quot;&gt;SISMEMBER&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SISMEMBER key member&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断member元素是否集合key的成员, 若元素是集合的成员返回1，若元素不是集合的成员或者集合不存在则返回0。&lt;/p&gt;
&lt;p&gt;若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;srem&quot;&gt;SREM&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SREM key member [member ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移除集合中的一个或多个元素，不存在的元素会被忽略，返回被成功移除的元素的个数。&lt;/p&gt;
&lt;p&gt;若key不存在则作为空集处理，返回0。若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;sinter-sunion-sdiff&quot;&gt;SINTER, SUNION, SDIFF&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SINTER key [key ...]
SUNION key [key ...]
SDIFF key [key ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回给定集合的交集(SINTER)，并集(SUNION)和差集(SDIFF)，若key不存在则作为空集处理，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;sinterstore-sunionstore-sdiffstore&quot;&gt;SINTERSTORE, SUNIONSTORE, SDIFFSTORE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SINTER dest key [key ...]
SUNION dest key [key ...]
SDIFF dest key [key ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算给定集合的交集(SINTERSTORE)，并集(SUNIONSTORE)和差集(SDIFFSTORE)，并将结果存入dest集合，若dest集合已存在则将其覆盖。&lt;/p&gt;
&lt;p&gt;若key不存在则作为空集处理，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;p&gt;dest可以是某个参与计算的key，dest可以指向其它类型，计算结束后dest中的值会被覆盖。&lt;/p&gt;
&lt;h3 id=&quot;spop&quot;&gt;SPOP&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SPOP key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SPOP&lt;/code&gt;移除并返回集合中的一个随机元素，当key不存在或key是空集时返回nil，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SRANDMEMBER key [count]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若只提供了key参数，那么返回集合中的一个随机元素。&lt;/p&gt;
&lt;p&gt;当key不存在或key是空集时返回nil，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;p&gt;若提供了count参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若count 为正数，且小于集合基数，那么返回一个包含count个元素的数组，数组中的元素各不相同。&lt;/li&gt;
&lt;li&gt;若count 大于等于集合中元素数，那么返回整个集合。&lt;/li&gt;
&lt;li&gt;若count为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为count的绝对值。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hash&quot;&gt;hash&lt;/h2&gt;
&lt;p&gt;哈希表(hash)是key-value结构, key和value的类型为字符串。&lt;/p&gt;
&lt;h3 id=&quot;hset&quot;&gt;HSET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HSET key field value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将哈希表key中的域field的值设为value。&lt;/p&gt;
&lt;p&gt;如果key不存在， 将创建一个新的哈希表并进行&lt;code&gt;HSET&lt;/code&gt;操作。如果域field已经存在于哈希表中，旧值将被覆盖。&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;HSET&lt;/code&gt;设置了一个新域则返回1，若覆盖了一个已有的域则返回0。&lt;/p&gt;
&lt;h3 id=&quot;hsetnx&quot;&gt;HSETNX&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HSETNX key field value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将哈希表key中的域field的值设为value。&lt;/p&gt;
&lt;p&gt;如果key不存在， 将创建一个新的哈希表并进行HSET操作。如果域field已经存在于哈希表中，则不进行任何操作。&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;HSETNX&lt;/code&gt;设置了一个新域则返回1，若域已经存在则返回0。&lt;/p&gt;
&lt;h3 id=&quot;hget&quot;&gt;HGET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HGET key field&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回哈希表key中指定域field的值，若哈希表key不存在或其域field不存在则返回nil。&lt;/p&gt;
&lt;h3 id=&quot;hmset&quot;&gt;HMSET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HMSET key field value [field value ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时将多个field-value(域-值)对设置到哈希表key中。若field已存在则会被覆盖。&lt;/p&gt;
&lt;p&gt;若key不存在，则创建一个空哈希表并执行HMSET操作&lt;/p&gt;
&lt;h3 id=&quot;hmget&quot;&gt;HMGET&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HMGET key field [field ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回哈希表key中一个或多个给定域的值，若field不存在则返回nil。&lt;/p&gt;
&lt;p&gt;若key不存在则作为空哈希表处理，每个field都会返回一个nil值。&lt;/p&gt;
&lt;h3 id=&quot;hdel&quot;&gt;HDEL&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HDEL key field [field ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除哈希表key中一个或多个指定域，不存在的域将被忽略，返回实际被删除域的数目。&lt;/p&gt;
&lt;h3 id=&quot;hlen&quot;&gt;HLEN&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HLEN key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回哈希表key中域的数量，若key不存在则返回0。&lt;/p&gt;
&lt;h3 id=&quot;hexists&quot;&gt;HEXISTS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HEXISTS key field &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断哈希表key中域field是否存在，若存在返回1。若哈希表key不存在或其中不存在域field则返回0。&lt;/p&gt;
&lt;h3 id=&quot;hkeys&quot;&gt;HKEYS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HKEYS key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以列表的形式返回哈希表key中所有域的名称。&lt;/p&gt;
&lt;h3 id=&quot;hvals&quot;&gt;HVALS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HVALS key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回哈希表key中所有域的值。&lt;/p&gt;
&lt;h3 id=&quot;hgetall&quot;&gt;HGETALL&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HGETALL key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以列表的形式返回哈希表key中所有的键和值，前一个元素为键其后的元素为它的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; HMSET hash a 1 b 2
OK
&amp;gt; HGETALL hash
1) &quot;a&quot;
2) &quot;1&quot;
3) &quot;b&quot;
4) &quot;2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hincrby-hincrbyfloat&quot;&gt;HINCRBY, HINCRBYFLOAT&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HINCRBY key field increment&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为哈希表key中的域field的值加上增量increment, 增量可以为负数进行减法操作。&lt;/p&gt;
&lt;p&gt;若哈希表中不存在域field则现将该域初始化为0，然后进行加法操作。&lt;/p&gt;
&lt;p&gt;若哈希表key不存在，则将创建一个空哈希表，然后按上一条规则执行。&lt;/p&gt;
&lt;p&gt;若key指向其它类型或域的值不能解释为整数则返回一个错误。&lt;/p&gt;
&lt;p&gt;类似地，&lt;code&gt;HINCRBYFLOAT&lt;/code&gt;可以进行浮点数运算。&lt;/p&gt;
&lt;h2 id=&quot;zset&quot;&gt;zset&lt;/h2&gt;
&lt;p&gt;有序集合(SortedSet, zset)是一种特殊的集合类型，它不允许重复元素，可以根据每个元素的score进行排序。&lt;/p&gt;
&lt;h3 id=&quot;zadd&quot;&gt;ZADD&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZADD key [NX|XX] [FH] [INCR] score member [[score member] [score member] ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个或多个member元素及其score值加入到有序集key当中, 若元素已经在集合中则更新它的score，score值可以是整数值或浮点数。&lt;/p&gt;
&lt;p&gt;返回新添加的元素的数量，不包括被更新的元素的数量。&lt;/p&gt;
&lt;p&gt;当key存在但不是有序集类型时，返回一个错误。&lt;/p&gt;
&lt;p&gt;ZADD命令支持一些选项：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;NX: 不更新存在的成员，仅添加新成员&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;XX: 不添加新成员，仅更新存在的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数(CH=changed)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;INCR: 对成员的值进行增加操作而不是设置操作，等同于&lt;code&gt;ZINCRBY&lt;/code&gt;命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;zrem&quot;&gt;ZREM&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZREM key member [member ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移除有序集 key 中的一个或多个成员，不存在的成员将被忽略, 返回实际被移除的元素数量。&lt;/p&gt;
&lt;p&gt;当 key 存在但不是有序集类型时，返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;zcard&quot;&gt;ZCARD&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZCARD key&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回有序集key中元素的数目，若key不存在则返回0，若key指向其它类型则返回一个错误。&lt;/p&gt;
&lt;h3 id=&quot;zcount&quot;&gt;ZCOUNT&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZCOUNT key min max&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回有序集key中，score值在min和max之间(包括等于min或max)的元素数量。&lt;/p&gt;
&lt;h3 id=&quot;zrange-zrevrange&quot;&gt;ZRANGE, ZREVRANGE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZRANGE key start stop [WITHSCORES]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回有序集key中，指定区间内的成员。start和stop用于指定元素的排名，它们以0为底且支持负下标，指定的是闭区间。&lt;/p&gt;
&lt;p&gt;即0代表集合中score最小的元素，-1代表最大的元素。&lt;/p&gt;
&lt;p&gt;其中成员的位置按score值递增(从小到大)来排序, 具有相同score值的成员按字典序来排列。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ZRANGE key 0 -1&lt;/code&gt;可以返回集合中所有元素递增排列的序列。&lt;/p&gt;
&lt;p&gt;若start的值大于集合中元素的个数 或者 start大于stop值 则返回一个空列表；若stop大于集合中元素的个数则当做该集合的最大下标处理。&lt;/p&gt;
&lt;p&gt;默认情况下ZRANGE命令仅返回元素，若添加了WITHSCORES选项则会将score一并返回。返回列表中元素和score成对出现，前一个为元素后一个为score。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrange z 0 -1
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;
&amp;gt; zrange z 0 -1 WITHSCORES
1) &quot;a&quot;
2) &quot;1&quot;
3) &quot;b&quot;
4) &quot;2&quot;
5) &quot;c&quot;
6) &quot;5&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似地，ZREVRANGE指令按照score递减排序(从大到小)。&lt;/p&gt;
&lt;h3 id=&quot;zrangebyscore-zrevrangebyscore&quot;&gt;ZRANGEBYSCORE, ZREVRANGEBYSCORE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回有序集key中score在min和max(包括等于min和max)之间的的元素，按照score值递增排列。&lt;/p&gt;
&lt;p&gt;默认情况下&lt;code&gt;ZRANGEBYSCORE&lt;/code&gt;命令仅返回元素，若添加了WITHSCORES选项则会将score一并返回。返回列表中元素和score成对出现，前一个为元素后一个为score。&lt;/p&gt;
&lt;p&gt;可选的LIMIT参数指定返回结果的数量及区间，类似于SQL中的&lt;code&gt;SELECT offset, count&lt;/code&gt;，offset为跳过元素的数量，count为返回元素的最大数量。&lt;/p&gt;
&lt;p&gt;类似地，&lt;code&gt;ZREVRANGEBYSCORE&lt;/code&gt;命令可以按照score值递减排列。&lt;/p&gt;
&lt;h3 id=&quot;zrank-zrevrank&quot;&gt;ZRANK, ZREVRANK&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZRANK key member&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。&lt;/p&gt;
&lt;p&gt;排名以0为底，score值最小的成员排名为0。&lt;/p&gt;
&lt;p&gt;使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。&lt;/p&gt;
&lt;h3 id=&quot;zincrby&quot;&gt;ZINCRBY&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ZINCRBY key increment member&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为有序集key的成员member的score值加上增量increment，increment可以为负值，可以为整数或者浮点数。&lt;/p&gt;
&lt;p&gt;当key不存在，或 member不是key的成员时，&lt;code&gt;ZINCRBY&lt;/code&gt;会初始化空集合，或者将成员初始化为0。&lt;/p&gt;
&lt;p&gt;当key指向其它类型时，则会返回一个错误。&lt;/p&gt;

&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; RPUSH a 1 2 3
QUEUED
127.0.0.1:6379&amp;gt; LRANGE a 0 -1
QUEUED
127.0.0.1:6379&amp;gt; EXEC
1) (integer) 3
2) 1) &quot;1&quot;
   2) &quot;2&quot;
   3) &quot;3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis提供了事务机制，支持原子性地执行多条指令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MULTI&lt;/code&gt;命令进入事务模式，其后的命令进入队列缓存，直到&lt;code&gt;EXEC&lt;/code&gt;命令执行队列中的命令，或者&lt;code&gt;DISCARD&lt;/code&gt;命令放弃事务执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXEC&lt;/code&gt;命令会以列表的形式返回事务中所有命令的返回值。&lt;/p&gt;
&lt;p&gt;若事务的指令队列中存在语法错误则整个事务都会放弃执行。若队列中某条指令出现了运行时错误(如哈希指令操作了列表)， Redis会继续执行事务中的后续指令。&lt;/p&gt;
&lt;p&gt;Redis保证在事务的原子性，事务执行期间不会有其它客户端的指令插入。&lt;/p&gt;
&lt;p&gt;Redis事务不支持回滚必须由使用者保证一致性。&lt;/p&gt;
&lt;p&gt;因为Redis是单线程执行的，总是能保证事务的隔离性。Redis事务不提供额外的持久化机制，持久性由持久化配置决定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WATCH&lt;/code&gt;命令应在事务开始前执行，用于监视某个键的值是否改变。 若在执行&lt;code&gt;WATCH&lt;/code&gt;和&lt;code&gt;EXEC&lt;/code&gt;指令中间，任意一个被监视的键发生改变或被删除那么事务将中止执行，EXEC命令会返回nil。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; WATCH lock
OK
# 若此时其它客户端修改了lock的值，那么事务不会开始执行。
127.0.0.1:6379&amp;gt; MULTI
OK
127.0.0.1:6379&amp;gt; SET b 1
QUEUED
127.0.0.1:6379&amp;gt; GET b
QUEUED
127.0.0.1:6379&amp;gt; EXEC
1) OK
2) &quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;WATCH&lt;/code&gt;的监视到&lt;code&gt;EXEC&lt;/code&gt;开始执行事务为止，因此&lt;code&gt;WATCH&lt;/code&gt;不会阻止在事务中修改被监视的键。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; WATCH lock
OK
127.0.0.1:6379&amp;gt; MULTI
OK
127.0.0.1:6379&amp;gt; SET lock 1
QUEUED
127.0.0.1:6379&amp;gt; GET lock
QUEUED
127.0.0.1:6379&amp;gt; EXEC
1) OK
2) &quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;WATCH&lt;/code&gt;命令主要用于保证事务开始执行时的状态正确，典型的&quot;秒杀&quot;应用中，多个客户端首先使用WATCH命令监视锁，随后执行购买事务。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;WATCH&lt;/code&gt;命令和事务执行之间若有其它客户端成功执行事务，使得锁发生变化则当前客户端无法执行事务，即抢购失败。&lt;/p&gt;
&lt;p&gt;示例(伪代码):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; SET remains 100
&amp;gt; SET empty 0
&amp;gt; WATCH empty
# 此时可能已有其它客户端抢先执行事务
&amp;gt; MULTI
&amp;gt; DECR remains
&amp;gt; if (remains == 0): SET empty 1 # 修改锁，阻止其它客户端抢购  
# 此处还应有写购买记录和修改余额等操作
&amp;gt; EXEC&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UNWATCH&lt;/code&gt;命令用于取消&lt;code&gt;WATCH&lt;/code&gt;命令对所有key的监视。&lt;/p&gt;
&lt;h2 id=&quot;pipeline&quot;&gt;pipeline&lt;/h2&gt;
&lt;p&gt;Redis采用请求/响应式协议进行与服务端的交互，通常情况下一次请求只包含一条指令。&lt;/p&gt;
&lt;p&gt;pipeline模式可以一次请求执行多条指令，减少IO的开销。&lt;/p&gt;
&lt;p&gt;这里给出一个python客户端使用pipeline的示例:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; redis.Redis(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'127.0.0.1'&lt;/span&gt;, port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pipe &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;.pipeline(transaction&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pipe.&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;x&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;)
Pipeline&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ConnectionPool&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Connection&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;127.0.0.1&lt;/span&gt;,port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;,db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pipe.&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;y&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;)
Pipeline&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ConnectionPool&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Connection&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;127.0.0.1&lt;/span&gt;,port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;,db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; pipe.execute()
[&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pipeline不是原子性的，执行过程中可能会有来自其他客户端的指令执行。不要使用pipeline发送多条SET/GET指令代替MSET/MGET。&lt;/p&gt;
&lt;p&gt;pipeline会占据整个连接，在完成前无法执行其它指令。客户端应配置好连接池防止被pipeline阻塞。&lt;/p&gt;
&lt;h2 id=&quot;发布订阅&quot;&gt;发布订阅&lt;/h2&gt;
&lt;p&gt;Redis的发布订阅模式允许客户端监听某些频道，发布者在该频道上发布消息后，消息会被推送到订阅了该频道的客户端。&lt;/p&gt;
&lt;p&gt;发布订阅模式允许服务端主动通知客户端，无需客户端轮询状态变化，因此Redis可以实现消息队列的功能。&lt;/p&gt;
&lt;p&gt;首先打开一个客户端订阅chat频道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SUBSCRIBE chat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开另一个客户端发布一条消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; PUBLISH chat &quot;Hi there&quot;
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PUBLISH命令的返回值是接收到该消息的订阅者的数量。&lt;/p&gt;
&lt;p&gt;订阅了该频道的客户端会受到消息推送:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; SUBSCRIBE chat
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;chat&quot;
3) (integer) 1

1) &quot;message&quot;
2) &quot;chat&quot;
3) &quot;Hi there&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UNSUBSCRIBE命令用于取消订阅的频道:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UNSUBSCRIBE [channel [channel ...]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PSUBSCRIBE和PUNSUBSCRIBE可以使用模式匹配来订阅和取消订阅频道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PSUBSCRIBE pattern [pattern ...]
PUNSUBSCRIBE [pattern [pattern ...]]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;scan&quot;&gt;SCAN&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;KEYS&lt;/code&gt;命令处理大数据库或者&lt;code&gt;SMEMBERS&lt;/code&gt;命令处理大集合时可能阻塞数据库数秒之久，这在生产环境下是无法介绍的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCAN&lt;/code&gt;和&lt;code&gt;SSCAN&lt;/code&gt;命令可用分页迭代的方式遍历大数据集，每次迭代仅返回少量数据不会阻塞服务器:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SCAN cursor [MATCH pattern] [COUNT count]
127.0.0.1:6379&amp;gt; SCAN 0
1) &quot;20&quot;
2)  1) &quot;1125677473485562817&quot;
    2) &quot;5537448729649573447&quot;
    3) &quot;2854796168938416843&quot;
    4) &quot;7439346733403784473&quot;
    5) &quot;-6333572342266574627&quot;
    6) &quot;-9080851294203022766&quot;
    7) &quot;1125677473485562817&quot;
    8) &quot;820904952218043889&quot;
    9) &quot;1125677473485562827&quot;
   10) &quot;1125677473485562837&quot;
127.0.0.1:6379&amp;gt; SCAN 20
1) &quot;0&quot;
2)  1) &quot;1125677473485562817&quot;
    2) &quot;-1053519331922297522&quot;
    3) &quot;7439346733403784473&quot;
    4) &quot;-2594669955628668552&quot;
    5) &quot;-4053026386633294784&quot;
    6) &quot;7439346733403784473&quot;
    7) &quot;-1053519331922297522&quot;
    8) &quot;2649406091729268560&quot;
    9) &quot;7439346733403784473&quot;
   10) &quot;1053519331903186673&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SCAN&lt;/code&gt;命令的返回值包含两部分，第一部分为下次迭代的游标，第二部分为本次迭代取得的键。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCAN cursor MATCH pattern&lt;/code&gt;可以像&lt;code&gt;KEYS&lt;/code&gt;命令一样使用通配符筛选需要迭代的键。&lt;code&gt;SCAN cursor COUNT count&lt;/code&gt;可以设置每次迭代返回键的数量。&lt;/p&gt;
&lt;p&gt;使用0作为游标表示开始一次新的迭代，当&lt;code&gt;SCAN&lt;/code&gt;命令返回的游标为0时表示本次迭代已经结束。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCAN&lt;/code&gt;命令保证在整个迭代期间一直存在于数据库中的键一定会被返回。如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCAN&lt;/code&gt;命令可能会将一个键返回多次，由应用程序处理重复的元素。&lt;/p&gt;
&lt;p&gt;Redis中提供了几个类似的命令用于遍历大集合:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SSCAN&lt;/code&gt;: 遍历集合(set)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HSCAN&lt;/code&gt;: 遍历哈希表(hash)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZSCAN&lt;/code&gt;: 遍历有序集合(zset), 包括元素成员和元素分值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd z 1 a 2 b 3 c
(integer) 0
127.0.0.1:6379&amp;gt; zscan z 0
1) &quot;0&quot;
2) 1) &quot;a&quot;
   2) &quot;1&quot;
   3) &quot;b&quot;
   4) &quot;2&quot;
   5) &quot;c&quot;
   6) &quot;3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hyperloglog&quot;&gt;HyperLogLog&lt;/h2&gt;
&lt;p&gt;一个集合中不重复元素的个数称为集合的基数，如集合{a, b, c}的基数为3。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html&quot;&gt;HyperLogLog&lt;/a&gt;是一种估计大集合基数的算法，Redis封装了该算法:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PFADD&lt;/code&gt;命令将元素添加到HyperLogLog中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PFADD key element [element ...] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PFCOUNT&lt;/code&gt;命令返回基数估计值，当给定了多个key时则返回它们基数之和(不是并集的基数)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PFCOUNT key [key ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PFMERGE&lt;/code&gt;命令将多个HyperLogLog合并，destKey的基数即为sourceKey并集的基数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PFMERGE destkey sourcekey [sourcekey ...]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 04 Mar 2018 06:34:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/8504662.html</dc:identifier>
</item>
<item>
<title>【SSH框架】系列之 Spring 整合 Hibernate 框架 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8504319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8504319.html</guid>
<description>&lt;h4 id=&quot;h1ssh&quot;&gt;1、SSH 三大框架整合原理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180304123726332-1465654430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Spring 与 Struts2 的整合就是将 Action 对象交给 Spring 容器来负责创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring 与 Hibernate 的整合就是将 SessionFactory 交给 Spring 容器来负责维护，并且 Spring 容器负责 Session 维护以及相关的 AOP 事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h2springhibernate&quot;&gt;2、Spring 整合 Hibernate 框架&lt;/h4&gt;
&lt;p&gt;（1）、新建 web 项目，导入 Spring 和 Hibernate 框架所需要的 jar 包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180304124344856-1505581856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、单独配置 Spring 容器，具体配置如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;applicationContext.xml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建配置文件，并导入约束&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;beans &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot; &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:context=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:aop=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot; &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:tx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &lt;br/&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &lt;br/&gt;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &lt;br/&gt;http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd &quot;&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;beans&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置 Spring 随项目启动&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、单独配置 Hibernate&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC&lt;br/&gt;&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;&lt;br/&gt;&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-configuration&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot; readability=&quot;1&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot; readability=&quot;2&quot;&gt;session-factory&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;session-factory&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;hibernate-configuration&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、Spring 整合 Hibernate&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 Spring 容器中配置SessionFactory&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、Spring 整合 hibernate 环境操作数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用 hibernate 模板进行具体操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;扫描关注微信公众号，了解更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180304121820283-1244576284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Mar 2018 04:19:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8504319.html</dc:identifier>
</item>
<item>
<title>[Cake] 1. CI中的Cake - blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/cake-in-ci.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/cake-in-ci.html</guid>
<description>&lt;p&gt;在上一篇&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/cake-overview.html&quot; target=&quot;_black&quot;&gt;C#Make自动化构建-简介&lt;/a&gt;中，简单的介绍了下Cake的脚本如何编写以及通过Powershell在本地运行Cake脚本。本篇在此基础上，介绍下如何在CI环境中使用Cake。&lt;/p&gt;

&lt;h2&gt;1.1 为Task添加注释信息&lt;/h2&gt;
&lt;p&gt;Cake的每一个Task都可以添加一项描述，用来解释它的用途。比如下面的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Task(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;restore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     .Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;还原项目依赖&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     .Does(() =&amp;gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    DotNetCoreRestore(soluction);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后Cake接收一个名为 &lt;span class=&quot;cnblogs_code&quot;&gt;ShowsDescription&lt;/span&gt; 的参数，运行Powershell或者bash的时候可以传递-ShowDescription来显示Task的信息。为了方便输入，我把ShowDescription改成了Help（仅更改了build.ps1中传递参数的名称）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304105832995-1296120337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2 Cake.exe 和 Cake.CoreCLR&lt;/h2&gt;
&lt;p&gt;Cake目前有两个版本（参见&lt;a href=&quot;https://github.com/cake-build/cake/releases&quot; target=&quot;_blank&quot;&gt;Cake Releases&lt;/a&gt;）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/Cake/&quot; target=&quot;_blank&quot;&gt;Cake.exe&lt;/a&gt;是面向net461的，可以在winodws上直接运行；也可以在linux上借助 &lt;span class=&quot;cnblogs_code&quot;&gt;mono cake.exe&lt;/span&gt; (Mono已经实现net47)来运行。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/Cake.CoreCLR/&quot; target=&quot;_blank&quot;&gt;Cake.CoreCLR&lt;/a&gt;（0.26版本以后开始支持.net core 2的，之前是.net core 1.1）面向.netcore的，可以使用 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet cake.dll&lt;/span&gt; 来运行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们直接下载这两个nuget包，然后用7z解压一下（nupkg文件为zip）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304111131724-1603230153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cake.0.26.1.nupkg解压后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304111414625-366590052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在windows下可以直接通过console窗口来运行它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304111552896-1682845137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cake.coreclr.0.26.1.nupkg解压后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304111746579-1441658712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过dotnet cake.dll来运行它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304111916382-1419450335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Cake脚本本身的跨平台（windows，linux，docker等）是借助于上面提到的cake.exe或cake.coreclr来实现的。基于这些，我们可以有如下的组合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;windows：用powershell来引导执行cake.exe。&lt;/li&gt;
&lt;li&gt;windows：用powershell来引导执行dotnet cake.dll。&lt;/li&gt;
&lt;li&gt;linux：用bash来引导执行mono cake.exe。&lt;/li&gt;
&lt;li&gt;linux：用bash来引导执行dotnet cake.dll。&lt;/li&gt;
&lt;li&gt;docker：视docker镜像的os平台而定，从上面四个组合中选择一个。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于目前dotnet cli本身的不健全，缺少独立于*.csproj文件之外来安装nuget包的命令，故而使得安装cake.coreclr变得非常恶心。参见两种变通方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;借助外部工具下载cake.coreclr的nuget包：&lt;a href=&quot;https://github.com/devlead/BitbucketPipelinesShield/blob/master/build.sh&quot; target=&quot;_blank&quot;&gt;https://github.com/devlead/BitbucketPipelinesShield/blob/master/build.sh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;构造一个临时的*.csproj文件，然后用dotnet restore来下载cake.coreclr的nuget包：&lt;a href=&quot;https://gist.github.com/luigiberrettini/19a124d24af74039ae87065adb007e2c&quot; target=&quot;_blank&quot;&gt;https://gist.github.com/luigiberrettini/19a124d24af74039ae87065adb007e2c&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;故而目前在window平台下选择1，在其他平台下选择3比较合适，在docker下可以构建一个mone+dotnet的混合环境的image（&lt;a href=&quot;https://hub.docker.com/r/lnhcode/dotnet2-mono5/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/lnhcode/dotnet2-mono5/&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;好消息是目前.net core的每日构建版已经添加了 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet install&lt;/span&gt;  和 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet install tool&lt;/span&gt; 的命令（&lt;a href=&quot;https://github.com/dotnet/cli/blob/master/src/dotnet/commands/dotnet-install/InstallCommandParser.cs&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/cli/blob/master/src/dotnet/commands/dotnet-install/InstallCommandParser.cs&lt;/a&gt;），可以直接用来安装nuget包。这个新功能会随着.net core 2.1的正式发布而到来。到时候就可以统一借助dotnet cli来安装cake.coreclr了。&lt;/p&gt;

&lt;p&gt;cake的目的在于一次编写，可以运行在不同的构建环境和构建工具中。同时可以把构建脚本纳入到源代码管理中，而不是编写在某一特定的ci/cd工具中。正如这篇文章&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/programming-in-your-ci-cd-tool&quot; target=&quot;_blank&quot;&gt;https://www.thoughtworks.com/radar/techniques/programming-in-your-ci-cd-tool&lt;/a&gt;中的观点一样。&lt;/p&gt;
&lt;p&gt;借助Github提供的很多免费的CI服务，我在&lt;a href=&quot;https://github.com/linianhui/cake.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/cake.example&lt;/a&gt;上接入了3个CI服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201803/168328-20180304115601425-1651385627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.1 Cake with AppVeyor&lt;/h2&gt;
&lt;p&gt;AppVeyor主要提供有windows的ci环境，我们只需要再github的项目根目录添加 &lt;span class=&quot;cnblogs_code&quot;&gt;appveyor.yml&lt;/span&gt; 文件，然后关联一下AppVeyor的服务即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; version: 1.0&lt;span&gt;.{build}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; image: Visual Studio 2017
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;build: off
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;test_script:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; - ps: ./build.ps1 -target test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个示例调用了build.ps1来运行测试&lt;a href=&quot;https://ci.appveyor.com/project/linianhui/cake-example&quot; target=&quot;_blank&quot;&gt;https://ci.appveyor.com/project/linianhui/cake-example&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.2 Cake with Travis&lt;/h2&gt;
&lt;p&gt;Travis提供有linux的ci环境，同样的我们添加一个 &lt;span class=&quot;cnblogs_code&quot;&gt;.travis.yml&lt;/span&gt; 文件然后关联Travis的服务即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;language: csharp
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;os:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  - linux
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;mono: latest
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; dotnet: 2.1.4
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;script:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  - chmod +x ./build.sh
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   - ./build.sh -target=test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个示例的运行环境是linux，安装了mone和dotnet，然后调用了build.sh来运行测试&lt;a href=&quot;https://travis-ci.org/linianhui/cake.example&quot; target=&quot;_blank&quot;&gt;https://travis-ci.org/linianhui/cake.example&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.3 Cake with Circle&lt;/h2&gt;
&lt;p&gt;Circle提供有docker的环境，同样的添加一个 &lt;span class=&quot;cnblogs_code&quot;&gt;.circleci/config.yml&lt;/span&gt; 文件然后关联Circle的服务即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: 2
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;jobs:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  test:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    docker:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      - image: lnhcode/dotnet2-mono5
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    steps:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      - checkout
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      - run: chmod +x ./build.sh
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       - run: ./build.sh -target=&lt;span&gt;test
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;workflows:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   version: 2
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  test:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    jobs:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       - test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例中我使用了自己定义的一个dotnet2-mono2的docker镜像，然后调用builds.sh来运行测试&lt;a href=&quot;https://circleci.com/gh/linianhui/cake.example/tree/master&quot; target=&quot;_blank&quot;&gt;https://circleci.com/gh/linianhui/cake.example/tree/master&lt;/a&gt;。dotnet2-mono5的镜像位于：&lt;a href=&quot;https://hub.docker.com/r/lnhcode/dotnet2-mono5/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/lnhcode/dotnet2-mono5/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上简单的介绍了一下Cake的简介信息，和如何再不同的CI环境中使用Cake来维护一个相同的自动化构建的流程。如有错误，欢迎指正！&lt;/p&gt;

&lt;p&gt;dotnet2-mono5 的dockerfile：&lt;a href=&quot;https://github.com/linianhui/dockerfiles/blob/master/dotnet2-mono5/Dockerfile&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/dockerfiles/blob/master/dotnet2-mono5/Dockerfile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文示例代码：&lt;a href=&quot;https://github.com/linianhui/cake.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/cake.example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不要再CI/CD中编程：&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/programming-in-your-ci-cd-tool&quot; target=&quot;_blank&quot;&gt;https://www.thoughtworks.com/radar/techniques/programming-in-your-ci-cd-tool&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Mar 2018 04:16:00 +0000</pubDate>
<dc:creator>blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/cake-in-ci.html</dc:identifier>
</item>
<item>
<title>R语言-时间序列 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8504187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8504187.html</guid>
<description>&lt;p&gt;时间序列:可以用来预测未来的参数,&lt;/p&gt;
&lt;p&gt;1.生成时间序列对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; sales &amp;lt;- c(18, 33, 41,  7, 34, 35, 24, 25, 24, 21, 25, 20&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;            22, 31, 40, 29, 25, 21, 22, 54, 31, 25, 26, 35&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.生成时序对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; tsales &amp;lt;- ts(sales,start = c(2003,1),frequency = 12&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;plot(tsales)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.获得对象信息&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;start(tsales)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;end(tsales)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;frequency(tsales)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.对相同取子集&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; tsales.subset &amp;lt;- window(tsales,start=c(2003,5),end=c(2004,6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; tsales.subset
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304103351288-619030523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304103514451-1882122786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:手动生成的时序图&lt;/p&gt;
&lt;p&gt;2.简单移动平均&lt;/p&gt;
&lt;p&gt;案例:尼罗河流量和年份的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;library(forecast)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; opar &amp;lt;- par(no.readonly =&lt;span&gt; T)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; par(mfrow=c(2,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; ylim &amp;lt;-&lt;span&gt; c(min(Nile),max(Nile))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; plot(Nile,main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Raw time series&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; plot(ma(Nile,3),main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Simple Moving Averages (k=3)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylim =&lt;span&gt; ylim)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; plot(ma(Nile,7),main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Simple Moving Averages (k=3)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylim =&lt;span&gt; ylim)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; plot(ma(Nile,15),main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Simple Moving Averages (k=3)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylim =&lt;span&gt; ylim)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; par(opar)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304104007622-1972407348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:随着K值的增大,图像越来越平滑我们需要找到最能反映规律的K值&lt;/p&gt;
&lt;p&gt;3.使用stl做季节性分解&lt;/p&gt;
&lt;p&gt;案例:Arirpassengers年份和乘客的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.画出时间序列&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;plot(AirPassengers)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; lAirpassengers &amp;lt;-&lt;span&gt; log(AirPassengers)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; plot(lAirpassengers,ylab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;log(Airpassengers)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.分解时间序列&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; fit &amp;lt;- stl(lAirpassengers,s.window = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;period&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;plot(fit)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;fit$time.series
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; par(mfrow=c(2,1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.月度图可视化&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; monthplot(AirPassengers,xlab=&lt;span&gt;''&lt;/span&gt;,ylab=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.季度图可视化&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; seasonplot(AirPassengers,year.labels = T,main = &lt;span&gt;''&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304104545205-347975939.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;374&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304104613577-1989207143.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　          原始图                                                                                                                                    对数变换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304104716033-1965863833.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;361&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304104813933-89708290.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　总体趋势图                                                                                                                        月度季度图&lt;/p&gt;


&lt;p&gt; 4.指数预测模型&lt;/p&gt;
&lt;p&gt;　　4.1单指数平滑&lt;/p&gt;
&lt;p&gt;　　　　案例:预测康涅狄格州的气温变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.拟合模型&lt;/span&gt;
fit2 &amp;lt;- ets(nhtemp,model = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ANN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
fit2
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.向前预测&lt;/span&gt;
forecast(fit2,1&lt;span&gt;)
plot(forecast(fit2,&lt;/span&gt;1),xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     ylab &lt;/span&gt;= expression(paste(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Temperature (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,degree*F,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,)),
     main&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New Haven Annual Mean Temperature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.得到准确的度量&lt;/span&gt;
accuracy(fit2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304105357213-642294468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结论:浅灰色是80%的置信区间,深灰色是95%的置信区间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304105618135-1409108377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.2有水平项,斜率和季节项的指数模型&lt;/p&gt;
&lt;p&gt;　　　　案例:预测5个月的乘客流量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.光滑参数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; fit3 &amp;lt;- ets(log(AirPassengers),model = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;accuracy(fit3)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.未来值预测&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; pred &amp;lt;- forecast(fit3,5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;pred
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; plot(pred,main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Forecast for air Travel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Log(Airpassengers)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.使用原始尺度预测&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; pred$mean &amp;lt;-&lt;span&gt; exp(pred$mean)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; pred$lower &amp;lt;-&lt;span&gt; exp(pred$lower)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; pred$upper &amp;lt;-&lt;span&gt; exp(pred$upper)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; p &amp;lt;-&lt;span&gt; cbind(pred$mean,pred$lower,pred$upper)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; dimnames(p)[[2]] &amp;lt;- c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lo 80&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lo 95&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hi 80&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hi 95&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304110107408-1740244691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304110247478-934743644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结论:从表格中可知3月份的将会有509200乘客,95%的置信区间是[454900,570000]&lt;/p&gt;
&lt;p&gt;　　4.3ets自动预测&lt;/p&gt;
&lt;p&gt;　　　　案例:自动预测JohnsonJohnson股票的趋势&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit4 &amp;lt;-&lt;span&gt; ets(JohnsonJohnson)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;fit4
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; plot(forecast(fit4),main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Johnson and Johnson Forecasts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      ylab=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Quarterly Earnings (Dollars)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, xlab=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304110644177-894935372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结论:预测值使用蓝色线表示,浅灰色表示80%置信空间,深灰色表示95%置信空间&lt;/p&gt;
&lt;p&gt;5.ARIMA预测&lt;/p&gt;
&lt;p&gt;步骤:&lt;/p&gt;
&lt;p&gt;　　1.确保时序是平稳的&lt;/p&gt;
&lt;p&gt;　　2.找出合理的模型(选定可能的p值或者q值)&lt;/p&gt;
&lt;p&gt;　　3.拟合模型&lt;/p&gt;
&lt;p&gt;　　4.从统计假设和预测准确性等角度评估模型&lt;/p&gt;
&lt;p&gt;　　5.预测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(tseries)
plot(Nile)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.原始序列差分一次&lt;/span&gt;
&lt;span&gt;ndiffs(Nile)

dNile &lt;/span&gt;&amp;lt;-&lt;span&gt; diff(Nile)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.差分后的图形&lt;/span&gt;
&lt;span&gt;plot(dNile)
adf.test(dNile)
Acf(dNile)
Pacf(dNile)
&lt;/span&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;3.拟合模型&lt;/span&gt;
fit5 &amp;lt;- arima(Nile,order = c(0,1,1&lt;span&gt;))
fit5
accuracy(fit5)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.评价模型&lt;/span&gt;
&lt;span&gt;qqnorm(fit5$residuals)
qqline(fit5$residuals)
Box.test(fit5$residuals,type &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ljung-Box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.预测模型&lt;/span&gt;
forecast(fit5,3&lt;span&gt;)
plot(forecast(fit5,&lt;/span&gt;3),xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Annual Flow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304112520199-1137798664.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;313&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304112553542-1883781791.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　原始图                                                                                                                                        一次差分图形&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304112653033-974234817.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;315&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304112803286-1630420627.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　正态Q-Q图(如果满足正态分布,点会落在图中的线上)                                                                                       使用Arima(0,1,1)模型的预测值&lt;/p&gt;
&lt;p&gt;Arima自动预测&lt;/p&gt;
&lt;p&gt;　　案例:预测3个月之后的太阳黑子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit6 &amp;lt;-&lt;span&gt; auto.arima(sunspots)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;fit6
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; forecast(fit6,3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;accuracy(fit6)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; plot(forecast(fit6,3), xlab = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      ylab = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Monthly sunspot numbers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180304112957940-1105412558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　结论:函数自动选定(2,1,2)与其他模型相比,AIC的值最小,预测结果更准确&lt;/p&gt;
</description>
<pubDate>Sun, 04 Mar 2018 03:31:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8504187.html</dc:identifier>
</item>
<item>
<title>三、文件的操作、函数、类和对象 - 酱紫安</title>
<link>http://www.cnblogs.com/jiangzijiang/p/8503330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangzijiang/p/8503330.html</guid>
<description>&lt;h2 id=&quot;文件的打开与关闭&quot;&gt;文件的打开与关闭&lt;/h2&gt;
&lt;p&gt;在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件&lt;/p&gt;
&lt;p&gt;open(文件名，访问模式)&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
说明:
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;访问模式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;rb&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;wb&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ab&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;r+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。文件指针将会放在文件的开头。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;w+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;a+&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;rb+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;wb+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ab+&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;关闭文件&quot;&gt;&amp;lt;2&amp;gt;关闭文件&lt;/h2&gt;
&lt;p&gt;close( )&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新建一个文件，文件名为:test.txt&lt;/span&gt;
    f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭这个文件&lt;/span&gt;
    f.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;文件的读写&quot;&gt;文件的读写&lt;/h2&gt;
&lt;h2 id=&quot;写数据write&quot;&gt;&amp;lt;1&amp;gt;写数据(write)&lt;/h2&gt;
&lt;p&gt;使用write()可以完成向文件写入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;demo:


f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world, i am here!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;读数据read&quot;&gt;&amp;lt;2&amp;gt;读数据(read)&lt;/h2&gt;
&lt;p&gt;使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;demo:

f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

content &lt;/span&gt;= f.read(5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(content)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;*30&lt;span&gt;)

content &lt;/span&gt;=&lt;span&gt; f.read()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(content)

f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果open是打开一个文件，那么可以不用谢打开的模式，即只写 &lt;code&gt;open('test.txt')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;读数据（readlines）&quot;&gt;&amp;lt;3&amp;gt;读数据（readlines）&lt;/h2&gt;
&lt;p&gt;就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

content &lt;/span&gt;=&lt;span&gt; f.readlines()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(content))

i&lt;/span&gt;=1
&lt;span&gt;for&lt;/span&gt; temp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; content:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(i, temp))
    i&lt;/span&gt;+=1&lt;span&gt;

f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;读数据（readline）&quot;&gt;&amp;lt;4&amp;gt;读数据（readline）&lt;/h2&gt;
&lt;p&gt;一行一行读&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

content &lt;/span&gt;=&lt;span&gt; f.readline()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;content)

content &lt;/span&gt;=&lt;span&gt; f.readline()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;content)

f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件的随机读写&quot;&gt;文件的随机读写&lt;/h2&gt;
&lt;h2 id=&quot;获取当前读写的位置&quot;&gt;&amp;lt;1&amp;gt;获取当前读写的位置&lt;/h2&gt;
&lt;p&gt;在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开一个已经存在的文件&lt;/span&gt;
    f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    str &lt;/span&gt;= f.read(3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;（ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取的数据是 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str）

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找当前位置&lt;/span&gt;
    position =&lt;span&gt; f.tell()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前文件位置 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, position

    str &lt;/span&gt;= f.read(3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取的数据是 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找当前位置&lt;/span&gt;
    position =&lt;span&gt; f.tell()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前文件位置 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, position)

    f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;定位到某个位置&quot;&gt;&amp;lt;2&amp;gt;定位到某个位置&lt;/h2&gt;
&lt;p&gt;如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()&lt;/p&gt;
&lt;p&gt;seek(offset, from)有2个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;offset:偏移量&lt;/li&gt;
&lt;li&gt;from:方向
&lt;ul&gt;&lt;li&gt;0:表示文件开头&lt;/li&gt;
&lt;li&gt;1:表示当前位置&lt;/li&gt;
&lt;li&gt;2:表示文件末尾&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;demo:把位置设置为：从文件开头，偏移5个字节&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开一个已经存在的文件&lt;/span&gt;
    f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    str &lt;/span&gt;= f.read(30&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取的数据是 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找当前位置&lt;/span&gt;
    position =&lt;span&gt; f.tell()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前文件位置 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, position)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新设置位置&lt;/span&gt;
    f.seek(5&lt;span&gt;,0)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找当前位置&lt;/span&gt;
    position =&lt;span&gt; f.tell()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前文件位置 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, position)

    f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;demo:把位置设置为：离文件末尾，3字节处&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开一个已经存在的文件&lt;/span&gt;
    f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找当前位置&lt;/span&gt;
    position =&lt;span&gt; f.tell()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前文件位置 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, position)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新设置位置&lt;/span&gt;
    f.seek(-3,2&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取到的数据为：文件最后3个字节数据&lt;/span&gt;
    str =&lt;span&gt; f.read()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取的数据是 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str)

    f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;文件的重命名、删除&quot;&gt;文件的重命名、删除&lt;/h2&gt;
&lt;p&gt;有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能&lt;/p&gt;
&lt;h2 id=&quot;文件重命名&quot;&gt;&amp;lt;1&amp;gt;文件重命名&lt;/h2&gt;
&lt;p&gt;os模块中的rename()可以完成对文件的重命名操作&lt;/p&gt;
&lt;p&gt;rename(需要修改的文件名, 新的文件名)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

    os.rename(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;毕业论文.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;毕业论文-最终版.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&amp;lt;2&amp;gt;删除文件
&lt;/pre&gt;
&lt;p&gt;os模块中的remove()可以完成对文件的删除操作&lt;/p&gt;
&lt;p&gt;remove(待删除的文件名)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

    os.remove(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;毕业论文.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;文件夹的相关操作&quot;&gt;文件夹的相关操作&lt;/h2&gt;
&lt;p&gt;实际开发中，有时需要用程序的方式对文件夹进行一定的操作，比如创建、删除等&lt;/p&gt;
&lt;p&gt;就像对文件操作需要os模块一样，如果要操作文件夹，同样需要os模块&lt;/p&gt;
&lt;h2 id=&quot;创建文件夹&quot;&gt;&amp;lt;1&amp;gt;创建文件夹&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

    os.mkdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;获取当前目录&quot;&gt;&amp;lt;2&amp;gt;获取当前目录&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

 os.getcwd()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;改变默认目录&quot;&gt;&amp;lt;3&amp;gt;改变默认目录&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

os.chdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;获取目录列表&quot;&gt;&amp;lt;4&amp;gt;获取目录列表&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

os.listdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;删除文件夹&quot;&gt;&amp;lt;5&amp;gt;删除文件夹&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

os.rmdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;）&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;函数定义和调用&quot;&gt;函数定义和调用&lt;/h2&gt;
&lt;h2 id=&quot;定义函数&quot;&gt;&amp;lt;1&amp;gt;定义函数&lt;/h2&gt;
&lt;p&gt;定义函数的格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;def&lt;/span&gt;&lt;span&gt; 函数名():
        代码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;demo:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个函数，能够完成打印信息的功能&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; printInfo():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;（ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;------------------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;）
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; （&lt;span&gt;'&lt;/span&gt;&lt;span&gt;         人生苦短，我用Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;）
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;（ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;------------------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;）
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;调用函数&quot;&gt;&amp;lt;2&amp;gt;调用函数&lt;/h2&gt;
&lt;p&gt;定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它&lt;/p&gt;
&lt;p&gt;调用函数很简单的，通过 函数名() 即可完成调用&lt;/p&gt;
&lt;p&gt;demo:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义完函数后，函数是不会自动执行的，需要调用它才可以&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; （Info()）
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;4种函数的类型&quot;&gt;4种函数的类型&lt;/h2&gt;
&lt;p&gt;函数根据有没有参数，有没有返回值，可以相互组合，一共有4种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参数，无返回值&lt;/li&gt;
&lt;li&gt;无参数，有返回值&lt;/li&gt;
&lt;li&gt;有参数，无返回值&lt;/li&gt;
&lt;li&gt;有参数，有返回值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;无参数，无返回值的函数&quot;&gt;&amp;lt;1&amp;gt;无参数，无返回值的函数&lt;/h2&gt;
&lt;p&gt;此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;def&lt;/span&gt;&lt;span&gt; printMenu():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;      xx涮涮锅 点菜系统&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  1.  羊肉涮涮锅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  2.  牛肉涮涮锅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  3.  猪肉涮涮锅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;无参数无返回值&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;无参数，有返回值的函数&quot;&gt;&amp;lt;2&amp;gt;无参数，有返回值的函数&lt;/h2&gt;
&lt;p&gt;此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取温度&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getTemperature():

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里是获取温度的一些处理过程&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;为了简单起见，先模拟返回一个数据&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 24&lt;span&gt;

    temperature &lt;/span&gt;=&lt;span&gt; getTemperature()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;当前的温度为:%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%temperature)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;有参数，无返回值的函数&quot;&gt;&amp;lt;3&amp;gt;有参数，无返回值的函数&lt;/h2&gt;
&lt;p&gt;此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数&lt;/p&gt;
&lt;h2 id=&quot;有参数，有返回值的函数&quot;&gt;&amp;lt;4&amp;gt;有参数，有返回值的函数&lt;/h2&gt;
&lt;p&gt;此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算1~num的累积和&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calculateNum(num):

        result &lt;/span&gt;=&lt;span&gt; 0
        i &lt;/span&gt;= 1
        &lt;span&gt;while&lt;/span&gt; i&amp;lt;=&lt;span&gt;num:

            result &lt;/span&gt;= result +&lt;span&gt; i

            i&lt;/span&gt;+=1

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    result &lt;/span&gt;= calculateNum(100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1~100的累积和为:%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%result)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;函数的嵌套调用&quot;&gt;函数的嵌套调用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317826/201803/1317826-20180303222008754-1593403028.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;439&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;一个函数里面又调用了另外一个函数，这就是所谓的函数嵌套调用 &lt;img alt=&quot;函数嵌套调用&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;局部变量&quot;&gt;局部变量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;局部变量，就是在函数内部定义的变量&lt;/li&gt;
&lt;li&gt;不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响&lt;/li&gt;
&lt;li&gt;局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;全局变量&quot;&gt;全局变量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在函数外边定义的变量叫做&lt;code&gt;全局变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全局变量能够在所有的如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。函数中进行访问&lt;/li&gt;
&lt;li&gt;如果在函数中修改全局变量，那么就需要使用&lt;code&gt;global&lt;/code&gt;进行声明，否则出错&lt;/li&gt;
&lt;li&gt;如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。&lt;/li&gt;
&lt;li&gt;对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;code class=&quot;lang-python&quot;/&gt;递归函数&lt;/h2&gt;
&lt;p&gt;如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。&lt;/p&gt;
&lt;p&gt;lambda函数的语法只包含一个语句，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;lambda [arg1 [,arg2,.....argn]]:expression
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 sum = &lt;span&gt;lambda&lt;/span&gt; arg1, arg2: arg1 +&lt;span&gt; arg2

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用sum函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value of total : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sum( 10, 20&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value of total : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sum( 20, 20 )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上实例输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    Value of total :  30&lt;span&gt;
    Value of total :  &lt;/span&gt;40
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;定义一个类，格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; 类名:
    方法列表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;demo：定义一个Car类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getCarInfo(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;车轮子个数:%d, 颜色%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(self.wheelNum, self.color))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; move(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;车正在移动...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义类时有2种：新式类和经典类，上面的Car为经典类，如果是Car(object)则为新式类&lt;/li&gt;
&lt;li&gt;类名 的命名规则按照&quot;大驼峰&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建对象&quot;&gt;创建对象&lt;/h2&gt;
&lt;p&gt;创建对象的格式为:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;对象名 = 类名()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;init方法&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;方法&lt;/h2&gt;
&lt;p id=&quot;使用方式&quot;&gt;使用方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; 类名:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化函数，用来完成一些默认的设定&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;__init__()&lt;/code&gt;方法，在创建一个对象时默认被调用，不需要手动调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__(self)&lt;/code&gt;中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么&lt;code&gt;__init__(self)&lt;/code&gt;中出了self作为第一个形参外还需要2个形参，例如&lt;code&gt;__init__(self,x,y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__(self)&lt;/code&gt;中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-定义str方法&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, newWheelNum, newColor):
        self.wheelNum &lt;/span&gt;=&lt;span&gt; newWheelNum
        self.color &lt;/span&gt;=&lt;span&gt; newColor

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;嘿。。。我的颜色是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + self.color + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我有&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + int(self.wheelNum) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个轮胎...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; move(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;车在跑，目标:夏威夷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


BMW &lt;/span&gt;= Car(4, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;白色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(BMW)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在python中方法名如果是&lt;code&gt;__xxxx__()&lt;/code&gt;的，那么就有特殊的功能，因此叫做“魔法”方法&lt;/li&gt;
&lt;li&gt;当使用print输出对象的时候，只要自己定义了&lt;code&gt;__str__(self)&lt;/code&gt;方法，那么就会打印从在这个方法中return的数据&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;self&quot;&gt;self&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;所谓的self，可以理解为自己&lt;/li&gt;
&lt;li&gt;可以把self当做C++中类里面的this指针一样理解，就是对象自身的意思&lt;/li&gt;
&lt;li&gt;某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可&lt;code class=&quot;lang-python&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个飞机大战的雏形（用到了pygame,挺好学的，学累了可以用它弄点自己简单的小游戏。练练Python的基本语法）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pygame
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pygame.locals &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HeroPlane(object):
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,screen):
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置飞机默认的位置&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         self.x = 230
&lt;span&gt; 14&lt;/span&gt;         self.y = 600
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置要显示内容的窗口&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         self.screen =&lt;span&gt; screen
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;         self.imageName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./feiji/hero.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         self.image =&lt;span&gt; pygame.image.load(self.imageName).convert()
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来存储英雄飞机发射的所有子弹&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         self.bulletList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; display(self):
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新飞机的位置&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        self.screen.blit(self.image,(self.x,self.y))
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这种方法会漏掉很多需要删除的数据&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for i in self.bulletList:&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     if i.y&amp;lt;0:&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         self.bulletList.remove(i)&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存放需要删除的对象信息&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         needDelItemList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.bulletList:
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.judge():
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                needDelItemList.append(i)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; needDelItemList:
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            self.bulletList.remove(i)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; del needDelItemList&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新及这架飞机发射出的所有子弹的位置&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; bullet &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.bulletList:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            bullet.display()
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            bullet.move()
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改所有子弹的位置&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for bullet in self.bulletList:&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     bullet.y -= 2&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; moveLeft(self):
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         self.x -= 10
&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; moveRight(self):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         self.x += 10
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; sheBullet(self):
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         newBullet =&lt;span&gt; Bullet(self.x,self.y,self.screen)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        self.bulletList.append(newBullet)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bullet(object):
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,x,y,screen):
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         self.x = x+40
&lt;span&gt; 70&lt;/span&gt;         self.y = y-20
&lt;span&gt; 71&lt;/span&gt;         self.screen =&lt;span&gt; screen
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         self.image = pygame.image.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./feiji/bullet-3.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).convert()
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; move(self):
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         self.y -= 2
&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; display(self):
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        self.screen.blit(self.image,(self.x,self.y))
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; judge(self):
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.y&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnemyPlane(object):
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,screen):
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置飞机默认的位置&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         self.x =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         self.y =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置要显示内容的窗口&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;         self.screen =&lt;span&gt; screen
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;         self.imageName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./feiji/enemy-1.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;         self.image =&lt;span&gt; pygame.image.load(self.imageName).convert()
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来存储敌人飞机发射的所有子弹&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         self.bulletList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         self.direction = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; display(self):
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新飞机的位置&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        self.screen.blit(self.image,(self.x,self.y))
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这种方法会漏掉很多需要删除的数据&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for i in self.bulletList:&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     if i.y&amp;lt;0:&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         self.bulletList.remove(i)&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存放需要删除的对象信息&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;         needDelItemList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.bulletList:
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; i.judge():
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                needDelItemList.append(i)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; needDelItemList:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            self.bulletList.remove(i)
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; del needDelItemList&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新及这架飞机发射出的所有子弹的位置&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; bullet &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.bulletList:
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            bullet.display()
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            bullet.move()
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; move(self):
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果碰到了右边的边界，那么就往左走，如果碰到了左边的边界，那么就往右走&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             self.x += 2
&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; self.direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             self.x -= 2
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.x&amp;gt;480-50&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             self.direction = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; self.x&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             self.direction = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; sheBullet(self):
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         num = random.randint(1,100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; num == 88&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             newBullet =&lt;span&gt; EnemyBullet(self.x,self.y,self.screen)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;            self.bulletList.append(newBullet)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnemyBullet(object):
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,x,y,screen):
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;         self.x = x+30
&lt;span&gt;155&lt;/span&gt;         self.y = y+30
&lt;span&gt;156&lt;/span&gt;         self.screen =&lt;span&gt; screen
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         self.image = pygame.image.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./feiji/bullet-1.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).convert()
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; move(self):
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         self.y += 2
&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; display(self):
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;        self.screen.blit(self.image,(self.x,self.y))
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; judge(self):
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.y&amp;gt;890&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1. 创建一个窗口，用来显示内容&lt;/span&gt;
&lt;span&gt;175&lt;/span&gt;     screen = pygame.display.set_mode((480,890),0,32&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 创建一个和窗口大小的图片，用来充当背景&lt;/span&gt;
&lt;span&gt;178&lt;/span&gt;     background = pygame.image.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./feiji/background.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).convert()
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 创建一个飞机对象&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;     heroPlane =&lt;span&gt; HeroPlane(screen)
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4. 创建一个敌人飞机&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;     enemyPlane =&lt;span&gt; EnemyPlane(screen)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; 
&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 把背景图片放到窗口中显示&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;        screen.blit(background,(0,0))
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;        heroPlane.display()
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;        enemyPlane.move()
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;        enemyPlane.sheBullet()
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;        enemyPlane.display()
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; 
&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断是否是点击了退出按钮&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; event &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pygame.event.get():
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(event.type)&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; event.type ==&lt;span&gt; QUIT:
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;                exit()
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; KEYDOWN:
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; event.key == K_a &lt;span&gt;or&lt;/span&gt; event.key ==&lt;span&gt; K_LEFT:
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;                    heroPlane.moveLeft()
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;控制飞机让其向左移动&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt;                 &lt;span&gt;elif&lt;/span&gt; event.key == K_d &lt;span&gt;or&lt;/span&gt; event.key ==&lt;span&gt; K_RIGHT:
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                    heroPlane.moveRight()
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                 &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; K_SPACE:
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;                    heroPlane.sheBullet()
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; 
&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过延时的方式，来降低这个while循环的循环速度，从而降低了cpu占用率&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;         time.sleep(0.01&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;         pygame.display.update()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1317826/201803/1317826-20180304095755712-1049870418.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;610&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Mar 2018 02:00:00 +0000</pubDate>
<dc:creator>酱紫安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangzijiang/p/8503330.html</dc:identifier>
</item>
<item>
<title>Minikube之Win10单机部署 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8503839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8503839.html</guid>
<description>&lt;p&gt;Kubernetes（k8s）是自动化容器操作的开源平台，基于这个平台，你可以进行容器部署，资源调度和集群扩容等操作。如果你曾经用过Docker部署容器，那么可以将Docker看成Kubernetes底层使用的组件，Kubernetes是Docker的上层封装，通过它可以很方便的进行Docker集群的管理。今天我们使用minikube在单机上进行Kubernetes集群的部署，目的是让我们对k8s有个初步的认识,方便自己快速搭建并体验Kubernetes.&lt;/p&gt;

&lt;p&gt;首先安装docker环境，不详细说明了，网上资料一大堆，可以参考官方安装文档 &lt;a title=&quot;https://docs.docker.com/docker-for-windows/install/&quot; href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;https://docs.docker.com/docker-for-windows/install/&lt;/a&gt;  ,要求Win10 Pro以上&lt;/p&gt;

&lt;p&gt;为了方便大家开发和体验Kubernetes，社区提供了可以在本地部署的&lt;a href=&quot;https://github.com/kubernetes/minikube&quot;&gt;Minikube&lt;/a&gt;。由于网络访问原因，很多朋友无法使用minikube进行实验。可以从阿里云的镜像地址来获取所需Docker镜像和配置。参考 &lt;a title=&quot;https://yq.aliyun.com/articles/221687&quot; href=&quot;https://yq.aliyun.com/articles/221687&quot;&gt;https://yq.aliyun.com/articles/221687&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;在Windows环境下，如果开启了Hyper-V，不支持VirtualBox方式，我们以Hyper-V方式安装 ，下载 &lt;a href=&quot;http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.25.0/minikube-windows-amd64.exe&quot;&gt;minikube-windows-amd64.exe&lt;/a&gt; 文件，并重命名为 &lt;code&gt;minikube.exe. 我们在c盘下创建一个文件夹叫做Kubernetes，放到Kubernetes 下，同时下载&lt;/code&gt;&lt;code&gt;kubectl&lt;/code&gt; &lt;code&gt;&lt;a title=&quot;https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe&quot; href=&quot;https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe&quot;&gt;https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe&lt;/a&gt;，kubectl即kubernetes的客户端，通过他可以进行类似docker run等容器管理操作。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094731202-1806588599.png&quot;&gt;&lt;img width=&quot;654&quot; height=&quot;180&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094734014-845562024.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载minikube和kubectl放到PATH路径下（bin目录已经在PATH中）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094734686-2129196290.png&quot;&gt;&lt;img width=&quot;496&quot; height=&quot;471&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094735389-809668852.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先应该打开Hyper-V管理器创建一个外部虚拟交换机&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094736217-1576906402.png&quot;&gt;&lt;img width=&quot;463&quot; height=&quot;329&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094736889-1679280780.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094737249-1298731886.png&quot;&gt;&lt;img width=&quot;462&quot; height=&quot;424&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094737530-1787615147.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后，我们可以用如下命令来创建基于Hyper-V的Kubernetes测试环境&lt;/p&gt;

&lt;p&gt;.\minikube.exe start --registry-mirror=&lt;a href=&quot;https://registry.docker-cn.com&quot;&gt;https://registry.docker-cn.com&lt;/a&gt; --vm-driver=&quot;hyperv&quot; --memory=4096 --hyperv-virtual-switch=&quot;minikubeSwitch&quot;&lt;/p&gt;

&lt;p&gt;注：需要管理员权限来创建Hyper-V虚拟机&lt;/p&gt;

&lt;p&gt;首次启动会下载localkube，下载过程可能会失败，重试几次即可&lt;/p&gt;


&lt;p&gt;Minikube利用本地虚拟机环境部署Kubernetes，其基本架构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;900&quot; height=&quot;675&quot; alt=&quot;4&quot; src=&quot;https://yqfile.alicdn.com/c03a43e0731ca579d1844fb44269fd2fd257bfb3.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户使用Minikube CLI管理虚拟机上的Kubernetes环境，比如：启动，停止，删除，获取状态等。一旦Minikube虚拟机启动，用户就可以使用熟悉的Kubectl CLI在Kubernetes集群上执行操作。&lt;/p&gt;

&lt;h2&gt;打开Kubernetes控制台&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;minikube dashboard， 首次打开要下载，下载过程可能会失败，重试几次即可，打开就可以看到类似界面&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094737827-1416123883.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;627&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201803/510-20180304094738139-690933723.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;pre&gt;
参考文章：
&lt;/pre&gt;
&lt;pre&gt;
&lt;a title=&quot;https://blogs.msdn.microsoft.com/wasimbloch/2017/01/23/setting-up-kubernetes-on-windows10-laptop-with-minikube/&quot; href=&quot;https://blogs.msdn.microsoft.com/wasimbloch/2017/01/23/setting-up-kubernetes-on-windows10-laptop-with-minikube/&quot;&gt;https://blogs.msdn.microsoft.com/wasimbloch/2017/01/23/setting-up-kubernetes-on-windows10-laptop-with-minikube/&lt;/a&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;a title=&quot;https://qii404.me/2018/01/06/minukube.html&quot; href=&quot;https://qii404.me/2018/01/06/minukube.html&quot;&gt;https://qii404.me/2018/01/06/minukube.html&lt;/a&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;a title=&quot;https://yq.aliyun.com/articles/221687&quot; href=&quot;https://yq.aliyun.com/articles/221687&quot;&gt;https://yq.aliyun.com/articles/221687&lt;/a&gt; 
&lt;/pre&gt;</description>
<pubDate>Sun, 04 Mar 2018 01:48:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8503839.html</dc:identifier>
</item>
<item>
<title>常系数线性齐次递推 - RogerDTZ</title>
<link>http://www.cnblogs.com/RogerDTZ/p/8503773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RogerDTZ/p/8503773.html</guid>
<description>&lt;p&gt;给定数列前k项&lt;span class=&quot;math inline&quot;&gt;\(h_0...h_{k-1}\)&lt;/span&gt;，其后的项满足：&lt;span class=&quot;math inline&quot;&gt;\(h_i=\sum_{i=1}^kh_{i-j}a_i\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(a_1...a_k\)&lt;/span&gt;是给定的系数，求&lt;span class=&quot;math inline&quot;&gt;\(h_n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据范围小的时候：&lt;/p&gt;
&lt;p&gt;​ 做法一：暴力&lt;span class=&quot;math inline&quot;&gt;\(O(nk)\)&lt;/span&gt;的DP&lt;/p&gt;
&lt;p&gt;​ 做法二：矩阵快速幂.&lt;/p&gt;
&lt;p&gt;​ 记&lt;span class=&quot;math inline&quot;&gt;\(H_i=\begin{bmatrix}h_i&amp;amp;h_{i+1}&amp;amp;...&amp;amp;h_{i+k-1}\end{bmatrix}\)&lt;/span&gt;. 则&lt;span class=&quot;math inline&quot;&gt;\(h_n\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(H_{n-k+1}\)&lt;/span&gt;的最后一项。&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math inline&quot;&gt;\(H_{n-k+1}=H_0M^{n-k+1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 其中&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;是转移矩阵，如当&lt;span class=&quot;math inline&quot;&gt;\(k=4\)&lt;/span&gt;时是这么填的：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ M=\begin{bmatrix} 0&amp;amp;0&amp;amp;0&amp;amp;a_4\\ 1&amp;amp;0&amp;amp;0&amp;amp;a_3\\ 0&amp;amp;1&amp;amp;0&amp;amp;a_2\\ 0&amp;amp;0&amp;amp;1&amp;amp;a_1 \end{bmatrix} \]&lt;/span&gt;&lt;br/&gt;​ 时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(k^3lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据范围大一些的时候：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math inline&quot;&gt;\(k\leq2000,n\leq10^9\)&lt;/span&gt;. 这时候矩阵快速幂也做不了了&lt;/p&gt;
&lt;p&gt;​ 还是拿&lt;span class=&quot;math inline&quot;&gt;\(k=4\)&lt;/span&gt;时举例，&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的特征多项式&lt;span class=&quot;math inline&quot;&gt;\(f(\lambda)\)&lt;/span&gt;为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(\lambda)=det(\lambda I-M)=\begin{bmatrix} \lambda&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\lambda&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;\lambda&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;\lambda \end{bmatrix} -\begin{bmatrix} 0&amp;amp;0&amp;amp;0&amp;amp;a_4\\ 1&amp;amp;0&amp;amp;0&amp;amp;a_3\\ 0&amp;amp;1&amp;amp;0&amp;amp;a_2\\ 0&amp;amp;0&amp;amp;1&amp;amp;a_1 \end{bmatrix}=\begin{bmatrix} \lambda&amp;amp;0&amp;amp;0&amp;amp;-a_4\\ -1&amp;amp;\lambda&amp;amp;0&amp;amp;-a_3\\ 0&amp;amp;-1&amp;amp;\lambda&amp;amp;-a_2\\ 0&amp;amp;0&amp;amp;-1&amp;amp;\lambda-a_1 \end{bmatrix} \]&lt;/span&gt;&lt;br/&gt;​ 用行列式的性质，将&lt;span class=&quot;math inline&quot;&gt;\(f(\lambda)\)&lt;/span&gt;按最后一列拉普拉斯展开，得到如下，其中&lt;span class=&quot;math inline&quot;&gt;\((-1)^{i+j}f(x)_{i,j}\)&lt;/span&gt;即行列式定义里的代数余子式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} f(\lambda)&amp;amp;=\sum_{i=1}^ka_{k-i+1}(-1)^{i+j}f(\lambda)_{i,j} &amp;amp;取j=k（按最后一列展开）\\ &amp;amp;=\sum_{i=1}^ka_{k-i+1}(-1)^{i+k}f(\lambda)_{i,k} \end{aligned} \]&lt;/span&gt;&lt;br/&gt;​ 化简得到如下式子（也可以按&lt;span class=&quot;math inline&quot;&gt;\(k=4\)&lt;/span&gt;带进去看看规律）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(\lambda)=\lambda^k-\sum_{i=1}^ka_i\lambda^{k-i} \]&lt;/span&gt;&lt;br/&gt;​ &lt;em&gt;现在明确一个定义，&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;这个函数的自变量&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;可以是实数，也可以是矩阵等等。这个函数仅仅是表示如何将自变量组合起来。表达的意思也会多样化，比如多项式、矩阵的多项式...下文会随时切换自变量的种类，但是函数的本质不变。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的特征值，是一个数。但是根据Cayley-Hamilton定理，如果把&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;替换成&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;代入得到&lt;span class=&quot;math inline&quot;&gt;\(f(M)=M^k-\sum_{i=1}^ka_iM^{k-i}\)&lt;/span&gt;，结果为一个零矩阵，即&lt;span class=&quot;math inline&quot;&gt;\(M^k-\sum_{i=1}^ka_iM^{k-i}=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 我们想要求&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次方（这里的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;只是代表&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次方，题目中&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;应该用&lt;span class=&quot;math inline&quot;&gt;\(n-k+1\)&lt;/span&gt;替代），然而&lt;span class=&quot;math inline&quot;&gt;\(M^n\)&lt;/span&gt;直接快速幂求不现实，复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(k^3lg n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;​ 首先退一步考虑，要求一个数字的n次方&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;，如果我们把&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;对&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;取模会发生什么？&lt;/p&gt;
&lt;p&gt;​ 根据多项式取模的定义，&lt;span class=&quot;math inline&quot;&gt;\(x^n modf(x)=f(x)g(x)+r(x)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r(x)\)&lt;/span&gt;是两个多项式（自变量为矩阵的多项式）.&lt;/p&gt;
&lt;p&gt;​ 将&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;看成&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(f(M)\)&lt;/span&gt;为0.&lt;/p&gt;
&lt;p&gt;​ 故&lt;span class=&quot;math inline&quot;&gt;\(M^nmodf(M)=r(M)\)&lt;/span&gt;，且&lt;span class=&quot;math inline&quot;&gt;\(M^n=M^nmodf(M)\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(M_n=r(M)\)&lt;/span&gt;这个多项式&lt;/p&gt;
&lt;p&gt;​ 根据多项式取模的特性，&lt;span class=&quot;math inline&quot;&gt;\(r(x)\)&lt;/span&gt;的阶数严格小于模数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的阶数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;(最高次项是&lt;span class=&quot;math inline&quot;&gt;\(x^k\)&lt;/span&gt;). 那么&lt;span class=&quot;math inline&quot;&gt;\(r(x)\)&lt;/span&gt;所包含的&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的指数一定小于&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，到达了可以计算的范围。&lt;/p&gt;
&lt;p&gt;​ 要求&lt;span class=&quot;math inline&quot;&gt;\(M^n\)&lt;/span&gt;，就只需要求&lt;span class=&quot;math inline&quot;&gt;\(M^n mod f(M)\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(r(M)\)&lt;/span&gt;。如果两个多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;对模数取模分别得到&lt;span class=&quot;math inline&quot;&gt;\(C(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(D(x)\)&lt;/span&gt;，那么多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)B(x)\)&lt;/span&gt;对模数取模结果就是&lt;span class=&quot;math inline&quot;&gt;\(C(x)D(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​ 那么就可以用快速幂来求解&lt;span class=&quot;math inline&quot;&gt;\(M^nmodf(M)\)&lt;/span&gt;的结果了，也就是求出了&lt;span class=&quot;math inline&quot;&gt;\(r(x)\)&lt;/span&gt;的各项系数（记为&lt;span class=&quot;math inline&quot;&gt;\(c_i\)&lt;/span&gt;）。实际计算中，表面上是在计算&lt;span class=&quot;math inline&quot;&gt;\(M^n\)&lt;/span&gt;，实际上计算的是&lt;span class=&quot;math inline&quot;&gt;\(M^nmodf(M)\)&lt;/span&gt;的结果。&lt;/p&gt;
&lt;p&gt;​ 至此求出&lt;span class=&quot;math inline&quot;&gt;\(r(x)=\sum\limits_{i=0}^{k-1}c_ix^i\)&lt;/span&gt;. 将它看成矩阵的多项式代入&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，得&lt;span class=&quot;math inline&quot;&gt;\(r(M)=\sum\limits_{i=0}^{k-1}c_iM^i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 所以&lt;span class=&quot;math inline&quot;&gt;\(M^n=\sum\limits_{i=0}^{k-1}c_iM^i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 把&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;替换成题目所需要的&lt;span class=&quot;math inline&quot;&gt;\(n-k+1\)&lt;/span&gt;，最终答案&lt;span class=&quot;math inline&quot;&gt;\(h_n\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(H_0M^{n-k+1}\)&lt;/span&gt;的最后一项。&lt;/p&gt;
&lt;p&gt;​&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H_0M^{n-k+1}=H_0\sum_{i=0}^{k-1}c_iM^i=\sum_{i=0}^{k-1}c_iH_0M_i=\sum_{i=0}^{k-1}c_iH_i \]&lt;/span&gt;&lt;br/&gt;​ 额那么要求的是&lt;span class=&quot;math inline&quot;&gt;\(H_0M^{n-k+1}\)&lt;/span&gt;的最后一项。记&lt;span class=&quot;math inline&quot;&gt;\(last(H_i)=h_{k+i}\)&lt;/span&gt; ，那么&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ h_n=last(H_0M^{n-k+1})=\sum_{i=0}^{k-1}c_ilast(H_i)=\sum_{i=0}^{k-1}c_ih_{i+k} \]&lt;/span&gt;&lt;br/&gt;​ 发现&lt;span class=&quot;math inline&quot;&gt;\(i+k\in[k,2k-1]\)&lt;/span&gt;，所以暴力算出&lt;span class=&quot;math inline&quot;&gt;\(h_k...h_{2k-1}\)&lt;/span&gt;，代入求解得到&lt;span class=&quot;math inline&quot;&gt;\(h_n\)&lt;/span&gt;，至此全部求完。&lt;/p&gt;
&lt;p&gt;​ 分析复杂度：多项式乘法此处用暴力算会比FFT快，耗时最多的集快速幂求&lt;span class=&quot;math inline&quot;&gt;\(r(x)\)&lt;/span&gt; ，复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(k^2lgn)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​ y&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;cstdio&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; K=&lt;span class=&quot;dv&quot;&gt;4005&lt;/span&gt;,mod=&lt;span class=&quot;fl&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n,k;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a[K],h[K];
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b[K],c[K],t[K],mo[K];
&lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; add(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &amp;amp;x,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; y){
    x+=y;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(x&amp;gt;=mod) x-=mod;
}
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; mul(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *x,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *y,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *z){
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;*k&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;;i++) t[i]=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;k;i++)
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;j&amp;lt;k;j++)
            add(t[i+j],&lt;span class=&quot;dv&quot;&gt;1LL&lt;/span&gt;*x[i]*y[j]%mod);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;*k&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;;i&amp;gt;=k;i--){
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j=k&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;;j&amp;gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;j--)
            add(t[i-k+j],mod&lt;span class=&quot;dv&quot;&gt;-1LL&lt;/span&gt;*t[i]*mo[j]%mod);
        t[i]=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;k;i++) z[i]=t[i];
}
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ksm(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; y){
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;y;mul(b,b,b),y&amp;gt;&amp;gt;=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(y&amp;amp;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            mul(c,b,c);
}
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(){
    freopen(&lt;span class=&quot;st&quot;&gt;&quot;input.in&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;,stdin);
    scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;k); n++;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;i&amp;lt;=k;i++){
        scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&amp;amp;a[i]);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(a[i]&amp;lt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) a[i]+=mod;
    }
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;i&amp;lt;=k;i++){
        scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&amp;amp;h[i]);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(h[i]&amp;lt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) h[i]+=mod;
    }
    mo[k]=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;i&amp;lt;=k;i++) mo[k-i]=mod-a[i];
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(n&amp;lt;=k){printf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,h[n]);&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;}
    b[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; c[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    ksm(n-k);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=k&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;;i&amp;lt;=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;*k;i++)
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;j&amp;lt;=k;j++)
            add(h[i],&lt;span class=&quot;dv&quot;&gt;1LL&lt;/span&gt;*a[j]*h[i-j]%mod);
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ans=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;k;i++) 
        add(ans,&lt;span class=&quot;dv&quot;&gt;1LL&lt;/span&gt;*c[i]*h[i+k]%mod);
    printf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,ans);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;参考资料&quot;&gt;参考资料&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_33229466/article/details/78933309&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_33229466/article/details/78933309&lt;/a&gt; &quot;ORZ&quot;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Mar 2018 01:16:00 +0000</pubDate>
<dc:creator>RogerDTZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RogerDTZ/p/8503773.html</dc:identifier>
</item>
<item>
<title>javascript 面向对象（多种创建对象的方式） - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8503699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8503699.html</guid>
<description>&lt;h3&gt;创建对象&lt;/h3&gt;
&lt;p&gt;第一种：基于Object对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
person.name &lt;/span&gt;= 'My Name'&lt;span&gt;;
person.age &lt;/span&gt;= 18&lt;span&gt;;
person.getName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种：对象字面量方式（比较清楚的查找对象包含的属性及方法）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {
    name : &lt;/span&gt;'My name'&lt;span&gt;,
    age : &lt;/span&gt;18&lt;span&gt;,
    getName : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;使用Object构造函数或对象字面量都可以创建对象，但缺点是创建多个对象时，会产生大量的重复代码，因此下面介绍可解决这个问题的创建对象的方法&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1、工厂模式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.getAge &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person = createPerson('张三', 23&lt;span&gt;);　　
console.log(person.name);    　&lt;span&gt;//'张三'&lt;/span&gt;
console.log(person.age);　　　　&lt;span&gt;//23&lt;/span&gt;
console.log(person.getAge());　　&lt;span&gt;//23&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;缺点：创建对象交给一个工厂方法来实现，可以传递参数，但&lt;span&gt;主要缺点是无法识别对象类型&lt;/span&gt;，因为创建对象都是使用Object的原生构造函数来完成的。&lt;/p&gt;

&lt;h4&gt;2、构造函数模式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    };
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person('张三', 23&lt;span&gt;);
console.log(person.name);　　&lt;span&gt;//'张三'&lt;/span&gt;
console.log(person.age);　　 &lt;span&gt;//23&lt;/span&gt;
console.log(person.getAge());　　&lt;span&gt;//23&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
alert(person instanceof Person);　　&lt;span class=&quot;rem&quot;&gt;//true;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
alert(person instanceof Object);　　&lt;span class=&quot;rem&quot;&gt;//true;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有显式地创建对象&lt;/li&gt;
&lt;li&gt;直接将属性和方法赋值给this对象；&lt;/li&gt;
&lt;li&gt;没有return语句；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAge =  &lt;span&gt;new&lt;/span&gt; Function (&quot;return this.age&quot;&lt;span&gt;);　　//和上面是一样的，会重复创建多个函数
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;缺点：上述代码，创建多个实例时，&lt;span&gt;会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中&lt;/span&gt;，当然这一般不会有错，但这会造成内存浪费。&lt;/p&gt;

&lt;h4&gt;3、原型模式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}
Person.prototype.age &lt;/span&gt;= 23&lt;span&gt;;
Person.prototype.getAge &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person('张三'&lt;span&gt;);
console.log(person.name);　　//'张三'
console.log(person.age);　　//23
console.log(person.getAge());　　//23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JS每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，&lt;span&gt;它是所有通过new操作符使用函数创建的实例的原型对象&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原型对象最大特点是，所有对象实例共享它所包含的属性和方法，&lt;/span&gt;也就是说，所有在原型对象中创建的属性或方法都直接被所有对象实例共享。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; 实例属性或方法的访问过程是一次搜索过程：&lt;/p&gt;
&lt;ul dir=&quot;ltr&quot;&gt;&lt;li&gt;首先从对象实例本身开始，如果找到属性就直接返回该属性值；&lt;/li&gt;
&lt;li&gt;如果实例本身不存在要查找属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索原则，得到本实例的返回；&lt;strong&gt;简单来说，就是实例中属性会屏蔽原型对象中的属性；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过使用hasOwnProperty()方法来判断，属性是实例本身的，还是原型上的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
person.hasOwnProperty(&quot;name&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true        &lt;/span&gt;
person.hasOwnProperty(&quot;age&quot;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;缺点：最主要是当对象的属性是引用类型时，它的值是不变的，&lt;span&gt;总是引用同一个外部对象，所有实例对该对象任何一个地方产生的改动会引起其他实例的变化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}
Person.prototype.age &lt;/span&gt;= 23&lt;span&gt;;
Person.prototype.color &lt;/span&gt;= ['red', 'yellow'&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person('张三'&lt;span&gt;);
console.log(person1.name);　　//'张三'
console.log(person1.color);　&lt;span&gt;　//[&quot;red&quot;, &quot;yellow&quot;]&lt;/span&gt;
person1.color.push(&lt;/span&gt;'black'&lt;span&gt;);　　
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person('李四'&lt;span&gt;);
console.log(person2.name);　　//'李四'&lt;br/&gt;console.log(person2.color);　　&lt;span&gt;//[&quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;]　　//person1的修改影响了person2&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4、组合使用构造函数模式及原型模式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;目前最为常用的定义类型方式，是组合使用构造函数模式与原型模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数模式用于定义实例的属性，&lt;span&gt;而原型模式用于定义方法和共享的属性。&lt;/span&gt;结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。&lt;/p&gt;
&lt;p&gt;此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color = ['red', 'yellow'&lt;span&gt;];
}
Person.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor : Person,　　&lt;span&gt;//原型字面量形式会将对象的constructor变Object，此外强制指回Person；&lt;/span&gt;
    getAge : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person('张三', 23&lt;span&gt;);
person1.color.push(&lt;/span&gt;'black'&lt;span&gt;);
console.log(person1.name);　　//张三
console.log(person1.color);　　&lt;span&gt;//[&quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;]&lt;/span&gt;
console.log(person1.getAge());　　//23
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person('李四', 24&lt;span&gt;);
console.log(person2.name);　　//李四
console.log(person2.color);　　&lt;span&gt;//['red','yellow']　　&lt;/span&gt;
console.log(person2.getAge());　　//24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt; 5、动态原型模式&lt;/h5&gt;
&lt;p&gt;     组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age, job) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job =&lt;span&gt; job;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lessons = ['Math', 'Physics'&lt;span&gt;];
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getName != 'function') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过判断实例封装&lt;/span&gt;
　　Person.prototype =&lt;span&gt; {
　　　　constructor: Person,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原型字面量方式会将对象的constructor变为Object，此外强制指回Person&lt;/span&gt;
　　　　getName: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
　　　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
　　　　}
　　}
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person('Jack', 19, 'SoftWare Engneer'&lt;span&gt;);
person1.lessons.push(&lt;/span&gt;'Biology'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person('Lily', 39, 'Mechanical Engneer'&lt;span&gt;);
alert(person1.lessons);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Math,Physics,Biology&lt;/span&gt;
alert(person2.lessons);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Math,Physics&lt;/span&gt;
alert(person1.getName === person2.getName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true,//共享原型中定义方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 03 Mar 2018 23:50:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8503699.html</dc:identifier>
</item>
</channel>
</rss>