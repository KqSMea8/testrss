<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>个人简介 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9662464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9662464.html</guid>
<description>[unable to retrieve full-text content]落花四月 Fight For Freedom!!! Email: 1263030049@qq.com Gmail: miraitowa2@gmail.com Github: &quot;https://github.com/Miraitowa&quot; 关于我 1： ，`miraitowa520 miraitowa`</description>
<pubDate>Mon, 17 Sep 2018 07:49:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9662464.html</dc:identifier>
</item>
<item>
<title>python——web 环境搭建 - 无法无天的日子</title>
<link>http://www.cnblogs.com/wfwt180801-/p/9662569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfwt180801-/p/9662569.html</guid>
<description>&lt;p&gt;1.安装引用第三方库 selenium&lt;/p&gt;
&lt;p&gt;pip install selenium&lt;/p&gt;
&lt;p&gt;2.下载浏览器驱动（驱动版本和浏览器版本要对应参考链接 http://npm.taobao.org/mirrors/chromedriver/）&lt;/p&gt;
&lt;p&gt;查看浏览器驱动对应关系，本次已最新驱动版本作为教材讲解  版本2.42  发布时间2018.9.13，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450704/201809/1450704-20180917155216026-1072610891.png&quot; alt=&quot;&quot; width=&quot;1352&quot; height=&quot;703&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面点击打开2.42驱动版本，可以看到有三个版本的驱动， mac windows linux（注意chrome浏览器windows版本中不区分64位和32位直接下载32位版本就可以），点击notes.txt文件查看该版本对应chrmoe浏览器的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450704/201809/1450704-20180917155609564-1961376163.png&quot; alt=&quot;&quot; width=&quot;1168&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450704/201809/1450704-20180917155810102-1283554837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上提供chrome的浏览器驱动对应表，火狐浏览器暂未提供，未能找到官方对应表&lt;/p&gt;
&lt;p&gt;3.浏览器驱动下载后解压至python的安装目录下&lt;/p&gt;
&lt;p&gt;pycharm 编辑器中打开，验证环境是否安装成功，运行以下代码，如正常打开www.baidu.com 则环境安装成功&lt;/p&gt;
&lt;p&gt;import selenium&lt;/p&gt;
&lt;p&gt;abc = webdriver.Chrome()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;abc.get('http://www.baidu.com')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 07:47:00 +0000</pubDate>
<dc:creator>无法无天的日子</dc:creator>
<og:description>1.安装引用第三方库 selenium pip install selenium 2.下载浏览器驱动（驱动版本和浏览器版本要对应参考链接 http://npm.taobao.org/mirrors/c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfwt180801-/p/9662569.html</dc:identifier>
</item>
<item>
<title>java.util.ConcurrentModificationException异常原因及解决方法 - 小张同学-Tonz</title>
<link>http://www.cnblogs.com/tonz/p/9662236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tonz/p/9662236.html</guid>
<description>&lt;p&gt;在java语言中，ArrayList是一个很常用的类，在编程中经常要对ArrayList进行删除操作，在使用remove方法对ArrayList进行删除操作时，报&lt;span&gt;java.util.ConcurrentModificationException&lt;/span&gt;异常，下面探讨一下该异常的原因以及解决办法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         List&amp;lt;Integer&amp;gt; listA=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         listA.add(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         listA.add(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         listA.add(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         listA.add(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         listA.add(5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         listA.add(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Integer a:listA){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (a==3&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 listA.remove(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码在删除value=3的元素时，报java.util.ConcurrentModificationException异常，如下图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Exception in thread &quot;main&quot;&lt;span&gt; java.util.ConcurrentModificationException
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     at java.util.ArrayList$Itr.next(ArrayList.java:851&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     at com.zhang.Test.main(Test.java:19)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么是不是删除每一个元素都会报上面的异常呢？经过测试发现，删除value=5的元素（倒数第二个元素）时，就不会报上面异常，除此之外均会报如上异常。（此处不再一一测试，有兴趣可自己编码测试）&lt;/p&gt;
&lt;p&gt;我们通过上述测试发现了规律，既除了删除倒数第二个错误不会异常，删除其他元素均会异常。既然掌握了规律，那么就要从源码层面揭露该异常的原因。首先发现Java的for循环，就是将List对象遍历托管给Iterator，你如果要对list进行增删操作，都必须经过Iterator，否则Iterator遍历时会乱，所以直接对list进行删除时，Iterator会抛出ConcurrentModificationException异常。&lt;/p&gt;
&lt;p&gt;其实，每次foreach迭代的时候都有两部操作：&lt;/p&gt;
&lt;p&gt;第一步：iterator.hasNext()  //判断是否有下个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：item = iterator.next()  //下个元素是什么，并赋值给上面例子中的item变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            cursor &lt;/span&gt;= i + 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过debug调试，我们发现，checkForComodification时返回了异常，异常原因为 modCount != expectedModCount。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 进一步阅读源码，发现：&lt;/p&gt;
&lt;p&gt;　　1.modCount 时List从new开始，被修改的次数。当List调用Remove等方法时，modCount++&lt;/p&gt;
&lt;p&gt;　　2.expectedModCount是指Iterator现在期望这个list被修改的次数是多少次。是在Iterator初始化的时候将modCount 的值赋给了expectedModCount&lt;/p&gt;
&lt;p&gt;那么就解释了为什么会报上述异常：&lt;/p&gt;
&lt;p&gt;　　1.modCount 会随着调用List.remove方法而自动增减，而expectedModCount则不会变化，就导致modCount != expectedModCount。&lt;/p&gt;
&lt;p&gt;　　2.在删除倒数第二个元素后，cursor=size-1，此时size=size-1，导致hasNext方法认为遍历结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; listA=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        listA.add(&lt;/span&gt;1&lt;span&gt;);
        listA.add(&lt;/span&gt;2&lt;span&gt;);
        listA.add(&lt;/span&gt;3&lt;span&gt;);
        listA.add(&lt;/span&gt;4&lt;span&gt;);
        listA.add(&lt;/span&gt;5&lt;span&gt;);
        listA.add(&lt;/span&gt;6&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Integer a:listA){
            System.out.println(a);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a==5&lt;span&gt;) {
                listA.remove(&lt;/span&gt;5&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码加了打印后，输出1,2,3,4,5;进一步证明最后一个元素6并没有被遍历到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在找到原因后，则进一步进行解决&lt;/p&gt;
&lt;p&gt;经过查阅源码可以发现，iterator也有一个remove方法如下，其中有一个重要的操作为expectedModCount = modCount;这样就保证了两者的相等。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            checkForComodification();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ArrayList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
                cursor &lt;/span&gt;=&lt;span&gt; lastRet;
                lastRet &lt;/span&gt;= -1&lt;span&gt;;
                expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; listA=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        listA.add(&lt;/span&gt;1&lt;span&gt;);
        listA.add(&lt;/span&gt;2&lt;span&gt;);
        listA.add(&lt;/span&gt;3&lt;span&gt;);
        listA.add(&lt;/span&gt;4&lt;span&gt;);
        listA.add(&lt;/span&gt;5&lt;span&gt;);
        listA.add(&lt;/span&gt;6&lt;span&gt;);
        Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it_b=&lt;span&gt;listA.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it_b.hasNext()){
            Integer a&lt;/span&gt;=&lt;span&gt;it_b.next();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a==4&lt;span&gt;) {
                it_b.remove();
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Integer b:listA){
            System.out.println(b);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;java.util.ConcurrentModificationException异常完美解决。&lt;/p&gt;


</description>
<pubDate>Mon, 17 Sep 2018 07:38:00 +0000</pubDate>
<dc:creator>小张同学-Tonz</dc:creator>
<og:description>在java语言中，ArrayList是一个很常用的类，在编程中经常要对ArrayList进行删除操作，在使用remove方法对ArrayList进行删除操作时，报java.util.Concurren</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tonz/p/9662236.html</dc:identifier>
</item>
<item>
<title>vue+axios 前端实现登录拦截（路由拦截、http拦截） - 马清元</title>
<link>http://www.cnblogs.com/maqingyuan/p/9662417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maqingyuan/p/9662417.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;vue+axios 前端实现登录拦截（路由拦截、http拦截）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、路由拦截&lt;/h3&gt;
&lt;h3 id=&quot;登录拦截逻辑&quot;&gt;登录拦截逻辑&lt;/h3&gt;
&lt;h4 id=&quot;第一步路由拦截&quot;&gt;第一步：路由拦截&lt;/h4&gt;
&lt;p&gt;首先在定义路由的时候就需要多添加一个自定义字段&lt;code&gt;requireAuth&lt;/code&gt;，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， &lt;br/&gt;否则就进入登录页面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const routes = [
    {
        path: '/',
        name: '/',
        component: Index
    },
    {
        path: '/repository',
        name: 'repository',
        meta: {
            requireAuth: true,  // 添加该字段，表示进入这个路由是需要登录的
        },
        component: Repository
    },
    {
        path: '/login',
        name: 'login',
        component: Login
    }
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义完路由后，我们主要是利用&lt;code&gt;vue-router&lt;/code&gt;提供的钩子函数&lt;code&gt;beforeEach()&lt;/code&gt;对路由进行判断。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;router.beforeEach((to, from, next) =&amp;gt; {
    if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限
        if (store.state.token) {  // 通过vuex state获取当前的token是否存在
            next();
        }
        else {
            next({
                path: '/login',
                query: {redirect: to.fullPath}  // 将跳转的路由path作为参数，登录成功后跳转到该路由
            })
        }
    }
    else {
        next();
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个钩子方法接收三个参数： &lt;br/&gt;* to: Route: 即将要进入的目标 路由对象 &lt;br/&gt;* from: Route: 当前导航正要离开的路由 &lt;br/&gt;* next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 &lt;br/&gt;* next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 &lt;br/&gt;* next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 &lt;br/&gt;* next(‘/’) 或者 next({ path: ‘/’ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确保要调用 next 方法，否则钩子就不会被 resolved。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;4.6875&quot;&gt;
&lt;p&gt;完整的方法见&lt;code&gt;/src/router.&lt;a class=&quot;replace_word&quot; title=&quot;JavaScript知识库&quot; href=&quot;http://lib.csdn.net/base/javascript&quot; target=&quot;_blank&quot;&gt;js&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，&lt;code&gt;to.meta&lt;/code&gt;中是我们自定义的数据，其中就包括我们刚刚定义的&lt;code&gt;requireAuth&lt;/code&gt;字段。通过这个字段来判断该路由是否需要登录权限。需要的话，同时当前应用不存在token，则跳转到登录页面，进行登录。登录成功后跳转到目标路由。&lt;/p&gt;

&lt;p&gt;登录拦截到这里就结束了吗？并没有。这种方式只是简单的前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。 &lt;br/&gt;这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。&lt;/p&gt;

&lt;h4 id=&quot;第二步拦截器&quot;&gt;第二步：拦截器&lt;/h4&gt;

&lt;p&gt;要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置&lt;code&gt;http response inteceptor&lt;/code&gt;，当后端接口返回&lt;code&gt;401 Unauthorized（未授权）&lt;/code&gt;，让用户重新登录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// http request 拦截器
axios.interceptors.request.use(
    config =&amp;gt; {
        if (store.state.token) {  // 判断是否存在token，如果存在的话，则每个http header都加上token
            config.headers.Authorization = `token ${store.state.token}`;
        }
        return config;
    },
    err =&amp;gt; {
        return Promise.reject(err);
    });
 
// http response 拦截器
axios.interceptors.response.use(
    response =&amp;gt; {
        return response;
    },
    error =&amp;gt; {
        if (error.response) {
            switch (error.response.status) {
                case 401:
                    // 返回 401 清除token信息并跳转到登录页面
                    store.commit(types.LOGOUT);
                    router.replace({
                        path: 'login',
                        query: {redirect: router.currentRoute.fullPath}
                    })
            }
        }
        return Promise.reject(error.response.data)   // 返回接口返回的错误信息
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们要明白设置拦截器的目的是什么,当我们需要统一处理http请求和响应时我们通过设置拦截器处理方便很多.&lt;/p&gt;
&lt;p&gt;这个项目我引入了element ui框架,所以我是结合element中loading和message组件来处理的.我们可以单独建立一个http的js文件处理axios,再到main.js中引入.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**
 * http配置
 */
// 引入axios以及element ui中的loading和message组件
import axios from 'axios'
import { Loading, Message } from 'element-ui'
// 超时时间
axios.defaults.timeout = 5000
// http请求拦截器
var loadinginstace
axios.interceptors.request.use(config =&amp;gt; {
 // element ui Loading方法
 loadinginstace = Loading.service({ fullscreen: true })
 return config
}, error =&amp;gt; {
 loadinginstace.close()
 Message.error({
 message: '加载超时'
 })
 return Promise.reject(error)
})
// http响应拦截器
axios.interceptors.response.use(data =&amp;gt; {// 响应成功关闭loading
 loadinginstace.close()
 return data
}, error =&amp;gt; {
 loadinginstace.close()
 Message.error({
 message: '加载失败'
 })
 return Promise.reject(error)
})
 
export default axios&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就统一处理了http请求和响应的拦截.当然我们可以根据具体的业务要求更改拦截中的处理.&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 07:27:00 +0000</pubDate>
<dc:creator>马清元</dc:creator>
<og:description>vue+axios 前端实现登录拦截（路由拦截、http拦截） 一、路由拦截 登录拦截逻辑 第一步：路由拦截 首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maqingyuan/p/9662417.html</dc:identifier>
</item>
<item>
<title>python、Java、大数据和Android的薪资如何？ - TwoIce</title>
<link>http://www.cnblogs.com/twoice/p/9662292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoice/p/9662292.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　莫名其妙，从去年年底开始，Python这个东西在中国，突然一下子就火起来了，直至现在，他的热度更是超越了java，成为软件工程师最为关注的话题。Python之所以能火起来，很大一方面是因为大数据、人工智能和机器学习越来越受人关注的原因，那么，伴随着Python的火热，他的薪资是否也相应的高了起来了呢？于是，针对这个话题，在今年暑假，我做了一个关于Python、java和大数据和安卓的工作岗位的调查。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java火了几十年，工作也是所有编程语言中最容易找的，这里面有很大一部分原因是由于安卓还得由Java开发（即使现在出了Kotlin），那么Python和大数据的工作状态又是怎么样的呢？于是在这里，我从51job中爬取了这四个职业的相关情况。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、项目介绍&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span&gt;主要目标&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、分析python、Java、大数据和Android岗位的薪资如何？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、分析python、Java、大数据和Android岗位在全国的分布情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、python、Java、大数据和Android的前景到底如何？&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;环境&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;win7、python2、pychram&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、数据采集：scrapy、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、数据存储：csv文件、json文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、数据清洗：pandas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、可视化：matplotlib、百度地图API&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、爬取&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在招聘网上分别搜索这四个职业，查看了一下&lt;/span&gt;url&lt;span&gt;、页码和需要爬取的数据，求出&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143359334-1372524782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;scrapy&lt;span&gt;框架进行爬取，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;items:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job51Item(scrapy.Item):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职位名&lt;/span&gt;
    jobname =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 公司名&lt;/span&gt;
    company =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作地点&lt;/span&gt;
    work_place =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 薪资&lt;/span&gt;
    salary =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职位链接&lt;/span&gt;
    joblink = scrapy.Field()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spiders:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; ..items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Job51Item


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; JobSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    allowed_domains &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;51job.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    offset &lt;/span&gt;= 1

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ------------&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制链&lt;/span&gt;
    lang = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职位&lt;/span&gt;
    page = 260    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页码&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ------------&lt;/span&gt;
&lt;span&gt;
    start_urls &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/000000,000000,0000,00,9,99,%s,2,%d.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(lang,offset)]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):

        ajob &lt;/span&gt;= response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;resultList&quot;]/div[@class=&quot;el&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; job &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ajob:

            item &lt;/span&gt;=&lt;span&gt; Job51Item()

            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jobname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = job.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./p/span/a/@title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;company&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = job.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./span[1]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;work_place&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = job.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./span[2]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = job.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./span[3]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;joblink&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = job.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./p/span/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.offset &amp;lt;=&lt;span&gt; self.page:
            self.offset &lt;/span&gt;+= 1
            &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://search.51job.com/list/000000,000000,0000,00,9,99,%s,2,%d.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(self.lang,self.offset),callback=self.parse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改控制链中的&lt;/span&gt;lang&lt;span&gt;和&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;变量，分别爬取&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个职位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行&lt;/span&gt;scrapy&lt;span&gt;：&lt;/span&gt;&lt;span&gt;scrapy crawl job -o android1.csv&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据保存在一个&lt;/span&gt;csv&lt;span&gt;文件中，会得到&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;csv&lt;/span&gt;&lt;span&gt;文件，对应&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;种职位，其中&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;和安卓：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143450681-1848100886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来对文件去重合并：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

java_job &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job_java.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print java_job.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (100000, 5)&lt;/span&gt;
&lt;span&gt;
python_job &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job_python.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print python_job.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (41421, 5)&lt;/span&gt;
&lt;span&gt;
bigdata_job &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job_bigdata.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print bigdata_job.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (61191, 5)&lt;/span&gt;
&lt;span&gt;
android1_job &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job_android1.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print android1_job.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (31734, 5)&lt;/span&gt;
&lt;span&gt;
android2_job &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job_android2.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print android2_job.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (12961, 5)&lt;/span&gt;
&lt;span&gt;
df &lt;/span&gt;=&lt;span&gt; pd.concat([java_job,python_job,bigdata_job,android1_job,android2_job])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; df = python_job.append(java_job).append(bigdata_job)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print df.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (202612, 10)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 添加Android12之后：(247308, 5)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; df.to_csv('data/job.csv',index=False)&lt;/span&gt;
df.drop_duplicates(inplace=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; df.shape
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; (168544, 5)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (192781, 5)&lt;/span&gt;
df = df.reindex(columns=[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jobname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;work_place&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;company&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;joblink&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
df.to_csv(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143134129-1347169436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分文件结果截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143220016-545604218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着跟进链接，爬取职位详细信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143548111-18655823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;items:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseJobItem(scrapy.Item):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职位链接&lt;/span&gt;
    job_link =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职位信息&lt;/span&gt;
    job_info =&lt;span&gt; scrapy.Field()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 职能类型&lt;/span&gt;
    job_type = scrapy.Field()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;spiders&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; ..items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BaseJobItem
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_link():

    df &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../data/job.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;joblink&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; JobSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;basejob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    allowed_domains &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;51job.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    start_urls &lt;/span&gt;=&lt;span&gt; get_link()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):

        item &lt;/span&gt;=&lt;span&gt; BaseJobItem()

        job_info &lt;/span&gt;= response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;bmsg job_msg inbox&quot;]/p/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()
        job_type &lt;/span&gt;= response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;bmsg job_msg inbox&quot;]/div[@class=&quot;mt10&quot;]/p[1]/span[@class=&quot;el&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()

        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_link&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; response.url
        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; job_info
        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; job_type

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行：&lt;span&gt;scrapy crawl basejob -o basejob.csv&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;数据量有点大，话费了三个小时爬完。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143815141-1630469509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;文件有184M&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917143850783-1876916680.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来将两个文件(job.csv&lt;span&gt;和&lt;/span&gt;&lt;span&gt;basejob.csv)&lt;/span&gt;合并：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

df1 &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/basejob.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,header=0,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,names=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_info,job_type,joblink&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

df2 &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/job.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print df1.head()&lt;/span&gt;
df = pd.merge(df1,df2,on=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;joblink&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; df.sample(5&lt;span&gt;)

df &lt;/span&gt;= df.reindex(columns=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jobname,work_place,salary,company,joblink,job_type,job_info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
df.to_csv(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/zhaoping.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=False,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ,index_label=u'jobname,work_place,salary,company,joblink,job_type,job_info'.split(',')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;得到最终文件&lt;/span&gt;zhaoping.csv&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917144009678-2095583274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 三、分析&lt;/h2&gt;
&lt;p&gt;这四种职业的薪资如何呢？针对这个问题，我将这些数据进行清洗，然后分析再使之可视化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为只需要分析薪资，所以知道职位和薪资的字段就行了，这里使用&lt;/span&gt;job.csv&lt;span&gt;文件进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先读取数据并清洗：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

df &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/job.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

df &lt;/span&gt;= df[~df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].isna()]

df[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].apply(get_salary)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来将薪资格式化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_salary(salary):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    将薪资格式化
    :param salary:薪资，如：1-1.5万/月
    :return: 10K
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    time &lt;/span&gt;= salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; salary.&lt;span&gt;__contains__&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        money &lt;/span&gt;= salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0][-1&lt;span&gt;]
        salary_num &lt;/span&gt;= salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;= re.search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]).group()
        money &lt;/span&gt;= salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0].strip(salary_num)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;=&lt;span&gt; float(salary_num)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; salary,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,money,salary_num
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; time == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;= salary_num/12
    &lt;span&gt;elif&lt;/span&gt; time == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;天&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;*= 30&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; time == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小时&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;*= 30*12
    &lt;span&gt;if&lt;/span&gt; money == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;万&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;*= 10
    &lt;span&gt;elif&lt;/span&gt; money == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        salary_num &lt;/span&gt;/= 1000

    &lt;span&gt;return&lt;/span&gt; salary_num
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取不同语言的薪资待遇的对比并画图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; diff_lang():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    获取不同语言的薪资待遇的对比
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    lang &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    avg_salary &lt;/span&gt;=&lt;span&gt; map(get_avg_salary,lang)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 针对Android和安卓做特殊处理&lt;/span&gt;
    lang = lang[:-1&lt;span&gt;]
    avg_salary &lt;/span&gt;= avg_salary[:-2]+[sum(avg_salary[-2:])/len(avg_salary[-2&lt;span&gt;:])]

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; lang
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; avg_salary

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i,j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(lang,avg_salary):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s的平均薪资为:%.3fK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (i.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),j)

    p &lt;/span&gt;=&lt;span&gt; plt.bar(lang,avg_salary)

    autolabel(p)
    plt.xlabel(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;编程语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    plt.ylabel(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均薪资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    plt.title(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python、java、大数据和安卓职业薪资待遇对比&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还有获取某个编程语言的平均薪资的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; get_avg_salary(lang=&lt;span&gt;''&lt;/span&gt;,city=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    获取某个编程语言的平均薪资
    :param lang: 编程语言名
    :return: 平均薪资
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    jobdf &lt;/span&gt;= df[df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jobname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].str.contains(lang)]

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; city != &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
        jobdf &lt;/span&gt;= jobdf[jobdf[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;work_place&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].str.contains(city)]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; jobdf.shape[0] &amp;lt; 10&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    sum_salary &lt;/span&gt;= jobdf[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum_salary.astype(float).mean()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还有画图时显示柱状图上的数值的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; autolabel(rects):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    定义函数来显示柱状上的数值
    :param rects:matplotlib.container.BarContainer
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; rect &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rects:
        height &lt;/span&gt;=&lt;span&gt; rect.get_height()
        plt.text(rect.get_x(), &lt;/span&gt;1.01*height, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%.1f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % float(height))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了显示中文字还要声明一下字体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kaiti&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行diff_lang()函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917144705675-36841914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;从图中可以看出，大数据的薪资是最高的，达到了&lt;/span&gt;1W&lt;span&gt;以上，而&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;位居二三，却远远没有大数据的薪资高，而安卓在这几个职位中薪资是最低的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后对同一语言不通地区薪资的待遇进行分析对比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; diff_place():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    获取同一语言不通地区薪资的待遇
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    citys &lt;/span&gt;= list(df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;work_place&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].str.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).map(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x:x[0]).drop_duplicates())

    citys.remove(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;朝阳&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 朝阳有点特殊，有些城市直接就是朝阳，不过数量太少，直接忽略了，所以这里做朝阳的特殊处理&lt;/span&gt;
&lt;span&gt;
    lang &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls如：['python','北京']&lt;/span&gt;
    ls = [[a,b] &lt;span&gt;for&lt;/span&gt; a &lt;span&gt;in&lt;/span&gt; lang &lt;span&gt;for&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt;&lt;span&gt; citys]

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; x是某种语言在某个城市的平均薪资&lt;/span&gt;
    x = [get_avg_salary(*l) &lt;span&gt;for&lt;/span&gt; l &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ls]


    info &lt;/span&gt;=&lt;span&gt; {}

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i,j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(ls,x):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; if j != None:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print i[0],i[1],j&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; info.has_key(i[0]):
            info[i[0]] &lt;/span&gt;=&lt;span&gt; {}
            info[i[0]][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
            info[i[0]][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; j !=&lt;span&gt; None:
            info[i[0]][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] += [i[1&lt;span&gt;]]
            info[i[0]][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] +=&lt;span&gt; [j]

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; info的可能取值如：info = {&quot;python&quot;: {&quot;city&quot;: [&quot;上海&quot;, &quot;成都&quot;,...],&quot;avg_salary&quot;: [11.974358974358974, 7.016129032258065, ...]},...}&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特殊处理:对安卓和Android的数据进行合并&lt;/span&gt;
    info =&lt;span&gt; get_android(info)

    with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/inf.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as inf:
        json.dump(info,inf)

    plt.figure(&lt;/span&gt;1,(12,6&lt;span&gt;))
    plt.title(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python、java、大数据和安卓职业各城市薪资待遇对比(单位：K)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; l &lt;span&gt;in&lt;/span&gt; lang[:-1&lt;span&gt;]:
        plt.subplot(len(lang[:&lt;/span&gt;-1]),1,lang.index(l) + 1&lt;span&gt;)

        so &lt;/span&gt;= zip(info[l][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],info[l][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        so.sort(key&lt;/span&gt;=&lt;span&gt;lambda&lt;/span&gt; x:x[1],reverse=&lt;span&gt;True)
        p &lt;/span&gt;= plt.bar(range(len(info[l][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])),map(&lt;span&gt;lambda&lt;/span&gt; x:x[1],so),label=&lt;span&gt;l)
        plt.xticks(range(len(info[l][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])),map(&lt;span&gt;lambda&lt;/span&gt; x:x[0],so),rotation=45&lt;span&gt;)
        autolabel(p)
        plt.tight_layout()
        plt.legend()

    plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对安卓和Android的数据进行合并：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_android(info):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    对安卓和Android的数据进行合并
    :param info: = {&quot;python&quot;: {&quot;city&quot;: [&quot;上海&quot;, &quot;成都&quot;,...],&quot;avg_salary&quot;: [11.974358974358974, 7.016129032258065, ...]},...}

    :return: info
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    citys &lt;/span&gt;= set(info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]+info[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; city &lt;span&gt;in&lt;/span&gt;&lt;span&gt; citys:
        i,j &lt;/span&gt;=&lt;span&gt; 0, 0
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; city &lt;span&gt;in&lt;/span&gt; info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            i &lt;/span&gt;= info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].index(city)]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; city &lt;span&gt;in&lt;/span&gt; info[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            j &lt;/span&gt;= info[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][info[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].index(city)]
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            info[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(city)
            info[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(i)
        info[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][info[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安卓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].index(city)] = (i+j)/2
    &lt;span&gt;del&lt;/span&gt; info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; info
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后得到同一语言不同地区薪资的待遇结果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145102715-1787536817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以以热力图显示数据，这里使用百度的&lt;/span&gt;api&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; urllib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlopen, quote
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

reload(sys)
sys.setdefaultencoding(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getlnglat(address):
    url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://api.map.baidu.com/geocoder/v2/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    output &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ak &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FOtHtZ92dCKMjpx0XA05g8VEZn95QWOK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    add &lt;/span&gt;= quote(address.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;由于本文城市变量为中文，为防止乱码，先用quote进行编码&lt;/span&gt;
    uri = url + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;address=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + add  + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;output=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + output + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;ak=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; ak
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; uri
    req &lt;/span&gt;=&lt;span&gt; urlopen(uri)
    res &lt;/span&gt;= req.read() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将其他编码的字符串解码成unicode&lt;/span&gt;
    temp = json.loads(res) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对json数据进行解析&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

file &lt;/span&gt;= open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/city.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立json数据文件&lt;/span&gt;
with open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/test.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:

    js &lt;/span&gt;=&lt;span&gt; json.load(f)

    data &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k,v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; js.iteritems():
        c &lt;/span&gt;=&lt;span&gt; {}
        c[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; k
        c[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][i] == u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;异地招聘&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            lnglat &lt;/span&gt;= getlnglat(v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][i])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用构造的函数来获取经度&lt;/span&gt;
            test =&lt;span&gt; {}
            test[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = lnglat[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            test[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = lnglat[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            test[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = v[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avg_salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;][i]

            c[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(test)
        data.append(c)

    json.dump(data,file,ensure_ascii&lt;/span&gt;=False)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;那么&lt;/span&gt;Python&lt;span&gt;在不同&lt;/span&gt;地区薪资的待遇热力图如下，其中，越往中间颜色越深薪资越高：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145226053-1310200293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从上如看出Python &lt;span&gt;的主要工作地区集中在长江三角洲、珠江三角洲一带，而北京的薪资是最高的还有几个内地城市占比也不低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么看一下&lt;/span&gt;Java&lt;span&gt;在不同&lt;/span&gt;地区薪资的待遇热力图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145251570-1066852414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图可以看出，Java&lt;span&gt;工作地点同样是集中于那三带地区，不过相比于&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;，他的主要工作地点更多，且最高薪资大多集中在珠江三角洲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再看一下大数据在不同地区薪资的待遇热力图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145316388-470498930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目测大数据和Java&lt;span&gt;分布差别不大，不过从图中红色区域分布可以看出，大数据的薪资更高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后看一下安卓在不同地区薪资的待遇热力图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145337019-1427101195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安卓的工作分布低于其他的几种（比Python&lt;span&gt;略高点&lt;/span&gt;），而且薪资也也不如其他的几门语言。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从上述四个热力图分析不难看出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;大数据无论是工作地点还是薪资均高于其他三种职业；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;Python&lt;span&gt;火则火矣，薪资也不低，但工作地点还是太少；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;Java&lt;span&gt;仍旧是宝刀未老，其工作地点和薪资也仅次于大数据行业；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;&lt;span&gt;安卓终究过时了，薪资比不上其他三个职业，也就工作地点要比&lt;/span&gt;Python&lt;span&gt;多点；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;由此观之，大数据的发展空间是最大的，前途也是最好的，&lt;/span&gt;Java&lt;span&gt;仍然是不二的选择，&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;已过时，&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;还待发展。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;再看一下&lt;/span&gt;4&lt;span&gt;种职位的岗位分析图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先看&lt;/span&gt;Python岗位&lt;span&gt;的代码：&lt;/span&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

plt.rcParams[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kaiti&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

df &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/job_python.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

s &lt;/span&gt;= df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jobname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].value_counts()

job &lt;/span&gt;= s[s&amp;gt;150&lt;span&gt;]

plt.pie(x &lt;/span&gt;=job.values,labels=job.index,autopct=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%2.1f%%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其他的同理，最后得到饼图：&lt;/p&gt;
&lt;p&gt;Python&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145632378-511356480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145814643-1000939161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917145921653-334885059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安卓：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917150011044-1716979943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;最后来看一下&lt;/span&gt;Python&lt;span&gt;语言的职能类型词云，代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd


df1 &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/job_python.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

df2 &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/zhaoping.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

df &lt;/span&gt;= pd.merge(df1,df2,on=&lt;span&gt;list(df1.columns))

df &lt;/span&gt;= df[~df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].isna()]

dfpy &lt;/span&gt;= df[df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].str.contains(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]

s &lt;/span&gt;= dfpy[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].str.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).sum()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print pd.Series(s).value_counts()&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt; s

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制词云图：&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; wordcloud &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WordCloud
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pylab as plt


wl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(s)

generate &lt;/span&gt;=&lt;span&gt; WordCloud(
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'C:/Users/Windows/fonts/msyh.ttf'&lt;/span&gt;
    font_path = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/Windows/fonts/msyh.ttf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    background_color&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    max_words&lt;/span&gt;=30&lt;span&gt;,
    prefer_horizontal &lt;/span&gt;= 0.8&lt;span&gt;,
    random_state&lt;/span&gt;=88&lt;span&gt;
).generate(wl)

plt.figure(figsize&lt;/span&gt;=(8,5&lt;span&gt;))
plt.imshow(generate)
plt.axis(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; plt.savefig(u'../day5-2/黑卡词云图.png')&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他职业的也大致如此.&lt;/p&gt;
&lt;p&gt;Python：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917150628863-1120651575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917150718714-80212060.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917150807103-1495677361.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安卓：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201809/1139339-20180917150508047-850005542.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 17 Sep 2018 07:11:00 +0000</pubDate>
<dc:creator>TwoIce</dc:creator>
<og:description>莫名其妙，从去年年底开始，Python这个东西在中国，突然一下子就火起来了，直至现在，他的热度更是超越了java，成为软件工程师最为关注的话题。Python之所以能火起来，很大一方面是因为大数据、人工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/twoice/p/9662292.html</dc:identifier>
</item>
<item>
<title>Todolist组件 - 怪味曹小豆</title>
<link>http://www.cnblogs.com/caoxueying2018/p/9662210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caoxueying2018/p/9662210.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、什么是组件？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;组件是可复用的 Vue 实例。是页面上的某一部分。&lt;/p&gt;
&lt;p&gt;大型项目可以拆分成很多小组件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、如何定义(创建)组件？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局组件：通过Vue.component方法创建的组件是全局组件。其中'todo-list'是这个组件的名字。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488621/201809/1488621-20180917094814074-1373137028.png&quot; alt=&quot;&quot; width=&quot;372&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;局部组件：其他vue实例若要使用这个组件，必须通过components对这个局部组件进行一个注册，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488621/201809/1488621-20180917095752843-802382744.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;426&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子：实现把用户在input框中输入的内容输出到li里&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue入门&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;inputValue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;handleSubmit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;todo-item &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item,index) in list&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; :content&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 给todo-item传参，通过属性的形式传参 :content = &quot;item&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;todo-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局组件&lt;/span&gt;
&lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;todo-item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
            props:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;], 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在该组件中定义一个props属性（值可以是一个数组）。意思是该组件接收从外部传递进来的一个名字是content的属性。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该组件定义了接收，一旦外部进行传递后，该组件即可直接使用传递过来的参数了。&lt;/span&gt;
&lt;span&gt;            template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;li&amp;gt;{{content}}&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件不能直接使用content，如果想直接使用，该组件必须接收这个属性，用props接收&lt;/span&gt;
&lt;span&gt;        })
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,          
            data:{
                inputValue:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                list:[]
            },
            methods:{
                handleSubmit:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputValue);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                }  
            }
        })

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488621/201809/1488621-20180917105848430-2012565567.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、组件与实例的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每一个vue组件都是一个vue实例。组件有props、data、template等属性，methods等方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;vue实例也是vue组件。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个vue项目，由千千万万个vue实例所组成。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488621/201809/1488621-20180917111430945-698681717.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;203&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、组件与组件间如何通信？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;父组件向子组件传值，是通过属性的形式，进行值的传递的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子组件显示与否，取决于父组件list这个数据。所以，若想实现子组件的删除，必须在父组件上把子组件对应的数据给删除掉；&lt;/span&gt;当点击子组件时，需要让子组件和父组件通信。子组件要告诉父组件：把我的条目数据删除掉。&lt;/li&gt;
&lt;li&gt;在vue里，要想实现父组件和子组件的通信，需通过一个发布订阅模式来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;例：删除TodoItem功能，代码如下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue入门&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;inputValue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;handleSubmit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;todo-item &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item,index) in list&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; 
            :content&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt; :index&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; @delete&lt;/span&gt;&lt;span&gt;=&quot;handleDelete&quot;&lt;/span&gt;
            &lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 给todo-item传参，通过属性的形式传参 :content = &quot;item&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 父组件可以监听到子组件向外触发的这个delete事件，并执行自己的handleDelete方法。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;todo-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局组件&lt;/span&gt;
&lt;span&gt;        Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;todo-item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
            props:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;], 
            template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;li @click=&quot;handleClick&quot;&amp;gt;{{content}}&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            methods:{
                handleClick:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当点击子组件时，需通知父组件，调动this.$emit方法，触发一个delete自定义事件--delete，传递一个值--this.index.&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子组件向外部进行一个发布&lt;/span&gt;
&lt;span&gt;                }
            }
        })
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,          
            data:{
                inputValue:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                list:[]
            },
            methods:{
                handleSubmit:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputValue);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                },
                handleDelete:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list.splice(index, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                }  
            }
        })

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt; 通过&lt;strong&gt;父组件向子组件传值&lt;/strong&gt;的形式，就做好了删除TodoItem这个功能。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 17 Sep 2018 07:01:00 +0000</pubDate>
<dc:creator>怪味曹小豆</dc:creator>
<og:description>一、什么是组件？ 组件是可复用的 Vue 实例。是页面上的某一部分。 大型项目可以拆分成很多小组件。 二、如何定义(创建)组件？ 全局组件：通过Vue.component方法创建的组件是全局组件。其中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caoxueying2018/p/9662210.html</dc:identifier>
</item>
<item>
<title>IOTutility 一个轻量级的 IOT 基础操作库 - 楚韩技术</title>
<link>http://www.cnblogs.com/chiang-tech/p/9662170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiang-tech/p/9662170.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;Base utility for IOT devices, networking, controls etc...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IOTutility 的目的是提供一个易用的，轻量级的，能够快速使用的 IOT 编程功能库。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么要写一个-iot-编程库&quot;&gt;1. 为什么要写一个 IOT 编程库？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;对于 IOT 设备而言，本身是功能比较单一，代码量也是越少越好，那么使用原生的库编程看起来应该是最好的选择。但是我在很多项目开发的初期却发现
我总是在做一些重复的编码，比如建立基础的 TCP 和 UDP 通信，设计简单的通信协议来让 IOT 设备和管理服务器之间传递数据等等。其实这些工作可以
相对完整的放在一个模块中，让我们快速的开始实施自己的想法。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iotutility-具有什么功能&quot;&gt;2. IOTutility 具有什么功能？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;目前对于 IOT 设备最主要的还是网络通信，所以 IOTutility 的主要功能是搭建网络环境和实现基本的通信协议例如 MQTT， IEC61850 等基于 TCP 的
应用层协议&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iotutility-有什么特点&quot;&gt;3. IOTutility 有什么特点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;IOTutility 是个人业余开发而来，目前仅限于功能正常，没有经过大规模测试，那么唯一的特点就是简单。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;iotutility-实现了哪些功能&quot;&gt;IOTutility 实现了哪些功能&lt;/h2&gt;
&lt;p&gt;目前只实现了基础的 UDP 和 TCP 通信，多线程和基础信号量，以及部分 MQTT 协议。&lt;/p&gt;
&lt;h2 id=&quot;mqtt-protocol-implement-mqtt-实现&quot;&gt;&lt;em&gt;MQTT protocol implement&lt;/em&gt; MQTT 实现&lt;/h2&gt;
&lt;p&gt;app 目录中包含了一个 MQTT client 的实现，要实现一次 MQTT 通信，只需要以下几个步骤：&lt;/p&gt;
&lt;h3 id=&quot;创建一个-mqtt_session&quot;&gt;1. 创建一个 MQTT_Session&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;MQTT_Session* Session = MQTT_SessionCreate(&quot;198.41.30.241&quot;, 1883);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是创建一个到 iot.eclipse.org 的 MQTT 通信&lt;/p&gt;
&lt;h3 id=&quot;连接到服务器&quot;&gt;2. 连接到服务器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Session-&amp;gt;Connect(Session);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接调用 Connect 接口，连接到创建的服务器地址&lt;/p&gt;
&lt;h3 id=&quot;订阅感兴趣的主题&quot;&gt;3. 订阅感兴趣的主题&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Session-&amp;gt;Subscribe(Session, &quot;wuhan/#&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样会订阅所有传递到 iot.eclipse.org 服务器以 &lt;em&gt;wuhan/&lt;/em&gt; 开头的所有消息，如果要处理这些消息，需要调用 Fetch 接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Session-&amp;gt;Fetch(Session, topic_and_message);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可以通过-publish-接口直接上传消息给服务器&quot;&gt;4. 可以通过 Publish 接口直接上传消息给服务器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Session-&amp;gt;Publish(Session, &quot;wuhan/test&quot;, &quot;hello&quot;, 5);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;下载代码&quot;&gt;1. 下载代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/ruiers/IOTutility.git&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译代码库&quot;&gt;2. 编译代码库&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd IOTutility
make&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译示例程序并执行&quot;&gt;3. 编译示例程序并执行&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;make mqtt_client.bin
./mqtt_client.bin &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输出示例&quot;&gt;4. 输出示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;android@ubuntumysqlserver:~/share/github/IOTutility$ ./mqtt_client.bin 
a
topic     10:wuhan/test
message    5:hello
a
topic     10:wuhan/test
message    5:hello
z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按下 ‘a’ 发送一个消息到服务器，按下 ‘z’ 退出程序。 消息发送到 iot.eclipse.org， 我们的接收线程接收后会打印出消息的&lt;br/&gt;主题和消息信息。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 06:56:00 +0000</pubDate>
<dc:creator>楚韩技术</dc:creator>
<og:description>IOTutility 一个轻量级的 IOT 基础操作库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chiang-tech/p/9662170.html</dc:identifier>
</item>
<item>
<title>Spring源码解析 – AnnotationConfigApplicationContext容器创建过程 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9662119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9662119.html</guid>
<description>&lt;p&gt;Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationConfigApplicationContext的实现结构图中可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AnnotationConfigApplicationContext继承GenericApplicationContext这个通用应用上下文，GenericApplicationContext内部定义了一个DefaultListableBeanFactory实例，GenericApplicationContext实现了BeanDefinitionRegistry接口，所以可以通过AnnotationConfigApplicationContext实例注册bean defintion，然后调用refresh()方法来初始化上下文。&lt;/li&gt;
&lt;li&gt;AnnotationConfigApplicationContext继承AbstractApplicationContext，AbstractApplicationContext提供了ApplicationContext的抽象实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通过一个示例分析AnnotationConfigApplicationContext的初始化过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 AnnotationConfigApplicationContext applicationContext  = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(ExtensionConfig.&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 初始化bean读取器和扫描器;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.注册bean配置类&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;   register(annotatedClasses);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.刷新上下文&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;   refresh();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. this() 初始化bean读取器和扫描器&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnnotationConfigApplicationContext() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt; AnnotatedBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.scanner = &lt;span&gt;new&lt;/span&gt; ClassPathBeanDefinitionScanner(&lt;span&gt;this&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GenericApplicationContext部分代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericApplicationContext &lt;span&gt;extends&lt;/span&gt; AbstractApplicationContext &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistry {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory beanFactory;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个BeanFactory&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GenericApplicationContext() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.beanFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    …
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;2. register(annotatedClasses)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;注册bean配置类, AnnotationConfigApplicationContext容器通过AnnotatedBeanDefinitionReader的register方法实现注解bean的读取，具体源码如下：&lt;/p&gt;
&lt;p&gt; AnnotationConfigApplicationContext.java中register方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按指定bean配置类读取bean&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(Class&amp;lt;?&amp;gt;&lt;span&gt;... annotatedClasses) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; annotatedClass : annotatedClasses) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      registerBean(annotatedClass);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; registerBean(Class&amp;lt;?&amp;gt;&lt;span&gt; annotatedClass) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    doRegisterBean(annotatedClass, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心实现逻辑&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; doRegisterBean(Class&amp;lt;T&amp;gt; annotatedClass, @Nullable Supplier&amp;lt;T&amp;gt;&lt;span&gt; instanceSupplier, @Nullable String name,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       @Nullable Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Bean配置类信息转成容器中AnnotatedGenericBeanDefinition数据结构, AnnotatedGenericBeanDefinition继承自BeanDefinition作用是定义一个bean的数据结构，下面的getMetadata可以获取到该bean上的注解信息&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;    AnnotatedGenericBeanDefinition abd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnotatedGenericBeanDefinition(annotatedClass);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Conditional装配条件判断是否需要跳过注册&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.conditionEvaluator.shouldSkip(abd.getMetadata())) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@param instanceSupplier a callback for creating an instance of the bean
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;   abd.setInstanceSupplier(instanceSupplier);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析bean作用域(单例或者原型)，如果有@Scope注解，则解析@Scope，没有则默认为singleton &lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;    ScopeMetadata scopeMetadata = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scopeMetadataResolver.resolveScopeMetadata(abd);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用域写回BeanDefinition数据结构, abd中缺损的情况下为空，将默认值singleton重新赋值到abd&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;   abd.setScope(scopeMetadata.getScopeName());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成bean配置类beanName&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;    String beanName = (name != &lt;span&gt;null&lt;/span&gt; ? name : &lt;span&gt;this&lt;/span&gt;.beanNameGenerator.generateBeanName(abd, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通用注解解析到abd结构中，主要是处理Lazy, primary DependsOn, Role ,Description这五个注解&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;   AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@param qualifiers specific qualifier annotations to consider, if any, in addition to qualifiers at the bean class level
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @Qualifier特殊限定符处理，&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (qualifiers != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt; qualifier : qualifiers) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (Primary.&lt;span&gt;class&lt;/span&gt; ==&lt;span&gt; qualifier) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果配置@Primary注解，则设置当前Bean为自动装配autowire时首选bean&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             abd.setPrimary(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 　　&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Lazy.&lt;span&gt;class&lt;/span&gt; ==&lt;span&gt; qualifier) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前bean为延迟加载&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             abd.setLazyInit(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他注解，则添加到abd结构中&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             abd.addQualifier(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutowireCandidateQualifier(qualifier));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义bean注册，通常用在applicationContext创建后，手动向容器中一lambda表达式的方式注册bean, 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如：applicationContext.registerBean(UserService.class, () -&amp;gt; new UserService());&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinitionCustomizer customizer : definitionCustomizers) {
&lt;/span&gt;&lt;span&gt;53　　　　&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义bean添加到BeanDefinition&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;      customizer.customize(abd);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据beanName和bean定义信息封装一个beanhold,heanhold其实就是一个 beanname和BeanDefinition的映射&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;    BeanDefinitionHolder definitionHolder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder(abd, beanName);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理对象&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanDefinitionReaderUtils.registerBeanDefinition 内部通过DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition)按名称将bean定义信息注册到容器中，
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际上DefaultListableBeanFactory内部维护一个Map&amp;lt;String, BeanDefinition&amp;gt;类型变量beanDefinitionMap，用于保存注bean定义信息（beanname 和 beandefine映射）&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;register方法重点完成了bean配置类本身的解析和注册，处理过程可以分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据bean配置类，使用BeanDefinition解析Bean的定义信息，主要是一些注解信息&lt;/li&gt;
&lt;li&gt;Bean作用域的处理，默认缺少@Scope注解，解析成单例&lt;/li&gt;
&lt;li&gt;借助AnnotationConfigUtils工具类解析通用注解&lt;/li&gt;
&lt;li&gt;将bean定义信息已beanname，beandifine键值对的形式注册到ioc容器中&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;3. refresh()刷新上下文&lt;/h2&gt;
&lt;p&gt;   refresh方法在AbstractApplicationContext容器中实现，refresh()方法的作用加载或者刷新当前的配置信息，如果已经存在spring容器，则先销毁之前的容器，重新创建spring容器，载入bean定义，完成容器初始化工作，所以可以看出AnnotationConfigApplicationContext容器是通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器完成对Bean定义的载入。     &lt;/p&gt;
&lt;p&gt;AbstractApplicationContext.java中refresh方法的实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refresh() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException, IllegalStateException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.startupShutdownMonitor) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.刷新前的预处理&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      prepareRefresh();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取刷新后的内部Bean工厂&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       ConfigurableListableBeanFactory beanFactory =&lt;span&gt; obtainFreshBeanFactory();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.BeanFactory的预准备工作&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      prepareBeanFactory(beanFactory);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanFactory准备工作完成后，可以做一些后置处理工作，
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 　　　　  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.空方法，用于在容器的子类中扩展&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         postProcessBeanFactory(beanFactory);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 执行BeanFactoryPostProcessor的方法，BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         invokeBeanFactoryPostProcessors(beanFactory);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6. 注册BeanPostProcessor（Bean的后置处理器）,用于拦截bean创建过程&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         registerBeanPostProcessors(beanFactory);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7. 初始化MessageSource组件（做国际化功能；消息绑定，消息解析）&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         initMessageSource();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8. 初始化事件派发器&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;         initApplicationEventMulticaster();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9.空方法，可以用于子类实现在容器刷新时自定义逻辑&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         onRefresh();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10. 注册时间监听器，将所有项目里面的ApplicationListener注册到容器中来&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;         registerListeners();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11. 初始化所有剩下的单实例bean,单例bean在初始化容器时创建，原型bean在获取时（getbean）时创建&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;         finishBeanFactoryInitialization(beanFactory);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12. 完成BeanFactory的初始化创建工作，IOC容器就创建完成；&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;         finishRefresh();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;       &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isWarnEnabled()) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             logger.warn(&quot;Exception encountered during context initialization - &quot; +
&lt;span&gt;45&lt;/span&gt;                   &quot;cancelling refresh attempt: &quot; +&lt;span&gt; ex);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destroy already created singletons to avoid dangling resources.&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;         destroyBeans();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset 'active' flag.&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;         cancelRefresh(ex);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Propagate exception to caller.&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;          &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;       &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset common introspection caches in Spring's core, since we
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; might not ever need metadata for singleton beans anymore...&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;         resetCommonCaches();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体分析refresh中的函数逻辑：&lt;/p&gt;
&lt;h3&gt;1.   刷新预处理：&lt;/h3&gt;
&lt;p&gt;AbstractApplicationContext. prepareRefresh ()方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepareRefresh() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置容器启动时间&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.startupDate =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动标识&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.closed.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.active.set(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       logger.info(&quot;Refreshing &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空方法，用于子容器自定义个性化的属性设置方法&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   initPropertySources();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验属性的合法等&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   getEnvironment().validateRequiredProperties();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存容器中的一些早期的事件&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.earlyApplicationEvents = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 获取刷新后的内部Bean工厂，obtainFreshBeanFactory方法为内部bean工厂重新生成id，并返回bean工厂&lt;/h3&gt;
&lt;p&gt;  AbstractApplicationContext. obtainFreshBeanFactory()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ConfigurableListableBeanFactory obtainFreshBeanFactory() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为beanfactory生成唯一序列化id，beanfactory已经在GenericApplicationContext构造函数中初始化了，refreshBeanFactory的逻辑在AbstractApplicationContext的实现类GenericApplicationContext中&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; refreshBeanFactory();
&lt;/span&gt;&lt;span&gt; 4　　&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取beanfactory&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    ConfigurableListableBeanFactory beanFactory =&lt;span&gt; getBeanFactory();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; +&lt;span&gt; beanFactory);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanFactory;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GenericApplicationContext.refreshBeanFactory()实现代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refreshBeanFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalStateException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.refreshed.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &quot;GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个序列化id&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactory.setSerializationId(getId());
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用AbstractApplicationContext. refreshBeanFactory()在不同实现容器中有点区别，如果是以xml方式配置bean，会使用AbstractRefreshableApplicationContext容器中的实现，该容器中实现xml配置文件定位，并通过BeanDefinition载入和解析xml配置文件。&lt;/p&gt;
&lt;p&gt;而如果是注解的方式，则并没有解析项目包下的注解，而是通过在refresh()方法中执行ConfigurationClassPostProcessor后置处理器完成对bean的加载.&lt;/p&gt;
&lt;h3&gt;3.BeanFactory的预准备工作&lt;/h3&gt;
&lt;p&gt; prepareBeanFactory主要完成beanFactory的一些属性设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Tell the internal bean factory to use the context's class loader etc.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    beanFactory.setBeanClassLoader(getClassLoader());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置类加载器&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;    beanFactory.setBeanExpressionResolver(&lt;span&gt;new&lt;/span&gt; StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bean表达式解析器&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    beanFactory.addPropertyEditorRegistrar(&lt;span&gt;new&lt;/span&gt; ResourceEditorRegistrar(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, getEnvironment()));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure the bean factory with context callbacks.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;    beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt; ApplicationContextAwareProcessor(&lt;span&gt;this&lt;/span&gt;));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个BeanPostProcessor实现ApplicationContextAwareProcessor
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置忽略的自动装配接口，表示这些接口的实现类不允许通过接口自动注入&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    beanFactory.ignoreDependencyInterface(EnvironmentAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    beanFactory.ignoreDependencyInterface(MessageSourceAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    beanFactory.ignoreDependencyInterface(ApplicationContextAware.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanFactory interface not registered as resolvable type in a plain factory.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MessageSource registered (and found for autowiring) as a bean.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册可以自动装配的组件，就是可以在任何组件中允许自动注入的组件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    beanFactory.registerResolvableDependency(BeanFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, beanFactory);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    beanFactory.registerResolvableDependency(ResourceLoader.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    beanFactory.registerResolvableDependency(ApplicationEventPublisher.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;    beanFactory.registerResolvableDependency(ApplicationContext.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register early post-processor for detecting inner beans as ApplicationListeners.&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;    beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt; ApplicationListenerDetector(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加编译时的AspectJ&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadTimeWeaverAwareProcessor(beanFactory));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set a temporary ClassLoader for type matching.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;       beanFactory.setTempClassLoader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给beanfactory容器中注册组件ConfigurableEnvironment、systemProperties、systemEnvironment&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.invokeBeanFactoryPostProcessors 执行bean工厂后置处理器&lt;/h3&gt;
&lt;p&gt; AbstractApplicationContext. invokeBeanFactoryPostProcessors方法实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (beanFactory.getTempClassLoader() == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadTimeWeaverAwareProcessor(beanFactory));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       beanFactory.setTempClassLoader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;invokeBeanFactoryPostProcessors方法内部执行实现了BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor这两个接口的Processor，先获取所有BeanDefinitionRegistryPostProcessor的实现，按优先级执行（是否实现PriorityOrdered优先级接口，是否实现Ordered顺序接口）；再以相同的策略执行所有BeanFactoryPostProcessor的实现。&lt;/p&gt;
&lt;p&gt;PostProcessorRegistrationDelegate. invokeBeanFactoryPostProcessors实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeBeanFactoryPostProcessors(
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;       ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt;&lt;span&gt; beanFactoryPostProcessors) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invoke BeanDefinitionRegistryPostProcessors first, if any.&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;    Set&amp;lt;String&amp;gt; processedBeans = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (beanFactory &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistry) {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;       BeanDefinitionRegistry registry =&lt;span&gt; (BeanDefinitionRegistry) beanFactory;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;       List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;       List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (postProcessor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistryPostProcessor) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             BeanDefinitionRegistryPostProcessor registryProcessor =
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;                  (BeanDefinitionRegistryPostProcessor) postProcessor;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            registryProcessor.postProcessBeanDefinitionRegistry(registry);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            registryProcessors.add(registryProcessor);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;            regularPostProcessors.add(postProcessor);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not initialize FactoryBeans here: We need to leave all regular beans
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uninitialized to let the bean factory post-processors apply to them!
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Separate between BeanDefinitionRegistryPostProcessors that implement
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PriorityOrdered, Ordered, and the rest.&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;       List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;       String[] postProcessorNames =
&lt;span&gt; 32&lt;/span&gt;             beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, PriorityOrdered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            processedBeans.add(ppName);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;      sortPostProcessors(currentRegistryProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;      registryProcessors.addAll(currentRegistryProcessors);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;      currentRegistryProcessors.clear();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;       postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            processedBeans.add(ppName);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;      sortPostProcessors(currentRegistryProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;      registryProcessors.addAll(currentRegistryProcessors);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;      currentRegistryProcessors.clear();
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;       &lt;span&gt;boolean&lt;/span&gt; reiterate = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;       &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (reiterate) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;          reiterate = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;          postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;          &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;processedBeans.contains(ppName)) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;               processedBeans.add(ppName);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                reiterate = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;         sortPostProcessors(currentRegistryProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;         registryProcessors.addAll(currentRegistryProcessors);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;         currentRegistryProcessors.clear();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now, invoke the postProcessBeanFactory callback of all processors handled so far.&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invoke factory processors registered with the context instance.&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not initialize FactoryBeans here: We need to leave all regular beans
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uninitialized to let the bean factory post-processors apply to them!&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;    String[] postProcessorNames =
&lt;span&gt; 88&lt;/span&gt;          beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ordered, and the rest.&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;    List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;    List&amp;lt;String&amp;gt; orderedPostProcessorNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;    List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (processedBeans.contains(ppName)) {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; skip - already processed in first phase above&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, PriorityOrdered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;          priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, Ordered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;         orderedPostProcessorNames.add(ppName);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;         nonOrderedPostProcessorNames.add(ppName);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Next, invoke the BeanFactoryPostProcessors that implement Ordered.&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;    List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String postProcessorName : orderedPostProcessorNames) {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;       orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;   sortPostProcessors(orderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Finally, invoke all other BeanFactoryPostProcessors.&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;    List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String postProcessorName : nonOrderedPostProcessorNames) {
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;       nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Clear cached merged bean definitions since the post-processors might have
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; modified the original metadata, e.g. replacing placeholders in values...&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;   beanFactory.clearMetadataCache();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面在处理BeanDefinitionRegistryPostProcessors时有一个非常重要的过程，AnnotationConfigApplicationContext构造函数在初始化reader时为内部beanFactory容器初始化了一个id为org.springframework.context.annotation.internalConfigurationAnnotationProcessor的组件，这是一个ConfigurationClassPostProcessor组件，用来处理添加@Configuration注解的类，并将Bean定义注册到BeanFactory中。&lt;/p&gt;
&lt;h3&gt;6.注册BeanPostProcessor（Bean的后置处理器）,用于拦截bean创建过程&lt;/h3&gt;
&lt;p&gt; 注册后置处理器的大致逻辑是：&lt;/p&gt;
&lt;p&gt;　　1.获取所有的 BeanPostProcessor&lt;/p&gt;
&lt;p&gt;　　2.根据处理器实现的接口区分出4中类型：&lt;/p&gt;
&lt;p&gt;　　　　a.实现PriorityOrdered接口的处理器&lt;/p&gt;
&lt;p&gt;　　　　b.实现Ordered接口的处理器，&lt;/p&gt;
&lt;p&gt;　　　　c.实现MergedBeanDefinitionPostProcessor接口的处理器，&lt;/p&gt;
&lt;p&gt;　　　　d.普通后置处理器&lt;/p&gt;
&lt;p&gt;　　3.按这个4中类型依次注册到容器中&lt;/p&gt;
&lt;p&gt;　　4.注册一个特殊的后置处理器ApplicationListenerDetector，ApplicationListenerDetector本身也实现了MergedBeanDefinitionPostProcessor接口，有个问题，这个为什么没有在上面c,d之间注册，而是放到最后？&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;AbstractApplicationContext .registerBeanPostProcessors(beanFactory);实现逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanPostProcessors(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register BeanPostProcessorChecker that logs an info message when
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a bean is created during BeanPostProcessor instantiation, i.e. when
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a bean is not eligible for getting processed by all BeanPostProcessors.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 +&lt;span&gt; postProcessorNames.length;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Separate between BeanPostProcessors that implement PriorityOrdered,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ordered, and the rest.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按优先级分类&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    List&amp;lt;BeanPostProcessor&amp;gt; priorityOrderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    List&amp;lt;BeanPostProcessor&amp;gt; internalPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    List&amp;lt;String&amp;gt; orderedPostProcessorNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;    List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, PriorityOrdered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;          BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         priorityOrderedPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (pp &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MergedBeanDefinitionPostProcessor) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            internalPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, Ordered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;         orderedPostProcessorNames.add(ppName);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;         nonOrderedPostProcessorNames.add(ppName);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先注册实现PriorityOrdered接口的处理器，添加到beanfactory容器中beanFactory.addBeanPostProcessor(postProcessor);&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册实现Ordered接口的处理器&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;    List&amp;lt;BeanPostProcessor&amp;gt; orderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : orderedPostProcessorNames) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;       BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;      orderedPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (pp &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MergedBeanDefinitionPostProcessor) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;         internalPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;   sortPostProcessors(orderedPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;   registerBeanPostProcessors(beanFactory, orderedPostProcessors);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册没有实现Ordered或PriorityOrdered的处理器（nonOrderedPostProcessors）&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;    List&amp;lt;BeanPostProcessor&amp;gt; nonOrderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : nonOrderedPostProcessorNames) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;       BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;      nonOrderedPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (pp &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MergedBeanDefinitionPostProcessor) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;         internalPostProcessors.add(pp);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Finally, re-register all internal BeanPostProcessors.
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后，重新注册所有internal BeanPostProcessors（实现MergedBeanDefinitionPostProcessor接口的后置处理器&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; &lt;span&gt;   sortPostProcessors(internalPostProcessors, beanFactory);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;   registerBeanPostProcessors(beanFactory, internalPostProcessors);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册ApplicationListenerDetector，用于Bean创建完时检查是否是ApplicationListener&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;    beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationListenerDetector(applicationContext));
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span class=&quot;4Char&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;7.&lt;span class=&quot;4Char&quot;&gt;初始化&lt;span class=&quot;4Char&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;MessageSource&lt;span class=&quot;4Char&quot;&gt;组件（做国际化功能；消息绑定，消息解析）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; AbstractApplicationContext .initMessageSource()方法实现代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initMessageSource() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取beanFactory&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    ConfigurableListableBeanFactory beanFactory =&lt;span&gt; getBeanFactory();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否已经存在id为MESSAGE_SOURCE_BEAN_NAME的组件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make MessageSource aware of parent MessageSource.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.messageSource &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HierarchicalMessageSource) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          HierarchicalMessageSource hms = (HierarchicalMessageSource) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageSource;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (hms.getParentMessageSource() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only set parent context as parent MessageSource if no parent MessageSource
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; registered already.&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            hms.setParentMessageSource(getInternalParentMessageSource());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;          logger.debug(&quot;Using MessageSource [&quot; + &lt;span&gt;this&lt;/span&gt;.messageSource + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use empty MessageSource to be able to accept getMessage calls.&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;       DelegatingMessageSource dms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelegatingMessageSource();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      dms.setParentMessageSource(getInternalParentMessageSource());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.messageSource =&lt;span&gt; dms;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageSource);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;          logger.debug(&quot;Unable to locate MessageSource with name '&quot; + MESSAGE_SOURCE_BEAN_NAME +
&lt;span&gt;28&lt;/span&gt;                &quot;': using default [&quot; + &lt;span&gt;this&lt;/span&gt;.messageSource + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span class=&quot;4Char&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;8.&lt;span class=&quot;4Char&quot;&gt;初始化事件派发器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; AbstractApplicationContext .initApplicationEventMulticaster()方法实现逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initApplicationEventMulticaster() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取BeanFactory&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    ConfigurableListableBeanFactory beanFactory =&lt;span&gt; getBeanFactory();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有配置beanName为applicationEventMulticaster的事件派发器，则将其赋给容器中的applicationEventMulticaster对象&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.applicationEventMulticaster =
&lt;span&gt; 7&lt;/span&gt;             beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          logger.debug(&quot;Using ApplicationEventMulticaster [&quot; + &lt;span&gt;this&lt;/span&gt;.applicationEventMulticaster + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在，则创建一个SimpleApplicationEventMulticaster事件派发器，并注册到beanfactory中&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.applicationEventMulticaster = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleApplicationEventMulticaster(beanFactory);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationEventMulticaster);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;          logger.debug(&quot;Unable to locate ApplicationEventMulticaster with name '&quot; +
&lt;span&gt;18&lt;/span&gt;                APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
&lt;span&gt;19&lt;/span&gt;                &quot;': using default [&quot; + &lt;span&gt;this&lt;/span&gt;.applicationEventMulticaster + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;10. 注册时间监听器，将项目里面的ApplicationListener注册到容器中来&lt;/h3&gt;
&lt;p&gt;  registerListeners方法主要实现将事件监听器添加到IOC容器中的事件派发器中，并在最后做了一个事件发布的逻辑(如果之前的步骤有产生事件，则将earlyApplicationEvents中保存的事件逐一发布)&lt;/p&gt;
&lt;p&gt; AbstractApplicationContext .registerListeners()方法实现逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerListeners() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register statically specified listeners first.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (ApplicationListener&amp;lt;?&amp;gt;&lt;span&gt; listener : getApplicationListeners()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      getApplicationEventMulticaster().addApplicationListener(listener);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not initialize FactoryBeans here: We need to leave all regular beans
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uninitialized to let post-processors apply to them!&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String listenerBeanName : listenerBeanNames) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Publish early application events now that we finally have a multicaster...&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    Set&amp;lt;ApplicationEvent&amp;gt; earlyEventsToProcess = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlyApplicationEvents;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;.earlyApplicationEvents = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (earlyEventsToProcess != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ApplicationEvent earlyEvent : earlyEventsToProcess) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         getApplicationEventMulticaster().multicastEvent(earlyEvent);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;11. 初始化所有剩下的单实例bean,单例bean在初始化容器时创建，原型bean在获取时（getbean）时创建&lt;/h3&gt;
&lt;p&gt; AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory);方法实现代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件转换器相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;
&lt;span&gt; 4&lt;/span&gt;          beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      beanFactory.setConversionService(
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register a default embedded value resolver if no bean post-processor
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (such as a PropertyPlaceholderConfigurer bean) registered any before:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; at this point, primarily for resolution in annotation attribute values.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.hasEmbeddedValueResolver()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       beanFactory.addEmbeddedValueResolver(strVal -&amp;gt;&lt;span&gt; getEnvironment().resolvePlaceholders(strVal));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;aspectj相关.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String weaverAwareName : weaverAwareNames) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      getBean(weaverAwareName);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Stop using the temporary ClassLoader for type matching.&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;    beanFactory.setTempClassLoader(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allow for caching all bean definition metadata, not expecting further changes.&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;   beanFactory.freezeConfiguration();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化后剩下的单实例bean&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;   beanFactory.preInstantiateSingletons();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DefaultListableBeanFactory. preInstantiateSingletons()方法实现逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; preInstantiateSingletons() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       logger.debug(&quot;Pre-instantiating singletons in &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Iterate over a copy to allow for init methods which in turn register new bean definitions.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; While this may not be part of the regular factory bootstrap, it does otherwise work fine.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器中所有bean名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;    List&amp;lt;String&amp;gt; beanNames = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionNames);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trigger initialization of all non-lazy singleton beans...&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Bean的定义信息；RootBeanDefinition&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;       RootBeanDefinition bd =&lt;span&gt; getMergedLocalBeanDefinition(beanName);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非抽象，单例，非延迟加载&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !&lt;span&gt;bd.isLazyInit()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是FactoryBean&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isFactoryBean(beanName)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过&quot;&amp;amp;beanName&quot;获取工厂Bean实例&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             Object bean = getBean(FACTORY_BEAN_PREFIX +&lt;span&gt; beanName);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bean &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; FactoryBean) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                &lt;span&gt;final&lt;/span&gt; FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) bean;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEagerInit;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (System.getSecurityManager() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; factory &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SmartFactoryBean) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                   isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                               ((SmartFactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) factory)::isEagerInit,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        getAccessControlContext());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                   isEagerInit = (factory &lt;span&gt;instanceof&lt;/span&gt; SmartFactoryBean &amp;amp;&amp;amp;
&lt;span&gt;31&lt;/span&gt;                         ((SmartFactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) factory).isEagerInit());
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEagerInit) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                  getBean(beanName);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是FactoryBean,则利用getBean(beanName)实例化bean &lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            getBean(beanName);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trigger post-initialization callback for all applicable beans...&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;       Object singletonInstance =&lt;span&gt; getSingleton(beanName);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (singletonInstance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;          &lt;span&gt;final&lt;/span&gt; SmartInitializingSingleton smartSingleton =&lt;span&gt; (SmartInitializingSingleton) singletonInstance;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt; (System.getSecurityManager() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;               smartSingleton.afterSingletonsInstantiated();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }, getAccessControlContext());
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            smartSingleton.afterSingletonsInstantiated();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;12. 完成BeanFactory的初始化创建工作，IOC容器就创建完成&lt;/h3&gt;
&lt;p&gt; AbstractApplicationContext.finishRefresh()实现逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishRefresh() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Clear context-level resource caches (such as ASM metadata from scanning).&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   clearResourceCaches();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化和生命周期有关的后置处理器LifecycleProcessor，默认DefaultLifecycleProcessor&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   initLifecycleProcessor();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调生命周期处理器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   getLifecycleProcessor().onRefresh();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布容器刷新完成事件：ContextRefreshedEvent&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;    publishEvent(&lt;span&gt;new&lt;/span&gt; ContextRefreshedEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;    LiveBeansView.registerApplicationContext(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上基本分析了AnnotationConfigApplicationContext容器的初始化过程， Spring容器在启动过程中，会先保存所有注册进来的Bean的定义信息；Spring容器根据条件创建Bean实例，区分单例，还是原型，后置处理器等（后置处理器会在容器创建过程中通过getBean创建，并执行相应的逻辑）；Spring容器在创建bean实例后，会使用多种后置处理器来增加bean的功能，比如处理自动注入，AOP，异步，这种后置处理器机制也丰富了bean的功能。&lt;/p&gt;

</description>
<pubDate>Mon, 17 Sep 2018 06:51:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<og:description>Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9662119.html</dc:identifier>
</item>
<item>
<title>.Net Core应用框架Util介绍（三） - 何镇汐</title>
<link>http://www.cnblogs.com/xiadao521/p/Util-Introduction-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiadao521/p/Util-Introduction-3.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上篇介绍了Util的开发环境，并让你把Demo运行起来。本文将介绍该Demo的前端Angular运行机制以及目录结构。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;目录结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;span&gt; 　　在VS上打开Util Demo，会看见如下的目录结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180911172259839-2017188886.png&quot; alt=&quot;&quot;/&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现代前端通常采用VS Code开发，不过我们为了使用TagHelper，需要采用VS开发，这为你提供了更多的选择。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可以将WebApi和Angular应用放在同一个项目中，就像现在看见的那样。也可以分别把WebApi和Angular应用放到不同项目中。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你已经习惯了VS Code开发，这同样没问题，不过你将放弃TagHelper带来的强类型代码提示和编译时检查特性。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于Angular，它提供了ng cli命令行工具，你可以用ng cli来创建项目结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前文已简要介绍了TagHelper，它是用来提升Angular视图页面开发效率的利器。为了使用TagHelper，不得不放弃ng cli，因为它不支持在Angular组件上配置服务端动态地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面介绍这个项目中包含的目录和文件。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Apis目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这个目录用来存放Web Api控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180911193901522-34769985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ApplicationController演示了普通CRUD操作，RoleController演示了树型层次的CRUD操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你暂时不要关心Web Api CRUD操作，我会在后续介绍。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt; Areas目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180911220513729-1521445724.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;用过Asp.Net Mvc的同学可能知道，Areas就是区域，它的作用是提供模块化管理。我们把不同的模块用Areas的区域分隔开，这样在项目规模变大时，还能迅速找到相关页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　与传统Asp.Net Mvc应用不同，Util的Areas控制器并不进行任何操作，只是简单的返回视图页面，cshtml仅起到代码生成器的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个更好的选择是使用RazorPage,它把控制器和页面合并了，将来会使用这种方式。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Configs目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;span&gt;　　你并不需要它，我在Demo中用来放测试配置，项目上我通常把Configs目录放在应用层类库。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Controllers目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 　　Controllers目录是用来放置与首页相关的控制器。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Datas目录&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　Util引入了DDD经典架构，Datas位于基础设施层，一些人把它叫仓储层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Datas通常放在单独的类库，为了演示简单，我放在该WEB项目的目录中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;DbScripts目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这个目录提供了Sql Server建库脚本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一些人可能很惊讶，什么年代了，还在使用Db First开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在多年的开发实战中，我摸索到一套以PowerDesigner数据建模配合CodeSmith代码生成的开发模式。对于CRUD，它具有快速高效的特点，同时你还能拥有清晰的数据字典以供未来查阅。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于具备面向对象编程能力的人，这种方式并不会降低代码质量和设计水平，在将代码生成出来以后，通过手工调整就可达到与Code First相同的代码水平。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我会在未来某个合适的时候介绍这种开发模式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; Domains目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　DDD经典架构中领域层相关的目录，实际开发中将放到单独的类库。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Services目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　DDD经典架构中应用层相关的目录，实际开发中将放到单独的类库。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Typings目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　&lt;span&gt;Angular相关的所有东西都在这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180911235944251-64890278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;app目录用来存放与业务相关的项目资源&lt;/strong&gt;，比如Angular组件，指令，服务等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　值得&lt;strong&gt;注意&lt;/strong&gt;的是，该目录包含组件对应的.html文件，这些.html文件和.cshtml文件是怎样的关系？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180911234621644-1878849445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果你从未运行过Util Demo项目，打开app目录，并未找到任何.html文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可能已经猜到了，&lt;strong&gt;.html文件是由.cshtml文件生成的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你永远都不应该手工编辑这些.html文件，因为在调试运行时将被覆盖。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;test目录包含Ts单元测试&lt;/strong&gt;，我仅对极少数Helper进行单元测试。通过下面的npm命令把测试运行起来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180912000926161-199048368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;util目录包含对Angular常用API和Angular Material组件的封装。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180912001720765-147472584.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　Angular组件由视图和控制器两部分构成。视图即模板页，包含html标签。控制器用来编写逻辑，包含Ts代码。换句话说，Angular应用开发主要是编写html和ts（当然还有css，暂时不要管它）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　TagHelper并不是Util封装Angular的唯一手段，&lt;strong&gt;对于Angular控制器,Util采用链式封装&lt;/strong&gt;手法，将Angular常用Api封装得更加简单易用，使你对Angular Api只要有一个模糊的印象就可以开发了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;对于Angular视图页面&lt;/strong&gt;，并不能直接采用TagHelper简单包装，这样会导致TagHelper过于复杂，另外很多功能需要在运行时进行判断，TagHelper只在开发调试阶段存在，所以采用两层封装会更加省力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;首先采用Angular组件或指令对Material组件进行封装，然后采用TagHelper提供强类型提示。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于希望采用VS Code开发的同学，Typings/util目录中封装的代码同样可以使用，它跟TagHelper没有什么关系，你可以把它Copy到你的项目，我尚未把它发布到npm。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Views目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　Views目录包含首页。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;appsettings.json文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是一个配置文件，数据库连接字符串在这里。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;nlog.config文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是NLog日志组件的配置文件，Util 采用NLog输出开发调试和错误日志，默认位置是&lt;strong&gt;c:\log&lt;/strong&gt;目录。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;package.json文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是npm包管理器的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Program.cs文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是Asp.Net Core程序入口点文件。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Startup.cs文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是Asp.Net Core启动文件，在这里配置依赖注入和中间件请求管道。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;tsconfig.json文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是Typescript语言配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;webpack.config.js文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　它是Webpack自动化构建工具的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还有两个配置文件隐藏在webpack.config.js下，它们对util和第三方Js框架进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180912012245066-1906835631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;运行机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;对于没有前端基础的同学，可能很难理解这个Demo是如何运行起来的，下面为你介绍这个Demo的运行机制，我们从npm包还原开始。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt; npm还原&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;当你输入&lt;strong&gt;yarn&lt;/strong&gt;和&lt;strong&gt;cnpm install node-sass&lt;/strong&gt;，它会找到&lt;strong&gt;package.json&lt;/strong&gt;文件的&lt;strong&gt;dependencies&lt;/strong&gt;节，然后把需要的文件下载到&lt;strong&gt;node_modules&lt;/strong&gt;目录中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 执行Webpack构建&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　然后输入&lt;strong&gt;npm run dev&lt;/strong&gt;，这里发生了什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;npm run&lt;/strong&gt;是npm的一个命令，它会查找&lt;strong&gt;package.json&lt;/strong&gt;中&lt;strong&gt;scripts&lt;/strong&gt;定义的命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916122851927-905053392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;npm run dev&lt;/span&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　dev&lt;/strong&gt;就是npm run要查找的命令名，它是一个约定俗成的名称，代表开发阶段配置，即develop，当然你不一定用这个名字，叫abc也可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　npm run dev&lt;/strong&gt;查找到&lt;strong&gt;package.json&lt;/strong&gt;文件&lt;strong&gt;scripts&lt;/strong&gt;节定义的&lt;strong&gt;dev&lt;/strong&gt;命令，它的内容是&lt;strong&gt;npm run vendor &amp;amp;&amp;amp; npm run app&lt;/strong&gt;，这个命令是由两个npm run命令组成的。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; npm run vendor&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　npm run vendor&lt;/strong&gt;的内容是&lt;strong&gt;webpack --config webpack.config.vendor.js&lt;/strong&gt;，这将对webpack.config.vendor.js执行构建操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;webpack&lt;/strong&gt;命令&lt;strong&gt;默认查找webpack.config.js&lt;/strong&gt;文件，现在要查找的是webpack.config.vendor.js，所以需要添加参数&lt;strong&gt;—config。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来看看webpack.config.vendor.js包含什么内容。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('62400ef6-8efa-4685-93a4-eb635f725a99')&quot; readability=&quot;59&quot;&gt;&lt;img id=&quot;code_img_closed_62400ef6-8efa-4685-93a4-eb635f725a99&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62400ef6-8efa-4685-93a4-eb635f725a99&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('62400ef6-8efa-4685-93a4-eb635f725a99',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62400ef6-8efa-4685-93a4-eb635f725a99&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;113&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; const pathPlugin = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; const webpack = require('webpack'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; Extract = require(&quot;extract-text-webpack-plugin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三方Js库&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; const jsModules =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     'reflect-metadata'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     'zone.js'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     'moment'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     '@angular/animations'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     '@angular/common'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     '@angular/common/http'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     '@angular/compiler'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     '@angular/core'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     '@angular/forms'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     '@angular/elements'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     '@angular/platform-browser'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     '@angular/platform-browser/animations'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     '@angular/platform-browser-dynamic'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     '@angular/router'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     '@angular/cdk/esm5/collections.es5'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     '@angular/flex-layout'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     '@angular/material'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     'primeng/primeng'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     'lodash'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &quot;echarts-ng2&quot;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三方Css库&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; const cssModules =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     '@angular/material/prebuilt-themes/indigo-pink.css'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     'material-design-icons/iconfont/material-icons.css'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     'font-awesome/css/font-awesome.css'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     'primeicons/primeicons.css'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     'primeng/resources/themes/omega/theme.css'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     'primeng/resources/primeng.min.css'
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; module.exports = (env) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否开发环境&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     const isDev = !(env &amp;amp;&amp;amp;&lt;span&gt; env.prod);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     const mode = isDev ? &quot;development&quot; : &quot;production&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将css提取到单独文件中&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     const extractCss = &lt;span&gt;new&lt;/span&gt; Extract(&quot;vendor.css&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路径&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getPath(path) {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pathPlugin.join(__dirname, path);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包第三方Js库&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;     let vendorJs =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        mode: mode,
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        entry: { vendor: jsModules },
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        output: {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             publicPath: 'dist/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             path: getPath(&quot;wwwroot/dist&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             filename: &quot;[name].js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             library: '[name]'
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        resolve: {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             extensions: ['.js'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         devtool: &quot;source-map&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        plugins: [
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllPlugin({
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 path: getPath(&quot;wwwroot/dist/[name]-manifest.json&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 name: &quot;[name]&quot;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            }),
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; webpack.ContextReplacementPlugin(/\@angular\b.*\b(bundles|linker)/, getPath('./Typings'&lt;span&gt;)),
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; webpack.ContextReplacementPlugin(/angular(\\|\/)core(\\|\/)@angular/, getPath('./Typings'&lt;span&gt;)),
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; webpack.IgnorePlugin(/^vertx$/&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包css&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;     let vendorCss =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        mode: mode,
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        entry: { vendor: cssModules },
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        output: {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             publicPath: './'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             path: getPath(&quot;wwwroot/dist&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             filename: &quot;[name].css&quot;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         devtool: &quot;source-map&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        module: {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            rules: [
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 { test: /\.css$/, use: extractCss.extract({ use: isDev ? 'css-loader' : 'css-loader?minimize'&lt;span&gt; }) },
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     test: /\.(png|jpg|gif|woff|woff2|eot|ttf|svg)(\?|$)/&lt;span&gt;, use: {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                         loader: 'url-loader'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                        options: {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                             limit: 20000&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                             name: &quot;[name].[ext]&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                             outputPath: &quot;images/&quot;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        plugins: [
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            extractCss
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; isDev ?&lt;span&gt; [ vendorJs, vendorCss] : [vendorCss];
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;webpack.config.vendor.js&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　vendorJs&lt;/span&gt;&lt;/strong&gt; &lt;span lang=&quot;EN-US&quot;&gt;对象用于配置将哪些第三方&lt;span lang=&quot;EN-US&quot;&gt;Js框架文件进行打包，&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;vendorCss&lt;/strong&gt; 对象用于配置需要打包的第三方框架提供的&lt;span lang=&quot;EN-US&quot;&gt;Css文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;　　entry&lt;/strong&gt;属性指定了需要打包的入口文件，&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;output&lt;/strong&gt;属性则指定输出的位置和文件名。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当&lt;span lang=&quot;EN-US&quot;&gt;webpack.config.vendor.js执行完毕，会在&lt;span lang=&quot;EN-US&quot;&gt;Util.Samples.Webs项目的&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;wwwroot&lt;/strong&gt;目录创建一个&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;dist&lt;/strong&gt;子目录，并生成&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;vendor.js&lt;/strong&gt;和&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;vendor.css&lt;/strong&gt;两个文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;vendor.js仅在开发调试阶段使用&lt;/strong&gt;，所以并没有对它进行压缩，正式发布并不需要执行&lt;span lang=&quot;EN-US&quot;&gt;vendorJs对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该脚本的最后一行证明了这一点。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;return&lt;/span&gt; isDev ? [ vendorJs, vendorCss] : [vendorCss];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; npm run app&lt;/span&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;strong&gt;npm run app&lt;/strong&gt;又包含两个命令，用于执行&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;webpack.config.util.js&lt;/strong&gt;和&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;webpack --config webpack.config.util.js &amp;amp;&amp;amp; webpack&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　先来看看&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;webpack.config.util.js&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a6a47177-2ec1-4b8c-8018-ea779d914f65')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_a6a47177-2ec1-4b8c-8018-ea779d914f65&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a6a47177-2ec1-4b8c-8018-ea779d914f65&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a6a47177-2ec1-4b8c-8018-ea779d914f65',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a6a47177-2ec1-4b8c-8018-ea779d914f65&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; const pathPlugin = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; const webpack = require('webpack'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; module.exports = (env) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否开发环境&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     const isDev = !(env &amp;amp;&amp;amp;&lt;span&gt; env.prod);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     const mode = isDev ? &quot;development&quot; : &quot;production&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路径&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getPath(path) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pathPlugin.join(__dirname, path);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包util脚本库&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        mode: mode,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         entry: { util: [getPath(&quot;Typings/util/index.ts&quot;&lt;span&gt;)] },
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        output: {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             publicPath: 'dist/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             path: getPath(&quot;wwwroot/dist&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             filename: &quot;[name].js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             library: '[name]'
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        resolve: {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             extensions: ['.js', '.ts'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         devtool: &quot;source-map&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        module: {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            rules: [
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 { test: /\.ts$/, use: ['awesome-typescript-loader?silent=true'&lt;span&gt;] }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        plugins: [
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllReferencePlugin({
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 manifest: require('./wwwroot/dist/vendor-manifest.json'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }),
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllPlugin({
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 path: getPath(&quot;wwwroot/dist/[name]-manifest.json&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 name: &quot;[name]&quot;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;webpack.config.util.js&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;它将查找&lt;span lang=&quot;EN-US&quot;&gt;Util.Samples.Webs项目下&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;Typings/util/index.ts&lt;/strong&gt;文件，这是&lt;span lang=&quot;EN-US&quot;&gt;util默认导出文件，所有在外部需要访问的类型都会从这里导出。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当&lt;span lang=&quot;EN-US&quot;&gt;webpack.config.util.js执行完毕，会在&lt;span lang=&quot;EN-US&quot;&gt;dist目录创建&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;util.js&lt;/strong&gt;文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同样的，&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;util.js文件仅用于开发调试阶段&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面看&lt;strong&gt;webpack.config.js&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3289f396-d06a-4703-a30b-78f794a287db')&quot; readability=&quot;53&quot;&gt;&lt;img id=&quot;code_img_closed_3289f396-d06a-4703-a30b-78f794a287db&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3289f396-d06a-4703-a30b-78f794a287db&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3289f396-d06a-4703-a30b-78f794a287db',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3289f396-d06a-4703-a30b-78f794a287db&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; const pathPlugin = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; const webpack = require('webpack'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; Extract = require(&quot;extract-text-webpack-plugin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; const AngularCompilerPlugin = require('@ngtools/webpack'&lt;span&gt;).AngularCompilerPlugin;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; module.exports = (env) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否开发环境&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     const isDev = !(env &amp;amp;&amp;amp;&lt;span&gt; env.prod);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     const mode = isDev ? &quot;development&quot; : &quot;production&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将css提取到单独文件中&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     const extractCss = &lt;span&gt;new&lt;/span&gt; Extract(&quot;app.css&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路径&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getPath(path) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pathPlugin.join(__dirname, path);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包js&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     let jsConfig =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        mode: mode,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         entry: { app: getPath(&quot;Typings/main.ts&quot;&lt;span&gt;) },
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        output: {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             publicPath: 'dist/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             path: getPath(&quot;wwwroot/dist&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             filename: &quot;[name].js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             chunkFilename: '[id].chunk.js'
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        resolve: {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             extensions: ['.js', '.ts'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         devtool: &quot;source-map&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        module: {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            rules: [
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 { test: /\.ts$/, use: isDev ? ['awesome-typescript-loader?silent=true', 'angular-router-loader'] : ['@ngtools/webpack'&lt;span&gt;] },
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 { test: /\.js$/, loader: '@angular-devkit/build-optimizer/webpack-loader', options: { sourceMap: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; } },
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 { test: /\.html$/, use: 'html-loader?minimize=false'&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        plugins: [
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 'process.env': { NODE_ENV: isDev ? JSON.stringify(&quot;dev&quot;) : JSON.stringify(&quot;prod&quot;&lt;span&gt;) }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         ].concat(isDev ?&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllReferencePlugin({
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 manifest: require('./wwwroot/dist/vendor-manifest.json'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }),
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllReferencePlugin({
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 manifest: require('./wwwroot/dist/util-manifest.json'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        ] : [
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AngularCompilerPlugin({
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     tsConfigPath: 'tsconfig.json'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     entryModule: &quot;Typings/app/app.module#AppModule&quot;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            ])
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包css&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     let cssConfig =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        mode: mode,
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         entry: { app: getPath(&quot;wwwroot/css/main.scss&quot;&lt;span&gt;) },
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        output: {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             publicPath: './'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             path: getPath(&quot;wwwroot/dist&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             filename: &quot;[name].css&quot;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        resolve: {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             modules: ['wwwroot'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         devtool: &quot;source-map&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        module: {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            rules: [
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                     test: /\.scss$/&lt;span&gt;, use: extractCss.extract({
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                         use: isDev ? ['css-loader', { loader: 'postcss-loader', options: { plugins: [require('autoprefixer')] } }, 'sass-loader'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                             : ['css-loader?minimize', { loader: 'postcss-loader', options: { plugins: [require('autoprefixer')] } }, 'sass-loader'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;                    })
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                     test: /\.(png|jpg|gif|woff|woff2|eot|ttf|svg)(\?|$)/&lt;span&gt;, use: {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                         loader: 'url-loader'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;                        options: {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                             limit: 20000&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;                             name: &quot;[name].[ext]&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                             outputPath: &quot;images/&quot;
&lt;span&gt;87&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;        plugins: [
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;            extractCss
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [jsConfig, cssConfig];
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;webpack.config.js&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　webpack.config.js查找Typings目录下的&lt;strong&gt;main.ts&lt;/strong&gt;，main.ts是angular项目的入口文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　webpack通过递归依赖查找main.ts，将除了util.js和vendor.js以外所有引用到的ts或js文件打包到dist/&lt;strong&gt;app.js&lt;/strong&gt;文件中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;，正式发布时，app.js将采用angular官方提供的webpack编译插件&lt;strong&gt;@ngtools/webpack&lt;/strong&gt;进行AOT编译并打包生成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916181934752-1817801675.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　现在&lt;strong&gt;dist&lt;/strong&gt;目录生成了如下文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916190340536-1269564408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;0.chunk.js&lt;/strong&gt;是由angular&lt;strong&gt;子模块&lt;/strong&gt;生成的js文件，当路由配置对子模块启用了延迟加载，每个子模块都会生成一个独立的js文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916193359791-49115102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;loadChildren&lt;/strong&gt;以延迟加载的方式来配置&lt;strong&gt;SystemModule&lt;/strong&gt;子模块。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;span&gt;运行机制&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　现在运行angular应用的js文件已经就绪，让我们把它运行起来，在VS上&lt;strong&gt;F5&lt;/strong&gt;启动项目。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：你应该使用Google &lt;strong&gt;Chrome&lt;/strong&gt;来打开它，IE浏览器，可以通过启用&lt;strong&gt;polyfill&lt;/strong&gt;来勉强支持，不过由于效果不佳，我已经把它扔掉了。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器打开首页&lt;strong&gt;http://localhost:5200&lt;/strong&gt;，Asp.Net Core启动文件&lt;strong&gt;Startup&lt;/strong&gt;.cs中配置的默认路由将被激活，从而将请求发送到HomeController控制器的Index方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916195813847-1186334832.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;187&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916195917610-430857690.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;strong&gt;Index&lt;/strong&gt;方法直接返回了&lt;strong&gt;Views&lt;/strong&gt;目录下&lt;strong&gt;Index.cshtml&lt;/strong&gt;首页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916200803898-1799785474.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　environment&lt;/strong&gt;标签是一个环境判断条件，用于设置开发及上线等不同阶段的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;lt;environment &lt;strong&gt;include&lt;/strong&gt;=&quot;Development&quot;&amp;gt;用于&lt;strong&gt;开发&lt;/strong&gt;阶段，&amp;lt;environment &lt;strong&gt;exclude&lt;/strong&gt;=&quot;Development&quot;&amp;gt;用于&lt;strong&gt;发布&lt;/strong&gt;阶段，可以看出，在&lt;strong&gt;发布后并不需要vendor.js和util.js文件&lt;/strong&gt;，因为app.js会包含它们。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好，现在浏览器加载了Index首页，Angular应用是如何运行起来的呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;Angular的引导过程&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 　　还记得Angular应用入口文件&lt;strong&gt;main.ts&lt;/strong&gt;吗，来看看它包含什么内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916210622437-1573296013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;platformBrowserDynamic&lt;/strong&gt;是为浏览器平台提供的&lt;strong&gt;JIT动态编译&lt;/strong&gt;服务，它将引导AppModule根模块的启动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;AppModule&lt;/strong&gt;是Angular应用的&lt;strong&gt;根模块&lt;/strong&gt;，它的主要任务之一就是启动AppComponent根组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916212911161-1869807496.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　AppComponent&lt;/strong&gt;是整个Angular应用的&lt;strong&gt;根组件&lt;/strong&gt;，所有其它组件都将被加载到根组件中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916213800623-493416437.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　selector&lt;/strong&gt;用于指定组件的&lt;strong&gt;自定义标签&lt;/strong&gt;，这里将根组件标签定义为&lt;strong&gt;&amp;lt;app&amp;gt;&amp;lt;/app&amp;gt;&lt;/strong&gt;，你发现它已经被放置在Index.cshtml中。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AppComponent根组件准备启动了，由于是&lt;strong&gt;JIT&lt;/strong&gt;编译，所以它&lt;strong&gt;需要获取视图&lt;/strong&gt;。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　组件的视图由&lt;strong&gt;templateUrl&lt;/strong&gt;属性指定。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;templateUrl: env.prod() ? './app.component.html' : '/home/main'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;我们希望开发阶段通过访问服务端控制器来获取视图，这样在编辑TagHelper时就能更方便，只需刷新页面就能看见效果。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;env&lt;/strong&gt;是一个环境检测对象，&lt;strong&gt;prod&lt;/strong&gt;方法如果返回true表明当前为正式环境，将从app.component.html静态文件获取视图，如果是开发调试环境，则访问服务端HomeController控制器的Main方法获取视图。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917113757332-702443719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Main方法上的&lt;strong&gt;Html&lt;/strong&gt;特性，是用来帮助.cshtml生成.html静态文件的辅助工具。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般情况下，你并不需要手工设置Html特性来生成html文件，Util提供了&lt;strong&gt;ViewControllerBase&lt;/strong&gt;控制器基类，当你的视图控制器继承它，所有html文件就会生成到约定的目录中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917115957791-1784851416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由&lt;strong&gt;Template&lt;/strong&gt;属性设置的路径可知，Typings/app中的项目结构也采用模块化组织，与区域模块相对应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;现在来看根组件的视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917121031771-301597986.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;　　这是你第一次看见Util封装的&lt;strong&gt;TagHelper&lt;/strong&gt;标签，以&lt;strong&gt;&amp;lt;util-&lt;/strong&gt;打头的标签都是Util TagHelper，它们以粗体显示，这是由于安装了Resharper的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　TagHelper在运行时会把html输出到页面，它们把弱类型的html封装成了具有强类型提示的标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如何知道某个TagHelper到底输出了什么html呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一种办法是打开它生成的.html文件来查找，不过当页面很复杂时，这种办法有点吃力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一种办法是查看&lt;strong&gt;日志&lt;/strong&gt;，Util TagHelper的每个组件都提供了&lt;strong&gt;write-log&lt;/strong&gt;属性，当设置为true，就会在C盘log目录生成日志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917123647026-750719974.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917123440139-872141703.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917123556100-1555409147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　main.cshtml视图中最关键的部分就是&lt;strong&gt;&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;&lt;/strong&gt;标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;router-outlet是Angular路由的占位符&lt;/strong&gt;，当根模块AppModule中配置的路由激活时，相关的Angular组件就会被放进这个占位符中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根模块中的路由配置被拆分到一个单独的模块&lt;strong&gt;AppRoutingModule&lt;/strong&gt;中，路由配置如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917125332104-602439362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;通过路由配置可以发现，当打开首页时，命中路由第二项&lt;strong&gt;path:’’&lt;/strong&gt;，会跳转到/systems/application路径，systems是一个子模块，我们来查看它的路由配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917130317703-1469129478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917130324725-70731682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　/systems/application将激活&lt;strong&gt;ApplicationIndexComponent&lt;/strong&gt;组件，并把它加载到根组件的&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ApplicationIndexComponent组件请求服务端地址&lt;strong&gt;/view/systems/application&lt;/strong&gt;获取视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917131519649-1919767258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;/view&lt;/strong&gt;打头的地址将匹配到Areas区域控制器，这是在MVC路由配置中设置的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916222853869-505973085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;控制器&lt;strong&gt;ApplicationController&lt;/strong&gt;的&lt;strong&gt;Index&lt;/strong&gt;方法将返回视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180917134115215-1495679197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Angular JIT编译会在系统启动时请求服务端URL，在Chrome浏览器&lt;strong&gt;F12&lt;/strong&gt;调出开发者工具，刷新页面，会观察到页面请求了Areas中的控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180916222002128-507838666.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以你在开发阶段运行项目会感觉比较慢，在正式发布后就没这些开销了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　本文简要介绍了Util Demo的目录结构和运行机制，如果你没有Angular基础，估计还是很难看懂，建议你阅读&lt;strong&gt;Angular中文网&lt;/strong&gt;&lt;a href=&quot;https://angular.cn/&quot;&gt;https://angular.cn&lt;/a&gt;。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　未完待续，下一篇将对Util Demo的Angular封装进行介绍，本来是准备这篇介绍的，不过限于篇幅，放到下篇，我知道，太长的文章既难写更难读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写文需要动力，请大家多多支持，点下推荐，Github点下星星。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util应用框架交流一群: 24791014&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 06:49:00 +0000</pubDate>
<dc:creator>何镇汐</dc:creator>
<og:description>上篇介绍了Util的开发环境，并让你把Demo运行起来。本文将介绍该Demo的前端Angular运行机制以及目录结构。 目录结构 在VS上打开Util Demo，会看见如下的目录结构。 现代前端通常采</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiadao521/p/Util-Introduction-3.html</dc:identifier>
</item>
<item>
<title>一篇入门 — Scala 宏 - 旻天clock</title>
<link>http://www.cnblogs.com/clockq/p/9661639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clockq/p/9661639.html</guid>
<description>&lt;p&gt;上一节, 我简单的说了一下反射的基本概念以及运行时反射的用法, 同时简单的介绍了一下编译原理知识, 其中我感觉最为&lt;code&gt;绕&lt;/code&gt;的地方, 就属泛型的几种使用方式了.&lt;br/&gt;&lt;strong&gt;而最抽象的概念, 就是对于符号和抽象树的这两个概念的理解.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在回顾一下泛型的几种进阶用法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上界 &amp;lt;:&lt;/li&gt;
&lt;li&gt;下界 &amp;gt;:&lt;/li&gt;
&lt;li&gt;视界 &amp;lt;%&lt;/li&gt;
&lt;li&gt;边界 :&lt;/li&gt;
&lt;li&gt;协变 +T&lt;/li&gt;
&lt;li&gt;逆变 -T&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在想想, 既然已经有了泛型了, 还要这几个功能干嘛呢? 其实可以类比一下, 之前没有泛型, 而为什么引入泛型呢?&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;当然是为了代码更好的服用. 想象一下, 本来一个方法没有入参, 但通过参数, 可以减少很多相似代码.&lt;/p&gt;
&lt;p&gt;同理, 泛型是什么, generics. 又叫什么, 类型参数化. 本来方法的入参只能接受一种类型的参数, 加入泛型后, 可以处理多种类型的入参.&lt;/p&gt;
&lt;p&gt;顺着这条线接着往下想, 有了逆变和协变, 我们让泛型的包装类也有了类继承关系, 有了继承的层级关系, 方法的处理能力又会大大增加.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;泛型, 并不神奇, 只是省略了一系列代码, 而且引入泛型还会导致&lt;code&gt;泛型擦除&lt;/code&gt;, 以及一系列的隐患. 而类型擦除其实也是为了兼容更早的语言, 我们束手无策.&lt;br/&gt;但泛型在设计上实现的数据和逻辑分离, 却可以大大提高程序代码的简洁性和可读性, 并提供可能的编译时类型转换安全检测功能. 所以在可以使用泛型的地方我们还是推荐的.&lt;/p&gt;

&lt;p&gt;上篇文章已经介绍过, 编译器反射也就是在Scala的表现形式, 就是我们本篇的重点 宏(&lt;code&gt;Macros&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&quot;macros-能做什么呢&quot;&gt;&lt;code&gt;Macros&lt;/code&gt; 能做什么呢?&lt;/h3&gt;
&lt;p&gt;直白一点, 宏能够&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Code that generates code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还记得上篇文章中, 我们提到的AST(abstract syntax tree, 抽象语法树)吗? &lt;code&gt;Macros&lt;/code&gt; 可以利用 &lt;code&gt;compiler plugin&lt;/code&gt; 在 &lt;code&gt;compile-time&lt;/code&gt; 操作 &lt;code&gt;AST&lt;/code&gt;, 从而实现一些为所以为的...任性操作&lt;/p&gt;
&lt;p&gt;所以, 可以理解宏就是一段在编译期运行的代码, 如果我们可以合理的利用这点, 就可以将一些代码提前执行, 这意味着什么, 更早的(&lt;code&gt;compile-time&lt;/code&gt;)发现错误, 从而避免了 &lt;code&gt;run-time&lt;/code&gt;错误. 还有一个不大不小的好处, 就是可以减少方法调用的堆栈开销.&lt;/p&gt;
&lt;p&gt;是不是很吸引人, 好, 开始Macros的盛宴.&lt;/p&gt;
&lt;h2 id=&quot;黑盒宏和白盒宏&quot;&gt;黑盒宏和白盒宏&lt;/h2&gt;
&lt;p&gt;黑盒和白盒的概念, 就不做过多介绍了. 而Scala既然引用了这两个单词来描述宏, 那么两者区别也就显而易见了. 当然, 这两个是新概念, 在2.10之前, 只有一种宏, 也就是白盒宏的前身.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;官网描述如下:&lt;br/&gt;Macros that faithfully follow their type signatures are called blackbox macros as their implementations are irrelevant to understanding their behaviour (could be treated as black boxes).&lt;br/&gt;Macros that can't have precise signatures in Scala's type system are called whitebox macros (whitebox def macros do have signatures, but these signatures are only approximations).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我怕每个人的理解不一样, 所以先贴出了官网的描述, 而我的理解呢, 就是我们指定好返回类型的&lt;code&gt;Macros&lt;/code&gt;就是黑盒宏, 而我们虽然指定返回值类型, 甚至是以&lt;code&gt;c.tree&lt;/code&gt;定义返回值类型, 而更加细致的具体类型, 即真正的返回类型可以在宏中实现的, 我们称为白盒宏.&lt;/p&gt;
&lt;p&gt;可能还是有点绕哈, 我举个例子吧. 在此之前, 先把二者的位置说一下:&lt;/p&gt;
&lt;p&gt;2.10&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scala.reflect.macros.Context&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.11 +&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scala.reflect.macros.blackbox.Context&lt;/li&gt;
&lt;li&gt;scala.reflect.macros.whitebox.Context&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;黑盒例子&quot;&gt;黑盒例子&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;import scala.reflect.macros.blackbox

object Macros {
    def hello: Unit = macro helloImpl

    def helloImpl(c: blackbox.Context): c.Expr[Unit] = {
        import c.universe._
        c.Expr {
              Apply(
                    Ident(TermName(&quot;println&quot;)),
                    List(Literal(Constant(&quot;hello!&quot;)))
              )
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是要注意, 黑盒宏的使用, 会有四点限制, 主要方面是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;类型推到&lt;/li&gt;
&lt;li&gt;隐式推到&lt;/li&gt;
&lt;li&gt;模式匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我不细说了, 有兴趣可以看看官网: &lt;a href=&quot;https://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html&quot; class=&quot;uri&quot;&gt;https://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;白盒例子&quot;&gt;白盒例子&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;import scala.reflect.macros.blackbox

object Macros {
    def hello: Unit = macro helloImpl

    def helloImpl(c: blackbox.Context): c.Tree = {
      import c.universe._
      c.Expr(q&quot;&quot;&quot;println(&quot;hello!&quot;)&quot;&quot;&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Using macros is easy, developing macros is hard.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;了解了&lt;code&gt;Macros&lt;/code&gt;的两种规范之后, 我们再来看看它的两种用法, 一种和C的风格很像, 只是在编译期将宏展开, 减少了方法调用消耗. 还有一种用法, 我想大家更熟悉, 就是注解, 将一个宏注解标记在一个类, 方法, 或者成员上, 就可以将所见的代码, 通过AST变成everything, 不过, 请不要变的太离谱.&lt;/p&gt;
&lt;h2 id=&quot;def-macros&quot;&gt;Def Macros&lt;/h2&gt;
&lt;p&gt;方法宏, 其实之前的代码中, 已经见识过了, 没什么稀奇, 但刚才的例子还是比较简单的, 如果我们要传递一个参数, 或者泛型呢?&lt;/p&gt;
&lt;p&gt;看下面例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;object Macros {
    def hello2[T](s: String): Unit = macro hello2Impl[T]

    def hello2Impl[T](c: blackbox.Context)(s: c.Expr[String])(ttag: c.WeakTypeTag[T]): c.Expr[Unit] = {
        import c.universe._
        c.Expr {
            Apply(
                Ident(TermName(&quot;println&quot;)),
                List(
                    Apply(
                        Select(
                            Apply(
                                Select(
                                    Literal(Constant(&quot;hello &quot;)),
                                    TermName(&quot;$plus&quot;)
                                ),
                                List(
                                    s.tree
                                )
                            ),
                            TermName(&quot;$plus&quot;)
                        ),
                        List(
                            Literal(Constant(&quot;!&quot;))
                        )
                    )
                )
            )
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和之前的不同之处, 暴露的方法hello2主要在于多了参数&lt;code&gt;s&lt;/code&gt;和泛型&lt;code&gt;T&lt;/code&gt;, 而&lt;code&gt;hello2Impl&lt;/code&gt;实现也多了两个括号&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(s: c.Expr[String])&lt;/li&gt;
&lt;li&gt;(ttag: c.WeakTypeTag[T])&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来一一讲解&lt;/p&gt;
&lt;h3 id=&quot;c.expr&quot;&gt;c.Expr&lt;/h3&gt;
&lt;p&gt;这是&lt;code&gt;Macros&lt;/code&gt;的表达式包装器, 里面放置着类型&lt;code&gt;String&lt;/code&gt;, 为什么不能直接传&lt;code&gt;String&lt;/code&gt;呢?&lt;br/&gt;当然是不可以了, 因为宏的入参只接受Expr, 调用宏传入的参数也会默认转为Expr.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里要注意, 这个&lt;code&gt;(s: c.Expr[String])&lt;/code&gt;的入参名必须等于&lt;code&gt;hello2[T](s: String)&lt;/code&gt;的入参名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;weaktypetagt&quot;&gt;WeakTypeTag[T]&lt;/h3&gt;
&lt;p&gt;记得上一期已经说过的&lt;code&gt;TypeTag&lt;/code&gt; 和 &lt;code&gt;ClassTag&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; val ru = scala.reflect.runtime.universe
ru @ 6d657803: scala.reflect.api.JavaUniverse = scala.reflect.runtime.JavaUniverse@6d657803

scala&amp;gt; def foo[T: ru.TypeTag] = implicitly[ru.TypeTag[T]]
foo: [T](implicit evidence$1: reflect.runtime.universe.TypeTag[T])reflect.runtime.universe.TypeTag[T]

scala&amp;gt; foo[Int]
res0 @ 7eeb8007: reflect.runtime.universe.TypeTag[Int] = TypeTag[Int]

scala&amp;gt; foo[List[Int]]
res1 @ 7d53ccbe: reflect.runtime.universe.TypeTag[List[Int]] = TypeTag[scala.List[Int]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这都没有问题, 但是如果我传递一个泛型呢, 比如这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; def bar[T] = foo[T] // T is not a concrete type here, hence the error
&amp;lt;console&amp;gt;:26: error: No TypeTag available for T
       def bar[T] = foo[T]
                       ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错, 对于不具体的类型(泛型), 就会报错了, 必须让T有一个边界才可以调用, 比如这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; def bar[T: TypeTag] = foo[T] // to the contrast T is concrete here
                                    // because it's bound by a concrete tag bound
bar: [T](implicit evidence$1: reflect.runtime.universe.TypeTag[T])reflect.runtime.universe.TypeTag[T]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但, 有时我们无法为泛型提供边界, 比如在本章的&lt;code&gt;Def Macros&lt;/code&gt;中, 这怎么办? 没关系, 杨总说过:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;任何计算机问题都可以通过加一层中间件解决.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以, Scala引入了一个新的概念 =&amp;gt; &lt;code&gt;WeakTypeTag[T]&lt;/code&gt;, 放在&lt;code&gt;TypeTag&lt;/code&gt;之上, 之后可以&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; def foo2[T] = weakTypeTag[T]
foo2: [T]=&amp;gt; reflect.runtime.universe.WeakTypeTag[T]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无须边界, 照样使用, 而&lt;code&gt;TypeTag&lt;/code&gt;就不行了.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; def foo[T] = typeTag[T]
&amp;lt;console&amp;gt;:15: error: No TypeTag available for T
       def foo[T] = typeTag[T]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有兴趣请看&lt;br/&gt;&lt;a href=&quot;https://docs.scala-lang.org/overviews/reflection/typetags-manifests.html&quot; class=&quot;uri&quot;&gt;https://docs.scala-lang.org/overviews/reflection/typetags-manifests.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;apply&quot;&gt;Apply&lt;/h3&gt;
&lt;p&gt;在前面的例子中, 我们多次看到了&lt;code&gt;Apply()&lt;/code&gt;, 这是做什么的呢?&lt;br/&gt;我们可以理解为这是一个AST构建函数, 比较好奇的我看了下源码, 搜打死乃.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ApplyExtractor{
    def apply(fun: Tree, args: List[Tree]): Apply = {
        ???
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着眼熟不? 没错, 和&lt;code&gt;Scala&lt;/code&gt; 的&lt;code&gt;List[+A]&lt;/code&gt;的构建函数类似, 一个延迟创建函数. 好了, 先理解到这.&lt;/p&gt;
&lt;h3 id=&quot;ident&quot;&gt;Ident&lt;/h3&gt;
&lt;p&gt;定义, 可以理解为Scala标识符的构建函数.&lt;/p&gt;
&lt;h3 id=&quot;literalconstanthello&quot;&gt;Literal(Constant(&quot;hello &quot;))&lt;/h3&gt;
&lt;p&gt;文字, 字符串构建函数&lt;/p&gt;
&lt;h3 id=&quot;select&quot;&gt;Select&lt;/h3&gt;
&lt;p&gt;选择构建函数, 选择的什么呢? 答案是一切, 不论是选择方法, 还是选择类. 我们可以理解为&lt;code&gt;.&lt;/code&gt;这个调用符. 举个例子吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scala&amp;gt; showRaw(q&quot;scala.Some.apply&quot;)
res2: String = Select(Select(Ident(TermName(&quot;scala&quot;)), TermName(&quot;Some&quot;)), TermName(&quot;apply&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有上面的例子:&lt;br/&gt;&lt;code&gt;&quot;hello &quot;.$plus(s.tree)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Apply(
    Select(
        Literal(Constant(&quot;hello &quot;)),
        TermName(&quot;$plus&quot;)
    ),
    List(
        s.tree
    )
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SelectExtractor {
    def apply(qualifier: Tree, name: Name): Select = {
        ???
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;termnameplus&quot;&gt;TermName(&quot;$plus&quot;)&lt;/h3&gt;
&lt;p&gt;理解&lt;code&gt;TermName&lt;/code&gt;之前, 我们先了解一下什么是&lt;code&gt;Names&lt;/code&gt;, &lt;code&gt;Names&lt;/code&gt;在官网解释是:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Names are simple wrappers for strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只是一个简单的字符串包装器, 也就是把字符串包装起来, &lt;code&gt;Names&lt;/code&gt;有两个子类, 分别是&lt;code&gt;TermName&lt;/code&gt; 和 &lt;code&gt;TypeName&lt;/code&gt;, 将一个字符串用两个子类包装起来, 就可以使用&lt;code&gt;Select&lt;/code&gt; 在tree中进行查找, 或者组装新的tree.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html&quot;&gt;官网地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;宏插值器&quot;&gt;宏插值器&lt;/h2&gt;
&lt;p&gt;刚刚就为了实现一个如此简单的功能, 就写了那么巨长的代码, 如果如此的话, 即便&lt;code&gt;Macros&lt;/code&gt; 功能强大, 也不易推广&lt;code&gt;Macros&lt;/code&gt;. 因此Scala又引入了一个新工具 =&amp;gt; &lt;code&gt;Quasiquotes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Quasiquotes&lt;/code&gt; 大大的简化了宏编写的难度, 并极大的提升了效率, 因为它让你感觉写宏就像写scala代码一样.&lt;/p&gt;
&lt;p&gt;同样上面的功能, &lt;code&gt;Quasiquotes&lt;/code&gt;实现如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;object Macros {
    def hello2[T](s: String): Unit = macro hello2Impl[T]

    def hello2Impl[T](c: blackbox.Context)(s: c.Expr[String])(ttag: c.WeakTypeTag[T]): c.Expr[Unit] = {
        import c.universe._
        val tree = q&quot;&quot;&quot;println(&quot;hello &quot; + ${s.tree} + &quot;!&quot;)&quot;&quot;&quot;
        
        c.Expr(tree)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;q&quot;&quot;&quot; ??? &quot;&quot;&quot;&lt;/code&gt; 就和 &lt;code&gt;s&quot;&quot;&quot; ??? &quot;&quot;&quot;&lt;/code&gt;, &lt;code&gt;r&quot;&quot;&quot; ??? &quot;&quot;&quot;&lt;/code&gt; 一样, 可以使用&lt;code&gt;$&lt;/code&gt;引用外部属性, 方便进行逻辑处理.&lt;/p&gt;
&lt;h2 id=&quot;macros-annotations&quot;&gt;Macros ANNOTATIONS&lt;/h2&gt;
&lt;p&gt;宏注释, 就和我们在Java一样, 下面是我写的一个例子:&lt;br/&gt;对于以&lt;code&gt;class&lt;/code&gt;修饰的类, 我们也像&lt;code&gt;case class&lt;/code&gt;修饰的类一样, 完善&lt;code&gt;toString()&lt;/code&gt;方法.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.pharbers.macros.common.connecting

import scala.reflect.macros.whitebox
import scala.language.experimental.macros
import scala.annotation.{StaticAnnotation, compileTimeOnly}

@compileTimeOnly(&quot;enable macro paradis to expand macro annotations&quot;)
final class ToStringMacro extends StaticAnnotation {
    def macroTransform(annottees: Any*): Any = macro ToStringMacro.impl
}

object ToStringMacro {
    def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
        import c.universe._

        val class_tree = annottees.map(_.tree).toList match {
            case q&quot;$mods class $tpname[..$tparams] $ctorMods(...$paramss) extends ..$parents { $self =&amp;gt; ..$stats }&quot; :: Nil =&amp;gt;

                val params = paramss.flatMap { params =&amp;gt;
                    val q&quot;..$trees&quot; = q&quot;..$params&quot;
                    trees
                }
                val fields = stats.flatMap { params =&amp;gt;
                    val q&quot;..$trees&quot; = q&quot;..$params&quot;
                    trees.map {
                        case q&quot;$mods def toString(): $tpt = $expr&quot; =&amp;gt; q&quot;&quot;
                        case x =&amp;gt; x
                    }.filter(_ != EmptyTree)
                }
                val total_fields = params ++ fields

                val toStringDefList = total_fields.map {
                    case q&quot;$mods val $tname: $tpt = $expr&quot; =&amp;gt; q&quot;&quot;&quot;${tname.toString} + &quot; = &quot; + $tname&quot;&quot;&quot;
                    case q&quot;$mods var $tname: $tpt = $expr&quot; =&amp;gt; q&quot;&quot;&quot;${tname.toString} + &quot; = &quot; + $tname&quot;&quot;&quot;
                    case _ =&amp;gt; q&quot;&quot;
                }.filter(_ != EmptyTree)
                val toStringBody = if(toStringDefList.isEmpty) q&quot;&quot;&quot; &quot;&quot; &quot;&quot;&quot; else toStringDefList.reduce { (a, b) =&amp;gt; q&quot;&quot;&quot;$a + &quot;, &quot; + $b&quot;&quot;&quot; }
                val toStringDef = q&quot;&quot;&quot;override def toString(): String = ${tpname.toString()} + &quot;(&quot; + $toStringBody + &quot;)&quot;&quot;&quot;&quot;

                q&quot;&quot;&quot;
                    $mods class $tpname[..$tparams] $ctorMods(...$paramss) extends ..$parents { $self =&amp;gt; ..$stats
                        $toStringDef
                    }
                &quot;&quot;&quot;

            case _ =&amp;gt; c.abort(c.enclosingPosition, &quot;Annotation @One2OneConn can be used only with class&quot;)
        }

        c.Expr[Any](class_tree)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;compiletimeonly&quot;&gt;compileTimeOnly&lt;/h3&gt;
&lt;p&gt;非强制的, 但建议加上. 官网解释如下:&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;It is not mandatory, but is recommended to avoid confusion. Macro annotations look like normal annotations to the vanilla Scala compiler, so if you forget to enable the macro paradise plugin in your build, your annotations will silently fail to expand. The @compileTimeOnly annotation makes sure that no reference to the underlying definition is present in the program code after typer, so it will prevent the aforementioned situation from happening.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;staticannotation&quot;&gt;StaticAnnotation&lt;/h3&gt;
&lt;p&gt;继承自&lt;code&gt;StaticAnnotation&lt;/code&gt;的类, 将被Scala解释器标记为注解类, 以注解的方式使用, 所以不建议直接生成实例, 加上&lt;code&gt;final&lt;/code&gt;修饰符.&lt;/p&gt;
&lt;h3 id=&quot;macrotransform&quot;&gt;macroTransform&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def macroTransform(annottees: Any*): Any = macro ToStringMacro.impl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于使用&lt;code&gt;@ToStringMacro&lt;/code&gt;修饰的代码, 编译器会自动调用&lt;code&gt;macroTransform&lt;/code&gt;方法, 该方法的入参, 是&lt;code&gt;annottees: Any*&lt;/code&gt;, 返回值是&lt;code&gt;Any&lt;/code&gt;, 主要是因为&lt;code&gt;Scala&lt;/code&gt;缺少更细致的描述, 所以使用这种笼统的方式描述可以接受一切类型参数.&lt;br/&gt;而方法的实现, 和&lt;code&gt;Def Macro&lt;/code&gt;一样.&lt;/p&gt;
&lt;h3 id=&quot;impl&quot;&gt;impl&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._
    ???
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了&lt;code&gt;Macros&lt;/code&gt;的具体实现了. 这里其实和&lt;code&gt;Def Macro&lt;/code&gt;也差不多. 但对于需要传递参数的宏注解, 需要按照下面的写法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final class One2OneConn[C](param_name: String) extends StaticAnnotation {
    def macroTransform(annottees: Any*): Any = macro One2OneConn.impl
}

object One2OneConn {
    def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
        import c.universe._
        
        // 匹配当前注解, 获得参数信息
        val (conn_type, conn_name) = c.prefix.tree match {
            case q&quot;new One2OneConn[$conn_type]($conn_name)&quot; =&amp;gt;
                (conn_type.toString, conn_name.toString.replace(&quot;\&quot;&quot;, &quot;&quot;))
            case _ =&amp;gt; c.abort(c.enclosingPosition, &quot;Annotation @One2OneConn must provide conn_type and conn_name !&quot;)
        }
        
        ???
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有几点需要注意的地方:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;宏注解只能操作当前自身注解, 和定义在当前注解之下的注解, 对于之前的注解, 因为已经展开, 所以已经不能操作了.&lt;/li&gt;
&lt;li&gt;如果宏注解生成多个结果, 例如既要展开注解标识的类, 还要直接生成类实例, 则返回结果需要以块(Block)包起来.&lt;/li&gt;
&lt;li&gt;宏注释必须使用白盒宏.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;macro-paradise&quot;&gt;Macro Paradise&lt;/h2&gt;
&lt;p&gt;Scala 推出了一款插件, 叫做Macro Paradise(宏天堂), 可以帮助开发者控制带有宏的Scala代码编译顺序, 同时还提供调试功能, 这里不做过多介绍, 有兴趣的可以查看官网: &lt;a href=&quot;https://docs.scala-lang.org/overviews/macros/paradise.html&quot;&gt;Macro Paradise&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 05:40:00 +0000</pubDate>
<dc:creator>旻天clock</dc:creator>
<og:description>前情回顾 上一节, 我简单的说了一下反射的基本概念以及运行时反射的用法, 同时简单的介绍了一下编译原理知识, 其中我感觉最为 的地方, 就属泛型的几种使用方式了. 而最抽象的概念, 就是对于符号和抽象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clockq/p/9661639.html</dc:identifier>
</item>
</channel>
</rss>