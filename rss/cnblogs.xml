<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于React-Native0.55.4的语音识别项目全栈方案 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9841068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9841068.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;移动端的&lt;code&gt;API&lt;/code&gt;能力验证方案与PC端不一样！不一样！！不一样！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使需要使用的&lt;code&gt;API&lt;/code&gt;都存在，也不一定能用，这一点和PC端是有很大区别的，国内的手机系统虽然都是基于&lt;code&gt;Android&lt;/code&gt;,但几乎都会经过各大厂商的定制，功能与原版&lt;code&gt;Android&lt;/code&gt;系统并不是完全一致的，在考察技术方案的时候一定要确认用&lt;code&gt;demo&lt;/code&gt;把功能跑起来才可以，别问我怎么知道的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-移动端直接访问web应用&quot;&gt;一. 移动端直接访问Web应用？&lt;/h2&gt;
&lt;p&gt;PC端基于&lt;code&gt;Web API&lt;/code&gt;的语音识别方案可参考&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9557355.html&quot;&gt;《【Recorder.js+百度语音识别】全栈方案技术细节》&lt;/a&gt;一文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 调用&lt;code&gt;Web API&lt;/code&gt;的多媒体采集接口需要特定的域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Web API&lt;/code&gt;的多媒体接口是&lt;strong&gt;WebRTC&lt;/strong&gt;技术在PC端的实现，由于多媒体采集涉及到用户隐私，所以在浏览器端调用这个接口需要在安全的域下才能被调起，安全的域是指以下三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;file:///&lt;/code&gt;本地域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://localhost&lt;/code&gt;本地web服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https://&lt;/code&gt;安全域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前两类一般用于桌面应用和本地调试，实际网站上线部署需要以&lt;code&gt;https&lt;/code&gt;方式部署，如何部署&lt;code&gt;https&lt;/code&gt;及申请免费的CA证书等网上有很多文章讲解，本文不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 手机浏览器几乎都不直接支持&lt;code&gt;WebRTC&lt;/code&gt; 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将PC端的Web应用以&lt;code&gt;https&lt;/code&gt;方式部署好之后，从手机浏览器直接访问时无法唤起录音接口权限认证，&lt;code&gt;navigator.getUserMedia( )&lt;/code&gt;方法一只返回&lt;code&gt;permissionDenied&lt;/code&gt;错误，无论是在&lt;strong&gt;Android6.0&lt;/strong&gt;以下通过编辑&lt;code&gt;manifest.xml&lt;/code&gt;添加还是&lt;strong&gt;Android6.0&lt;/strong&gt;以上通过动态获取的方式取得&lt;code&gt;RECORD_AUDIO&lt;/code&gt;权限，网站都可以正常访问，相关的&lt;code&gt;Web API&lt;/code&gt;接口也都存在，但即使获得用户授权后也无法调起录音功能。笔者测试了&lt;em&gt;UC浏览器&lt;/em&gt;，&lt;em&gt;百度移动浏览器&lt;/em&gt;和&lt;em&gt;Android6.0(API23)自带的浏览器&lt;/em&gt;，&lt;em&gt;Android8.0(API26)自带的浏览器&lt;/em&gt;,结果是都不支持。&lt;/p&gt;
&lt;h2 id=&quot;二.-方案调研和新的坑&quot;&gt;二. 方案调研和新的坑&lt;/h2&gt;
&lt;p&gt;o(￣▽￣)d 既然从移动端直接访问Web应用时无法调起录音接口，至少是无法兼容很多系统和机型，如果不考虑直接原生开发Android的话，只有寄希望于Hybrid的方案了。&lt;/p&gt;
&lt;h3 id=&quot;webview&quot;&gt;2.1 WebView&lt;/h3&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在一个app中单页面全屏放置一个WebView组件，然后加载https方式部署的web应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;理由&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;手机浏览器无法支持的情况下，只能寄希望于&lt;code&gt;WebView&lt;/code&gt;。&lt;code&gt;WebView&lt;/code&gt;是Android底层用于加载网页的组件，Android4.4版本以后已将内置的浏览器引擎更换为chromium，也就是chrome的内核，从&lt;strong&gt;Can I Use&lt;/strong&gt;上查询的支持度是Android5.0以上的版本的&lt;code&gt;WebView&lt;/code&gt;都是支持&lt;code&gt;WebRTC&lt;/code&gt;接口的&lt;code&gt;getUserMedia( )&lt;/code&gt;方法的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;应用编译目标版本为&lt;code&gt;API23&lt;/code&gt;，在支持&lt;code&gt;API23&lt;/code&gt;（Android6.0）的虚拟机和真机中测试，均无法通过&lt;code&gt;WebAPI&lt;/code&gt;接口调起麦克风进行录音。在支持&lt;code&gt;API26&lt;/code&gt;（Android8.0）版本的虚拟机中，功能均可实现。最终在&lt;strong&gt;Can I Use&lt;/strong&gt;中对于&lt;code&gt;getUserMedia( )&lt;/code&gt;方法支持度的统计信息的备注中，发现已知问题中在写明了：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/22/da8ab992c897c52327d35c7e00d3164c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单地说就是这个方法在&lt;code&gt;Android webview&lt;/code&gt;，&lt;code&gt;iOS&lt;/code&gt;和&lt;code&gt;PWA&lt;/code&gt; 基本都用不了。建议以后开发中可能用到一些不常用的API时完整地看一下相关信息。&lt;/p&gt;
&lt;h3 id=&quot;crosswalk&quot;&gt;2.2 crosswalk&lt;/h3&gt;
&lt;ul readability=&quot;5.3629568106312&quot;&gt;&lt;li readability=&quot;1.7235023041475&quot;&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;官方网址：&lt;a href=&quot;https://crosswalk-project.org/&quot; class=&quot;uri&quot;&gt;https://crosswalk-project.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;crosswalk&lt;/code&gt;，在进行app打包时，将&lt;code&gt;webview&lt;/code&gt;内核替换为&lt;code&gt;xwalk&lt;/code&gt;(crosswalk开发的基于chromium的浏览器内核)，以扩展原生&lt;code&gt;webview&lt;/code&gt;的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;理由&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;既然原生&lt;code&gt;webview&lt;/code&gt;功能被阉割，那么可以利用这个小型黑科技来把一个功能更强大的浏览器内核跟自己的应用打包在一起，笔者3年前在&lt;code&gt;cordova&lt;/code&gt;2.0-3.0版本流行的年代使用过这个技术，好处是的确可以扩展&lt;code&gt;webview&lt;/code&gt;的能力无疑，不好的地方在于app项目会直接增大80-90Mb的体积，当然通过几个版本的迭代，现在crosswalk可以针对手机内核类型生成不同的包，app体积增量大约在20Mb，基本属于可接受范围。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;遗憾地是这个项目一年前已经停止维护了，最后一版的官方脚手架工具也无法初始化新的工程，间接使用的方式分为两种，第一，下载&lt;code&gt;crosswalk&lt;/code&gt;的包，手动在&lt;code&gt;android&lt;/code&gt;工程中替换原生&lt;code&gt;WebView&lt;/code&gt;，对Hybrid开发者来说难度较大且与hybrid技术兼容性不可控；另一种方案在下一小节说明。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不建议使用，有那个精力真不如去研究一下可靠的hybrid方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cordovaionic&quot;&gt;2.3 Cordova/ionic&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/22/cc82171e8d3daf83273bdb0e5b715ac1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;8.3856107660455&quot;&gt;&lt;li readability=&quot;3.8219178082192&quot;&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;官方网址：&lt;a href=&quot;https://cordova.apache.org/&quot; class=&quot;uri&quot;&gt;https://cordova.apache.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codova&lt;/code&gt;是一个很流行的hybrid方案，现在已经升级到8.0.0版本，它本身就是一个将web应用打包为app的解决方案。&lt;code&gt;cordova&lt;/code&gt;的基本原理是将一般&lt;code&gt;UI&lt;/code&gt;层操作和功能放在&lt;code&gt;WebView&lt;/code&gt;里实现，需要调用移动设备硬件或原生接口时，均通过添加&lt;code&gt;cordova&lt;/code&gt;插件的形式来实现，每一个&lt;code&gt;cordova&lt;/code&gt;版本都会横跨支持若干个&lt;code&gt;Android&lt;/code&gt;版本，例如新的&lt;code&gt;cordova7.0.0&lt;/code&gt;在官方文档的说明中是支持android从4.4到8.1版本的，笔者认为非常适合小型hybrid开发团队使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;理由&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;值得一提的是&lt;code&gt;cordova&lt;/code&gt;拥有一个非常流行的移动端开发×××&lt;code&gt;ionic&lt;/code&gt;,现在已经迭代至&lt;code&gt;4.0&lt;/code&gt;阶段，这个技术笔者是有特殊感情的，当年&lt;code&gt;ionic&lt;/code&gt;还在&lt;code&gt;alpha&lt;/code&gt;版本的时候，笔者就在使用了，它是基于&lt;strong&gt;cordova+angular&lt;/strong&gt;这个技术组合的，拥有清新且设计感极强的UI组件，非常值得尝试。另外，&lt;code&gt;cordova&lt;/code&gt;是拥有&lt;code&gt;crosswalk&lt;/code&gt;插件的，可以直接以插件的形式，在&lt;code&gt;cordova&lt;/code&gt;项目打包时加入&lt;code&gt;crosswalk&lt;/code&gt;，有相关需求的读者可以以一试，尤其是团队里没有Android开发人员也没有专门的设计人员的时候，&lt;code&gt;ionic&lt;/code&gt;出品的应用一定会让别人对你另眼相看。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;笔者曾在使用&lt;code&gt;cordova&lt;/code&gt;3.3的时候就融入过&lt;code&gt;crosswalk&lt;/code&gt;，也通过&lt;code&gt;cordova&lt;/code&gt;插件成功调用过底层的&lt;code&gt;GPS&lt;/code&gt;，&lt;code&gt;摄像头&lt;/code&gt;及其他一些原生组件，当时是为了适配Android4.4版本。&lt;code&gt;cordova7.0.0&lt;/code&gt;的脚手架经测试在国内是可以使用的，新建的工程无论是通过自带命令行还是import进Android Studio来进行开发都可以打包为对应的工程，官方文档有很详细的调用各种底层接口的说明，网上也有&lt;code&gt;cordova7.0.0+crosswalk&lt;/code&gt;方案对应的技术贴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;笔者由于技术协议中指定技术栈的缘故，无法中途替换解决方案，故本次未进行测试。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可考虑作为整体解决方案进行尝试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;react-native&quot;&gt;2.4 React-Native&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/22/f2cef2861288dde6aa03d713907322dc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.900247320692&quot;&gt;&lt;li readability=&quot;8.8359569179785&quot;&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;官方网址：&lt;a href=&quot;https://reactnative.cn/&quot; class=&quot;uri&quot;&gt;https://reactnative.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是笔者本次使用的方案，由于web端采用&lt;code&gt;React&lt;/code&gt;技术栈完成的缘故，为了不增加团队小伙伴的学习成本，移动端就选用了&lt;code&gt;React-Native&lt;/code&gt;的方案。这个方案既可以按照混合开发的方式来进行，也可以按照单个&lt;code&gt;WebView&lt;/code&gt;的方式来进行(已验证这种方案无法支持&lt;code&gt;WebRTC&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;可能很多人已经听说去年&lt;code&gt;Airbnb&lt;/code&gt;公开宣布不再继续使用&lt;code&gt;React-Native&lt;/code&gt;作为移动端解决方案并做了详细的解释，当时也是很多人鼓吹说&lt;code&gt;React-Native&lt;/code&gt;要凉凉了。实际上&lt;code&gt;Airbnb&lt;/code&gt;在声明中说的很清楚，&lt;code&gt;React-Native&lt;/code&gt;是非常好的hybrid解决方案，他们所遇到的问题是当性能和用户体验优化到一定程度时，在hybrid技术的维护和开发上投入的人力过多了，整个项目的前端人员不仅有Web前端，还有高级的&lt;code&gt;Android&lt;/code&gt;和&lt;code&gt;IOS&lt;/code&gt;人员来保障hybrid项目的推进，他们认为这样的人力成本相比于原生开发而言要高很多，所以更换了方案。听明白了吗？所以作为软件技术比国外落后不知道多少年的天朝码农，考虑实际的项目需求，尽管放心大胆地用就好了，跟风真的没什么价值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;理由&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;热门的hybrid解决方案，和Web前端三驾马车之一的&lt;code&gt;React&lt;/code&gt;属同门，语法和组件结构相似度高，社区活跃且周边生态较好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;React-native&lt;/code&gt;已经发布&lt;code&gt;0.57.3&lt;/code&gt;版本，但经测试&lt;code&gt;0.55.4&lt;/code&gt;在国内属于可正常新建工程的版本(使用&lt;code&gt;react-native init XXX&lt;/code&gt;命令创建的工程)，&lt;code&gt;0.56&lt;/code&gt;大版本中发布的两个小版本均在初始打包时报错，命令行的提示链接到一个已知issue，但可惜照做以后也未能打包成功，&lt;code&gt;0.57&lt;/code&gt;默认的Android-SDK是&lt;code&gt;API27&lt;/code&gt;，也就是Android8.1，对于经验不足的开发者来说（比如我自己），太新的版本也不建议使用，除非你的项目是在指定机器上运行的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;React-native&lt;/code&gt;也封装了&lt;code&gt;WebView&lt;/code&gt;组件，但很遗憾，直接加载web应用的方式经测试也无法调起&lt;code&gt;getUserMedia( )&lt;/code&gt;这个方法，所以&lt;strong&gt;最终只能通过混合开发的方案来实现&lt;/strong&gt;（但回过头来想，跟通过&lt;code&gt;WebView&lt;/code&gt;来调用硬件接口相比，其实这种实现方式反而更符合逻辑）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建议未掌握多语言混合开发能力的hybrid开发者尽可能选用热门方案，理由很简单，所有的前端项目都有坑，但热门项目出了问题可以找大牛咨询。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code&gt;WebRTC&lt;/code&gt;技术录音相关的&lt;code&gt;navigator.getUserMedia&lt;/code&gt;,&lt;code&gt;navigator.mediaDevices.getUserMedia&lt;/code&gt;,&lt;code&gt;AudioContext&lt;/code&gt;这上面这几个方案中都是存在的，但事实是都没能在&lt;code&gt;webview&lt;/code&gt;中调起麦克风进行录音。&lt;/p&gt;
&lt;p&gt;当然&lt;code&gt;WebRTC&lt;/code&gt;作为独立的标准和技术，也是可以融入Android工程的，但从前端开发者的角度来说这条路就有点跑偏了，执着于&lt;code&gt;WebRTC&lt;/code&gt;或者团队里有原生开发者的小伙伴可以研究一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三.-react-native方案的整体架构&quot;&gt;三. React-Native方案的整体架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/22/4e3dbb6943f89f5b041b4e9dcb167ba1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上只要多复用现成的组件，加上适量的定制，尽可能不使用一些奇技淫巧，产品的流畅度基本区分不出来是否是Hybrid开发还是Native开发，当然跟笔者的项目体量不是很大也有一定关系。&lt;/p&gt;
&lt;h2 id=&quot;四.-使用插件清单&quot;&gt;四. 使用插件清单&lt;/h2&gt;
&lt;ul readability=&quot;7.279958677686&quot;&gt;&lt;li readability=&quot;0.56190476190476&quot;&gt;
&lt;p&gt;&lt;code&gt;react-native-audio&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/jsierles/react-native-audio&quot; class=&quot;uri&quot;&gt;https://github.com/jsierles/react-native-audio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;调用麦克风采集音频。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.621359223301&quot;&gt;
&lt;p&gt;&lt;code&gt;rn-fetch-blob&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/joltup/rn-fetch-blob&quot; class=&quot;uri&quot;&gt;https://github.com/joltup/rn-fetch-blob&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在RN中从native层通过原生线程直接发送大体积二进制数据或文件，通过Bridge对象从Web发请求会造成性能问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.76973684210526&quot;&gt;
&lt;p&gt;&lt;code&gt;Multer&lt;/code&gt;模块&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/expressjs/multer&quot; class=&quot;uri&quot;&gt;https://github.com/expressjs/multer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Express&lt;/code&gt;服务端中间件，用于接收客户端发送的大体积二进制数据或文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.793893129771&quot;&gt;
&lt;p&gt;&lt;code&gt;FFmpeg&lt;/code&gt;工具&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://ffmpeg.org/&quot; class=&quot;uri&quot;&gt;http://ffmpeg.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多媒体格式转换库。手机端采集编码的格式无法被百度语音识别接口直接识别，需要先进行重编码。&lt;code&gt;node.js&lt;/code&gt;开发者通过&lt;code&gt;child_process&lt;/code&gt;模块直接从代码中唤起命令行执行即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.6066945606695&quot;&gt;
&lt;p&gt;&lt;code&gt;docxtemplater&lt;/code&gt;模块&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://docxtemplater.readthedocs.io/en/latest/&quot; class=&quot;uri&quot;&gt;https://docxtemplater.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.js&lt;/code&gt;模块语音识别结果需要在后台生成&lt;code&gt;docx&lt;/code&gt;格式的文件（word文档），可使用这个模块，使用方法和模板渲染引擎基本一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五.-rn开发细节和遇到的坑&quot;&gt;五. RN开发细节和遇到的坑&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;真机调试时，需要摇晃手机，在配置菜单中填写&lt;strong&gt;内网IP+端口号&lt;/strong&gt;，否则会直接红屏报错。&lt;/li&gt;
&lt;li&gt;真机调试时，需要在设置中开启应用的&lt;code&gt;悬浮框&lt;/code&gt;权限，否则可能白屏什么都不显示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebRTC&lt;/code&gt;在&lt;code&gt;Android WebView&lt;/code&gt;兼容性不好，&lt;code&gt;IOS&lt;/code&gt;内置浏览器不支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;react-native-audio&lt;/code&gt;进行录音时，每一次调用&lt;code&gt;Stop&lt;/code&gt;之后，若要再次启动录音功能，必须先调用&lt;code&gt;AudioRecorder.prepareRecordingAtPath( )&lt;/code&gt;方法重新初始化，否则会红屏报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WebView&lt;/code&gt;组件必须设置&lt;code&gt;ref={(webview)=&amp;gt;{this.webview = webview}}&lt;/code&gt;,否则&lt;code&gt;onMessage&lt;/code&gt;属性无法监听到来自&lt;code&gt;WebView&lt;/code&gt;加载网页通过&lt;code&gt;window.postMessage&lt;/code&gt;发来的消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TouchableHighlight&lt;/code&gt;组件必须先设置&lt;code&gt;onPress&lt;/code&gt;属性的回调函数（可以为空函数），否则触摸变色的响应属性&lt;code&gt;UnderlayColor&lt;/code&gt;无法生效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modal&lt;/code&gt;组件在一个自定义组件中只能有一个（如果有多个必须通过条件判断只实例化一个），否则即使未显示的&lt;code&gt;Modal&lt;/code&gt;组件的&lt;code&gt;Visible&lt;/code&gt;属性设置为&lt;code&gt;false&lt;/code&gt;，其实例方法也会和另一个&lt;code&gt;Modal&lt;/code&gt;组件发生重叠覆盖，可能出现的现象就是显示了第一个&lt;code&gt;Modal&lt;/code&gt;的界面，却执行了第二个&lt;code&gt;Modal&lt;/code&gt;的同名方法。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 23 Oct 2018 23:16:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>移动端的 能力验证方案与PC端不一样！不一样！！不一样！！！ 即使需要使用的 都存在，也不一定能用，这一点和PC端是有很大区别的，国内的手机系统虽然都是基于 ,但几乎都会经过各大厂商的定制，功能与原版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9841068.html</dc:identifier>
</item>
<item>
<title>dubbo源码(章节二) -- dubbo的Ioc - Europa_Universalis</title>
<link>http://www.cnblogs.com/EuropaUniversalis/p/9833151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EuropaUniversalis/p/9833151.html</guid>
<description>&lt;p&gt;上一篇主要分析了extensionLoader的获取，以及获取extension的第一种方式，即通过装饰类或者动态代理的方式，今天我们首先从获取extension的第二种方式说起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Find the extension with the given name.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
getExtension(String name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;下面讨论getExtension(String name)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从这个方法的代码跟踪开始，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getExtension(String name) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 　　Holder&amp;lt;Object&amp;gt; holder =&lt;span&gt; cachedInstances.get(name);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 　　......&lt;br/&gt;4 　　Object instance =&lt;span&gt; holder.get();
&lt;/span&gt;5 　　......   &lt;br/&gt;6 　　instance =&lt;span&gt; createExtension(name);&lt;br/&gt;&lt;/span&gt;7 　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) instance;
&lt;/span&gt;8 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里省略了比较多的内容，有了前面一篇跟踪代码的经验，缓存的具体使用就不再贴出来了，我们只看主要逻辑即可，跟进去看createExtension(name)，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T createExtension(String name) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; getExtensionClasses().get(name);&lt;/span&gt;&lt;span&gt; &lt;br/&gt;3&lt;/span&gt; 　　T instance =&lt;span&gt; clazz.newInstance();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;              &lt;br/&gt;5 　　&lt;span&gt;injectExtension(instance);
&lt;/span&gt; 6 　　Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses =&lt;span&gt; cachedWrapperClasses;&lt;/span&gt; &lt;br/&gt;7 　　&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; wrapperClass : wrapperClasses) {
&lt;/span&gt; 8 　　　　instance =&lt;span&gt; &lt;br/&gt;9 　　　　injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
&lt;/span&gt;10 　　&lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;&lt;/span&gt; &lt;br/&gt;12 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里先是通过getExtensionClasses().get(name)拿到一个class对象，getExtensionClasses()方法上一篇说过了，它最终所赋值的是type扩展的所有实现中，既没有@Adaptive注解，也不包含type类型的构造器(这一类扩展实现我们称之为包装类)的那些实现类，并且被缓存在cachedClasses map中，map的key即为实现类在dubbo spi配置文件中的类名，这里提一个细节，如果在cachedClasses中没有拿到key为name对应的value，这里就会抛出异常，那也就是说，getExtension(name)这种方式，只能用来获取既非@Adaptive注解，又非包装类的那些类的实现，因为只有这样的类才会被缓存在cachedClasses中。这里拿到这个类并实例化一个Instance，然后调用了方法injectExtension(instance)，这个方法看名字就知道了，inject既就是注射的意思，这里就将实现dubbo的依赖注入，现在来看这个方法的实现，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T injectExtension(T instance) {&lt;/span&gt;&lt;span&gt; &lt;br/&gt;2&lt;/span&gt; 　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : instance.getClass().getMethods()) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　　　&lt;span&gt;if&lt;/span&gt; (method.getName().startsWith(&quot;set&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　　　　　　　&amp;amp;&amp;amp; method.getParameterTypes().length == 1
&lt;span&gt; 5&lt;/span&gt; 　　　　　　　　&amp;amp;&amp;amp;&lt;span&gt; Modifier.isPublic(method.getModifiers())) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　　　　　Class&amp;lt;?&amp;gt; pt = method.getParameterTypes()[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                          &lt;br/&gt;8 　　　　　　String property = method.getName().length() &amp;gt; 3 ? &lt;br/&gt;9 　　　　　　　　method.getName().substring(3, 4).toLowerCase() + &lt;br/&gt;10 　　　　　　　　method.getName().substring(4) : &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 　　　　　　Object object =&lt;span&gt; objectFactory.getExtension(pt, property);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 　　　　　　&lt;span&gt;method.invoke(instance, object);&lt;br/&gt;&lt;/span&gt;13 　　　　&lt;span&gt;}&lt;br/&gt;&lt;/span&gt;14 　　}&lt;br/&gt;&lt;span&gt;&lt;span&gt;15&lt;/span&gt; 　　return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;16 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把这个class的所有方法都提取出来，然后做了一系列的判断，这就是要通过setter方法为对象注入属性了。被注入的object是通过objectFactory.getExtension(...)得到的，回忆一下上一篇说过，每个extension对象都会有一个objectFactory，objectFactory就是一个AdaptiveExtensionFactory，它的作用是：为dubbo的Ioc提供所有对象。所以这里我们看到，setter方法要注入的属性值，是通过这个扩展的objectFactory拿到的，我们跟进去看一下它的实现，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getExtension(Class&amp;lt;T&amp;gt;&lt;span&gt; type, String name) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ExtensionFactory factory : factories) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 　　　　T extension =&lt;span&gt; factory.getExtension(type, name);&lt;br/&gt;&lt;/span&gt;4 　　　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; extension;&lt;br/&gt;&lt;/span&gt;5 　　}&lt;br/&gt;6 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会遍历factories，每个元素都是ExtensionFactory的一个非Adaptive实现，我们在上一篇已经看到了，ExtensionFactory的非Adpative实现，最终被放入factories中的，是SpiExtensionFactory，不过实际上在另外的包里还有一个ExtensionFactory的非Adaptive实现类：SpringExtensionFactory，这里我们不妨把SpiExtensionFactory和SpringExtensionFactory同时拿来分析，可以看到只要这里getExtension(type，name)返回非空，就直接返回所获取的这个值，我们依次看下这两个实现分别是怎么做的，先看SpiExtensionFactory：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getExtension(Class&amp;lt;T&amp;gt;&lt;span&gt; type, String name) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 　　&lt;span&gt;if&lt;/span&gt; (type.isInterface() &amp;amp;&amp;amp; type.isAnnotationPresent(SPI.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 　　　　ExtensionLoader&amp;lt;T&amp;gt; loader =&lt;span&gt; ExtensionLoader.getExtensionLoader(type);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 　　　　&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;loader.getSupportedExtensions().isEmpty()) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 　　　　　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loader.getAdaptiveExtension();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 　　　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 　　&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里判断type是不是@SPI标注的注解，如果是，说明这个type是一个dubbo spi扩展，那么就返回它的一个AdaptiveExtension，它为什么叫SpiExtensionFactory呢？就是获取Spi扩展的一个factory，获取spi扩展的adaptive实现的做法在上一篇里已经讨论过了。也就是说，如果一个扩展实现类中需要注入另一个spi扩展的实现，那就是通过它的objectFactory里的SpiExtensionFactory来获取需要注入的这个扩展的Adaptive实现。&lt;/p&gt;
&lt;p&gt;那么如果要注入的对象不是dubbo spi扩展呢，这里不会进入if，就会返回null，我们接下来看SpringExtensionFactory，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getExtension(Class&amp;lt;T&amp;gt;&lt;span&gt; type, String name) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ApplicationContext context : contexts) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　　　&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.containsBean(name)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　　　　　Object bean =&lt;span&gt; context.getBean(name);&lt;/span&gt;&lt;span&gt; &lt;br/&gt;5&lt;/span&gt; 　　　　　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) bean;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;6&lt;/span&gt; 　　　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
 9 　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ApplicationContext context : contexts) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 　　　　&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context.getBean(type);&lt;br/&gt;&lt;/span&gt;11 　　&lt;span&gt;}&lt;/span&gt;
12 　　&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SpringExtensionFactory就很简单了，直接从spring的ApplicationContext中尝试获取bean，先尝试通过name获取，如果by name失败，再尝试通过by type来获取。也就是说，如果一个扩展实现类中需要注入一个普通对象(非Spi注解的dubbo扩展)，那就通过它的objectFactory里的SpringExtensionFactory来获取这个要被注入的类对象，当然前提是spring容器中已经注入了这个对象。&lt;/p&gt;
&lt;p&gt;ok，通过objectFactory提供的对象，我们完成了extension属性的注入，不过createExtension方法所做的并不止这些，我们回到injectExtension的调用处，即createExtension方法的第五行，接着往下看，代码第六行获取了缓存cachedWrapperClasses，上一篇讲了，这个变量缓存了所有非@Adaptive注解同时包含了带有本扩展类型的构造器方法的那些扩展实现类。实际上从这个缓存的名字里就能看出来，Wrapper意指包装，就是说这里所包含的类都是包装类。为了解释这行代码，这里必须举一个例子：我们看接口Protocol，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@SPI(&quot;dubbo&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Protocol{
　　......  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个@Spi注解的dubbo扩展接口，考虑它的三个实现，MockProtocol，ProtocolFilterWrapper，ProtocolListenerWrapper，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MockProtocol &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Protocol {
　　@Override
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort() {
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt; 0&lt;span&gt;;
　　}
　　......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProtocolFilterWrapper &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Protocol {
&lt;/span&gt;&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Protocol protocol;

&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; ProtocolFilterWrapper(Protocol protocol) {
&lt;/span&gt;&lt;span&gt;　　　　if&lt;/span&gt; (protocol == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;　　　　　　throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(......&lt;span&gt;);
　　　　}
&lt;/span&gt;&lt;span&gt;　　　　this&lt;/span&gt;.protocol =&lt;span&gt; protocol;
　　}
　　@Override
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort() {
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt;&lt;span&gt; protocol.getDefaultPort();
　　}&lt;br/&gt;　　......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProtocolListenerWrapper &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Protocol {
&lt;/span&gt;&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Protocol protocol;

&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt;&lt;span&gt; ProtocolListenerWrapper(Protocol protocol) {
&lt;/span&gt;&lt;span&gt;　　　　if&lt;/span&gt; (protocol == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;　　　　　　throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(......&lt;span&gt;);
　　　　}
&lt;/span&gt;&lt;span&gt;　　　　this&lt;/span&gt;.protocol =&lt;span&gt; protocol;
　　}
　　@Override
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort() {
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt;&lt;span&gt; protocol.getDefaultPort();
　　}&lt;br/&gt;　　...... 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这三个类都没有被@Adaptive注解，其中ProtocolFilterWrapper，ProtocolListenerWrapper都有一个私有属性Protocol，同时有一个Protocol类型作为入参的构造器，所以在类加载之后，这两个类都会被放入cachedWrapperClasses缓存中，而MockProtocol则既不被@Adaptive注解，也不包含Protocol作为入参的构造器，它在类加载之后会被放入cachedClasses中，所以它是可以被通过第二种获取扩展对象的方式获取的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExtensionLoader.getExtensionLoader(Protocol.&lt;span&gt;class&lt;/span&gt;).getExtension(&quot;mock&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&quot;mock&quot;为dubbo spi配置文件中该类的name。&lt;/p&gt;
&lt;p&gt;ok，当MockProtocol被注入了属性之后，代码获取了cachedWrapperClasses的值，然后依次取出其中缓存的类，初始化它们，并将当前protocol作为参数传入构造器，同时将返回的protocol赋值给当前instance。所以，如果cachedWrapperClasses中的顺序是：ProtocolFilterWrapper，ProtocolListenerWrapper，那么执行完上述代码之后，在createExtension方法的最后一行，我们最终获取到的instance将不再是MockProtocol的实例，而是ProtocolListenerWrapper的实例，它里面拥有一个protocol属性，此protocol将会是ProtocolFilterWrapper的实例，而它里面还是拥有一个protocol属性，这个protocol才是我们一开始就拿到的MockProtocol的实例。如下所示；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
instance(ProtocolListenerWrapper@947&lt;span&gt;)
    &lt;/span&gt;--&amp;gt;protocol(ProtocolFilterWrapper@950&lt;span&gt;)
        &lt;/span&gt;--&amp;gt;protocol(MockProtocol@874)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这，想必大家就明白了为什么这一类的实现类，会被称为包装类了吧。如果调用instance的方法，例如代码中贴出来的getDefaultPort()，就将从包装的最外层开始向内调用。&lt;/p&gt;
&lt;p&gt;ok，这一篇我们分析了dubbo获取扩展实现的第二种方式，同时分析了dubbo Ioc的原理，总结下dubbo的spi：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要获取dubbo spi接口的实现，就要先获取对应的ExtensionLoader，而通过loader获取实现的方式有两种。&lt;/li&gt;
&lt;li&gt;getExtensionClasses()方法会加载配置文件中配置的该接口的所有实现，并赋值给相应的缓存：
&lt;ul&gt;&lt;li&gt;接口的所有实现中，要么存在唯一的一个类被@Adaptive注解，要么就动态生成一个Adaptive代理类。这个类被缓存在cachedAdaptiveClass中，我们称之为第一种实现类。&lt;/li&gt;
&lt;li&gt;接口的所有实现中，如果存在一些实现，没有被@Adaptive注解，但是包含一个以该接口类型为参数的构造器，称这种类为第二种实现类或包装类，它们被缓存在cachedWrapperClasses中。&lt;/li&gt;
&lt;li&gt;剩下的实现类，既不被@Adaptive注解，也不包含特殊的构造器，我们称之为第三种实现类，它们被缓存在cachedClasses中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;getAdaptiveExtension()方法将获得扩展接口的装饰模式的实现类，这个类有且只有一个。&lt;/li&gt;
&lt;li&gt;getExtension(name)方法根据配置文件中的类的name来获取扩展实现类，只有第三种实现类能通过这种方式被获取，但是如果该接口有包装类存在，那么此方法获取的永远是被包装的类。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 23 Oct 2018 18:15:00 +0000</pubDate>
<dc:creator>Europa_Universalis</dc:creator>
<og:description>上一篇主要分析了extensionLoader的获取，以及获取extension的第一种方式，即通过装饰类或者动态代理的方式，今天我们首先从获取extension的第二种方式说起。 下面讨论getEx</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EuropaUniversalis/p/9833151.html</dc:identifier>
</item>
<item>
<title>音频算法之我思 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/9840603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/9840603.html</guid>
<description>&lt;p&gt;很长一段时间，扎根在音频领域，各种玩耍。&lt;/p&gt;
&lt;p&gt;渐渐上了轨道。&lt;/p&gt;
&lt;p&gt;一切的一切仅仅因为相信自己能做好，也必须做好。&lt;/p&gt;
&lt;p&gt;不懂就去查，去问，去找资料，去找视频。&lt;/p&gt;
&lt;p&gt;渐渐的，我开始懂了，也慢慢有了系统性的理解。&lt;/p&gt;
&lt;p&gt;随后经常能发散思维。&lt;/p&gt;
&lt;p&gt;最近，&lt;/p&gt;
&lt;p&gt;在自动增益，&lt;/p&gt;
&lt;p&gt;音频降噪，&lt;/p&gt;
&lt;p&gt;语速检测，&lt;/p&gt;
&lt;p&gt;相位谱重建各个算法之间穿梭。&lt;/p&gt;
&lt;p&gt;慢慢有所产出，有所突破。&lt;/p&gt;
&lt;p&gt;特别是在音频降噪领域，&lt;/p&gt;
&lt;p&gt;不能算质的飞跃，&lt;/p&gt;
&lt;p&gt;但是确实摸到了一些规律。&lt;/p&gt;
&lt;p&gt;而写完相位谱重建算法之后，&lt;/p&gt;
&lt;p&gt;我也突发奇想，&lt;/p&gt;
&lt;p&gt;相位谱既然能通过高斯分布的思路进行重建，&lt;/p&gt;
&lt;p&gt;那是不是可以说明，&lt;/p&gt;
&lt;p&gt;高斯分布可以用来作为音频算法的信号标准化，归一化。&lt;/p&gt;
&lt;p&gt;这是一个值得去研究的方向，&lt;/p&gt;
&lt;p&gt;音频信号的高斯归一化。&lt;/p&gt;
&lt;p&gt;前面面试了一家公司的时候，&lt;/p&gt;
&lt;p&gt;提到说音频通过能量谱可以重建相位谱，&lt;/p&gt;
&lt;p&gt;那面试官好像认定我是傻子，&lt;/p&gt;
&lt;p&gt;就好像觉得我是在胡扯一样。&lt;/p&gt;
&lt;p&gt;真的懒得解释，&lt;/p&gt;
&lt;p&gt;实操是验证真理的唯一标准。&lt;/p&gt;
&lt;p&gt;而语速检测，&lt;/p&gt;
&lt;p&gt;其实有点类似音乐的节拍检测，&lt;/p&gt;
&lt;p&gt;只不过一定要去除空白帧，&lt;/p&gt;
&lt;p&gt;因为空白从另一个角度来说，&lt;/p&gt;
&lt;p&gt;可以认为是停顿，或者说换气。&lt;/p&gt;
&lt;p&gt;所以语速检测的思路也可以基本确认。&lt;/p&gt;
&lt;p&gt;而自动增益方面，&lt;/p&gt;
&lt;p&gt;找资料的时候发现一个神奇的标准，EBU R128，&lt;/p&gt;
&lt;p&gt;这里就不科普展开了，感兴趣的可以维基一下。&lt;/p&gt;
&lt;p&gt;这个算法在FFMPEG里面有很详细的实现，&lt;/p&gt;
&lt;p&gt;抠出来算法代码，直接应用，&lt;/p&gt;
&lt;p&gt;效果不要太好。&lt;/p&gt;
&lt;p&gt;近期，终于回到广东，&lt;/p&gt;
&lt;p&gt;在南京接受了太多的负能量，回来之后真的有获得新生的感觉。&lt;/p&gt;
&lt;p&gt;世界顿时和平。&lt;/p&gt;
&lt;p&gt;相对于深度学习而言，&lt;/p&gt;
&lt;p&gt;我还是比较坚持采用传统算法去实现降噪增益等处理，&lt;/p&gt;
&lt;p&gt;原因也很简单，音频时效性特别重要。&lt;/p&gt;
&lt;p&gt;采用深度学习很多时候要做大量的工作才能保证时效性了，&lt;/p&gt;
&lt;p&gt;从软件，硬件的角度来说，音频不比图像好处理。&lt;/p&gt;
&lt;p&gt;自然挑战也多了起来，&lt;/p&gt;
&lt;p&gt;不过庆幸的是，&lt;/p&gt;
&lt;p&gt;在傻逼一样的坚持之后，&lt;/p&gt;
&lt;p&gt;不采用深度学习方案的音频降噪，&lt;/p&gt;
&lt;p&gt;终于达到近乎可以商用的程度了。&lt;/p&gt;
&lt;p&gt;当然最近也在思考算法的下一步优化方案。&lt;/p&gt;
&lt;p&gt;继续验证思路，继续改良。&lt;/p&gt;
&lt;p&gt;这里放出linux系统下的可执行文件，供大家评测。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/cpuimage/denoise.zip&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/cpuimage/denoise.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压后采用命令行: ./denoise sample.wav &lt;/p&gt;
&lt;p&gt;执行后生成降噪后的文件sample_out.wav&lt;/p&gt;
&lt;p&gt;现在是自适应降噪强度，&lt;/p&gt;
&lt;p&gt;降噪后自动做增益，&lt;/p&gt;
&lt;p&gt;后续计划加上降噪的强度控制。&lt;/p&gt;
&lt;p&gt;噪声样本自行寻觅，&lt;/p&gt;
&lt;p&gt;比较好找。就不提供了。&lt;/p&gt;
&lt;p&gt;在音频这条路上，&lt;/p&gt;
&lt;p&gt;如果我走偏了，大家记得把我拉回来。&lt;/p&gt;

&lt;p&gt;当然若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 16:06:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>很长一段时间，扎根在音频领域，各种玩耍。 渐渐上了轨道。 一切的一切仅仅因为相信自己能做好，也必须做好。 不懂就去查，去问，去找资料，去找视频。 渐渐的，我开始懂了，也慢慢有了系统性的理解。 随后经常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/9840603.html</dc:identifier>
</item>
<item>
<title>IO通信模型（一）同步阻塞模式BIO（Blocking IO） - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/9839741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/9839741.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-12bc6f2131aca12a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;几个概念&quot;&gt;几个概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;阻塞IO&lt;/strong&gt; 和&lt;strong&gt;非阻塞IO&lt;/strong&gt; 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题：前者等待；后者继续执行（但是使用线程一直轮询，直到有IO资源准备好了）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步IO&lt;/strong&gt; 和 &lt;strong&gt;异步IO&lt;/strong&gt;，这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题：前者不响应，直到IO资源准备好以后；后者返回一个标记（好让程序和自己知道以后的数据往哪里通知），当IO资源准备好以后，再用事件机制返回给程序。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步阻塞模式blocking-io&quot;&gt;同步阻塞模式（Blocking IO）&lt;/h3&gt;
&lt;p&gt;同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时如果数据没有准备号会被阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-17c25a3abb126094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;BIO&quot;/&gt;&lt;br/&gt;&lt;a align=&quot;center&quot; href=&quot;http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html&quot;&gt;图片来源:www.masterraghu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伪代码表示如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    // 阻塞，直到有数据
    read(socket, buffer);
    process(buffer);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BIO通信方式的&lt;code&gt;特点&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个线程负责连接，多线程则为每一个接入开启一个线程。&lt;/li&gt;
&lt;li&gt;一个请求一个应答。&lt;/li&gt;
&lt;li&gt;请求之后应答之前客户端会一直等待（阻塞）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;BIO通信方式在单线程服务器下一次只能处理一个请求，在处理完毕之前一直阻塞。因此不适用于高并发的情况。不过可以使用多线程&lt;code&gt;稍微&lt;/code&gt;改进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-7245e9391fe5bcd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;BIO通信模型-来源于慕课网&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;java同步阻塞模式&quot;&gt;Java同步阻塞模式&lt;/h3&gt;
&lt;p&gt;Java中的阻塞模式BIO，就是在&lt;code&gt;java.net&lt;/code&gt;包中的Socket套接字的实现，Socket套接字是TCP/UDP等传输层协议的实现。&lt;/p&gt;
&lt;h3 id=&quot;java同步阻塞模式编码&quot;&gt;Java同步阻塞模式编码&lt;/h3&gt;
&lt;h4 id=&quot;多线程客户端&quot;&gt;多线程客户端&lt;/h4&gt;
&lt;p&gt;为了测试服务端程序，可以先编写一个多线程客户端用于请求测试。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.concurrent.CountDownLatch;

/**
 * &amp;lt;p&amp;gt;
 * BIO测试
 * 模拟20个客户端并发请求，服务端则使用单线程。
 *
 * @Author niujinpeng
 * @Date 2018/10/15 10:50
 */
public class SocketClient {
    public static void main(String[] args) throws InterruptedException {
        Integer clientNumber = 20;
        CountDownLatch countDownLatch = new CountDownLatch(clientNumber);

        // 分别启动20个客户端
        for (int index = 0; index &amp;lt; clientNumber; index++, countDownLatch.countDown()) {
            SocketClientRequestThread client = new SocketClientRequestThread(countDownLatch, index);
            new Thread(client).start();
        }

        synchronized (SocketClient.class) {
            SocketClient.class.wait();
        }
    }
}

/**
 * &amp;lt;p&amp;gt;
 * 客户端，用于模拟请求
 *
 * @Author niujinpeng
 * @Date 2018/10/15 10:53
 */
class SocketClientRequestThread implements Runnable {

    private CountDownLatch countDownLatch;

    /**
     * 线程的编号
     */
    private Integer clientIndex;


    public SocketClientRequestThread(CountDownLatch countDownLatch, Integer clientIndex) {
        this.countDownLatch = countDownLatch;
        this.clientIndex = clientIndex;
    }

    @Override
    public void run() {
        Socket socket = null;
        OutputStream clientRequest = null;
        InputStream clientResponse = null;
        try {
            socket = new Socket(&quot;localhost&quot;, 83);
            clientRequest = socket.getOutputStream();
            clientResponse = socket.getInputStream();

            //等待，直到SocketClientDaemon完成所有线程的启动，然后所有线程一起发送请求
            this.countDownLatch.await();

            // 发送请求信息
            clientRequest.write((&quot;这是第&quot; + this.clientIndex + &quot;个客户端的请求&quot;).getBytes());
            clientRequest.flush();

            // 等待服务器返回消息
            System.out.println(&quot;第&quot; + this.clientIndex + &quot;个客户端请求发送完成，等待服务器响应&quot;);
            int maxLen = 1024;
            byte[] contentBytes = new byte[maxLen];
            int realLen;
            String message = &quot;&quot;;

            // 等待服务端返回，in和out不能cloese
            while ((realLen = clientResponse.read(contentBytes, 0, maxLen)) != -1) {
                message += new String(contentBytes, 0, realLen);
            }
            System.out.println(&quot;第&quot; + this.clientIndex + &quot;个客户端接受到来自服务器的消息:&quot; + message);

        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                if (clientRequest != null) {
                    clientRequest.close();
                }
                if (clientRequest != null) {
                    clientResponse.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单线程服务端&quot;&gt;单线程服务端&lt;/h4&gt;
&lt;p&gt;因为Java中的Socket就是BIO的模式，因此我们可以很简单的编写一个BIO单线程服务端。&lt;/p&gt;
&lt;p&gt;SocketServer.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * BIO服务端
 * &amp;lt;p&amp;gt;
 * 单线程阻塞的服务器端
 *
 * @Author niujinpeng
 * @Date 2018/10/15 11:17
 */
public class SocketServer {

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(83);
        try {
            while (true) {
                // 阻塞，直到有数据准备完毕
                Socket socket = serverSocket.accept();

                // 开始收取信息
                InputStream input = socket.getInputStream();
                OutputStream output = socket.getOutputStream();
                Integer sourcePort = socket.getPort();
                int maxLen = 1024 * 2;
                byte[] contextBytes = new byte[maxLen];

                // 阻塞，直到有数据准备完毕
                int realLen = input.read(contextBytes, 0, maxLen);
                // 读取信息
                String message = new String(contextBytes, 0, realLen);

                // 输出接收信息
                System.out.println(&quot;服务器收到来自端口【&quot; + sourcePort + &quot;】的信息：&quot; + message);
                // 响应信息
                output.write(&quot;Done!&quot;.getBytes());

                // 关闭
                output.close();
                input.close();
                socket.close();

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (serverSocket != null) {
                serverSocket.close();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多线程服务端&quot;&gt;多线程服务端&lt;/h4&gt;
&lt;p&gt;单线程服务器，在处理请求时只能同时处理一条，也就是说如果在请求到来时发现有请求尚未处理完毕，只能等待处理，因此使用&lt;code&gt;多线程改进&lt;/code&gt;服务端。&lt;/p&gt;
&lt;p&gt;SocketServerThread.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * BIO服务端
 * &amp;lt;p&amp;gt;
 * 多线程的阻塞的服务端
 * &amp;lt;p&amp;gt;
 * 当然，接收到客户端的socket后，业务的处理过程可以交给一个线程来做。
 * 但还是改变不了socket被一个一个的做accept()的情况。
 *
 * @Author niujinpeng
 * @Date 2018/10/15 11:17
 */
public class SocketServerThread implements Runnable {

    /**
     * 日志
     */
    private static final Logger logger = LoggerFactory.getLogger(SocketServerThread.class);

    private Socket socket;

    public SocketServerThread(Socket socket) {
        this.socket = socket;
    }

    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(83);
        try {
            while (true) {
                Socket socket = serverSocket.accept();
                //当然业务处理过程可以交给一个线程（这里可以使用线程池）,并且线程的创建是很耗资源的。
                //最终改变不了.accept()只能一个一个接受socket的情况,并且被阻塞的情况
                SocketServerThread socketServerThread = new SocketServerThread(socket);
                new Thread(socketServerThread).start();
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            if (serverSocket != null) {
                serverSocket.close();
            }
        }
    }


    @Override
    public void run() {
        InputStream in = null;
        OutputStream out = null;
        try {
            //下面我们收取信息
            in = socket.getInputStream();
            out = socket.getOutputStream();
            Integer sourcePort = socket.getPort();
            int maxLen = 1024;
            byte[] contextBytes = new byte[maxLen];
            //使用线程，同样无法解决read方法的阻塞问题，
            //也就是说read方法处同样会被阻塞，直到操作系统有数据准备好
            int realLen = in.read(contextBytes, 0, maxLen);
            //读取信息
            String message = new String(contextBytes, 0, realLen);

            //下面打印信息
            logger.info(&quot;服务器收到来自于端口：&quot; + sourcePort + &quot;的信息：&quot; + message);

            //下面开始发送信息
            out.write(&quot;回发响应信息！&quot;.getBytes());
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            //试图关闭
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
                if (this.socket != null) {
                    this.socket.close();
                }
            } catch (IOException e) {
                logger.error(e.getMessage(), e);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来多线程增加了服务能力，但是很明显多线程改进之后仍有以下&lt;code&gt;局限性&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接收和通知处理结果的过程依旧是单线程的。&lt;/li&gt;
&lt;li&gt;系统可以创建的线程数量有限。&lt;code&gt;cat /proc/sys/kernel/threads-max&lt;/code&gt;可以查看可以创建的线程数量。&lt;/li&gt;
&lt;li&gt;如果线程较多，CPU需要更多的时间切换，处理真正业务的时间就会变少。&lt;/li&gt;
&lt;li&gt;创建线程会消耗较多资源，JVM创建一个线程都会默认分配128KB空间。&lt;/li&gt;
&lt;li&gt;多线程也无法解决因为&lt;code&gt;调用底层系统&lt;/code&gt;的&lt;code&gt;同步IO&lt;/code&gt;而决定的同步IO机制。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;同步阻塞模式总结&quot;&gt;同步阻塞模式总结&lt;/h3&gt;
&lt;p&gt;BIO模式因为进程的阻塞挂起，不会消耗过多的CPU资源，而且开发难度低，比较适合并发量小的网络应用开发。同时很容易发现因为请求IO会阻塞进程，所以不时候并发量大的应用。如果为每一个请求分配一个线程，系统开销就会过大。&lt;/p&gt;
&lt;p&gt;同时在Java中，使用了多线程来处理阻塞模式，也无法解决程序在&lt;code&gt;accept()&lt;/code&gt;和&lt;code&gt;read()&lt;/code&gt;时候的阻塞问题。因为&lt;code&gt;accept()&lt;/code&gt;和&lt;code&gt;read()&lt;/code&gt;的IO模式支持是基于操作系统的，如果操作系统发现没有套接字从指定的端口传送过来，那么&lt;code&gt;操作系统就会等待&lt;/code&gt;。这样&lt;code&gt;accept()&lt;/code&gt;和&lt;code&gt;read()&lt;/code&gt;方法就会一直等待。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本文原发于个人博客&lt;/strong&gt;：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;GitHub 源码：&lt;a href=&quot;https://github.com/niumoo/java-toolbox/tree/master/src/main/java/net/codingme/box/io/bio&quot;&gt;https://github.com/niumoo/java-toolbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此文参考文章：&lt;a href=&quot;https://blog.csdn.net/tjiyu/article/details/52959418&quot;&gt;5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO&lt;/a&gt;&lt;br/&gt;此文参考文章：&lt;a href=&quot;https://blog.csdn.net/yinwenjie/article/details/48472237&quot;&gt;架构设计：系统间通信（3）——IO通信模型和JAVA实践 上篇&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注公众号与我联系！&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e5ce036f5efd9f20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:54:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>几个概念 阻塞IO 和 非阻塞IO 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题：前者等待；后者继续执行（但是使用线程一直轮询，直到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/9839741.html</dc:identifier>
</item>
<item>
<title>第25天面向对象编程详解之继承 - 沉沦的罚</title>
<link>http://www.cnblogs.com/huwentao/p/9836359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwentao/p/9836359.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象补充知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;面向对象核心二字在与对象，对象就是特征和技能的结合体，基于该思想编程就好比在创建一个世界，世界上的任何事物都是对象，你就好比是这个世界的上帝，这是一种基于上帝式的思维方式。
优点：扩展性强
缺点：编程的复杂度要远远高于面向过程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一：&lt;/span&gt;&lt;/strong&gt;既然面向对象这么好，我们之后的编程是不是都要用面向对象呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　不是的，衡量一个软件的标准除了扩展性之外，其实还有很多的方面，如性能，可维护性，可移植性等等，但是面向对象编程设计之初就是为了解决扩展性的，所以在其他的一些软件质量的考核上面并没有想象中的那么好，因此，如果我们的软件从一写出来&lt;br/&gt;很长时间都不会再去改动的话，用面向对象编程就不太合适了。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
对象是特征和技能的结合体，类就是一系列对象相同特征和技能的结合体。&lt;br/&gt;现实生活中&lt;br/&gt;　　先有对象，随着人类文明的发展总结出了类。&lt;br/&gt;代码世界中&lt;br/&gt;　　我们需要先定义类，然后才能通过类去创建对象。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类的创建过程:&lt;/span&gt;&lt;/strong&gt; 创建一个老男孩选课系统&lt;/p&gt;
&lt;p&gt;现实世界的分析：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;&lt;/span&gt;要从需求中分析出对象的特征和技能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;分析对象的特征与技能是要根据特定的环境下进行分析的，因为我们分析的特征与技能是希望之后可以使用的，而不是说只是用来看看而已的。

例如：下面分析的一个对象特征也没错，但是就是没有结合特定的环境下分析的特征与技能，在选课系统中，对于特征，我们需要的是一个人的信息，便于之后查询，如名字，年龄，性别等等，但是对于外貌的特征我们是不需要的。对与技能，我们需要的是对象是如何选课的，而不是它是怎么吃饭和怎么喝水的。因此在分析需求的时候一定要根据特定的环境来分析对象的特征和技能。

老男孩选课系统分析
对象1：
    特征
        两个耳朵
        一个眼睛
    技能
        吃
        喝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;老男孩选课系统分析
学生类
对象1：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张铁蛋&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 12&lt;span&gt;
    技能
        选课
对象2：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王铁锤&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 10&lt;span&gt;
    技能
        选课
教师类
对象3：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 18&lt;span&gt;
        级别 level &lt;/span&gt;= 10&lt;span&gt;
        薪资 salary &lt;/span&gt;= 100000&lt;span&gt;
    技能
        修改分数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;属性的分析&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;&lt;/span&gt;寻找相似的特征和技能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;学生类：
相似的特征
    学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
相似的技能
    选课&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码世界的分析：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;&lt;/span&gt;根据相似的特征和技能定义类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
当我们寻找出相似的特征与技能之后我们就可以根据现实世界中的类别来通过class关键字创建自己的类
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据我们现实世界中分析出来的伪代码来定义我们的类&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;学生类：&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的特征&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 学校  school = 'Oldboy'&lt;/span&gt;
    school = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的技能&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选课&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤四：&lt;/strong&gt;&lt;/span&gt;根据类创建对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个学生对象&lt;/span&gt;
stu1 = OldBoyStudent()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;虽然还有很多的细节没有实现，当对象创建完成之后就代表着我们已经成功的把现实中的内容迁移到了我们代码世界中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类的用途&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;用途一：
    类本质上就是一个命名空间，我们可以对该名称空间进行增删改查
用途二：
    调用类产生对象，执行了两个步骤
    &lt;/span&gt;1&lt;span&gt;. 产生一个空对象obj
    &lt;/span&gt;2. 触发类中__init__方法，OldBoyStudent.&lt;span&gt;__init__&lt;/span&gt;(obj)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;用途一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;名称空间就是名字和空间地址的一一映射关系，在python中我们可以使用自动触发函数__dict__去查看当前对象的命名空间中都有哪些名字，说到这里，可能你就会意识到，既然名称空间的存储是一个字典，那么对于这个字典的增删改查是不是就是对名称空间的增删改查呢，没错，就是这样的。
&lt;br/&gt;例如对于上面的例子,我们要查看类中的名称空间
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;学生类：&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的特征&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 学校  school = 'Oldboy'&lt;/span&gt;
    school = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的技能&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选课&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个学生对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 查看的两种方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(OldBoyStudent.&lt;span&gt;__dict__&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;school&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(OldBoyStudent.school)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 增加就是在__dict__中添加一对键值对&lt;/span&gt;
OldBoyStudent.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; OldBoyStudent.__dict__['name']  = 'egon'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用途二&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对象的创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
在我们上面的例子中发现，类中只有一个属性school和一个方法choose_course，那么对于一个对象而言它的名字，年龄，和性别就需要我们每次创建完成之后重新去定义它的属性。
&lt;/pre&gt;
&lt;pre readability=&quot;7&quot;&gt;
# 创建学生对象，并且添加属性&lt;br/&gt;stu1 = OldBoyStudent()&lt;br/&gt;stu1.name = 'egon'&lt;br/&gt;stu1.age = 18&lt;br/&gt;stu1.gender = 'male'&lt;p&gt;当我需要再创建一个对象的时候，还需要重新去定义这个属性，这太麻烦了，因此，python帮我们封装了一个函数__init__函数，我们可以在创建的时候直接通过传递属性参数进行赋值就可以了
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;9&quot;&gt;
class OldBoyStudent:&lt;br/&gt;school = 'Oldboy'&lt;br/&gt;def __init__(self, name, age, gender):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender &lt;p&gt;def choose_course(self):&lt;br/&gt;print('choose_course')&lt;/p&gt;&lt;p&gt;# 创建学生对象，并且添加属性&lt;br/&gt;stu1 = OldBoyStudent('egon', 11, 'male')
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;理解：面向对象是更高程度的一种封装&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;当我们有很多此调用这个函数的时候，我们都需要去传递这样的一组数据，很麻烦&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(address, port, db, charset, sql):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当我们有很多此调用这个函数的时候，我们都需要去传递这样的一组数据，很麻烦&lt;/span&gt;
exec1(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法一：&lt;/strong&gt;&lt;/span&gt;将函数exec1的参数设置成默认参数，这样的话虽然解决了上面存在的问题，但是如果一旦出现另一组数据的话一样是这样的情况，并没有太大的进步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; exec1(address=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306, db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sql=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 虽然说对于第一种的调用我们简化了很多，但是一旦出现另一组数据和之前一样比较麻烦&lt;/span&gt;
&lt;span&gt;exec1()
exec1()
exec1()
exec1()
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法二&lt;/strong&gt;&lt;/span&gt;：将数据定义成变量，通过变量进行传递参数，虽然说稍微简单了一点点，但是当出现两组或者几组数据的时候将会变的非常混乱，不仅如此，数据的耦合性非常强。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(address, port, db, charset, sql):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)

HOST&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
PORT&lt;/span&gt;=3306&lt;span&gt;
DB&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
CHARSET&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SQL&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样比之前直接传入数据会稍微简单一点，但是对于定义的一些变量，我们并不需要它可以被其他的程序所使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因此，我们需要把变量和函数绑定起来&lt;/span&gt;
&lt;span&gt;exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法三：&lt;/strong&gt;&lt;/span&gt;通过函数将数据和方法进行绑定，这也是一种面向对象编程的一种思想，但是我们一般并不会这样去写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过函数的方式把变量和函数绑定到一块，其他的函数自然就使用不到此函数内的变量和方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 并且通过字典的形式将之前的变量包括到一块，可以简化我们函数传递的参数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    obj_dict &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3306&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    }
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(obj_dict):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

    exec1(obj_dict)
func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法四：&lt;/strong&gt;&lt;/span&gt;通过类的形式来将变量和方法进行绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 并且通过字典的形式将之前的变量包括到一块，可以简化我们函数传递的参数&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mysql:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, port, db, charset, sql):
        self.host&lt;/span&gt;=&lt;span&gt;host
        self.port&lt;/span&gt;=&lt;span&gt;port
        self.db&lt;/span&gt;=&lt;span&gt;db
        self.charset&lt;/span&gt;=&lt;span&gt;charset
        self.sql&lt;/span&gt;=&lt;span&gt;sql

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.host, self.port, self.db, self.charset, self.sql)


mysql_obj &lt;/span&gt;= Mysql(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mysql_obj.exec1()
mysql_obj.exec1()
mysql_obj.exec1()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python3中统一了类与类型的概念&lt;/span&gt;
l = list([1, 2, 3&lt;span&gt;])
l.append(&lt;/span&gt;4&lt;span&gt;)
list.append(l, &lt;/span&gt;5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(l)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类与类型的概念&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;面向对象是一种更高程度的封装
    在之前没有面向对象的时候，我们会发现如果需要传递参数的时候，我们无非有两种方式，一种是传递数据，一种就是传递功能，但是没有说我可以通过传递一个变量，这个变量既有数据又有功能的。也就是说一旦我们需要的参数较多，而且调用的次数较为频繁的时候，我们难免就会产生大量的重复操作，因为我们没有一个变量可以将其进行封装。
    而对象呢就是高度封装了一系列的方法和属性的变量，我们可以通过传递一个对象，就可以获得它所有的方法和属性，简化了我们传递参数时的操作。
面向对象的精髓虽在：
　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 掌握了一种方法，能够把专门的数据和专门的方法整合到一块，&lt;/span&gt;
　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当我们拿到一个对象的时候不仅仅能够拿到对应的数据，也能拿到相应的配套方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;人生三问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span readability=&quot;4&quot;&gt;什么是继承&lt;br/&gt;　　继承是一种遗传关系，子类可以重用父类中的属性。&lt;br/&gt;　　在程序中继承是一种新建子类的方式，新创建的类称为子类或者派生类，被继承的类称为父类\基类\超类。&lt;br/&gt;为什么要用继承
　　减少类与类之间的代码冗余的问题&lt;br/&gt;怎么使用继承&lt;br/&gt;　　先抽象再继承&lt;p&gt;只有在python2中才会分新式类和经典类，python3都是新式类&lt;br/&gt;新式类：但凡继承了object类的子类，以及该子类的子子类，...都称为新式类。&lt;br/&gt;经典类：但凡没有继承object类的子类，以及该子类的子子类，....都称为经典类。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承概览：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在python3中默认是继承object类的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在python2中默认是没有继承的，如果想要继承要把object传进去&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent1:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent2:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sub1(Parent1):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sub2(Parent1, Parent2):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(Sub1.&lt;span&gt;__bases__&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __bases__显示的是当前子类继承的父类&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Sub2.&lt;span&gt;__bases__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Parent2.&lt;span&gt;__bases__&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在python3中默认是继承object类的&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Parent1.&lt;span&gt;__bases__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class '__main__.Parent1'&amp;gt;,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class '__main__.Parent1'&amp;gt;, &amp;lt;class '__main__.Parent2'&amp;gt;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class 'object'&amp;gt;,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class 'object'&amp;gt;,)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;属性的查找顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况一：&lt;/strong&gt;单继承问题查找顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023183959265-315676427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;情况二：&lt;/strong&gt;非菱形多继承问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184752022-1256503363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;情况三：&lt;/strong&gt;菱形多继承问题&lt;/p&gt;
&lt;p&gt;python2中是深度优先查找（经典类）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184333891-2142926923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python3中是广度优先查找（新式类）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184609499-1631011750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：只有在python2中的菱形问题才会出现深度查找。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/span&gt;继承是如何解决代码冗余问题的&lt;/p&gt;
&lt;p&gt;首先创建了一个学生类和一个教师类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;学生类和教师类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;我们发现这两个类中有些重复的代码，如他们的共有属性school = 'OldBoy'，为了简化代码，我们需要抽象一个父类，将共有属性放进去，然后通过继承让两个类可以获得相应的属性值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个类然后让学生类和教师类继承&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;27&quot;&gt;
class OldBoyPerson:&lt;br/&gt;school = 'OldBoy'&lt;p&gt;# 根据之前写的Oldboy选课系统来说&lt;br/&gt;class OldBoyStudent(OldBoyPerson):&lt;br/&gt;# school = 'OldBoy'  因为父类中有属性，所以这里就不需要了&lt;/p&gt;&lt;p&gt;def __init__(self, name, age, gender):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender&lt;/p&gt;&lt;p&gt;def choose_course(self):&lt;br/&gt;print('choose_course')&lt;/p&gt;&lt;p&gt;class OldBoyTeacher(OldBoyPerson):&lt;br/&gt;# school = 'OldBoy'&lt;/p&gt;&lt;p&gt;def __init__(self, name, age, gender, level, salary):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender&lt;br/&gt;self.level=level&lt;br/&gt;self.salary=salary&lt;/p&gt;&lt;p&gt;def change_score(self, stu, score):&lt;br/&gt;print('change score')
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;这样确实是减少了子类中的公共属性，但是我们发现在__init__方法中也有一部分是重复的，对于这样的重复的选项我们应该怎么去减少呢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;步骤一：先将学生类和教师类中相同的参数的name， age， gender提取出来放在父类中的__init方法中

步骤二: 通过不同的方法让子类中的init方法中接受到传递过来的额外的参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/span&gt;指名道姓的通过类去找到相应的方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyPerson:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处就是指名道姓的要调用父类中的__init__方法&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时父类中的__init__方法就是一个普通的方法，我们需要把四个参数全部传进去&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样就达到了继承的效果了&lt;/span&gt;
        OldBoyPerson.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender) 
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;方法一与继承无关，只是可以达到继承的目的而已&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/span&gt;：严格依照继承的方法去继承用到函数super&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyPerson:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数一是当前类，参数二当前对象&lt;/span&gt;
        super(OldBoyTeacher, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(name, age, gender)
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;super函数严格按照继承关系&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;难点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; super(OldBoyTeacher, self)在python3中不需要传递参数，它会创建一个特殊的对象&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该对象是强调: super()函数会严格按照类的mro列表的顺序依次查找属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;A没有继承B,&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先打印&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当执行到super函数的时候，会安好mro列表的顺序去查找&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前mro列表已经执行到A，所以下一个查找地方是B因此会执行B类的test方法&lt;/span&gt;
&lt;span&gt;        super().test()   
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;from B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所以打印了&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(A,B):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

c&lt;/span&gt;=C()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先创建对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1. 对象中没有此方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2. 去C类中查找，没有找到&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3. 去父类A中查找，有test，开始执行test函数&lt;/span&gt;
&lt;span&gt;c.test()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(C.mro())
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 23 Oct 2018 15:43:00 +0000</pubDate>
<dc:creator>沉沦的罚</dc:creator>
<og:description>面向对象补充知识 面向对象概念 问题一：既然面向对象这么好，我们之后的编程是不是都要用面向对象呢？ 类的概念 类的创建过程: 创建一个老男孩选课系统 现实世界的分析： 步骤一：要从需求中分析出对象的特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwentao/p/9836359.html</dc:identifier>
</item>
<item>
<title>关于编程语言的一些趣史 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9840321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9840321.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230059968-2119226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回顾历史做仔细的分析与研究，总能给人意想不到的发现和惊叹。从认知的难易程度上来看，编程语言的范式可以按照如下的方式排序：最容易理解的是structured programming，一根线从上往下；再来会稍微费点功夫理解的是object-oriented（OO）programming；更困难的是functional programming，相当抽象，整个就是一数学的抽象思维。&lt;/p&gt;
&lt;p&gt;自然地，历史的发展都是由简单到复杂，我们会下意识地认为编程语言在历史上的出现顺序也应该是：structured programming、OO、functional programming。&lt;/p&gt;
&lt;p&gt;但翻阅历史，却会惊讶地发现它们的出现顺序竟然是反过来的！&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;structured programming是在1968年出现，其标志是Dijkstra（对，那个最短路径算法里出现的名字）发表他的seminal paper 'Cooperating sequential processes’。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再来是更早的1966年，Dahl和Nygaard发现function call stack frame可以被放到heap去做，这标志着OO的出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;而似乎最难以理解的functional programming，则几乎可以追溯到1936年计算机被发明的时期。其标志是Alonzo Church推出lambda calculus。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一件值得探讨的事情是：为什么Dijkstra要引入structured programming？虽然从现在来看structured programming是如此的直观，以至于你会问，为什么会过了那么久才引入structured programming？&lt;/p&gt;
&lt;p&gt;在Dijkstra的时代，主流编程语言都不是structured的，到处充斥着goto所带来的跳转。为什么会遍地的goto呢？因为在计算机语言的莽荒时期，一切都是向机器看齐的。对于机器语言、汇编来讲，指令集的各种jump操作是再平常不过的事情了。既然它们都有之灵跳转，对应的编程语言怎么好意思说不支持goto呢？&lt;/p&gt;
&lt;p&gt;所以，structured programming反而在当时是一种极端的非主流，因为它为programming给予了相当大的限制。&lt;/p&gt;
&lt;p&gt;Dijkstra之所以要引入structured programming源自于他要把“计算机”这门学科变为科学的尝试：将数学的公理化体系引入computer science（CS）。但经过大量尝试后，他发现要为代码构建牢固的数学公理体系着实不是一件容易的事情。而其中最大的问题障碍，就是goto带来的不确定性。&lt;/p&gt;
&lt;p&gt;于是，Dijkstra采用了数学家常用的研究方法：当需要推出一个漂亮的理论却发现前提条件不够时，就反过来先引入这个结论需要的前提假设。&lt;/p&gt;
&lt;p&gt;于是，Dijkstra就直接把goto（至少是被滥用的goto）废除掉。没有了goto，虽然引入数学的严格证明会变得相当简单，但这样会不会限制语言的表达？又或者说，有些代码是不是没有了goto就无法写出来呢？&lt;/p&gt;
&lt;p&gt;说来也是历史机缘，恰好在这个时候，Bohm and Jacopini在理论上证明了：所有的程序都可以被以下三种句式所替代： sequence, selection(if/then/else), iteration(for/while)。而这正好是Dijkstra所需要的，因为实现这三种语句完全用不到goto。于是，Dijkstra的为CS引入严格数学公理体系的壮举也就水到渠成：所有的由sequence、selection（if/then/else）语句构成的程序，可以由数学枚举法证明。而由iteration（for/while）语句构成的程序，则可以由数学归纳法完成。而structured programming这种被做了更多限制的编程范式也就应运而生。（很有意思的事情是，三种编程范式structured programming、OO、functional programming的引入，都是通过“限制功能”而非增加功能做出的，也即是，为了更强你需要更弱一点。更多讨论可以参考我以前的一篇文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483774&amp;amp;idx=1&amp;amp;sn=74906052c65df36baa63cbbf5800c656&amp;amp;chksm=ec20e6c2db576fd4c230ea140e0cfd5cb910500b5ff219f66b1e7038d3f9fd844e2cb29c6ccf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;为了快一点为什么却要慢一点&lt;/a&gt;》。）&lt;/p&gt;
&lt;p&gt;如果按照这样的思维框架去思考算法，比如LeetCode中的算法题目，又会有一些惊人发现。我的一个想转行做程序员的朋友曾跟我聊过这样一段刷题感受：似乎算法题目都或多或少地在使用数学归纳法。这确实是很强的洞见。回顾起来，无论是divide-and-conquere还是dynamic programmming，这两种作为算法基石的工具都运用到了数学归纳法的思维方式。前者（递归）是天然的数学归纳法处理方式，而后者则是做了空间复杂度优化的递归，同样按照数学归纳法的方式做处理。&lt;/p&gt;
&lt;p&gt;进一步，我们可以考察一些工作中遇到的问题。刚毕业工作的小白程序员常常会疑惑这样一个事情，明明自己在学校中算法的造诣颇高，按道理说算法好不就是编程的功底好么，但为什么到了工作岗位中还是各种碰壁？&lt;/p&gt;
&lt;p&gt;按照我们上面构建的思维框架，我们其实可以给出一种解释：因为算法部分的修炼，仅仅保证了你在structured programming这个语言范式下做事具备了很好的能力。可工作中所涉及到的软件设计，则是在OO范式和functional programming范式下进行的。领域不同，自然是新手，碰壁也是自然之事。&lt;/p&gt;
&lt;p&gt;再回到我们最开始的那个问题，为什么编程范式会是以相反的认知方向来发展？因为这是按照“构建计算机领域”的难易程度在走，也即是背后的数学发展在展开，而不是编程语言使用的难易程度在发展。这是一门新兴学科初期的发展特点——先考虑的是生产的便利性，再来是消费者的便利性。&lt;/p&gt;
&lt;p&gt;========&lt;/p&gt;
&lt;p&gt;Comments for 《Clean Architecture》&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484593&amp;amp;idx=1&amp;amp;sn=26c4e29b584a98e244d7334c6a75b63c&amp;amp;chksm=ec20e30ddb576a1b548420615abfe3545acff718db4585d33190e0e5b03df0425f5ef55eb99d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;他人皆蠢，吗？&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484588&amp;amp;idx=1&amp;amp;sn=5d047d123e90b6165916f91a49b37c98&amp;amp;chksm=ec20e310db576a06facd210f3bf06351c7a2b372fdc88bb2ae22c2b856b3cc7d2090c501c0a5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;从Facebook面试看互联网行业&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484582&amp;amp;idx=1&amp;amp;sn=3b7a671c9bffc89f7c7182624ce05164&amp;amp;chksm=ec20e31adb576a0c48f81147ed4ffabfaad6766995e6085256a0ba9ebbeb40f8ab3c6136a148&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;GeekArtT两周年&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230137555-2124868900.jpg&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;314&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230213124-1621146937.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:03:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>回顾历史做仔细的分析与研究，总能给人意想不到的发现和惊叹。从认知的难易程度上来看，编程语言的范式可以按照如下的方式排序：最容易理解的是structured programming，一根线从上往下；再来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9840321.html</dc:identifier>
</item>
<item>
<title>一种精准monkey测试的方法 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9840315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9840315.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相信大家都知道移动端应用的monkey测试吧，不知你们有没有为monkey测试的太过于随机性的特性有过困扰，至少在我们这种界面控件较少且控件位置较偏的app的使用上其测试有效性大打折扣。因此本文主要针对这个问题，提供了一种解决方案。&lt;/p&gt;

&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 问题背景&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Monkey测试：是Android自动化测试的一种手段，简单的说是像猴子一样乱点，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，是一种随机性测试，为了测试软件的健壮性和稳定性，通常用于安卓应用的压力测试。&lt;/p&gt;

&lt;p&gt;因此，我们的产品也用了这种传统的monkey手段进行app稳定性测试，在使用一段时间后，并未发现实际性问题。通过观察一段时间的执行过程，发现由于我们app几个页面控件布局是比较偏上和偏下边缘，中间只有一个大按钮，这样中间大按钮命中率比较高经常会进入同一个页面，那么其他页面和按钮的功能几乎没有被点击到。这种传统monkey测试控件命中率太低！&lt;/p&gt;

&lt;p&gt;市面上有很多类似布局的app，相信在采用传统monkey测试时也存在此类问题。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;我们知道，对于app页面布局的控件位置、属性等信息是可以用android sdk 工具包中的uiautomatorviewer.bat查看的，如果在monkey测试时能获得这些控件的位置信息，那么就可以实现控件的精准点击。android sdk提供了这个命令“adb shell uiautomator dump”，可以实现将当前activity布局文件dump到xml文件中，这样问题就得到了解决。&lt;/p&gt;

&lt;p&gt;dump 布局文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225823747-2097395912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;得到的window_dump.xml内容：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version='1.0' encoding='UTF-8' standalone='yes' ?&amp;gt;&lt;br/&gt;&amp;lt;hierarchy rotation=&quot;0&quot;&amp;gt;&lt;br/&gt;&amp;lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.FrameLayout&quot; package=&quot;com.bass.cleaner.security&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[0,0][1080,1776]&quot;&amp;gt;&lt;br/&gt;&amp;lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;com.bass.cleaner.security&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[0,0][1080,1776]&quot;&amp;gt;&lt;br/&gt;...&lt;br/&gt;&amp;lt;/hierarchy&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;uiautomatorviewer.bat查看控件属性：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225915522-474274684.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是，又一问题，xml中的控件非常多，并非每个控件都可以点击，如果挨个尝试点击那么执行效率也是非常慢的，不符合预期。幸好，控件有个clickable属性，当其等于true时，表示该控件可点，反之不可点。那么，我们将控件信息xml文件中“clickable=true”的控件过滤出来，再去计算这些控件的位置进行点击，就可以实现精准点击。到此，问题得到完美解决。&lt;/p&gt;

&lt;p&gt;举例，执行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225925959-1880331920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，在实际中，还存在控件的点击顺序问题，如果点击顺序不合适，也会存在有些控件被频繁点击、有些控件可能点击不到的情况。这就需要根据实际的测试目标来指定执行策略，例如，在当前页可点击的控件列表中，随机点击、顺序点击，或存储各页面控件的目录树，进行深度遍历点击等等。&lt;/p&gt;

&lt;p&gt;随机测试完后，有时还需要还原执行过程，定位发现的问题，所以在执行过程中，我还加入了一些截图操作，在每次点击控件前进行点击坐标的标记、截图，这样，测试完后就能根据这些截图很完美的还原出了整个随机测试的过程，大大简化的问题的定位。举例，下图是执行过程中的几张连续截图： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225946648-1511251522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225954854-1965273642.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023230010317-1037714923.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;图中，红点位置就是点击位置，很直观的展示了执行过程。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;本文所述的方案很好的解决了monkey测试在控件布局不均衡的app上执行有效性低的问题。同时，实现了一种自适应的随机测试手段，也就是无需针对不同app编写不同的随机测试脚本，实现了一套测试代码用于所有app的随机性测试。&lt;/h3&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;“自动化兼容测试” 服务将提供云端自动化兼容服务，提交云端百台真机，并行测试。快速发现游戏/应用兼容性和性能问题，覆盖安卓主流机型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击：&lt;a href=&quot;https://wetest.qq.com/product/auto-compatibility-testing?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;https://wetest.qq.com/product/auto-compatibility-testing&lt;/a&gt; 了解更多详情。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：2852350015&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:02:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<og:description>WeTest 导读 相信大家都知道移动端应用的monkey测试吧，不知你们有没有为monkey测试的太过于随机性的特性有过困扰，至少在我们这种界面控件较少且控件位置较偏的app的使用上其测试有效性大打</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9840315.html</dc:identifier>
</item>
<item>
<title>Composite模式（组合设计模式） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9840291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9840291.html</guid>
<description>&lt;h4 id=&quot;composite-设计模式&quot;&gt;Composite 设计模式？&lt;/h4&gt;
&lt;p&gt;在计算机的文件系统中，有“文件夹”的概念（在有些操作系统（Linux操作系统）中，也称为“目录”）。文件夹里面既可以放入文件，也可以放入其他文件夹（子文件夹）。在子文件夹中，一样地既可以放入文件，也可以放入子文件夹。可以说，文件夹是形成了一种容器结构、递归结构。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;结构模式：能够使容器与内容具有一致性，创造出递归结构的模式就是Composite模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;关注点：使用Composite模式可以使容器与内容具有一致性，也可以称其为多个和单个的一致性，即将多个对象结合在一起，当作一个对象进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;到处存在的递归结构：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在视窗系统中，一个窗口可以含有一个子窗口，&lt;br/&gt;2.在文章的列表中，各列表之间可以相互嵌套，这也是一种递归结构。&lt;br/&gt;3.将多条计算机命令合并为一条宏命令时，如果使用递归结构实现宏命。&lt;br/&gt;4.树结构的数据结构都适用Composite模式。&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;实现：演示文件夹 文件子项之间的层次关系&lt;br/&gt;名字===================&amp;gt;&amp;gt;&amp;gt;说明&lt;br/&gt;Entry || 抽象类，用来实现File类和Directory类的一致性&lt;br/&gt;File || 表示文件的类&lt;br/&gt;Directory || 表示文件夹的类&lt;br/&gt;FileTreatementException || 表示向文件中增加Entry时发生的异常的类&lt;br/&gt;Main || 测试程序行为的类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Add（）方法的存在位置:&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;存在Entry 抛出异常。&lt;/li&gt;
&lt;li&gt;存在Entry 中什么也不做。&lt;/li&gt;
&lt;li&gt;声明在Entry中为抽象方法 不去实现。&lt;/li&gt;
&lt;li&gt;直接定义在Directory类中，但是需要关注类型之间的转换。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181023225719892-288395746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181023225727918-403187019.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;p&gt;···&lt;/p&gt;
&lt;p&gt;public abstract class Entry {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 1. 文件名
 * 2. 文件大小
 * @return
 */
public abstract String getName();
public abstract int getSize();

/**
 * Directory  增加条目
 * File 不能增加条目
 */
public Entry add(Entry entry)throws FileTreatementException{
    throw new FileTreatementException();
}

public void printList(){
    printList(&quot;&quot;);
}

protected abstract void printList(String prefix);

@Override
public String toString() {
    return getName()+&quot;(&quot;+getSize()+&quot;)&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;···&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class File extends Entry {

    private String name;

    private int size;

    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    protected void printList(String prefix) {
        System.out.println(prefix+&quot;/&quot;+this);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
public class Directory extends Entry {

    private String name;

    private List&amp;lt;Entry&amp;gt; directory=new ArrayList&amp;lt;&amp;gt;();

    public Directory(String name) {
        this.name = name;
    }

    @Override
    public Entry add(Entry entry) throws FileTreatementException {
        directory.add(entry);
        return this;
    }

    @Override
    public String getName() {
        return name;
    }

    /**
     * getSize() | printList(String prefix)
     *
     * 都会递归去遍历下面可能存在的 目录或者文件的子项
     */

    @Override
    public int getSize() {
        int size=0;
        Iterator&amp;lt;Entry&amp;gt; it = directory.iterator();
        while (it.hasNext()){
            // 这里的Entry 可能是目录 也可能是文件
            Entry next = it.next();
            size+=next.getSize();
        }

        return size;
    }

    @Override
    protected void printList(String prefix) {
        // 这里的 prefix是一个引用 this将会调用tostring()方法 又会继续调用getName() getSize()方法
        System.out.println(prefix+&quot;/&quot;+this);
        Iterator&amp;lt;Entry&amp;gt; it = directory.iterator();
        while(it.hasNext()){
            // 这里的Entry 可能是目录 也可能是文件
            Entry next = it.next();
            next.printList(prefix+&quot;/&quot;+this);
        }
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FileTreatementException&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public class FileTreatementException extends Exception {

    public FileTreatementException() {
    }

    public FileTreatementException(String message) {
        super(message);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义的目的结构：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;start +++++++++++
/root(16000)
/root(16000)/bin(16000)
/root(16000)/bin(16000)/vi(1000)
/root(16000)/bin(16000)/notepaid(15000)
/root(16000)/temp(0)
/root(16000)/user(0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) throws FileTreatementException{

        System.out.println(&quot;start +++++++++++&quot;);

        Directory rootdir=new Directory(&quot;root&quot;);

        Directory bindir = new Directory(&quot;bin&quot;);
        Directory tempdir = new Directory(&quot;temp&quot;);
        Directory userdir = new Directory(&quot;user&quot;);

        rootdir.add(bindir);
        rootdir.add(tempdir);
        rootdir.add(userdir);

        bindir.add(new File(&quot;vi&quot;,1000));
        bindir.add(new File(&quot;notepaid&quot;,15000));

        rootdir.printList();
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 23 Oct 2018 14:58:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Composite 设计模式？ 在计算机的文件系统中，有“文件夹”的概念（在有些操作系统（Linux操作系统）中，也称为“目录”）。文件夹里面既可以放入文件，也可以放入其他文件夹（子文件夹）。在子文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9840291.html</dc:identifier>
</item>
<item>
<title>Spring 学习01 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9840268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9840268.html</guid>
<description>&lt;p&gt;1 spring是开源的轻量级框架&lt;/p&gt;
&lt;p&gt;2 spring核心主要两部分：&lt;/p&gt;
&lt;p&gt;（1）aop：面向切面编程，扩展功能不是修改源代码实现&lt;/p&gt;
&lt;p&gt;（2）ioc：控制反转，&lt;/p&gt;
&lt;p&gt;- 比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象&lt;/p&gt;
&lt;p&gt;- 把对象的创建不是通过new方式实现，而是交给spring配置创建类对象&lt;/p&gt;
&lt;p&gt;3 spring是一站式框架&lt;/p&gt;
&lt;p&gt;（1）spring在javaee三层结构中，每一层都提供不同的解决技术&lt;/p&gt;
&lt;p&gt;- web层：springMVC&lt;/p&gt;
&lt;p&gt;- service层：spring的ioc&lt;/p&gt;
&lt;p&gt;- dao层：spring的jdbcTemplate&lt;/p&gt;
&lt;p&gt;4 spring版本&lt;/p&gt;
&lt;p&gt;（1）hibernate5.x&lt;/p&gt;
&lt;p&gt;（2）spring4.x&lt;/p&gt;

&lt;p&gt;1 把对象的创建交给spring进行管理&lt;/p&gt;
&lt;p&gt;2 ioc操作两部分：&lt;/p&gt;
&lt;p&gt;（1）ioc的配置文件方式&lt;/p&gt;
&lt;p&gt;（2）ioc的注解方式&lt;/p&gt;

&lt;p&gt;1 ioc底层原理使用技术&lt;/p&gt;
&lt;p&gt;（1）xml配置文件&lt;/p&gt;
&lt;p&gt;（2）dom4j解决xml&lt;/p&gt;
&lt;p&gt;（3）工厂设计模式&lt;/p&gt;
&lt;p&gt;（4）反射&lt;/p&gt;
&lt;p&gt;2 画图分析ioc实现原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223437933-1481605296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步 导入jar包&lt;/p&gt;
&lt;p&gt;（1）解压资料zip文件&lt;/p&gt;
&lt;p&gt;Jar特点：都有三个jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223531660-1517566117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223538381-1916802095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）做spring最基本功能时候，导入四个核心的jar包就可以了&lt;/p&gt;
&lt;p&gt;（3）导入支持日志输出的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223552589-187325623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步 创建类，在类里面创建方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223615673-402888542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步 创建spring配置文件，配置创建类&lt;/p&gt;
&lt;p&gt;（1）spring核心配置文件名称和位置不是固定的&lt;/p&gt;
&lt;p&gt;- 建议放到src下面，官方建议applicationContext.xml&lt;/p&gt;
&lt;p&gt;（2）引入schema约束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223635881-1391547452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223641255-945994850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）配置对象创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223651719-1715751927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步 写代码测试对象创建&lt;/p&gt;
&lt;p&gt;（1）这段代码在测试中使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223706991-1471186601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1 spring引入schema约束，把约束文件引入到eclipse中&lt;/p&gt;
&lt;p&gt;（1）复制约束路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223743602-44259373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223751810-1288888922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;1.Bean实例化的方式&lt;/h2&gt;
&lt;p&gt;1 在spring里面通过配置文件创建对象&lt;/p&gt;
&lt;p&gt;2 bean实例化三种方式实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种 使用类的无参数构造创建（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223937495-1351680771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类里面没有无参数的构造，出现异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223949081-16554937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种 使用静态工厂创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建静态的方法，返回类对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224006390-681547141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224016338-2118945765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种 使用实例工厂创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建不是静态的方法，返回类对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224053678-1163742822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224101323-1028454901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.Bean标签常用属性&lt;/h2&gt;
&lt;p&gt;（1）id属性：起名称，id属性值名称任意命名&lt;/p&gt;
&lt;p&gt;- id属性值，不能包含特殊符号&lt;/p&gt;
&lt;p&gt;- 根据id值得到配置对象&lt;/p&gt;
&lt;p&gt;（2）class属性：创建对象所在类的全路径&lt;/p&gt;
&lt;p&gt;（3）name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）scope属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- singleton：默认值，单例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224246991-1920738706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224253271-918904367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; prototype：多例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224307053-1353064249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;- request：创建对象把对象放到request域里面&lt;/p&gt;
&lt;p&gt;- session：创建对象把对象放到session域里面&lt;/p&gt;
&lt;p&gt;- globalSession：创建对象把对象放到globalSession里面&lt;/p&gt;

&lt;p&gt;1 创建对象时候，向类里面属性里面设置值&lt;/p&gt;
&lt;p&gt;2 属性注入的方式介绍（三种方式）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用set方法注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）使用有参数构造注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）使用接口注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224500278-503250059.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3 在spring框架里面，支持前两种方式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）set方法注入（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）有参数构造注入&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;使用有参数构造注入属性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224554802-269351005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224608037-274084728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用set方法注入属性（重点）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224626277-399144596.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224633278-1699850367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1 创建service类和dao类&lt;/p&gt;
&lt;p&gt;（1）在service得到dao对象&lt;/p&gt;
&lt;p&gt;2 具体实现过程&lt;/p&gt;
&lt;p&gt;（1）在service里面把dao作为类型属性&lt;/p&gt;
&lt;p&gt;（2）生成dao类型属性的set方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224740487-574933007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）配置文件中注入关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224754448-74685792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224856503-1633688160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224903636-386827805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1 数组&lt;/p&gt;
&lt;p&gt;2 list集合&lt;/p&gt;
&lt;p&gt;3 map集合&lt;/p&gt;
&lt;p&gt;4 properties类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入复杂类型属性值 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;person&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.itcast.property.Person&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数组 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;arrs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小王&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小马&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小宋&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小奥&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小金&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小普&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;            
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; map &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;aa&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;lucy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;bb&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;mary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;cc&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;tom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; properties &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;driverclass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（1）IOC: 控制反转，把对象创建交给spring进行配置&lt;/p&gt;
&lt;p&gt;（2）DI: 依赖注入，向类里面的属性中设置值&lt;/p&gt;
&lt;p&gt;（3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作&lt;/p&gt;

&lt;p&gt;1 加载spring核心配置文件，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023225154082-852321699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）new对象，功能可以实现，效率很低&lt;/p&gt;
&lt;p&gt;2 实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成&lt;/p&gt;

&lt;p&gt;3 实现原理&lt;/p&gt;
&lt;p&gt;（1）ServletContext对象&lt;/p&gt;
&lt;p&gt;（2）监听器&lt;/p&gt;
&lt;p&gt;（3）具体使用：&lt;/p&gt;
&lt;p&gt;- 在服务器启动时候，为每个项目创建一个ServletContext对象&lt;/p&gt;
&lt;p&gt;- 在ServletContext对象创建时候，使用监听器可以具体到ServletContext对象在什么时候创建&lt;/p&gt;
&lt;p&gt;- 使用监听器监听到ServletContext对象创建时候，&lt;/p&gt;
&lt;p&gt;-- 加载spring配置文件，把配置文件配置对象创建&lt;/p&gt;
&lt;p&gt;-- 把创建出来的对象放到ServletContext域对象里面（setAttribute方法）&lt;/p&gt;
&lt;p&gt;- 获取对象时候，到ServletContext域得到 （getAttribute方法）&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《黑马程序员》&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 14:55:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Spring概念 1 spring是开源的轻量级框架 2 spring核心主要两部分： （1）aop：面向切面编程，扩展功能不是修改源代码实现 （2）ioc：控制反转， - 比如有一个类，在类里面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9840268.html</dc:identifier>
</item>
<item>
<title>【论文阅读】Deep Adversarial Subspace Clustering - 我若成风者</title>
<link>http://www.cnblogs.com/EstherLjy/p/9840016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EstherLjy/p/9840016.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;导读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文为CVPR2018论文《Deep Adversarial Subspace Clustering》的阅读总结。目的是做聚类，方法是DASC=DSC（Deep Subspace Clustering）+GAN（Generative Adversarial Networks）。本文从以下四个方面来对论文做个简要整理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;背景：&lt;/strong&gt;简要介绍与本文密切相关的基础原理，DSC，GAN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;方法：&lt;/strong&gt;介绍论文使用的方法和细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;实验&lt;/strong&gt;：实验结果和简要分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;总结：&lt;/strong&gt;论文主要特色和个人体会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　论文方法DASC（深度对抗聚类）是基于DSC（深度子空间聚类）和GAN（生成对抗网络）的，所以，在介绍论文方法之前，对DSC和GAN做个简要介绍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;1.DSC&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;1）原理（LRR）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　首先要明确的是，整个论文的大方向是做聚类。做聚类以往已经有非常多的方法，最近几年比较流行也即DSC所采用的理论基石是低秩表示（LRR）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　LRR理论基本思想是，对于一个数据（如图像或图像特征等）可以表示为干净数据部分和噪声部分，其中干净数据部分又可以采用字典和系数表示的形式，此时要求干净数据的系数表示部分是低秩的，噪声部分是稀疏的。此时，如果用数据本身作为字典，那么其系数部分就可以描述原始数据间的相似度。用数学公式表示如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023200724867-2042546461.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，X=[x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;,...x&lt;sub&gt;n&lt;/sub&gt;]∈R&lt;sup&gt;d*n&lt;/sup&gt;表示原始输入数据（一般是图像的特征），Z∈R&lt;sup&gt;n*n&lt;/sup&gt;表示系数部分，E∈R&lt;sup&gt;d*n&lt;/sup&gt;表示噪声。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么这个式子与聚类有什么关系呢？&lt;span&gt;关系是，假设待聚类的数据分布于多个线性子空间，那么通过求解上述式子的最小化问题，我们可以得到数据X间的相似度矩阵Z，有了相似度矩阵我们就可以对输入数据X=[x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;,...x&lt;sub&gt;n&lt;/sub&gt;]进行聚类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因此，实现对多个d维数据x&lt;sub&gt;i&lt;/sub&gt;的聚类，LRR方法采用的方法是，将x&lt;sub&gt;i&lt;/sub&gt;按列组合成X，然后通过优化上述式子，得到Z，最后将Z输入到谱聚类算法中，就可以得到最终的聚类结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）方法（网络）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　一般来说，对于图像做聚类，我们采用的方法是，对图像提取特征，然后得到特征表示，组成X，然后采用LRR原理进行聚类。但是这种先提取特征再进行聚类的缺点是一个两阶段的过程，两者不能互相促进。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因此DSC将特征提取和相似度矩阵的学习融入到一个网络中进行统一学习。重新定义符号表示，用X表示输入数据，Z表示特征，θ表示待学习的参数相似度矩阵，那么DSC的学习是最优化下面的式子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　min ||Z-Zθ||F+λ||θ||F，以求得参数Z和θ。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　网络整体结构如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023205848051-317685050.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上图所示，输入图像X，经过两层编码器进行编码（即特征转换），得到特征表示Z，然后将Z reshape成一个列向量，然后与后面变量Zθ进行全连接，再将Zθ重新reshape成与前面相对应的大小，再经过两个解码层，得到恢复出的图像。即，原图-&amp;gt;编码得特征-&amp;gt;解码得原图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　3）设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　DSC重点主要是Loss的设计，Loss由重建损失、参数正则损失、自表示损失几部分组成：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023211250895-929355003.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2.GAN&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;strong&gt;　1）原理&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023211519259-2027577176.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　GAN由一个生成器和一个判别器组成。其中，生成器负责生成数据，从真实的数据中生成假的数据，期望假的数据越逼真越好。判别器负责判断接收到的数据是真实的还是产生的，即一个二分类器，期望效果比较好，也就是说真实的数据判别为真的概率更大，假的数据判别为真的概率更小。所以，在生成器期望生成的数据逼真到能够欺骗判别器而判别器期望判别能力强的情况下，通过两者的博弈，来达到生成数据能够模拟真实数据的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）设计&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　实现GAN主要是通过Loss的设计，D的输出为数据被判定为真实数据的概率，整体Loss如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212325668-1809181585.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优化D：&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212427639-1118700760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优化G：&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212505566-941055626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于上述Loss的解释是，优化判别器D时，希望D判别能力强，那么就希望真实数据被判定为真的概率大，所以&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212757947-1061554669.jpg&quot; alt=&quot;&quot; width=&quot;232&quot; height=&quot;41&quot;/&gt;应该比较大，&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212822370-141020961.jpg&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;34&quot;/&gt;应该比较小，所以是最大化V（D，G）。优化产生器时，期望伪造数据比较真，那么就希望Z为伪造品时，D（G（Z））比较大，也即&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023213033795-1935425564.jpg&quot; alt=&quot;&quot;/&gt;比较小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更多关于GAN的解释可见其他博客，这里不做更详细的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;3）作用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　使得伪造的数据足够逼真，比如从噪声数据，逐步学习，得到人脸数据等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;3.DASC&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　上面介绍完了DAC和GAN，我们知道DSC已经可以做聚类了，而且聚类算比较好的了，那么还能不能再提高呢？答案是可以。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们知道，DSC是一步一步训练得到Z来做聚类，其中有个问题是，我们并不确定迭代到多少次效果比较好，也不能确定下次迭代就比上次得到的Z好，那么有没有什么方法能够指导无监督网络DSC的学习，让网络的训练每次都朝着效果更好的方向训练呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这就是DASC所做的工作了，基础思想是，用GAN来指导DSC的学习，使其每次都朝着效果更好的方向发展。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本章介绍DASC的方法，从原理、生成器、判别器、训练这四个部分分别进行探讨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1）原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用GAN指导DSC的学习，就需要明确下面两个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一是，把处于同一子空间的数据，进行线性组合得到新的数据，那么新的数据依然处于该子空间。反之，处于不同子空间的数据，进行线性组合得到的数据跟原始数据处在不同子空间。（可以从下图看出）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023214939474-389380133.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二是，处在同一子空间的数据，判别器（即分类器）分辨不出是真实数据还是伪造的数据，即输出概率为0.5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过一二知，聚类效果比较好-&amp;gt;新数据依然处于该子空间-&amp;gt;判别器无法判别真假。即，判别器越无法判断真假数据，说明聚类效果越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，我们要做的任务就是，通过生成器得到正（真实数据）次（线性组合得到的伪造数据）品，输入到判别器中，经过对抗学习，得到更好的相似度矩阵θ和特征表达Z，从而来得到最终的聚类结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023215418280-42416868.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　其中，生成器G包括DSC和正次品采样层。下面的DSC得到中间聚类结果后，将Z输入给采样层，采样层得到正次品输入给判别器D。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）生成器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　生成器的操作步骤是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　11）聚类得到C&lt;sub&gt;i&lt;/sub&gt;和特征表示z&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　22）计算类C&lt;sub&gt;i&lt;/sub&gt;中z&lt;sub&gt;i&lt;/sub&gt;到相对应的子空间S&lt;sub&gt;i&lt;/sub&gt;的投影残差L&lt;sub&gt;r&lt;/sub&gt;。其中S&lt;sub&gt;i&lt;/sub&gt;是由投影矩阵U&lt;sub&gt;i&lt;/sub&gt;来表示的，U&lt;sub&gt;i&lt;/sub&gt;（或者说S&lt;sub&gt;i&lt;/sub&gt;）是判别器学习得到的，与生成器的学习无关。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023220118217-1514083914.png&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;32&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　33）选择投影残差L&lt;sub&gt;r&lt;/sub&gt;最小的80%~90%的Ci中的数据作为正品。（因为经过DSC大部分的数据已经是正确的。这里还可以起到去噪的作用）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　44）随机线性组合计算得到与正品同样数量的次品。其中α来于[0-1]中的随机数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023220633993-381547809.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;40&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　55）将正次品输给判别器D。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023215832615-242570166.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3）判别器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11）学习的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学习的参数为子投影矩阵U&lt;sub&gt;i&lt;/sub&gt;(代表子空间S&lt;sub&gt;i&lt;/sub&gt;),用子空间来判别是正品还是次品。原则是，投影残差L&lt;sub&gt;r&lt;/sub&gt;越小，说明是正品（文章中说能量越小）的概率越大，对判别器来说Loss的输出也应该越小。反之Loss就越大。所以投影残差L&lt;sub&gt;r&lt;/sub&gt;即与Loss成反比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221032840-373200963.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;38&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　22）优化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过上述分析，直接给出Loss优化如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221555468-1806092355.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;96&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221605883-628787633.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;69&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221647698-430491565.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;40&quot;/&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221654565-477086462.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221723376-888628272.png&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　33）细节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　投影矩阵U&lt;sub&gt;i&lt;/sub&gt;和类簇C&lt;sub&gt;i&lt;/sub&gt;并不是一一对应的关系，因为每次更新都需要找一下是否子空间投影矩阵是否有变化，所以需要C&lt;sub&gt;i&lt;/sub&gt;进行竞争U&lt;sub&gt;i&lt;/sub&gt;。竞争的方式是，对每个类簇计算平均投影残差，然后选择具有最小平均残差的U&lt;sub&gt;i&lt;/sub&gt;作为自己的投影矩阵。如果该U&lt;sub&gt;i&lt;/sub&gt;具有更小平均投影残差的类簇，那么原类簇则采用对Z进行QR分解来得到自己的U&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　判别器采用两层全连接感知机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4）训练&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11）DSC预训练初始化DASC网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　22）用Z&lt;sub&gt;i&lt;/sub&gt;的QR分解初始化U&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　33）联合交替更新DASC中的D和G，其中D更新五次，G更新一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、实验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接贴结果吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222605755-778692214.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222555136-224902851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222618293-2016192363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222628436-1071589468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.该文章采用了DSC+GAN的方式，是GAN在无监督聚类上的首次成功运用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.文章对无监督的聚类进行了定性的评估：线性组合在同一子空间（不能被判别器正确识别）说明聚类效果好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.文章对无监督聚类进行了定量的评估：据子空间的投影残差越小说明属于真实数据的概率越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.在写作方面，文章采用比较新颖刁钻的方式。比如，把投影距离称为能量大小，把线性组合称为新子空间采样。换汤不换药，还显得很好喝，就比较骚了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>我若成风者</dc:creator>
<og:description>导读： 本文为CVPR2018论文《Deep Adversarial Subspace Clustering》的阅读总结。目的是做聚类，方法是DASC=DSC（Deep Subspace Cluste</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EstherLjy/p/9840016.html</dc:identifier>
</item>
</channel>
</rss>