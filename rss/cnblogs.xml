<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>监控利器 sysdig - 每天5分钟玩转 Docker 容器技术（79） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7646995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7646995.html</guid>
<description>&lt;p&gt;sysdig 是一个轻量级的系统监控工具，同时它还原生支持容器。通过 sysdig 我们可以近距离观察 linux 操作系统和容器的行为。&lt;/p&gt;
&lt;p&gt;Linux 上有很多常用的监控工具，比如 strace，tcpdump，htop， iftop，lsof ......&lt;/p&gt;
&lt;p&gt;而 sysdig 则是将这些工具的功能集成到一个工具中，并且提供一个友好统一的操作界面。&lt;/p&gt;
&lt;p&gt;下面我们将演示 sysdig 强大的监控能力。&lt;/p&gt;
&lt;p&gt;安装和运行 sysdig 的最简单方法是运行 Docker 容器，命令行为：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;docker container run -it --rm --name=sysdig --privileged=true \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/var/run/docker.sock:/host/var/run/docker.sock \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/dev:/host/dev \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/proc:/host/proc:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/boot:/host/boot:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/lib/modules:/host/lib/modules:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          --volume=/usr:/host/usr:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          sysdig/sysdig&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;可以看到，sysdig 容器是以&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;privileged&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;方式运行，而且会读取操作系统&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;/dev&lt;/span&gt;&lt;/code&gt;，&lt;code&gt;&lt;span&gt;/proc&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;等数据，这是为了获取足够的系统信息。&lt;/p&gt;
&lt;p&gt;启动后，通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker container exec -it sysdig bash&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;进入容器，执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;csysdig&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;命令，将以交互方式启动 sysdig。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730627071912.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730627071912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个类似 linux top 命令的界面，但要强大太多。sysdig 按不同的 View 来监控不同类型的资源，点击底部&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Views&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;span&gt;菜单（或者按 F2），显示 View 选择列表。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730418051587.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730418051587.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;界面左边列出了 sysdig 支持的 View，一共 30 多项，涵盖了操作系统的各个方面，因为这里主要是讨论容器监控，所以我们将光标移到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Containers&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这一项，界面右边立即显示出此 View 的功能介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;回车或者双击&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Containers&lt;/span&gt;&lt;/code&gt;，进入容器监控界面。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730637090026.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627730637090026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sysdig 会显示该 Host 所有容器的实时数据，每两秒刷新一次。各列数据的含义也是自解释的，如果不清楚，可以点一下底部&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Legend&lt;/span&gt;&lt;/code&gt;（或者按 F7）。如果想按某一列排序，比如按使用的内存量，很简单，点一下列头&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;VIRT&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731367099298.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731367099298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想看某个容器运行的进程，比如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;weavescope&lt;/span&gt;&lt;/code&gt;，将光标移到目标容器，然后回车或者双击。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731153030550.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731153030550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以继续双击查看进程中的线程。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731276033888.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627731276033888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回上一级，按退格键即可。&lt;/p&gt;
&lt;p&gt;sysdig 的交互功能很强，如果界面显示的条目很多，可以点击底部&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Search&lt;/span&gt;&lt;/code&gt;菜单，然后输入关键字进行查找。如下图，关键字为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;service&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627733376009111.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627733376009111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果觉得界面刷新太快，看不清楚关注的信息，可以点击底部&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pause&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;菜单。&lt;/p&gt;
&lt;p&gt;sysdig 的特点如下：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;监控信息全，包括 Linux 操作系统和容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界面交互性强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不过 sysdig 显示的是实时数据，看不到变化和趋势。而且是命令行操作方式，需要 ssh 到 Host 上执行，会带来一些不便。下一节介绍的 Weave Scope 在这方面似乎提供了更好的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 22:47:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7646995.html</dc:identifier>
</item>
<item>
<title>PE文件格式详解,第二讲,NT头文件格式,以及文件头格式 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7648683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7648683.html</guid>
<description>&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS:本篇博客默认你已经有了汇编基础,所以会使用32位汇编编写最小PE进行讲解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天详解NT 头格式,以及文件头格式,以及作用, 关于DOS头文件格式,以及DOSStub昨天的博客已经写过了.主要是分散讲解.便于理解.&lt;/p&gt;
&lt;h2&gt;一丶最小PE的生成,以及标准PE的生成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ps: (如果直接学习NT头,文件头,请不用看这个生成PE,直接看下面讲解即可)&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.标准PE的生成&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了便于学习PE文件格式,所以这里写出一个最小PE,还有一个最小的标准PE,让大家理解.&lt;/p&gt;
&lt;p&gt;32位汇编编写.(汇编是能编写最小PE的)&lt;/p&gt;
&lt;p&gt;首先我们先写一段基本的汇编代码,然后一层一层的优化&lt;/p&gt;
&lt;p&gt;32位汇编代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
.&lt;span&gt;386&lt;/span&gt;&lt;span&gt;
.model flat,stdcall
option &lt;/span&gt;&lt;span&gt;casemap:&lt;/span&gt;&lt;span&gt;none

include windows.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include user32.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include kernel32.&lt;/span&gt;&lt;span&gt;inc　　　　　　;包含各种lib库以及头文件&lt;/span&gt;&lt;span&gt;
includelib user32.lib
includelib kernel32.lib

.data
    g_szHello db &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,0dh,0ah,&lt;span&gt;00　　　　;定义Hello字符串&lt;/span&gt;&lt;span&gt;
.code
&lt;/span&gt;&lt;span&gt;start:&lt;/span&gt;&lt;span&gt;
  invoke MessageBoxA,NULL,offset g_szHello ,NULL,MB_OK ;弹出信息框
  invoke ExitProcess,&lt;/span&gt;&lt;span&gt;0　　　　;退出程序&lt;/span&gt;&lt;span&gt;
end start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单的汇编代码&lt;/p&gt;
&lt;p&gt;看下EXE的大小,以及内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171010211440949-835748159.png&quot; alt=&quot;&quot;/&gt;2.50KB有点大了.&lt;/p&gt;
&lt;p&gt;可以继续优化,但是比如手动敲命令行了.注意,这里使用的masm32的link连接器&lt;/p&gt;
&lt;p&gt;首先我们要去掉分区,因为这里的EXE主要是分区太多.所以去掉.&lt;/p&gt;
&lt;p&gt;怎么去掉? 只需要把上面的汇编代码修改一下即可.&lt;/p&gt;
&lt;p&gt;修改为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
.&lt;span&gt;386&lt;/span&gt;&lt;span&gt;
.model flat,stdcall
option &lt;/span&gt;&lt;span&gt;casemap:&lt;/span&gt;&lt;span&gt;none

include windows.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include user32.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include kernel32.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
includelib user32.lib
includelib kernel32.lib

.code
  g_szHello db &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,0dh,0ah,&lt;span&gt;00   ;将数据段的数据,放到代码区中&lt;/span&gt;
&lt;span&gt;start:&lt;/span&gt;&lt;span&gt;
  invoke MessageBoxA,NULL,offset g_szHello ,NULL,MB_OK
  invoke ExitProcess,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
end start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单,就是把.data去掉即可.&lt;/p&gt;
&lt;p&gt;这个就是标准PE了,看下文件大小.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171010212214012-496365991.png&quot; alt=&quot;&quot;/&gt;注意一下,这里我使用的是RadAsm集成开发环境,&lt;/p&gt;
&lt;p&gt;编译器是Masm32的link连接器. 如果使用VC6.0以及以上的,文件会变的很大,可能会有16.KB,28.KB,不利于大家学习.如果不会配置RadAsm集成开发环境,请参考以前的帖子.自己配置一下即可.&lt;/p&gt;
&lt;h3&gt;2.最小PE的生成&lt;/h3&gt;
&lt;p&gt; 区合并和内存对齐优化,生成最小PE(不通用)&lt;/p&gt;
&lt;p&gt;首先我们要知道PE中的区在哪里,以及怎么使内存对齐缩小,不至于让PE很大.&lt;/p&gt;
&lt;p&gt;首先看下我们的标准PE格式的二进制.(使用Winhex,或者010 Editor都可以)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171010213432199-1870178578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,生成的时候默认会为我们生成.const常量区,那么我们可以让它和代码区合并吗?&lt;/p&gt;
&lt;p&gt;注意,如果是别的程序,是不可以合并的,因为常量区很有用,但是如果生成最小PE那么你需要合并,&lt;/p&gt;
&lt;p&gt;最后一个Hello的位置,则是代码区&lt;/p&gt;
&lt;p&gt;手工连接,使其合并分区,变为最小PE&lt;/p&gt;
&lt;p&gt;命令行参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171010213649699-1349827397.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171010213713543-784312413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;/ALIGN:内存对齐(2的倍数即可,默认是4096)&lt;/p&gt;
&lt;p&gt;/MERGE: 区 = 区  (合并分区)&lt;/p&gt;
&lt;p&gt;例如link加上 写成下面这样&lt;/p&gt;
&lt;p&gt;/ALIGN:4 /MERGE:.rdata=.text&lt;/p&gt;
&lt;p&gt;手工编译连接看下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011002620512-135984214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过这样写还要另外加选项,不能保证她是否是能运行,不通用,所以使用标准pe讲解&lt;/p&gt;
&lt;h2&gt; 二丶NT头&lt;/h2&gt;
&lt;p&gt;首先看下NT头和文件头的结构体.&lt;/p&gt;
&lt;p&gt;NT头:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_NT_HEADERS {
    DWORD Signature;　　　　　　　　　　　　　　//4个字节的PE标志
    IMAGE_FILE_HEADER FileHeader;　　　　　　//文件头
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;//可选头
} IMAGE_NT_HEADERS32, &lt;/span&gt;*PIMAGE_NT_HEADERS32;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NT 头第一个成员,对应的是PE位置,4个字节.&lt;/p&gt;
&lt;p&gt;内存分布图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011003408496-326517269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里,建议大家使用010编辑器,可以使用自定义PE模版,解析PE各个位置内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011003553215-1006665952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面模版自动点击则可以解析&lt;/p&gt;
&lt;h2&gt;三丶文件头&lt;/h2&gt;
&lt;p&gt;文件头结构体:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_FILE_HEADER {
    WORD    Machine;　　　　　　　　　　　　　　　　 　　//机器型号,作用是区别这个exe是哪个CPU可以跑的.重要.
    WORD    NumberOfSections;　　　　　　　　　　  　　//节的数量  (可以理解为汇编中区的个数)现在我们有两个,一个.rdata 一个.text
    DWORD   TimeDateStamp;　　　　　　　　　　　　 　　//程序的编译时间,参考用,没有实际作用
    DWORD   PointerToSymbolTable;　　　　　　　　　　//符号表地址  我们使用的PDB文件(里面有函数吗什么的)都存放在这个表中,不过微软是单独生成的PDB文件,所以这个字段没用,主要是给别人用
    DWORD   NumberOfSymbols;　　　　　　　　　　 　　//符号表大小
    WORD    SizeOfOptionalHeader;　　　　　　　 　　//可选头大小,这个字段很重要.因为要通过这个字段,才知道可选头是多大,而不懂PE的人求选项头都是用sizeof()求出来的.所以真正的选项头大小要靠这个字段
    WORD    Characteristics;　　　　　　　　　　　　//文件属性,描述文件信息的.
} IMAGE_FILE_HEADER, &lt;/span&gt;*PIMAGE_FILE_HEADER;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面只是简单的写了下各个成员的作用.&lt;/p&gt;
&lt;p&gt;在这里需要注意的是   可选头大小,文件属性,以及机器型号.  其余的自己看看.&lt;/p&gt;
&lt;h3&gt;1.机器型号:&lt;/h3&gt;
&lt;p&gt;机器型号,在PE中的定义,在VC++6.0中已经给出了.&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_UNKNOWN           0
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_I386              0x014c  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Intel 386.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_R3000             0x0162  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS little-endian, 0x160 big-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_R4000             0x0166  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS little-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_R10000            0x0168  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS little-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS little-endian WCE v2&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_ALPHA             0x0184  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alpha_AXP&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_POWERPC           0x01F0  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IBM PowerPC Little-Endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_SH3               0x01a2  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SH3 little-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_SH3E              0x01a4  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SH3E little-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_SH4               0x01a6  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SH4 little-endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_ARM               0x01c0  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ARM Little-Endian&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_THUMB             0x01c2
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_IA64              0x0200  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Intel 64&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_MIPS16            0x0266  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_MIPSFPU           0x0366  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MIPS&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_MACHINE_ALPHA64           0x0284  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ALPHA64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下PE中怎么存储的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011004406855-371503698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照小尾方式,则是 0x014C ,那么对应上面的宏则是386的程序(看注释),而我们的汇编编译出来的标准PE也正是标准PE,如果学习PE,自己可以去看下PE存储&lt;/p&gt;
&lt;h3&gt;2.可选头大小&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011004736527-464195155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个地方是我计算偏移得出,根据结构体的类型大小,可以自己计算偏移得出.&lt;/p&gt;
&lt;p&gt;可以看出,可选头的大小是0x00E0 大小,换算成10进制就可以知道,E0是224字节大小,所以根据这个,可以计算出可选头大小&lt;/p&gt;
&lt;h3&gt;3.文件属性&lt;/h3&gt;
&lt;p&gt; 文件属性紧跟在E0 00 后面,它是0F 01&lt;/p&gt;
&lt;p&gt;文件属性是按照位来的.&lt;/p&gt;
&lt;p&gt;什么意思?&lt;/p&gt;
&lt;p&gt;先看下宏定义:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_RELOCS_STRIPPED           0x0001  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Relocation info stripped from file.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; File is executable  (i.e. no unresolved externel references).&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Line nunbers stripped from file.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Local symbols stripped from file.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Agressively trim working set&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; App can handle &amp;gt;2gb addresses&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_BYTES_REVERSED_LO         0x0080  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bytes of machine word are reversed.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_32BIT_MACHINE             0x0100  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 32 bit word machine.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_DEBUG_STRIPPED            0x0200  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Debugging info stripped from file in .DBG file&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If Image is on removable media, copy and run from the swap file.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If Image is on Net, copy and run from the swap file.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_SYSTEM                    0x1000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; System File.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_DLL                       0x2000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; File is a DLL.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; File should only be run on a UP machine&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_FILE_BYTES_REVERSED_HI         0x8000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bytes of machine word are reversed.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先按照小尾方式查看.&lt;/p&gt;
&lt;p&gt;0x010f&lt;/p&gt;
&lt;p&gt;那么先看第一个1,不看后面的,找百位为1的那么就是 0x100 在上面则可以找到对应的宏,它的注释是: &lt;/p&gt;
&lt;pre&gt;
32 bit word machine. 代表了他是一个32位程序&lt;br/&gt;那么看个位是F,那么就找F,但是需要注意,他因为是位运算,所以是 | 连接起来了,那么F 代表了
&lt;/pre&gt;
&lt;pre&gt;
0x0001  | 0x0002 | 0x0004 | 0x0008  那么分别就对应前4个宏&lt;br/&gt;那么最终想要表示的结果是
&lt;/pre&gt;
&lt;pre&gt;
32 bit word machine.
&lt;/pre&gt;
&lt;pre&gt;
Relocation info stripped from file.
&lt;/pre&gt;
&lt;pre&gt;
File is executable  (i.e. no unresolved externel references)
&lt;/pre&gt;
&lt;pre&gt;
Line nunbers stripped from file
&lt;/pre&gt;
&lt;pre readability=&quot;22.305068226121&quot;&gt;
Local symbols stripped from file.&lt;p&gt;翻译过来就是 这是一个32位程序,是一个可执行程序....&lt;br/&gt;那么训练一下,我随便写一个&lt;br/&gt;0x2102&lt;br/&gt;那么 按照 个 十 百 千 位去寻找&lt;br/&gt;先找千位　　 0x2000  // File is a DLL.  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　说明这是一个DLL文件&lt;br/&gt;再找百位　　 0x100　　// 32 bit word machine.　　　　　　　　　　　　　　　　　　　　　　　　　　　    说明是一个32位可执行程序&lt;br/&gt;再找十位　　 十位为零,则没有.&lt;br/&gt;再找个位　　 0x0002  // File is executable  (i.e. no unresolved externel references).　　　　　说明是一个可执行程序&lt;br/&gt;那么总结一下,说明了这个文件是一个 DLL文件,是一个32位程序,是一个可执行程序&lt;/p&gt;&lt;p&gt;总的来说很简单,主要是熟练运用,在不使用工具的前提下,明白各个位置代表的作用&lt;/p&gt;&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)
&lt;/p&gt;&lt;/pre&gt;</description>
<pubDate>Tue, 10 Oct 2017 17:14:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7648683.html</dc:identifier>
</item>
<item>
<title>【DDD】领域驱动设计实践 —— Domain层实现 - 倒骑的驴</title>
<link>http://www.cnblogs.com/daoqidelv/p/7648392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daoqidelv/p/7648392.html</guid>
<description>&lt;p&gt;       本文是DDD框架实现讲解的第三篇，主要介绍了DDD的Domain层的实现，详细讲解了entity、value object、domain event、domain service的职责，以及如何识别出领域中的这些对象，并附有具体的业务建模示例。相比于《领域驱动设计》原书中的航运系统例子，社交服务系统的业务场景对于大家更加熟悉，相信更好理解。本文是【DDD】系列文章的其中一篇，其他可参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/daoqidelv/p/7492322.html&quot;&gt;使用领域驱动设计思想实现业务系统&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　Domain层是具体的业务领域层，是发生业务变化最为频繁的地方，是业务系统最核心的一层，是DDD关注的焦点和难点。这一层包含了如下一些domain object：entity、value object、domain event、domain service、factory、repository等。DDD实践的难点其实就在于如何识别这些object。下面将一一说明他们。&lt;/p&gt;

&lt;p&gt; 　　领域实体是domain的核心成员。domain entity具有如下三个特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;唯一业务标识&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持有自己的业务属性和业务行为&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性可变，有着自己的生命周期&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　 在社区这一业务领域中，‘帖子’就是一个业务实体，它需要有一个唯一性业务标识表征，拥有这个业务实体相关的业务属性（作者、标题、内容等）和业务行为（关联话题、删帖等），同时他的状态和内容可以不断发生变化。&lt;/p&gt;
&lt;p&gt;　　 示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post {
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    * 帖子id
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、‘帖子’实体有唯一业务标识&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *帖子作者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; authorId;    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子标题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String title;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、‘帖子’实体拥有自己的业务属性&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子源内容
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sourceContent;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 发帖时间
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Timestamp postingTime;    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子状态
     * NOTE：使用enum实现，限定status的字典值
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; com.dqdl.community.domain.model.post.PostStatus
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PostStatus status;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子作者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PostAuthor postAuthor;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子加入的话题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Set&amp;lt;TopicPost&amp;gt; topics = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;TopicPost&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Post() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.postingTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timestamp(System.currentTimeMillis());        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Post(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setId(id);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Post(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; authorId, String title, String sourceContent) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setAuthorId(authorId);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setTitle(title);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setSourceContent(sourceContent);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setPostAuthor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PostAuthor(authorId));
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除帖子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setStatus(PostStatus.HAS_DELETED);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、帖子的状态可以改变&lt;/span&gt;
&lt;span&gt;    }
        
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将帖子关联话题 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; topicIds 话题集合
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; joinTopics(String topicIds) &lt;span&gt;throws&lt;/span&gt; BusinessException{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、‘帖子’实体拥有自己的业务行为&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isEmpty(topicIds)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        String[] topicIdArray &lt;/span&gt;=&lt;span&gt; topicIds.split(CommonConstants.COMMA);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;topicIdArray.length; i++&lt;span&gt;) {
            TopicPost topicPost &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TopicPost(Long.valueOf(topicIdArray[i]), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getId());
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.topics.add(topicPost);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(topicSize() &amp;gt;&lt;span&gt; MAX_JOINED_TOPICS_NUM) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BusinessException(ReturnCode.ONE_POST_MOST_JOIN_INTO_FIVE_TOPICS);
            }
        }
    }&lt;br/&gt;//......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;       领域值对象。value object是相对于domain entity来讲的，对照起来value object有如下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可以有唯一业务标识 &lt;/strong&gt; &lt;em&gt;  【区别于domain entity】&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持有自己的业务属性和业务行为&lt;/strong&gt; &lt;em&gt;【同domain entity】&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一旦定义，他是不可变的，它通常是短暂的&lt;/strong&gt;&lt;span&gt;，这和java中的值对象（基本类型和String类型）类似 &lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;em&gt;【区别于domain entity】&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如社区业务领域中，‘帖子的置顶信息’可以理解为是一个值对象，不需要为这一值对象定义独立的业务唯一性标识，直接使用‘帖子id‘便可表征，同时，它只有’置顶状态‘和’置顶位置‘，一旦其中一个属性需要发生变化，则重建值对象并赋值给’帖子‘实体的引用，不会对领域带来任何负面影响。&lt;/p&gt;
&lt;p&gt;　　代码示例：（TODO：关于PostTopInfo 这个value object的使用，示例代码中暂未涉及。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 帖子置顶消息，value object
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; daoqidelv
 * @createdate 2017年10月10日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PostTopInfo {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 帖子id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; postId;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 置顶标志。true -- 置顶， false -- 不置顶。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isTop;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 置顶位置，当isTop == true时，该字段有意义。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; topIndex;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PostTopInfo(&lt;span&gt;long&lt;/span&gt; postId, &lt;span&gt;boolean&lt;/span&gt; isTop, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; topIndex) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setPostId(postId);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setTop(isTop);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setTopIndex(topIndex);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getPostId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; postId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPostId(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; postId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.postId =&lt;span&gt; postId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isTop() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; isTop;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTop(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isTop) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isTop =&lt;span&gt; isTop;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTopIndex() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; topIndex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTopIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; topIndex) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.topIndex =&lt;span&gt; topIndex;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 　　领域服务。区别于应用服务，他属于业务领域层。可以认为，如果某种行为无法归类给任何实体/值对象，则就为这些行为建立相应的领域服务即可。传统意义上的util static方法中，涉及到业务逻辑的部分，都可以考虑归入domain service。&lt;/p&gt;
&lt;p&gt;　　比如：‘社区’这一业务领域中的‘内容过滤’这一模块，便是领域服务，他不只属于Post实体，还会被用于评论（Comment）实体中，故我们将他独立成domain service。&lt;/p&gt;
&lt;p&gt;　　domain service的实现和使用的示例代码请参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/daoqidelv/p/7533067.html&quot;&gt;【DDD】业务建模实践 —— 发布帖子&lt;/a&gt; 中的‘示例代码’这一节。&lt;/p&gt;

&lt;p&gt; 　　领域事件。领域中产生的一些消息事件，可以在性能和解耦层面得到好处。我们通常借助于消息中间件，通过事件通知/订阅的方式落地。&lt;/p&gt;
&lt;p&gt;　　在‘社区’业务领域中，‘发帖’之后，会同时为帖子作者生成一个‘发帖动态’，这个‘生成发帖动态’场景并不同步完成，而是通过领域事件发布异步完成。‘发帖’创建Post实体后，发布一个‘发帖动态’领域事件（PostingDynamic），‘动态’（Dynamic）相关服务消费该领域事件，并生成Dynamic实体。&lt;/p&gt;
&lt;p&gt;　　示例代码暂未给出。&lt;/p&gt;

&lt;p&gt; 　　领域对象工厂。用于复杂领域对象的创建/重建。重建是指通过respostory加载持久化对象后，重建领域对象。&lt;/p&gt;
&lt;p&gt;　　示例代码中暂未涉及，试实际情况而定是否引入factory。&lt;/p&gt;

&lt;p&gt;　　仓库。我们将仓库的接口定义归类在domain层，因为他和domain entity联系紧密。仓库接口定义了和基础实施的持久化层交互契约，完成领域对应的增删改查操作。domain层的repository只是定义契约的接口，实际实现仍然由infrastructure完成。&lt;/p&gt;
&lt;p&gt;　　仓库的实际实现根据不同的存储介质而不同，可以是redis、oracle、mongodb等。具体仓库的实现会讲给infrastructure层完成，我们会在下一篇blog中详细阐述repository的实现。&lt;/p&gt;
&lt;p&gt;　　对于repository的接口定义，建议规范接口名命名，比如：查询都叫着query等等，减小沟通成本。&lt;/p&gt;
&lt;p&gt;　　示例代码只包含了‘社区’领域模型中Post实体相关的repository接口定义，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPostRepository {
    
    Post query(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; postId);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; save(Post post);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; delete(Post post);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　接下来附上‘社区’业务领域中‘帖子’实体建模过程的blog，讲述了如何通过不断迭代完善业务模型，希望对你有用：&lt;/p&gt;

&lt;p&gt;　　此demo的代码已上传至github，欢迎下载和讨论，但拒绝被用于任何商业用途。&lt;/p&gt;
&lt;p&gt;　　github地址：https://github.com/daoqidelv/community-ddd-demo/tree/master&lt;/p&gt;
&lt;p&gt;　　branch：master&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 15:57:00 +0000</pubDate>
<dc:creator>倒骑的驴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daoqidelv/p/7648392.html</dc:identifier>
</item>
<item>
<title>Hadoop（二）搭建伪分布式集群 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7647686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7647686.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面只是大概介绍了一下Hadoop，现在就开始搭建集群了。我们下尝试一下搭建一个最简单的集群。之后为什么要这样搭建会慢慢的分享，先要看一下效果吧！&lt;/p&gt;

&lt;h2&gt;1.1、单机模式（独立模式）（Local或Standalone  Mode）&lt;/h2&gt;
&lt;p&gt;　　-默认情况下，Hadoop即处于该模式，用于开发和调式。&lt;/p&gt;
&lt;p&gt;　　-不对配置文件进行修改。&lt;br/&gt;　　-使用&lt;span&gt;本地文件系统，而不是分布式文件系统&lt;/span&gt;。&lt;br/&gt;　　-Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，&lt;span&gt;Map()和Reduce()任务作为同一个进程的不同部分来执行的&lt;/span&gt;。&lt;br/&gt;　　-用于&lt;span&gt;对MapReduce程序的逻辑进行调试，确保程序的正确&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;1.2、伪分布式模式（Pseudo-Distrubuted Mode）&lt;/h2&gt;
&lt;p&gt;　　-Hadoop的守护进程运行在本机机器，模拟一个小规模的集群　&lt;/p&gt;
&lt;p&gt;　　-在&lt;span&gt;一台主机模拟多主机&lt;/span&gt;。&lt;br/&gt;　　-Hadoop&lt;span&gt;启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程&lt;/span&gt;。&lt;br/&gt;　　-在这种模式下，Hadoop使用的是&lt;span&gt;分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程&lt;/span&gt;。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，&lt;/p&gt;
&lt;p&gt;　　　　以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。&lt;br/&gt;　　-修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性）&lt;br/&gt;　　-格式化文件系统&lt;/p&gt;
&lt;h2&gt;1.3、全分布式集群模式（Full-Distributed Mode）&lt;/h2&gt;
&lt;p&gt;　　-Hadoop的守护进程运行在一个集群上　&lt;/p&gt;
&lt;p&gt;　　-Hadoop的&lt;span&gt;守护进程运行在由多台主机搭建的集群上，是真正的生产环境&lt;/span&gt;。&lt;br/&gt;　　-在所有的主机上&lt;span&gt;安装JDK和Hadoop，组成相互连通的网络&lt;/span&gt;。&lt;br/&gt;　　-在主机间&lt;span&gt;设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表&lt;/span&gt;。&lt;br/&gt;　　-修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数&lt;br/&gt;　　-格式化文件系统&lt;/p&gt;

&lt;p&gt;环境：在ubuntu17.04&lt;/p&gt;
&lt;p&gt;　　　　jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;　　　　hadoop 2.8.1&lt;/p&gt;
&lt;h2&gt;2.1、能够正常运行的Ubuntu操作系统&lt;/h2&gt;
&lt;p&gt;　　在Ubuntu下，软件安装到/opt下，当前正在使用的用户，对于opt目录需要有读写权限：　&lt;/p&gt;
&lt;p&gt;　　1）将opt的权限给为777（漏洞文件），不推荐在生产环境中使用。但是可以在学习和调试环境中使用。　　　　　&lt;/p&gt;
&lt;p&gt;　　2）sudo&lt;/p&gt;
&lt;p&gt;　　　　在启动Hadoop的各个守护进程的时候，需要使用sudo。&lt;br/&gt;　　　　在管理Hadoop的时候，实际上由不同的用户启动不同集群的守护进程。&lt;br/&gt;　　　　统一使用当前的用户管理所有集群。&lt;/p&gt;
&lt;p&gt;　　3）该目录的所有者设置为当前用户&lt;/p&gt;
&lt;h2&gt;2.2、安装JDK，并配置环境变量&lt;/h2&gt;
&lt;p&gt;　　1）将jdk安装包放在家目录下&lt;/p&gt;
&lt;p&gt;　　2）解压到opt目录下&lt;/p&gt;
&lt;p&gt;　　　　sudo tar zxvf jdk-8u131-linux-x64.tar.gz -C /opt&lt;/p&gt;
&lt;p&gt;　　　　此时在/opt目录下：会有一个jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;　　3）创建软链接&lt;/p&gt;
&lt;p&gt;　　　　sudo ln -snf /opt/jdk1.8.0_131 /opt/jdk&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010210840355-2051409448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：创建软连接的目的是为了，我们在做项目的时候，可能会用到不同的jdk版本，这是要换软件的话，只需要修改软链接就可以了。而不用修改配置文件。&lt;/p&gt;
&lt;p&gt;　　4）配置环境变量　　　&lt;/p&gt;
&lt;p&gt;　　　　局部环境变量：~/.bashrc&lt;br/&gt;　　　　全局环境变量：/etc/profile&lt;br/&gt;　　　　export JAVA_HOME=/opt/jdk&lt;br/&gt;　　　　export JRE_HOME=$JAVA_HOME/jre&lt;br/&gt;　　　　export CLASSPATH=.:$JAVA_HOME/lib&lt;br/&gt;　　　　export PATH=$PATH:$JAVA_HOME/bin&lt;/p&gt;
&lt;p&gt;　　　　source 相关文件（更新配置文件）&lt;/p&gt;
&lt;p&gt;　　5）查看是否安装成功&lt;/p&gt;
&lt;p&gt;　　　java、javac、java -version&lt;/p&gt;

&lt;h2&gt;3.1、安装hadoop&lt;/h2&gt;
&lt;p&gt;　　1）解压hadoop安装包到opt目录下&lt;/p&gt;
&lt;p&gt;　　　　sudo  tar zxvf hadoop-2.8.1.tar.gz -C /opt&lt;/p&gt;
&lt;p&gt;　　2）创建软链接&lt;/p&gt;
&lt;p&gt;　　　　ln -snf /opt/hadoop-2.8.1   /opt/hadoop　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211309324-431154157.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）配置环境变量　　&lt;/p&gt;
&lt;p&gt;　　　　在/etc/profile文件中加入以下内容：&lt;br/&gt;　　　　export HADOOP_HOME=/opt/hadoop&lt;br/&gt;　　　　export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin&lt;br/&gt;　　　　source /etc/profile&lt;/p&gt;
&lt;p&gt;　　4）使用hadoop version命令测试是否配置成功&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211424777-870467980.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2、配置hadoop&lt;/h2&gt;
&lt;p&gt;　　配置文件存放在/opt/hadoop/etc/hadoop中有n多个文件，暂时我们只需要修改的只有5个&lt;/p&gt;
&lt;p&gt;　　1）hadoop-env.sh&lt;/p&gt;
&lt;p&gt;　　　　大约在25行左右　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　export JAVA_HOME=${JAVA_HOME}改成export JAVA_HOME=/opt/jdk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211938887-441968715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：在配置文件中有提示我们怎么设置，我们一般不删除，二回选择注释它的提示。&lt;/p&gt;
&lt;p&gt;　　2）core-site.xml　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　　　&amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.0.0.5:9000&amp;lt;/value&amp;gt;   &lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212345871-1121339163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：1.0.0.5是你主节点所在主机的ip，而9000为端口&lt;/p&gt;
&lt;p&gt;　　3）hdfs-site.xml　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;hadoop-cluster&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/nn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;&lt;span&gt;dfs.namenode.ch
                    eckpoint.dir&lt;/span&gt;&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.namenode.checkpoint.edits.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/dn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212523715-657867265.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）mapred-site.xml&lt;/p&gt;
&lt;p&gt;　　　　在hadoop的相关目录中没有此文件，但是有一个mapred-site.xml.template文件，将该文件复制一份为mapred-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　cp mapred-site.xml.template mapred-site.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212728262-586427381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）yarn-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;!-- 指定ResourceManager的地址--&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;0.5&lt;/span&gt;&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;!-- 指定reducer获取数据的方式--&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.nodemanager.local-dirs&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/yarn/nm&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212905699-2115750669.png&quot; alt=&quot;&quot; width=&quot;432&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7）创建相关目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        sudo mkdir -p /data/hadoop/hdfs/&lt;span&gt;nn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;dn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;snn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/yarn/nm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　注意：　　&lt;/p&gt;
&lt;p&gt;　　　　如果&lt;span&gt;使用sudo启动hadoop的相关进程，这几目录的权限可以不用管&lt;/span&gt;。&lt;br/&gt;　　　　如果是&lt;span&gt;使用当前的用户启动相关进程，对于opt目录，当前用户得有读写权限，对于/data目录也需要读写权限&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　遇到问题：&lt;/p&gt;
&lt;p&gt;　　　　　　笔者就是在这个目录权限的问题吃el很大得亏。首先为了不使用sudo我将/data目录的权限修改为777，然后进行&lt;/p&gt;
&lt;p&gt;　　　　　　HDFS集群格式化的时候，出现：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010213351309-1503138602.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　这时我在想为什么呢？原来我只是给data目录设置了读写权限，但是没有给它的子目录设置读写权限。所以：　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　　　　　chmod -R &lt;span&gt;777&lt;/span&gt; /data    递归设置权限
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8）对HDFS集群进行格式化，HDFS集群是用来存储数据的。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　hdfs namenode -format
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3、启动集群&lt;/h2&gt;
&lt;p&gt;　　1）启动HDFS集群　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　hadoop-daemon.sh start namenode 启动主节点&lt;br/&gt;　　　　hadoop-daemon.sh start datanode 启动从节点&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214239918-1067025019.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）启动YARN集群&lt;/p&gt;
&lt;p&gt;　　　　yarn-daemon.sh start resourcemanager&lt;br/&gt;　　　　yarn-daemon.sh start nodemanager&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214358668-7481029.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）启动作业历史服务器&lt;/p&gt;
&lt;p&gt;　　　　mr-jobhistory-daemon.sh start historyserver&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214508637-1286314807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）jps命令查看是否启动成功&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214544090-1756410260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）HDFS和YARN集群都有相对应的WEB监控页面&lt;/p&gt;
&lt;p&gt;　　　　HDFS：http://ip:50070&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214721105-1362648307.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　YARN：http://ip:8088&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214857324-806088798.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6）HDFS集群的简单操作命令&lt;/p&gt;
&lt;p&gt;　　　　hdfs dfs -ls /&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010215935293-1929086326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　hdfs dfs -mkdir -p /user/zyh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010220056621-281989886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7） YARN集群的操作----提交任务/作业&lt;/p&gt;
&lt;p&gt;　　　　计算PI值的作业：&lt;br/&gt;　　　　yarn jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.1.jar pi 4 100&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010220350934-750510351.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我之前没有注意发现我的yarn的从节点没有启动起来，在执行计算PI值的时候没有成功才看到：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225330934-888154571.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看日志发现是配置文件：&lt;/p&gt;
&lt;p&gt;　　在hdfs-site-web.xml中：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225646043-2033598849.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看http://1.0.0.5:50070可以查看从节点是否启动：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225929902-90790098.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在执行上面使用yarn集群来计算pi值得命令：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010230147246-1473267315.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看http://1.0.0.5:8088可以看出计算pi值得任务正在执行：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010230032137-1249088310.png&quot; alt=&quot;&quot; width=&quot;993&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后成功：&lt;/p&gt;
&lt;p&gt;　　　　　这里就截图了，电脑卡住了，上图中在web页面可以查看到任务执行成功，终端中会显示执行结果！　　　　　&lt;/p&gt;

&lt;p&gt;喜欢就点“推荐”哦！&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 15:07:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7647686.html</dc:identifier>
</item>
<item>
<title>设计模式 5/23 原型模式 - Lionel Andrés Messi</title>
<link>http://www.cnblogs.com/LionelMessi/p/7597803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LionelMessi/p/7597803.html</guid>
<description>&lt;p&gt;原型模式，一个深入浅出，检验你对基础知识了解的是否透彻的一个设计模式。&lt;/p&gt;
&lt;p&gt;之所以这样定义，因为我栽了个跟头&lt;/p&gt;
&lt;p&gt;想要吃透原型模式，就得深入理解 浅拷贝，深拷贝&lt;/p&gt;
&lt;p&gt;想要深入吃透 浅拷贝，深拷贝&lt;/p&gt;
&lt;p&gt;我们就要对 值类型 和 引用类型 有较深的认识&lt;/p&gt;
&lt;p&gt;如果对 值类型 和 引用类型 有了较深的认识，在GC也至少有一定的修为了&lt;/p&gt;
&lt;p&gt;..........我还能继续这样写下去很多，所以有开头的那句话，原型模式，一个深入浅出，检验你对基础知识了解的是否透彻的一个设计模式。&lt;/p&gt;

&lt;p&gt;对值类型 和 引用类型 的浅薄的 入门，可以参考 几年前写的 &lt;a href=&quot;http://www.cnblogs.com/LionelMessi/p/4314370.html&quot; target=&quot;_blank&quot;&gt;面试前的准备---C#知识点回顾----02&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有一些基础知识的介绍,可以作为了解 浅拷贝 和 深拷贝的铺垫&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了，看黑板!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：指的是拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，你有一张光盘，你进行了多次刻录，产生了第二张，第三者光盘，那这三种光盘是相互独立的，第一张损坏或第二张损坏，都不会影响到第三张【光盘，会不会暴露年龄啊】。在.NET领域，值对象就是典型的例子，如int, Double以及结构体和枚举等。具体例子如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ece5c375-fedd-43c7-b296-667860a7cc35')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ece5c375-fedd-43c7-b296-667860a7cc35',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;int&lt;/span&gt; source = &lt;span&gt;11&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值类型赋值内部执行深拷贝&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; copy =&lt;span&gt; source;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对拷贝对象进行赋值不会改变源对象的值&lt;/span&gt;
            copy = &lt;span&gt;22&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时source仍然为11
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样对源对象赋值也不会改变拷贝对象的值&lt;/span&gt;
            source = &lt;span&gt;33&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时copy 仍然为22            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 怎么实现深拷贝，可以最原始的一个一个赋值，但也可以用反射或反序列化方式来实现，因人而异，具体根据具体需求定，寻找代码最合适的方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：指的是拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。此时，其中一个对象的改变都会影响到另一个对象。其实我们自己经常浅拷贝，在家，你是个宝宝的身份，在学校，你是学生的身份，在公司面前，你是职员，但如果你生病了，那么你所有身份都会生病，全都反应在你这个实体身上。在.NET中引用类型就是一个例子。如类类型。具体例子如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ca861ab6-86fd-4121-a253-0db8ae9d2710')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ca861ab6-86fd-4121-a253-0db8ae9d2710',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
 Person you = &lt;span&gt;new&lt;/span&gt; Person() { Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            Person schoolP &lt;/span&gt;= you; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 浅拷贝&lt;/span&gt;
            schoolP.Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝对象改变Info值&lt;/span&gt;
            Person familyP =&lt;span&gt; you;
            familyP.Info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宝宝&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Person emp &lt;/span&gt;=&lt;span&gt; you;
            emp.Info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;职员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 突然你生病了&lt;/span&gt;
            you.Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生病了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;schoolP.Info: {0}；familyP.Info: {1}；emp.Info:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, schoolP.Info, familyP.Info, emp.Info);
            Console.Read();


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Info { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;重点！！！在C#中，浅拷贝的实现方式很简单，.NET自身也提供了实现，只需要实现接口 : ICloneable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET中值类型默认是深拷贝的，而对于引用类型，默认实现的是浅拷贝。&lt;strong&gt;所以对于类中引用类型的属性改变时，其另一个对象也会发生改变。当某个类的实例有个字段是值类型，那么实际该字段会和类的实例保持在同一个地方，即堆上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此次载的跟头就是在，让我痛定思痛的记住了，类都是引用类型&lt;/p&gt;

&lt;p&gt;有了前面的铺垫，我们来看看原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点再次来临，2点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.前半句告诉你原型还得自己建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.后半句指点你，剩下的对象可以通过拷贝实现。具体是深拷贝还是浅拷贝，根据你的需求来定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，来品味下原型模式&lt;/p&gt;
&lt;p&gt;在 War3 ，魔兽争霸[再次暴露年龄], 大海龟地图中有4个点位有野怪，这些野怪组成由 1个大海龟，2个小海龟组成，都是海龟，他们的差别是伤害输出的不同。&lt;/p&gt;
&lt;p&gt;我们来看看怎么画这个图&lt;/p&gt;
&lt;p&gt;先定义野怪，因为在地图中，除了海归，还有其他野怪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('48140130-99f5-49c8-aa20-9e360af3ef17')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('48140130-99f5-49c8-aa20-9e360af3ef17',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 敌人，野怪
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Enemy : ICloneable
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Enemy(Location location, &lt;span&gt;int&lt;/span&gt; power, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; speed)
        {
            Location &lt;/span&gt;=&lt;span&gt; location;
            Power &lt;/span&gt;=&lt;span&gt; power;
            Speed &lt;/span&gt;=&lt;span&gt; speed;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出生点位
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Location Location { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 攻击力[1~10 越来越强]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Power { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 行动速度[1~10 越来越快]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Speed { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 深拷贝
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Enemy DeepClone();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 浅拷贝
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Clone()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.MemberwiseClone();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这是出生点位类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fce33373-9bc8-4703-82b2-b0c0736b3435')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fce33373-9bc8-4703-82b2-b0c0736b3435',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出生点位
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Location
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 横坐标
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; X;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 纵坐标
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Y;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Location(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
        {
            X &lt;/span&gt;=&lt;span&gt; x;
            Y &lt;/span&gt;=&lt;span&gt; y;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;再定义海归野怪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e0e27e0b-925e-49e4-9fce-0a90374ccfe7')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e0e27e0b-925e-49e4-9fce-0a90374ccfe7',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 海龟
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeaTurtle : Enemy
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SeaTurtle(Location location, &lt;span&gt;int&lt;/span&gt; power, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; speed)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(location, power, speed)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Enemy DeepClone()
        {
            MemoryStream memoryStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
            BinaryFormatter formatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryFormatter();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化成流&lt;/span&gt;
            formatter.Serialize(memoryStream, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            memoryStream.Position &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化成对象&lt;/span&gt;
            SeaTurtle seaTurtle =&lt;span&gt; (SeaTurtle)formatter.Deserialize(memoryStream);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seaTurtle;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是海龟，攻击力:{0},速度:{1},出生点位:{2},{3}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Power, Speed, Location.X, Location.Y);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;比如我们现在要生成一组野怪，我们看看怎么用原型模式实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4b8e8a6b-bc8b-4198-9e43-2d65324e07b6')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4b8e8a6b-bc8b-4198-9e43-2d65324e07b6',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Location seaTurtleLocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Location(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大海龟出生&lt;/span&gt;
            SeaTurtle bigSeaTurtle = &lt;span&gt;new&lt;/span&gt; SeaTurtle(seaTurtleLocation, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;照着大海龟 拷贝一个小海龟  A &lt;/span&gt;
            Enemy smallSeaTurtleA =&lt;span&gt; (SeaTurtle)bigSeaTurtle.DeepClone();
            smallSeaTurtleA.Location.X &lt;/span&gt;= seaTurtleLocation.X + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            smallSeaTurtleA.Power &lt;/span&gt;= bigSeaTurtle.Power / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再直接copy小海龟A 拷贝一个小海龟  B   &lt;/span&gt;
            Enemy smallSeaTurtleB =&lt;span&gt; (SeaTurtle)smallSeaTurtleA.DeepClone();
            smallSeaTurtleB.Location.X &lt;/span&gt;= seaTurtleLocation.X - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            bigSeaTurtle.Show();
            smallSeaTurtleA.Show();
            smallSeaTurtleB.Show();
            Console.ReadLine();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最终的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
我是海龟，攻击力:&lt;span&gt;10&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
我是海龟，攻击力:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
我是海龟，攻击力:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在Enemy类中实现了接口ICloneable，大家可以试试用Clone方法会得到什么效果 &lt;/p&gt;

&lt;p&gt;总结下&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;用于创建重复的对象，同时又能保证性能，同时，我们还可以不用构造方法&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。&lt;/p&gt;
&lt;p&gt;2、逃避了构造函数的约束，如果我们的构造方法有约定，那因为可以不用到构造方法，所以我们逃避了约定&lt;/p&gt;

&lt;p&gt;以上就是关于 原型模式 的分享&lt;/p&gt;
&lt;p&gt;你们的支持是我写作的动力源泉，请不要吝啬你的点赞，谢谢&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 15:04:00 +0000</pubDate>
<dc:creator>Lionel Andr&amp;#233;s Messi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LionelMessi/p/7597803.html</dc:identifier>
</item>
<item>
<title>Spring读书笔记——bean加载 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</guid>
<description>&lt;p&gt;我们的日常开发几乎离不开Spring，他为我们的开发带来了很大的便捷，那么Spring框架是如何做到方便他人的呢。今天就来说说bean如何被加载加载。&lt;/p&gt;
&lt;p&gt;我们在xml文件中写过太多类似这样的bean声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;jsonParser&quot; class=&quot;com.jackie.json.FastjsonJsonParser&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这样的声明是如果被Spring读取并加载的呢？&lt;/p&gt;
&lt;h3 id=&quot;defaultlistablebeanfactory&quot;&gt;DefaultListableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
      implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是DefaultListableBeanFactory类源码的声明，集成了父类AbstractAutowireCapableBeanFactory以及实现了接口&lt;br/&gt;ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable（且不管这些又长有难懂的父类和父接口都是干什么的）&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/619240/201710/619240-20171010225719480-1219586878.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是DefaultListableBeanFactory的所有依赖父类，可以看到最顶层使我们熟悉的Object类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地位&lt;/strong&gt;&lt;br/&gt;DefaultListableBeanFactory类是整个bean加载的核心部分。后面我们要说到的XmlBeanFactory就是DefaultListableBeanFactory的子类。&lt;/p&gt;
&lt;h3 id=&quot;xmlbeanfactory&quot;&gt;XmlBeanFactory&lt;/h3&gt;
&lt;p&gt;XmlBeanFactory是DefaultListableBeanFactory的子类。其与DefaultListableBeanFactory类的不同之处通过看源码就会发现，XmlBeanFactory使用了自定义的XmlBeanDefinitionReader用于读取xml文件内容。&lt;/p&gt;
&lt;p&gt;XmlBeanFactory的源码并不复杂&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

   private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


   /**
    * Create a new XmlBeanFactory with the given resource,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource) throws BeansException {
      this(resource, null);
   }

   /**
    * Create a new XmlBeanFactory with the given input stream,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @param parentBeanFactory parent bean factory
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
      super(parentBeanFactory);
      this.reader.loadBeanDefinitions(resource);
   }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有两个构造函数&lt;/li&gt;
&lt;li&gt;两个构造函数都有参数Resource，我们在调用前可以通过各种实现比如&lt;code&gt;new ClassPathResource(&quot;application-context.xml&quot;)&lt;/code&gt;的方式传值&lt;/li&gt;
&lt;li&gt;Resource有很多实现比如 文件（FileSystemResource）、URL资源（UrlResource）、InputStream资源（InputStreamResource）、Byte数组（ByteArrayResource）等&lt;/li&gt;
&lt;li&gt;使用Resource是因为该接口抽象出了Spring用到的各种底层资源比如File、Url、Classpath等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bean加载过程&quot;&gt;bean加载过程&lt;/h3&gt;
&lt;p&gt;说到这里的bean加载就离不开我们上面提到的XmlBeanFactory类。&lt;br/&gt;一切的加载XML以及解析bean的操作都要从XmlBeanFactory的&lt;br/&gt;XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)&lt;br/&gt;说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;理所当然，我们首先点击进入XmlBeanDefinitionReader类的loadBeanDefinitions方法。整个过程简单说就是：&lt;br/&gt;1.首先对传入的Resouce进行封装，成为EncodeResource对象（之所以这么做，是考虑可以对于资源文件进行编码）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;得到Resource的输入流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream inputStream = encodedResource.getResource().getInputStream();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;3.调用doLoadBeanDefinitions方法&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;进入doLoadBeanDefinitions方法，我们可以看到方法实现也很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
    try {
        int validationMode = getValidationModeForResource(resource);
        Document doc = this.documentLoader.loadDocument(
                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;IOException parsing XML document from &quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要做了三件事&lt;br/&gt;得到XML文件的验证模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int validationMode = getValidationModeForResource(resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.加载XML文件，得到对应的Document对象(这里可以发现是调用了this.documentLoader即DefaultDocmentLoader类)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Document doc = this.documentLoader.loadDocument(
      inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的解析成Document其实就是常规的SAX解析XML的操作。&lt;/p&gt;
&lt;p&gt;3.根据得到的Document对象注册Bean&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registerBeanDefinitions(doc, resource)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析注册beandefinitions&quot;&gt;解析注册BeanDefinitions&lt;/h3&gt;
&lt;p&gt;上面的在得到Docment对象后，就是需要解析注册BeanDefinitions了。&lt;br/&gt;进入registerBeanDefinitions方法我们可以看到其实现为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        documentReader.setEnvironment(this.getEnvironment());
        int countBefore = getRegistry().getBeanDefinitionCount();
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续深入，则进入到类DefaultBeanDefinitionDocumentReaderregisterBeanDefinitions方法的doRegisterBeanDefinitions实现。&lt;br/&gt;在这个方法里实现了对于XML中的bean真正的解析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void doRegisterBeanDefinitions(Element root) {
   String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
   if (StringUtils.hasText(profileSpec)) {
      Assert.state(this.environment != null, &quot;Environment must be set for evaluating profiles&quot;);
      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
            profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
      if (!this.environment.acceptsProfiles(specifiedProfiles)) {
         return;
      }
   }

   // Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In
   // order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly,
   // keep track of the current (parent) delegate, which may be null. Create
   // the new (child) delegate with a reference to the parent for fallback purposes,
   // then ultimately reset this.delegate back to its original (parent) reference.
   // this behavior emulates a stack of delegates without actually necessitating one.
   BeanDefinitionParserDelegate parent = this.delegate;
   this.delegate = createHelper(this.readerContext, root, parent);

   preProcessXml(root);
   parseBeanDefinitions(root, this.delegate);
   postProcessXml(root);

   this.delegate = parent;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;追踪该方法中的每一个方法就是具体执行解析xml并加载bean的过程，有兴趣可以打断点调试一遍。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 14:56:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</dc:identifier>
</item>
<item>
<title>RobotFramework自动化测试框架-移动手机自动化测试Click A Point关键字的使用 - 老清</title>
<link>http://www.cnblogs.com/laoqing/p/7648185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoqing/p/7648185.html</guid>
<description>&lt;p&gt;Click A Point关键字用来模拟点击APP界面上的一个点，该关键字接收两个三个参数[ x=0 | y=0 | duration=100 ]，x和y代表的是点的坐标位置，duration代表的是点击持续的时长。这三个参数如果没有传入的话，会分表默认x=0，y=0，duration=100。&lt;/p&gt;
&lt;p&gt;示例1：这里依旧采用上面使用的APP界面来做操作示例，使用Click A Point关键字来模拟点击一个button按钮，输入button按钮所在的坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200756/201710/1200756-20171010222734309-1290535433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Open Application   http://localhost:4723/wd/hub  platformName=Android platformVersion=22       deviceName=98YFBP522VSU       app=C:/Users/yongqing/Desktop/app-debug.apk   appPackage=com.example.calculator    appActivity=MainActivity&lt;/p&gt;
&lt;p&gt;Input Text       accessibility_id=输入框 23                               &lt;/p&gt;
&lt;p&gt;Input Text       id=com.example.calculator:id/factortwo       12                               &lt;/p&gt;
&lt;p&gt;Click A Point  370  339  1000             &lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;Starting test: RobotFrameworkTest1.TestSuite5.TestCase008&lt;/p&gt;
&lt;p&gt;20170510 15:32:25.243 :  INFO : Typing text '23' into text field 'accessibility_id=输入框'&lt;/p&gt;
&lt;p&gt;20170510 15:32:25.243 :  INFO : msg:find accessibility_id=输入框&lt;/p&gt;
&lt;p&gt;20170510 15:32:32.005 :  INFO : Typing text '12' into text field 'id=com.example.calculator:id/factortwo'&lt;/p&gt;
&lt;p&gt;20170510 15:32:32.006 :  INFO : msg:find id=com.example.calculator:id/factortwo&lt;/p&gt;
&lt;p&gt;20170510 15:32:37.282 :  INFO : Clicking on a point (370,339).&lt;/p&gt;
&lt;p&gt;Ending test:   RobotFrameworkTest1.TestSuite5.TestCase008         &lt;/p&gt;
&lt;p&gt;从执行结果可以看到，还可以通过Click A Point关键字模拟点击一个button按钮。&lt;/p&gt;
&lt;p&gt; 【原文归作者所有，欢迎转载，但是保留版权】&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 14:28:00 +0000</pubDate>
<dc:creator>老清</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoqing/p/7648185.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(三)加入一个新驱动：西门子S7 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/7647775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/7647775.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        首先感谢博客园：第一篇文章、第一个开源项目，算是旗开得胜。可以看到，项目大部分流量来自于博客园，码农乐园，名不虚传^^。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;园友给了我很多支持，并提出了很好的改进意见。现加入屏幕分辨率自适应和OPC Server可CLSID和ProgID自适应加载功能。屏幕自适应本是普遍问题，因为之前都是标配硬件，举手之劳，一懒就忽略了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205248340-732885456.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅仅十天前，我还是上github只会点击&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205235168-872764741.png&quot; alt=&quot;&quot;/&gt;的菜鸟。Readme文件如何编辑都是现学现卖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次向github上传仓库，下载了发现居然没有任何exe,dll,bak文件！度之，更改忽略文件。总之是赶鸭子上架，各种囧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然则有园友捧场，我也就不揣浅陋，以见教于大方了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;如何加入一个新驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我更新了dll文件夹：增加了libnodave.dll、libnodave.net.dll、SiemensPLCDriver.dll。这个SiemensPLCDriver.dll，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是西门子S7系列PLC的驱动程序(包括源代码，在Program里面）。&lt;strong&gt;请先同步或者重新下载最新版本&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;libnodave开源库(&lt;a href=&quot;https://github.com/netdata/libnodave&quot; target=&quot;_blank&quot;&gt;https://github.com/netdata/libnodave&lt;/a&gt;)据说是来自西门子的德国大神所作。某前辈当年一句话：能搞定驱动就是大牛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我找到了libnodave,封装后成功的实现了与西门子200PLC通讯，很受鼓舞，也成为了项目的起点。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注册驱动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;打开变量管理器TagConfig，点注册，双击【路径】框，在dll文件夹里找到SiemensPLCDriver.dll。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205141543-1846769824.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205131449-1949480711.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果出现在下方列表，打钩，点注册，一般会提示成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205117652-902099210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这时候，右键点树节点S1-&amp;gt;参数设置，就会看到S7以太网协议已经成为可选项。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;驱动的加载&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205055824-1570444533.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上述一系列动作，就是驱动dll的信息，已经写入了数据库的RegisterModule表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这张表就是为系统服务&lt;strong&gt;反射&lt;/strong&gt;加载驱动程序提供基本信息：加载的位置、类名 、描述，以便实例化为具体的驱动类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;span&gt;DAServer&lt;/span&gt;内有一个AddDriver方法，就是&lt;span&gt;Activator&lt;/span&gt;.CreateInstance加载驱动并转换为&lt;span&gt;IDriver&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用反射加载，最大优点就是用户可以自己实现一个驱动，或者引用第三方驱动，并用TagConfig注册，而不需要改动源代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;如何实现一个新驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 驱动接口规范&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;[&lt;span&gt;Description&lt;/span&gt;(&quot;S7 以太网协议&quot;)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;public sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SiemensTCPReader : &lt;span&gt;IPLCDriver&lt;/span&gt;, &lt;span&gt;IMultiReadWrite&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在前一篇文章里提到，&lt;span&gt;IPLCDriver&lt;/span&gt; 是所有PLC都实现的接口。&lt;span&gt;IMultiReadWrite&lt;/span&gt; 是支持批量读写的下位机必须实现的接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为PLC都具有可连接性、可读写性，同时西门子的协议还支持批量读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SiemensTCPReader&lt;/span&gt; 里的Connect方法，就是对libnodave中connectPLC方法的封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dispose方法，就是释放libnodave的非托管资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReadBytes、ReadInt32、ReadBit、ReadFloat、WriteFloat等方法，就是对&lt;span&gt;IReaderWriter&lt;/span&gt;接口的实现。也就是单独读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReadMultiple、WriteMultiple方法是对&lt;span&gt;IMultiReadWrite&lt;/span&gt; 接口的实现，也是对libnodave中批量读写方法的封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个&lt;span&gt;Description&lt;/span&gt; 属性描述符，在注册之后会被反射为驱动的描述字符，存入数据库。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 为什么要实现批量读写，如何实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;批量读写的目的，就是为了提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人总是拿C#、.NET的所谓性能说事。首先我认为.NET性能优良。关键是你怎么写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对性能影响最大的往往不是语言、框架，而是IO。IO的性能成本往往是语言本身的十倍、百倍、甚至千倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在PLC通讯过程中，请求往返就是性能瓶颈。因为大部分下位机不支持订阅-发布（推送）模式，只能采用定期轮询方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是轮询，如果变量很多，如果一个个去读写，读1000个变量要轮询1000次，一次往返起码几十毫秒，效率差的惊人，还占用PLC大量资源。这是行不通的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但如果你想一次就能读入1000个变量，要考虑到变量可能是不连续的，散乱的。而每次读取的大小受PDU所限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，就一定要对变量的分布分析整理，类似送快递，客户虽然分布在各个小区，但并不能像醉汉一样漫无目的的投递，而是根据客户的分布，执行最优化的路线选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整理的结果，就是将所有要读写的变量分割为块，每块大小不能超过PLC 的PDU。力求往返次数最少、一次读入的区块最大、包含的变量最多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分割整理变量区块的功能，就是&lt;span&gt;PLCGroup&lt;/span&gt; 的UpdatePDUArea函数实现的。不过我在这里只是进行简单的地址归纳，并没有做最优解。最优算法肯定是存在的，但可能与现行方法出入不会太大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网关层接口概述&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下位机通讯原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何实现一个设备驱动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何设计图元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VS插件模块及原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归档模块及文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何进行功能扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组态变量表达式实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。欢迎大家提出宝贵意见和建议！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 13:02:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/7647775.html</dc:identifier>
</item>
<item>
<title>Java Socket通信以及可能出现的问题解决 - 摇头耶稣</title>
<link>http://www.cnblogs.com/shakinghead/p/7647761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shakinghead/p/7647761.html</guid>
<description>&lt;p&gt;Java中基于TCP协议实现网络通信的两个类：客户端的Socket和服务器端的ServerSocket。&lt;/p&gt;
&lt;p&gt;Socket通信模型如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1218256/201710/1218256-20171010201225777-505754918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不管Socket通信的功能有多复杂，任何&lt;span lang=&quot;EN-US&quot;&gt;socket通信过程的基本结构都是一样的。其基本步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;①分别在客户端和服务器端创建&lt;span lang=&quot;EN-US&quot;&gt;Socket和&lt;span lang=&quot;EN-US&quot;&gt;ServerSocket实例；服务器端通过&lt;span lang=&quot;EN-US&quot;&gt;.accept()方法等待请求并阻塞。请求收到后，建立连接&lt;span lang=&quot;EN-US&quot;&gt;Socket对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;②通过&lt;span lang=&quot;EN-US&quot;&gt;getInputStream和&lt;span lang=&quot;EN-US&quot;&gt;getOutputStream方法分别在客户端和服务器端打开输入输出流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;③利用&lt;span lang=&quot;EN-US&quot;&gt;IO流进行读写操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;④关闭所有的流资源和套接字资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;其中，编程工作主要集中在第三步，其他的部分代码基本相同。所有步骤都可能抛出&lt;span lang=&quot;EN-US&quot;&gt;IO异常！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;我在编写一个简单的socket程序时，使用的Socket通信出现了一个问题：我在客户端写入的数据，在服务器端无法输出。当我从客户端断开连接时，之前写入的所有数据立刻在服务器端输出出来了。经过反复的验证和求解，以下是我的结论和解决方法。希望有同样问题的小伙伴看完可以解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;通过一端的Socket建立了PrintWriter类来写入数据，通过另一端的Socket建立了BufferedReader类来读取数据并输出。如果数据写入后没有被显示，可能的原因有两种：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;一、写入的数据存储在缓冲区中，没有被写入IO流中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;如果不主动的干涉，写入的数据会一直堆在缓冲区中，直到缓冲区满了引发JVM自动刷新缓冲区。显然这不符合我们的需求。对于这种情况，PrintWriter类提供了flush()方法来强制刷新缓冲区，将缓冲区数据写入IO流中。另外，PrintWriter类的构造器有一个参数”boolean autoflush“，这个参数默认为false，如果设置为true，则会开启自动刷新缓冲区功能。但是请注意，这里的自动刷新是有触发条件的，那就是：PrintWriter类写入数据的方法必须是println、printf或者format方法时，才会触发自动刷新。如果是调用write()这类方法写入数据，是不会触发自动刷新的！总结起来，就是三点：autoflush参数设置，write和println方法的选择，flush方法的使用。对这三个进行组合，就能保证在Socket通信的某一端写入数据时，数据一定能成功地写入到IO流中！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、读取数据使用了readLine()方法，该方法没有正常的结束：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;请注意，BufferedReader类的readLine()方法是一个阻塞函数！也就是说，这个方法本身是读取一行数据，但是它自己识别不了什么叫做“一行”!当调用该方法读取完一段数据后，它会阻塞，而不会return它的读取数据。这就是为什么有的时候明明已经刷新了缓冲区正确的写入数据了，还是通过输入流读取数据并显示出来的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;对于readLine()方法，它解除阻塞、正确结束并返回读取的值，只有以下几种情况：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;①读取的数据里含有回车符&quot;\r&quot;或者换行符&quot;\n&quot;或者回车换行符&quot;\r\n&quot;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;②读取的数据是在另一端通过println方法写入的，因为println方法自带换行符；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;③BufferedReader类的缓冲区满了，那么JVM会自动刷新缓冲区从而释放“积攒”的数据（但是鉴于默认缓冲区大小为8192个字符，对于小数据量的通信，显然触发不了）；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;④对于读取的数据，写入这些数据的流发生异常或者直接关闭，那么readLine()就会把它吃的数据全部吐出来。这就刚好解释了，为什么在我的程序中，断开客户端Socket连接，服务器端立刻输出所有客户端消息的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;综上，在Socket通信过程中，保证某一端输出流的缓冲被刷新，保证另一端的readLine方法能正常停止，即可解决写入的数据在另一端无法输出的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;以下是我修改后能成功运行的代码，分别是服务器端Socket和客户端Socket。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;over！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStreamWriter;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShakingServer{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建服务器套接字实例，设置监听端口为2000&lt;/span&gt;
        ServerSocket server=&lt;span&gt;new&lt;/span&gt; ServerSocket(2000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始监听客户端的请求，并阻塞&lt;/span&gt;
        Socket socket=&lt;span&gt;server.accept();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求收到后，自动建立连接。通过IO流进行数据传输&lt;/span&gt;
        System.out.println(&quot;连接建立成功&quot;&lt;span&gt;);

        OutputStream os&lt;/span&gt;=&lt;span&gt;socket.getOutputStream();
        PrintWriter pw&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PrintWriter(&lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(os)),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        pw.write(&lt;/span&gt;&quot;欢迎访问摇头耶稣的世界！&quot;&lt;span&gt;);
        pw.flush();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我关闭了输出流，所以另一端的readLine方法才正常结束了&lt;/span&gt;
&lt;span&gt;        socket.shutdownOutput();

        InputStream is&lt;/span&gt;=&lt;span&gt;socket.getInputStream();
        InputStreamReader isr&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(is);
        BufferedReader br&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            String str&lt;/span&gt;=&lt;span&gt;br.readLine();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str.equals(&quot;quit&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            System.out.println(&lt;/span&gt;&quot;Client said: &quot;+&lt;span&gt;str);
        }
        socket.shutdownInput();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket.shutdownOutput();&lt;/span&gt;
&lt;span&gt;        socket.close();
        server.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStreamWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShakingClient{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建客户端的套接字，设置连接的服务器的IP地址和端口号&lt;/span&gt;
        Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&quot;169.254.132.203&quot;,2000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入流读取服务器发送的信息&lt;/span&gt;
        BufferedReader br=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启自动刷新缓冲区&lt;/span&gt;
        PrintWriter pw=&lt;span&gt;new&lt;/span&gt; PrintWriter(&lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(socket.getOutputStream())),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);            
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从键盘读取数据&lt;/span&gt;
        BufferedReader ii=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in));
        System.out.println(br.readLine());
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为开启了自动刷新，且调用的是println方法，所以可以不调用flush方法&lt;/span&gt;
        pw.println(&quot;请求进入摇头耶稣的世界&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pw.flush();&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            String str&lt;/span&gt;=&lt;span&gt;ii.readLine();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了回车符来保证另一端的readLine方法正常结束&lt;/span&gt;
            pw.write(str+&quot;\r&quot;&lt;span&gt;);
            pw.flush();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入quit则退出聊天室&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(str.equals(&quot;quit&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        socket.shutdownInput();
        socket.shutdownOutput();
        socket.close();
    }
}
                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Oct 2017 12:52:00 +0000</pubDate>
<dc:creator>摇头耶稣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shakinghead/p/7647761.html</dc:identifier>
</item>
<item>
<title>JavaScript接口 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7646969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7646969.html</guid>
<description>&lt;p&gt;&lt;span&gt;JavaScript中实现接口的方法有三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种，使用注释的方法实现接口&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;特点：&lt;br/&gt;（1）最简单，但是功能最弱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）利用 interface和 implement&quot;文字&quot;&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;2&quot;&gt;（3）把他们用注释的方式表现出来&lt;p&gt;具体实现如下：&lt;/p&gt;&lt;p&gt;1，用注释定义一个接口&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * interface PersonDao(){
    * function add(obj);
    * function remove(obj);
    * function find(id);
    * }
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）用注释来注明实现的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * PersonDaoImp  implement PersonDao （PersonDaoImp实现接口PersonDao） 
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PersonDaoImp=&lt;span&gt;function () {   };//定义实现类&lt;br/&gt;//实现
    PersonDaoImp.prototype.add&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;&lt;span&gt;    }
    PersonDaoImp.prototype.remove&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;&lt;span&gt;    }
    PersonDaoImp.prototype.find&lt;/span&gt;=&lt;span&gt;function(id){
       &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;（1）使用文字的形式告知是谁实现谁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）优点，这样是很有意义的，大型项目需要的就是规范和标准，可以在没有写实现之前充分考虑架构和设计&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3）缺点：需要人为的遵守注释中的说明&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;第二种，使用属性检验法实现接口 。 实质为通过一个属性判断实现了谁&lt;br/&gt;具体如下：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;1，用注释来定义一个接口&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * interface PersonDao(){
     * function add(obj);
     * function remove(obj);
     * function find(id);
     * }
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;2，&lt;/span&gt;&lt;/span&gt;用注释来说明实现接口类+实现类中增加属性&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * PersonDaoImp  implement PersonDao
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PersonDaoImp=&lt;span&gt;function () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.implementInterface=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告知该类实现的接口是啥是一个数组，&lt;/span&gt;
&lt;span&gt;}
    PersonDaoImp.prototype.add&lt;/span&gt;=&lt;span&gt;function(obj){
             alert(obj);
    }
    PersonDaoImp.prototype.remove&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;    }
    PersonDaoImp.prototype.find&lt;/span&gt;=&lt;span&gt;function(id){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）检验属性的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收一个不定参数 可能有多个  使用Object&lt;/span&gt;
&lt;span&gt;        function imp1(Object) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历传入对象的所用属性  i=1：第一个是不定参数，从第二个参数开始遍历接口，故i=1&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arguments除Object外&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; interfaceName=&lt;span&gt;arguments[i];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; interfaceFind=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;Object.implementInterface.length;j++&lt;span&gt;){
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Object.implementInterface[j]==&lt;span&gt;interfaceName){
                         interfaceFind&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                         &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                     }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;interfaceFind){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）接口与实现类的配合实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  function addObj(obj) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; PersonDao=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonDaoImp();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始检查  实现类是否实现接口&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!imp1(PersonDao,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;某对象是否实现接口(对象，接口)   第一次参数是对象，第二个参数是不定参数&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDaoImp没有实现接口PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;
&lt;span&gt;                PersonDao.add(obj);
            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
addObj(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;第三种，鸭式变形法  一种形似的命名方式，从实现角度来理解为：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如果对象中具有的方法与接口中定义的方法同名  则认为是实现了本接口。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;具体如下：&lt;br/&gt;1，定义一个接口类   注意这里与上面两种不一样了，不用写注释说明了&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Interface=function (name,methods) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：接口名字&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须是两个参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methods=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个空数组装载函数名&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;methods.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;  methods[i]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
                alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数名必须是字符串类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.methods.push( methods[i]);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;2，定义一个静态方法来实现接口与实现类的 直接检验&lt;br/&gt;注意，&lt;/span&gt;&lt;span&gt;静态方法不要写成Interface.prototype ,因为这是写到接口的原型链上的，我们要把静态的函数直接写到类层次上。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Interface.ensureImplement=function (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) {
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数必须不少于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     }
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inter=&lt;span&gt;arguments[i];
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是接口就必须是Interface类型&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(inter.constructor!=&lt;span&gt;Interface){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;如果是接口类的话，就必须是Interface类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接口中的方法是否全部实现
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历函数集合&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;inter.methods.length;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method=inter.methods[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口中所有函数

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;object[method]是传入的函数&lt;/span&gt;
             &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;object&lt;/span&gt;[method]||&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[method]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类中必须有方法名字与接口中所用方法名相同&lt;/span&gt;
                     &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现类中没有完全实现接口中的所有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        }
                    }
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，应用&lt;/p&gt;
&lt;p&gt;3.1定义自己的接口    &lt;/p&gt;
&lt;p&gt;         例如：此处定义两个接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; FirstInterface=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FirstInterface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);//第一个接口
&lt;/span&gt;&lt;span&gt; var&lt;/span&gt; SecondInterface=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SecondInterface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;save&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]);//第二个接口&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2，定义实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 function commManager() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现两个类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先实现方法&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.add=&lt;span&gt;function () {
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok--实现&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.remove=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.search=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.save=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验&lt;/span&gt;
        Interface.ensureImplement(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,GridManager,formManager);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3，实现类的实例化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; comm=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; commManager();
    comm.add();//调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 总结：三种方式都有自己的优势与缺点，每种的选择需要根据自己的需要进行选择。但是在设计的时候实现类间低耦合的相当重要的。&lt;/p&gt;
&lt;p&gt;本人初学，若有不足之处，还希望大家能多多指出，大家相互学习，谢谢。&lt;/p&gt;




&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span/&gt;
&lt;/pre&gt;

</description>
<pubDate>Tue, 10 Oct 2017 12:51:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7646969.html</dc:identifier>
</item>
</channel>
</rss>