<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【深度学习】目标检测算法总结（R-CNN、Fast R-CNN、Faster R-CNN、FPN、YOLO、SSD、RetinaNet） - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8994246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8994246.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;目标检测是很多计算机视觉任务的基础，不论我们需要实现图像与文字的交互还是需要识别精细类别，它都提供了可靠的信息。本文对目标检测进行了整体回顾，第一部分从RCNN开始介绍基于候选区域的目标检测器，包括Fast R-CNN、Faster R-CNN 和 FPN等。第二部分则重点讨论了包括YOLO、SSD和RetinaNet等在内的单次检测器，它们都是目前最为优秀的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1.1  滑动窗口检测器&lt;/h2&gt;
&lt;p&gt;　　自从 AlexNet 获得 ILSVRC 2012 挑战赛冠军后，用 CNN 进行分类成为主流。&lt;span&gt;一种用于目标检测的暴力方法是从左到右、从上到下滑动窗口，利用分类识别目标&lt;/span&gt;。为了在不同观察距离处检测不同的目标类型，我们使用不同大小和宽高比的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505111653711-1500490246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;滑动窗口（从右到左，从上到下）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　我们根据滑动窗口从图像中剪切图像块。由于很多分类器只取固定大小的图像，因此这些图像块是经过变形转换的。但是，这不影响分类准确率，因为分类器可以处理变形后的图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505111735651-1493010468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将图像变形转换成固定大小的图像&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　变形图像块被输入 CNN 分类器中，提取出 4096 个特征。之后，我们使用 &lt;strong&gt;&lt;span&gt;SVM 分类器识别类别&lt;/span&gt;&lt;/strong&gt;和该&lt;span&gt;&lt;strong&gt;边界框的另一个线性回归器&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505111849348-1143701044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;滑动窗口检测器的系统工作流程图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下面是伪代码。我们创建很多窗口来检测不同位置的不同目标。要提升性能，一个显而易见的办法就是减少窗口数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; window &lt;span&gt;in&lt;/span&gt;&lt;span&gt; windows 
    patch &lt;/span&gt;= get_patch(image, window) &lt;br/&gt;　　results = detector(patch)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2  选择性搜索&lt;/h2&gt;
&lt;p&gt;　　我们不使用暴力方法，而是用&lt;span&gt;&lt;strong&gt;&lt;span&gt;候选区域方法（region proposal method）&lt;/span&gt;创建目标检测的感兴趣区域（ROI）&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;在&lt;span&gt;&lt;strong&gt;选择性搜索（selective search，SS）&lt;/strong&gt;&lt;/span&gt;中，我们首先将每个像素作为一组。然后，计算每一组的&lt;strong&gt;纹理&lt;/strong&gt;，并将两个最接近的组结合起来。但是为了避免单个区域吞噬其他区域，我们首先对较小的组进行分组。我们继续合并区域，直到所有区域都结合在一起。下图第一行展示了如何使区域增长，第二行中的蓝色矩形代表合并过程中所有可能的 &lt;strong&gt;ROI&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505112317315-199748128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：van de Sande et al. ICCV'11&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.3  R-CNN&lt;/h2&gt;
&lt;p&gt;　　R-CNN 利用&lt;span&gt;&lt;strong&gt;候选区域方法&lt;/strong&gt;&lt;/span&gt;创建了约 &lt;strong&gt;2000 个 ROI&lt;/strong&gt;。这些区域被转换为固定大小的图像，并分别馈送到卷积神经网络中（将原始图像根据ROI切割、reshape再送进NN学习）。&lt;span&gt;&lt;strong&gt;该网络架构后面会跟几个全连接层，以实现目标分类并提炼边界框。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505112837057-1309880568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用候选区域、CNN、仿射层来定位目标。以下是 R-CNN 整个系统的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505112934129-1540508900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过使用更少且更高质量的 ROI，R-CNN 要比滑动窗口方法更快速、更准确。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ROIs =&lt;span&gt; region_proposal(image)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs:
    patch &lt;/span&gt;=&lt;span&gt; get_patch(image, ROI) 
    results &lt;/span&gt;= detector(pach)
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;边界框回归器&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;候选区域方法&lt;/strong&gt;有非常高的计算复杂度。为了加速这个过程，我们通常会使用计算量较少的候选区域选择方法构建 ROI，并在后面使用线性回归器（使用全连接层）进一步提炼边界框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/152480469203110cd92fd4a&quot; alt=&quot;从RCNN到SSD，这应该是最全的一份目标检测算法盘点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;使用回归方法将蓝色的原始边界框提炼为红色的&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.4  Fast R-CNN&lt;/h2&gt;
&lt;p&gt;　　R-CNN 需要非常多的候选区域以提升准确度，但其实有很多区域是彼此重叠的，因此 R-CNN 的训练和推断速度非常慢。如果我们有 2000 个候选区域，且每一个都需要独立地馈送到 CNN 中，那么对于不同的 ROI，我们需要重复提取 2000 次特征。（&lt;span&gt;&lt;strong&gt;R-CNN&lt;/strong&gt;&lt;strong&gt;很多卷积运算是重复的&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　此外，CNN 中的特征图以一种密集的方式表征空间特征，那么我们能直接使用特征图代替原图来检测目标吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505113547297-839794159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505113611987-2136919947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;直接利用特征图计算 ROI&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Fast R-CNN 使用特征提取器（CNN）先提取整个图像的特征，而不是从头开始对每个图像块提取多次。&lt;/strong&gt;&lt;/span&gt;然后，&lt;span&gt;&lt;strong&gt;我们可以将创建候选区域的方法直接应用到提取到的特征图上&lt;/strong&gt;&lt;/span&gt;。例如，Fast R-CNN 选择了 VGG16 中的卷积层 conv5 输出的 Feture Map 来生成 ROI，这些关注区域随后会结合对应的特征图以裁剪为特征图块，并用于目标检测任务中。我们&lt;span&gt;&lt;strong&gt;使用 ROI 池化将特征图块转换为固定的大小&lt;/strong&gt;&lt;/span&gt;，并馈送到全连接层进行分类和定位。因为 Fast-RCNN 不会重复提取特征，因此它能显著地减少处理时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505114046902-840884064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将候选区域直接应用于特征图，并使用 ROI 池化将其转化为固定大小的特征图块&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　以下是 Fast R-CNN 的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505114125219-882795149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在下面的伪代码中，计算量巨大的特征提取过程从 For 循环中移出来了，因此速度得到显著提升。&lt;strong&gt;Fast R-CNN 的训练速度是 R-CNN 的 10 倍，推断速度是后者的 150 倍。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
ROIs &lt;/span&gt;=&lt;span&gt; region_proposal(feature_maps)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs:
    patch &lt;/span&gt;=&lt;span&gt; roi_pooling(feature_maps, ROI) 
    results &lt;/span&gt;= detector2(patch)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Fast R-CNN 最重要的一点就是包含特征提取器、分类器和边界框回归器在内的整个网络能通过多任务损失函数进行端到端的训练，这种多任务损失即结合了分类损失和定位损失的方法，大大提升了模型准确度。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;ROI 池化&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　因为 Fast R-CNN 使用全连接层，所以我们应用 ROI 池化将不同大小的 ROI 转换为固定大小。&lt;/p&gt;
&lt;p&gt;　　为简洁起见，我们先将 8×8 特征图转换为预定义的 2×2 大小。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下图左上角：特征图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;右上角：将 ROI（蓝色区域）与特征图重叠。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;左下角：将 ROI 拆分为目标维度。例如，对于 2×2 目标，我们将 ROI 分割为 4 个大小相似或相等的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;右下角：找到每个部分的最大值，得到变换后的特征图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505114516419-1856119752.png&quot; alt=&quot;&quot;/&gt;&lt;em&gt;输入特征图（左上），输出特征图（右下），ROI (右上，蓝色框)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　按上述步骤得到一个 2×2 的特征图块，可以馈送至分类器和边界框回归器中。&lt;/p&gt;
&lt;h2&gt;1.5  Faster R-CNN&lt;/h2&gt;
&lt;p&gt;　　Fast R-CNN 依赖于外部候选区域方法，如选择性搜索。但这些算法在 CPU 上运行且速度很慢。在测试中，Fast R-CNN 需要 2.3 秒来进行预测，其中 2 秒用于生成 2000 个 ROI。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
ROIs &lt;/span&gt;= region_proposal(feature_maps)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Expensive!&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs
    patch &lt;/span&gt;=&lt;span&gt; roi_pooling(feature_maps, ROI) 
    results &lt;/span&gt;= detector2(patch)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Faster R-CNN 采用与 Fast R-CNN 相同的设计，&lt;span&gt;&lt;strong&gt;只是它用内部深层网络代替了候选区域方法&lt;/strong&gt;&lt;/span&gt;。新的&lt;strong&gt;&lt;span&gt;候选区域网络（RPN）&lt;/span&gt;&lt;/strong&gt;在生成 ROI 时效率更高，并且以每幅图像 10 毫秒的速度运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505140852035-53224161.png&quot; alt=&quot;&quot;/&gt;&lt;em&gt;Faster R-CNN 的流程图与 Fast R-CNN 相同&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505140951802-712034784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;外部候选区域方法代替了内部深层网络&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;候选区域网络(RPN)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;候选区域网络（RPN）&lt;/strong&gt;&lt;/span&gt;将第一个卷积网络的输出特征图作为输入。它在特征图上滑动一个 3×3 的卷积核，以使用卷积网络（如下所示的 ZF 网络）构建与类别无关的候选区域。其他深度网络（如 VGG 或 ResNet）可用于更全面的特征提取，但这需要以速度为代价。ZF 网络最后会输出 256 个值，它们将馈送到两个独立的全连接层，以预测边界框和两个 objectness 分数，这两个 objectness 分数度量了边界框是否包含目标。我们其实可以使用回归器计算单个 objectness 分数，但为简洁起见，Faster R-CNN 使用只有两个类别的分类器：即带&lt;strong&gt;有目标的类别&lt;/strong&gt;和&lt;strong&gt;不带有目标的类别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505141538370-1305739714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于特征图中的每一个位置，RPN 会做 k 次预测。因此，RPN 将输出 4×k 个坐标和每个位置上 2×k 个得分。下图展示了 8×8 的特征图，且有一个 3×3 的卷积核执行运算，它最后输出 8×8×3 个 ROI（其中 k=3）。下图（右）展示了单个位置的 3 个候选区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142042648-254532648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此处有 3 种猜想，稍后我们将予以完善。由于只需要一个正确猜想，因此我们最初的猜想最好涵盖不同的形状和大小。因此，Faster R-CNN 不会创建随机边界框。相反，它会预测一些与左上角名为&lt;strong&gt;&lt;span&gt;「锚点」&lt;/span&gt;&lt;/strong&gt;的参考框相关的偏移量（如x、y）。我们限制这些偏移量的值，因此我们的猜想仍然类似于锚点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142155131-51553556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要对每个位置进行 k 个预测，我们需要以每个位置为中心的 k 个锚点。每个预测与特定锚点相关联，但不同位置共享相同形状的锚点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142221601-1484881357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这些锚点是精心挑选的，因此它们是多样的，且覆盖具有不同比例和宽高比的现实目标。这使得我们可以以更好的猜想来指导初始训练，并允许每个预测专门用于特定的形状。该策略使早期训练更加稳定和简便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142409837-738297303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://arxiv.org/pdf/1506.01497.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Faster R-CNN 使用更多的锚点。它部署 9 个锚点框：3 个不同宽高比的 3 个不同大小的锚点框。每一个位置使用 9 个锚点，每个位置会生成 2×9 个 objectness 分数和 4×9 个坐标。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;R-CNN 方法的性能&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如下图所示，Faster R-CNN 的速度要快得多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142556821-1286928548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.6  基于区域的全卷积神经网络（R-FCN）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　假设我们只有一个特征图用来检测右眼。那么我们可以使用它定位人脸吗？应该可以。因为右眼应该在人脸图像的左上角，所以我们可以利用这一点定位整个人脸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505142731192-1064481204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果我们还有其他用来检测左眼、鼻子或嘴巴的特征图，那么我们可以将检测结果结合起来，更好地定位人脸。&lt;/p&gt;
&lt;p&gt;　　现在我们回顾一下所有问题。在 Faster R-CNN 中，检测器使用了多个全连接层进行预测。如果有 2000 个 ROI，那么成本非常高。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
ROIs &lt;/span&gt;=&lt;span&gt; region_proposal(feature_maps)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs
    patch &lt;/span&gt;=&lt;span&gt; roi_pooling(feature_maps, ROI)
    class_scores, box &lt;/span&gt;= detector(patch)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Expensive!&lt;/span&gt;
    class_probabilities = softmax(class_scores)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;R-FCN 通过减少每个 ROI 所需的工作量实现加速（去掉了全连接层）&lt;/strong&gt;&lt;/span&gt;。上面基于区域的特征图与 ROI 是独立的，可以在每个 ROI 之外单独计算。剩下的工作就比较简单了，因此 R-FCN 的速度比 Faster R-CNN 快。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
ROIs &lt;/span&gt;=&lt;span&gt; region_proposal(feature_maps)         
score_maps &lt;/span&gt;=&lt;span&gt; compute_score_map(feature_maps)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs
    V &lt;/span&gt;=&lt;span&gt; region_roi_pool(score_maps, ROI)     
    class_scores, box &lt;/span&gt;= average(V)                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Much simpler!&lt;/span&gt;
    class_probabilities = softmax(class_scores)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在我们来看一下 5 × 5 的特征图 M，内部包含一个蓝色方块。我们将方块平均分成 3 × 3 个区域。现在，我们在 M 中创建了一个新的特征图，来检测方块的左上角（TL）。这个新的特征图如下图（右）所示。只有黄色的网格单元 [2, 2] 处于激活状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505143333476-553828348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在左侧创建一个新的特征图，用于检测目标的左上角&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　我们将方块分成 9 个部分，由此创建了 9 个特征图，每个用来检测对应的目标区域。这些特征图叫作&lt;span&gt;&lt;strong&gt;位置敏感得分图（position-sensitive score map）&lt;/strong&gt;&lt;/span&gt;，因为每个图检测目标的子区域（计算其得分）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505143440734-1537004993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;生成 9 个得分图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下图中红色虚线矩形是建议的 ROI。我们将其分割成 3 × 3 个区域，并询问每个区域包含目标对应部分的概率是多少。例如，左上角 ROI 区域包含左眼的概率。我们将结果存储成 3 × 3 vote 数组，如下图（右）所示。例如，vote_array[0][0] 包含左上角区域是否包含目标对应部分的得分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505143707803-1747244764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将 ROI 应用到特征图上，输出一个 3 x 3 数组&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　将得分图(Feature Map)和 ROI 映射到 vote 数组的过程叫作&lt;span&gt;&lt;strong&gt;位置敏感 ROI 池化（position-sensitive ROI-pool）&lt;/strong&gt;&lt;/span&gt;。该过程与前面讨论过的 ROI 池化非常接近。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505144039681-1211806338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;将 ROI 的一部分叠加到对应的得分图上，计算 V[i][j]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在计算出位置敏感 ROI 池化的所有值后，&lt;span&gt;类别得分是其所有元素得分的平均值&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505144213719-1278140951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ROI 池化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　假如我们有 C 个类别要检测。我们将其扩展为 C + 1 个类别，这样就为背景（非目标）增加了一个新的类别。每个类别有 3 × 3 个得分图，因此一共有 (C+1) × 3 × 3 个得分图。使用每个类别的得分图可以预测出该类别的类别得分。然后我们对这些得分应用 softmax 函数，计算出每个类别的概率。&lt;/p&gt;
&lt;p&gt;　　以下是数据流图，在我们的案例中，k=3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505144433895-646844741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.7  R-CNN系列总结&lt;/h2&gt;
&lt;p&gt;　　我们首先了解了基础的滑动窗口算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; window &lt;span&gt;in&lt;/span&gt;&lt;span&gt; windows
    patch &lt;/span&gt;=&lt;span&gt; get_patch(image, window)
    results &lt;/span&gt;= detector(patch)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后尝试减少窗口数量，尽可能减少 for 循环中的工作量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ROIs =&lt;span&gt; region_proposal(image)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs
    patch &lt;/span&gt;=&lt;span&gt; get_patch(image, ROI)
    results &lt;/span&gt;= detector(patch)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　第二部分，我们将对单次目标检测器（包括 &lt;span&gt;SSD、YOLO、YOLOv2、YOLOv3&lt;/span&gt;）进行综述。我们将分析 &lt;span&gt;FPN&lt;/span&gt; 以理解多尺度特征图如何提高准确率，特别是小目标的检测，其在单次检测器中的检测效果通常很差。然后我们将分析 Focal loss 和 RetinaNet，看看它们是如何解决训练过程中的类别不平衡问题的。&lt;/p&gt;
&lt;h2&gt;2.1  单次检测器&lt;/h2&gt;
&lt;p&gt;　　Faster R-CNN 中，在分类器之后有一个专用的候选区域网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505150514021-608192161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Faster R-CNN 工作流&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　基于区域的检测器是很准确的，但需要付出代价。Faster R-CNN 在 PASCAL VOC 2007 测试集上每秒处理 7 帧的图像（7 FPS）。和 R-FCN 类似，研究者通过减少每个 ROI 的工作量来精简流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
ROIs &lt;/span&gt;=&lt;span&gt; region_proposal(feature_maps)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ROI &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ROIs
    patch &lt;/span&gt;=&lt;span&gt; roi_align(feature_maps, ROI)
    results &lt;/span&gt;= detector2(patch)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Reduce the amount of work here!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;作为替代，我们是否需要一个分离的候选区域步骤？我们可以直接在一个步骤内得到边界框和类别吗？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
feature_maps =&lt;span&gt; process(image)
results &lt;/span&gt;= detector3(feature_maps) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; No more separate step for ROIs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　让我们再看一下滑动窗口检测器。我们可以通过在特征图上滑动窗口来检测目标。对于不同的目标类型，我们使用不同的窗口类型。以前的滑动窗口方法的致命错误在于使用窗口作为最终的边界框，这就需要非常多的形状来覆盖大部分目标。更有效的方法是将窗口当做初始猜想，这样我们就得到了从当前滑动窗口同时预测类别和边界框的检测器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505150849466-1873550181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;基于滑动窗口进行预测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　这个概念和 Faster R-CNN 中的锚点很相似。然而，单次检测器会同时预测边界框和类别。例如，我们有一个 8 × 8 特征图，并在每个位置做出 k 个预测，即总共有 8 × 8 × k 个预测结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505150922230-1139435351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;64 个位置&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在每个位置，我们有 k 个锚点（锚点是固定的初始边界框猜想），一个锚点对应一个特定位置。我们使用相同的锚点形状仔细地选择锚点和每个位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151100976-222588785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;使用 4 个锚点在每个位置做出 4 个预测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　以下是 4 个锚点（绿色）和 4 个对应预测（蓝色），每个预测对应一个特定锚点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151142570-1755259728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4 个预测，每个预测对应一个锚点&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;在 &lt;span&gt;Faster R-CNN&lt;/span&gt; 中，我们使用卷积核来做 5 个参数的预测：4 个参数对应某个锚点的预测边框，1 个参数对应 objectness 置信度得分。&lt;/span&gt;&lt;/strong&gt;因此 3× 3× D × 5 卷积核将特征图从 8 × 8 × D 转换为 8 × 8 × 5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151406838-326303487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;使用 3x3 卷积核计算预测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在单次检测器中，卷积核还预测 C 个类别概率以执行分类（每个概率对应一个类别）。因此我们应用一个 3× 3× D × 25 卷积核将特征图从 8 × 8 × D 转换为 8 × 8 × 25（C=20）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151523154-1980699118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;每个位置做出 k 个预测，每个预测有 25 个参数&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;单次检测器通常需要在准确率和实时处理速度之间进行权衡&lt;/strong&gt;。它们&lt;span&gt;&lt;strong&gt;在检测太近距离或太小的目标时容易出现问题&lt;/strong&gt;&lt;/span&gt;。在下图中，左下角有 9 个圣诞老人，但某个单次检测器只检测出了 5 个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151616482-1459991526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2  SSD (Single Shot MultiBox Detector)&lt;/h2&gt;
&lt;p&gt;　　SSD 是使用 VGG19 网络作为特征提取器（和 Faster R-CNN 中使用的 CNN 一样）的单次检测器。我们在该网络之后添加自定义卷积层（蓝色），并使用卷积核（绿色）执行预测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151811043-167769337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;同时对类别和位置执行单次预测&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　然而，&lt;span&gt;&lt;strong&gt;卷积层降低了空间维度和分辨率。因此上述模型仅可以检测较大的目标&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;为了解决该问题，我们从多个特征图上执行独立的目标检测。采用多尺度特征图独立检测。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505151959649-948297901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;使用多尺度特征图用于检测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　以下是特征图图示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505152113936-1996087392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://arxiv.org/pdf/1512.02325.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　SSD 使用卷积网络中较深的层来检测目标。如果我们按接近真实的比例重绘上图，我们会发现图像的空间分辨率已经被显著降低，且可能已无法定位在低分辨率中难以检测的小目标。如果出现了这样的问题，我们需要增加输入图像的分辨率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505152455865-701418716.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3  YOLO&lt;/h2&gt;
&lt;p&gt;YOLO 是另一种单次目标检测器。&lt;/p&gt;

&lt;p&gt;　　YOLO  在卷积层之后使用了 DarkNet 来做特征检测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505152800163-2054035704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然而，它并没有使用多尺度特征图来做独立的检测。相反，&lt;span&gt;它将特征图部分平滑化，并将其和另一个较低分辨率的特征图拼接&lt;/span&gt;。例如，YOLO 将一个 28 × 28 × 512 的层重塑为 14 × 14 × 2048，然后将它和 14 × 14 ×1024 的特征图拼接。之后，YOLO 在新的 14 × 14 × 3072 层上应用卷积核进行预测。&lt;/p&gt;
&lt;p&gt;　　YOLO（v2）做出了很多实现上的改进，将 mAP 值从第一次发布时的 63.4 提高到了 78.6。&lt;strong&gt;YOLO9000&lt;/strong&gt; 可以检测 9000 种不同类别的目标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153021706-817546212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://arxiv.org/pdf/1612.08242.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　以下是 YOLO 论文中不同检测器的 mAP 和 FPS 对比。YOLOv2 可以处理不同分辨率的输入图像。低分辨率的图像可以得到更高的 FPS，但 mAP 值更低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153224811-1562662970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://arxiv.org/pdf/1612.08242.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　YOLOv3&lt;/strong&gt;&lt;/span&gt; 使用了更加复杂的骨干网络来提取特征。&lt;span&gt;DarkNet-53 主要由 3 × 3 和 1× 1 的卷积核以及类似 ResNet 中的跳过连接构成。&lt;/span&gt;相比 ResNet-152，DarkNet 有更低的 BFLOP（十亿次浮点数运算），但能以 2 倍的速度得到相同的分类准确率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153326529-880142215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://pjreddie.com/media/files/papers/YOLOv3.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;YOLOv3 还添加了&lt;span&gt;&lt;strong&gt;特征金字塔&lt;/strong&gt;&lt;/span&gt;，以更好地检测小目标。&lt;/span&gt;以下是不同检测器的准确率和速度的权衡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153407847-635993486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图源：https://pjreddie.com/media/files/papers/YOLOv3.pdf&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;特征金字塔网络（FPN）&lt;/h3&gt;
&lt;p&gt;　　检测不同尺度的目标很有挑战性，尤其是小目标的检测。&lt;span&gt;&lt;strong&gt;特征金字塔网络（FPN）&lt;/strong&gt;&lt;/span&gt;是一种旨在提高准确率和速度的特征提取器。它取代了检测器（如 Faster R-CNN）中的特征提取器，并生成更高质量的特征图金字塔。&lt;/p&gt;
&lt;p&gt;数据流&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153541591-434143389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPN（图源：https://arxiv.org/pdf/1612.03144.pdf）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;FPN 由自下而上和自上而下路径组成。其中自下而上的路径是用于特征提取的常用卷积网络。空间分辨率自下而上地下降。当检测到更高层的结构，每层的语义值增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153633421-1630357404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPN 中的特征提取（编辑自原论文）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　SSD 通过多个特征图完成检测。但是，最底层不会被选择执行目标检测。它们的分辨率高但是语义值不够，导致速度显著下降而不能被使用。SSD 只使用较上层执行目标检测，因此对于小的物体的检测性能较差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153710364-502628155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图像修改自论文 https://arxiv.org/pdf/1612.03144.pdf&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　FPN 提供了一条自上而下的路径，从语义丰富的层构建高分辨率的层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153759647-1349206532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;自上而下重建空间分辨率（编辑自原论文）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;虽然该重建层的语义较强，但在经过所有的上采样和下采样之后，目标的位置不精确。在重建层和相应的特征图之间添加横向连接可以使位置侦测更加准确&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505153843772-922492232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;增加跳过连接（引自原论文）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下图详细说明了自下而上和自上而下的路径。其中 P2、P3、P4 和 P5 是用于目标检测的特征图金字塔。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;fr-fic fr-dib&quot; src=&quot;https://image.jiqizhixin.com/uploads/editor/e1f56dc7-4ace-475d-aed4-dc25bbaae97b/1524810340484.jpg&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;740&quot; data-ratio=&quot;1.171487603305785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8H2Xghj59KZqesWzoictPPA6sdaEDtIpVxFzwmJ4sq99KbJ7QMrBBbEGlh9CDndE1D7ofeuibcSv3w/640?wx_fmt=png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;FPN 结合 RPN&lt;/h3&gt;
&lt;p&gt;　　FPN 不单纯是目标检测器，还是一个目标检测器和协同工作的特征检测器。分别传递到各个特征图（P2 到 P5）来完成目标检测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505154100351-506606115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;FPN 结合 Fast R-CNN 或 Faster R-CNN&lt;/h3&gt;
&lt;p&gt;　　在 FPN 中，我们生成了一个特征图的金字塔。用 RPN（详见上文）来生成 ROI。基于 ROI 的大小，我们选择最合适尺寸的特征图层来提取特征块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505154304324-944539261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;困难案例&lt;/h3&gt;
&lt;p&gt;　　对于如 SSD 和 YOLO 的大多数检测算法来说，我们做了比实际的目标数量要多得多的预测。所以错误的预测比正确的预测要更多。这产生了一个对训练不利的类别不平衡。训练更多的是在学习背景，而不是检测目标。但是，我们需要负采样来学习什么是较差的预测。所以，我们计算置信度损失来把训练样本分类。选取最好的那些来确保负样本和正样本的比例最多不超过 3:1。这使训练更加快速和稳定。&lt;/p&gt;
&lt;h3&gt;推断过程中的非极大值抑制&lt;/h3&gt;
&lt;p&gt;　　检测器对于同一个目标会做出重复的检测。我们利用非极大值抑制来移除置信度低的重复检测。将预测按照置信度从高到低排列。如果任何预测和当前预测的类别相同并且两者 IoU 大于 0.5，我们就把它从这个序列中剔除。&lt;/p&gt;
&lt;h3&gt;Focal Loss（RetinaNet）&lt;/h3&gt;
&lt;p&gt;　　类别不平衡会损害性能。SSD 在训练期间重新采样目标类和背景类的比率，这样它就不会被图像背景淹没。Focal loss（FL）采用另一种方法来减少训练良好的类的损失。因此，只要该模型能够很好地检测背景，就可以减少其损失并重新增强对目标类的训练。我们从交叉熵损失 CE 开始，并添加一个权重来降低高可信度类的 CE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505154928961-1861681079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　例如，令 γ = 0.5, 经良好分类的样本的 Focal loss 趋近于 0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505154944466-182594553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;编辑自原论文&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　这是基于 FPN、ResNet 以及利用 Focal loss 构建的 &lt;strong&gt;&lt;span&gt;RetianNet&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201805/1192699-20180505155008197-695403303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;RetinaNet&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原文链接：https://medium.com/@jonathan_hui/what-do-we-learn-from-region-based-object-detectors-faster-r-cnn-r-fcn-fpn-7e354377a7c9&lt;br/&gt;https://medium.com/@jonathan_hui/what-do-we-learn-from-single-shot-object-detectors-ssd-yolo-fpn-focal-loss-3888677c5f4d&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 07:51:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8994246.html</dc:identifier>
</item>
<item>
<title>R实战 第七篇：绘图文本表 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4489746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4489746.html</guid>
<description>&lt;p&gt;文本表是显示数据的重要图形，一个文本表按照区域划分为：列标题，行标题，数据区，美学特征有：前景样式、背景央视、字体、网格线等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，使用ggtexttable绘图文本表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;载入ggpubr包，可以使用ggtexttable绘制文本表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
library(ggpubr)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，基本函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绘制一个文本表，常会用到7个基本函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ggtexttable()&lt;/strong&gt;：用于绘制文本表，并返回ggtexttable类型的变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ttheme()&lt;/strong&gt;：用于设置表的样式，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rownames_style(), colnames_style(), tbody_style()&lt;/strong&gt;：用于设置列标题，行标题和数据区的样式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;table_cell_font()&lt;/strong&gt;：用于设置单元格中文本的size和face，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;table_cell_bg()&lt;/strong&gt;：用于设置单元格的背景色（fill,color,linewidth）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这7个基本函数的定义是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
ggtexttable(x, rows = rownames(x), cols = colnames(x), vp = NULL, theme =&lt;span&gt; ttheme(), ...)

ttheme(base_style &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, base_size = &lt;span&gt;11&lt;/span&gt;, base_colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, padding = unit(c(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), 
    colnames.style &lt;/span&gt;= colnames_style(size =&lt;span&gt; base_size), 
    rownames.style &lt;/span&gt;= rownames_style(size =&lt;span&gt; base_size),
      tbody.style &lt;/span&gt;= tbody_style(size =&lt;span&gt; base_size))

colnames_style(color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, face = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, size = &lt;span&gt;12&lt;/span&gt;&lt;span&gt;,
  fill &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, linewidth = &lt;span&gt;1&lt;/span&gt;, linecolor = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parse =&lt;span&gt; FALSE, ...)

rownames_style(color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, face = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;italic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, size = &lt;span&gt;12&lt;/span&gt;, fill =&lt;span&gt; NA,
  linewidth &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;, linecolor = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parse =&lt;span&gt; FALSE, ...)

tbody_style(color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, face = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, size = &lt;span&gt;12&lt;/span&gt;&lt;span&gt;,
  fill &lt;/span&gt;= c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey95&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey90&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), linewidth = &lt;span&gt;1&lt;/span&gt;, linecolor = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parse =&lt;span&gt; FALSE, ...)

table_cell_font(tab, row, column, face &lt;/span&gt;= NULL, size =&lt;span&gt; NULL)

table_cell_bg(tab, row, column, fill &lt;/span&gt;= NULL, color = NULL, linewidth = NULL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;vp&lt;/strong&gt;：可选的视口（view port）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parse&lt;/strong&gt;：设置为TRUE时，表示使用文字表示符号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;...&lt;/strong&gt;：额外的参数，用于设置文本对齐，例如：hjust 和 x，其中，hjust = 1 靠右, = 0 靠左，x是间距&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fill&lt;/strong&gt;：填充的背景色，当填充数据区时，如果该参数是含有多个颜色的向量，那么R循环使用向量中颜色来填充表格的背景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;face&lt;/strong&gt;：字体的效果，有效值是 c(&quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tab&lt;/strong&gt;：ggtexttable类型的对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;base_style&lt;/strong&gt;：系统自定义的基础样式，&lt;code&gt;c(&quot;default&quot;, &quot;blank&quot;, &quot;classic&quot;, &quot;minimal&quot;, &quot;light&quot;, &quot;lBlack&quot;, &quot;lBlue&quot;, &quot;lRed&quot;, &quot;lGreen&quot;, &quot;lViolet&quot;, &quot;lCyan&quot;, &quot;lOrange&quot;, &quot;lBlackWhite&quot;, &quot;lBlueWhite&quot;, &quot;lRedWhite&quot;, &quot;lGreenWhite&quot;, &quot;lVioletWhite&quot;, &quot;lCyanWhite&quot;, &quot;lOrangeWhite&quot;, &quot;mBlack&quot;, &quot;mBlue&quot;, &quot;mRed&quot;, &quot;mGreen&quot;, &quot;mViolet&quot;, &quot;mCyan&quot;, &quot;mOrange&quot;, &quot;mBlackWhite&quot;, &quot;mBlueWhite&quot;, &quot;mRedWhite&quot;, &quot;mGreenWhite&quot;, &quot;mVioletWhite&quot;, &quot;mCyanWhite&quot;, &quot;mOrangeWhite&quot; )&lt;/code&gt;. 注意， l = &quot;light&quot;; m = &quot;medium&quot;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;base_size，base_colour&lt;/strong&gt;：默认的字体大小和颜色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;padding&lt;/strong&gt;：是两个元素的向量，指定每个单元格内的文本的水平和垂直填充&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把rows参数设置为NULL，表示移除行名称；使用theme参数自定义表格显示的样式，hjust=1，x=0.9，表示单元格的文本靠右，间距为0.9。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
df &amp;lt;-&lt;span&gt; head(iris)
tbody.style &lt;/span&gt;= tbody_style(color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   fill &lt;/span&gt;= c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#e8f3de&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#d3e8bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), hjust=&lt;span&gt;1&lt;/span&gt;, x=&lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;)
ggtexttable(head(iris), rows &lt;/span&gt;=&lt;span&gt; NULL,
           theme &lt;/span&gt;=&lt;span&gt; ttheme(
             colnames.style &lt;/span&gt;= colnames_style(color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fill = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#8cc257&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
             tbody.style &lt;/span&gt;=&lt;span&gt; tbody.style
           )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180505154549793-1251040658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，设置文本表的单元格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用变量保存文本表的对象，然后对文本表的单元格进行修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
tab &amp;lt;- ggtexttable(head(iris), rows =&lt;span&gt; NULL,
                  theme &lt;/span&gt;= ttheme(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;classic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
tab &lt;/span&gt;&amp;lt;- table_cell_font(tab, row = &lt;span&gt;3&lt;/span&gt;, column = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                      face &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
tab &lt;/span&gt;&amp;lt;- table_cell_bg(tab, row = &lt;span&gt;4&lt;/span&gt;, column = &lt;span&gt;3&lt;/span&gt;, linewidth = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
                    fill&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darkolivegreen1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;darkolivegreen4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
tab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二，使用grid和gridExtra绘制网格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用grid 和 gridExtra这两个包来绘制网格图形，特别是多个图形的布局以及表格的绘制。使用这种方式来绘制文本表，比ggtexttable复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绘制最基本的表格，使用grid.table()函数来绘制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(gridExtra)
library(grid)
d &lt;/span&gt;&amp;lt;- head(iris[,&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;])
grid.table(d)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表格的列名（column name）是由数据框来的列名确定的，列之间的距离（sapce）是由表格单元（cell）和列名的长度确定的，行名（row name）是自动生成的数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180505134528257-1674314288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，美学参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表格的格式是由主题（theme）确定的，theme是图像参数的嵌套列表，内置的两个主题函数是：ttheme_default() 和 ttheme_minimal()，用于指定表格显示的格式，这两个函数的差异是ttheme_minimal()不显示网格线。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
ttheme_default(base_size = &lt;span&gt;12&lt;/span&gt;, base_colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, base_family = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,parse &lt;/span&gt;= FALSE, padding = unit(c(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), ...)
ttheme_minimal(base_size &lt;/span&gt;= &lt;span&gt;12&lt;/span&gt;, base_colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, base_family = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,parse &lt;/span&gt;= FALSE, padding = unit(c(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180505140604918-2118667247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ttheme_minimal()函数定义三个图形选项core，colhead和rowhead，分别用于控制表格显示的&lt;strong&gt;数据区，列标题和行标题&lt;/strong&gt;的格式，该参数的值都是list类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
core/colhead/rowhead=list(bg_params = list(fill = blues9[&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;], col=&lt;span&gt;NA), fg_params&lt;/span&gt;=list(fontface=&lt;span&gt;3&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在每一个图形选项中，可以定义两个图形参数：&lt;strong&gt;bg_params&lt;/strong&gt;和&lt;strong&gt;fg_params&lt;/strong&gt;，分别控制表格的背景和前景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
bg_params = list(fill = blues9[&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;], col=NA,alpha = &lt;span&gt;1&lt;/span&gt;,hjust=&lt;span&gt;0&lt;/span&gt;, x=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
fg_params &lt;/span&gt;= list(col=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fontface=&lt;span&gt;4L&lt;/span&gt;, parse=TRUE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;parse&lt;/strong&gt;：设置为TRUE时，可以使用文字表示符号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;col&lt;/strong&gt;：fg_params中的col参数控制字体的颜色，bg_params中的col控制网格线的颜色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt;：控制背景色的透明度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hjust&lt;/strong&gt;：控制水平对齐， hjust = 1 靠右, = 0 靠左 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vjust&lt;/strong&gt;：控制垂直对齐，vjust = 1 靠上, = 0 靠下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fontface&lt;/strong&gt;：控制字体大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，使用简约风格的主题来绘制表格：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
tt &amp;lt;-&lt;span&gt; ttheme_minimal(
  core&lt;/span&gt;=list(bg_params = list(fill = blues9[&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;], col=&lt;span&gt;NA),
            fg_params&lt;/span&gt;=list(fontface=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)),
  colhead&lt;/span&gt;=list(fg_params=list(col=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;navyblue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fontface=&lt;span&gt;4L&lt;/span&gt;&lt;span&gt;)),
  rowhead&lt;/span&gt;=list(fg_params=list(col=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fontface=&lt;span&gt;3L&lt;/span&gt;&lt;span&gt;)))
grid.table(iris[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;], theme=tt)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201805/628084-20180505135432065-2021247230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sthda.com/english/rpkgs/ggpubr/reference/ggtexttable.html&quot; target=&quot;_blank&quot;&gt;Draw a Textual Table&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rdocumentation.org/packages/ggpubr/versions/0.1.6/topics/ggtexttable&quot; target=&quot;_blank&quot;&gt;ggtexttable&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/gridExtra/gridExtra.pdf&quot; target=&quot;_blank&quot;&gt;Package ‘gridExtra’&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/gridExtra/vignettes/tableGrob.html&quot; target=&quot;_blank&quot;&gt;Displaying tables as grid graphics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rstudio.github.io/DT/&quot; target=&quot;_blank&quot;&gt;DT: An R interface to the DataTables library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rpubs.com/YaPi/357294&quot; target=&quot;_blank&quot;&gt;grid Practice&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 07:50:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4489746.html</dc:identifier>
</item>
<item>
<title>wamp 服务监控和启动 - forestk</title>
<link>http://www.cnblogs.com/forestk/p/8994947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forestk/p/8994947.html</guid>
<description>&lt;p&gt;近日我的 wamp 莫名其妙的崩溃重启，apache 能自动起来， mysql 却悲剧了。&lt;/p&gt;
&lt;p&gt;于是有了下面的wamp服务监控和启动的批处理文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
@echo off

rem define loop time 
set secs=5
set srvname1=&quot;wampapache64&quot;
set srvname2=&quot;wampmysqld64&quot;
 
echo.
echo ==========================================================
echo ==     Query Services Status Every %secs% second
echo ==     Auto Start Services : %srvname1%, %srvname2%
echo ==========================================================
echo Detecting ...
if %srvname1%. == . goto end
if %srvname2%. == . goto end
 
:chkit
set svrst1=0
for /F &quot;tokens=1* delims= &quot; %%a in ('net start') do if /I &quot;%%a&quot; == %srvname1% set svrst1=1
if %svrst1% == 0 echo %date%-%time%
if %svrst1% == 0 net start %srvname1%
set svrst1=

ping -n %secs% 127.0.0.1 &amp;gt; nul

set svrst2=0
for /F &quot;tokens=1* delims= &quot; %%a in ('net start') do if /I &quot;%%a&quot; == %srvname2% set svrst2=1
if %svrst2% == 0 echo %date%-%time%
if %svrst2% == 0 net start %srvname2%

set svrst2=

ping -n %secs% 127.0.0.1 &amp;gt; nul


goto chkit
 
:end
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关键的命令是 for /F &quot;tokens=1* delims= &quot; %%a in ('net start') do if /I &quot;%%a&quot; == %srvname1% set svrst1=1&lt;/p&gt;
&lt;p&gt;详细的 For 命令解说，可参考 ： &lt;a href=&quot;https://blog.csdn.net/wh_19910525/article/details/7912440&quot; target=&quot;_blank&quot;&gt;dos下 和 批处理中的 for 语句的基本用法&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 07:50:00 +0000</pubDate>
<dc:creator>forestk</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forestk/p/8994947.html</dc:identifier>
</item>
<item>
<title>小dai浅谈通信网络（一）——引子 - 你若盛开，清风自来！</title>
<link>http://www.cnblogs.com/daiaiai/p/8994932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daiaiai/p/8994932.html</guid>
<description>&lt;p&gt;说起通信网络，首先来看一个场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小明和小刚在闹市碰面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小明对小刚大声喊道：“小刚，你好啊！”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小刚摇手答到：“你好，小明！”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就这段对话，从通信角度能看到多少信息勒？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.两个人: 小刚和小明&lt;/p&gt;
&lt;p&gt;2.代表两个人的称呼“小明”“小刚”&lt;/p&gt;
&lt;p&gt;3.由于是当面诉说，采用的传播介质是空气；&lt;/p&gt;
&lt;p&gt;4.传播的信号是声波&lt;/p&gt;
&lt;p&gt;5发生装置是声带、舌头、嘴巴&lt;/p&gt;
&lt;p&gt;6.收听装置是耳朵&lt;/p&gt;
&lt;p&gt;7.他们说的是中文，比如小明的发声“小刚”，小刚知道是在称呼自己。并且小明招呼完了，理应该小刚打招呼&lt;/p&gt;
&lt;p&gt;8.发生了两次通话：&lt;/p&gt;
&lt;p&gt;一次是小明对小刚；&lt;/p&gt;
&lt;p&gt;另外一次是小刚对小刚&lt;/p&gt;
&lt;p&gt;9.在此过程中，小明说话的期间，小刚是可以随时说话的&lt;/p&gt;
&lt;p&gt;10.从小刚说话的顺序，不是先称呼，而是先说“你好”，明显有听到小明的招呼，并且因此也告知了小明，我有听到你的招呼。当然这个告知对方我有听到你的招呼，往往可以从肢体语言获知。&lt;/p&gt;
&lt;p&gt;11.从小刚明显听到了小明的话来说，并且还在闹市之中，说明小刚的听力是完全没问题&lt;/p&gt;
&lt;p&gt;12.由于当时在闹市，为了让对方能够准确听到自己的话，明显小明和小刚都放大了说话的分贝。&lt;/p&gt;
&lt;p&gt;以上称述，如有疏忽，欢迎指正，后续再添加上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对应在通信网络中是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.网络设备，比如路由器；&lt;/p&gt;
&lt;p&gt;2.网络识别码，比如以太网的MAC地址&lt;/p&gt;
&lt;p&gt;3.光纤、电缆或者空气；&lt;/p&gt;
&lt;p&gt;4.一般是采用电磁波&lt;/p&gt;
&lt;p&gt;5.发生装置，比如光模块、网卡等；&lt;/p&gt;
&lt;p&gt;6.接收装置，一般同5；&lt;/p&gt;
&lt;p&gt;7.采用的网络协议族，比如2G的GSM、3G的CDMA系列、WIFI的802.11系列什么的。&lt;/p&gt;
&lt;p&gt;     里面会包括调制/编码技术，决定能折腾出来多少信号代号，而每个信号代号代表什么意思；&lt;/p&gt;
&lt;p&gt;     也包括CSMA/CD、CSMA/CA等，指定双方通信规则，就像说话，这不能谁都讲话吧，这不上课老师，总说你有要说的，yes，要举手哦&lt;/p&gt;
&lt;p&gt;8.端到端传输，就比如路由器和路由器两两之间直连的通信，或者你的手机和基站这种。&lt;/p&gt;
&lt;p&gt;9.当前一般都是采用的异步/双工模式，也就是说端到端的传输可以随时发声，并且任何哪一端都可以随时发声。其他还有单工模式和半双工模式,同步传输模式，此处不再累述。&lt;/p&gt;
&lt;p&gt;10/11/12点都属于狭义的QOS（服务质量）范畴，每种网络协议都有自己的QOS机制，由于我最熟悉TCP/IP协议族，在此通过TCP协议做个一一对应&lt;/p&gt;
&lt;p&gt;10.TCP中，通过seq序列号来表示，我发送了多少数据；然后对端再通过ack=seq(准确接受到的最后序列号)+1来告知对端自己准确接收到了哪些数据&lt;/p&gt;
&lt;p&gt;11.TCP中，使用WINDOW机制来设定，一次连续传输的最大数据量大小。接收方会告知对方，我本地能接收到的数据块最大是多少，就是使用window这个参数来告知，而能接收数据块的大小，则由向操作系统申请的socket大小决定。发送方收到window后，会连续的一次性发送数个数据包，直到整个发送的有效数据的大小=或者小于window的大小。而何时下次再发送，请听下一文分解。&lt;/p&gt;
&lt;p&gt;12.TCP中，使用拥塞窗口cwnd/慢启动等机制，可以控制发送方发送速率，有效适应当前网络环境情况。又如在WLAN里面，会根据网络情况，调整不同的键控技术等，来调整速率。&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 07:44:00 +0000</pubDate>
<dc:creator>你若盛开，清风自来！</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daiaiai/p/8994932.html</dc:identifier>
</item>
<item>
<title>别跟我谈EF抵抗并发，敢问你到底会不会用EntityFramework - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8989983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8989983.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;一直以来写的博文都是比较温婉型的博文，今天这篇博文算是一篇批判性博文，有问题欢迎探讨，如标题，你到底会不会用EntityFramework啊。&lt;/p&gt;
&lt;h2&gt;你到底会不会用EntityFramework啊&lt;/h2&gt;
&lt;p&gt;　　面试过三年至六年的同行，作为过面试者到如今作为面试官也算是老大对我的信任，对来面试的面试者的任何一位同行绝没有刁难之意，若还装逼那就没有什么意义。我也基本不看面试者的项目经历，因为我个人觉得每个面试者所在公司所做项目都不一样，可能面试者项目所做的业务我一点都不知道，而我所关心的是项目当中所用到的技术，稍微看下了简历让面试者简单做个自我介绍，这算是基本流程吧。然后直接问面试者最擅长的技术是哪些？比如ASP.NET MVC、比如ASP.NET Web APi、比如EntityFramework，再比如数据库等等。如果面试者没有特别擅长的技术那我就简历上提出所熟悉和项目当中用到的技术进行提问。这里暂且不提其他技术，单单说EntityFramework，面试的面试者大部分都有用过EntityFramework，我就简单问了下，比如您用的EntityFramework版本是多少？答案是不知道，这个我理解，可能没去关心过这个问题，再比如我问您知道EntityFramework中有哪些继承策略，然后面试者要么是一脸懵逼，要么是不知道，要么回了句我们不用。这个我也能理解，重点来了，我问您在EntityFramwork中对于批量添加操作是怎么做的，无一例外遍历循环一个一个添加到上下文中去，结果令我惊呆了，或许是只关注于实现，很多开发者只关注这个能实现就好了，这里不过多探讨这个问题，每个人观点不一样。&lt;/p&gt;
&lt;p&gt;　　大部分人用EntityFramework时出现了问题，就吐槽EntityFramework啥玩意啊，啥ORM框架啊，各种问题，我只能说您根本不会用EntityFramework，甚至还有些人并发测试EntityFramework的性能，是的，没错，EntityFramework性能不咋的（这里我们只讨论EF 6.x），或者说在您实际项目当中有了点并发发现EF出了问题，又开始抱怨EF不行了，同时对于轻量级、跨平台、可扩展的EF Core性能秒杀EF，即使你并发测试EF Core性能也就那么回事，我想说的是你并发测试EF根本没有任何意义，请好生理解EF作为ORM框架出现的意义是什么，不就是为了让我们关注业务么，梳理好业务对象，在EF中用上下文操作对象就像直接操作表一样。然后我们回到EF抵抗并发的问题，有的童鞋认为EF中给我提供了并发Token和行版本以及还有事务，这不就是为了并发么，童鞋对于并发Token和行版本这是对于少量的请求可能存在的并发EF团队提出的基本解决方案，对于事务无论是同一上文抑或是跨上下文也好只是为了保证数据一致性罢了。要是大一点的并发来了，您难道还让EF不顾一切冲上去么，这无疑是飞蛾扑火自取灭亡，你到底会不会用EntityFramework啊。EF作为概念上的数据访问层应该是处于最底层，如果我们项目可预见没有所谓的并发问题，将上下文直接置于最上层比如控制器中并没有什么问题，但是项目比较大，随着用户量的增加，我们肯定是可预知的，这个我们需要从项目架构层面去考虑，此时在上下文上游必定还有其他比如C#中的并发队列或者Redis来进行拦截使其串行进行。&lt;/p&gt;
&lt;p&gt;　　有些人号称是对EntityFramwork非常了解，认为不就是增、删、该、查么，但是有的时候用出了问题就开始自我开解，我这么用没有任何问题啊，我们都知道在EF 6.x中确实有很多坑，这个时候就借这个缘由洗白了，这不是我的锅，结果EF背上了无名之锅，妄名之冤。是的，您们没有说错，EF 6.x是有很多坑，您避开这些坑不就得了，我只能说这些人太浮于表面不了解基本原理就妄下结论，你到底会不会用EntityFramework啊。好了来，免说我纸上谈兵，我来举两个具体例子，您们看你到底会不会用。&lt;/p&gt;
&lt;h2&gt;EntityFramework 6.x查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order = ctx.Orders.FirstOrDefault(d =&amp;gt; d.Code ==&lt;span&gt; code);           
            };
            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的例子用过EF 6.x的童鞋估计用烂了吧，然后查询出来的结果让我们也非常满意至少是达到了我们的预期，我们来看看生成的SQL语句。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505034150312-1492611243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请问用EF的您们发现什么没有，在WHERE查询条件加上了一堆没有用的东西，我只是查询Code等于Jeffcky的实体数据，从生成的SQL来看可查询Code等于Jeffcky的也可查询Code等于空的数据，要是我们如下查询，生成如上SQL语句我觉得才是我们所预期的对不对。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orders = ctx.Orders.Where(d =&amp;gt; d.Code == &lt;span&gt;null&lt;/span&gt; || d.Code ==&lt;span&gt; code).ToList();

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果您真的会那么一点点用EntityFramework，那么请至少了解背后生成的SQL语句吧，这是其中之一，那要是我们直接使用值查询呢，您们觉得是否和利用参数生成的SQL语句是一样的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order = ctx.Orders.FirstOrDefault(d =&amp;gt; d.Code == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505040445058-460584128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出乎意料吧，利用值查询在WHERE条件上没有过多的条件过滤，而利用参数查询则是生成过多的条件筛选，到这里是不是就到此为止了呢，如果您们对于参数查询不想生成对空值的过滤，我们在上下文构造函数中可关闭这种所谓【语义可空】判断，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EfDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EfDbContext() : &lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;span&gt;Configuration.UseDatabaseNullSemantics &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= true&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
        }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505040820406-1488825092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;// 摘要:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取或设置一个值，该值指示当比较两个操作数，而它们都可能为 null 时，是否展示数据库 null 语义。默认值为 false。例如：如果 UseDatabaseNullSemantics&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 为 true，则 (operand1 == operand2) 将转换为 (operand1 = operand2)；如果 UseDatabaseNullSemantics&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 为 false，则将转换为 (((operand1 = operand2) AND (NOT (operand1 IS NULL OR operand2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// IS NULL))) OR ((operand1 IS NULL) AND (operand2 IS NULL)))。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 返回结果:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果启用数据库 null 比较行为，则为 true；否则为 false。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在EF 6.x中对于查询默认情况下会进行【语义可空】筛选，通过如上分析，不知您们是否知道如上的配置呢。&lt;/p&gt;
&lt;h2&gt;EntityFramework 6.x更新&lt;/h2&gt;
&lt;p&gt;EF 6.x更新操作又是用熟透了吧，在EF中没有Update方法，而在EF Core中存在Update和UpdateRange方法，您们是否觉得更新又是如此之简单呢？我们下面来首先看一个例子，看看您们是否真的会用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Customer GetCustomer()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
            {
                Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上实体如我们请求传到后台需要修改的实体（假设该实体在数据库中存在哈），这里我们进行写死模拟。接下来我们来进行如下查询，您们思考一下是否能正常更新呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer = ctx.Customers.FirstOrDefault(d =&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    ctx.Customers.Attach(customer);
                    ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们根据传过来的实体主键去数据库中查询是否存在，若存在则将传过来的实体附加到上下文中（因为此时请求过来的实体还未被跟踪），然后将其状态修改为已被修改，最后提交，解释的是不是非常合情合理且合法，那是不是就打印更新成功了呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505042827387-1846036817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到上述错误想必有部分童鞋一下子就明白问题出在哪里，当我们根据传过来的实体主键去数据库查询，此时在数据库中存在就已被上下文所跟踪，然后我们又去附加已传过来的实体且修改状态，当然会出错因为在上下文已存在相同的对象，此时必然会产生已存在主键冲突。有的童鞋想了直接将传过来的实体状态修改为已修改不就得了么，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此肯定能更新成功了，我想都不会这么干吧，要是客户端进行传过来的主键在数据库中不存在呢（至少我们得保证数据是已存在才修改），此时进行如上操作将抛出如下异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505043732674-656840341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时为了解决这样的问题最简单的方法之一则是在查询实体是否存在时直接通过AsNoTracking方法使其不能被上下文所跟踪，这样就不会出现主键冲突的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .AsNoTracking()
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id == customer.Id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505044031767-655577929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们继续往下探讨 ，此时我们将数据库Email修改为可空（映射也要对应为可空，否则抛出验证不通过的异常，你懂的），如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505045519785-848286229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后将前台传过来的实体进行如下修改，不修改Email，我们注释掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Customer GetCustomer()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
            {
                Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Email = &quot;2752154844@qq.com&quot;,&lt;/span&gt;
                Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们接着再来进行如下查询试试看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .AsNoTracking()
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    ctx.Customers.Attach(customer);
                    ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505045706386-1802954226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时Email为可空，因为我们设置实体状态为Modified，此时将对实体进行全盘更新，所以对于设置实体状态为Modified是针对所有列更新，要是我们只想更新指定列，那这个就不好使了，此时我们可通过Entry().Property()...来手动更新指定列，比如如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .AsNoTracking()
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    ctx.Customers.Attach(customer);
                    ctx.Entry(customer).Property(p &lt;/span&gt;=&amp;gt; p.Name).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    ctx.Entry(customer).Property(p &lt;/span&gt;=&amp;gt; p.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505135158525-2026476692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们继续往下走。除了上述利用AsNoTracking方法外使其查询出来的实体未被上下文跟踪而成功更新，我们还可以使用手动赋值的方式更新数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    dataBaseCustomer.CreatedTime &lt;/span&gt;=&lt;span&gt; customer.CreatedTime;
                    dataBaseCustomer.ModifiedTime &lt;/span&gt;=&lt;span&gt; customer.ModifiedTime;
                    dataBaseCustomer.Email &lt;/span&gt;=&lt;span&gt; customer.Email;
                    dataBaseCustomer.Name &lt;/span&gt;=&lt;span&gt; customer.Name;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上也能更新成功而不用将查询出来的实体未跟踪，然后将前台传过来的实体进行附加以及修改状态，下面我们删除数据库中创建时间和修改时间列，此时我们保持数据库中数据和从前台传过来的数据一模一样，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Customer GetCustomer()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
            {
                Id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505051350428-1480041787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们再来进行如下赋值修改，你会发现此时更新失败的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    dataBaseCustomer.Email &lt;/span&gt;=&lt;span&gt; customer.Email;
                    dataBaseCustomer.Name &lt;/span&gt;=&lt;span&gt; customer.Name;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180505051506451-834923367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是为何呢？因为数据库数据和前台传过来的数据一模一样，但是不会进行更新，毫无疑问EF这样处理是明智且正确的，无需多此一举更新，那我们怎么知道是否有不一样的数据进行更新操作呢，换句话说EF怎样知道数据未发生改变就不更新呢？我们可以用上下文属性中的ChangeTacker中的HasChanges方法，如果上下文知道数据未发生改变，那么直接返回成功，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    dataBaseCustomer.Email &lt;/span&gt;=&lt;span&gt; customer.Email;
                    dataBaseCustomer.Name &lt;/span&gt;=&lt;span&gt; customer.Name;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;&lt;span&gt;ctx.ChangeTracker.HasChanges&lt;/span&gt;())
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了到此为止我们已经看到关于更新已经有了三种方式，别着急还有最后一种，通过Entry().CurrentValues.SetValues()方式，这种方式也是指定更新，将当前实体的值设置数据库中查询出来所被跟踪的实体的值。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer =&lt;span&gt; GetCustomer();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataBaseCustomer =&lt;span&gt; ctx.Customers
                    .FirstOrDefault(d &lt;/span&gt;=&amp;gt; d.Id ==&lt;span&gt; customer.Id);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dataBaseCustomer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;span&gt;ctx.Entry(dataBaseCustomer).CurrentValues.SetValues(customer);
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctx.SaveChanges() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于EF更新方式讲了四种，其中有关细枝末节就没有再细说可自行私下测试，不知道用过EF的您们是否四种都知道以及每一种对应的场景是怎样的呢？对于数据更新我一般直接通过查询进行赋值的形式，当然我们也可以用AutoMapper，然后通过HasChanges方法来进行判断。&lt;/p&gt;
&lt;h2&gt;EntityFramework 6.x批量添加&lt;/h2&gt;
&lt;p&gt;对于批量添加已经是EF 6.x中老掉牙的话题，但是依然有很多面试者不知道，我这里再重新讲解一次，对于那些私下不学习，不与时俱进的童鞋好歹也看看前辈们（不包括我）总经的经验吧，不知道为何这样做，至少回答答案是对的吧。看到下面的批量添加数据代码是不是有点想打人。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100000&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer
                    {
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Name &lt;/span&gt;=&lt;span&gt; i.ToString()
                    };
                    ctx.Customers.Add(customer);
                    ctx.SaveChanges();
                }
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于原因无需我过多解释，如果您这样操作，那您这一天的工作大概也就是等着数据添加完毕，等啊等。再不济您也将SaveChanges放在最外层一次性提交啊，这里我就不再测试，浪费时间在这上面没必要，只要您稍微懂点EF原理至少会如下这么使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; customers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100000&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer
                    {
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Name &lt;/span&gt;=&lt;span&gt; i.ToString()
                    };
                    customers.Add(customer);
                }
                ctx.Customers.AddRange(customers);
                ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果您给我的答案如上，我还是认可的，要是第一种真的说不过去了啊。经过如上操作依然有问题，我们将所有记录添加到同一上下文实例，这意味着EF会跟踪这十万条记录， 对于刚开始添加的几个记录，会运行得很快，但是当越到后面到达到十万时，EF正在追踪更大的对象图，您们觉得恐怖不，这就是您不懂EF原理的代价，还对其进行诟病，吐槽性能可以，至少保证你写的代码没问题吧，我们进一步优化需要关闭自调用的DetectChanges方法无需进行对每一个添加的实体进行扫描。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; customers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; acd =&lt;span&gt; ctx.Configuration.AutoDetectChangesEnabled;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100000&lt;/span&gt;; i++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer
                        {
                            Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            Name &lt;/span&gt;=&lt;span&gt; i.ToString()
                        };
                        customers.Add(customer);
                    }
                    ctx.Customers.AddRange(customers);
                    ctx.SaveChanges();
                }
                &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
                {
                    ctx.Configuration.AutoDetectChangesEnabled &lt;/span&gt;=&lt;span&gt; acd;
                }
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们通过局部关闭自调用DetectChanges方法，此时EF不会跟踪实体，这样将不会造成全盘扫描而使得我们不会处于漫长的等待，如此优化将节省大量时间。如果在我们了解原理的前提下知道添加数据到EF上下文中，随着数据添加到集合中也会对已添加的数据进行全盘扫描，那我们何不创建不同的上下文进行批量添加呢？未经测试在这种情况下是否比关闭自调用DetectChanges方法效率更高，仅供参考，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFContextExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EfDbContext BatchInsert&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; EfDbContext context, T entity, &lt;span&gt;int&lt;/span&gt; count, &lt;span&gt;int&lt;/span&gt; batchSize) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        {
            context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().Add(entity);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count % batchSize == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                context.SaveChanges();
                context.Dispose();
                context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt;();
            EfDbContext ctx;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100000&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer
                    {
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Name &lt;/span&gt;=&lt;span&gt; i.ToString()
                    };
                    ctx &lt;/span&gt;= ctx.BatchInsert(customer, i, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                }
                ctx.SaveChanges();
            };
            Console.ReadKey();
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;不喜勿喷，敢问您们到底会不会用EntityFramework啊，EF 6.x性能令人诟病但是至少得保证您们写的代码没问题吧，您们可结合Dapper使用啊，担心EF 6.x性能不行，那请用EntityFramework Core吧，你值得拥有。谨以此篇批判那些不会用EF的同行，还将EF和并发扯到一块，EF不是用来抵抗并发，它的出现是为了让我将重心放在梳理业务对象，关注业务上，有关我对EF 6.x和EF Core 2.0理解全部集成到我写的书《你必须掌握的EntityFramework 6.x与Core 2.0》最近即将出版，想了解的同行可关注下，谢谢。&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 07:21:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8989983.html</dc:identifier>
</item>
<item>
<title>Spring Cloud入门教程-Ribbon实现客户端负载均衡 - 乾儿_Polaris</title>
<link>http://www.cnblogs.com/zxuqian/p/8994758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxuqian/p/8994758.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4914554-8a1b07e275c751f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们继续以之前博客的代码为基础，增加Ribbon组件来提供客户端负载均衡。负载均衡是实现高并发、高性能、可伸缩服务的重要组成部分，它可以把请求分散到一个集群中不同的服务器中，以减轻每个服务器的负担。客户端负载均衡是运行在客户端程序中的，如我们的web项目，然后通过获取集群的IP地址列表，随机选择一个server发送请求。相对于服务端负载均衡来说，它不需要消耗服务器的资源。&lt;/p&gt;
&lt;h2 id=&quot;基础环境&quot;&gt;基础环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;Maven 3.3.9&lt;/li&gt;
&lt;li&gt;IntelliJ 2018.1&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;项目源码&quot;&gt;项目源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zxuqian/spring-cloud/tree/spring-cloud-tutorial-ribbon&quot;&gt;Gitee码云&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;更新配置&quot;&gt;更新配置&lt;/h2&gt;
&lt;p&gt;我们这次需要在本地启动两个产品服务程序，用来验证负载均衡，所以需要为第二个程序提供不同的端口。Spring Cloud配置服务中心的配置默认会覆盖本地系统环境变量，而我们需要通过系统环境变量来设置产品服务的端口，所以需要在配置中心git仓库中修改产品服务的配置文件&lt;code&gt;product-service.yml&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8081
&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;cloud:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;config:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;allow-override:&lt;/span&gt; true
      &lt;span class=&quot;fu&quot;&gt;override-system-properties:&lt;/span&gt; false&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;allow-override&lt;/code&gt;的默认值即为true，写出它来是想作说明，它的意思是允许远程配置中心的配置项覆盖本地的配置，并不是说允许本地的配置去覆盖远程的配置。当然我们可以把它设置成false，但是为了提供更精确的覆盖规则，这里保留了默认值。&lt;br/&gt;我们添加了&lt;code&gt;override-system-properties=false&lt;/code&gt;，即虽然远程配置中心的配置文件可以覆盖本地的配置，但是不要覆盖本地系统变量。修改完成后提交到git仓库。&lt;/p&gt;
&lt;p&gt;另外，在&lt;code&gt;productService&lt;/code&gt;项目的&lt;code&gt;ProductController&lt;/code&gt;中添加一些log，用来验证负载均衡是否生效：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package cn.zxuqian.controllers;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.slf4j.Logger;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.LoggerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RestController;&lt;/span&gt;


&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductController {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Logger log = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(ProductController.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/products&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productList&lt;/span&gt;() {
        log.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access to /products endpoint&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;外套，夹克，毛衣，T恤&quot;&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;为web配置ribbon&quot;&gt;为web配置Ribbon&lt;/h2&gt;
&lt;p&gt;首先在&lt;code&gt;pom.xml&lt;/code&gt;中添加Ribbon的依赖：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-ribbon&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后修改&lt;code&gt;Application&lt;/code&gt;类，添加如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@EnableCircuitBreaker&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RibbonClient&lt;/span&gt;(name = &lt;span class=&quot;st&quot;&gt;&quot;product-service&quot;&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Application {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(Application.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@LoadBalanced&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RestTemplate &lt;span class=&quot;fu&quot;&gt;rest&lt;/span&gt;(RestTemplateBuilder builder) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; builder.&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用到了&lt;code&gt;@RibbonClient(name = &quot;product-service&quot;)&lt;/code&gt;注解，用来标记此项目为Ribbon负载均衡的客户端，它需要选择产品服务集群中其中的一台来访问所需要的服务，这里的&lt;code&gt;name&lt;/code&gt;属性对应于productService项目中配置的&lt;code&gt;spring.application.name&lt;/code&gt;属性。&lt;br/&gt;&lt;code&gt;@LoadBalanced&lt;/code&gt;注解标明了&lt;code&gt;RestTemplate&lt;/code&gt;会被配置为自动使用Ribbon的&lt;code&gt;LoadBalancerClient&lt;/code&gt;来选择服务的uri并发送请求。&lt;/p&gt;
&lt;p&gt;在我们在&lt;code&gt;ProductService&lt;/code&gt;类中添加如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductService {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; RestTemplate restTemplate;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; DiscoveryClient discoveryClient;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProductService&lt;/span&gt;(RestTemplate restTemplate) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;restTemplate&lt;/span&gt; = restTemplate;
    }

    &lt;span class=&quot;fu&quot;&gt;@HystrixCommand&lt;/span&gt;(fallbackMethod = &lt;span class=&quot;st&quot;&gt;&quot;backupProductList&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productList&lt;/span&gt;() {
        List&amp;lt;ServiceInstance&amp;gt; instances = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;discoveryClient&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getInstances&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;product-service&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(instances != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; instances.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;restTemplate&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getForObject&lt;/span&gt;(instances.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getUri&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;/products&quot;&lt;/span&gt;, String.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        }

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;backupProductList&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;夹克，毛衣&quot;&lt;/span&gt;;
    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productListLoadBalanced&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;restTemplate&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getForObject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://product-service/products&quot;&lt;/span&gt;, String.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里新添加了一个&lt;code&gt;productListLoadBalanced&lt;/code&gt;方法，跟之前的&lt;code&gt;productList&lt;/code&gt;方法访问的是同一服务，只不过是用Ribbon Client去做了负载均衡，这里的uri的host变成了&lt;code&gt;product-service&lt;/code&gt;即要访问的服务的名字，跟&lt;code&gt;@RibbonClient&lt;/code&gt;中配置的&lt;code&gt;name&lt;/code&gt;属性保持一致。最后在我们的&lt;code&gt;ProductController&lt;/code&gt;中添加下面的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductController {

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ProductService productService;

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/products&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productList&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; productService.&lt;span class=&quot;fu&quot;&gt;productList&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/productslb&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productListLoadBalanced&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; productService.&lt;span class=&quot;fu&quot;&gt;productListLoadBalanced&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来创建一个专门处理&lt;code&gt;/productslb&lt;/code&gt;请求的方法，调用&lt;code&gt;productServie&lt;/code&gt;提供负载均衡的方法。&lt;/p&gt;
&lt;p&gt;到这里我们的代码就完成了，代码看似简单，其实是所有的配置都使用了默认值。Ribbon提供了编程式和配置式两种方式来配置Ribbon Client。现简单介绍下，后续深入Ribbon时再和大家一起看看如何修改它的配置。Ribbon提供如下配置(左边是接口，右边是默认实现)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IClientConfig&lt;/code&gt; ribbonClientConfig: DefaultClientConfigImpl&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IRule ribbonRule&lt;/code&gt;: ZoneAvoidanceRule&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPing ribbonPing&lt;/code&gt;: DummyPing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerList&amp;lt;Server&amp;gt;&lt;/code&gt; ribbonServerList: ConfigurationBasedServerList&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerListFilter&amp;lt;Server&amp;gt;&lt;/code&gt; ribbonServerListFilter: ZonePreferenceServerListFilter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ILoadBalancer&lt;/code&gt; ribbonLoadBalancer: ZoneAwareLoadBalancer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerListUpdater&lt;/code&gt; ribbonServerListUpdater: PollingServerListUpdater&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为我们这个项目用了Eureka，所以有些配置项和默认实现有所不同，如Eureka使用&lt;code&gt;DiscoveryEnabledNIWSServerList&lt;/code&gt;取代&lt;code&gt;ribbonServerList&lt;/code&gt;来获取在Eureka上注册的服务的列表。下边有一个简单的Congiguration类，来自Spring官网：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SayHelloConfiguration {

  &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
  IClientConfig ribbonClientConfig;

  &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; IPing &lt;span class=&quot;fu&quot;&gt;ribbonPing&lt;/span&gt;(IClientConfig config) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PingUrl&lt;/span&gt;();
  }

  &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; IRule &lt;span class=&quot;fu&quot;&gt;ribbonRule&lt;/span&gt;(IClientConfig config) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;AvailabilityFilteringRule&lt;/span&gt;();
  }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ribbon默认不会发送Ping检查server的健康状态，默认均正常，然后IRune默认实现为&lt;code&gt;ZoneAvoidanceRule&lt;/code&gt;用来避免AWS EC2问题较多的zone，这在本地测试环境来说是用不到的，然后替换成了&lt;code&gt;AvailabilityFilteringRule&lt;/code&gt;，这个可以开启Ribbon自带的断路器功能，来过滤不正常工作的服务器。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;首先启动我们的&lt;code&gt;configserver&lt;/code&gt;配置中心服务，然后启动&lt;code&gt;registry&lt;/code&gt; Eureka注册与发现服务，然后启动两个&lt;code&gt;productService&lt;/code&gt;，第一个我们可以正常使用&lt;code&gt;spring-boot:run&lt;/code&gt;插件来启动，第二个我们需要给它提供一个新的端口，可以用如下命令启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ SERVER_PORT=8082 mvn spring-boot:run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后启动我们的&lt;code&gt;web&lt;/code&gt;客户端项目，访问&lt;code&gt;http://localhost:8080/productslb&lt;/code&gt;，然后刷新几次，会看到运行着&lt;code&gt;productService&lt;/code&gt;的两个命令行窗口会随机出现我们的log：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Access to /products endpoint&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;欢迎访问我的博客&lt;a href=&quot;http://zxuqian.cn/spring-cloud-tutorial-ribbon/&quot;&gt;张旭乾的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 07:02:00 +0000</pubDate>
<dc:creator>乾儿_Polaris</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxuqian/p/8994758.html</dc:identifier>
</item>
<item>
<title>RocketMQ源码 — 六、 RocketMQ高可用（1） - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8994705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8994705.html</guid>
<description>&lt;p&gt;高可用究竟指的是什么？请参考：&lt;a href=&quot;https://coolshell.cn/articles/17459.html&quot;&gt;关于高可用的系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RocketMQ做了以下的事情来保证系统的高可用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多master部署，防止单点故障&lt;/li&gt;
&lt;li&gt;消息冗余（主从结构），防止消息丢失&lt;/li&gt;
&lt;li&gt;故障恢复（本篇暂不讨论）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么问题来了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;怎么支持多broker的写？&lt;/li&gt;
&lt;li&gt;怎么实现消息冗余？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分开说明这两个问题&lt;/p&gt;
&lt;h2 id=&quot;多master集群&quot;&gt;多master集群&lt;/h2&gt;
&lt;p&gt;这里强调出master集群，是因为需要多个broker set，而一个broker set只有一个master（见下文的“注意”），所以是master集群&lt;/p&gt;
&lt;p&gt;broker有三种角色：ASYNC_MASTER、SYNC_MASTER和SLAVE，这些角色常用的搭配为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ASYNC_MASTER、SLAVE：容许丢消息，但是要broker一直可用，master异步传输CommitLog到slave&lt;/li&gt;
&lt;li&gt;SYNC_MASTER、SLAVE：不允许丢消息，master同步传输CommitLog到slave&lt;/li&gt;
&lt;li&gt;ASYNC_MASTER：如果只是想简单部署则使用这种方式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;master：负责消息的读写&lt;/p&gt;
&lt;p&gt;slave：只负责读消息&lt;/p&gt;
&lt;p&gt;SYNC_MASTER与ASYNC_MASTER的区别是sync会等待消息传输到slave才算消息写完成，而async不会同步等待，而是异步复制到slave&lt;/p&gt;
&lt;p&gt;RocketMQ的架构图（&lt;a href=&quot;http://rocketmq.apache.org/docs/rmq-arc/&quot;&gt;原图地址&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201805/846961-20180505144614692-1825592300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：在RocketMQ里面有一个概念broker set，一个broker set由一个master和多个slave组成，一个broker set内的每个broker的brokerName相同。&lt;/p&gt;
&lt;p&gt;在broker集群中每个master相互之间是独立，master之间不会有交互，每个master维护自己的CommitLog、自己的ConsumeQueue，但是每一个master都有可能收到同一个topic下的producer发来的消息&lt;/p&gt;
&lt;p&gt;为了支持多master集群，需要解决几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;namesrv怎么管理broker&lt;/li&gt;
&lt;li&gt;producer发送消息的时候知道发送到哪一个broker（为什么是master）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;namesrv怎么管理broker&quot;&gt;1. namesrv怎么管理broker&lt;/h3&gt;
&lt;p&gt;broker启动的时候会向namesrv注册自己的信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.broker.BrokerController#registerBrokerAll&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;registerBrokerAll&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; checkOrderConfig, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; oneway) {
    TopicConfigSerializeWrapper topicConfigWrapper = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getTopicConfigManager&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;buildTopicConfigSerializeWrapper&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
    RegisterBrokerResult registerBrokerResult = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerOuterAPI&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;registerBrokerAll&lt;/span&gt;(
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerConfig&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBrokerClusterName&lt;/span&gt;(),
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBrokerAddr&lt;/span&gt;(),
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerConfig&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBrokerName&lt;/span&gt;(),
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerConfig&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBrokerId&lt;/span&gt;(),
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getHAServerAddr&lt;/span&gt;(),
        topicConfigWrapper,
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;filterServerManager&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;buildNewFilterServerList&lt;/span&gt;(),
        oneway,
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerConfig&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getRegisterBrokerTimeoutMills&lt;/span&gt;());
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;信息中包括：&lt;/p&gt;
&lt;p&gt;clusterName：broker 集群的名字，如：DefaultCluster&lt;/p&gt;
&lt;p&gt;brokerAddr：broker的ip:port，如：192.168.0.102:10911&lt;/p&gt;
&lt;p&gt;brokerName：注意这个字段，上面介绍过了，一个broker set中的brokerName是相同的，需要在部署的时候配置&lt;/p&gt;
&lt;p&gt;brokerId：用来唯一标示一个broker set中的broker，master是0（org.apache.rocketmq.common.MixAll#MASTER_ID），slave是正整数&lt;/p&gt;
&lt;p&gt;haServerAddr：haServer的ip:port，如：192.168.0.102:10912&lt;/p&gt;
&lt;p&gt;topicConfigWrapper：是比较复杂的数据结构，主要包含了broker上所有的topic信息，如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;dataVersion&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;counter&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1514252649572&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;topicConfigTable&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;perm&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;readQueueNums&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicFilterType&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;SINGLE_TAG&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicName&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicSysFlag&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;writeQueueNums&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;%RETRY%please_rename_unique_group_name_4&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;perm&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;readQueueNums&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicFilterType&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;SINGLE_TAG&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicName&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;%RETRY%please_rename_unique_group_name_4&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;topicSysFlag&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;writeQueueNums&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面包含了两个topic：TopicTest和%RETRY%please_rename_unique_group_name_4，相关字段的含义：&lt;/p&gt;
&lt;p&gt;order：是否是顺序消息&lt;/p&gt;
&lt;p&gt;perm：表明该topic的权限，可读（4）、可写（2）、可继承（1），通过位运算组合&lt;/p&gt;
&lt;p&gt;readQueueNums：决定了consume消费的MessageQueue共有几个&lt;/p&gt;
&lt;p&gt;writeQueueNums：决定了producer发送消息的MessageQueue共有几个&lt;/p&gt;
&lt;p&gt;这些信息发送给namesrv之后，namesrv转化为自己的数据结构，namesrv处理broker注册的方法是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#registerBroker&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; RegisterBrokerResult &lt;span class=&quot;fu&quot;&gt;registerBroker&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String clusterName,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String brokerAddr,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String brokerName,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; brokerId,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String haServerAddr,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; TopicConfigSerializeWrapper topicConfigWrapper,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; filterServerList,
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Channel channel) {
    RegisterBrokerResult result = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RegisterBrokerResult&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 这里会判断只有master才会创建QueueData，因为只有master才包含了读写队列的信息&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// slave没有自己独立的读写队列信息（salve不会创建自己的queue信息），只是和master的的读写队列信息一致&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; != topicConfigWrapper
                &amp;amp;&amp;amp; MixAll.&lt;span class=&quot;fu&quot;&gt;MASTER_ID&lt;/span&gt; == brokerId) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;isBrokerTopicConfigChanged&lt;/span&gt;(brokerAddr, topicConfigWrapper.&lt;span class=&quot;fu&quot;&gt;getDataVersion&lt;/span&gt;())
                    || registerFirst) {
                    ConcurrentMap&amp;lt;String, TopicConfig&amp;gt; tcTable =
                        topicConfigWrapper.&lt;span class=&quot;fu&quot;&gt;getTopicConfigTable&lt;/span&gt;();
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tcTable != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Map.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;&amp;lt;String, TopicConfig&amp;gt; entry : tcTable.&lt;span class=&quot;fu&quot;&gt;entrySet&lt;/span&gt;()) {
                            &lt;span class=&quot;co&quot;&gt;// 这个方法创建了QueueData，QueueData包含broker set下的读写队列的信息&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createAndUpdateQueueData&lt;/span&gt;(brokerName, entry.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;());
                        }
                    }
                }
            }

            &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        log.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;registerBroker Exception&quot;&lt;/span&gt;, e);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面涉及到的namesrv的几个重要数据结构&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 每个cluster下的broker set信息，一个brokerName对应的broker set&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span class=&quot;co&quot;&gt;/* clusterName */&lt;/span&gt;, Set&amp;lt;String&lt;span class=&quot;co&quot;&gt;/* brokerName */&lt;/span&gt;&amp;gt;&amp;gt; clusterAddrTable;
&lt;span class=&quot;co&quot;&gt;// 每个broker set中的broker信息(set中有哪些broker，每个broker的brokerId和brokerAddr)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span class=&quot;co&quot;&gt;/* brokerName */&lt;/span&gt;, BrokerData&amp;gt; brokerAddrTable;
&lt;span class=&quot;co&quot;&gt;// 每个broker的存活情况&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span class=&quot;co&quot;&gt;/* brokerAddr */&lt;/span&gt;, BrokerLiveInfo&amp;gt; brokerLiveTable;
&lt;span class=&quot;co&quot;&gt;// 每个topic下的queue信息，包括每个broker set中读写队列的个数，consumer消费消息和producer发送消息的路由信息都从这个数据结构中获取&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HashMap&amp;lt;String&lt;span class=&quot;co&quot;&gt;/* topic */&lt;/span&gt;, List&amp;lt;QueueData&amp;gt;&amp;gt; topicQueueTable;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，namesrv通过将broker注册来的信息构造成自己的数据结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个cluster有哪些broker set&lt;/li&gt;
&lt;li&gt;每个broker set包括哪些broker，brokerId和broker的ip:port&lt;/li&gt;
&lt;li&gt;每个broker的存活情况，根据每次broker上报来的信息，清除可能下线的broker&lt;/li&gt;
&lt;li&gt;每个topic的消息队列信息，几个读队列，几个写队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;namesrv汇总所有的broker的这些信息，然后供consumer和producer拉取&lt;/p&gt;
&lt;h3 id=&quot;producer发送消息的时候知道发送到哪一个master&quot;&gt;2. producer发送消息的时候知道发送到哪一个master&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sunshine-2015/p/6291116.html&quot;&gt;之前&lt;/a&gt;我们知道producer发送消息的时候发往哪一个broker是由MessageQueue决定的，所以我们先要搞清楚producer发送消息时候的MessageQueue怎么来的。producer维护了一个topicPublishInfoTable，里面包含了每个topic对应的MessageQueue，所以问题就变成了topicPublishInfoTable怎么构造的。&lt;/p&gt;
&lt;p&gt;producer发送消息之前都会获取topic对应的队列信息，当topicPublishInfoTable中没有的时候会从namesrv获取，获取的方法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.client.impl.factory.MQClientInstance#updateTopicRouteInfoFromNameServer(java.lang.String, boolean, org.apache.rocketmq.client.producer.DefaultMQProducer)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;updateTopicRouteInfoFromNameServer&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String topic, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isDefault,
    DefaultMQProducer defaultMQProducer) {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lockNamesrv&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;(LOCK_TIMEOUT_MILLIS, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;)) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                TopicRouteData topicRouteData;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isDefault &amp;amp;&amp;amp; defaultMQProducer != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;co&quot;&gt;// 从manesrv获取topic的路由信息，namesrv从topicQueueTable获取到该topic对应的所有的QueueData&lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// 然后将每个brokerName下的BrokerData返回&lt;/span&gt;
                    topicRouteData = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;mQClientAPIImpl&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getTopicRouteInfoFromNameServer&lt;/span&gt;(topic, &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;);
                }
                      &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
                      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (BrokerData bd : topicRouteData.&lt;span class=&quot;fu&quot;&gt;getBrokerDatas&lt;/span&gt;()) {
                            &lt;span class=&quot;co&quot;&gt;// 每个broker set下所有的broker地址(ip:port)&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerAddrTable&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(bd.&lt;span class=&quot;fu&quot;&gt;getBrokerName&lt;/span&gt;(), bd.&lt;span class=&quot;fu&quot;&gt;getBrokerAddrs&lt;/span&gt;());
                        }
                        &lt;span class=&quot;co&quot;&gt;// Update Pub info&lt;/span&gt;
                        {
                            &lt;span class=&quot;co&quot;&gt;// 将从namesrv获取到的路由信息转换为TopicPublishInfo&lt;/span&gt;
                            &lt;span class=&quot;co&quot;&gt;// 期间会将没有master的broker set的queue信息去除&lt;/span&gt;
                            TopicPublishInfo publishInfo = &lt;span class=&quot;fu&quot;&gt;topicRouteData2TopicPublishInfo&lt;/span&gt;(topic, topicRouteData);
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
        log.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;updateTopicRouteInfoFromNameServer Exception&quot;&lt;/span&gt;, e);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，producer也知道自己可以向哪些MessageQueue发送消息了，接下来就是producer的负载均衡算法选出其中一个MessageQueue发送消息（org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#selectOneMessageQueue，这个暂时不详表），MessageQueue包含的信息有topic、brokerName、queueId，但是producer发送的时候得知道broker的ip:port信息，而且一个brokerName对应的是一个broker set，并不能确定具体的broker，所以接下来应该找到具体的broker&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// org.apache.rocketmq.client.impl.factory.MQClientInstance#findBrokerAddressInPublish&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;findBrokerAddressInPublish&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String brokerName) {
    &lt;span class=&quot;co&quot;&gt;// 上面updateTopicRouteInfoFromNameServer方法将broker set下的broker地址信息保存到brokerAddrTable&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 再次重申：一个broker set下的broker的brokerName相同&lt;/span&gt;
    HashMap&amp;lt;Long&lt;span class=&quot;co&quot;&gt;/* brokerId */&lt;/span&gt;, String&lt;span class=&quot;co&quot;&gt;/* address */&lt;/span&gt;&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;brokerAddrTable&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(brokerName);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (map != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !map.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span class=&quot;co&quot;&gt;// 没有花样，就是直接返回brokerId时MixAll.MASTER_ID的broker的ip:port信息&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 前面说过master的brokerId就是MixAll.MASTER_ID，所以获取到的broker是broker set中的master&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; map.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(MixAll.&lt;span class=&quot;fu&quot;&gt;MASTER_ID&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;终于真相大白，producer只会向是master的broker发送消息，也就是一个broker set中brokerId是0的broker。&lt;/p&gt;
&lt;p&gt;producer只能发送消息到master，而不能发送到slave，这也说明了master负责读“写”，而slave只负责读（当然，这里只说明了“写”的部分，关于master 和slave的“读”下一篇介绍）。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇介绍了RocketMQ究竟做了什么来实现作为一个消息队列中间件的高可用，由于篇幅会偏长，所以分为两篇文章来说明，下一篇说明文中遗留下的另一个问题——RocketMQ源码 — 六、 RocketMQ高可用（2）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://coolshell.cn/articles/17459.html&quot;&gt;关于高可用的系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://rocketmq.apache.org/docs/rmq-arc/&quot;&gt;RocketMQ Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sunshine-2015/p/6291116.html&quot;&gt;RocketMQ源码 — 三、 Producer消息发送过程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 06:46:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8994705.html</dc:identifier>
</item>
<item>
<title>CSS flex布局 - 方木一</title>
<link>http://www.cnblogs.com/polk6/p/css-flex.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/polk6/p/css-flex.html</guid>
<description>&lt;h2&gt;1.1 说明&lt;/h2&gt;
&lt;p&gt;flex布局，也称为flex弹性布局；主要目的是使item的宽度、高度按一定顺序填充父容器的可用空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201804/153475-20180424154413463-758490502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在下文中，将以parent指代父容器，item指代容器内的项。&lt;/p&gt;

&lt;h2&gt;1.2 浏览器支持情况&lt;/h2&gt;
&lt;p&gt;IE 11才完全支持flex布局方案，在IE 10的CSS中可使用-ms-前缀支持部分flex布局，但只能使用旧的flex布局属性：&lt;a href=&quot;https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/&quot; target=&quot;_blank&quot;&gt;CSS Flexible Box Layout Module(2012 syntax)&lt;/a&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;IE&lt;/td&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;Firefox&lt;/td&gt;
&lt;td&gt;Chrome&lt;/td&gt;
&lt;td&gt;Android &lt;br/&gt;Chrome&lt;/td&gt;
&lt;td&gt;iOS &lt;br/&gt;Safari&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;10 -ms-&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;18 -moz-&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;21 -webkit-&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;直接进入正题，先介绍父容器可使用flex布局相关的属性。&lt;/p&gt;
&lt;h2&gt;2.1 display: flex | inline-flex&lt;/h2&gt;
&lt;p&gt;要创建一个flex容器，必须将父容器样式中的display属性设置为 flex 或 inline-flex。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:false;&quot;&gt;
.parent {
    display: flex; /* or inline-flex */
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.2 flex-direction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：设置item展示的方向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-direction: row | row-reverse | column | column-reverse; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;row&lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：item显示在一行，从左到右依次展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;row-reverse&lt;/span&gt;：item显示在一行，从右到左依次展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;column&lt;/span&gt;：item显示在一列，从上到下依次展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;column-reverse&lt;/span&gt;：item显示在一列，从下到上依次展示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201804/153475-20180424170306143-1054877460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.3 flex-wrap&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：当item在一行展示不下时，设置换行显示的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：item的宽度之和大于父容器的宽度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-wrap: nowrap | wrap | wrap-reverse;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;nowrap&lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：item不会换行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wrap&lt;/span&gt;：按照item本身的宽度展示，若当前行展示不下时会换一行展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wrap-reverse&lt;/span&gt;：同wrap，不过是按相反方向换行展示item。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201804/153475-20180424170155719-1358092857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.4 flex-flow&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：flex-direction flex-wrap 的简写方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-flow: flex-direction flex-wrap;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;：row nowrap&lt;/p&gt;

&lt;h2&gt;2.5 设置item对齐的属性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：parent(父容器) 控制 item 的对齐方式的属性有justify-content、align-items、align-content。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;justify-content&lt;/span&gt;：控制所有item在main axis(主轴)上的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;align-items&lt;/span&gt;：控制所有item在cross axis(交叉轴)的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;align-content&lt;/span&gt;：当 &lt;span&gt;flex-wrap:wrap*&lt;/span&gt;  时(即item换行排列)，控制item在cross axis(交叉轴)上的对齐方式。&lt;/p&gt;
&lt;h3&gt;main axis(主轴) 与 cross axis(交叉轴)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;main axis(主轴)&lt;/strong&gt;：指的是与flex-direction设定的值方向一致的轴，如flex-direction:row；那么主轴就是横轴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cross axis(交叉轴)&lt;/strong&gt;：与main axis(主轴)交叉的轴，如主轴为横轴，交叉轴就是纵轴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201805/153475-20180504161139048-994660902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;轴的头部和尾部&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;main-start&lt;/strong&gt;：main axis(主轴)的头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main-end&lt;/strong&gt;：main axis(主轴)的尾部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cross-start&lt;/strong&gt;：cross axis(交叉轴)的头部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cross-end&lt;/strong&gt;：cross axis(交叉轴)的尾部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201805/153475-20180504164909852-276775825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1) justify-content&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：控制所有item在main axis(主轴)上的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
justify-content: flex-start | flex-end | center | space-between | space-around;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;flex-start&lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：item从 main axis(主轴)头部开始。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flex-end&lt;/span&gt;：item从 main axis(主轴)尾部开始。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;center&lt;/span&gt;：item在 main axis(主轴)居中展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;space-between&lt;/span&gt;：item均匀的分布在 main axis(主轴)上，其中第一个在 main axis(主轴)头部，最后一个在  main axis(主轴)尾部。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;space-around&lt;/span&gt;：item分布在 main axis(主轴)上。每个item的左右间隔是相等的。如每个item左右间隔为15px，第1个item与开始初间隔15px，第1个与第2个item间隔30px。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;space-evenly&lt;/span&gt;：item均匀分布在 main axis(主轴)上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201804/153475-20180425231009089-587548052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container&quot; target=&quot;_blank&quot;&gt;MDN:Aligning Items in a Flex Container&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2) align-items&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：控制所有item在cross axis(交叉轴)的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
align-items: flex-start | flex-end | center | baseline | stretch;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;stretch&lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：item高度撑开到整个cross axis(交叉轴)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flex-start&lt;/span&gt;：item头对齐在cross axis(交叉轴)的开始处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flex-end&lt;/span&gt;：item尾对齐在cross axis(交叉轴)的结尾处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;center&lt;/span&gt;：item垂直居中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;baseline&lt;/span&gt;：根据内容基线对齐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201804/153475-20180426114336541-1062140657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3)align-content&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：当&lt;span&gt; flex-wrap:wrap*  &lt;/span&gt;时(即item换行排列)，控制item在cross axis(交叉轴)曲线上的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;stretch&lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：item高度撑开到整个cross axis(交叉轴)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flex-start&lt;/span&gt;：item头对齐在cross axis(交叉轴)的开始处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flex-end&lt;/span&gt;：item尾对齐在cross axis(交叉轴)的结尾处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;center&lt;/span&gt;：item垂直居中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;space-between&lt;/span&gt;：item均匀的分布在cross axis(交叉轴)上，其中第一个在cross axis(交叉轴)头部，最后一个在cross axis(交叉轴)尾部。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;space-around&lt;/span&gt;：item分布在cross axis(交叉轴)上。每个item的上下间隔是相等的。。如每个item上下间隔为15px，第1个item与开始初间隔15px，第1个与第2个item间隔30px。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201805/153475-20180503110803831-618281304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;3.1 item的默认宽度、高度&lt;/h2&gt;
&lt;p&gt;学习item可使用的flex属性前，首先要知道默认情况下item的宽度、高度，以父容器&lt;span&gt; flex-direction:row&lt;/span&gt; 为例：&lt;/p&gt;
&lt;p&gt;1)父容器设置了height，而item没有设置，那么item的height会填满父容器的height。因为默认情况下parent设置item的样式为align-items : stretch。&lt;/p&gt;
&lt;p&gt;2)父容器未设置height，某个item设置了height，其他item的height会等于item中最大的height。&lt;/p&gt;
&lt;p&gt;3)父容器和item都没有设置height，item会根据内容大小设置height，其他item的height会等于item中最大的height。&lt;/p&gt;

&lt;h2&gt;3.2 order&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：默认情况下，item按HTML代码的顺序排列。但order属性可以控制item在父容器中展现的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
order: &amp;lt;integer&amp;gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; default is 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Ordering_Flex_Items&quot; target=&quot;_blank&quot;&gt;MDN:Ordering Flex Items&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.3 flex-basis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：设置item的初始化大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-basis: number | auto;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;auto &lt;/span&gt; &lt;strong&gt;默认值&lt;/strong&gt;：根据内容区域的设置大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;number&lt;/span&gt; ：可以为具体数字或百分比。&lt;/p&gt;

&lt;h2&gt;3.4 flex-grow&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：指定item的瓜分剩余空间的占比；当前item的剩余空间占比 = current.flex-grow / allI.flex-grow 之和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-grow: &amp;lt;number&amp;gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; default 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;number&lt;/span&gt; 默认0：指定item如何瓜分剩余空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201805/153475-20180503112522718-149420018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.5 flex-shrink&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;： item缩减的占比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex-shrink: &amp;lt;number&amp;gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; default 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;number&lt;/span&gt;：默认1；&lt;/p&gt;

&lt;h2&gt;3.6 flex&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：flex-grow flex-shrink flex-basis 的简写方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flex: flex-grow flex-shrink flex-basis;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;：0 1 auto&lt;/p&gt;


&lt;h3 id=&quot;activated&quot; data-scroll-id=&quot;activated&quot;/&gt;


&lt;h2&gt;5.1 自适应布局&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：指定的item可以随着父容器的大小一起改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.parent {
    position: absolute;
    display: flex;
    width: 100%;
    height: 100%;
}
 
.left {
    width: 200px;
    height: 100%;
    background-color: #72e4a0;
}
 
.right {
    flex: 1; /* or flex-grow: 1 */
    height: 100%;
    background-color: #9dc3e6;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201803/153475-20180307135016720-941289409.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5.2 居中布局&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：包括水平居中、垂直居中以及水平垂直居中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：水平垂直居中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.parent {width: 200px;height: 100px;position: relative;background-color: #374858;}
.item {width: 100px;height: 50px;background-color: #9dc3e6;}

.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/153475/201805/153475-20180505120518516-1642219390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;w3schools CSS flex Property：&lt;a href=&quot;https://www.w3schools.com/cssref/css3_pr_flex.asp&quot; target=&quot;_blank&quot;&gt;https://www.w3schools.com/cssref/css3_pr_flex.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A Complete Guide to Flexbox：&lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot; target=&quot;_blank&quot;&gt;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W3C CSS Flexible Box Layout：&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot; target=&quot;_blank&quot;&gt;https://www.w3.org/TR/css-flexbox-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MDN FlexBox：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 06:42:00 +0000</pubDate>
<dc:creator>方木一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/polk6/p/css-flex.html</dc:identifier>
</item>
<item>
<title>JQuery系统梳理 - 杨。。</title>
<link>http://www.cnblogs.com/yanglianwei/p/8991903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanglianwei/p/8991903.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　JQuery在前端网页开发中可以说是非常常用了，它所拥有的强大功能足以让我们完成各式各样的效果。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、JQuery基础语法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 使用JQuery必须先导入jquery.x.x.x.js文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. JQuery中的选择器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    $(&quot;选择器名称&quot;).函数名();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     注意：$是JQuery的缩写，也就是说，选择器可以使用JQuery(&quot;:input&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. JQuery 文档就绪函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JQuery代码&lt;/span&gt;&lt;span&gt;
 });&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     简写形式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(jQuery(&lt;/span&gt;&quot;:input:disabled()&quot;&lt;span&gt;));
                
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  说到文档就绪函数就要说说JQuery文档就绪函数和window.onload的区别了！！以下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;【JQuery文档就绪函数与window.onload的区别】&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ① window.onload必须等待网页资源(包括图片、视频等)全部加载完成后，才能执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       文档就绪函数只需要等待网页DOM结构加载完成后，即可执行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ② window.onload在一个页面中，只能写一次；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       文档就绪函数在一个页面中，可以有N个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. JS对象和JQuery对象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ① 使用$取到的节点为JQuery对象，只能调用JQuery方法，不能调用原生JS方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       同理：使用getElement系列函数取到的为JS对象，也不能调用JQuery函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;#div&quot;).click(&lt;span&gt;function&lt;/span&gt;(){}); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对的&lt;/span&gt;
$(&quot;#div&quot;).onclick=&lt;span&gt;function&lt;/span&gt;(){}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错的，JQuery对象不能用JS方法&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;【JS对象与JQuery对象的相互转换】&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   ① JQuery转JS：使用.get(index) 或 [index]选中的就是JS对象；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;#div&quot;).get(0).onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){}
$(&lt;/span&gt;&quot;#div&quot;)[0].onclick=&lt;span&gt;function&lt;/span&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   ② JS转JQuery：使用$()包裹JS对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; div=document.getElementsByTagName(&quot;div&quot;&lt;span&gt;);
$(div).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(){});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5. 解决JQuery多库冲突问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    页面中如果同时引入多个JS框架，可能导致$冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 使用JQuery.noConflict();使JQuery放弃在全局使用$；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 使用JQuery关键字替代$. 或者使用一个自执行函数:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;!&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在自执行函数中，可以使用$替代JQuery&lt;/span&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;除自执行函数外的其他区域，禁止JQuery使用$&lt;/span&gt;
}(JQuery);&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;二、DOM操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　DOM是JQuery中很重要的一部分，是需要熟练掌握的部分（但即使记不住也不是很严重，因为这些操作都可以用JS来实现。只是相对于 JS篇幅较长的代码量来说，何不学会好好运用以下的函数呢~）。DOM操作中包含各类函数，可以完成增加、删除等操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342408/201805/1342408-20180504175348449-574785896.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div1的内部最后追加一个图片&lt;/span&gt;
$(&quot;#div1&quot;).append(&quot;&amp;lt;img src='../01-HTML基本标签/img/man.gif' /&amp;gt;&quot;&lt;span&gt;);  
$(&lt;/span&gt;&quot;&amp;lt;img src='../01-HTML基本标签/img/women.gif' /&amp;gt;&quot;).appendTo(&quot;#div1&quot;&lt;span&gt;); 

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div1的内部最前方插入&lt;/span&gt;
$(&quot;#div1&quot;).prepend(&quot;&amp;lt;img src='../01-HTML基本标签/img/man.gif' /&amp;gt;&quot;&lt;span&gt;); 
$(&lt;/span&gt;&quot;&amp;lt;img src='../01-HTML基本标签/img/women.gif' /&amp;gt;&quot;).prependTo(&quot;#div1&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div1的外部，后面插入节点。&lt;/span&gt;
$(&quot;#div1&quot;).after(&quot;&amp;lt;p&amp;gt;一个P标签&amp;lt;/p&amp;gt;&quot;&lt;span&gt;);
$(&lt;/span&gt;&quot;&amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;&quot;).insertAfter(&quot;#div1&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div1的外部，前面插入节点。&lt;/span&gt;
$(&quot;#div1&quot;).before(&quot;&amp;lt;p&amp;gt;一个P标签&amp;lt;/p&amp;gt;&quot;&lt;span&gt;);
$(&lt;/span&gt;&quot;&amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;&quot;).insertBefore(&quot;#div1&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每一次插入都要在div1的前面，所以会顶替掉之前插入的位置。&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为每一个选中的节点，都套一层父节点。&lt;/span&gt;
$(&quot;div&quot;).wrap(&quot;&amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将选中的所有节点包裹在同一个父节点中。&lt;/span&gt;
$(&quot;div&quot;).wrapAll(&quot;&amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除选中节点的父节点。&lt;/span&gt;
$(&quot;#div1 p&quot;).unwrap();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除div1&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将选中节点中的所有元素包裹在一个新的父节点中。新的父节点依然是当前元素的唯一子节点。&lt;/span&gt;
$(&quot;#div1&quot;).wrapInner(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将选中的节点重新替换为新的节点。会换掉里面的内容。&lt;/span&gt;
$(&quot;div p&quot;).replaceWith(&quot;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&quot;&lt;span&gt;);
$(&lt;/span&gt;&quot;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&quot;).replaceAll(&quot;div p&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空当前节点中的内容，但会保留当前节点标签。&lt;/span&gt;
$(&quot;#div1&quot;&lt;span&gt;).empty();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除当前节点以及当前节点的所有子节点。&lt;/span&gt;
$(&quot;#div1&quot;).remove();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复后不会保留原绑定事件&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除当前节点以及当前节点的所有子节点。&lt;/span&gt;
$(&quot;#div1&quot;).detach();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复后可以保留原绑定事件&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中有两点需要注意的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. [remove和detach的区别]&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    使用remove删除的节点，如果恢复以后，将不再保留节点所绑定的事件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    使用detach删除的节点，在节点恢复以后，可以恢复节点之前所绑定的事件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    div1
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    div2
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用remove删除div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用detach删除div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;恢复被删除的div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    #div1&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
    }&lt;span&gt;
    #div2&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt; green&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JQuery代码：用之前要先导入JQuery插件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;#div1&quot;).click(&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先给div1定义一个点击事件&lt;/span&gt;
    alert(123&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div1=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
$(&lt;/span&gt;&quot;button:eq(0)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    div1 &lt;/span&gt;= $(&quot;#div1&quot;).remove(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用remove删除div1&lt;/span&gt;
&lt;span&gt;});
                
$(&lt;/span&gt;&quot;button:eq(1)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){ 
    div1 &lt;/span&gt;= $(&quot;#div1&quot;).detach(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用detach删除div1&lt;/span&gt;
&lt;span&gt;});
                
$(&lt;/span&gt;&quot;button:eq(2)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;#div2&quot;).before(div1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复被删除的div1&lt;/span&gt;
&lt;span&gt;});
                &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; 2. [JS中cloneNode与JQuery中clone()的区别]&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     a. cloneNode如果不传参数或传入false，表示只克隆当前节点，不克隆子节点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         参数传入true，表示克隆当前节点以及所有子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     b. clone() 无论传入true还是false都会克隆当前节点以及所有子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         传入true表示克隆节点的同时将包括节点所绑定的事件。否则，只表示克隆节点，而不克隆事件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;#div1&quot;).clone().insertBefore(&quot;button:eq(0)&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不论传入true还是false都会克隆子节点以及其绑定事件。&lt;/span&gt;
&lt;span&gt;
$(&lt;/span&gt;&quot;#div1&quot;).clone().empty().insertBefore(&quot;button:eq(0)&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JQuery是一种链式语法，克隆后接着清空div1里面的子节点。达到只克隆当前节点的目的；没有click事件。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、CSS及属性操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1342408/201805/1342408-20180505094857664-217040637.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342408/201805/1342408-20180505095111347-1845536262.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_150fb6e3-c7dc-4b78-952d-0c12922eef59&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_150fb6e3-c7dc-4b78-952d-0c12922eef59&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_150fb6e3-c7dc-4b78-952d-0c12922eef59&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到节点的属性&lt;/span&gt;
console.log($(&quot;#div1&quot;).attr(&quot;id&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的属性&lt;/span&gt;
$(&quot;#div1&quot;).attr(&quot;class&quot;,&quot;cls cls2 cls3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入对象，以键值对的形式同时设置多对属性。&lt;/span&gt;
$(&quot;#div1&quot;&lt;span&gt;).attr({
    &lt;/span&gt;&quot;class&quot;:$(&quot;#div1&quot;).attr(&quot;class&quot;)+&quot; cls1&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先取到原来的，再加上&quot;cls1&quot;&lt;/span&gt;
    &quot;name&quot;:&quot;name1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;style&quot;:&quot;font-size:24px; color:blue;&quot;&lt;span&gt;
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点的属性&lt;/span&gt;
$(&quot;#div1&quot;).removeAttr(&quot;class&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到属性，用法和attr一样&lt;/span&gt;
console.log($(&quot;input:eq(0)&quot;).prop(&quot;hidden&quot;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在原有class的基础上，新增class名字。&lt;/span&gt;
$(&quot;#div1&quot;).addClass(&quot;cls1&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定的class名称。  其余未删除的class名，依然保留&lt;/span&gt;
$(&quot;#div1&quot;).removeClass(&quot;cls cls1&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换class： 如果有指定class就删除，如果没有就新增。&lt;/span&gt;
$(&quot;button:eq(0)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;#div1&quot;).toggleClass(&quot;div1&quot;&lt;span&gt;);
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到或设置节点中的html代码；&lt;/span&gt;
console.log($(&quot;#div1&quot;).html(&quot;&amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;&quot;&lt;span&gt;).html());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到或设置节点中的文本；&lt;/span&gt;
console.log($(&quot;#div1&quot;).text(&quot;&amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;&quot;&lt;span&gt;).text());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到或设置表单元素的value值。&lt;/span&gt;
console.log($(&quot;input&quot;).val(&quot;&amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;&quot;&lt;span&gt;).val());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给节点添加css样式，属于行级样式表权限。&lt;/span&gt;
$(&quot;#div1&quot;).css(&quot;color&quot;,&quot;green&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入一个对象，同时给一个节点添加多对css样式。&lt;/span&gt;
$(&quot;#div1&quot;&lt;span&gt;).css({
    &lt;/span&gt;&quot;color&quot;:&quot;green&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;font-size&quot;:&quot;14px&quot;&lt;span&gt;
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过回调函数返回值，修改css的样式。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;传入计时器，使div1的宽度自动增大，到width=600px时停下。&lt;/span&gt;
$(&quot;button:eq(0)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $(&lt;/span&gt;&quot;#div1&quot;&lt;span&gt;).css({
            &lt;/span&gt;&quot;width&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index,value){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; v = parseFloat(value) + 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(v&amp;gt;600&lt;span&gt;){
                clearInterval(id);
                            }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; v+&quot;px&quot;&lt;span&gt;;
               }
            });
    },&lt;/span&gt;10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到或者设置节点的 宽高。只包含width/height&lt;/span&gt;
console.log($(&quot;#div1&quot;).height(400&lt;span&gt;));
console.log($(&lt;/span&gt;&quot;#div1&quot;).width(&quot;400px&quot;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到 节点 的宽度+padding。 不包含border和margin&lt;/span&gt;
console.log($(&quot;#div1&quot;&lt;span&gt;).innerHeight());
console.log($(&lt;/span&gt;&quot;#div1&quot;&lt;span&gt;).innerWidth());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不传参数， 表示 宽高+padding+border;传入true，表示 宽高+padding+border+margin&lt;/span&gt;
console.log($(&quot;#div1&quot;&lt;span&gt;).outerHeight());
console.log($(&lt;/span&gt;&quot;#div1&quot;).outerWidth(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个节点，相对于浏览器左上角的偏移量。返回一个对象{}&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;此方法，测量时，会将margin算作偏移量的距离。&lt;/span&gt;
console.log($(&quot;#div1&quot;&lt;span&gt;).offset());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个节点，相对于父容器的偏移量。&lt;/span&gt;
console.log($(&quot;#div1&quot;&lt;span&gt;).position());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或取到指定节点的滚动条的位置&lt;/span&gt;
console.log($(&quot;#div1&quot;).scrollTop(100));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;【attr和prop两者的不同】&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            1. 在读取 属性名=&quot;属性值&quot; 的属性时， attr将返回属性值和undefined；而prop将返回true或false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             2. 也就是说，attr要取到的属性，必须是在标签上已经写明的属性。 否则无法取到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;【position使用注意】&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            1. 使用此方法，要求父元素必须是定位元素。 如果父元素不是定位元素，则依然是相对于浏览器左上角进行测量。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            2. 此方法，测量偏移时，将不考虑margin。 而会将margin视为当前容器的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、事件处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 事件绑定的快捷方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：绑定的事件无法取消&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).dblclick(&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击，不可解绑&lt;/span&gt;
    alert(123&lt;span&gt;)
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 使用on进行事件绑定，使用off可以解绑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   a. 使用on进行单事件绑定&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可解绑&lt;/span&gt;
    alert(123&lt;span&gt;)
});
$(&lt;/span&gt;&quot;button:eq(0)&quot;).off(&quot;click&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解绑&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   b. 使用on，同时给多个事件绑定同一函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).on(&quot;click dblclick mouseover&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){  
    console.log(&lt;/span&gt;123&lt;span&gt;);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   c. 使用on同时给多个事件分别绑定不同的函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;&lt;span&gt;).on({
    &lt;/span&gt;&quot;click&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;click&quot;&lt;span&gt;);
        },
    &lt;/span&gt;&quot;mouseover&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&quot;mouseover&quot;&lt;span&gt;);
    }
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   d. 使用on，给回调函数传参，要求是对象格式。传递的参数可以在e.data中取到&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:14},&lt;span&gt;function&lt;/span&gt;(e){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以传入事件、data数据（可以是对象）、函数&lt;/span&gt;
    console.log(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到JQuery.Event&lt;/span&gt;
    console.log(e.data); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到数据&lt;/span&gt;
    console.log(e.data.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到名字&lt;/span&gt;
    console.log(e.data.age); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到年龄&lt;/span&gt;
&lt;span&gt;});
$(document).on(&lt;/span&gt;&quot;mousemove&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    console.log(e);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 使用on 事件委派&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a. 事件委派：将与俺来绑定在DOM节点上的事件，改为绑定在其父节点甚至根节点上，然后委派给当前节点执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b. 事件委派的作用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         ① 将事件直接绑定在根节点上，可以减少事件绑定的次数，更加节省资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         ② 使用事件委派绑定的事件，当页面新增同类型标签时，新的标签也可以获得绑定的已有事件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通绑定事件&lt;/span&gt;
$(&quot;p&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;123&lt;span&gt;)
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑在DOM根节点上。事件委派。&lt;/span&gt;
$(document).on(&quot;click&quot;,&quot;p&quot;,&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入一个选择器，委派给那一个标签来执行。每次点在根节点上，会判断和传入的选择器是否匹配，如果匹配，则委派给该选择器执行。&lt;/span&gt;
    alert(123&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是普通绑定，新增的标签不会获得已绑定事件;但如果是事件委派绑定的事件，当页面新增同类型标签时，新的标签也可以获得绑定的已有事件。&lt;/span&gt;
$(&quot;button:eq(0)&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;&amp;lt;p&amp;gt;hahah&amp;lt;/p&amp;gt;&quot;).insertBefore(&quot;p:eq(0)&quot;&lt;span&gt;);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 取消事件绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   a. 使用off取消事件绑定&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;1&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(){
    alert(&lt;/span&gt;2&lt;span&gt;);
}
$(&lt;/span&gt;&quot;button:eq(0)&quot;).on(&quot;click&quot;&lt;span&gt;,func); 
$(&lt;/span&gt;&quot;button:eq(0)&quot;).off(&quot;click&quot;,func); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只清除绑定了func函数的click事件&lt;/span&gt;
$(&quot;button:eq(0)&quot;).off(&quot;click&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除了所有的click事件&lt;/span&gt;
&lt;span&gt;                
$(&lt;/span&gt;&quot;button:eq(0)&quot;).off(&quot;click dblclick&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时清除多个事件&lt;/span&gt;
$(&quot;button:eq(0)&quot;).off(&quot;click&quot;,&quot;p&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除事件委派&lt;/span&gt;
$(&quot;p&quot;).off(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除绑定在&quot;p&quot;上的所有事件&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   b. 使用one，绑定的事件，只能出现一次&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).one(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;&quot;使用one我只能出来一次&quot;&lt;span&gt;);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5. 事件切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   a. hover():接受两个函数，分别表示mouseover() mouseout()两个事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       如果只写一个函数，表示mouseover()。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;p:eq(0)&quot;).hover(&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标指上和鼠标拿走状态&lt;/span&gt;
    $(&lt;span&gt;this&lt;/span&gt;).css(&quot;background-color&quot;,&quot;red&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).css(&quot;background-color&quot;,&quot;blue&quot;&lt;span&gt;);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   b. toggle(): &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ① 不传参数，表示：当前元素如果为显示状态，则隐藏；如果为隐藏状态，则显示。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       ② 传入一个动画执行效果：&quot;ease&quot; &quot;slow&quot; &quot;fast&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;             $(&quot;p:eq(0)&quot;).toggle(&quot;ease&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       ③ 传入一个函数，表示：隐藏动画或显示动画，完成后执行的回调函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ④ 接受一个Boolean类型的参数，表示：如果传入的是true则显示当前元素；如果传入的是false则隐藏当前元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;p:eq(0)&quot;).toggle(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不传参数&lt;/span&gt;
&lt;span&gt;
    $(&lt;/span&gt;&quot;p:eq(0)&quot;).toggle(&quot;ease&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入状态，切换效果不一样&lt;/span&gt;
&lt;span&gt;
    $(&lt;/span&gt;&quot;p:eq(0)&quot;).toggle(&quot;fast&quot;,&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入一个函数&lt;/span&gt;
        alert(123&lt;span&gt;);
    });
                    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; is=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;随便写个条件&quot;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要字符串不为空，为true&lt;/span&gt;
        is=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    $(&lt;/span&gt;&quot;p:eq(0)&quot;).toggle(is); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时为true                &lt;/span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;五、事件动画&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　JQuery的事件动画要比JS中自己写的好用很多，一行代码就可以解决一个效果。其中animate自定义动画很灵活很方便，配合delay可以做出你想要的效果。在动画这一方面，JQuery非常人性化的为我们提供了插件库。里面都是各种技术大牛写好的效果封装成了插件，我们可以直接套用。这里，附上插件库链接，有需要的可以自行查找：&lt;a href=&quot;http://www.jq22.com/&quot; target=&quot;_blank&quot;&gt;http://www.jq22.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342408/201805/1342408-20180505104732823-582715520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;show()                                $(&quot;#div1&quot;).show(2000,function(){//传入毫秒数和回调函数（动画完成后执行的函数）&lt;/span&gt;
    alert(123&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hide()                            $(&quot;#div1&quot;).hide(2000,function(){&lt;/span&gt;
    alert(123&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示或隐藏元素,修改height属性&lt;/span&gt;
$(&quot;#div1&quot;).slideDown(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让隐藏的元素显示&lt;/span&gt;
    alert(123&lt;span&gt;);
});
$(&lt;/span&gt;&quot;#div1&quot;).slideUp(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让显示的元素隐藏&lt;/span&gt;
    alert(123&lt;span&gt;);
});
$(&lt;/span&gt;&quot;#div1&quot;).slideToggle(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让显示的元素隐藏；让隐藏的元素显示&lt;/span&gt;
    alert(123&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示或隐藏元素,修改opacity属性&lt;/span&gt;
$(&quot;#div1&quot;).fadeIn(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏的元素显示&lt;/span&gt;
    alert(123&lt;span&gt;);
});
$(&lt;/span&gt;&quot;#div1&quot;).fadeOut(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的元素隐藏&lt;/span&gt;
    alert(123&lt;span&gt;);
});
$(&lt;/span&gt;&quot;#div1&quot;).fadeToggle(2000,&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏的显示；显示的隐藏&lt;/span&gt;
    alert(123&lt;span&gt;);
});
$(&lt;/span&gt;&quot;#div1&quot;).fadeTo(2000,0.5,&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用于fadeToggle相同。但是多了第二个参数，表示动画完成后的最终透明度。&lt;/span&gt;
    alert(123&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;animate()动画和delay动画延时&lt;/span&gt;
$(&quot;#div1&quot;&lt;span&gt;).animate({
    fontSize: &lt;/span&gt;&quot;64px&quot;&lt;span&gt;
}, &lt;/span&gt;2000, &quot;linear&quot;).delay(2000&lt;span&gt;).animate({
    width: &lt;/span&gt;&quot;0px&quot;&lt;span&gt;,
    opacity: &lt;/span&gt;&quot;0&quot;&lt;span&gt;,
}, &lt;/span&gt;3000, &quot;linear&quot;&lt;span&gt;);

$(&lt;/span&gt;&quot;#div2&quot;&lt;span&gt;).animate({
    fontSize: &lt;/span&gt;&quot;68px&quot;&lt;span&gt;
}, &lt;/span&gt;2000, &quot;linear&quot;).delay(2000&lt;span&gt;).animate({
    fontSize: &lt;/span&gt;&quot;16px&quot;&lt;span&gt;
}, &lt;/span&gt;3000&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stop():停止当前节点的所有动画。后续动画将不再执行，动画回调不在调用。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;finish():直接结束当前节点的所有动画。动画直接进入最后状态，直接调用动画回调。&lt;/span&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;#div1&quot;&lt;span&gt;).stop();
        $(&lt;/span&gt;&quot;#div1&quot;&lt;span&gt;).finish();                
});    &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1. show():&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a. 不传参将会直接显示，而不进行动画；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b. 参数传入事件毫秒，或者表示速度的字符串&quot;slow&quot; &quot;fast&quot; &quot;normal&quot;则将在指定时间内完成动画;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c. 参数也可以穿入回调函数，表示动画完成后执行的回调。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. animate()动画，自定义动画，接收4个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a. 动画完成后最终状态的CSS键值对集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;       &lt;/em&gt; 注意：CSS的样式，要求使用驼峰式命名。例如：fontSize;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b. 动画完成的时间。可以是毫秒，可以是&quot;slow&quot; &quot;fast&quot; &quot;normal&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c. 动画完成的效果。可选值&quot;linear&quot; &quot;swing&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    d. 动画完成后的回调函数。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 05 May 2018 05:18:00 +0000</pubDate>
<dc:creator>杨。。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanglianwei/p/8991903.html</dc:identifier>
</item>
<item>
<title>ABP框架 - 启动配置 - lcyhjx</title>
<link>http://www.cnblogs.com/lcyhjx/p/8994347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcyhjx/p/8994347.html</guid>
<description>&lt;p&gt;ABP可以在启动的时候对模块进行配置。&lt;/p&gt;

&lt;p&gt;在模块的PreInitialize方法中，可以对ABP进行配置。配置示例如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class SimpleTaskSystemModule : AbpModule
{
    public override void PreInitialize()
    {
        //Add languages for your application
        Configuration.Localization.Languages.Add(new LanguageInfo(&quot;en&quot;, &quot;English&quot;, &quot;famfamfam-flag-england&quot;, true));
        Configuration.Localization.Languages.Add(new LanguageInfo(&quot;tr&quot;, &quot;Türkçe&quot;, &quot;famfamfam-flag-tr&quot;));

        //Add a localization source
        Configuration.Localization.Sources.Add(
            new XmlLocalizationSource(
                &quot;SimpleTaskSystem&quot;,
                HttpContext.Current.Server.MapPath(&quot;~/Localization/SimpleTaskSystem&quot;)
                )
            );

        //Configure navigation/menu
        Configuration.Navigation.Providers.Add&amp;lt;SimpleTaskSystemNavigationProvider&amp;gt;();        
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ABP是模块化设计，不同的模块都可以对ABP进行配置。例如不同的模块可以通过添加不同的导航提供者来在主菜单上添加自己的菜单项。&lt;/p&gt;

&lt;p&gt;Configuration.ReplaceService 方法可以用来重写ABP中的内置服务。例如，你可以自己实现一个管理会话的服务(MySession), 然后使用Configuration.ReplaceService来替换掉ABP中内置的会话服务。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Configuration.ReplaceService&amp;lt;IAbpSession, MySession&amp;gt;(DependencyLifeStyle.Transient);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ReplaceService有一个重载方法，可以通过传递action参数来实现自定义替换。例如使用自定义的DbPerTenantConnectionStringResolver来替换IConnectionStringResolver, 代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Configuration.ReplaceService(typeof(IConnectionStringResolver), () =&amp;gt;
{
    IocManager.Register&amp;lt;IConnectionStringResolver, DbPerTenantConnectionStringResolver&amp;gt;(DependencyLifeStyle.Transient);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个服务可以被替换多次，这种情况在不同的模块中比较容易出现（例如服务A在模块A中被替换了一次，在模块B中又被替换了一次）。那么最后一次被替换的服务才是会被正确使用的服务，哪一个服务是最后一次被替换的服务，则是通过模块依赖的加载顺序来可确定。&lt;/p&gt;

&lt;p&gt;除了ABP框架自身提供的启动配置外，模块也可以通过扩展IAbpModuleConfigurations 接口提供自己的配置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class AbpWebConfigurationExtensions
{
    public static IAbpWebCommonModuleConfiguration AbpWebCommon(this IModuleConfigurations configurations);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;...
using Abp.Web.Configuration;
...
public override void PreInitialize() 
{
    Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = true;
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们先通过AbpWebCommon扩展方法对IModuleConfigurations接口进行了扩展，接着在模块的PreInitialize方法中配置AbpWebCommon模块，将所有的异常信息都发送给客户端。&lt;/p&gt;

&lt;p&gt;假设我们定义了一个MyModule的模块，这个模块有一些配置属性，那么第一步，我们可以为这些配置属性创建一个类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyModuleConfig
{
    public bool SampleConfig1 { get; set; }

    public string SampleConfig2 { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们可以在模块的PreInitialize 方法中，通过依赖除注入注册这个配置类，这样它就可以被注入了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IocManager.Register&amp;lt;MyModuleConfig&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示，配置类应该被注册为单实例的。注册后，我们就可以对MyModule模块进行配置了：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Configuration.Get&amp;lt;MyModuleConfig&amp;gt;().SampleConfig1 = false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，直接使用了Configuration.Get&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class MyModuleConfigurationExtensions
{
    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)
    {
        return moduleConfigurations.AbpConfiguration.Get&amp;lt;MyModuleConfig&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改进后，其他模块就可以通过扩展方法来配置MyModule了：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Configuration.Modules.MyModule().SampleConfig1 = false;
Configuration.Modules.MyModule().SampleConfig2 = &quot;test&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改进后的这种方法，可以非常容易的知道有哪些模块配置，并且提供一个统一的访问入口(Configuration.Modules...)。ABP内置的模块配置也是通过这种扩展方法的方式来实现的。&lt;/p&gt;
&lt;p&gt;设置了配置信息后，如果模块中的其他服务需要获取模块配置信息（MyModuleConfig），我们可以注入MyModuleConfig，接着就可以使用了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyService : ITransientDependency
{
    private readonly MyModuleConfig _configuration;

    public MyService(MyModuleConfig configuration)
    {
        _configuration = configuration;
    }

    public void DoIt()
    {
        if (_configuration.SampleConfig2 == &quot;test&quot;)
        {
            //...
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方方式，ABP就可以对模块就行集中的配置管理了。在统一的地方进行模块的配置设置，在需要使用的地方通过注入的方式来获取配置的值。&lt;/p&gt;
</description>
<pubDate>Sat, 05 May 2018 04:22:00 +0000</pubDate>
<dc:creator>lcyhjx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcyhjx/p/8994347.html</dc:identifier>
</item>
</channel>
</rss>