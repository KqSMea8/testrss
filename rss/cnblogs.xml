<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《Clean Code》 代码简洁之道 - 妖艳货</title>
<link>http://www.cnblogs.com/codelovers/p/8028200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codelovers/p/8028200.html</guid>
<description>&lt;h2 id=&quot;h2-u4F5Cu8005u4ECBu7ECD&quot;&gt;作者介绍&lt;/h2&gt;
&lt;p&gt;原文作者： Robert C. Martin, Object Mentor公司总裁，面向对象设计、模式、UML、敏捷方法学和极限编程领域的资深顾问，是《敏捷软件开发：原则、模式、与实践》的作者。&lt;br/&gt;翻译作者：韩磊，互联网产品与运营专家，技术书籍著译者。译著有《梦断代码》和《C#编程风格》等。（竟然不是程序员~~~）&lt;/p&gt;
&lt;h2 id=&quot;h2-u5185u5BB9u6982u8981&quot;/&gt;
&lt;p&gt;&lt;em&gt;本书后几章主要讲了java相关的类、系统、和并发的设计介绍，较粗略，与简洁之道不是特别融合，故而省略，想要详细了解的建议去看更优质的详细讲解。&lt;/em&gt;&lt;br/&gt;本书主要站在代码的可读性上讨论。可读性？ 顾名思义，代码读起来简洁易懂， 让人心情愉悦，大加赞赏。&lt;br/&gt;在N年以后，自己或者他人仍然能够稍加阅读就能明白其中的意思。什么是整洁代码？看看程序员鼻祖们怎么说的，&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;整洁代码只做好一件事。—— Bjarne Stroustrup, C++语言发明者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;整洁代码从不隐藏设计者的意图。—— Grady Booch, 《面向对象分析与设计》作者&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不能想着，这代码我能看懂就好了， 即使当下能看懂，那几个月甚至一年以后呢。更不能说为了体现自己编程“高大上”，故意用一些鲜为人知的语法，如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const LIMIT = 10
const LIMIT = Number(++[[]][+[]]+[+[]])
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;尽可能少的依赖关系，模块提供尽量少的API。—— Dave Thoms, OTI创始人, Eclipse战略教父&lt;/li&gt;
&lt;li&gt;代码应该通过其字面表达含义，命名和内容保持一致。 —— Michael Feathers, 《修改代码的艺术》作者&lt;/li&gt;
&lt;li&gt;减少重复代码，甚至没有重复代码。—— Ron Jeffries, 《C#极限编程探险》作者&lt;/li&gt;
&lt;li&gt;让编程语言像是专门为解决那个问题而存在。 —— Ward Counningham, Wiki发明者&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​​&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;名副其实&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好的变量、函数或类的名称应该已经答复了所有的大问题，如果需要注释补充，就不算名副其实。&lt;br/&gt;工具函数内部的临时变量可以稍微能接收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// what's the meaning of the 'd'?
int d;
// what's list ?
List&amp;lt;int []&amp;gt; list;

int daysSinceCreation
int daysSinceModification
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此处的重定向，起名为“redirection”会不会更好一点，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 重定向
 */
public function forward(Request $request, $controller, $action) {}
/**
 * 重定向
 */
public function default(Request $request,  $controller, $action) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;既是注册帐号，为何不直接命名为 register 呢？也许会说，注册就是新增帐号，create也是新增帐号，自然，create可以代表注册。可新增帐号可能是自己注册，也可能是系统分配，还可能是管理员新增帐号，业务场景不一样，实现也很可能不一样。所以，建议取一个明确的，有意义的，一语道破函数干了啥的名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//注册账号
public function create($data) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;避免误导&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;程序员必须避免留下掩藏代码本意的错误线索。变量命名包含数据类型单词（array/list/num/number/str/string/obj/Object）时，需保证该变量一定是该类型，包括变量函数中可能的改变。更致命的误导是命名和内容意义不同，甚至完全相反。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 确定是 List？
accountList = 0
// 确定是 Number?
nodeNum = '1'

//确定所有情况返回值都是list吗？
function getUserList (status) {
    if (!status) return false
    let userList = []
    ...
    return userList
}
.align-left {
  text-align: &quot;right&quot;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;做有意义的区分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;product/productIno/productData 如何区分？哪个代表哪个意思？ Info 和 Data就像 a / an / the 一样，是意义含糊的废话。如下函数命名也是没有意义的区分，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
getActiveAccount()
getActiveAccounts()
getActiveAccountInfo()
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;使用读的出来的名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;读不出来就不方便记忆，不方便交流。大脑中有很大一块地方用来处理语言，不利用起来有点浪费了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用可搜索的名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让IDE帮助自己更便捷的开发。假如在公共方法里面起个变量名叫value，全局搜索，然后一脸懵逼地盯着这上百条搜索结果。 (value vs districts)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个概念对应一个词&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;媒体资源叫media resources 还是 publisher？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加有意义的语境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;firstName/lastName/street/city/state/hourseNumber&lt;br/&gt;=&amp;gt;&lt;br/&gt;addrFirstName/addrLastName/addrStreet/addrCity/addrState/hourseNumber&lt;/p&gt;
&lt;h2 id=&quot;h2-u6CE8u91CA&quot;/&gt;
&lt;p&gt;什么也比不上放置良好的注释来的有用。&lt;br/&gt;什么也不会比乱七八糟的注释更有本事搞乱一个模块。&lt;br/&gt;什么也不会比陈旧、提供错误信息的注释更有破坏性。&lt;br/&gt;若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释——也根本不需要。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作者为什么极力贬低注释？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注释会撒谎。由于程序员不能坚持维护注释，其存在的时间越久，离其所描述的代码越远，甚至最后可能全然错误。不准确的注释比没有注释坏的多，净瞎说，真实只在一处地方存在：代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 禁用、解冻
public function option(Request $request) {}
// 记录操作日志
protected function writeLog($optType,$optObjectName, $optId, $optAction) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;=&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
protected function recordOperationLog($optType,$optObjectName, $optId, $optAction) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将上面的 注释 + 代码 合成下方纯代码，看着更简洁，且不会读不懂。&lt;br/&gt;再者，可以在函数定义的地方添加说明性注释，可不能在每个用到这个函数的地方也添加注释，这样，在阅读函数调用的环境时，还得翻到定义的地方瞅瞅是什么意思。但如果函数本身的名称就能描述其意义，就不存在这个问题了。&lt;br/&gt;别担心名字太长，能准确描述函数本身的意义才是更重要的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注释不能美化糟糕的代码。&lt;br/&gt;对于烂透的代码，最好的方法不是写点儿注释，而是把它弄干净。与其花时间整一大堆注释，不如花时间整好代码，用代码来阐述。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// check the obj can be modified
if (obj.flag || obj.status === 'EFFECTIVE' &amp;amp;&amp;amp; user.info.menu === 1) {
    // todo
}
if (theObjCanBeModified()) {}
function theObjCanBeModified () {}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;h2-u597Du6CE8u91CA&quot;/&gt;
&lt;p&gt;　　1. 少许公司代码规范要求写的法律相关注释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * Laravel IDE Helper Generator
 *
 * @author    Barry vd. Heuvel &amp;lt;barryvdh@gmail.com&amp;gt;
 * @copyright 2014 Barry vd. Heuvel / Fruitcake Studio (http://www.fruitcakestudio.nl)
 * @license   http://www.opensource.org/licenses/mit-license.php MIT
 * @link      https://github.com/barryvdh/laravel-ide-helper
 */

namespace Barryvdh\LaravelIdeHelper;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 对意图的解释，如，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function testConcurrentAddWidgets() {
...
// this is our best attempt to get a race condition
// by creating large number of threads.
for (int i = 0; i &amp;lt; 25000; i++) {
 // to handle thread
}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. 阐释&lt;br/&gt;　　有时，对于某些不能更改的标准库，使用注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读的形式，也会是有用的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function compareTest () {
  // bb &amp;gt; ba
  assertTrue(bb.compareTo(ba) === 1) 
  // bb = ba
  assertTrue(bb.compareTo(ba) === 0) 
  // bb &amp;lt; ba
  assertTrue(bb.compareTo(ba) === -1) 
}
// could not find susan in students.
students.indexOf('susan') === -1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4. 警示&lt;br/&gt;　　注释用于警告其他程序员某种后果，也是被支持的。&lt;/p&gt;
&lt;p&gt;　　函数，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// Don't run unless you have some time to kill
function _testWithReallyBigFile () {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　文件顶部注释，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 文件来内容源于E:\Git_Workplace\tui\examples\views\components\color\tinyColor.js，需要新增/编辑/删除内容请更改源文件。
 */
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5. TODO&lt;/p&gt;
&lt;p&gt;　　来不及做的，使用TODO进行注释。虽然这个被允许存在，但不是无限书写TODO的理由，需要定期清理。&lt;/p&gt;
&lt;p&gt;　　6. 放大&lt;/p&gt;
&lt;p&gt;　　注释可以用来放大某些看着不合理代码的重要性。&lt;/p&gt;
&lt;p&gt;　　不就是个trim()么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// the trim is real importan. It removes the starting
// spaces that could casuse the item to be recoginized
// as another list
String listItemContent = match.group(3).trim()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　没引入任何编译后的js和css，代码如何正常工作的呢？请看注释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;!-- built files will be auto injected --&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7. 公共API中的DOC&lt;br/&gt;　　公共文档的doc一般会用于自动生成API帮助文档，试想如果一个公共库没有API说明文档，得是一件多么痛苦的事儿，啃源码花费时间实在太长。&lt;/p&gt;

&lt;h2 id=&quot;h2-u574Fu6CE8u91CA&quot;/&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;喃喃自语&lt;br/&gt;写了一些除了自己别人都看不懂的文字。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;多余的注释&lt;br/&gt;简单的函数，头部位置的注释全属多余，读注释的时间比读代码的时间还长，完全没有任何实质性的作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// Utility method that returns when this.closed is true.
// Throws an exception if the timeout is reached.
public synchronized void waitForClose(final long timeoutMillis)
throw Exception {
if (!closed) 
{
 wait(timeoutMillis);
 if (!closed)
   throw new Exception(&quot;MockResponseSender could not be closed&quot;);
}
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;误导性注释&lt;br/&gt;代码为东，注释为西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多余的注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;/&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 创建
public function create(Request $request) {}
// 更新
public function update(Request $request) {}
// 查询
public function read(Request $request) {}
// 删除
public function delete(Request $request) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　$table已经初始化过了，&lt;a class=&quot;at-link&quot; title=&quot;@var&quot; href=&quot;http://km.oa.com/user/var&quot; target=&quot;_blank&quot;&gt;@var&lt;/a&gt; string 这一行注释看上去似乎就没那么必要了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * The table name for the model.
 * @var string
 */
protected $table = 'order_t_creative';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 括号后面的注释&lt;/p&gt;
&lt;p&gt;　　只要遵循函数只做一件事，尽可能地短小，就不需要如下代码所示的尾括号标记注释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
try {
  ...
  while () {
   ...
  } // while
  ...
} // try
catch () {
  ...
} // catch
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一般不在括号后方添加注释，代码和注释不混在一行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function handleKeydown (e) {
  if (keyCode === 13) { // Enter
    e.preventDefault()
    if (this.focusIndex !== -1) {
      this.inputValue = this.options[this.focusIndex].value
    }
    this.hideMenu()
  }
  if (keyCode === 27) { // Esc
    e.preventDefault()
    this.hideMenu()
  }
  if (keyCode === 40) { // Down
    e.preventDefault()
    this.navigateOptions('next')
  }
  if (keyCode === 38) { // Up
    e.preventDefault()
    this.navigateOptions('prev')
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现作出如下调整，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function handleKeydown (e) {
  const Enter = 13
  const Esc = 27
  const Down = 40
  const Up = 38
  e.preventDefault()
  switch (keycode) {
    case Enter:
      if (this.focusIndex !== -1) {
        this.inputValue = this.options[this.focusIndex].value
      }
      this.hideMenu()
      break
    case Esc:
      this.hideMenu()
      break
    case Down:
      this.navigateOptions('next')
      break
    case Up:
      this.navigateOptions('prev')
      break
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　通过定义数字变量，不仅去掉了注释，各个数字也有了自己的意义，不再是魔法数字，根据代码环境，几乎不会有人问，“27是什么意思？” 诸如此类的问题。再者，if情况过多，用switch代替，看着稍显简洁。最后，每一个都有执行了&lt;code&gt;e.preventDefault()&lt;/code&gt;，可以放在switch外层，进行一次书写。&lt;/p&gt;
&lt;p&gt;　　6. 归属和署名&lt;br/&gt;　　源码控制系统非常善于记住谁在何时干了什么，没有必要添加签名。新项目可以清除地知道该和谁讨论，但随着时间的推移，签名将越来越不准确。&lt;br/&gt;当然，这个也见仁见智，支付宝小程序抄袭微信小程序事件的触发便是因为代码里面出现开发小哥的名字。如果为了版权需要，法律声明，我想写上作者也是没有什么大问题的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * Created by PhpStorm.
 * User: XXX
 * Date: 2017/9/29
 * Time: 14:14
 */

namespace App\Services;
use Cache;
class CacheService implements CacheServiceInterface
{
}
/**
 * 功能： 广告位管理
 * User: xxx@tencent.com
 * Date: 17-8-2
 * Time: 下午4:47
 */
class PlacementController extends BaseController
{
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7. 注释掉的代码&lt;br/&gt;　　直接把代码注释掉是讨厌的做法。Don’t do that! 其他人不敢删除注释掉的代码，可能会这么想，代码依然在那儿，一定有其原因，或者这段代码很重要，不能删除。&lt;br/&gt;其他人因为某些原因不敢删可以理解，但如果是自己写的注释代码，有啥不敢删呢？再重要的注释代码，删掉后，还有代码控制系统啊，这个系统会记住人为的每一次改动，还担心啥呢？放心地删吧！管它谁写的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// $app-&amp;gt;middleware([
//    App\Http\Middleware\DemoMiddleware::class
// ]);

// $app-&amp;gt;routeMiddleware([
//     'auth' =&amp;gt; App\Http\Middleware\Authenticate::class,
// ]);

if (APP_MODE == 'dev') {
    $app-&amp;gt;register(Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class);
}
$app-&amp;gt;register(\App\Providers\UserServiceProvider::class);
$app-&amp;gt;register(\App\Providers\UserRoleServiceProvider::class);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8. 信息过多&lt;/p&gt;
&lt;p&gt;　　9. 别在注释中添加有趣的历史性话题或无关的细节描述。&lt;/p&gt;
&lt;p&gt;　　10. 注释和代码没有明显的联系&lt;/p&gt;
&lt;p&gt;　　11. 注释和代码之间的联系应该显而易见，如果注释本身还需要解释，就太糟糕了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
* start with an array that is big enough to hold all the pixels
* (plus filter biytes), and extra 200 bytes for header info
*/
this.pngBytes = new byte[((this.width + 1) + this.height * 3) + 200];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　12. 非公共代码的doc类注释&lt;/p&gt;
&lt;p&gt;　　有些doc类的注释对公共API很有用，但如果代码不打算作公共用途，就没有必要了。&lt;/p&gt;
&lt;p&gt;下面的四行注释，除了第一行，其它的都显得很多余，无疑在重复函数参数已经描述过的内容。倘若阅读代码的人花了时间看注释，结果啥也没有，沮丧；知道没用自动掠过，没有花时间看注释，那这注释还留着干啥。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 根据媒体ID获取广告位ID
 * @param PlacementService $service
 * @param Request $request
 * @return Msg
 */
public function getPublisherPlacementIds(PlacementService $service, Request $request) {}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数第一规则是要短小，第二规则是还要更短小。if语句,else语句，while语句等，其中的代码块应该只有一行。函数代码行建议不要超过20行，每行代码长度建议150个字符左右。如下代码片段，建议换行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export default function checkPriv (store, path) {
  return store.state.user.privileges &amp;amp;&amp;amp; (store.state.user.privileges.includes(path) || store.state.user.privileges.includes(`/${path.split('/')[1]}/*`) || isAll(store))
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;函数应该只做一件事，做好这件事。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;　　如下函数，executeSqlContent()&lt;/code&gt; 很明显不止做一件事， 前半部分实现了连接配置的获取，后半部分根据config执行sql。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 根据文件名和文件路径执行具体的sql
 * @param $file
 * @param $dbConfigPath
 * @param $date
 */
protected function executeSqlContent($file, $dbConfigPath, $date)
{
    $config = [];
    // 获取数据库名称
    if ($file == 'nn_global.sql' || $file == 'nn_pub_template.sql') {
        // DB配置
        $config = config(&quot;database.connections.global&quot;);
        $userId = 'global';

    } elseif (strpos($file, 'nn_pub') !== false) {
        $fileName = explode('.', $file);

        $dbName = explode('_', $fileName[0]);
        if (count($dbName) == 3) {
            $dbInfo = UserDbTConfig::select(['onsn_name'])-&amp;gt;where('dbn_name', $fileName[0])-&amp;gt;first();
            if ($dbInfo) {
                $dbInfo = $dbInfo-&amp;gt;toArray();
                $onsInfo = zkname($dbInfo['onsn_name']);
                $config = config(&quot;database.connections.individual&quot;);
                // 覆盖HOST
                $config['host'] = $onsInfo-&amp;gt;ip;
                $config['port'] = $onsInfo-&amp;gt;port;
                $userId = $dbName[2];
            }
        }
    }

    if ($config) {
        // sql语句
        $dbSqlConfig = file_get_contents($dbConfigPath . $file);
        if ($dbSqlConfig) {
            $this-&amp;gt;info($file . '文件内容为：' . $dbSqlConfig);

            // 添加新的连接
            config([&quot;database.connections.pp_pub_{$userId}&quot; =&amp;gt; $config]);
            $db = DB::connection(&quot;nn_pub_{$userId}&quot;);
            $db-&amp;gt;statement($dbSqlConfig);

            // 执行成功，文件备份移动
            $dirName = 'static/bak/' . $date;
            if (!is_dir($dirName)) {
                mkdir($dirName, 0777, true);
            }
            $cmd = &quot;mv &quot; . $dbConfigPath . $file . &quot;  &quot; . $dirName;
            shell_exec($cmd);

            // 断开DB连接
            DB::disconnect(&quot;nn_pub_{$userId}&quot;);

            $this-&amp;gt;info($file . '文件内容为执行完成');
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;每个函数一个抽象层级，函数中混着不同抽象层级往往容易让人迷惑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如下代码便是抽象层级不一样， &lt;code&gt;getConnectionConfig()&lt;/code&gt; ，属于已经抽象过的一层函数调用，下方的文件处理却是具体的实现。&lt;br/&gt;举这个例子只是为了说明不同的抽象层级是这个意思，由于函数本身不复杂，不存在让人迷惑的问题。&lt;br/&gt;只是函数实现一旦混杂多了，不容易搞得清楚某一行表达式是基础概念还是细节，更多的细节就会在函数中纠结起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;executeSqlContent&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;($file, $dbConfigPath, $date)&lt;span class=&quot;hljs-function&quot;&gt;
{
    $config = &lt;span class=&quot;hljs-keyword&quot;&gt;$this-&amp;gt;getConnectionConfig($file)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if ($config) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　稍好一点的抽象层级如下，当然&lt;code&gt;excuteSql()&lt;/code&gt;还可以继续拆分，当书写函数的时候需要打空行来区别内容的大部分时候 可以考虑拆分函数了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;executeSqlByFile&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;($file, $dbConfigPath, $date)&lt;span class=&quot;hljs-function&quot;&gt;
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;$this-&amp;gt;getConnectionConfig($file)) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;$this-&amp;gt;excuteSql($file, $dbConfigPath, $date)
    }
}

&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getConnectionConfig&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;($file)&lt;span class=&quot;hljs-function&quot;&gt;
{
    $config = []
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用描述性的函数名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　长而具有描述性的名称，比短而令人费解的名称好。（如果短也能，当然更好）&lt;br/&gt;　　长而具有描述性的名称，比描述性长的注释好。代码维护时，大多数程序员都会自动忽略掉注释，不能保证每次更改都实时更新，越往后越不想看注释，因为很可能形成误导，程序才是真事实。&lt;br/&gt;　　所以，别怕长，更重要的是描述性，看到这个函数名称就知道是干啥的。读代码就像是读英文文章一样，先干了啥，后干了啥，细节怎么干的？&lt;/p&gt;
&lt;p&gt;　　小窍门：可以使用IDE搜索帮助完善命名。&lt;/p&gt;
&lt;p&gt;　　即使结合文件名，publisherController，打死我也无法将 &lt;code&gt;all&lt;/code&gt; 和 &lt;code&gt;移动媒体分类&lt;/code&gt; 联系起来。建议函数名：&lt;code&gt;getMobileMediaClassification()&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 移动媒体分类
 */
public function all(PublisherServices $service, Request $request) {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　完美命名示范，代码上方的注释或许已经不需要了，不过对于母语是中文的我们来说，就当是英文翻译了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * 根据媒体ID获取广告位ID
 */
public function getPublisherPlacementIds(PlacementService $service, Request $request)
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;函数参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最理想的参数数量是0，其次是一，再次是二，应尽量避免三。除非有足够的理由，否则不要用三个以上的参数了。&lt;br/&gt;参数多于两个，测试用例覆盖所有的可能值组合是令人生畏的。&lt;br/&gt;避免出现输出参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标识参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;向函数传入布尔参数简直就是骇人听闻的做法，这样做，就是大声宣布函数不止做一件事，为true会这样，为false会那样。非Boolean类型“标识”参数同理。&lt;/p&gt;
&lt;p&gt;如下代码明确地指出initOrder进行了两种完全不同的初始化方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 订单数据初始化分两种，一种为普通创建订单，一种为通过库存转下单
function initOrder(flag) {
  if (flag === true) {
    // normalInit
    // ...
  } else {
    // init order by inventory
    // ..
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;改进如下，也许你会说，&lt;code&gt;initOrder&lt;/code&gt;不还是干了两件事儿吗？不，它不是自己干了这两件事儿，它只是负责叫别人干这两件事。&lt;br/&gt;如果可以的话，&lt;code&gt;initOrder&lt;/code&gt;里面的判断甚至可以放在能直接拿到&lt;code&gt;flag&lt;/code&gt;的地方。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function initOrder(flag) {
  flag === true ? this.normalInit() : this.initOrderByInvenroty()
}

function normalInit () {
  // todo
}

function initOrderByInvenroty () {
  // todo
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;excuteSql($file, $dbConfigPath, $date)&lt;/code&gt; 中的参数 &lt;code&gt;$dbConfigPath&lt;/code&gt; 和 &lt;code&gt;$file&lt;/code&gt;在&lt;code&gt;file_get_contents()&lt;/code&gt;的作用下变成了&lt;code&gt;标识参数&lt;/code&gt;，&lt;br/&gt;&lt;code&gt;$dbSqlConfig&lt;/code&gt;为真就执行主体函数，为假就不执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
private function excuteSql($file, $dbConfigPath, $date)
{
    $dbSqlConfig = file_get_contents($dbConfigPath . $file);
    if ($dbSqlConfig) {
        $this-&amp;gt;info($file . '文件内容为：' . $dbSqlConfig);

        config([&quot;database.connections.pp_pub_{$userId}&quot; =&amp;gt; $config]);
        $db = DB::connection(&quot;nn_pub_{$userId}&quot;);
        $db-&amp;gt;statement($dbSqlConfig);

        $dirName = 'static/bak/' . $date;
        if (!is_dir($dirName)) {
            mkdir($dirName, 0777, true);
        }
        $cmd = &quot;mv &quot; . $dbConfigPath . $file . &quot;  &quot; . $dirName;
        shell_exec($cmd);

        DB::disconnect(&quot;nn_pub_{$userId}&quot;);
        $this-&amp;gt;info($file . '文件内容为执行完成');
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　改进如下，将标识参数拎出函数具体实现，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
protected function executeSqlByFile($file, $dbConfigPath, $date)
{
    if ($this-&amp;gt;getConnectionConfig($file) &amp;amp;&amp;amp; $this-&amp;gt;file_get_contents($dbConfigPath . $file)) {
        $this-&amp;gt;excuteSql($file, $dbConfigPath, $date)
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;分隔指令与询问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;函数要么做什么，要么回答什么，但二者不可兼得。函数应该修改某对象的状态或是返回该对象的相关信息，两样都干就容易导致混乱。&lt;/p&gt;
&lt;p&gt;从读者的角度思考，&lt;code&gt;set&lt;/code&gt;是指是否已经设置过呢？还是设置成功呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if (set(&quot;username&quot;, &quot;unclebob&quot;)) ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也许上述代码名称可以更为 &lt;code&gt;setAndCheckExists&lt;/code&gt; ， 但依旧没有解决实质性地问题，最好是将指令和询问分隔开来，代码如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if (attributeExists(&quot;username&quot;)) {
  setAttribute(&quot;username&quot;, &quot;unclebob&quot;)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;使用异常替代返回错误码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　错误处理代码能从主路径中分离出来，阅读的时候，可以直面主路径内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Promise.all([
  InventoryService.read({job_id: this.jobId}),
  this.getPlacementType()
]).then((result) =&amp;gt; {
  let [inventoryInfo] = result
  if (res.$code !== 0) {
    this.$alert.error(res.$msg)
    this.$loading(false)
  } else {
    let ret = this.getReserveInfo(data)
    if (ret.reservable) {
      this.orderInitFromInventory(inventoryInfo.$data, this.defaultOrderInfo)
    } else {
      this.$alert.error('该库存不能下单，可能原因：库存未计算完成！')
      this.$loading(false)
    }
  }
})
Promise.all([
  InventoryService.read({job_id: this.jobId}),
  this.getPlacementType()
]).then((result) =&amp;gt; {
  try {
    let [inventoryInfo] = result
    this.checkResponseCode(inventoryInfo)
    this.isInventoryCanBeOrdered(inventoryInfo.$data)
    this.orderInitFromInventory(inventoryInfo.$data, this.orderInfo)
  } catch (err) {
    this.$alert.error(err.message)
    this.$loading(false)
  }
})

isInventoryCanBeOrdered (data) {
  let ret = this.getReserveInfo(data)
  if (!ret.reservable) {
    throw Error('该库存不能下单，可能原因：库存未计算完成！')
  }
}

checkResponseCode (res) {
  if (res.$code !== 0) {
    throw Error(res.$msg)
  }
},
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;别重复自己。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　重复可能是软件中一切邪恶的根源。许多原则与实践都是为控制与消除重复而创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
created () {
  this.$setServiceLoading('数据初始化中...')
  let tplPromise = this.getCreativeTplList({})
  let p1 = new Promise((resolve, reject) =&amp;gt; {
    publisherService.getAll({
      op_status: 'ENABLE'
    }).then(res =&amp;gt; {
      if (res.$code !== 0) {
        reject()
      } else {
        this.publisherOptions = res.$data
        resolve()
      }
    })
  })
  let p2 = new Promise((resolve, reject) =&amp;gt; {
    publisherService.selectAllRules().then(res =&amp;gt; {
      if (res.$code !== 0) {
        reject()
      } else {
        this.protectionOptions = res.$data
        resolve()
      }
    })
  })
  let p3 = new Promise((resolve, reject) =&amp;gt; {
    realizeService.selectAllRules().then(res =&amp;gt; {
      if (res.$code !== 0) {
        reject()
      } else {
        this.realizeOptions = res.$data
        resolve()
      }
    })
  })
  Promise.all([p1, p2, p3, tplPromise]).then(() =&amp;gt; {
    if (this.$route.query.id) {
      this.isEditMode = true
      placementService.read({placement_id: this.$route.query.id}).then((res) =&amp;gt; {
        if (res.$code !== 0) {
          this.$alert.error(res.$msg, 3000)
        } else {
          Object.assign(this.formData, res.$data)
          Object.keys(this.formData).forEach(key =&amp;gt; {
            if (typeof this.formData[key] === 'number') {
              this.formData[key] += ''
            }
          })
          this.$nextTick(() =&amp;gt; {
            res.$data.creative_tpl_info.forEach((tpl) =&amp;gt; {
              this.formData.tpls[this.formData.placement_type][tpl.creative_tpl_type].checked.push(tpl.creative_tpl_id)
            })
            this.updateCreativeIds()
          })
        }
      }, () =&amp;gt; {
        this.$router.replace({path: '/placement/list'})
      })
    }
  }, () =&amp;gt; {
    this.$alert.error('初始化媒体信息失败...')
    this.$router.replace({path: '/placement/list'})
  })
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　消除重复代码,&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
created () {
  if (!this.$route.query || !this.$route.query.id) return
  this.$setServiceLoading('数据初始化中...')
  Promise.all([
    publisherService.getAll({ op_status: 'ENABLE' }),
    publisherService.selectAllRules({}),
    realizeService.selectAllRules({}),
    this.getCreativeTplList({})
  ]).then((resData) =&amp;gt; {
    if (!this.checkResCode(resData)) return
    let [publisherOptions, protectionOptions, realizeOptions] = resData
    this.publisherOptions = publisherOptions
    this.protectionOptions = protectionOptions
    this.realizeOptions = realizeOptions
    this.isEditMode = true
    placementService.read({placement_id: this.$route.query.id}).then((res) =&amp;gt; {
      if (!this.checkResCode([res])) return
      Object.assign(this.formData, res.$data)
      Object.keys(this.formData).forEach(key =&amp;gt; {
        if (typeof this.formData[key] === 'number') {
          this.formData[key] += ''
        }
      })
      this.$nextTick(() =&amp;gt; {
        res.$data.creative_tpl_info.forEach((tpl) =&amp;gt; {
          this.formData.tpls[this.formData.placement_type][tpl.creative_tpl_type].checked.push(tpl.creative_tpl_id)
        })
        this.updateCreativeIds()
      })
    })
  })
}

function checkResCode (resData) {
  for (let i = 0, len = resData.length; i &amp;lt; len; i++) {
    let res = resData[i]
    if (res.$code !== 0) {
      this.$alert.error(`初始化媒体信息失败，${res.$msg}`, 3000)
      this.$router.replace({path: '/placement/list'})
      return false
    }
  }
  return true
}
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;别返回null，也别传递null&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　javascript中，需要返回值的，别返回null/undefined，也别传递null/undefined，除非特殊需要。&lt;br/&gt;一旦返回值存在null，就意味着每一个调用的地方都要判断、处理null，否则就容易出现不可预料的情况。 如下方代码所示，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
public void registerItem(Item item) {
  if (item !== null) {
    ItemRegistry registry = peristentStore.getItemRegistry();
    if (registry != null) {
      Item existing = registry.getItem(item.getID());
      if (existing.getBillingPeriod().hasRetailOwner()) {
        existing.register(item);
      }
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以，在自己可以控制的函数中（不可控因素如：用户输入），别返回null，也别传递null，别让空判断搞乱了代码逻辑。&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;综合案例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据《clean code》来看，下面这个函数有以下几个方面需要改进，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数太大&lt;/li&gt;
&lt;li&gt;代码重复&lt;/li&gt;
&lt;li&gt;函数命名不具有描述性&lt;/li&gt;
&lt;li&gt;部分注释位置放置不合适&lt;/li&gt;
&lt;li&gt;某些行字符数量太多&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;99&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//注册账号
public function create($data)
{
    //检查是否可以注册
    $check = [
        'tdd'        =&amp;gt; $data['tdd'],
    ];
    foreach ($check as $field =&amp;gt; $value) {
        $exist = $this-&amp;gt;userService-&amp;gt;check($field, $value);
        if($exist) {
            throw new RichException(Error::INFO_UNIQUE, [[Error::INFO_UNIQUE,['QQ']]]);
        }
    }
    $userId = $data['user_id'];
    //检查主账号是否存在
    $exist = $this-&amp;gt;userService-&amp;gt;check('user_id', $userId);
    if(!$exist) {
        throw new RichException(Error::INFO_NOT_FIND_ERROR);
    }
    //姓名账号内唯一
    $exist = (new UserModel($userId))-&amp;gt;where('operate_name', '=', $data['operate_name'])-&amp;gt;where('user_id', '=', $userId)-&amp;gt;where('deleted', '=', 0)-&amp;gt;first();
    if($exist) {
        throw new RichException(Error::INFO_UNIQUE, [[Error::INFO_UNIQUE,['姓名']]]);
    }

    $time = date('Y-m-d H:i:s');
    //基本信息
    $exist = (new UserModel($userId))-&amp;gt;where('tdd', '=', $data['tdd'])-&amp;gt;where('user_id', '=', $userId)-&amp;gt;where('deleted', '=', 1)-&amp;gt;first();
    if($exist) {
        (new UserModel($userId))-&amp;gt;where('tdd', '=', $data['tdd'])-&amp;gt;update([
            'operate_name'  =&amp;gt; $data['operate_name'],
            'remarks'   =&amp;gt; isset($data['remarks']) ? $data['remarks'] : '',
            'tdd'        =&amp;gt; $data['tdd'],
            'time'  =&amp;gt; $time,
            'operate_status' =&amp;gt; UserModel::DEFAULT_STATUS,
            'user_id'   =&amp;gt; $userId,
            'deleted'   =&amp;gt; 0,
        ]);
    } else {
        (new UserModel($userId))-&amp;gt;insert([
            'operate_name'  =&amp;gt; $data['operate_name'],
            'remarks'   =&amp;gt; isset($data['remarks']) ? $data['remarks'] : '',
            'tdd'        =&amp;gt; $data['tdd'],
            'time'  =&amp;gt; $time,
            'operate_status' =&amp;gt; UserModel::DEFAULT_STATUS,
            'user_id'   =&amp;gt; $userId,
            'deleted'   =&amp;gt; 0,
        ]);
    }
    //删除账号同样可以创建
    $exist = (new UserQQModel())-&amp;gt;where('tdd','=', $data['tdd'])-&amp;gt;where('deleted', '=', 1)-&amp;gt;first();
    if($exist) {
        (new UserQQModel())-&amp;gt;where('tdd', '=', $data['tdd'])-&amp;gt;update([
            'tdd' =&amp;gt; $data['tdd'],
            'user_id' =&amp;gt; $userId,
            'user_type' =&amp;gt; UserInfoModel::USER_TYPE_OPT,
            'time' =&amp;gt; $time,
            'deleted'   =&amp;gt; 0,
        ]);
        //删除原角色信息
        (new OptUserRoleModel($userId))-&amp;gt;where('tdd','=', $data['tdd'])-&amp;gt;delete();
    } else {
        (new UserQQModel())-&amp;gt;insert([
            'tdd' =&amp;gt; $data['tdd'],
            'user_id' =&amp;gt; $userId,
            'user_type' =&amp;gt; UserInfoModel::USER_TYPE_OPT,
            'time' =&amp;gt; $time,
            'deleted'   =&amp;gt; 0,
        ]);
    }
    //角色信息
    if(isset($data['role_ids']) &amp;amp;&amp;amp; is_array($data['role_ids'])) {
        $OptRole = array();
        foreach ($data['role_ids'] as $item) {
            if($item) {
                $opt = [
                    'user_id'   =&amp;gt; $userId,
                    'tdd'    =&amp;gt; $data['tdd'],
                    'role_id'   =&amp;gt; $item,
                    'time'  =&amp;gt; $time,
                ];
                $OptRole[] = $opt;
            }
        }
        //更新角色数量信息---暂时不做维护
        if($OptRole) {
            (new OptUserRoleModel($userId))-&amp;gt;insert($OptRole);
        }
    }
    //记录日志
    $operateType = BusinessLogConst::CREATE;
    $operateObjectName = $data['operate_name'];
    $operateId = $data['tdd'];
    $operateAction = ['operate_name' =&amp;gt; $data['operate_name'], 'remarks'   =&amp;gt; isset($data['remarks']) ? $data['remarks'] : '', 'user_id'   =&amp;gt; $userId, 'role_ids' =&amp;gt; isset($data['role_ids']) ? json_encode($data['role_ids']) : ''];
    $res = $this-&amp;gt;writeLog($operateType, $operateObjectName, $operateId, $operateAction);

    return ['user_id' =&amp;gt; $userId, 'tdd' =&amp;gt; $data['tdd']];
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</description>
<pubDate>Tue, 12 Dec 2017 07:53:00 +0000</pubDate>
<dc:creator>妖艳货</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codelovers/p/8028200.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(七)数据采集与归档 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/8027791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/8027791.html</guid>
<description>&lt;div readability=&quot;9&quot;&gt;
&lt;p class=&quot;PublishStatus&quot;&gt;&lt;span&gt; 一&lt;strong&gt;、   &lt;/strong&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;PublishStatus&quot;&gt; &lt;span&gt;在当前自动化、信息化、智能化的时代背景下，数据的作用日渐凸显。而工业发展到如今，科技含量和自动化水平均显著提高，但对数据的采集、利用才开始起步。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对工业企业而言，数据采集日益受到重视，主要应用场景包括：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;节能降耗&lt;/strong&gt;。投入（如车间的水电气能耗、设备工时、原料耗用）和产出（产量、批数）这些成本核算的关键数据通过传感器采集，取代人工抄表已成为趋势。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;绩效考评&lt;/strong&gt;。投入、产出、损耗、工时数据，其对管理者的决策支持、对员工的绩效评估都很重要。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;批次追溯&lt;/strong&gt;。食品安全形势日益严峻，对物料的追溯也成为国家硬指标。追溯就是追根溯源，批次生产的每个环节都需要数据跟踪。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;设备管理&lt;/strong&gt;。如设备的运行时长对于设备保养、故障频率对于设备维护、设备参数对于工艺优化。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;数据既然如此重要，对于SCADA不但必须有，而且高要求：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;准确性&lt;/strong&gt;。信号不能失真，采集精度和时间戳尽可能精确；也不能带入太多干扰和噪音。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;完整性&lt;/strong&gt;。信号不能频繁丢失、丢步、跳步，万一信号断开，要快速重连，或者有冗余机制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;大容量&lt;/strong&gt;。大数据，首先要能撑的起这个“大”。大项目动辄几万点，采集频率又高，一天下来数据量都惊人，日积月累更是天量。&lt;/span&gt;&lt;span&gt;例如对于 1万点的系统， 1秒钟存储一次，每次单点占用 8字节，保存 10年的数据量将有 10000*8*10*365*86400=25228800000000字节，也就是 23TGB。若用 80GB硬盘存放，需 293块硬盘。&lt;/span&gt;&lt;span&gt;如此庞大的数据量，还要求快速插入、快速查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;要实现这些指标，非常具有挑战性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;实时库与历史库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工控环境特殊性在于，大量测点快速变化，需高速存取， IO密集型；数据结构简单规则，无非就是名称/ID、值、时间戳这些；数据流式存储，只需在尾部插入，不删不改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此常规的关系数据库不仅存取速度跟不上，也显得杀鸡用牛刀。实时库和历史库就是为工业环境准备的，测点的实时数据存储在内存，保证最快的存取速度；数据超过一定范围需要转储入历史库，我这里用了自定义格式的二进制文件，力求数据单元空间占用最小化、同时查询速度最大化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测点数据在内存中，包含【下位机映射缓存：ICache】→【快照数据集：TagList】→【历史数据缓存：HistoryList】这样的三级结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ICache是下位机当前数据的缓存，随扫描过程实时更新，继承&lt;span&gt;IReaderWriter&lt;/span&gt;接口，可读可写，可以通过Tag的Read\Write读取和更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对当前所有测点数据的快照查询，可以通过Tag的清单列表&lt;span&gt;MetaTagList&lt;/span&gt;结合神器Linq实现。Linq对内存列表数据的查询能力可以说既强大又优雅，这是微软送给C#码农的礼物，不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测点数据改变就会生成一条新的记录。这些记录如马上转储到数据库或文件，则测点数量多变化快，其IO是系统不能承担之重。但如果测点记录堆积过多不及时清理，则一方面可靠性下降，如系统崩溃、断电就会发生大量数据点丢失，同时内存占用越来越大，影响系统性能。所以测点历史数据的缓存容量应可根据测点数量和存取频率自适应或由用户自定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;海量的测点数据，普通关系数据库是难以招架的。如SQL SERVER免费版只有4-10个G上限。而这个容量可能一个月就溢出了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，为了适应天量数据，就需要二进制文件存储。有人会问为啥不用NO SQL,Hadoop这些高大上的东东，我的观点是不追求高大上，因为工控数据不同于搜索引擎，都是简单而标准的结构。可以根据其特点进行有针对性的设计，无需部署复杂的NO SQL架构也一样可以实现高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;历史数据库要最大限度的压缩数据，同时又要保证快速插入、快速查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何保证数据单元最小化？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析存储结构，一条记录包括变量名、当前值、时间戳。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量名可能为一个长字符串，数据量大之后显然是过于冗长。因此代之以ID号（2字节）。还可以进一步压缩，如相同变量存在一起，ID也可以省了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前值大部分是浮点数，4字节，这个不能缩减，否则影响数据精度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间戳为DateTime，要占8字节，但如果数据按日排序，日期部分省去，4个字节的时间部分就可以精确到毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，通过合理设计存储结构，一条记录可以压缩到8个字节（开关量5个字节）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何保证快速插入记录？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存档文件日积月累肯定是越来越庞大，如果采用覆盖式写入或更新写入，不仅可靠性下降，读写成本也越来越高。想快速插入必须保证每次写入不改变原来的数据，仅仅在末尾追加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何保证快速查询？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先为保证可靠性和数据容量限制，数据分月存放。文件名为【年-月.bin】。如需跨月查询，按文件名搜索拼接即可。开头256个字节存放日期索引。32*8字节，对应每日记录的头指针，也即上一日记录的末尾。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主索引下，每一天的记录头为日内索引区。包含一个索引数组，每一项索引有变量ID、变量长度、数量。如要查某日某ID的变量，即可先找到ID,再根据其变量长度*数量累加计算，即可定位到该变量的第一条记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同一变量的记录按时间戳顺序排列。这样，要定位到该变量某一时间的记录，即可对时间戳采用二分法快速定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串类型的归档比较特殊，专门在&lt;span&gt;EventLog&lt;/span&gt;作为日志存取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;数据转储流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;为什么要建立三级转储&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;数据在什么情况下会被采集？默认是变化了采集。如果一个数据长期不变，但需要定期采样，可以设置归档周期：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201712/43917-20171212150602222-183250546.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;221&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据被采集之后首先是存在内存中。内存的特点是快，小。存取快，但是容量有限，采样数据堆积多了就要清理转储到关系数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么要多一层关系数据库？因为采样的数据是时间序列的，但最终二进制文件的索引结构按照变量-时间戳排布，比如依次排入变量A-13:40，变量B-13:41，变量A-13:42这样一个时间序列，如直接写二进制存档文件就需按变量排序并重新整理写入，文件越大其写入效率越低，对系统拖累越大。而先转储到关系数据库，再定期将上一日的数据转储到二进制文件，既可以充分利用关系数据库的高性能批量插入功能（在SQL SERVER就是&lt;span&gt;Sqlbulkcopy&lt;/span&gt;），又可利用关系库的查询排序能力，一举两得，转储之后数据库记录清空，也避免关系库容量溢出的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由上所述，转储包含【历史数据缓存：HistoryList】→【关系数据库：Log_HDA】→【二进制文件：bin文件】三级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每转储成功一次，上一级的数据就清空，保证每一级之间的数据不重叠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样一来，数据记录就分布于三个位置：内存、关系库、二进制文件。要查询数据，就需要对这三部分数据进行“拼接”。拼接的规则就是以当前级最末一条记录的时间戳为准。如当前级中没有，就查下一级。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;源头：内存数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;内存数据库是一个HistoryData列表。有两种情况可以触发清理：定期清理、溢出清理。定期清理是设置固定的周期。溢出就是超过一定大小，到时间就转到关系库。可由&lt;span&gt;server.xml&lt;/span&gt;配置。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;中介：关系数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;就是数据库的Log_HDA表。承上（内存）启下（二进制文件），暂存数据。也包含ID、值、时间戳这几个字段。每天凌晨开始，网关服务调用&lt;span&gt;DataHelper&lt;/span&gt;内部的WriteToFile方法（实际是调用关系库的&lt;span&gt;WRITEHDATA&lt;/span&gt;存储过程），对暂存的测点记录按时间、变量排序，转储到二进制文件中。如写入失败，判断最后一个时间戳，下一次继续追加写入，类似断点续传。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;存储：二进制数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;二进制存档文件按月存放，自带索引。所有对其操作均在&lt;span&gt;DataHelper&lt;/span&gt;的&lt;span&gt;HDAIOHelper&lt;/span&gt; 类中。包括从数据库写入、查询、定期转储、压缩归档（用旋转门算法）等。为提高读写性能，采用内存映射文件&lt;span&gt;MemoryMappedFile&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;数据应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;数据的应用场景，主要是查询、显示、挖掘。查询→生成各种报表、图表，以供人工分析比较；显示→图形化展示，一目了然；挖掘→结合先进的挖掘工具，找出数据内在关联性，提供决策支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201712/43917-20171212150437738-14582946.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;403&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;数据查询&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;目前支持的查询场景包括：按时间段检索、按变量ID检索、获取某变量在一段时间内的平均值/最大值/最小值/初始值/当前值。如要对一段记录执行复杂查询（如按时间间隔分组等），需要取出该时间段内所有记录，用Linq查询。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;数据显示&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;目前支持实时数据显示和历史数据趋势图。我这里用了一套微软俄罗斯研究院的DynamicDataDisplay开源组件，性能不错，很适合动态图显示，目前还发展出了javascript版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201712/43917-20171212150510472-1426363127.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;数据报表&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;利用微软的RDLC报表和Chart图表的强大功能，可以方便的设计出各种复杂报表、图表。顺带赞一下RDLC，集成于Visual Studio和SQL SERVER，可以在Web显示，支持内嵌表格、仪表、图表、钻取报表，还可以方便的导出为Excel、Pdf、Word，与.NET 完美集成，强烈推荐。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;未来改进&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式：&lt;/strong&gt;对一个大系统，分布式是必须的。即数据分别在不同节点采集、存储，但形式上依然是一个整体，可以统一查询和传输。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存映像&lt;/strong&gt;：目前的测点缓存模式存在可靠性不足的问题（如突然断电或系统崩溃造成的数据丢失），可依赖Sqlite和内存映像解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MQTT&lt;/strong&gt;：物联网通行的MQTT协议可以解决不同系统之间的实时订阅传输问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查询扩展&lt;/strong&gt;：原生支持按时间间隔分组取出数据等常用查询场景，可以有效提高查询性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安全控制&lt;/strong&gt;：采用证书认证方式，加强权限管理，防止数据传输过程中被篡改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据归档流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201712/43917-20171212150534051-2109669009.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网关层接口概述&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下位机通讯原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何实现一个设备驱动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何设计图元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据采集与归档&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VS插件模块及原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归档模块及文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何进行功能扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组态变量表达式实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;github地址：https://github.com/GavinYellow/SharpSCADA。QQ群：102486275&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Dec 2017 07:38:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/8027791.html</dc:identifier>
</item>
<item>
<title>Android破解学习之路（二）——Android游戏 滚动的天空破解 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8028039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8028039.html</guid>
<description>&lt;p&gt;&lt;span&gt;经过上一期的破解教程，相信大家跟我一样都是对破解是初入门，我们破解的目的是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赚钱吗？百度上一大堆破解版的应用，破解的人有赚到钱吗？实实在在的说，其实也是方便自己而已。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;玩个游戏，感觉过不去了，来个破解，无限金币什么的，通关轻轻松松是不？我们也在破解当中赚钱了不是？省去了买金币的钱&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感觉废话说多了，正题开始&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、破解准备&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前大家都是下载好了Androidkiller，如果没有下，那么请前去我的上一篇http://www.cnblogs.com/kexing/p/8001065.html&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，我把滚动的天空的下载地址放出来链接: https://pan.baidu.com/s/1nvQPzvj 密码: 6666&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家下载之后跟着教程走吧&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、破解开始&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;老样子，将下载好的apk丢进Androidkiller进行反编译，之后将支付失败转为Unicode进行搜索&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212143209535-943123590.png&quot; alt=&quot;&quot; width=&quot;1123&quot; height=&quot;540&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;可以看到，搜索结果有三个，看名字大概确定OppPay是支付的关键，进去看看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212143701207-441549872.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;334&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;从图中，我们可以看到，一个onSuccess和onFailure方法，这两个应该就是支付成功和支付失败的方法了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、破解思路&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;破解的思路来了，我们什么情况会进入到支付失败的这个方法呢？无非是点击了支付，APP弹出了支付界面，但之后我们又不想支付了，于是点击了取消，这时APP就会进入到onFailure方法当中&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，方法就来了，我们将&lt;span&gt;本来要执行的onFailure改为onSuccess，取消不就是相当于支付成功了吗&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.将onSuccess方法中的代码替换掉onFailure原来的代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212145504676-1443755725.png&quot; alt=&quot;&quot; width=&quot;1127&quot; height=&quot;468&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：这里提醒一下，.locals  开始全部都算是onFailure里面代码，上图选中的其实是onSuccess里面的代码，我已经替换了，之后保存，编译，测试&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2.将原本调用onFailure方法改为onSuccess方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们可以去找到调用onFailure方法的地方，之后，让其调用onSuccess方法，这样也是可以达成破解的目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212150559222-445759429.png&quot; alt=&quot;&quot; width=&quot;1377&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;我们搜索onFailure，可以找到有几个结果，经过代码查看，可以确定主要是在PayResultReceiver这个smail文件中，为什么可以确定是在这个文件呢？大家可以看上面，有个取消支付的Unicode，从这，我们可以断定，取消支付点击之后，就是会执行onFailure，我们可以把这个onFailure改为onSuccess，这样就是相当于调用onSuccess方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过，个人觉得这个方法在这个APP不好用，因为&lt;span&gt;PayResultReceiver这个smail文件&lt;/span&gt;有三处地方需要改，步骤显得有些繁琐，还不如第一种简单快捷&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四、测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 在测试之前，我们还要将发送短信的权限给删除，这样就不怕APP扣费了，在AndroidMainfest文件中删去图中方框那行就行了，之后编译安装测试一下吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212153725754-1055559896.png&quot; alt=&quot;&quot; width=&quot;1270&quot; height=&quot;617&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212152806832-1212770617.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171212152836644-1508454656.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 12 Dec 2017 07:30:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8028039.html</dc:identifier>
</item>
<item>
<title>phpcms网站搬家 至 服务器 完整并且详细过程 - 悦~</title>
<link>http://www.cnblogs.com/nuanai/p/7987720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuanai/p/7987720.html</guid>
<description>&lt;p&gt;想要自己的网站让人们看到那就要上传服务器空间后，这样才会通过搜索域名进行网页访问。&lt;/p&gt;
&lt;p&gt;但是在上传的过程中肯定会有很多东西要修改，例如数据库怎么上传、路径怎么修改等。。。。。这些对于生手可能会慌乱，不用害怕！&lt;/p&gt;
&lt;p&gt;这就让大家看下，自己不断尝试后的完整搬家步骤！！！&lt;/p&gt;
&lt;p&gt;必须有自己的上传工具，我这里使用的就是FLASHFXP软件~~~下面开始自己的上传之路~~~&lt;/p&gt;
&lt;p&gt;一、上传服务器&lt;/p&gt;
&lt;p&gt;（1）链接自己的服务器空间（测试空间）&lt;/p&gt;
&lt;p&gt;　　a.输入ftp地址&lt;/p&gt;
&lt;p&gt;　　b.输入ftp用户名&lt;/p&gt;
&lt;p&gt;　　c.输入ftp密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212152543144-1639180207.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）开始上传自己的文件&lt;/p&gt;
&lt;p&gt;因为是phpcms，所以先要上传一个完整的phpcms的安装文件上去，进行安装，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171205154814972-1242864525.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）进行安装phpcms到服务器中&lt;/p&gt;
&lt;p&gt;　　a.打到本地phpcms安装包文件位置，远程位置也打开你想要安装的位置，如图&lt;/p&gt;
&lt;p&gt;　　我在远程位置新建了个文件夹，将phpcms上传到我新建的文件夹里面（右键单击选择---传输选定的项）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171205160110144-637407201.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171205161301675-761704837.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　b.传输完成后就是安装了&lt;/p&gt;
&lt;p&gt;　　（1）在浏览器的地址栏中输入远程的phpcms的安装包的路径，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171206094625503-675626584.png&quot; alt=&quot;&quot; width=&quot;903&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）进行安装就可以了，一步一步操作，到了数据库安装步骤后，填写自己的数据库信息就可以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212152816785-1109791667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（3）填写完成后就是开始安装了~~安装完成显示如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171206095814675-676373242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）进行后台登录就可以了&lt;/p&gt;

&lt;p&gt;（4）上传本地相关文件&lt;/p&gt;
&lt;p&gt;将自己的本地的模板文件、样式表文件、js文件、图片文件等传到服务器的相同位置，这个就不详细说了吧，会phpcms的都知道放在什么位置了，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212151928410-1024212634.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;250&quot;/&gt;     文件夹下的            &lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212152016738-1980110825.png&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次上传至上图的规定位置即可&lt;/p&gt;

&lt;p&gt;（5）登录服务器端的phpcms后台及后台数据替换&lt;/p&gt;
&lt;p&gt;　　a.输入用户名、密码、验证码，进行登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171206111918597-2088701670.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b.登录成功后，进行修改模板为自己的模板和域名（不多说了，都知道怎么修改）&lt;/p&gt;
&lt;p&gt;　　c.替换数据库&lt;/p&gt;
&lt;p&gt;　　(1)将本地的数据库信息备份（进入本地后台---扩展----数据库工具-----选择数据连接池-----开始备份）&lt;/p&gt;
&lt;p&gt;　　备份完成后找文件夹路径为：phpcms文件夹中的-------install_package\caches\bakup\default文件下的sql文件（这就是你备份的文件）&lt;/p&gt;
&lt;p&gt;　　(2)将备份的文件上传服务器的相应位置（怎么上传不多说，上传的步骤操作多边了）&lt;/p&gt;
&lt;p&gt;　　(3)登上远程phpcms后台，重复(1)中的步骤至“数据库工具”-----改成-----&quot;数据导入&quot;------“数据恢复”，恢复数据库。&lt;/p&gt;
&lt;p&gt;　　d.以上步骤都完成后，单击phpcms中的更新缓存，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212145927238-2052081952.png&quot; alt=&quot;&quot; width=&quot;733&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　全部更新完了后就可以打开自己网页的首页&lt;/p&gt;
&lt;p&gt;（6）以上就弄完了，也可以访问自己的网页了，但是有一步骤，就是图片的或是另外的一些路径还没有完全的更改路径，这样的话就需要手动修改文件了&lt;/p&gt;
&lt;p&gt;　　a.链接上自己的数据库，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212150457222-1092039699.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b.链接成功后，打开自己的数据库，然后导出自己的数据库信息（转储为sql文件）&lt;/p&gt;
&lt;p&gt;　　右键单击自己的数据库，然后选择“转储sql文件”就可以了，选择文件的保存位置就可以了，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212151001269-1643119125.png&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　c.找到自己的转储的sql文件，右键单击-----打开方式-----记事本，打开sql文件&lt;/p&gt;
&lt;p&gt;　　d.打开后，全选后，选择菜单“编辑”----“替换”，打开替换窗口，把本地链接替换成自己的域名链接然后“保存”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212151317801-1178478718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　e.全选内容，拿到数据库进行执行语句，复制到创建查询窗口，单击“运行”开始执行自己的数据库语句，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212151445722-319448910.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;405&quot;/&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/748803/201712/748803-20171212151515316-1466044664.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上就是手动更新数据库信息的连接，这样，才是把数据完整的弄到了自己的服务器上。这也是自己不断尝试的结果，希望可以帮助不会phpcms搬家的伙伴们！！&lt;/p&gt;
&lt;p&gt;　　还有就是在制作网站的过程中遇到了自己不熟悉的东西，那就是验证码怎么替换？这个很好弄，在下一篇博客中会继续告诉伙伴们~~~~&lt;/p&gt;

</description>
<pubDate>Tue, 12 Dec 2017 07:24:00 +0000</pubDate>
<dc:creator>悦~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nuanai/p/7987720.html</dc:identifier>
</item>
<item>
<title>前后端分离模式下的权限设计方案 - _liuxx</title>
<link>http://www.cnblogs.com/liuyh/p/8027833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyh/p/8027833.html</guid>
<description>&lt;p&gt;前后端分离模式下，所有的交互场景都变成了数据，传统业务系统中的权限控制方案在前端已经不再适用，因此引发了我对权限的重新思考与设计。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;权限控制到底控制的是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在理解权限控制之前，需要明白两个概念：资源和权限。什么是资源，对于一个系统来说，系统内部的所有信息都可以理解为这个系统的资源。页面是资源、数据是资源、按钮是资源、图片是资源、甚至页面上一条分割线也可理解为是这个系统的资源。而权限就是访问某个资源所需要的标识。无论系统的权限如何设计，在用户登录时，都可以计算得出用户所拥有的权限标识集合，也就确定了该用户能访问哪些系统资源，这就是我理解的权限控制的本质。于是我们可以得出：&lt;strong&gt;权限控制是控制登录用户对于系统资源的访问。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;前后端分离模式下，前后端在权限控制中各自的职责是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在弄清前后端在权限控制中各自的职责是什么之前，需要理解前后端各自在系统中的职责。这个还是很好理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 服务端：提供数据接口。&lt;/li&gt;
&lt;li&gt;前端：路由控制、页面渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于前端负责与用户交互，用户所能操作的资源入口都是由前端进行控制，那么前端的权限控制就包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 前端路由的权限控制，过滤非法请求，用户只能访问权限范围内的页面资源。&lt;/li&gt;
&lt;li&gt;页面内组件的权限控制，根据用户的权限控制页面组件的渲染。包括各种按钮、表格、分割线等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;随着前端组件化的快速发展，用户所看到的一切均可理解为组件，页面是个大组件，其内部由各个小组件拼凑而来，那么&lt;strong&gt;前端权限控制最终落地到对组件的权限控制。&lt;/strong&gt;于是脑补了出了最优雅的权限组件使用方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;组件 permissionName='xxx' /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前端可以渲染出用户权限范围内的各种系统资源，但是不能保证数据接口的安全性，某些比较喜欢折腾的用户完全可以越过前端的页面访问我们系统的数据接口，那么&lt;strong&gt;服务端的权限控制最终落地到对接口的权限验证。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;引上文，系统的一切资源均可进行权限控制，实际上也可以做到，但在我们实际的操作过程中，往往不需要细化到分割线那种程度。这里以按钮级权限控制为例做实现说明，如果有更细粒度的权限需求，此思路依然可行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前端路由权限控制。用户登录时拿到用户拥有的权限标识集合，在前端存储。路由变化时，进行权限判断，通过则渲染对应页面组件，否则渲染403组件。示例代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let hasPermission =&lt;span&gt; permission.check(current.permissionName);

&lt;/span&gt;&amp;lt;div className={styles.content}&amp;gt;&lt;span&gt;
    {hasPermission &lt;/span&gt;? children : &amp;lt;Exception type={403}/&amp;gt;}
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;封装bird-button权限按钮组件，传入按钮所需权限名，内部进行权限判断，通过则渲染按钮。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;BirdButton permissionName={'sys'} type='primary'&amp;gt;测试按钮&amp;lt;/BirdButton&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 服务端。服务端权限验证很好理解。使用拦截器验证当前请求的权限。代码示例：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SsoAuthorizeInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HandlerInterceptorAdapter {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TicketHandler ticketHandler;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SsoAuthorizeManager authorizeManager;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(handler &lt;span&gt;instanceof&lt;/span&gt; HandlerMethod)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        HandlerMethod handlerMethod &lt;/span&gt;=&lt;span&gt; (HandlerMethod) handler;
        SsoAuthorize authorize &lt;/span&gt;= handlerMethod.getMethodAnnotation(SsoAuthorize.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (authorize != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            TicketInfo ticketInfo &lt;/span&gt;=&lt;span&gt; ticketHandler.getTicket(request);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticketInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnAuthorizedException(&quot;用户信息已失效.&quot;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;

            String[] requirePermissions &lt;/span&gt;=&lt;span&gt; authorize.permissions();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requirePermissions.length==0)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isCheckAll =&lt;span&gt; authorize.isCheckAll();
            UserPermissionChecker permissionChecker &lt;/span&gt;=&lt;span&gt; authorizeManager.getUserPermissionChecker();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;permissionChecker.hasPermissions(ticketInfo.getUserId(),requirePermissions,isCheckAll)){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ForbiddenException(&quot;用户没有当前操作的权限.&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;源码地址&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本博客涉及到的前端权限控制思路均已在&lt;a href=&quot;https://github.com/liuxx001/bird-front&quot; target=&quot;_blank&quot;&gt;https://github.com/liuxx001/bird-front&lt;/a&gt;项目中实现，项目中除了按钮级权限方案还提供了后台业务系统开发中常用的数据组件，包括：&lt;/p&gt;
&lt;p&gt;所有业务组件的理念均是结合服务端接口进行组件的封装，兼顾灵活性的同时保证更优的业务开发速度。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Dec 2017 07:05:00 +0000</pubDate>
<dc:creator>_liuxx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyh/p/8027833.html</dc:identifier>
</item>
<item>
<title>iOS 视频直播弹幕的实现 - 自律的自由</title>
<link>http://www.cnblogs.com/ChengYing-Freedom/p/8025210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChengYing-Freedom/p/8025210.html</guid>
<description>&lt;p&gt;　　弹幕，并不是一个多么复杂的功能。&lt;/p&gt;
&lt;h2&gt;1.弹幕的实现性分析&lt;/h2&gt;
&lt;h3&gt;　　首先，从视觉上明确当前弹幕所具有的功能&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;从屏幕右侧滑入左侧，直至完全消失&lt;/li&gt;
&lt;li&gt;不管是长的弹幕，还是短的弹幕，速度一致（可能有的需求是依据弹幕长度，调整速度）&lt;/li&gt;
&lt;li&gt;有弹幕轨道，不是随机产生的弹幕&lt;/li&gt;
&lt;li&gt;弹幕不会进行重叠&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　接下来从功能角度思考需要做什么&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;重用机制，类似tableView有一个重用池，每个弹幕就是一个cell，当有弹幕发送的时候，如果当前的重用池没有控件，则创建一个新的控件，如果重用池里面有控件，则拿出这个控件，开始做动画，在动画结束后重新将该控件重归重用池。&lt;/li&gt;
&lt;li&gt;速度要求一致的话，需要考虑几点，首先如下图所示，&lt;span&gt;红色代表弹幕起始位置&lt;/span&gt;，&lt;span&gt;蓝色代表弹幕终止位置&lt;/span&gt;，长度代表它们的实际长度。当我们设定动画的时候，采用[UIView animationWithDuration.....]这个动画，设定duration为3s的话那么弹幕1的速度为（屏幕宽度+弹幕1宽度）/3，弹幕2的速度为（屏幕宽度+弹幕2宽度）/3，因为弹幕2长度大于弹幕1的长度，所以&lt;span&gt;弹幕2的速度大于弹幕1的速度。&lt;span&gt;（对于依据弹幕长度调整速度的需求来说，这里相对简单一些，不需要专门去计算速度，唯一麻烦的是需要考虑速度不一致带来的重叠问题）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1295908/201712/1295908-20171211163940915-1419327042.png&quot; alt=&quot;&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.开始准备&lt;/h2&gt;
&lt;p&gt;　　精通数学公式V=S/t （V代表速度，S代表路程，t代表时间）(*^__^*) &lt;/p&gt;
&lt;h2&gt;3.正式开始&lt;/h2&gt;
&lt;p&gt;　　创建一个View，命名为BarrageView，以及存储弹幕数据的对象BarrageModel&lt;/p&gt;
&lt;p&gt;　　以下为BarrageModel.h的内容，存储弹幕的头像，昵称，和消息内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BarrageModel : NSObject
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 用户昵称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property(nonatomic,copy)NSString &lt;/span&gt;*&lt;span&gt;userName;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 消息内容 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property(nonatomic,copy)NSString &lt;/span&gt;*&lt;span&gt;userMsg;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 用户头像 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property(nonatomic,copy)NSString &lt;/span&gt;*&lt;span&gt;userHeadImageUrl;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　接下来对BarrageView内容进行编辑，注释已经尽可能的详细，因此不多做介绍&lt;/p&gt;
&lt;p&gt;　　　在.h文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;UIKit/UIKit.h&amp;gt;
&lt;span&gt;@class&lt;/span&gt;&lt;span&gt; BarrageModel;
&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BarrageView : UIView

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *  记录当前最后一个弹幕View，通过这个View来计算是显示在哪个弹幕轨道上
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property(nonatomic,retain) UIView &lt;/span&gt;*&lt;span&gt;lastAnimateView;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 发送弹幕
 *
 *  @param msgModel 弹幕数据Model
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
-(&lt;span&gt;void&lt;/span&gt;)barrageSendMsg:(BarrageModel *&lt;span&gt;)msgModel;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在.m文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarrageView.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarrageModel.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的尺寸&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_FRAME   [[UIScreen mainScreen] bounds]
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的高度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_HEIGHT  CGRectGetHeight(SCREEN_FRAME)
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的宽度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_WIDTH  CGRectGetWidth(SCREEN_FRAME)

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BarrageView()
{
    CGFloat _minSpaceTime;  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 最小间距时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 数据源 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property (nonatomic,retain)NSMutableArray &lt;/span&gt;*&lt;span&gt;dataArr;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 弹幕UI的重用池 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property (nonatomic,retain)NSMutableArray &lt;/span&gt;*&lt;span&gt;resuingArr;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; BarrageView

&lt;/span&gt;-&lt;span&gt; (instancetype)initWithFrame:(CGRect)frame
{
    self &lt;/span&gt;=&lt;span&gt; [super initWithFrame:frame];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (self) {
        [self setInterface];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)setInterface
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化弹幕数据源，以及重用池&lt;/span&gt;
    self.dataArr =&lt;span&gt; [NSMutableArray array];
    self.resuingArr &lt;/span&gt;=&lt;span&gt; [NSMutableArray array];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个弹幕加入重用池作为备用&lt;/span&gt;
    UIView *view =&lt;span&gt;  [self createUI];
    [self.resuingArr addObject:view];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置弹幕数据的初始轮询时间&lt;/span&gt;
    _minSpaceTime = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否可以取弹幕数据进行动画&lt;/span&gt;
&lt;span&gt;    [self checkStartAnimatiom];
}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)checkStartAnimatiom
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当有数据信息的时候&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (self.dataArr.count&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self.resuingArr.count&amp;gt;&lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当重用池里面有备用的弹幕UI时
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在重用池中，取出第一个弹幕UI&lt;/span&gt;
            UIView *view =&lt;span&gt; [self.resuingArr firstObject];
            [self.resuingArr removeObject:view];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出的这个弹幕UI开始动画&lt;/span&gt;
&lt;span&gt;            [self startAnimationWithView:view];
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当重用池没有备用的弹幕UI时
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新创建一个弹幕UI&lt;/span&gt;
            UIView *view =&lt;span&gt; [self createUI];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿着这个弹幕UI开始动画&lt;/span&gt;
&lt;span&gt;            [self startAnimationWithView:view];
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟执行，在主线程中不能调用sleep()进行延迟执行
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用自身方法，构成一个无限循环，不停的轮询检查是否有弹幕数据&lt;/span&gt;
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_minSpaceTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&lt;span&gt;{
        [self checkStartAnimatiom];
    });
}

&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;)startAnimationWithView:(UIView *&lt;span&gt;)view
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出第一条数据&lt;/span&gt;
    BarrageModel *barrageModel =&lt;span&gt; [self.dataArr firstObject];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算昵称的长度&lt;/span&gt;
    CGSize nameSize = [barrageModel.userName boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, &lt;span&gt;14&lt;/span&gt;) options:NSStringDrawingUsesLineFragmentOrigin|&lt;span&gt;NSStringDrawingUsesFontLeading attributes:@{
                                                                                                                                                         NSFontAttributeName:[UIFont systemFontOfSize:&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;]
                                                                                                                                                         } context:nil].size;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算消息的长度&lt;/span&gt;
    CGSize msgSize = [barrageModel.userMsg boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, &lt;span&gt;14&lt;/span&gt;) options:NSStringDrawingUsesLineFragmentOrigin|&lt;span&gt;NSStringDrawingUsesFontLeading attributes:@{
                                                                                                                                                         NSFontAttributeName:[UIFont systemFontOfSize:&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;]
                                                                                                                                                         } context:nil].size;
    
    UIImageView &lt;/span&gt;*headImageView; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头像&lt;/span&gt;
    UILabel *userNameLabel;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;昵称&lt;/span&gt;
    UILabel *userMsgLabel;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息内容
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行赋值，宽度适应&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (UIView *subView &lt;span&gt;in&lt;/span&gt;&lt;span&gt; view.subviews) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subView.tag == &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;) {
            headImageView &lt;/span&gt;= (UIImageView *&lt;span&gt;)subView;
            headImageView.image &lt;/span&gt;= [UIImage imageNamed:&lt;span&gt;@&quot;&quot;&lt;/span&gt;&lt;span&gt;];
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (subView.tag == &lt;span&gt;1001&lt;/span&gt;&lt;span&gt;){
            userNameLabel &lt;/span&gt;= (UILabel *&lt;span&gt;)subView;
            userNameLabel.text &lt;/span&gt;=&lt;span&gt; barrageModel.userName;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新设置名称Label宽度&lt;/span&gt;
            CGRect nameRect =&lt;span&gt; userNameLabel.frame;
            nameRect.size.width &lt;/span&gt;=&lt;span&gt; nameSize.width;
            userNameLabel.frame &lt;/span&gt;=&lt;span&gt; nameRect;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            userMsgLabel &lt;/span&gt;= (UILabel *&lt;span&gt;)subView;
            userMsgLabel.text &lt;/span&gt;=&lt;span&gt; barrageModel.userMsg;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新设置消息内容Label宽度&lt;/span&gt;
            CGRect msgRect =&lt;span&gt; userMsgLabel.frame;
            msgRect.size.width &lt;/span&gt;=&lt;span&gt; msgSize.width;
            userMsgLabel.frame &lt;/span&gt;=&lt;span&gt; msgRect;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新设置弹幕的总体宽度 = 头像宽度 + 头像左右两侧距离 + (如果名字宽度大于消息内容宽度，以名字宽度为基准，如果名字宽度小于消息内容宽度，以消息内容宽度为基准)&lt;/span&gt;
    view.frame = CGRectMake(SCREEN_WIDTH, &lt;span&gt;0&lt;/span&gt;, CGRectGetWidth(headImageView.frame) + &lt;span&gt;4&lt;/span&gt; + (CGRectGetWidth(userNameLabel.frame)&amp;gt;CGRectGetWidth(userMsgLabel.frame)?&lt;span&gt;CGRectGetWidth(userNameLabel.frame):CGRectGetWidth(userMsgLabel.frame)), CGRectGetHeight(self.frame));
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管弹幕长短，速度要求一致。 V(速度) 为固定值 = 100(可根据实际自己调整)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; S = 屏幕宽度+弹幕的宽度  V = 100(可根据实际自己调整)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; V(速度) = S(路程)/t(时间) -------&amp;gt; t(时间) = S(路程)/V(速度);&lt;/span&gt;
    CGFloat duration = (view.frame.size.width+SCREEN_WIDTH)/&lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小间距运行时间为：弹幕从屏幕外完全移入屏幕内的时间 + 间距的时间&lt;/span&gt;
    _minSpaceTime = (view.frame.size.width + &lt;span&gt;30&lt;/span&gt;)/&lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后做动画的view&lt;/span&gt;
    _lastAnimateView =&lt;span&gt; view;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹幕UI开始动画&lt;/span&gt;
    [UIView animateWithDuration:duration delay:&lt;span&gt;0&lt;/span&gt; options:UIViewAnimationOptionCurveLinear animations:^&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行至左侧屏幕外&lt;/span&gt;
        CGRect frame =&lt;span&gt;  view.frame;
        view.frame &lt;/span&gt;= CGRectMake(-frame.size.width, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, frame.size.width, frame.size.height);
    } completion:&lt;/span&gt;^&lt;span&gt;(BOOL finished) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动画结束重新回到右侧初始位置&lt;/span&gt;
        view.frame = CGRectMake(SCREEN_WIDTH, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, CGRectGetHeight(self.frame));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新加入重用池&lt;/span&gt;
&lt;span&gt;        [self.resuingArr addObject:view];
    }];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这个弹幕数据移除&lt;/span&gt;
&lt;span&gt;    [self.dataArr removeObject:barrageModel];
}

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark public method
-(&lt;span&gt;void&lt;/span&gt;)barrageSendMsg:(BarrageModel *&lt;span&gt;)msgModel{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加弹幕数据&lt;/span&gt;
&lt;span&gt;    [self.dataArr addObject:msgModel];
}

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; mark 创建控件
-(UIView *&lt;span&gt;)createUI
{
    UIView &lt;/span&gt;*view = [[UIView alloc] initWithFrame:CGRectMake(SCREEN_WIDTH, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, CGRectGetHeight(self.frame))];
    view.backgroundColor &lt;/span&gt;= [UIColor colorWithWhite:&lt;span&gt;0&lt;/span&gt; alpha:&lt;span&gt;0.3&lt;/span&gt;&lt;span&gt;];
    
    UIImageView &lt;/span&gt;*headImageView = [[UIImageView alloc] initWithFrame:CGRectMake(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, CGRectGetHeight(self.frame)-&lt;span&gt;4&lt;/span&gt;, CGRectGetHeight(self.frame)-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)];
    headImageView.layer.cornerRadius &lt;/span&gt;= headImageView.frame.size.width/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    headImageView.layer.masksToBounds &lt;/span&gt;=&lt;span&gt; YES;
    headImageView.tag &lt;/span&gt;= &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
    headImageView.backgroundColor &lt;/span&gt;=&lt;span&gt; [UIColor redColor];
    [view addSubview:headImageView];
    
    
    UILabel &lt;/span&gt;*userNameLabel = [[UILabel alloc] initWithFrame:CGRectMake(CGRectGetMaxX(headImageView.frame) + &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;&lt;span&gt;)];
    userNameLabel.font &lt;/span&gt;= [UIFont systemFontOfSize:&lt;span&gt;14&lt;/span&gt;&lt;span&gt;];
    userNameLabel.tag &lt;/span&gt;= &lt;span&gt;1001&lt;/span&gt;&lt;span&gt;;
    [view addSubview:userNameLabel];
    
    
    UILabel &lt;/span&gt;*userMsgLabel = [[UILabel alloc] initWithFrame:CGRectMake(CGRectGetMaxX(headImageView.frame)+&lt;span&gt;2&lt;/span&gt;, CGRectGetMaxY(userNameLabel.frame), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;&lt;span&gt;)];
    userMsgLabel.font &lt;/span&gt;= [UIFont systemFontOfSize:&lt;span&gt;14&lt;/span&gt;&lt;span&gt;];
    userMsgLabel.tag &lt;/span&gt;= &lt;span&gt;1002&lt;/span&gt;&lt;span&gt;;
    [view addSubview:userMsgLabel];
    [self addSubview:view];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; view;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后在vc里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarrageView.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarrageModel.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的尺寸&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_FRAME   [[UIScreen mainScreen] bounds]
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的高度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_HEIGHT  CGRectGetHeight(SCREEN_FRAME)
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏幕的宽度&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SCREEN_WIDTH  CGRectGetWidth(SCREEN_FRAME)

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 第一个弹幕轨道 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property (nonatomic,retain)BarrageView &lt;/span&gt;*&lt;span&gt;barrageViewOne;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 第二个弹幕轨道 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@property (nonatomic,retain)BarrageView &lt;/span&gt;*&lt;span&gt;barrageViewTwo;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个弹幕轨道&lt;/span&gt;
    _barrageViewOne = [[BarrageView alloc]initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;, SCREEN_WIDTH, &lt;span&gt;34&lt;/span&gt;&lt;span&gt;)];
    [self.view addSubview:_barrageViewOne];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第二个弹幕轨道&lt;/span&gt;
    _barrageViewTwo = [[BarrageView alloc]initWithFrame:CGRectMake(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;300&lt;/span&gt;, SCREEN_WIDTH, &lt;span&gt;34&lt;/span&gt;&lt;span&gt;)];
    [self.view addSubview:_barrageViewTwo];

}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)&lt;span&gt;event&lt;/span&gt;&lt;span&gt;
{
    NSTimer &lt;/span&gt;*timer = [NSTimer scheduledTimerWithTimeInterval:&lt;span&gt;1&lt;/span&gt;&lt;span&gt; target:self selector:@selector(sendMessage) userInfo:nil repeats:YES];
    [timer fire];
}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)sendMessage
{
    BarrageModel &lt;/span&gt;*model =&lt;span&gt; [[BarrageModel alloc]init];
    model.userName &lt;/span&gt;= @[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;赵六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;七七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;八八&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;九九&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;十十&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;十一&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;十二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;十三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;十四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][arc4random()%&lt;span&gt;12&lt;/span&gt;&lt;span&gt;];
    model.userMsg &lt;/span&gt;= @[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;阿达个人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;都是vsqe12qwe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;胜多负少的凡人歌&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;委屈翁二群二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;12312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;热帖柔荑花&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;发彼此彼此&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;OK泼墨&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;人体有图图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;额外热无若无&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;微软将围&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][arc4random()%&lt;span&gt;11&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算当前做动画的弹幕UI的位置&lt;/span&gt;
    CGFloat onePositon = _barrageViewOne.lastAnimateView.layer.presentationLayer.frame.size.width +&lt;span&gt; _barrageViewOne.lastAnimateView.layer.presentationLayer.frame.origin.x;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算当前做动画的弹幕UI的位置&lt;/span&gt;
    CGFloat twoPositon = _barrageViewTwo.lastAnimateView.layer.presentationLayer.frame.size.width +&lt;span&gt; _barrageViewTwo.lastAnimateView.layer.presentationLayer.frame.origin.x;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( onePositon &amp;lt;&lt;span&gt; twoPositon ) {
        [_barrageViewOne barrageSendMsg:model];
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        [_barrageViewTwo barrageSendMsg:model];
    }
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.测试结论&lt;/h2&gt;
&lt;p&gt;　　经一个小时的定时器测试，内存没有增加。&lt;/p&gt;

</description>
<pubDate>Tue, 12 Dec 2017 06:59:00 +0000</pubDate>
<dc:creator>自律的自由</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChengYing-Freedom/p/8025210.html</dc:identifier>
</item>
<item>
<title>[P4基础]p4app的Docker镜像仓使用详解 - SStriver</title>
<link>http://www.cnblogs.com/spjy/p/8027787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spjy/p/8027787.html</guid>
<description>&lt;p&gt;本文参考 &lt;a href=&quot;http://sunyongfeng.com/201705/networks/p4/repo_p4app.html&quot;&gt;孙勇峰博客&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/p4lang/p4app/blob/master/README.md&quot;&gt;p4app README&lt;/a&gt; 以及 &lt;a href=&quot;https://hub.docker.com/r/p4lang/p4app/~/dockerfile/&quot;&gt;p4app Dockerfile&lt;/a&gt; 结合自己的理解做一些记录，有错误或不足之处欢迎批评指正。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;p4app是一个可以构建、运行、调试和测试P4程序的工具，p4app背后蕴含的哲学是“简单的事情应尽可能简单”，旨在使小而简单的P4程序易于编写、易于与他人分享。&lt;/p&gt;
&lt;h2 id=&quot;p4langp4app的镜像结构&quot;&gt;p4lang/p4app的镜像结构&lt;/h2&gt;
&lt;p&gt;Docker 镜像是分层结构以Ubuntu 16.04为base镜像依次构建，p4app为最顶层.&lt;br/&gt;对于如何构建这些镜像，有兴趣的可以看p4app的Dockerfile.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;p4app&lt;/li&gt;
&lt;li&gt;p4c&lt;/li&gt;
&lt;li&gt;pi&lt;/li&gt;
&lt;li&gt;bmv2&lt;/li&gt;
&lt;li&gt;third-party&lt;/li&gt;
&lt;li&gt;Ubuntu 16.04&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装p4app&quot;&gt;安装p4app&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;下载github的p4app源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git clone https://github.com/p4lang/p4app&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;为了方便可将p4app脚本拷贝到PATH路径&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo cp p4app /usr/local/bin&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下两种均可&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/spjy/p/8001062.html&quot;&gt;docker安装教程&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一键安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wget -qO- https://get.docker.com/ | sh&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;p4app运行p4app程序包. p4app程序包是一个以.p4app为后缀的目录，例如你用P4写了一个路由器程序，将其放在router.p4app目录文件夹下. 该目录应当包括你的P4程序、其他与你的程序相关联的文件和一个p4app.json文件. p4app.json指定如何执行你的p4程序(自定义执行动作).&lt;/p&gt;
&lt;p&gt;在p4app/examples中包含多个样例，具体如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;broadcast.p4app&lt;/li&gt;
&lt;li&gt;compile_only.p4app&lt;/li&gt;
&lt;li&gt;customtopo.p4app&lt;/li&gt;
&lt;li&gt;multi_iface.p4app&lt;/li&gt;
&lt;li&gt;multiswitch.p4app&lt;/li&gt;
&lt;li&gt;paxos_acceptor.p4app&lt;/li&gt;
&lt;li&gt;simple_counter.p4app&lt;/li&gt;
&lt;li&gt;simple_router.p4app&lt;/li&gt;
&lt;li&gt;source_routing.p4app&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;例如，你要执行simple_router.p4app程序包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ p4app run p4app/examples/simple_router.p4app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你执行这条命令，最终会进入mininet命令行界面.&lt;/p&gt;
&lt;p&gt;那么执行这条命令后具体发生了什么？我们先来看看p4app这个可执行脚本在做什么&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;p4app可执行脚本详解&quot;&gt;p4app可执行脚本详解&lt;/h2&gt;
&lt;h2 id=&quot;p4app命令参数&quot;&gt;p4app命令参数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;p4app run
&lt;ul&gt;&lt;li&gt;运行p4app程序包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app run
&lt;ul&gt;&lt;li&gt;运行p4app程序包并指定target&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app build
&lt;ul&gt;&lt;li&gt;构建p4app程序包并输出json文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app pack
&lt;ul&gt;&lt;li&gt;将p4app程序包压缩为单个文件，替换当前目录下的p4app程序包，使用gzip压缩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app unpack
&lt;ul&gt;&lt;li&gt;解压上述压缩包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app update
&lt;ul&gt;&lt;li&gt;更新到最新版本的p4app的docker镜像&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;p4app exec
&lt;ul&gt;&lt;li&gt;在最新运行的p4app容器实例中执行一条命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;p4app-run-内部具体执行流程&quot;&gt;p4app run 内部具体执行流程&lt;/h2&gt;
&lt;p&gt;以simple_router.p4app为例&lt;/p&gt;
&lt;ol readability=&quot;3.9652173913043&quot;&gt;&lt;li&gt;执行run-comman函数
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;执行run-p4app函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点来了，运行p4app容器实例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --privileged --interactive --tty --rm \
    --name &quot;p4app_$RANDOM&quot; \
    -v $1:/tmp/app.tar.gz \
    -v &quot;P4APP_LOGDIR&quot;:/tmp/p4app_logs \
    $P4APP_IMAGE /tmp/p4app.tar.gz &quot;${@:2}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#docker run 
# --tty 分配tty设备 可支持终端登录
# --interactive 打开STDIN 用于控制台交互
# 上面两个是-it
# --name 随机取了一个名字
# -v 将主机上/tmp/p4app.tar.gz.XXXXXX 挂载到容器的 /tmp/app.tar.gz 中
#  如果只是文件 将文件绝对路径挂载到容器的 /tem/app.tar.gz中
# -v 将主机的log目录挂载到容器的/tmp/p4app_logs 中
#  $P4APP_IMAGE $APP_TO_RUN &quot;${@:2}&quot;
#  指定 镜像 文件 其他参数(指定target)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0.97788309636651&quot;&gt;
&lt;p&gt;进入容器实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;p4app容器实例启动后执行的是&lt;a href=&quot;https://github.com/p4lang/p4app/blob/master/docker/scripts/p4apprunner.py&quot;&gt;p4apprunner.py&lt;/a&gt;脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;p4apprunner.py参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;必要参数
&lt;ul&gt;&lt;li&gt;app
&lt;ul&gt;&lt;li&gt;p4app程序包路径&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;target
&lt;ul&gt;&lt;li&gt;compile-bmv2 编译成bmv2目标&lt;/li&gt;
&lt;li&gt;mininet 单P4交换机测试&lt;/li&gt;
&lt;li&gt;multiswitch 多P4交换机测试&lt;/li&gt;
&lt;li&gt;stf 进行stf测试&lt;/li&gt;
&lt;li&gt;custom&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可选参数
&lt;ul&gt;&lt;li&gt;--buid-dir
&lt;ul&gt;&lt;li&gt;构建目录，默认为/tmp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;--quiet
&lt;ul&gt;&lt;li&gt;不显示log消息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;--build-only
&lt;ul&gt;&lt;li&gt;仅编译不运行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;--json
&lt;ul&gt;&lt;li&gt;Use this compiled JSON file instead of compiling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;--manifest
&lt;ul&gt;&lt;li&gt;manifest 清单文件路径，默认为./p4app.json&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;p4apprunner.py解析流程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解压提取p4app程序包&lt;/li&gt;
&lt;li&gt;根据p4app程序包中的p4app.json解析&lt;/li&gt;
&lt;li&gt;根据其中的target执行相应函数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;p4app-build-具体执行流程&quot;&gt;p4app build 具体执行流程&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行build-command函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ run-command --build-only &quot;${@:3}&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;执行run-command函数（同上）&lt;/li&gt;
&lt;li&gt;执行run-p4app函数（同上）&lt;/li&gt;
&lt;li&gt;进入容器实例（同上）&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;copy容器中$P4APP_LOGDIR/program.json到host本地目录下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;总结，添加--build-only选项，仅编译p4app程序输出json文件&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;p4app运行流程小结&quot;&gt;p4app运行流程小结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;第一次运行p4app时会自动下载docker镜像p4lang/p4app:latest
&lt;ul&gt;&lt;li&gt;该镜像中包括P4编译器、mininet、抓包工具tshark、发包工具scapy、net-tools和nmap套件等工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;启动一个p4app容器实例，并在容器中执行p4apprunner.py脚本&lt;/li&gt;
&lt;li&gt;根据传入的p4app.json执行相应操作&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;p4app.json解析&quot;&gt;p4app.json解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;p4app程序包最终如何运行，由manifest指定的p4app.json文件配置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：simple_router.p4app的p4app.json如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;program&quot;: &quot;simple_router.p4&quot;,
  &quot;language&quot;: &quot;p4-16&quot;,
  &quot;targets&quot;: {
    &quot;mininet&quot;: {
      &quot;num-hosts&quot;: 2,
      &quot;switch-config&quot;: &quot;simple_router.config&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有多个target时，需要指定一个默认的target，否则p4app运行其中的第一个target.&lt;br/&gt;&lt;strong&gt;(Ps：纠正孙勇峰博客中说的随机运行其中一个)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;program&quot;: &quot;my_program.p4&quot;,
  &quot;language&quot;: &quot;p4-14&quot;,
  &quot;default-target&quot;: &quot;debug&quot;,
  &quot;targets&quot;: {
    &quot;debug&quot;: { &quot;use&quot;: &quot;mininet&quot;, &quot;num-hosts&quot;: 2 },
    &quot;test1&quot;: { &quot;use&quot;: &quot;stf&quot;, &quot;test&quot;: &quot;test1.stf&quot; },
    &quot;test2&quot;: { &quot;use&quot;: &quot;stf&quot;, &quot;test&quot;: &quot;test2.stf&quot; },
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意其中的&quot;use&quot;字段，若没有指定&quot;use&quot;字段则默认为&quot;use&quot;:&quot;前面的targets名&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;targets字段详解&quot;&gt;targets字段详解&lt;/h2&gt;
&lt;h4 id=&quot;compile-bmv2&quot;&gt;compile-bmv2&lt;/h4&gt;
&lt;p&gt;将p4程序编译成bmv2目标，例如：样例compile_only.p4app&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
      &quot;program&quot;: &quot;compile_only.p4&quot;,
      &quot;language&quot;: &quot;p4-14&quot;,
      &quot;targets&quot;: {
        &quot;compile-bmv2&quot;: {
          &quot;compiler-flags&quot;: [&quot;-v&quot;, &quot;--p4runtime-file out.bin&quot;, &quot;--p4runtime-format json&quot;],
          &quot;run-after-compile&quot;: [&quot;cat out.bin&quot;]
        }
      }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mininet&quot;&gt;mininet&lt;/h4&gt;
&lt;p&gt;编译一个P4程序，并加载到一个BMV2 simple_switch中，然后创建一个mininet实验环境.&lt;br/&gt;支持以下可选的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;mininet&quot;: {
    &quot;num-hosts&quot;: 2,
    &quot;switch-config&quot;: &quot;file.config&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mininet将创建一个星型网络拓扑，包含num-hosts个host并通过不同端口连接到你的P4模拟交换机.&lt;/p&gt;
&lt;p&gt;你可以通过switch-config文件指定P4模拟交换机的启动配置，配置文件中是一系列 BMV2 simple_switch_CLI 命令.&lt;/p&gt;
&lt;h4 id=&quot;multiswitch&quot;&gt;multiswitch&lt;/h4&gt;
&lt;p&gt;multiswitch与mininet类似，编译P4程序并运行在mininet环境. multiswitch顾名思义可支持配置多个交换机、自定义拓扑并自定义在host上执行命令. 这些交换机默认自动配置L2/L3转发规则，用于所有host之间的互通. （前提是P4程序中包含ipv4_lpm、send_frame、forwar table）&lt;br/&gt;例如：multiswitch.p4app&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;program&quot;: &quot;simple_router.p4&quot;,
  &quot;language&quot;: &quot;p4-16&quot;,
  &quot;targets&quot;: {
      &quot;multiswitch&quot;: {
      &quot;auto-control-plane&quot;: true,
      &quot;links&quot;: [[&quot;h1&quot;, &quot;s1&quot;], [&quot;s1&quot;, &quot;s2&quot;], [&quot;s2&quot;, &quot;h2&quot;, 50]],
      &quot;hosts&quot;: {
        &quot;h1&quot;: {
            &quot;cmd&quot;: &quot;python echo_server.py $port&quot;,
            &quot;startup_sleep&quot;: 0.2,
            &quot;wait&quot;: false
        },
        &quot;h2&quot;: {
            &quot;cmd&quot;: &quot;python echo_client.py h1 $port $echo_msg&quot;,
            &quot;wait&quot;: true
        }
      },
      &quot;parameters&quot;: {
        &quot;port&quot;: 8000,
        &quot;echo_msg&quot;: &quot;foobar&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该配置创建如下拓扑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h1 &amp;lt;---&amp;gt; s1 &amp;lt;---&amp;gt; s2 &amp;lt;---&amp;gt; h2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 s2-h2 链路人工配置了50ms的时延. 而host的可选配置选项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cmd
&lt;ul&gt;&lt;li&gt;在host上运行的可执行命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;wait
&lt;ul&gt;&lt;li&gt;如果配置为true，表示等待此命令执行结束；配置为false，表示在后台运行此命令.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;startup_sleep
&lt;ul&gt;&lt;li&gt;启动命令执行完成后必须等待的时间（单位为秒）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;latency
&lt;ul&gt;&lt;li&gt;主机与交换机之间的时延. 可配置为纯数字（默认单位为秒）或具有时间单位的字符串（例如50ms或1s）. &lt;strong&gt;该配置将覆盖link对象中设置的时延.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;限制：目前每个host只能连一个switch&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;stf-simple-test-framework&quot;&gt;stf （simple test framework）&lt;/h4&gt;
&lt;p&gt;编译P4程序并运行一个stf测试用例. stf是一种模拟网络测试框架，可以测试你的P4程序以确保达到预期行为.&lt;br/&gt;例如：simple_counter.p4app&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//json文件
&quot;stf&quot;: {
      &quot;test&quot;: &quot;simple_counter.stf&quot;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//stf文件
add test1 data.f1:0x01010101 c1_2(val1:0x01, val2:0x02)
add test1 data.f1:0x02020202 c1_2(val1:0x10, val2:0x20)

add test2 data.f2:0x03030303 c3_4(val3:0x03, val4:0x04, port:1)
add test2 data.f2:0x04040404 c3_4(val3:0x30, val4:0x40, port:2)

expect 1 01010101 03030303 01 02 03 04
packet 0 01010101 03030303 55 66 77 88
expect 2 01010101 04040404 01 02 30 40
packet 0 01010101 04040404 55 66 77 88
expect 1 02020202 03030303 10 20 03 04
packet 0 02020202 03030303 99 88 77 66
expect 2 02020202 04040404 10 20 30 40
packet 0 02020202 04040404 14 25 36 47&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“test”字段指定的配置文件必须使用stf格式编写. &lt;strong&gt;但是目前还没有该格式的说明文档&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;custom&quot;&gt;custom&lt;/h4&gt;
&lt;p&gt;这是第三种编译P4程序并运行mininet实验环境的方法.&lt;/p&gt;
&lt;p&gt;允许使用者在“program”字段指定自定义python程序. 可通过mininet的python api指定网络拓扑和配置.&lt;/p&gt;
&lt;p&gt;例如：simple_routing.p4app&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;program&quot;: &quot;source_routing.p4&quot;,
  &quot;language&quot;: &quot;p4-14&quot;,
  &quot;targets&quot;: {
      &quot;custom&quot;: {
           &quot;program&quot;: &quot;topo.py&quot;
      }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在运行topo.py时，将默认执行以下操作：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PYTHONPATH=$PYTHONPATH:/scripts/mininet/ python2 topo.py \
                        --behavioral-exe simple_switch \
                        --json SOME_FILE \
                        --cli simple_switch_CLI&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时可以指定其他参数传递给自定义拓扑程序，方法是将它们包含在 program 定义中，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;program&quot;: &quot;source_routing.p4&quot;,
  &quot;language&quot;: &quot;p4-14&quot;,
  &quot;targets&quot;: {
      &quot;custom&quot;: {
           &quot;program&quot;: &quot;topo.py --num-hosts 2 --switch-config simple_router.config&quot;
      }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过python获取docker容器ID&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
container = os.environ['HOSTNAME']
print 'Run the switch CLI as follows:'
print '  docker exec -t -i %s %s' % (container, args.cli)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高级功能&quot;&gt;高级功能&lt;/h2&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用自定义的Docker image&lt;br/&gt;如果你热衷于研究P4工具链和P4app脚本，你可以自己构建docker镜像来代替标准的p4lang images. 只需要通过P4APP_IMAGE环境变量配置docker镜像即可. 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;P4APP_IMAGE=me/my_p4app_image:latest p4app run p4app/examples/sinmple_router.p4app&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;指定manifest文件&lt;br/&gt;默认情况下，p4app使用p4app程序包中的p4app.json的manifest文件. 如果你的manifest文件名称不是p4app，可以通过--manifest指定. 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p4app run myapp.p4app --manifest testing.json
p4app run myapp.p4app --manifest testing.p4app&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;指定log目录&lt;br/&gt;默认情况下，p4app挂载host的/tmp/p4app_logs目录到docker容器实例的/tmp/p4app_logs中. bmv2或其他任何程序输出都保存到该目录. 可通过P4APP_LOGDIR环境变量指定其他目录为log目录. 例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;P4APP_LOGDIR=./out p4app run myapp.p4app&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 12 Dec 2017 06:53:00 +0000</pubDate>
<dc:creator>SStriver</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/spjy/p/8027787.html</dc:identifier>
</item>
<item>
<title>【Flink】流-表概念 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/8027772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/8027772.html</guid>
<description>&lt;h2 id=&quot;data-streams上的关系查询&quot;&gt;Data Streams上的关系查询&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;关系型SQL&lt;/code&gt;与&lt;code&gt;stream processing&lt;/code&gt;对比如下。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;有限元组&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无限元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;完整数据集上的查询&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无法基于所有数据查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;查询会结束&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;查询不会结束&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Materialized View&lt;/strong&gt;被定义为一条SQL查询，其会缓存查询结果。但当所查询的表(基表)被修改时，缓存的结果将过期。&lt;br/&gt;&lt;strong&gt;Eager View Maintenance&lt;/strong&gt;会更新&lt;strong&gt;Materialized View&lt;/strong&gt;，当基表被更新时，会立刻更新&lt;strong&gt;Materialized View&lt;/strong&gt;中缓存的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eager View Maintenance&lt;/strong&gt;和&lt;strong&gt;SQL Query&lt;/strong&gt;在&lt;code&gt;streams&lt;/code&gt;上的关系如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库表是&lt;code&gt;INSERT、UPDATE、DELETE&lt;/code&gt;等&lt;code&gt;DML&lt;/code&gt;语句流的结果，被流称为&lt;strong&gt;changelog stream&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Materialized View&lt;/strong&gt;被定义为一条SQL查询。为更新&lt;code&gt;View&lt;/code&gt;，查询需要不断处理&lt;strong&gt;changelog stream&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Materialized View&lt;/strong&gt;是&lt;code&gt;streaming SQL&lt;/code&gt;查询结果。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;动态表-连续查询&quot;&gt;动态表 &amp;amp; 连续查询&lt;/h2&gt;
&lt;p&gt;动态表是Flink流上&lt;code&gt;Table Api &amp;amp; SQL&lt;/code&gt;的核心概念，其随时间动态变化；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询动态表会产生一个连续查询；&lt;/li&gt;
&lt;li&gt;连续查询永不停止，其会产生一个动态表；&lt;/li&gt;
&lt;li&gt;当所查询的动态表发生变化时，查询会更新结果动态表。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;连续查询的结果等同在输入表的快照上以批处理模式执行相同查询的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流、动态表、连续查询的关系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/stream-query-stream.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;stream&lt;/code&gt;会被转化为动态表。&lt;/li&gt;
&lt;li&gt;在动态表上进行连续查询，产生新的动态表。&lt;/li&gt;
&lt;li&gt;动态表会被转化为&lt;code&gt;stream&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;动态表是一个逻辑概念。 在查询执行期间动态表不一定（完全）&lt;code&gt;materialized&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为理解动态表和连续查询的概念，假设点击事件流有如下模式。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;[&lt;br/&gt;user: VARCHAR, // the name of the user&lt;br/&gt;cTime: TIMESTAMP, // the time when the URL was accessed&lt;br/&gt;url: VARCHAR // the URL that was accessed by the user&lt;br/&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;流上定义表&quot;&gt;流上定义表&lt;/h3&gt;
&lt;p&gt;为在流上使用关系查询，流需要被转化为表。流的每个记录被解释为结果表(动态表)上的&lt;code&gt;INSERT&lt;/code&gt;修改，我们从一个只有&lt;code&gt;INSERT&lt;/code&gt;的&lt;code&gt;changelog&lt;/code&gt;流中构建表。如下图所示，点击事件流被转化为表，表会随着点击事件记录的插入而不断增长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/append-mode.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;连续查询&quot;&gt;连续查询&lt;/h3&gt;
&lt;p&gt;连续查询作用于动态表并又会产生动态表；连续查询不会终止并会根据其输入表(动态表)上的更新来更新其结果表(动态表)。&lt;br/&gt;下面显示在点击事件流上定义的&lt;code&gt;clicks&lt;/code&gt;表上显示两个查询示例。&lt;/p&gt;
&lt;p&gt;首先是&lt;code&gt;GROUP-BY COUNT&lt;/code&gt;聚合查询示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/query-groupBy-cnt.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当查询开始时，&lt;code&gt;clicks&lt;/code&gt;表为空；当第一行插入到&lt;code&gt;clicks&lt;/code&gt;表中时，查询开始计算结果表(动态表)，如[Mary, ./home]插入后，结果表包含一行结果[Mary, 1]；当插入第二行[Bob, ./cart]时，查询会更新结果表并插入新记录[Bob, 1]。第三行[Mary, ./prod=id=1]插入时，查询会更新结果表中的[Mary, 1]记录，将其更新为[Mary, 2]。最后一行[Liz, 1]插入&lt;code&gt;clicks&lt;/code&gt;表后，也会更新到结果表(插入新记录)。&lt;/p&gt;
&lt;p&gt;第二个查询与第一个查询类似，除了用户属性之外，还在小时滚动窗口上对&lt;code&gt;clicks&lt;/code&gt;表进行分组，然后对URL进行计数(基于时间的计算，如窗口基于特殊的时间属性)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/query-groupBy-window-cnt.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个小时查询会计算结果并更新结果表。在&lt;code&gt;cTime&lt;/code&gt;在&lt;code&gt;12:00:00 - 12:59:59&lt;/code&gt;之间，&lt;code&gt;clicks&lt;/code&gt;表存在四条记录，对应的查询计算出两条结果；下个时间窗口(13:00:00 - 13:59:59)，&lt;code&gt;clicks&lt;/code&gt;表中存在三条记录，对应的查询计算出两条结果添加值结果表中；当记录插入至&lt;code&gt;clicks&lt;/code&gt;表中后，结果表也会被动态更新。&lt;/p&gt;
&lt;h4 id=&quot;更新和附加查询&quot;&gt;更新和附加查询&lt;/h4&gt;
&lt;p&gt;上述两个查询虽然有些类似(均计算统计聚合分组)，但两者也有显著不同：第一个查询会更新结果表的结果，如定义在结果表上的&lt;code&gt;changelog&lt;/code&gt;流包含&lt;code&gt;INSERT&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;；第二个查询仅仅往结果表中添加记录，如定义在结果表上的&lt;code&gt;changelog&lt;/code&gt;流只包含&lt;code&gt;INSERT&lt;/code&gt;。一个查询是否生成仅&lt;strong&gt;插入表&lt;/strong&gt;(&lt;code&gt;INSERT&lt;/code&gt;)或&lt;strong&gt;更新表&lt;/strong&gt;(&lt;code&gt;UPDATE&lt;/code&gt;)有一些含义:生成更新表的查询必须要维护更多状态，将仅&lt;strong&gt;插入表&lt;/strong&gt;转化为流与将&lt;strong&gt;更新表&lt;/strong&gt;转化为流不同。&lt;/p&gt;
&lt;h4 id=&quot;查询限制&quot;&gt;查询限制&lt;/h4&gt;
&lt;p&gt;很多查询可以等同在流上的连续查询，一些查询由于需维护状态的大小或计算更新代价大导致查询计算代价太大。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态大小：无界限流上的连续查询经常会运行数周或数月。因此，连续查询处理的数据总量可以很大，需要以前结果(结果表)的连续查询需要维护所有行以便进行更新。例如，第一个查询示例中需要保存每个&lt;code&gt;user&lt;/code&gt;的&lt;code&gt;url&lt;/code&gt;的&lt;code&gt;count&lt;/code&gt;以便可以增加&lt;code&gt;count&lt;/code&gt;，使得当输入表(左侧表)接收一行新数据时会产生新的结果(右侧表)。若只跟踪注册用户，那么维护&lt;code&gt;cnt&lt;/code&gt;大小代价不会太大(注册用户量不太大)。但若非注册用户也分配唯一的用户名，则随着时间的增加，维护&lt;code&gt;cnt&lt;/code&gt;大小代价将增大，最终导致查询失败。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SELECT user, COUNT(url)&lt;br/&gt;FROM clicks&lt;br/&gt;GROUP BY user;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;计算更新：即使只添加或更新单行记录，一些查询需要重新计算和更新大部分结果行，通常这样的查询不适合作为连续查询。如下查询示例中，会根据最后一次点击的时间为每个用户计算&lt;code&gt;RANK&lt;/code&gt;。一旦&lt;code&gt;clicks&lt;/code&gt;表收到新行，用户的&lt;code&gt;lastAction&lt;/code&gt;被更新并且应该计算新的&lt;code&gt;RANK&lt;/code&gt;。然而由于不存在两行相同&lt;code&gt;RANK&lt;/code&gt;，所以所有较低&lt;code&gt;RANK&lt;/code&gt;的行也需要被更新。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;SELECT user, RANK() OVER (ORDER BY lastLogin)&lt;br/&gt;FROM (&lt;br/&gt;SELECT user, MAX(cTime) AS lastAction FROM clicks GROUP BY user&lt;br/&gt;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;表到流的转化&quot;&gt;表到流的转化&lt;/h3&gt;
&lt;p&gt;动态表可像传统表一样被&lt;code&gt;INSERT、UPDATE、DELETE&lt;/code&gt;修改。可能只有一行的表被持续更新；或者是没有&lt;code&gt;UPDATE、DELETE&lt;/code&gt;更改的&lt;strong&gt;只插入表&lt;/strong&gt;。当将动态表转化为流或将其写入外部系统，这些更改(修改)需要被编码，&lt;code&gt;Flink&lt;/code&gt;的&lt;code&gt;Table API &amp;amp; SQL&lt;/code&gt;支持三种方式编码动态表上的更改(修改)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Append-only流：仅使用&lt;code&gt;INSERT更改&lt;/code&gt;进行修改的动态表可通过发出插入的行来转化为流。&lt;/li&gt;
&lt;li&gt;Retract流：&lt;code&gt;Retract流&lt;/code&gt;包含两种类型消息(&lt;code&gt;add消息和retract消息&lt;/code&gt;)，通过将动态表的&lt;code&gt;INSERT更改&lt;/code&gt;作为&lt;code&gt;add消息&lt;/code&gt;、将&lt;code&gt;DELETE更改&lt;/code&gt;作为&lt;code&gt;retract消息&lt;/code&gt;、将&lt;code&gt;UPDATE更改&lt;/code&gt;分解为旧记录的&lt;code&gt;retract消息&lt;/code&gt;和新记录的&lt;code&gt;add消息&lt;/code&gt;。下图展示了从动态表转化为&lt;code&gt;retract流&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/undo-redo-mode.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Upsert流：&lt;code&gt;Upsert流&lt;/code&gt;包含两种类型消息(&lt;code&gt;upset消息和delete消息&lt;/code&gt;)，动态表转化为&lt;code&gt;upsert流&lt;/code&gt;需要有主键(可复合)，具有主键的动态表通过将&lt;code&gt;INSERT、UPDATE更改&lt;/code&gt;编码为&lt;code&gt;upset消息&lt;/code&gt;，将&lt;code&gt;DELETE更改&lt;/code&gt;编码为&lt;code&gt;delete消息&lt;/code&gt;。&lt;code&gt;upset流&lt;/code&gt;与&lt;code&gt;retract流&lt;/code&gt;主要区别是&lt;code&gt;UPDATE更改&lt;/code&gt;使用单一消息(主键)进行编码，因此效率更高。下图展示了将&lt;code&gt;动态表&lt;/code&gt;转化为&lt;code&gt;upset流&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/fig/table-streaming/redo-mode.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;时间属性&quot;&gt;时间属性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Processing time(处理时间)&lt;/strong&gt;：表示事件被处理的系统时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event time(事件时间)&lt;/strong&gt;：表示事件发生时的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ingestion time(摄入时间)&lt;/strong&gt;：表示事件进入流处理系统的时间(在内部其与&lt;code&gt;Event time&lt;/code&gt;类型)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述时间可以在代码中指明时间特性。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; StreamExecutionEnvironment env = StreamExecutionEnvironment.&lt;span class=&quot;fu&quot;&gt;getExecutionEnvironment&lt;/span&gt;();

env.&lt;span class=&quot;fu&quot;&gt;setStreamTimeCharacteristic&lt;/span&gt;(TimeCharacteristic.&lt;span class=&quot;fu&quot;&gt;ProcessingTime&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// default&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// alternatively:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Table API &amp;amp; SQL&lt;/code&gt;中基于时间的操作（如窗口）需要设置时间概念和及其来源信息。因此，&lt;code&gt;tables&lt;/code&gt;可以提供&lt;code&gt;逻辑时间属性&lt;/code&gt;来指示时间并在&lt;code&gt;table&lt;/code&gt;程序中访问相应时间戳。时间属性可以是&lt;code&gt;表模式&lt;/code&gt;的一部分(从&lt;code&gt;DataStream&lt;/code&gt;中创建表时被定义)，或在使用&lt;code&gt;TableSource&lt;/code&gt;时被预定义，一旦时间属性被定义，那么其可以作为一个字段被引用或进行基于时间的操作。只要时间属性没有被修改，只是从查询的一部分转发到另一部分，那么它仍然是一个有效的时间属性。时间属性与常规时间戳相同，可被访问并计算。如果在计算中使用时间属性，那么其将被具象化为常规时间戳，常规时间戳不兼容&lt;code&gt;Flink&lt;/code&gt;的时间和水位系统，因此不能再用于基于时间的操作。&lt;/p&gt;
&lt;h3 id=&quot;处理时间&quot;&gt;处理时间&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;processing time&lt;/code&gt;允许&lt;strong&gt;表程序&lt;/strong&gt;基于本地机器的时间输出结果，它不需要提取时间戳和生成水位，有多种方式定义&lt;code&gt;processing time&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4 id=&quot;流转化为表过程&quot;&gt;流转化为表过程&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;processing time&lt;/code&gt;属性在模式定义时使用&lt;code&gt;.proctime&lt;/code&gt;属性定义，时间属性只能通过额外的逻辑字段扩展物理模式，因此，其可被定义在模式定义的末尾，具体如下。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
DataStream&amp;lt;Tuple2&amp;lt;String, String&amp;gt;&amp;gt; stream = ...;

&lt;span class=&quot;co&quot;&gt;// declare an additional logical field as a processing time attribute&lt;/span&gt;
Table table = tEnv.&lt;span class=&quot;fu&quot;&gt;fromDataStream&lt;/span&gt;(stream, &lt;span class=&quot;st&quot;&gt;&quot;Username, Data, UserActionTime.proctime&quot;&lt;/span&gt;);

WindowedTable windowedTable = table.&lt;span class=&quot;fu&quot;&gt;window&lt;/span&gt;(Tumble.&lt;span class=&quot;fu&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;10.minutes&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;as&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userActionWindow&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;使用tablesource&quot;&gt;使用TableSource&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;processing time&lt;/code&gt;属性可通过实现&lt;code&gt;DefinedProctimeAttribute&lt;/code&gt;接口定义，逻辑时间属性被附加到由&lt;code&gt;TableSource&lt;/code&gt;的返回类型定义的物理模式上。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// define a table source with a processing attribute&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserActionSource &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; StreamTableSource&amp;lt;Row&amp;gt;, DefinedProctimeAttribute {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TypeInformation&amp;lt;Row&amp;gt; &lt;span class=&quot;fu&quot;&gt;getReturnType&lt;/span&gt;() {
        String[] names = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[] {&lt;span class=&quot;st&quot;&gt;&quot;Username&quot;&lt;/span&gt; , &lt;span class=&quot;st&quot;&gt;&quot;Data&quot;&lt;/span&gt;};
        TypeInformation[] types = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TypeInformation[] {Types.&lt;span class=&quot;fu&quot;&gt;STRING&lt;/span&gt;(), Types.&lt;span class=&quot;fu&quot;&gt;STRING&lt;/span&gt;()};
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Types.&lt;span class=&quot;fu&quot;&gt;ROW&lt;/span&gt;(names, types);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataStream&amp;lt;Row&amp;gt; &lt;span class=&quot;fu&quot;&gt;getDataStream&lt;/span&gt;(StreamExecutionEnvironment execEnv) {
        &lt;span class=&quot;co&quot;&gt;// create stream &lt;/span&gt;
        DataStream&amp;lt;Row&amp;gt; stream = ...;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getProctimeAttribute&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// field with this name will be appended as a third field &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;;
    }
}

&lt;span class=&quot;co&quot;&gt;// register table source&lt;/span&gt;
tEnv.&lt;span class=&quot;fu&quot;&gt;registerTableSource&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActions&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserActionSource&lt;/span&gt;());

WindowedTable windowedTable = tEnv
    .&lt;span class=&quot;fu&quot;&gt;scan&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActions&quot;&lt;/span&gt;)
    .&lt;span class=&quot;fu&quot;&gt;window&lt;/span&gt;(Tumble.&lt;span class=&quot;fu&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;10.minutes&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;as&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userActionWindow&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;事件时间&quot;&gt;事件时间&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Event time&lt;/code&gt;允许&lt;strong&gt;表程序&lt;/strong&gt;根据每条记录中包含的时间输出结果，这样即使在无序事件或晚到事件情况下保持一致结果，当从持久化存储中读取记录时还保证可重放结果。此外，&lt;code&gt;event time&lt;/code&gt;允许批和流环境中的&lt;strong&gt;表程序&lt;/strong&gt;使用统一的语法，流环境中的时间属性可以是批环境中的记录的字段。为处理乱序事件，并区分流中准时和晚到事件，&lt;code&gt;Flink&lt;/code&gt;需要从事件中提取时间戳信息，并在时间戳上进行处理(水位)。&lt;code&gt;event time&lt;/code&gt;属性可被定义在&lt;strong&gt;流到表的转化中&lt;/strong&gt;或者使用&lt;strong&gt;TableSource&lt;/strong&gt;。&lt;code&gt;Table API &amp;amp; SQL&lt;/code&gt;假设在上述两种情况下，都在&lt;code&gt;DataStream API&lt;/code&gt;中生成时间戳和水位。&lt;/p&gt;
&lt;h4 id=&quot;流转化为表的过程中&quot;&gt;流转化为表的过程中&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;event time&lt;/code&gt;属性在模式定义时通过&lt;code&gt;.rowtime&lt;/code&gt;属性定义；时间戳和水位必须在转换的DataStream中已被分配；将&lt;code&gt;DataStream&lt;/code&gt;转化为&lt;code&gt;Table&lt;/code&gt;时有如下两种定义时间属性的方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过附加逻辑字段扩展物理表模式。&lt;/li&gt;
&lt;li&gt;用逻辑字段替换物理字段(如提取时间戳后不再需要)。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// Option 1:&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// extract timestamp and assign watermarks based on knowledge of the stream&lt;/span&gt;
DataStream&amp;lt;Tuple2&amp;lt;String, String&amp;gt;&amp;gt; stream = inputStream.&lt;span class=&quot;fu&quot;&gt;assignTimestampsAndWatermarks&lt;/span&gt;(...);

&lt;span class=&quot;co&quot;&gt;// declare an additional logical field as an event time attribute&lt;/span&gt;
Table table = tEnv.&lt;span class=&quot;fu&quot;&gt;fromDataStream&lt;/span&gt;(stream, &lt;span class=&quot;st&quot;&gt;&quot;Username, Data, UserActionTime.rowtime&quot;&lt;/span&gt;);


&lt;span class=&quot;co&quot;&gt;// Option 2:&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// extract timestamp from first field, and assign watermarks based on knowledge of the stream&lt;/span&gt;
DataStream&amp;lt;Tuple3&amp;lt;Long, String, String&amp;gt;&amp;gt; stream = inputStream.&lt;span class=&quot;fu&quot;&gt;assignTimestampsAndWatermarks&lt;/span&gt;(...);

&lt;span class=&quot;co&quot;&gt;// the first field has been used for timestamp extraction, and is no longer necessary&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// replace first field with a logical event time attribute&lt;/span&gt;
Table table = tEnv.&lt;span class=&quot;fu&quot;&gt;fromDataStream&lt;/span&gt;(stream, &lt;span class=&quot;st&quot;&gt;&quot;UserActionTime.rowtime, Username, Data&quot;&lt;/span&gt;);

&lt;span class=&quot;co&quot;&gt;// Usage:&lt;/span&gt;

WindowedTable windowedTable = table.&lt;span class=&quot;fu&quot;&gt;window&lt;/span&gt;(Tumble.&lt;span class=&quot;fu&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;10.minutes&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;as&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userActionWindow&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;使用tablesource-1&quot;&gt;使用TableSource&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;event time&lt;/code&gt;属性可通过实现&lt;code&gt;DefinedRowtimeAttribute&lt;/code&gt;接口定义，逻辑时间属性被附加到由&lt;code&gt;TableSource&lt;/code&gt;的返回类型定义的物理模式上。时间戳和水位一定要在&lt;code&gt;getDataStream&lt;/code&gt;方法返回的流中被分配。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// define a table source with a rowtime attribute&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserActionSource &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; StreamTableSource&amp;lt;Row&amp;gt;, DefinedRowtimeAttribute {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TypeInformation&amp;lt;Row&amp;gt; &lt;span class=&quot;fu&quot;&gt;getReturnType&lt;/span&gt;() {
        String[] names = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[] {&lt;span class=&quot;st&quot;&gt;&quot;Username&quot;&lt;/span&gt; , &lt;span class=&quot;st&quot;&gt;&quot;Data&quot;&lt;/span&gt;};
        TypeInformation[] types = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TypeInformation[] {Types.&lt;span class=&quot;fu&quot;&gt;STRING&lt;/span&gt;(), Types.&lt;span class=&quot;fu&quot;&gt;STRING&lt;/span&gt;()};
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Types.&lt;span class=&quot;fu&quot;&gt;ROW&lt;/span&gt;(names, types);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataStream&amp;lt;Row&amp;gt; &lt;span class=&quot;fu&quot;&gt;getDataStream&lt;/span&gt;(StreamExecutionEnvironment execEnv) {
        &lt;span class=&quot;co&quot;&gt;// create stream &lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// extract timestamp and assign watermarks based on knowledge of the stream&lt;/span&gt;
        DataStream&amp;lt;Row&amp;gt; stream = inputStream.&lt;span class=&quot;fu&quot;&gt;assignTimestampsAndWatermarks&lt;/span&gt;(...);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stream;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getRowtimeAttribute&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// field with this name will be appended as a third field &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;;
    }
}

&lt;span class=&quot;co&quot;&gt;// register the table source&lt;/span&gt;
tEnv.&lt;span class=&quot;fu&quot;&gt;registerTableSource&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActions&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserActionSource&lt;/span&gt;());

WindowedTable windowedTable = tEnv
    .&lt;span class=&quot;fu&quot;&gt;scan&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActions&quot;&lt;/span&gt;)
    .&lt;span class=&quot;fu&quot;&gt;window&lt;/span&gt;(Tumble.&lt;span class=&quot;fu&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;10.minutes&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UserActionTime&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;as&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userActionWindow&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;查询配置&quot;&gt;查询配置&lt;/h2&gt;
&lt;p&gt;不管输入是有界批量输入还是无界流输入，&lt;code&gt;Table API &amp;amp; SQL&lt;/code&gt;查询都有相同的语义。在很多情况下，流上的连续查询与离线计算具有相同准确的结果。然而，在实际情况下连续查询必须要限制其所维护状态的大小以避免使用完存储空间，并能够在长时间处理无限流数据。因此，连续查询可能只能根据输入数据的特征和查询本身提供近似准确的结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flink Table API &amp;amp; SQL&lt;/code&gt;接口提供参数调整连续查询的准确性和资源消耗。参数通过&lt;code&gt;QueryConfig&lt;/code&gt;对象定义，&lt;code&gt;QueryConfig&lt;/code&gt;对象可通过&lt;code&gt;TableEnvironment&lt;/code&gt;获取并在翻译表时被传回。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
StreamExecutionEnvironment env = StreamExecutionEnvironment.&lt;span class=&quot;fu&quot;&gt;getExecutionEnvironment&lt;/span&gt;();
StreamTableEnvironment tableEnv = TableEnvironment.&lt;span class=&quot;fu&quot;&gt;getTableEnvironment&lt;/span&gt;(env);

&lt;span class=&quot;co&quot;&gt;// obtain query configuration from TableEnvironment&lt;/span&gt;
StreamQueryConfig qConfig = tableEnv.&lt;span class=&quot;fu&quot;&gt;queryConfig&lt;/span&gt;();
&lt;span class=&quot;co&quot;&gt;// set query parameters&lt;/span&gt;
qConfig.&lt;span class=&quot;fu&quot;&gt;withIdleStateRetentionTime&lt;/span&gt;(Time.&lt;span class=&quot;fu&quot;&gt;hours&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;));

&lt;span class=&quot;co&quot;&gt;// define query&lt;/span&gt;
Table result = ...

&lt;span class=&quot;co&quot;&gt;// create TableSink&lt;/span&gt;
TableSink&amp;lt;Row&amp;gt; sink = ...

&lt;span class=&quot;co&quot;&gt;// emit result Table via a TableSink&lt;/span&gt;
result.&lt;span class=&quot;fu&quot;&gt;writeToSink&lt;/span&gt;(sink, qConfig);

&lt;span class=&quot;co&quot;&gt;// convert result Table into a DataStream&amp;lt;Row&amp;gt;&lt;/span&gt;
DataStream&amp;lt;Row&amp;gt; stream = tableEnv.&lt;span class=&quot;fu&quot;&gt;toAppendStream&lt;/span&gt;(result, Row.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, qConfig);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面描述了&lt;code&gt;QueryConfig&lt;/code&gt;的参数如何影响查询的准确性和资源消耗的。&lt;/p&gt;
&lt;h3 id=&quot;空闲状态保留时间&quot;&gt;空闲状态保留时间&lt;/h3&gt;
&lt;p&gt;很多查询在一个或多个关键属性上聚合或连接记录(如典型的聚合查询)，当在流上执行该查询时，连续查询需要维护记录或保持每个键的部分结果。若涉及到流的关键域(活动键值随时间会变化)，随着不同键被观察，连续查询会积累越来越多的状态。然而，在一段时间后键将变得不活动时，它们的对应状态将变得过期和无效。如下查询示例中计算每个&lt;code&gt;session&lt;/code&gt;的&lt;code&gt;clicks&lt;/code&gt;数量。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SELECT sessionId, COUNT(*) FROM clicks GROUP BY sessionId;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;sessionId&lt;/code&gt;被作为分组键，连续查询会为每个&lt;code&gt;sessionId&lt;/code&gt;维护&lt;code&gt;clicks&lt;/code&gt;数量。&lt;code&gt;sessionId&lt;/code&gt;属性随着时间推移而变化，&lt;code&gt;sessionId&lt;/code&gt;值仅在&lt;code&gt;session&lt;/code&gt;结束前处于活动状态(保持一段时间)。然而，由于不清楚&lt;code&gt;sessionId&lt;/code&gt;属性，连续查询期望每个&lt;code&gt;sessionId&lt;/code&gt;值在任何时间都有效，即会维护所有&lt;code&gt;sessionId&lt;/code&gt;的值。这样会导致随着时间的推移，所维护的&lt;code&gt;sessionId&lt;/code&gt;越来越多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空闲状态保留时间&lt;/strong&gt;参数定义键的状态不被更新，在删除之前保留多长时间。在上述查询中，&lt;code&gt;sessionId&lt;/code&gt;的计数在指定的配置时间内未被更新时将被移除。当键会移除后再次被添加，那么键将会被当成新的键(如上述示例中又会开始计0)。有两个参数配置&lt;strong&gt;空闲状态保留时间&lt;/strong&gt;，&lt;strong&gt;最小空闲状态保留时间&lt;/strong&gt;和&lt;strong&gt;最大空闲状态保留时间&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
StreamQueryConfig qConfig = ...

&lt;span class=&quot;co&quot;&gt;// set idle state retention time: min = 12 hour, max = 16 hours&lt;/span&gt;
qConfig.&lt;span class=&quot;fu&quot;&gt;withIdleStateRetentionTime&lt;/span&gt;(Time.&lt;span class=&quot;fu&quot;&gt;hours&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;), Time.&lt;span class=&quot;fu&quot;&gt;hours&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;));
&lt;span class=&quot;co&quot;&gt;// set idle state retention time. min = max = 12 hours&lt;/span&gt;
qConfig.&lt;span class=&quot;fu&quot;&gt;withIdleStateRetentionTime&lt;/span&gt;(Time.&lt;span class=&quot;fu&quot;&gt;hours&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置不同的最小和最大空闲状态保留时间的效率更高，因为它减少了查询内部簿记何时删除状态的次数。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.3/dev/table/streaming.html&quot; class=&quot;uri&quot;&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.3/dev/table/streaming.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Dec 2017 06:52:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leesf456/p/8027772.html</dc:identifier>
</item>
<item>
<title>个人代码规范分享 - 小小沧海</title>
<link>http://www.cnblogs.com/xxcanghai/p/8027711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxcanghai/p/8027711.html</guid>
<description>&lt;p&gt;本文总结了下我在前端开发过程中编写JavaScript的一些习惯的代码规范，以前端开发背景为主，但有些规则也适用其他语言。同时此规范并不绝对，仅供参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;变量长度：&lt;/strong&gt;&lt;br/&gt;变量名不要太长，尽量不超过5个单词，每个单词尽量使用缩写，缩写尽量不超过5个字母&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量缩写：&lt;/strong&gt;&lt;br/&gt;变量缩写可以采用两种缩写方案：&lt;/p&gt;
&lt;p&gt;1.使用单词前几个字母，能表述含义即可，控制在3-5个字母。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;医院：hosp
医生：doc
选项：opt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.若页面内同时出现“文档”和“医生”那么doc会冲突，可以适当增加长度或变换单词来区分。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;文档：docs
医生：doct&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.使用单词的重音字母，使人能看到字母联想到单词。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;产品：pdt
配置：cfg
检查：chk&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数命名&quot;&gt;函数命名&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;操作类函数：&lt;/strong&gt;&lt;br/&gt;一般使用动词，配合各类形容词，大致如下：&lt;br/&gt;1.纯动词。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;save()
delete()
close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.动词+名词。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;保存医生：saveDoc()
删除医院：delHosp()
创建产品：createPdt()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.动词+形容词+名词。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;删除选中的医生：delSelectDoc()
追加一个临时医院：appendTempHosp()
保存所有产品：saveAllPdt()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取数据类函数：&lt;/strong&gt;&lt;br/&gt;统一使用&lt;code&gt;get&lt;/code&gt;开头。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getDocList()
getDisablePdt()
getElementById(id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;从网络获取数据类函数：&lt;/strong&gt;&lt;br/&gt;统一使用&lt;code&gt;load&lt;/code&gt;开头。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;获取省份数据：loadProvince()
根据省份ID获取市区数据：loadCityByProvinceId(pid)
根据市区ID获取县数据：loadCountyByCityId(cid)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;load与get的区别个人认为在于，get更通用，可以用于代码内部的数据处理逻辑，load更倾向于从远程加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件响应函数：&lt;/strong&gt;&lt;br/&gt;on+(动词/操作)+元素+事件名。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;点击保存按钮：onSaveBtnClick()
点击添加按钮：onAddBtnClick()
当是否可用复选框变更时：onIsEnableChkChange()
头像图片鼠标移入时：onHeaderImgMouseEnter()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以是on+元素+(动词/操作/用途)+事件名。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onBtnSaveClick()
onChkIsEnableChange()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看个人习惯即可。&lt;/p&gt;
&lt;p&gt;虽然看上去略繁琐，但通过函数名本身，就可以完整的定位到此函数的用途。例如&lt;code&gt;onIsEnableChkChange&lt;/code&gt;函数名：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;看到&lt;code&gt;on&lt;/code&gt;开头，知道这是一个响应界面操作事件的函数&lt;/li&gt;
&lt;li&gt;看到&lt;code&gt;isEnable&lt;/code&gt;，知道这是“是否可用”的功能的元素。&lt;/li&gt;
&lt;li&gt;看到&lt;code&gt;chk&lt;/code&gt;，知道这是一个复选框&lt;code&gt;checkbox&lt;/code&gt;元素的事件&lt;/li&gt;
&lt;li&gt;看到末尾的&lt;code&gt;Change&lt;/code&gt;，知道这是一个&lt;code&gt;change&lt;/code&gt;事件的响应函数&lt;/li&gt;
&lt;li&gt;综上，看到命名，就可以联想到网页上有一个 名叫xxx是否可用的复选框，这是点击了这个复选框后的事件&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;变量命名&quot;&gt;变量命名&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;变量单词连接符：&lt;/strong&gt;&lt;br/&gt;不使用单词连接符，使用小驼峰式命名。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;btnSaveClick&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;布尔值类型变量：&lt;/strong&gt;&lt;br/&gt;统一使用is开头。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;是否可用：isEnable
是否选中：isCheck
是否删除：isDelete&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;集合类型变量：&lt;/strong&gt;&lt;br/&gt;统一使用List结尾。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;食品列表：foodList
医生列表：docList
已选产品列表：selectPdtList&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数组循环体内临时变量：&lt;/strong&gt;&lt;br/&gt;若循环体代码量少，或仅一行lambda表达式，则可简写 &lt;code&gt;doc&lt;/code&gt;或&lt;code&gt;d&lt;/code&gt;, &lt;code&gt;pdt&lt;/code&gt;或&lt;code&gt;p&lt;/code&gt;&lt;br/&gt;循环体代码量大时，或嵌套循环时，尽量使用&lt;code&gt;Item&lt;/code&gt;结尾。如&lt;code&gt;docItem&lt;/code&gt;, &lt;code&gt;pdtItem&lt;/code&gt;&lt;br/&gt;不强制要求，仅为区分层级关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典变量：&lt;/strong&gt;&lt;br/&gt;统一使用&lt;code&gt;Dic&lt;/code&gt;（Dictionary）结尾，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openWithDic
exeDumpDic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;枚举集合：&lt;/strong&gt;&lt;br/&gt;统一使用&lt;code&gt;Enum&lt;/code&gt;（Enumeration）结尾。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;医生类型枚举：docTypeEnum
产品状态枚举：pdtStatusEnum
服务器状态码枚举：serverCodeEnum&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;枚举项：&lt;/strong&gt;&lt;br/&gt;建议使用全大写，使用下划线连接单词，与常量规则一致。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;服务器返回值失败：serverCodeEnum.ERROR
服务器返回值成功：serverCodeEnum.SUCCESS &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jQuery变量：&lt;/strong&gt;&lt;br/&gt;建议使用&lt;code&gt;$&lt;/code&gt;开头，或&lt;code&gt;J_&lt;/code&gt;开头，风格统一即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$saveBtn
J_saveBtn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;函数变量：&lt;/strong&gt;&lt;br/&gt;建议使用&lt;code&gt;Fn&lt;/code&gt;或&lt;code&gt;Cb&lt;/code&gt;结尾，标明此变量为函数指针。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;钩子函数：hookFn
响应回调函数：responseCb
回调函数：callback&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常量：&lt;/strong&gt;&lt;br/&gt;统一使用全大写字母，单词用下划线连接。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MAX_SIZE
TIME_OUT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类（Class）构造函数：&lt;/strong&gt;&lt;br/&gt;统一使用大驼峰式命名。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ListView
DataTable
TableView&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类私有属性：&lt;/strong&gt;&lt;br/&gt;如果未使用&lt;code&gt;TypeScript&lt;/code&gt;或其他强类型语言，即若没有使用带有访问修饰符（&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;private&lt;/code&gt;等）的语言开发，应该通过变量名本身即可区分是私有属性还是公开属性。&lt;br/&gt;&lt;strong&gt;私有属性以及私有函数，应统一以下划线开头。如&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_data
_pdtList
_getData()
_setData()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目的在于给与类的使用者可以通过变量区分，哪些是可以使用的公开属性和方法，哪些不应该使用的私有属性以及不应该调用的私有方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件事件命名：&lt;/strong&gt;&lt;br/&gt;1.统一使用on开头。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onClick(e)
onSubmit(e)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.关键流程类事件，应提供after事件和before事件，以onBefore和onAfter开头。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;准备提交前事件：onBeforeSubmit
提交后事件：onAfterSubmit
准备展开前事件：onBeforeExpand
删除后事件：onAfterDel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.属性/状态变更类事件，应以on开头，changed结尾。如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;check属性变更时事件：onCheckedChange
select属性变更时事件：onSelectedChange
产品状态变更时事件：onPdtStatusChange&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;善用变量缓存&lt;/li&gt;
&lt;li&gt;重复使用多次的字符串必须缓存&lt;/li&gt;
&lt;li&gt;善用枚举变量，减少后期维护成本&lt;/li&gt;
&lt;li&gt;类方法应全部挂载到原型对象&lt;/li&gt;
&lt;li&gt;不应该使用类私有全局变量，应使用类静态变量&lt;/li&gt;
&lt;li&gt;尽量减少闭包代码，以减少可能会出现的问题的概率&lt;/li&gt;
&lt;li&gt;应坚持“先定义，后使用”的规范。以减少js默认的定义提升的坑&lt;/li&gt;
&lt;li&gt;整个代码应该应只有一个入口函数，即创建一个init函数，来执行所有初始代码，而不是整篇代码随定义，随执行&lt;/li&gt;
&lt;li&gt;事件绑定类函数应放在同一处执行，减少维护成本&lt;/li&gt;
&lt;li&gt;善用#region 创建代码块，不同功能的代码归类，初始化类，事件绑定类，界面交互类，纯数据处理工具类等。&lt;/li&gt;
&lt;li&gt;模块类文件，所有导出变量应全部定义在尾部。方便查阅&lt;/li&gt;
&lt;li&gt;尽可能不创建全局变量，不注册全局事件，为后期方便转型为单页应用&lt;/li&gt;
&lt;li&gt;尽量将代码纯数据逻辑与界面交互逻辑分开，方便后期写测试用例&lt;/li&gt;
&lt;li&gt;尽量将所有变更定义放置在 文件/函数 内顶部&lt;/li&gt;
&lt;li&gt;善用try catch和throw Error&lt;/li&gt;
&lt;li&gt;不要在数组内存放不同类型的数据，一个数组应只存放一种数据类型变量，方便强类型识别与纠错&lt;/li&gt;
&lt;li&gt;尽可能不要创建类数组变量&lt;/li&gt;
&lt;li&gt;尽可能不使用eval、with&lt;/li&gt;
&lt;li&gt;多写注释！推荐jsdoc风格注释，方便一键抽取注释生成代码文档&lt;/li&gt;
&lt;li&gt;推荐使用flowjs或ts等类型描述语言来约束、规范、纠错和智能感知。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上个人经验在组内分享时，有同学提出疑问：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么会有字典变量，以及枚举变量，这从本质上不都是Object对象么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于这个问题我是这么理解的，在js中确实对象是最强大的，任何在其他语言当中的&lt;strong&gt;类似对象&lt;/strong&gt;的数据结构，在js里都可以是对象。但也正因为如此宽泛，让我们的使用过程中会产生一些疑惑或误解，才需要对各种的对象做分类。&lt;br/&gt;所以回过头来再说&lt;strong&gt;对象&lt;/strong&gt;，&lt;strong&gt;字典&lt;/strong&gt;与&lt;strong&gt;枚举&lt;/strong&gt;的关系。&lt;/p&gt;
&lt;p&gt;他们的相同点：&lt;br/&gt;他们都是键值对集合（KeyValuePair）&lt;br/&gt;他们的Key都不能重复&lt;/p&gt;
&lt;p&gt;他们的不同点：&lt;br/&gt;&lt;strong&gt;对象：&lt;/strong&gt;&lt;br/&gt;对象的的Key可以是字符串类型或数值类型。如果同时包含这两种就&lt;strong&gt;类数组对象&lt;/strong&gt;，比如document.getElementBy...系列函数的返回值：&lt;code&gt;HTMLCollection&lt;/code&gt;，再比如HTML元素的子元素集合：&lt;code&gt;NodeList&lt;/code&gt;，以及HTML元素的属性值：&lt;code&gt;NamedNodeMap&lt;/code&gt;，等都是类数组对象。&lt;br/&gt;对象的Value的类型，可以是任意类型。而且是在一个对象变量中的Value都可以是任意类型，如JSON对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典：&lt;/strong&gt;&lt;br/&gt;而字典的Key一定是字符串类型的（其他语言中不是，受限于js语言），字典的Value也可以任意类型，&lt;strong&gt;但在一个字典对象变量中的所有Value一定是相同类型&lt;/strong&gt;，也就是说字典其实是个&lt;code&gt;Object&amp;lt;string, TValue&amp;gt;&lt;/code&gt;。&lt;br/&gt;例：比如前面刚刚提到的HTML元素的attributes属性值：&lt;code&gt;NamedNodeMap&lt;/code&gt;，就是&lt;strong&gt;应该&lt;/strong&gt;一个典型的字典对象：它属于&lt;code&gt;Dictionary&amp;lt;string, Attr&amp;gt;&lt;/code&gt;。&lt;br/&gt;但是奇葩的是&lt;code&gt;NamedNodeMap&lt;/code&gt;也支持数组下标式访问，所以它同时也是一个&lt;code&gt;List&amp;lt;Attr&amp;gt;&lt;/code&gt;，在js里只能归结于他是类数组对象的范畴内了。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/746158/201712/746158-20171212144406160-1504274585.jpg&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;枚举：&lt;/strong&gt;&lt;br/&gt;而最后的枚举对象的范围会更小，枚举的值一般为基本数据类型，在其他语言中甚至只能是数值类型。&lt;br/&gt;例如，定义一个枚举对象用于一组常量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 服务器接口返回值状态码枚举
var serverCodeEnum = {
    SUCCESS : 0,
    ERROR : 1,
    XXXXX : 2,
    XXXXX : 3,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;typescript中的枚举变量&quot;&gt;TypeScript中的枚举变量&lt;/h3&gt;
&lt;p&gt;在TypeScript为了照顾js语言的日常使用，把enum关键字的编译后代码做成了双向访问的类数组对象。&lt;br/&gt;也就是既可以用过名称获得数值，也可以通过数值获得名称。使用非常方便：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;【TypeScript代码中的枚举】
&lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; ownerTypeEnum &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

【编译为JS后的代码】
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ownerTypeEnum&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (ownerTypeEnum) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ownerTypeEnum[ownerTypeEnum[&lt;span class=&quot;st&quot;&gt;&quot;public&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;public&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    ownerTypeEnum[ownerTypeEnum[&lt;span class=&quot;st&quot;&gt;&quot;private&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;private&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)(ownerTypeEnum &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; (ownerTypeEnum &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 效果：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// ownerTypeEnum.private -&amp;gt; 1&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// ownerTypeEnum[1] -&amp;gt; &quot;private&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此类文字非常容易引战，所以再次声明以上仅个人习惯以及经验的分享，每个人都有自己的习惯，不管采用哪种习惯其实都可以。至少应该在组内，或是某项目内的所有成员都采用相同的一套规范，做到见名知意。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Dec 2017 06:44:00 +0000</pubDate>
<dc:creator>小小沧海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxcanghai/p/8027711.html</dc:identifier>
</item>
<item>
<title>移动端H5制作安卓和IOS的坑 持续更新... - zhangzhongjie</title>
<link>http://www.cnblogs.com/zjzhang/p/8027703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjzhang/p/8027703.html</guid>
<description>&lt;h2 id=&quot;移动端h5制作安卓和ios的坑-持续更新...&quot;&gt;移动端H5制作安卓和IOS的坑 持续更新...&lt;/h2&gt;
&lt;p&gt;前言：最近参加公司的H5页面创意竞赛，又遇到不少页面在不同系统上的坑。踩坑之余，觉得很多之前遇到的知识点都忘了，索性开一篇博文，把这些坑都统一归纳起来，持续收集更新，于己利人，抛砖引玉。&lt;/p&gt;
&lt;h4 id=&quot;ios系统手机无法自动播放bgm&quot;&gt;1. ios系统手机无法自动播放BGM&lt;/h4&gt;
&lt;p&gt;这个是苹果系统限制，默认不允许自动播放音频，往往需要点一下触发play()事件才能播放。&lt;br/&gt;那么我们在页面onload后触发播放事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.getElementById('music').play();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里一般都可以播放音乐了，如果还不行，很有可能是微信的限制。这时需要调用微信接口。&lt;br/&gt;页面先引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后JS写入微信事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function() {
    document.getElementById('music').play();
  }, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样利用微信接口调用play()事件，可以完美解决ios音频无法autoplay的问题。&lt;/p&gt;
&lt;h4 id=&quot;ios系统摇一摇播放音效事件无效&quot;&gt;2. ios系统摇一摇播放音效事件无效&lt;/h4&gt;
&lt;p&gt;在实现摇晃（引用了封装好的shake.js）手机触发某一音效这个需求时，发现在微信中，音效没有被触发。后面找到原因：在ios里并没有把自定义摇晃事件shake当成交互动作。而要播放音效，需要用户有交互动作。没有交互，音效就没被加载，那么我们先加载音效，结合上面的微信接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {
  shakeMusic.load();
}, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;load()&lt;/em&gt;过之后，再调用play()即可听到音效。&lt;/p&gt;
&lt;h4 id=&quot;ios系统不支持动画暂停样式animation-play-state&quot;&gt;3. ios系统不支持动画暂停样式（&lt;em&gt;animation-play-state&lt;/em&gt;）&lt;/h4&gt;
&lt;p&gt;H5页面一般都会有BGM，也会提供一个旋转的音乐图标供用户开启关闭音乐。我们希望当用户点击音乐按钮时图标停止旋转，再点图标顺着之前停止的位置继续跑动画。&lt;em&gt;animation-play-state&lt;/em&gt;是最简便的方式，然而，ios不支持。&lt;/p&gt;
&lt;p&gt;目前的解决方案是：音乐图标负责跑动画，图标父级元素负责记录停止时的转动值。&lt;/p&gt;
&lt;h4 id=&quot;html&quot;&gt;html&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;music&quot;&amp;gt;
    &amp;lt;img class=&quot;musicImg&quot; src=&quot;/images/music.png&quot;&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sass&quot;&gt;sass&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;.music {
  position: absolute;
  width: rem(64px);
  height: rem(64px);
  top: rem(66px);
  left: rem(15px);
  z-index: 1000;

  img {
    width: 100%;
  }
}

.musicRun {
  -webkit-animation: music 2.5s infinite linear 0.5s;
  animation: music 2.5s infinite linear 0.5s;
}

@-webkit-keyframes music {
  0% {}
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes music {
  0% {}
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;js&quot;&gt;JS&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;var $img = $('.musicImg')
  var music = document.getElementById('music');
  var isPlaying = false
  running()
  $img.on('click', function() {
    !isPlaying ? running() : paused()
})

  function running() {
    music.play();
    $img.addClass('musicRun')
    isPlaying = true
  }

  function paused() {
    music.pause();
    var siteImg = $img.css('transform') //获取当前元素的动画改变，transform的值
    var siteWp = $('.music').css('transform')
    $('.music').css('transform', siteWp === 'none' ? siteImg : siteImg.concat('', siteWp))
    //由于父元素没有动画，所以每次赋值的时候，需要将上次父元素的状态加上
    $img.removeClass('musicRun')
    isPlaying = false
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;安卓微信打开页面时动画静止&quot;&gt;4.安卓微信打开页面时动画静止&lt;/h4&gt;
&lt;p&gt;H5页面动画很重要。当我布好了动画样式，用安卓微信打开发现页面静止不动，动画没有生效。新进入页面没效果，刷新一下就恢复。&lt;/p&gt;
&lt;p&gt;最直接了当的解决方案：把动画提取出来，例如提到一个&lt;em&gt;running&lt;/em&gt;样式中，然后在页面load完了再把这个 动画值赋上去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;window.onload = function() {
  $('.index').addClass('running')
};&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Dec 2017 06:43:00 +0000</pubDate>
<dc:creator>zhangzhongjie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjzhang/p/8027703.html</dc:identifier>
</item>
</channel>
</rss>