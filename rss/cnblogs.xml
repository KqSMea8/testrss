<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[程序员的业余生活]一周读完《高效能人士的七个习惯》Day1:这是不是一碗鸡汤？ - xiaoyang_</title>
<link>http://www.cnblogs.com/xyang/p/10044565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyang/p/10044565.html</guid>
<description>&lt;p&gt;　　今天突然想聊聊最近对职场的一些感悟。&lt;/p&gt;

&lt;p&gt;  　 这段时间，小端一直在思考一个问题：作为一个程序员，怎么才能成为团队的核心？&lt;/p&gt;

&lt;p&gt;　　还记得刚入职场那几年，小端一直觉得，技术过硬，经验丰富，敢打敢拼，就是答案。并且也一直践行着这个认知，不断的学习新技术，巩固老知识。可是多年后回过头看下，惊讶的发现，新技术更新迭代的速度能让人发狂，老知识也逐渐成了海量，并且一旦一段时间不用，就仿佛自己曾经只是在梦里见过有没有。为什么？难道那些“核心们”，真的就有一颗最强大脑？似乎并不是那么回事。&lt;/p&gt;

&lt;p&gt;　　有了疑问，就要调查研究，就要深度思考。小端拒绝做一个蒙头狂奔的莽夫。&lt;/p&gt;

&lt;p&gt;　　通过与“核心”接触过程中的观察和感受逐渐发现，限制了自己高度的，是自己的认知。是自己把自己局限于一个很窄的领域，这就好比：我只要上了好大学就一定有个好工作。本是不相关、或者若相关的两件事，硬扯到一起，建立了因果关系。那么结果可想而知，当从因出发，无法收获果时，那种失落与无奈，其言难表。&lt;/p&gt;


&lt;p&gt;　　那么真正限制我们称为“核心”的到底是什么呢？&lt;/p&gt;

&lt;p&gt;　　首先我们得明白，在职场中，公司对员工的要求是什么？&lt;/p&gt;

&lt;p&gt;　　是员工技术过硬？经验丰富？敢打敢拼？显然不是这些，说的直白一点，这都是我们自己对自己的要求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　公司要求的，其实很简单，是能成事。是人效最大化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　而个人的自我要求，都是在匹配公司要求过程中产生的附加值。且这些附加值累加在一起，远小于能成事这个要求。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　那么问题来了，我们到底该具备什么能力，才能无限接近这个要求呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　综合素质&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这是一个非常大的概念，也是一个务虚的概念。但是一旦想明白了，实践了，收获绝不是看一本大部头技术书能比拟的（声明一点：我不排斥极客精神，相反，我认为如果两者兼得是最完美的。虽然做起来很难）。&lt;/p&gt;


&lt;p&gt; 　　 嗯...进入正题，接下来将花费几天的时间，和大家分享我通过读《高效能人士的七个习惯》后的对上述问题一些思考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uad5licdKKXwXbSSF7DiatkCgScRI4AadzXP0r3icibuNyWUFPXWkbQLPz5Wg0MZ8FSPUCkY4O3qWjD0e1Whlb2X1A/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1.1864406779661016&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                （这不是一个广告）&lt;/p&gt;
&lt;p&gt;　　在很多年前我就知道这本书，但是因为这个名字，我就一直很排斥。这还要追忆到早年间小端的一段奇葩经历：在很多年前，在朋友的案头看到有很多成功励志类的书，抱着好奇的心态翻了翻，发现内容真的很糙，套路就是先列几条作者自己都不相信的人生律条，然后就是反反复复的举一些干巴巴的例子，什么小王&amp;amp;#￥@……，老张！@#￥￥，严重缺乏逻辑性，纯粹是为了说明一个道理编的低劣小故事，后来了解到其实国内有那么一个出版行业，就是一堆编辑，利用网络，东拉西凑一堆内容，然后就成功占有了各大书店最显眼的位置。谁让这个社会都喜欢成功学呢。这种成功学版物，真是一碗难喝的鸡汤啊。&lt;/p&gt;

&lt;p&gt;　　所以我先入为主的就给这本书打上了列“道理”，讲“故事”标签。&lt;/p&gt;

&lt;p&gt;　　而真正开始认真读，源自圈内一位高T大佬的热情推荐（原谅我，也深刻的受这种成功者光环的影响）。&lt;/p&gt;

&lt;p&gt;　　小端之前读过《怎样阅读一本书》，按这个套路读下来，在开始阶段，不得不说，一直对书名+简介目录存疑。看起来毫不相关的几个“习惯”，怎么就让人高效了呢？&lt;/p&gt;

&lt;p&gt;　　嗯，通读下来，特别是反复读的时候发现，原来这七个习惯，一脉相承，首尾相连。&lt;/p&gt;

&lt;p&gt;　　首先，作者史蒂芬.柯维把个人的成就，建立在两个模型之上：&lt;strong&gt;个人能力的精进+对团队的驱动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　个人能力是基础，是敲门砖，是大厦的地基，是未来一切可能的前提。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　[对应前三个习惯：积极主动，以终为始，要事第一]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　而对团队的驱动力，则是决定高度的充要条件。作者反复强调，在如今的社会，靠大侠式的个人主义精神，终究难成大器，现在是一个到处充满协作的环境。我们不要1+1&amp;lt;=1的效果，我们甚至不能满足于1+1=2的效果，我们要学习书中的精髓，让团队协作效果是1+1&amp;gt;2。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　[对应4，5，6习惯：共赢思维，知己解彼，统合综效]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　人生是一场修炼，这两个模型，就是通往巅峰的秘籍。而人生的整个过程，又可以划分为三个阶段：&lt;/p&gt;

&lt;div class=&quot; list-paddingleft-2&quot;&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;依赖期：个人能力极弱，可以理解为初入师门的小白。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;独立期：精通第一个模型，即个人能力精进，能独立成事。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;互赖期：学成第二个模型，能驱动团队的高效能，达到1+1等于8，等于16的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;　　对两个模型的研习，始终贯穿于人生的整个阶段。这也就是第7个习惯的精髓：不断更新。只有这样，才能让成长过程，呈螺旋式上升。&lt;/p&gt;

&lt;p&gt;　　下面用图的方式，更形象的说明上述理论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uad5licdKKXyXeBaEHzVNAp2uXFEtW9wY0TictaqBNQf1M5FGEIUcwMZviclEpHnp5BGic2ZxxjldZ04ejOxcdjKOg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.8046971569839307&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;809&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　从图中可以看到，人生每个阶段，如若攀梯，困难必将伴随整个学习过程。而每个习惯之间，每个模型之间，都是针尖对麦芒之态势，深度学习过程中，预示着必将带来思想的激烈碰撞。&lt;/p&gt;

&lt;p&gt;　　言于此，标题中的问题：这本书是不是一碗鸡汤？相信你也有了自己的答案了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎扫描以下二维码关注公众号：小端有话说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/177141/201803/177141-20180327102908200-2000617773.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 07:53:00 +0000</pubDate>
<dc:creator>xiaoyang_</dc:creator>
<og:description>提出问题 今天突然想聊聊最近对职场的一些感悟。 这段时间，小端一直在思考一个问题：作为一个程序员，怎么才能成为团队的核心？ 还记得刚入职场那几年，小端一直觉得，技术过硬，经验丰富，敢打敢拼，就是答案。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyang/p/10044565.html</dc:identifier>
</item>
<item>
<title>测试本职工作中不可缺少的一环----重现BUG - duang的一声</title>
<link>http://www.cnblogs.com/duangduang666/p/10044526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duangduang666/p/10044526.html</guid>
<description>&lt;p&gt;在实际的测试工作中，我们会经常性的遇到“测试部，客户反馈有XX问题，你们重现一下”&lt;/p&gt;

&lt;p&gt;是否会对外面反馈的bug有异样的心理，为什么要我们重现，bug现象都知道了，为什么还要我们再现呢？&lt;/p&gt;

&lt;p&gt;如果有，那你没有做自己的本职工作，如果没有，那么恭喜你，你已经在做本职工作了，为什么我说是在做而不是已做好呢？&lt;/p&gt;

&lt;p&gt;请大家思考一下，我们测试部（测试工程师）的本职工作是什么？&lt;/p&gt;

&lt;p&gt;很多人都会说测试，发现BUG，提高软件质量等等&lt;/p&gt;

&lt;p&gt;既然是测试，那么外面发现问题，从一刀切的角度出发，那么是否就可以判定当前的本职工作没做到位。&lt;/p&gt;

&lt;p&gt;我们再回到最开始的问题，BUG的重现，为什么要我们重现，复现&lt;/p&gt;

&lt;p&gt;其实就一个目的，为了把我们的本职工作做得更好。&lt;/p&gt;

&lt;p&gt;从经济学的角度出发，因为实验室的测试是不能穷极所有的可能性，只会做当前认为最高效、最可靠的测试策略、计划去实施测试。&lt;/p&gt;

&lt;p&gt;从概率学的角度出发，选择不能覆盖所有可能性，那就存在遗漏的情况，意味着纸包不住火，迟早有一天会被发现，但也有可能直到软件生命周期结束都不会被发现。&lt;/p&gt;

&lt;p&gt;为什么我会说复现BUG是为了把我们的本职工作做得更好呢，因为通过复现bug，你能知道，我们当前认为最高效、最可靠的测试策略、计划存在缺陷，需要我们不断的去完善，去思考由此点问题，是否会存在整条线、甚至整个面的问题，只有这样我们才能不断的进步，用一个人工智能的话，就是自学习，从一个点问题，通过自学习，将整个面的问题都能处理。&lt;/p&gt;

&lt;p&gt;说了那么多，可能有人会问，那你发现有客户反馈bug时，你是怎么样的心理？&lt;/p&gt;

&lt;p&gt;有两种心理，1、震惊，为什么还有这种问题，我对自己的测试是抱有足够的信心的，不应该会有此种问题的反馈才对。&lt;/p&gt;
&lt;p&gt;2、紧张，难道我的工作疏忽了。&lt;/p&gt;

&lt;p&gt;然后会第一时间找到相关的人，了解清楚整个问题的所有细节，记住是所有的细节。然后想方设法重现客户的问题，并想出可以规避的手段，让客户不会由于此问题影响他们的正常工作。&lt;/p&gt;

&lt;p&gt;之后才会回查当时实施测试的过程，改进之，避免后继不再出现此类问题，这样才能将我们的本职工作做好。&lt;/p&gt;

&lt;p&gt;这是本人在工作的感悟，随笔，随便记录，不喜轻喷&lt;/p&gt;

</description>
<pubDate>Fri, 30 Nov 2018 07:38:00 +0000</pubDate>
<dc:creator>duang的一声</dc:creator>
<og:description>在实际的测试工作中，我们会经常性的遇到“测试部，客户反馈有XX问题，你们重现一下” 是否会对外面反馈的bug有异样的心理，为什么要我们重现，bug现象都知道了，为什么还要我们再现呢？ 如果有，那你没有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duangduang666/p/10044526.html</dc:identifier>
</item>
<item>
<title>springboot自定义异常处理 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10044468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10044468.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;Author:SimpleWu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;默认错误处理机制&quot;&gt;默认错误处理机制&lt;/h5&gt;
&lt;p&gt;SpringBoot默认的错误处理直接回返回对应的错误视图页面。比如404错误。&lt;/p&gt;
&lt;p&gt;如果是其它客户端访问，默认相应一个json数据。比如通过postman来访问当前页面。&lt;/p&gt;
&lt;p&gt;springboot错误页面处理过程：&lt;/p&gt;
&lt;p&gt;SpringBoot的错误信息配置是通过ErrorMvcAutoConfiguration来进行配置的，这个类中帮我们注册了一下组件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DefaultErrorAttributes：帮我们在页面上共享错误信息。&lt;/li&gt;
&lt;li&gt;BasicErrorController：处理默认的/error请求。分为两种处理请求的方式，一种是html方式，一种是json方式。&lt;/li&gt;
&lt;li&gt;ErrorPageCustomizer：系统发生错误后，该对象就会生效，来定义请求规则。&lt;/li&gt;
&lt;li&gt;DefaultErrorViewResolver：默认的错误视图解析器，将错误信息解析到相应的错误视图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;处理error请求过程： 一旦系统出现4xx或者 5xx之类的错误， ErrorPageCustomizer就会生效（定义错误的相应规则），就会来到/error请求。就会被BasicErrorController处理。BasicErrorController会根据请求头RequestHeaders中的Accept来区分是浏览器发送的请求还是其它工具发出的请求。分为两个处理方法，一个是errorHtml()和error()，在errorHtml()方法中，获取错误状态信息，由resolveErrorView解析器解析到默认的错误视图页面。错误页面是/error/404.html页面。如果templates中error里面有这个页面404错误就会精确匹配404.html如果没有这个404.html他会模糊匹配4xx.html页面，如果templates中没有找到错误页面，它就会去static文件中找。&lt;/p&gt;
&lt;p&gt;页面可以获取的错误信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;timestamp：时间戳。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;status：状态码。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;error：错误提示。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;exception：异常对象。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;message：异常消息。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;errors：数据效验相关的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;注意：static文件夹存放的是静态页面，它没有办法使用模板引擎表达式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;了解了上面的计息过程以后，我们自定义错误就简单了。自定义html错误页面分为两种情况：&lt;/p&gt;
&lt;p&gt;有模板引擎的情况下，在templates文件夹下建立一个error文件夹，里面以错误号的方式添加错误页面。我们也可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的其它错误，精确优先。&lt;/p&gt;
&lt;p&gt;没有模板引擎的情况下，在静态资源文件夹下添加以错误号命名的错误页面。&lt;/p&gt;
&lt;h5 id=&quot;自定义异常返回json数据&quot;&gt;自定义异常返回JSON数据&lt;/h5&gt;
&lt;p&gt;这种异常处理方式没有自适应效果，不论页面还是其它工具都会返回json格式的数据。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ControllerAdvice
public class MyExceptionHandler {
  @ResponseBody
  @ExceptionHandler(RuntimeException.class)
  public Map&amp;lt;String,Object&amp;gt; handleException(Exception e){
  Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
  map.put(&quot;code&quot;,&quot;user.notexist&quot;);
  map.put(&quot;message&quot;,e.getMessage());
  return map;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种处理方式错误码是500他首先会去模板引擎error中找定制的错误页面，没有就会去静态资源文件中error文件夹去。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ControllerAdvice
public class MyExceptionHandler {
@ExceptionHandler(UserNotExistException.class)
public String handleException(Exception e, HttpServletRequest request){
  Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
  //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程
  //Integer statusCode = (Integer) request.getAttribute(&quot;javax.servlet.error.status_code&quot;);
  request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);
  map.put(&quot;code&quot;,&quot;user.notexist&quot;);
  map.put(&quot;message&quot;,e.getMessage());
  //转发到/error
  return &quot;forward:/error&quot;;
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 30 Nov 2018 07:31:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>springboot异常处理 Author:SimpleWu 默认错误处理机制 SpringBoot默认的错误处理直接回返回对应的错误视图页面。比如404错误。 如果是其它客户端访问，默认相应一个js</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10044468.html</dc:identifier>
</item>
<item>
<title>anaconda 环境新建/删除/拷贝 jupyter notebook上使用python虚拟环境 TensorFlow - 小男孩的Code</title>
<link>http://www.cnblogs.com/miaoziblog/p/10044434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miaoziblog/p/10044434.html</guid>
<description>&lt;h2&gt;naconda修改国内镜像源&lt;/h2&gt;
&lt;p&gt;国外网络有时太慢，可以通过配置把下载源改为国内的&lt;br/&gt;通过 conda config 命令生成配置文件，这里使用清华的镜像：&lt;/p&gt;
&lt;p&gt;　　https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;/p&gt;
&lt;p&gt;首先，打开Anaconda Prompt窗口，执行命令：&lt;br/&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;br/&gt;然后，执行命令：&lt;/p&gt;
&lt;p&gt;conda config --set show_channel_urls yes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130150233901-782317984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到用户目录底下找到 .condarc 文件 &lt;/p&gt;
&lt;p&gt;路径在 C:\Users\用户\.condarc&lt;/p&gt;
&lt;p&gt;用编辑软件打开 .condarc 文件，删除第3行 –defaults，保存文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130150347259-816472734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Conda的环境管理&lt;/h2&gt;
&lt;p&gt;anaconda 安装好之后，可能自带的环境不是我们想要的这样就需要在创建一个环境，我安装的是 Anaconda3-5.3.1-Windows-x86_64，自带python是3.7&lt;/p&gt;
&lt;p&gt;TensorFlow目前支持的python最高是3.6不支持python3.7，这就需要添加新的环境。&lt;/p&gt;
















&lt;h2&gt;Conda的包管理&lt;/h2&gt;
&lt;p&gt;Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换&lt;/p&gt;







&lt;p&gt;conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如&lt;/p&gt;
&lt;p&gt;# 更新conda，保持conda最新&lt;br/&gt;conda update conda&lt;/p&gt;
&lt;p&gt;# 更新anaconda&lt;br/&gt;conda update anaconda&lt;/p&gt;
&lt;p&gt;# 更新python&lt;br/&gt;conda update python&lt;br/&gt;# 假设当前环境是python 3.5, conda会将python升级为3.5.x系列的当前最新版本&lt;/p&gt;

&lt;h3 class=&quot;title&quot;&gt;jupyter notebook更改默认工作路径&lt;/h3&gt;
&lt;p&gt;在Anaconda Prompt终端中输入下面命令，查看你的notebook配置文件在哪里：&lt;/p&gt;
&lt;p&gt;jupyter notebook --generate-config&lt;/p&gt;
&lt;p&gt;根据你运行实际显示的路径，打开这个配置文件，我电脑上是这个文件C:\Users\用户\.jupyter\jupyter_notebook_config.py&lt;/p&gt;
&lt;p&gt;找到 c.NotebookApp.notebook_dir 并修改然后保存，后面的是自己要设置的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130145929695-1562663348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置好之后，在开始菜单打开 Jupyter Notebook 可能还是显示的原来的工作路径。修改方案是&lt;/p&gt;
&lt;p&gt;先找到快捷方式的保存目录，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130150601882-100117341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鼠标右击属性 把 % *** %删除掉，% 里面的东西是默认工作路径指定用户的工作路径，不删除无论你怎么设置都不会起作用的。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130150757529-841106692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3 class=&quot;title&quot;&gt;jupyter notebook上使用python虚拟环境&lt;/h3&gt;
&lt;p class=&quot;title&quot;&gt;jupyter notebook上可以同时存在多个环境，&lt;/p&gt;
&lt;p&gt;参照上面新建 Conda环境，然后安装ipykernel，执行以下代码&lt;/p&gt;
&lt;p&gt;conda install -n py35 ipykernel&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;安装完成后，到Anaconda3的安装路径找到kernels文件夹，我的是D:\Anaconda3\share\jupyter\kernels&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;里面默认有一个文件夹 python3&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;要想 jupyter notebook运行时显示多个环境，如下&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130151707139-1305600113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以在 这个kernels文件夹里新建一个文件夹 我新建的是 tensorflow_py35，然后把python3文件夹里的文件全部复制到 tensorflow_py35这个文件夹里，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130151849807-1899306603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后记事本打开 文件 kernel.json 并如下图修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130152040435-348256836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完成后保存。重新打开jupyter notebook ，在New的时候就可显示两个环境啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057141/201811/1057141-20181130152149620-2009675075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ztf312/article/details/65448597&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/f70ea020e6f9&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 07:25:00 +0000</pubDate>
<dc:creator>小男孩的Code</dc:creator>
<og:description>naconda修改国内镜像源 国外网络有时太慢，可以通过配置把下载源改为国内的通过 conda config 命令生成配置文件，这里使用清华的镜像： https://mirrors.tuna.tsin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miaoziblog/p/10044434.html</dc:identifier>
</item>
<item>
<title>桥接模式 桥梁模式  bridge 结构型 设计模式（十二） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10044061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10044061.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;桥接模式Bridge&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144223748-1201316163.png&quot;&gt;&lt;img title=&quot;image_5c00db0d_60a6&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144225008-533579708.png&quot; alt=&quot;image_5c00db0d_60a6&quot; width=&quot;796&quot; height=&quot;446&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Bridge 意为桥梁，桥接模式的作用就像桥梁一样，用于把两件事物连接起来&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将抽象部分与他的实现部分进行分离，使得他们都可以独立的发展。&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;依赖倒置原则要求程序要依赖于抽象接口，不要依赖于具体实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象就是将多个事物、实体中共同的概念提取出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如，一组共同特性的对象概念，可以提取出来类&lt;/p&gt;
&lt;p&gt;如果一些类又具有共同的概念性联系，又可以提取出来抽象类和接口&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;抽象的具体，就是实现&lt;/p&gt;
&lt;p&gt;比如一个对象是一个类的实现，一个具体的子类是抽象父类的实现 &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;类的功能层次结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照依赖倒置原则，我们面向抽象进行编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常会使用接口或者抽象类用于描述功能概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后通过继承进行功能概念的扩展，子类继承父类，并且扩展父类以增加新的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类的实现层次结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在基于功能层次结构的基础上，需要对方法接口或者概念等进行具体实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些所有的实现就组成了类的实现层次结构&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个图片编辑器imageEditor(接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分为windows和Linux两个平台（接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后又分别有两个实现类windowsImpl 以及LinuxImpl（实现类）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144225906-1268015515.png&quot;&gt;&lt;img title=&quot;image_5c00db0d_2922&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144226867-962042412.png&quot; alt=&quot;image_5c00db0d_2922&quot; width=&quot;344&quot; height=&quot;340&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;图中，红框部分即为类的功能层次结构，蓝色矩形框部分即为类的实现层次结构&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于类的层级结构不是很复杂的时候，我们可能经常会将类的功能层次结构和实现层次结构掺杂在一起&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，你可能定义了一个抽象类A，然后他有两个子类B和C，B是用于实现，另一个C却是功能逻辑的扩展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当层次接口相对比较简单的时候，掺杂在一起，还相对容易应对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当层次结构变得很复杂时，如果还是掺杂在一起将会变得非常难以处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为当你想要扩展产品功能逻辑时，你可能很难确定到底应该在类的哪一个层次结构中去扩展&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们将编辑器抽象提取出来Editor（接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又有图形编辑器ImageEditor（接口）文本编辑器TextEditor（接口）视频编辑器VideoEditor（接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又分别有windows和linux两个版本的软件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红色框内为功能层次结构，蓝色框内为实现层次接口&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144227171-1320251404.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_7d15&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144227827-1006516198.png&quot; alt=&quot;image_5c00db0e_7d15&quot; width=&quot;1251&quot; height=&quot;453&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上图就是通过继承的形式进行功能扩展与实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看得出来，如果新增加一种新的编辑器，比如音频AudioEditor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么可能需要新增加AudioWindowsEditor和AudioLinuxEditor以及他们的实现类AudioWindowsEditorImpl和AudioLinuxEditorImpl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了新增的编辑器外，新增文件个数为4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果，当新增加一种操作系统，比如 Os X&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，将需要根据现有的Editor类型 创建对应的三个Os X操作系统的接口（ImgXEditor，TextXEditor，VideoXEditor）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在创建与之对应的三个实现类（ImgXEditorImpl，TextXEditorImpl，VideoXEditorImpl）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了新增的操作系统外，新增文件个数为6&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;这种采用多层继承结构的形式，类的个数巨大&lt;/p&gt;
&lt;p&gt;因为不仅仅有多种类型的Editor，设类型个数为X&lt;/p&gt;
&lt;p&gt;又需要在多个操作系统平台上进行实现，设平台个数为Y&lt;/p&gt;
&lt;p&gt;实现类的个数为X*Y&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;扩展时，如上例，个数又将会爆发式的增长&lt;/p&gt;
&lt;p&gt;随之而来的就是维护、使用、运行等成本的增加&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;继承从一开始就把抽象角色和实现角色进行了绑定，是一种强关联关系，并&lt;span&gt;&lt;strong&gt;不符合&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;组合复用原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译时期就已经确定，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不能够在运行时期进行变动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，继承将父类暴露给子类，如果父类发生变化，子类势必将会受到波及影响，将不得不做出修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;不符合开闭原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再有就是，对于每一个实现类，他即涉及具体类型的Editor又涉及平台，比如ImgWindowsEditor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于处理图像img 又涉及到windows平台，那么涉及到img或者windows的修改，都可能会影响他导致修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不符合单一职责原则&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;面对复杂继承层次结构带来的问题，所以，人们希望能够&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将抽象部分与他的实现部分进行分离，使得他们都可以独立的发展。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是桥接模式的最初动机&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;向分离的演进&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;仔细观察可以发现，之所以类会如此膨胀，扩展如此困难的原因就在于他&lt;span&gt;&lt;strong&gt;不止一个维度&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Editor类型以及不同平台实现两个维度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也正是这两个维度导致了不符合单一职责原则&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144228139-1500936285.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_3871&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144228699-33688998.png&quot; alt=&quot;image_5c00db0e_3871&quot; width=&quot;759&quot; height=&quot;453&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;是否可以将这两个维度进行分离？&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;如果能够分离，也就意味着不会是完全使用继承层次结构&lt;/p&gt;
&lt;p&gt;因为继承是强关联，完全继承，就不是分离&lt;/p&gt;
&lt;p&gt;那么，就需要考虑类的组合&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;如果能够分离，将他们拆分为各自不同的维度，那么就不会出现类的个数爆炸式增长的情况&lt;/p&gt;
&lt;p&gt;因为一旦分离，就可以各自独立发展&lt;/p&gt;
&lt;p&gt;独立发展，那么增加一个Editor类型就是一个Editor类型&lt;/p&gt;
&lt;p&gt;增加一个操作系统平台，就只是增加一个操作系统平台类型&lt;/p&gt;
&lt;p&gt;不在爆炸增长&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;如果能够进行分离，那么他们各自负责自己不同的维度，职责将会更加单一&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;客户端关注什么？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;客户端程序的目的在于使用Editor，也就是Img、Text、Video的编辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他其实并不在意到底是什么平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，他也不应该在意，只有这样才能够跨平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，在我们的类层次结构中，却偏偏的与平台建立了强关联&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以一种解决方案就是：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;客户端面向Editor进行编程&lt;/p&gt;
&lt;p&gt;Editor不关注平台的细节，将与平台相关的实现剥离开来&lt;/p&gt;
&lt;p&gt;而平台的实现部分，通过组合的方式，组合到Editor中来&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;类似适配器模式（对象适配器模式），Editor作为目标对象Target&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而与平台相关联的实现就是被适配的角色Adaptee&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而每一个类型比如ImgEditor都是Adapter&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144228899-933171933.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_6270&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144229081-456075292.png&quot; alt=&quot;image_5c00db0e_6270&quot; width=&quot;413&quot; height=&quot;239&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于平台相关的细节部分，通过组合的方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示Editor中含有指向Implementor的引用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及平台相关性的处理，借助于Implementor来完成&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144229726-170150175.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_b2c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144230022-1276907443.png&quot; alt=&quot;image_5c00db0e_b2c&quot; width=&quot;731&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 编辑器的抽象类
* 内部包含implementor 对Editor的请求可以借助于Implementor
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Editor {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Implementor implementor;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setImplementor(Implementor implementor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.implementor =&lt;span&gt; implementor;
    } 
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doEdit(){
        implementor.systemEditor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ImgEditor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Editor {
    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doEdit() {
        System.out.println(&lt;/span&gt;&quot;ImgEditor working&quot;&lt;span&gt;);
        implementor.systemEditor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TextEditor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Editor {
    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doEdit() {
        System.out.println(&lt;/span&gt;&quot;TextEditor working&quot;&lt;span&gt;);
        implementor.systemEditor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VideoEditor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Editor {
    @Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doEdit() {
        System.out.println(&lt;/span&gt;&quot;VideoEditor working&quot;&lt;span&gt;);
        implementor.systemEditor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;以上代码为上图中的左半部分&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144230257-1353613391.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_2bfb&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144230457-798114798.png&quot; alt=&quot;image_5c00db0e_2bfb&quot; width=&quot;406&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Implementor {
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; systemEditor();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WindowsImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Implementor {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; systemEditor() {
System.out.println(&lt;/span&gt;&quot;working on windows platform&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinuxImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Implementor {
 @Override
&lt;/span&gt;&lt;span&gt; public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; systemEditor() {
  System.out.println(&lt;/span&gt;&quot;working on linux platform&quot;&lt;span&gt;);
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;以上为右半部分的实现&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144230692-1228044022.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_af9&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144230874-783406762.png&quot; alt=&quot;image_5c00db0e_af9&quot; width=&quot;346&quot; height=&quot;213&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; bridge;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
Editor editor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImgEditor();
editor.setImplementor(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowsImpl());
editor.doEdit();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144231086-2103869806.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_326e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144231282-871387621.png&quot; alt=&quot;image_5c00db0e_326e&quot; width=&quot;555&quot; height=&quot;118&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;


&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;在示例代码中，创建了一个ImgEditor&lt;/p&gt;
&lt;p&gt;然后动态的借助于new WindowsImpl()  在windows平台上执行编辑任务&lt;/p&gt;
&lt;p&gt;在真正的借助于平台底层，执行平台相关的代码之前，还进行了一些其他的处理&lt;/p&gt;
&lt;p&gt;比如上面的打印语句：&lt;/p&gt;
&lt;p&gt;    System.out.println(&quot;ImgEditor working&quot;);&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;这种使用方式，用户关注的是Editor，不在与具体的平台进行绑定&lt;/p&gt;
&lt;p&gt;具体的平台通过组合的形式组合到Editor中&lt;/p&gt;
&lt;p&gt;在具体的使用到平台相关的方法中，Editor依赖于内部的Implementor 进行处理&lt;/p&gt;
&lt;p&gt;扩展时，也不会出现类文件个数爆炸增长的问题&lt;/p&gt;
&lt;p&gt;可以相互独立发展，这就是桥接模式      &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144231905-1978913650.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_14ad&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144232168-726545886.png&quot; alt=&quot;image_5c00db0e_14ad&quot; width=&quot;531&quot; height=&quot;248&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象化角色Abstraction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;抽象化给出定义，并保存一个对实现的引用&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修正抽象化RefinedAbstraction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;扩展抽象化角色，调整父类对抽象化的定义&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现角色Implementor&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;给出实现化角色的接口定义，但不给出具体的实现&lt;/p&gt;
&lt;p&gt;这个接口不一定和Abstraction中的接口定义相同，实际上，可以完全不相同也没关系&lt;/p&gt;
&lt;p&gt;实现化角色仅仅给出底层操作抽象化角色给出基于底层操作，更高一层的抽象操作&lt;/p&gt;
&lt;p&gt;比如底层是基于平台的，更高一层则是ImgEditor这种&lt;/p&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;具体实现化角色ConcreteImplementor&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;给出实现化角色的具体实现代码&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;桥接模式的重点在于理解抽象化与实现化的概念含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要局限在java中定义一个接口A，然后定义一个实现类AImpl，然后override所有的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种思维方式太狭隘了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象化在于针对于底层操作的更高一层抽象，更高一层的调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像上面的例子，ImgEditor真正的实现需要依赖底层具体的平台，所以ImgEditor的doEdit方法是底层平台实现的抽象化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;千万不要把抽象与实现局限在extends 和implements关键字的那种形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应该认为，但凡是更高一层的调用，或者封装，都可以认为是一种抽象与实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也正是因为这种模式是extends 和implements关键字场景的进一步抽象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以也被称之为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;接口Interface模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;extends 和implements关键字的形式自然是抽象与实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个对象中的方法，借助于另外的对象来实现，这也是一定程度上的“抽象化--实现化”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以说适配器模式也是一定程度上的抽象化--实现化”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;抽象化对象就像是手柄一样，通过手柄来操纵委派给实现化角色，所以桥梁模式也被称之为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;柄体模式&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;Handle and Body&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;抽象化等级结构中的方法，通过向对应的实现化对象委派实现自己的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就意味着抽象化角色可以通过向不同的实现化对象委派&lt;/span&gt;，&lt;span&gt;就可以达到动态的转换自己的功能的目的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在上面的示例中，&lt;/span&gt;&lt;span&gt;我们使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public void setImplementor(Implementor implementor)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进行Implementor的设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般经常使用&lt;strong&gt;工厂模式（方法）&lt;/strong&gt;进行创建赋值&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;桥梁模式与JDBC&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;jdbc的百度百科&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144232406-1555266685.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_3248&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144232949-1814908200.png&quot; alt=&quot;image_5c00db0e_3248&quot; width=&quot;872&quot; height=&quot;142&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;JDBC是桥梁模式的典型应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他将抽象化与实现化进行分离&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144233156-450213779.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_61e3&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144233433-490464571.png&quot; alt=&quot;image_5c00db0e_61e3&quot; width=&quot;517&quot; height=&quot;362&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;它为所有的关系数据库提供了一个通用的访问界面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提供了一组与具体厂家实现完全无关的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了JDBC这一组通用接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用系统就可以不依赖数据库引擎的具体细节而独立的演化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一个应用系统动态的选择一个合适的驱动器，然后通过驱动器向数据库引擎发出指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是抽象角色的行为委派给实现角色来完成任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;厂家的实现与JDBC之间，并没有任何的静态强关联&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实很多其他形式的驱动又何尝不是如此？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如Office办公软件打印不需要关注于具体的打印机厂家型号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会有统一的驱动为我们进行处理&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;模式对比&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;与适配器区别&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144233634-1234780260.png&quot;&gt;&lt;img title=&quot;image_5c00db0e_797d&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181130144233986-1992031057.png&quot; alt=&quot;image_5c00db0e_797d&quot; width=&quot;942&quot; height=&quot;294&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面说到桥接模式类似适配器模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，某种程度上讲，适配器模式也符合&lt;/span&gt;&lt;span&gt;“抽象化---实现化”的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，从上面的结构图中，可以看得出来，桥接模式与对象适配器模式的相似程度&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;他们都拥有抽象的概念角色 Abstraction和Target&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它们都拥有具体的客户端需要直接面对的角色 RefinedAbstraction和Adapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们都有工作需要委托给内部的“&lt;/span&gt;&lt;span&gt;工作人员&lt;/span&gt;&lt;span&gt;”Implementor 和 Adaptee&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们都依赖于“抽象”与“实现”的概念&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么到底有什么区别呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;适配器模式的主要目的是让因为接口不兼容而不能互相工作的类能够一起工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换句话说就是他们本身不同，我用“纽带” Adapter将他们连接起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而桥接模式则是将原本或许紧密结合在一起的抽象与实现，进行分离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使她们能够各自独立的发展，是把连接在一起的两个事物，拆分开来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后用“纽带”“桥梁”（也就是对象的引用）将他们连接起来&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;适配器模式就好比&lt;/span&gt;&lt;span&gt;张三和王五不认识，李四介绍他们认识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;桥梁模式好比张三和王五成天黏在一起活干得不好太乱套，李四说以后我作为接口人，你俩各干各的吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然看起来都是两个人，中间一个联系人，但是含义却是完全不同&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;与装饰器区别&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰器模式中，使用组合而不是继承来对类的功能进行扩展，避免了类的个数的爆炸增长，与桥梁模式的结果不约而同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;都解决了类爆炸增长的问题，都避免了过多的没必要的子类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;装饰器模式侧重于功能的动态增加，将额外的功能提取到子类中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过不同的排列组合，形成一个递归的调用方式，以动态的增加各部分的功能&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;桥梁模式是将原本系统中的实现细节抽取出来，比如原来抽象概念与实例化全部都是一个类层次结构中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把所有的实现细节，比如示例中的平台相关实现，抽取出来，进行分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;达到抽象与实现分离的目的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以虽然他们都可以解决子类爆炸式增长、不易扩展的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是他们的出发点完全不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个关注于功能的动态扩展组合&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个关注于抽象与实现的分离，获得更多的灵活性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果一个系统要求抽象化角色和具体化角色之间增加更多的灵活性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;避免在两个层次之间建立静态的联系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是实现化角色的改变，不会影响客户端，完全透明的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果系统需要在多个抽象化角色和实现化角色之间进行动态的耦合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是要求能够动态的组合&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果使用多层继承结构进行处理时，就可以考虑使用桥接模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尤其是一个类存在两个或者多个变化的维度，而且这两个维度也可能需要动态的扩展&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总之，当你需要抽象化和是实现化进行解耦时，你就可以考虑桥梁模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解耦就会变得透明不会互相影响能够独立发展，解耦就能够动态的组合，解耦了就不会有静态的联系&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;提高了扩展性，多层继承的良好替代方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将抽象与实现进行解耦，更加符合单一职责原则 组合复用原则以及开闭原则&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;注意点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;想要使用桥接模式，必然要理清楚你面对的需求中抽象与实现的部分，才能更好的进行运用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要具备抽象与实现分离的相关需要，都可以考虑桥梁模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面描述的多个维度不同发展，多层次的抽象，是桥梁模式的更高级别的运用，&lt;/span&gt;&lt;span&gt;必须要先分析清楚变化的维度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且最重要的就是分析出整个类层次结构中的“抽象化”部分和“实现化”部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的Editor示例中，ImgEditor TextEditor才是客户端程序关注的，他们不希望关注于具体平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDBC中，客户端程序关注的是数据库的查询操作行为，而不希望关注数据库的细节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以你必须找准到底谁是抽象化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;桥接模式的场景理解起来略微有点费神&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是他的根本逻辑却是非常简单，那就是抽象的概念功能与具体的实现进行分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;桥接模式是面向抽象编程--依赖倒置原则的具体体现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并且使用组合的形式，解决了多层继承结构中的一些问题&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 30 Nov 2018 06:56:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>本文介绍了桥接模式Bridge也叫做桥梁模式，从思维的演进角度分析理解了桥梁模式的意义，给出了桥梁模式的意图和结构，并且提供了java实现，通过对与适配器模式和装饰器模式的对比加深了桥梁模式的理解，文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10044061.html</dc:identifier>
</item>
<item>
<title>Python在Windows上安装配置测试 - JasonHU</title>
<link>http://www.cnblogs.com/huys/p/10043436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huys/p/10043436.html</guid>
<description>&lt;p&gt; 　　---恢复内容开始---&lt;/p&gt;
&lt;p&gt;　　Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.x还是3.x&lt;/strong&gt;&lt;br/&gt;　　目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的，因为现在Python正在朝着3.x版本进化，在进化过程中，大量的针对2.x版本的代码要修改后才能运行，所以，目前有许多第三方库还暂时无法在3.x上使用。&lt;/p&gt;
&lt;p&gt;为了保证你的程序能用到大量的第三方库，我们的教程仍以2.x版本为基础，确切地说，是2.7版本。请确保你的电脑上安装的Python版本是2.7.x，这样，你才能无痛学习这个教程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、下载安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　到这个网站下载https://www.python.org/downloads/windows/&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130115609052-863151067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是选择了3.5版本的可执行程序安装：python-3.5.4-amd64.exe&lt;/p&gt;
&lt;p&gt; 下载好运行安装。&lt;/p&gt;
&lt;p&gt;注： 请选中Add Python 这项，把Python添加到环境变量，这样以后在windows命令提示符下面也可以运行Python。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130124626109-672074702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130125059322-1597396242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130125352151-429589191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130125525840-1702827859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、测试运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、REPL（Read Eval Print Loop）环境运行&lt;/p&gt;
&lt;p&gt;        使用IDEL &lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130125719735-1355979660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        使用Python语法中的 print( ); 语法进行打印&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130125943428-476809198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、使用Windows命令提示符 cmd    &lt;/p&gt;
&lt;p&gt;          输入 python 返回值如下  证明你已经成功安装了python到环境变量。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130130447377-472631811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;******如果输入python你看到提示符&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;exit()&lt;/code&gt;并回车，就可以退出Python交互式环境（或直接关掉命令行窗口）。&lt;/p&gt;
&lt;p&gt;*****如果输入Python得到一个错误：&lt;code class=&quot;undefined&quot;&gt;‘python’不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　这是由于环境变量出问题，Windows会根据一个&lt;code&gt;Path&lt;/code&gt;的环境变量设定的路径去查找&lt;code&gt;python.exe&lt;/code&gt;，如果没找到，就会报错。如果在安装时漏掉了勾选&lt;code&gt;Add python.exe to Path&lt;/code&gt;，那就要手动把&lt;code&gt;python.exe&lt;/code&gt;所在的路径&lt;code&gt;C:\Python27&lt;/code&gt;添加到Path中。&lt;/p&gt;
&lt;p&gt;如果你不知道怎么修改环境变量，建议把Python安装程序重新运行一遍，记得勾上&lt;code&gt;Add python.exe to Path&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3、用文本编辑器编辑一段代码测试，如：Notepad++&lt;/p&gt;
&lt;p&gt;输入下面代码，保存到你想保存的目录如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello,欢迎您！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130132229231-310645773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Windows命令提示符 进入这个文件的目录，并运行这个Python代码文件的到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130132519475-390197732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、使用集成开发环境IDE-------PyCharm &lt;/p&gt;
&lt;p&gt;　下载安装好PyCharm，打开软件，新建工程&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130134817510-1032512858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目右键，新建一个Python文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130135052959-1804350766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入代码并且运行的到结果如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/194611/201811/194611-20181130135504474-675160345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完成！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、关于Python解释器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　编写Python代码得到的是以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。&lt;/p&gt;
&lt;p&gt;由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。所以存在多种解释器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPython&lt;/strong&gt;&lt;br/&gt;　　当从Python官方网站下载并安装好Python 就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。&lt;/p&gt;
&lt;p&gt;CPython是使用最广的Python解释器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPython&lt;/strong&gt;&lt;br/&gt;　　IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。&lt;/p&gt;
&lt;p&gt;CPython用&amp;gt;&amp;gt;&amp;gt;作为提示符，而IPython用In [序号]:作为提示符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PyPy&lt;/strong&gt;&lt;br/&gt;　　PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jython&lt;/strong&gt;&lt;br/&gt;　　Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IronPython&lt;/strong&gt;&lt;br/&gt;　　IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。&lt;/p&gt;


&lt;p&gt; 转载请注明出处&lt;/p&gt;
&lt;p&gt;---恢复内容结束---&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 05:59:00 +0000</pubDate>
<dc:creator>JasonHU</dc:creator>
<og:description>恢复内容开始 Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。 2.x还是3.x 目前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huys/p/10043436.html</dc:identifier>
</item>
<item>
<title>selenium之元素定位-xpath - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-python-selenium-xpath.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-python-selenium-xpath.html</guid>
<description>&lt;h2&gt;&lt;span&gt;被测试网页的HTML代码&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('afef9dc9-4c80-482a-bccd-d2aacc899d00')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_afef9dc9-4c80-482a-bccd-d2aacc899d00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_afef9dc9-4c80-482a-bccd-d2aacc899d00&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('afef9dc9-4c80-482a-bccd-d2aacc899d00',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_afef9dc9-4c80-482a-bccd-d2aacc899d00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;=&quot;div1-img1&quot;&lt;/span&gt;&lt;span&gt;
            src&lt;/span&gt;&lt;span&gt;=&quot;http://www.sogou.com/images/logo/new/sogou.png&quot;&lt;/span&gt;&lt;span&gt;
            href&lt;/span&gt;&lt;span&gt;=&quot;http://www.sogou.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sogou image&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;div1input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.sogou.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;搜狗搜索&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;查询&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;=&quot;div2-img2&quot;&lt;/span&gt;&lt;span&gt;
            src&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com/img/bdlogo.png&quot;&lt;/span&gt;&lt;span&gt;
            href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;baidu image&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;div2input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;百度搜索&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;查询&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;被测试代码&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用上面的代码生成被测试网页，基于此网页来实现各种不同的页面元素的xpath定位方法&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;①xpath绝对路径定位&lt;span class=&quot;ask-title&quot;&gt;元素&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;　　绝对路径表示页面元素在被测网页的HTML代码结构中，从根节点一层层地搜索到需要被定位的页面元素，绝对路径起始于正斜杠(/)，每一步均被斜杠分割。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;目的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;　　在被测网页中查找第一个div标签下的“查询”按钮&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;xpath定位表达式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/html/body/div/input[@value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; python定位语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
element = driver.find_element_by_xpath(&lt;span&gt;'/html/body/div/input[@value=&lt;span&gt;&quot;&lt;span&gt;查询&lt;span&gt;&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 代码解释：&lt;/p&gt;
&lt;p&gt;　　上述xpath定位表达式从html dom树的根节点（html节点）开始逐层查找，最后定位到“查询”按钮节点。路径表达式“/”表示跟节点。&lt;/p&gt;
&lt;p&gt;使用绝对路径定位页面元素的好处在于可以验证页面是否发生变化。如果页面结构发生变化，可以会造成原先有效的xpath表达式失败。使用绝对历经定位是十分脆弱的，因为即便页面代码结构只发生了微小的变化，也可能会造成原先有效的xpath定位表达式定位失败。因此，建议在自动化测试的定位实施环节中，优先考录使用后面将要介绍的相对路径进行定位。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;②xpath相对路径定位&lt;span class=&quot;ask-title&quot;&gt;元素&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;　　相对路径的每一步都根据当前节点集之中的节点来进行计算，起始于双//。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;目的;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;　　在被测试网页中，查找第一个div标签下的“查询”按钮。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;ask-title&quot;&gt;xpath定位表达式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
//div[@value=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python定位语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
element = driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;//div[@value=&lt;span&gt;'&lt;span&gt;查询&lt;span&gt;']&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;p&gt;　　上述xpath定位表达式中//表示从匹配选择的当前节点开始选择文档中的节点，而不考虑特面的位置。input[@value=&quot;查询&quot;]表示定位value值为“查询”两个字的input页面元素。&lt;/p&gt;
&lt;p&gt;相对路径的xpath定位表达式更加简洁，不管页面发生了何种变化，只要input标签的value属性值没变，始终都可以定位到。推荐使用相对路径的xpath表达式，并且越简洁越好，可大大降低测试脚本中定位表达式的维护成本。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span class=&quot;ask-title&quot;&gt;③xpath使用索引号定位&lt;span class=&quot;ask-title&quot;&gt;元素&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;　　索引号表示某个被定位的页面元素在其父元素节点下的同名元素中的位置符号，需要从1开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;目的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;　　在被测网页中，查找第一个div标签下的“查询”按钮&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;xpath定位表达式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
//input[1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python定位语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
element=driver.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[1]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;p&gt;　　索引号定位方式是根据该页面元素在页面中相同标签名之间出现的索引位置来进行定位。上述xpath定位表达式表示查找页面中第二个出现的input元素，即被测试页面上的“查询”按钮。&lt;/p&gt;
&lt;p&gt;若在Firefox浏览器的插件（try xpath，新版本的firepath已经没有了！真的挺伤心的）中使用上述的定位方式你会发现定位到两个元素，两个div标签下的input都被定位到了，这和只查找第一个input元素相冲突，这是由于被测网页中两个div标签都包含了input标签，xpath再查找的时候把每个div节点都当作相同的起始层级开始查找，所以用//input[1]表达式会同时查找到两个div节点下的第一个input元素。如果再两div标签下还有嵌套的div，并且嵌套的div下也有input标签，也会被定位到。因此在使用索引号定位页面元素的时候，需要注意网页html代码中是否包含了多个层级完全相同的代码结构，若出现了这种情况，就需要修改定位表达式，以确保自动化测试脚本中使用的定位表达式能唯一定位所需要的元素。如果想同时定位多个相同的input页面元素可以使用下面的python语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
elementList=driver.find_elements_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[1]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将定位的多个元素存储到list中，然后根据list索引号获取想要的页面元素。但如果发现页面元素会经常增加或减少，就不建议使用索引号定位方式。&lt;/p&gt;
&lt;p&gt;基于实例中的被测网页，下面给出更多的通过索引号定位的实例&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;预期定位圆面的元素&lt;/td&gt;
&lt;td&gt;定位表达式实例&lt;/td&gt;
&lt;td&gt;使用的属性值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;定位第二个div下的超链接&lt;/td&gt;
&lt;td&gt;//div[last()]/a&lt;/td&gt;
&lt;td&gt;div[last()]表示最后一个div元素，last（）函数获取的是指定元素的最后的索引号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;定位第一个div中的超链接&lt;/td&gt;
&lt;td&gt;//div[last()-1]/a&lt;/td&gt;
&lt;td&gt;div[last()-1]表示倒数第二个div元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;定位最前面一个属于div元素的子元素中的input元素&lt;/td&gt;
&lt;td&gt;//div/input[position()&amp;lt;2]&lt;/td&gt;
&lt;td&gt;position（）函数获取当前元素input的位置序号&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span class=&quot;ask-title&quot;&gt;④xpath使用页面元素的属性值定位&lt;span class=&quot;ask-title&quot;&gt;元素&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;　　在定位页面元素的时候 ，经常会遇到各种复杂的结构的被测试网页，并且很多页面元素也没有设计ID，Name等属性，同时又不想使用绝对路径或索引号来定位页面元素，但是发现要被要被定位的页面元素拥有某些固定不变的属性及属性值，此时推荐属性定位方式来定位页面元素。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;目的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;　　定位被测网页中的第一张img元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;&lt;span class=&quot;ask-title&quot;&gt;xpath定位表达式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
//input[@alt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div1-img1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python定位语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
img = driver.find_element_by_xpath(&lt;span&gt;&quot;//input[@alt=&lt;span&gt;'&lt;span&gt;div1-img1&lt;span&gt;']&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;p&gt;　　表达式使用了相对路径再结合元素拥有的特定属性方法进行定位，定位元素img的属性是“alt”，值为“div1-img1”，使用@符号指明后面接的是属性，并同属性及属性值一起写到元素后的方括号中。&lt;/p&gt;
&lt;p&gt;　　被测试网页的元素通常会包含各种各样的属性值，并且很多属性值具有唯一性。若能确认属性值不常变并且唯一，强烈建议使用相对路径再结合属性的定位方式来编写xpath定位方式，使用此方法可以解决99%的页面元素定位问题。下面给出更多的定位实例。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;预定位的页面元素&lt;/td&gt;
&lt;td&gt;定位表达式实例&lt;/td&gt;
&lt;td&gt;使用的属性值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;定位页面的第一张图片&lt;/td&gt;
&lt;td&gt;//img[@href=&quot;&quot;http://www.sogou.com]&lt;/td&gt;
&lt;td&gt;使用img标签的属性href值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;定位第二个div中第一个input输入框&lt;/td&gt;
&lt;td&gt;//div[@id=&quot;div2&quot;]/input[@name=&quot;div2input&quot;]或者//inuput[@name=&quot;div2input&quot;]&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;使用div变迁的name值&lt;/p&gt;
&lt;p&gt;使用input标签的name属性值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;定位第一个div中的第一个链接&lt;/td&gt;
&lt;td&gt;//div[@id=&quot;div1&quot;]/a[@href=&quot;http://www.sogou.com&quot;]&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;使用div标签的ID属性值&lt;/p&gt;
&lt;p&gt;使用a标签的href属性值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;定位页面的查询按钮&lt;/td&gt;
&lt;td&gt;//input[@type=&quot;button&quot;]&lt;/td&gt;
&lt;td&gt;使用input标签的type属性值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span class=&quot;ask-title&quot;&gt;⑤xpath使用模糊属性值定位元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;　　模糊属性值定位方式表示使用属性值的一部分内容定位。在自动化测试的实施过程中，常常会遇到页面元素的属性值是动态生成的，也就是说每次访问属性值都不一样，此类页面元素会加大定位难度，使用模糊属性值定位方式可以解决一部分类似难题，但前提是属性值中有一部分内容是不变的，xpath提供了一些可以实现模糊属性值的定位需求的函数。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td&gt;xpath函数&lt;/td&gt;
&lt;td&gt;定位表达式实例&lt;/td&gt;
&lt;td&gt;表达式解释&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;starts-with（str1，str2）&lt;/td&gt;
&lt;td&gt;//img[starts-with(@alt,&quot;div1&quot;)]&lt;/td&gt;
&lt;td&gt;查找属性alt的属性值以div1关键字开始的页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;contains（str1，str2）&lt;/td&gt;
&lt;td&gt;//img[contains(@alt,&quot;img&quot;)]&lt;/td&gt;
&lt;td&gt;查找alt属性的属性值包含img关键字的页面元素，只要包含即可，无需考虑位置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;contains函数属于xpath的高级用法，使用场景比较多，尽管页面元素的属性值经常变化，但只要其属性值有几个固定不变的关键词，就可以使用cotains函数进行定位。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span class=&quot;ask-title&quot;&gt;⑥xpath使用xpath轴定位元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 　　轴可以定义相对于当前节点的节点集。使用xpath定位方式可以根据再文档树中的元素相对位置关系进行页面元素定位。先找到一个相对好定位的元素，让它作为轴，根据它和要定位元素间的相对位置关系进行定位，可解决一些点定位难的问题。&lt;/p&gt;
&lt;p&gt;我们根据被测页面的代码来画一下结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201811/1421063-20181130123046854-2037592568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;xpath常用轴关键字：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;28&quot;&gt;&lt;tr&gt;&lt;td&gt;xpath轴关键字&lt;/td&gt;
&lt;td&gt;轴的含义说明&lt;/td&gt;
&lt;td&gt;定位表达式实例&lt;/td&gt;
&lt;td&gt;表达式解释&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;parent&lt;/td&gt;
&lt;td&gt;选择定钱节点的上一层父节点&lt;/td&gt;
&lt;td&gt;//img[@alt='div2-img2']/parent::div&lt;/td&gt;
&lt;td&gt;查找到属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上一级的div页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;child&lt;/td&gt;
&lt;td&gt;选择当前节点的下层所有子节点&lt;/td&gt;
&lt;td&gt;//div[@id='div1']/child::img&lt;/td&gt;
&lt;td&gt;查找到ID属性值为div1的div元素，并基于div的位置找到它下层节点中的img页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;ancestor　　&lt;/td&gt;
&lt;td&gt;选择当前节点所有上层节点&lt;/td&gt;
&lt;td&gt;//img[@alt='div2-img2']/ancestor::div&lt;/td&gt;
&lt;td&gt;查找到属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上级的div元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;descendant&lt;/td&gt;
&lt;td&gt;选择当前节点所有下层的节点（子，孙等）&lt;/td&gt;
&lt;td&gt;//div[@name='div2']/descendant::img&lt;/td&gt;
&lt;td&gt;查找到属性name的属性值为div2的div元素，并基于该元素的位置找到它下级所有节点中的img页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;following&lt;/td&gt;
&lt;td&gt;选择当前节点之后显示的所有节点&lt;/td&gt;
&lt;td&gt;//div[@id='div1']/following::img&lt;/td&gt;
&lt;td&gt;查找到ID属性值为div1的div页面元素，并基于div的位置找到它后面节点中的img页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;following-sibling&lt;/td&gt;
&lt;td&gt;选择当前节点后续所有兄弟节点&lt;/td&gt;
&lt;td&gt;//a[@href='http://www.sogou.com']/following-sibling::input&lt;/td&gt;
&lt;td&gt;查找到链接地址为http：//www.sogou.com的链接页面元素a，并基于链接的位置找到它后续兄弟节点中的input页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;preceding&lt;/td&gt;
&lt;td&gt;选择当前节点前面的所有节点&lt;/td&gt;
&lt;td&gt;//img[@alt='div2-img2']/preceding::div&lt;/td&gt;
&lt;td&gt;查找到属性alt的属性值为div2-img2的图片页面元素img，并基于图片的位置找到它前面节点中的div页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;preceding-sibling&lt;/td&gt;
&lt;td&gt;选择当前节点前面的 所有兄弟节点&lt;/td&gt;
&lt;td&gt;//input[@value='查询']/preceding-sibling::a[1]&lt;/td&gt;
&lt;td&gt;查找到value属性值为“查询”的输入框页面元素，并基于该输入框的位置找到他前面同级节点中的第一个链接页面元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有时候我们会再轴后面加一个星号*， 便是通配符，如：//input[@value=&quot;查询&quot;]/preceding::*，它表示查找属性value的值为“查询”的输入框input元素前面所有的同级元素，但不包括input元素本身&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;⑦xpath使用页面元素的文本定位元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　通过text()函数可以定位到元素文本包含某些关键内容的页面元素。&lt;/p&gt;
&lt;p&gt;xpath表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1.//a[text()=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;搜狗搜索&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;2.//a[.=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;搜狗搜索&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;3.//a[contains(.,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]

&lt;/span&gt;4.//a[contains(text(),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;百度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]

&lt;/span&gt;5.//a[contains(text(),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]/&lt;span&gt;preceding::div

&lt;/span&gt;6.//a[contains(. , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]/..
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python定位语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
sogou_a=driver.find_element_by_xpath(&lt;span&gt;'//a[text()=&lt;span&gt;&quot;&lt;span&gt;搜狗搜索&lt;span&gt;&quot;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;)
sogou_a&lt;/span&gt;=driver.find_element_by_xpath(&lt;span&gt;'//a[.=&lt;span&gt;&quot;&lt;span&gt;搜狗搜索&lt;span&gt;&quot;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;)
baidu_a&lt;/span&gt;=driver.find_element_by_xpath(&lt;span&gt;'//a[contains(.,&lt;span&gt;&quot;&lt;span&gt;百度&lt;span&gt;&quot;&lt;span&gt;)]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;)
baidu_a&lt;/span&gt;=driver.find_element_by_xpath(&lt;span&gt;'//a[contains(text(),&lt;span&gt;'&lt;span&gt;百度&lt;span&gt;'&lt;span&gt;)]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;)
div&lt;/span&gt;=driver.find_element_by_xpath(&lt;span&gt;'//a[contains(text(),&lt;span&gt;&quot;&lt;span&gt;百度&lt;span&gt;&quot;)]/&lt;span&gt;preceding::div&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;)
div&lt;/span&gt;=driver.find_element_by_xpath(&lt;span&gt;'//a[contains(. , &lt;span&gt;&quot;&lt;span&gt;百度&lt;span&gt;&quot;)]/..&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;p&gt;　　xpath表达式1和表达式2等价，都是查找文本内容为“搜狗搜索”的链接页面元素，使用的是精准匹配方式，也就是说文本内容必须完全匹配，不能多一个字也不能少一个字。第二个xpath语句中使用了以个点. 这里的点等价于text()，都指代的是当前节点的文本内容&lt;/p&gt;
&lt;p&gt;　　xpath表达式3和表达式4等价，都是查找文本内容包含“百度”关键字的链接页面元素，使用的是模糊匹配方式，即可以根据部分文本关键字进行匹配。&lt;/p&gt;
&lt;p&gt;　　xpath表达式5和表达式6等价，都是查找文本内容包含“百度”关键字的链接页面元素a的上层父元素div，6最后使用了两个点。。，它表示选取当前节点的父节点，等价于preceding::div。&lt;/p&gt;
&lt;p&gt;使用文本内容匹配模式进行定位，为定位复杂元素又提供了一种强大的定位模式，再遇到定位困难时，可以优先考虑使用此方式进行定位。建议大家对此定位方式进行练习，一边做到随意定位页面的任意元素。&lt;/p&gt;

&lt;p&gt;总结：好了，以上差不多就时xpath所有的定位方式了，大家可以根据实际工作中遇到的不同问题选择不同的定位方式。 如果文中有错误请留言指出，大家一起学习一起进步，欢迎多多指教！最后再说一句，实践出真知，多看多学多练多写，没有谁出生就是大牛，得经过漫长的岁月慢慢挤奶才变成大牛！哈哈&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 05:29:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>被测试网页的HTML代码 &lt;html&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;text-align:center&amp;quo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-python-selenium-xpath.html</dc:identifier>
</item>
<item>
<title>网络爬虫必备知识之urllib库 - Fate0729</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/10042421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/10042421.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;就库的范围，个人认为网络爬虫必备库知识包括urllib、requests、re、BeautifulSoup、concurrent.futures，接下来将结合爬虫示例分别对urllib库的使用方法进行总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　官方文档地址：&lt;a href=&quot;https://docs.python.org/3/library/urllib.html&quot;&gt;https://docs.python.org/3/library/urllib.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　urllib库是python的内置HTTP请求库，包含以下各个模块内容：&lt;/p&gt;
&lt;p&gt;（1）urllib.request：请求模块&lt;/p&gt;
&lt;p&gt;（2）urllib.error：异常处理模块&lt;/p&gt;
&lt;p&gt;（3）urllib.parse：解析模块&lt;/p&gt;
&lt;p&gt;（4）urllib.robotparser：robots.txt解析模块&lt;/p&gt;
&lt;p&gt;以下所有示例都以&lt;a href=&quot;http://example.webscraping.com/&quot; target=&quot;_blank&quot;&gt;http://example.webscraping.com/&lt;/a&gt;网站为目标，网站预览：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130094236602-1236743436.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）函数原型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
def urlopen(&lt;span&gt;url&lt;/span&gt;, &lt;span&gt;data=None&lt;/span&gt;, &lt;span&gt;timeout=&lt;/span&gt;&lt;span&gt;&lt;span&gt;socket._GLOBAL_DEFAULT_TIMEOUT&lt;/span&gt;,
            &lt;/span&gt;*, cafile=None, capath=None, cadefault=False, context=None):
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该函数功能简单，进行简单的网站请求，不支持复杂功能如验证、cookie和其他HTTP高级功能，若要支持这些功能必须使用build_opener()函数返回的OpenerDirector对象，后面介绍，埋个伏笔&lt;/p&gt;
&lt;p&gt;（2）先写个简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import urllib.request
        
url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://example.webscraping.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
response &lt;/span&gt;= urllib.request.urlopen(url,timeout=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http status:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, response.status)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130101710187-1467583017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）data参数使用&lt;/p&gt;
&lt;p&gt;　　data参数用于post请求，比如表单提交，如果没有data参数则是get请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import urllib.parse
import urllib.request

data &lt;/span&gt;= urllib.parse.urlencode({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print(data)
response &lt;/span&gt;= urllib.request.urlopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;data)
print(response.read())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130103700236-1519152577.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;85&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　首先解释下urlencode的用法，将key-value的键值对转换为我们想要的格式，返回的是a=1&amp;amp;b=2这样的字符串，解码使用unquote()，应为urltilib没有提供urldecode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
data1 = urllib.parse.urlencode({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print(data1)
data2 &lt;/span&gt;= urllib.parse.unquote(data1.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(data2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130104151111-1798299195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）timeout参数&lt;/p&gt;
&lt;p&gt;　　在某些网络情况不好或服务器出现异常的情况下，这个时候我们需要设置一个超时时间，否则程序会一直等待下去&lt;/p&gt;
&lt;p&gt;（5）urlopen函数返回响应对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
response = urllib.request.urlopen(url,timeout=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; response.__dict__.items():
    print(key,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130104857617-764669456.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　返回&amp;lt;class 'http.client.httpresponse'=&quot;&quot;&amp;gt;对象，我们可以response.status获取返回状态，response.read()获得响应题的内容　&lt;/p&gt;

&lt;p&gt;　　前面说过了urlopen不支持headers、cookie和HTTP的高级用法，那解决的方法就是使用build_opener()函数来定义自己的opener对象&lt;/p&gt;
&lt;p&gt;（1）函数原型&lt;/p&gt;
&lt;p&gt;　　build_opener([handler1[,headler2[,....]]])&lt;/p&gt;
&lt;p&gt;　　参数都是特殊处理程序对象的实例，下表列出了所有可用的处理程序对象：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;CacheFTPHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;具有持久FTP连续的FTP处理程序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;FileHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;打开本地文件&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;FTPHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通过FTP打开URL&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HTTPBasicAuthHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基本的HTTP验证处理&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;HTTPCookieProcessor&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;处理HTTP cookie&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HTTPDefaultErrorHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通过引发HTTPError异常来处理HTTP错误&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;HTTPDigestAuthHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HTTP摘要验证处理&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;HTTPHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通过HTTP打开URL&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;HTTPRedirectHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;处理HTTP重定向&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HTTPSHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通过安全HTTP打开url&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;ProxyHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;通过代理重定向请求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;ProxyBasicAuthHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基本的代理验证&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;ProxyDigestAuthHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;摘要代理验证&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;UnknownHandler&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;处理所有未知URL的处理程序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;（2）opener对象创建&lt;/p&gt;
&lt;p&gt; 　   这里以设置cookie和添加代理服务器为例进行说明&lt;/p&gt;
&lt;p&gt;　　有时候爬取网站需要携带cookie信息访问，这个时候需要设置cookie，同时大多数网站都会检测某一段事件某个IP的访问次数，如果访问次数过多，它会禁止你的访问，这个时候需要设置代理服务器来爬取数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
proxy =&lt;span&gt; urllib.request.ProxyHandler(
    {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:9743&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://127.0.0.1:9743&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    })
        
cjar &lt;/span&gt;=&lt;span&gt; http.cookiejar.CookieJar()
opener &lt;/span&gt;= urllib.request.build_opener(urllib.request.HTTPHandler, urllib.request.HTTPCookieProcessor(cjar))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）headers设置&lt;/p&gt;
&lt;p&gt;　　headers即为请求头，很多网站为了防止程序爬虫爬网站照成网站瘫痪，会需要携带一些headers头部信息才能访问，最常见的是user-agent参数&lt;/p&gt;
&lt;p&gt;　　打开网站，按F12，点网络我们会看到下面内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130111024433-708915972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
headers =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0)Gecko/20100101 Firefox/63.0)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example.webscraping.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　header的设置这里介绍两种方法：&lt;/p&gt;
&lt;p&gt;　　a. 通过urllib.request.Request对象　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
request = urllib.request.Request(url,headers=headers)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b. 通过OpenerDirector对象的add_headers属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
headers =&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example.webscraping.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}    
        
    cjar &lt;/span&gt;=&lt;span&gt; http.cookiejar.CookieJar()
    opener &lt;/span&gt;=&lt;span&gt; urllib.request.build_opener(urllib.request.HTTPHandler,urllib.request.HTTPCookieProcessor(cjar))
    header_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; headers.items():
        header_list.append(key)
        header_list.append(value)
    opener.add_handler &lt;/span&gt;= [header_list]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （4）OpenDirector的open()函数&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　里面有一部分代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(fullurl, str):
   req &lt;/span&gt;=&lt;span&gt; Request(fullurl, data)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
   req &lt;/span&gt;=&lt;span&gt; fullurl
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; data &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not None:
      req.data &lt;/span&gt;= data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明fullurl既可以是url，也可以是urllib.request.Request对象&lt;/p&gt;
&lt;p&gt;　　使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
request =&lt;span&gt; urllib.request.Request(url)
response &lt;/span&gt;= opener.open(request, timeout=&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 综合代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def DownLoad(url):
    headers &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example.webscraping.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}    
    
    proxy &lt;/span&gt;=&lt;span&gt; urllib.request.ProxyHandler(
        {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:9743&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://127.0.0.1:9743&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        })

    cjar &lt;/span&gt;=&lt;span&gt; http.cookiejar.CookieJar()
    opener &lt;/span&gt;=&lt;span&gt; urllib.request.build_opener(urllib.request.HTTPHandler,urllib.request.HTTPCookieProcessor(cjar))
    header_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; headers.items():
        header_list.append(key)
        header_list.append(value)
    opener.add_handler &lt;/span&gt;=&lt;span&gt; [header_list]
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        request &lt;/span&gt;=&lt;span&gt; urllib.request.Request(url)
        response &lt;/span&gt;= opener.open(request, timeout=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        print(response.__dict__)
    except urllib.error.URLError &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; e:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTPErro:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.code)
        elif hasattr(e, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;URLErro:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, e.reason)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　很多时候我们通过程序访问网页的时候，有的页面可能会出错，类似404，500的错误，这个时候就需要我们捕获异常，从上面的最后代码已经看到了urllib.error的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
except urllib.error.URLError &lt;span&gt;as&lt;/span&gt;&lt;span&gt; e:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTPErro:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.code)
    elif hasattr(e, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        print (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;URLErro:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, e.reason)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　HTTPError是URLError的子类&lt;/p&gt;
&lt;p&gt;　　URLError里只有一个属性：reason,即抓异常的时候只能打印错误信息，类似上面的例子&lt;/p&gt;
&lt;p&gt;　　HTTPError里有三个属性：code,reason,headers，即抓异常的时候可以获得code,reson，headers三个信息&lt;/p&gt;

&lt;p&gt;　　前面已经介绍过了urllib.parse.urlencode的使用，接下来再介绍三个函数：urlparse、urlunparse、urljoin&lt;/p&gt;
&lt;p&gt;（1）urlparse&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
def urlparse(url, scheme=&lt;span&gt;''&lt;/span&gt;, allow_fragments=True):
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Parse a URL into 6 components:&lt;/span&gt;
    &amp;lt;scheme&amp;gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;netloc&amp;gt;/&amp;lt;path&amp;gt;;&amp;lt;params&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;&lt;/span&gt;
    Return a &lt;span&gt;6&lt;/span&gt;-tuple: (scheme, netloc, path, &lt;span&gt;params&lt;/span&gt;&lt;span&gt;, query, fragment).
    Note that we don&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t break the components up in smaller bits&lt;/span&gt;
    (e.g. netloc &lt;span&gt;is&lt;/span&gt; a single &lt;span&gt;string&lt;/span&gt;) and we don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t expand % escapes.&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　意思就的对你传入的url进行拆分，包括协议，主机地址，端口，路径，字符串，参数，查询，片段&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130121701441-1292615089.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;32&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;protocol 协议，常用的协议是http&lt;/li&gt;
&lt;li&gt;hostname 主机地址，可以是域名，也可以是IP地址&lt;/li&gt;
&lt;li&gt;port 端口 http协议默认端口是：80端口，如果不写默认就是:80端口&lt;/li&gt;
&lt;li&gt;path 路径 网络资源在服务器中的指定路径&lt;/li&gt;
&lt;li&gt;parameter 参数 如果要向服务器传入参数，在这部分输入&lt;/li&gt;
&lt;li&gt;query 查询字符串 如果需要从服务器那里查询内容，在这里编辑&lt;/li&gt;
&lt;li&gt;fragment 片段 网页中可能会分为不同的片段，如果想访问网页后直接到达指定位置，可以在这部分设置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）urlunparse&lt;/p&gt;
&lt;p&gt;　　功能和urlparse功能相反，用于将各组成成分拼接成URL&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def urlunparse(components):
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; urllib.parse import urlunparse

print(urlunparse((&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a=123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130123324386-2011416888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）urljoin&lt;/p&gt;
&lt;p&gt;　　函数的作用就是url拼接，后面的优先级高于前面&lt;/p&gt;
&lt;p&gt;　　函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
def urljoin(&lt;span&gt;base&lt;/span&gt;, url, allow_fragments=&lt;span&gt;True):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Join a base URL and a possibly relative URL to form an absolute&lt;/span&gt;
    interpretation of the latter.&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; urllib.parse import urljoin

print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FAQ.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://pythonsite.com/FAQ.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/about.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://pythonsite.com/FAQ.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/about.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://pythonsite.com/FAQ.html?question=2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com?wd=abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://pythonsite.com/index.php&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?category=2#comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?category=2#comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(urljoin(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.baidu.com#comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?category=2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130123616721-1121157109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　该模块用于robots.txt内容解析&lt;/p&gt;
&lt;p&gt; 　　例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; urllib.robotparser import RobotFileParser

rp &lt;/span&gt;=&lt;span&gt; RobotFileParser()
rp.set_url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://example.webscraping.com/robots.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print(rp.read())
url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://example.webscraping.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
user_agent &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BadCrawler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
print(rp.can_fetch(user_agent,url))
user_agent &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GoodCrawler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
print(rp.can_fetch(user_agent,url))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201811/1117865-20181130124719190-1022510109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 04:49:00 +0000</pubDate>
<dc:creator>Fate0729</dc:creator>
<og:description>1. urllib库全局内容 官方文档地址：https://docs.python.org/3/library/urllib.html urllib库是python的内置HTTP请求库，包含以下各个模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobingqianrui/p/10042421.html</dc:identifier>
</item>
<item>
<title>下拉框click事件与搜索框blur事件的爱恨纠葛 - 十年雪落</title>
<link>http://www.cnblogs.com/maopixin/p/10043449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maopixin/p/10043449.html</guid>
<description>&lt;h2&gt;还原车祸现场&lt;/h2&gt;
&lt;p&gt;功能类似于百度搜索，搜索框输入内容，下拉框显示候选项，点击候选项就选择候选项，然后下拉框隐藏，点击外面就直接隐藏下拉框，于是我写了以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参会单位联想&lt;/span&gt;
$('input[name=&quot;company_name&quot;]').bind('input propertychange', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    clearTimeout(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.timer);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.ajax({
            url:domin&lt;/span&gt;+'/api/company/index'&lt;span&gt;,
            data:{
                k:_this.value
            },
            dataType:&lt;/span&gt;'jsonp'&lt;span&gt;,
            success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.status.code==0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.data.length&amp;lt;=0) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &quot;&quot;&lt;span&gt;;
                    res.data.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e,i){
                        str &lt;/span&gt;+= '&amp;lt;dd data-value=&quot;'+e.id+'&quot; data-type=&quot;'+e.role_code+'&quot; class=&quot;&quot;&amp;gt;'+e.name+'&amp;lt;/dd&amp;gt;'&lt;span&gt;;
                    })
                    $(&lt;/span&gt;'#company_list'&lt;span&gt;).html(str);
                    $(_this).parent().addClass(&lt;/span&gt;'layui-form-selected'&lt;span&gt;);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    form.val(&lt;/span&gt;&quot;beforehand&quot;&lt;span&gt;, {
                        &lt;/span&gt;&quot;company-type&quot;: &quot;&quot;&lt;span&gt;,
                    });
                }
            }
        })
    }, &lt;/span&gt;1000&lt;span&gt;);
    $(&lt;/span&gt;'#company_list').on('click','dd',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        _this.value &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerHTML;
        postData.company_id &lt;/span&gt;= $(&lt;span&gt;this&lt;/span&gt;).data('value'&lt;span&gt;);
        form.val(&lt;/span&gt;&quot;beforehand&quot;&lt;span&gt;, {
            &lt;/span&gt;&quot;company-type&quot;: company_type[$(&lt;span&gt;this&lt;/span&gt;).data('type')]?company_type[$(&lt;span&gt;this&lt;/span&gt;).data('type')]:&quot;普通&quot;&lt;span&gt;,
        });
        $(_this).parent().removeClass(&lt;/span&gt;'layui-form-selected'&lt;span&gt;);
        $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).parent().html(''&lt;span&gt;);
        isSelect &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    })
});
$(&lt;/span&gt;'input[name=&quot;company_name&quot;]').blur(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
　　$(&lt;/span&gt;'input[name=&quot;company_name&quot;]').parent().removeClass('layui-form-selected'&lt;span&gt;);
})&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先去请求数据，然后渲染列表，然后监听候选项点击，最后blur的时候隐藏下拉框，觉得自己写的很完美，于是便兴冲冲的去测试，但是一测试我发现了大问题，在我点击列表项也就是 &lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt; 的时候，下拉框直接隐藏了，候选项的内容也没有被填到input里面去。我便很费解，于是便去找度娘玩耍，众说纷纭，我在很多胡扯的评论中终于找到了。总结如下，看看完整的步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点击 &lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt; ，此时先触发 &lt;span class=&quot;cnblogs_code&quot;&gt;mousedown&lt;/span&gt; &lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;input&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;blur&lt;/span&gt; 触发&lt;/li&gt;
&lt;li&gt;下拉框消失&lt;/li&gt;
&lt;li&gt;此时鼠标抬起并不是在下拉框上&lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;click&lt;/span&gt; 并没有触发&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决方案&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;监听的&lt;span class=&quot;cnblogs_code&quot;&gt;document&lt;/span&gt;的&lt;span class=&quot;cnblogs_code&quot;&gt;mouseup&lt;/span&gt;而不是&lt;span class=&quot;cnblogs_code&quot;&gt;input&lt;/span&gt;的&lt;span class=&quot;cnblogs_code&quot;&gt;blur&lt;/span&gt;事件，这样先触发&lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt;的&lt;span class=&quot;cnblogs_code&quot;&gt;mouseup&lt;/span&gt;，此时数据就已经取到，然后冒泡到&lt;span class=&quot;cnblogs_code&quot;&gt;document&lt;/span&gt;，移除下拉框（类似于百度搜索）&lt;/li&gt;
&lt;li&gt;监听&lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt;的&lt;span class=&quot;cnblogs_code&quot;&gt;mousedown&lt;/span&gt;，这也会先取值，然后&lt;span class=&quot;cnblogs_code&quot;&gt;input&lt;/span&gt;再失焦（体验不太好，用户按下就会触发，不允许纠结，比如我按下第一个的时候，突然想选择第二个）&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;dd&lt;/span&gt;还是，input还是blur，全局定义一个&lt;span class=&quot;cnblogs_code&quot;&gt;isSelect&lt;/span&gt;变量，监听&lt;span class=&quot;cnblogs_code&quot;&gt;dl&lt;/span&gt;的&lt;span class=&quot;cnblogs_code&quot;&gt;mousedown&lt;/span&gt; 触发以后修改&lt;span class=&quot;cnblogs_code&quot;&gt;isSelect = &lt;span&gt;true&lt;/span&gt;&lt;/span&gt; ，这样在&lt;span class=&quot;cnblogs_code&quot;&gt;blur&lt;/span&gt;时，先判断&lt;span class=&quot;cnblogs_code&quot;&gt;isSelect&lt;/span&gt; 就好了。（代码如下）&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; isSelect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; some code&lt;/span&gt;
    $('#company_list').on('click','dd',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　_this.value &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerHTML;
　　　　postData.company_id &lt;/span&gt;= $(&lt;span&gt;this&lt;/span&gt;).data('value'&lt;span&gt;);
　　　　form.val(&lt;/span&gt;&quot;beforehand&quot;&lt;span&gt;, {
&lt;/span&gt;　　　　　　&quot;company-type&quot;: company_type[$(&lt;span&gt;this&lt;/span&gt;).data('type')]?company_type[$(&lt;span&gt;this&lt;/span&gt;).data('type')]:&quot;普通&quot;&lt;span&gt;,
　　　　});
　　　　$(_this).parent().removeClass(&lt;/span&gt;'layui-form-selected'&lt;span&gt;);
　　　　$(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).parent().html(''&lt;span&gt;);
　　　　isSelect &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;
&lt;span&gt;　　})&lt;br/&gt;// some code&lt;br/&gt;// 以下为新增
&lt;/span&gt;$('#company_list').mousedown(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 下拉框mousedown时，保存下拉框为真&lt;/span&gt;
　　isSelect = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 注册定时器 0毫秒以后触发，在定时器触发之前 ，input 的失焦事件触发此时isSelect为真&lt;/span&gt;
　　setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;　　　　//&lt;/span&gt;&lt;span&gt; 此时input的失焦已经触发了&lt;/span&gt;
　　　　isSelect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
　　　　$(&lt;/span&gt;'input[name=&quot;company_name&quot;]'&lt;span&gt;).focus()
　　},&lt;/span&gt;0&lt;span&gt;)
})
$(&lt;/span&gt;'input[name=&quot;company_name&quot;]').blur(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
&lt;/span&gt;&lt;span&gt;　　if&lt;/span&gt;(!isSelect){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;
　　　　$('input[name=&quot;company_name&quot;]').parent().removeClass('layui-form-selected'&lt;span&gt;);
　　}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 虽然 &lt;span class=&quot;cnblogs_code&quot;&gt;setTimeout&lt;/span&gt; 是0毫秒的延迟，但是他在下一次的事件队列中，所以会先执行 &lt;span class=&quot;cnblogs_code&quot;&gt;input&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;blur&lt;/span&gt; 事件，再执行 &lt;span class=&quot;cnblogs_code&quot;&gt;setTimeout&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;有关事件循环 &lt;span class=&quot;cnblogs_code&quot;&gt;EventLoop&lt;/span&gt; 的知识，大家可以自行百度，理解了这个，虽然不会让你写代码变厉害，但是对理解js是有很大的作用的。不过想彻底理解，需要理解宏任务 &lt;span class=&quot;cnblogs_code&quot;&gt;task&lt;/span&gt; 与微任务 &lt;span class=&quot;cnblogs_code&quot;&gt;Microtasks&lt;/span&gt; ，以及 &lt;span class=&quot;cnblogs_code&quot;&gt;Promise&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;下次可能会写一下关于 &lt;span class=&quot;cnblogs_code&quot;&gt;EventLoop&lt;/span&gt; 的东西。&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 04:20:00 +0000</pubDate>
<dc:creator>十年雪落</dc:creator>
<og:description>还原车祸现场 功能类似于百度搜索，搜索框输入内容，下拉框显示候选项，点击候选项就选择候选项，然后下拉框隐藏，点击外面就直接隐藏下拉框，于是我写了以下代码 先去请求数据，然后渲染列表，然后监听候选项点击</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maopixin/p/10043449.html</dc:identifier>
</item>
<item>
<title>SpringBoot-MongoDB 索引冲突分析及解决 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10043447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10043447.html</guid>
<description>&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;spring-data-mongo 实现了基于 MongoDB 的 &lt;strong&gt;ORM-Mapping&lt;/strong&gt; 能力，&lt;br/&gt;通过一些简单的注解、Query封装以及工具类，就可以通过对象操作来实现集合、文档的增删改查；&lt;br/&gt;在 SpringBoot 体系中，spring-data-mongo 是 MongoDB Java 工具库的不二之选。&lt;/p&gt;
&lt;h2 id=&quot;二问题产生&quot;&gt;二、问题产生&lt;/h2&gt;
&lt;p&gt;在一次项目问题的追踪中，发现SpringBoot 应用启动失败，报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error creating bean with name 'mongoTemplate' defined in class path resource [org/bootfoo/BootConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.mongodb.core.MongoTemplate]: Factory method 'mongoTemplate' threw exception; nested exception is org.springframework.dao.DataIntegrityViolationException: Cannot create index for 'deviceId' in collection 'T_MDevice' with keys '{ &quot;deviceId&quot; : 1}' and options '{ &quot;name&quot; : &quot;deviceId&quot;}'. Index already defined as '{ &quot;v&quot; : 1 , &quot;unique&quot; : true , &quot;key&quot; : { &quot;deviceId&quot; : 1} , &quot;name&quot; : &quot;deviceId&quot; , &quot;ns&quot; : &quot;appdb.T_MDevice&quot;}'.; nested exception is com.mongodb.MongoCommandException: Command failed with error 85: 'exception: Index with name: deviceId already exists with different options' on server 127.0.0.1:27017. The full response is { &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 6, &quot;errmsg&quot; : &quot;exception: Index with name: deviceId already exists with different options&quot;, &quot;code&quot; : 85, &quot;ok&quot; : 0.0 }
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588)
    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)
    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)
    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)

...

Caused by: org.springframework.dao.DataIntegrityViolationException: Cannot create index for 'deviceId' in collection 'T_MDevice' with keys '{ &quot;deviceId&quot; : 1}' and options '{ &quot;name&quot; : &quot;deviceId&quot;}'. Index already defined as '{ &quot;v&quot; : 1 , &quot;unique&quot; : true , &quot;key&quot; : { &quot;deviceId&quot; : 1} , &quot;name&quot; : &quot;deviceId&quot; , &quot;ns&quot; : &quot;appdb.T_MDevice&quot;}'.; nested exception is com.mongodb.MongoCommandException: Command failed with error 85: 'exception: Index with name: deviceId already exists with different options' on server 127.0.0.1:27017. The full response is { &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 6, &quot;errmsg&quot; : &quot;exception: Index with name: deviceId already exists with different options&quot;, &quot;code&quot; : 85, &quot;ok&quot; : 0.0 }
    at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.createIndex(MongoPersistentEntityIndexCreator.java:157)
    at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForAndCreateIndexes(MongoPersistentEntityIndexCreator.java:133)
    at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForIndexes(MongoPersistentEntityIndexCreator.java:125)
    at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.&amp;lt;init&amp;gt;(MongoPersistentEntityIndexCreator.java:91)
    at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.&amp;lt;init&amp;gt;(MongoPersistentEntityIndexCreator.java:68)
    at org.springframework.data.mongodb.core.MongoTemplate.&amp;lt;init&amp;gt;(MongoTemplate.java:229)
    at org.bootfoo.BootConfiguration.mongoTemplate(BootConfiguration.java:121)
    at org.bootfoo.BootConfiguration$$EnhancerBySpringCGLIB$$1963a75.CGLIB$mongoTemplate$2(&amp;lt;generated&amp;gt;)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
    at java.lang.reflect.Method.invoke(Unknown Source)
    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
    ... 58 more

Caused by: com.mongodb.MongoCommandException: Command failed with error 85: 'exception: Index with name: deviceId already exists with different options' on server 127.0.0.1:27017. The full response is { &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 6, &quot;errmsg&quot; : &quot;exception: Index with name: deviceId already exists with different options&quot;, &quot;code&quot; : 85, &quot;ok&quot; : 0.0 }
    at com.mongodb.connection.ProtocolHelper.getCommandFailureException(ProtocolHelper.java:115)
    at com.mongodb.connection.CommandProtocol.execute(CommandProtocol.java:114)
    at com.mongodb.connection.DefaultServer$DefaultServerProtocolExecutor.execute(DefaultServer.java:168)


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键信息：&lt;strong&gt;&lt;em&gt;org.springframework.dao.DataIntegrityViolationException: Cannot create index&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从异常信息上看，出现的是索引冲突(&lt;strong&gt;Command failed with error 85&lt;/strong&gt;)，spring-data-mongo 组件在程序启动时会实现根据注解创建索引的功能。&lt;br/&gt;查看业务实体定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Document(collection = &quot;T_MDevice&quot;)
public class MDevice {

    @Id
    private String id;

    @Indexed(unique=true)
    private String deviceId;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;deviceId 这个字段上定义了一个索引，&lt;strong&gt;unique=true&lt;/strong&gt;表示这是一个唯一索引。&lt;br/&gt;我们继续 查看 MongoDB中表的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.getCollection('T_MDevice').getIndexes()

&amp;gt;&amp;gt;
[
    {
        &quot;v&quot; : 1,
        &quot;key&quot; : {
            &quot;_id&quot; : 1
        },
        &quot;name&quot; : &quot;_id_&quot;,
        &quot;ns&quot; : &quot;appdb.T_MDevice&quot;
    },
    {
        &quot;v&quot; : 1,
        &quot;key&quot; : {
            &quot;deviceId&quot; : 1
        },
        &quot;name&quot; : &quot;deviceId&quot;,
        &quot;ns&quot; : &quot;appdb.T_MDevice&quot;
    }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现数据库表中同样存在一个名为 deviceId的索引，但是并非唯一索引！&lt;/p&gt;
&lt;h2 id=&quot;三详细分析&quot;&gt;三、详细分析&lt;/h2&gt;
&lt;p&gt;为了核实错误产生的原因，我们尝试通过 Mongo Shell去执行索引的创建，发现返回了同样的错误。&lt;br/&gt;通过将数据库中的索引删除，或更正为 &lt;strong&gt;unique=true&lt;/strong&gt; 之后可以解决当前的问题。&lt;/p&gt;
&lt;p&gt;从严谨度上看，一个索引冲突导致 SpringBoot 服务启动不了，是可以接受的。&lt;br/&gt;但从灵活性来看，是否有某些方式能&lt;strong&gt;禁用索引的自动创建&lt;/strong&gt;，或者仅仅是打印日志呢？&lt;/p&gt;
&lt;p&gt;尝试 google &lt;strong&gt;spring data mongodb disable index creation&lt;/strong&gt;&lt;br/&gt;发现 &lt;a href=&quot;https://jira.spring.io/browse/DATAMONGO-1201&quot;&gt;JIRA-DATAMONGO-1201&lt;/a&gt;在2015年就已经提出，至今未解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181130121848856-882268010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图&lt;/p&gt;
&lt;p&gt;stackoverflow 找到许多&lt;a href=&quot;https://stackoverflow.com/questions/41394711/mongodb-prevent-index-auto-creation&quot;&gt;同样问题&lt;/a&gt;，&lt;br/&gt;但大多数的解答是不采用索引注解，选择其他方式对索引进行管理。&lt;/p&gt;
&lt;p&gt;这些结果并不能令人满意。&lt;/p&gt;
&lt;p&gt;尝试查看 spring-data-mongo 的机制，定位到 &lt;strong&gt;MongoPersistentEntityIndexCreator&lt;/strong&gt;类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化方法中，会根据 MappingContext(实体映射上下文)中已有的实体去创建索引&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public MongoPersistentEntityIndexCreator(MongoMappingContext mappingContext, MongoDbFactory mongoDbFactory,
            IndexResolver indexResolver) {
        ...
        //根据已有实体创建
        for (MongoPersistentEntity&amp;lt;?&amp;gt; entity : mappingContext.getPersistentEntities()) {
            checkForIndexes(entity);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在接收到MappingContextEvent时，创建对应实体的索引&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    public void onApplicationEvent(MappingContextEvent&amp;lt;?, ?&amp;gt; event) {

        if (!event.wasEmittedBy(mappingContext)) {
            return;
        }

        PersistentEntity&amp;lt;?, ?&amp;gt; entity = event.getPersistentEntity();

        // Double check type as Spring infrastructure does not consider nested generics
        if (entity instanceof MongoPersistentEntity) {
            //创建单个实体索引
            checkForIndexes((MongoPersistentEntity&amp;lt;?&amp;gt;) entity);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MongoPersistentEntityIndexCreator&lt;/strong&gt;是通过MongoTemplate引入的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public MongoTemplate(MongoDbFactory mongoDbFactory, MongoConverter mongoConverter) {

        Assert.notNull(mongoDbFactory);

        this.mongoDbFactory = mongoDbFactory;
        this.exceptionTranslator = mongoDbFactory.getExceptionTranslator();
        this.mongoConverter = mongoConverter == null ? getDefaultMongoConverter(mongoDbFactory) : mongoConverter;
        ...

        // We always have a mapping context in the converter, whether it's a simple one or not
        mappingContext = this.mongoConverter.getMappingContext();
        // We create indexes based on mapping events
        if (null != mappingContext &amp;amp;&amp;amp; mappingContext instanceof MongoMappingContext) {
            indexCreator = new MongoPersistentEntityIndexCreator((MongoMappingContext) mappingContext, mongoDbFactory);
            eventPublisher = new MongoMappingEventPublisher(indexCreator);
            if (mappingContext instanceof ApplicationEventPublisherAware) {
                ((ApplicationEventPublisherAware) mappingContext).setApplicationEventPublisher(eventPublisher);
            }
        }
    }


    ...
    //MongoTemplate实现了 ApplicationContextAware，当ApplicationContext被实例化时被感知
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {

        prepareIndexCreator(applicationContext);

        eventPublisher = applicationContext;
        if (mappingContext instanceof ApplicationEventPublisherAware) {
            //MappingContext作为事件来源，向ApplicationContext发布
            ((ApplicationEventPublisherAware) mappingContext).setApplicationEventPublisher(eventPublisher);
        }
        resourceLoader = applicationContext;
    }

    ...
    //注入事件监听
    private void prepareIndexCreator(ApplicationContext context) {

        String[] indexCreators = context.getBeanNamesForType(MongoPersistentEntityIndexCreator.class);

        for (String creator : indexCreators) {
            MongoPersistentEntityIndexCreator creatorBean = context.getBean(creator, MongoPersistentEntityIndexCreator.class);
            if (creatorBean.isIndexCreatorFor(mappingContext)) {
                return;
            }
        }

        if (context instanceof ConfigurableApplicationContext) {
            //使 IndexCreator 监听 ApplicationContext的事件
            ((ConfigurableApplicationContext) context).addApplicationListener(indexCreator);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，&lt;strong&gt;MongoTemplate&lt;/strong&gt;在初始化时，先通过&lt;strong&gt;MongoConverter&lt;/strong&gt; 带入 MongoMappingContext，&lt;br/&gt;随后完成一系列初始化，整个过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化 MongoTemplate;&lt;/li&gt;
&lt;li&gt;实例化 MongoConverter;&lt;/li&gt;
&lt;li&gt;实例化 MongoPersistentEntityIndexCreator；&lt;/li&gt;
&lt;li&gt;初始化索引(通过MappingContext已有实体);&lt;/li&gt;
&lt;li&gt;Repository初始化 -&amp;gt; MappingContext 发布映射事件；&lt;/li&gt;
&lt;li&gt;ApplicationContext 将事件通知到 IndexCreator；&lt;/li&gt;
&lt;li&gt;IndexCreator 创建索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实例化过程中，没有任何配置可以阻止索引的创建。&lt;/p&gt;
&lt;h2 id=&quot;四解决问题&quot;&gt;四、解决问题&lt;/h2&gt;
&lt;p&gt;从前面的分析中，可以发现问题关键在 IndexCreator，能否提供一个自定义的实现呢，答案是可以的！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现的要点如下&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现一个IndexCreator，可继承MongoPersistentEntityIndexCreator，去掉索引的创建功能；&lt;/li&gt;
&lt;li&gt;实例化 MongoConverter和 MongoTemplate时，使用一个空的 MongoMappingContext对象避免初始化索引；&lt;/li&gt;
&lt;li&gt;将自定义的IndexCreator作为Bean进行注册，这样在prepareIndexCreator方法执行时，&lt;br/&gt;原来的 MongoPersistentEntityIndexCreator不会监听ApplicationContext的事件&lt;/li&gt;
&lt;li&gt;IndexCreator 实现了ApplicationContext监听，接管 MappingEvent事件处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实例化Bean&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Bean
    public MongoMappingContext mappingContext() {
        return new MongoMappingContext();
    }

    // 使用 MappingContext 实例化 MongoTemplate
    @Bean
    public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoMappingContext mappingContext) {
        MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory),
                mappingContext);
        converter.setTypeMapper(new DefaultMongoTypeMapper(null));

        MongoTemplate mongoTemplate = new MongoTemplate(mongoDbFactory, converter);

        return mongoTemplate;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义IndexCreator&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 自定义IndexCreator实现
    @Component
    public static class CustomIndexCreator extends MongoPersistentEntityIndexCreator {

        // 构造器引用MappingContext
        public CustomIndexCreator(MongoMappingContext mappingContext, MongoDbFactory mongoDbFactory) {
            super(mappingContext, mongoDbFactory);
        }

        public void onApplicationEvent(MappingContextEvent&amp;lt;?, ?&amp;gt; event) {
            PersistentEntity&amp;lt;?, ?&amp;gt; entity = event.getPersistentEntity();

            // 获得Mongo实体类
            if (entity instanceof MongoPersistentEntity) {
                System.out.println(&quot;Detected MongoEntity &quot; + entity.getName());
                
                //可实现索引处理..
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里 CustomIndexCreator继承了&lt;strong&gt;MongoPersistentEntityIndexCreator&lt;/strong&gt;，将自动接管MappingContextEvent事件的监听。&lt;br/&gt;在业务实现上可以根据需要完成索引的处理！&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;spring-data-mongo 提供了非常大的便利性，但在灵活性支持上仍然不足。上述的方法实际上有些隐晦，在官方文档中并未提及这样的方式。&lt;br/&gt;ORM-Mapping 框架在实现Schema映射处理时需要考虑校验级别，比如 Hibernate便提供了 none/create/update/validation 多种选择，毕竟这对开发者来说更加友好。&lt;br/&gt;期待 spring-data-mongo 在后续的演进中能尽快完善 Schema的管理功能！&lt;/p&gt;
</description>
<pubDate>Fri, 30 Nov 2018 04:19:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>一、背景 spring data mongo 实现了基于 MongoDB 的 ORM Mapping 能力， 通过一些简单的注解、Query封装以及工具类，就可以通过对象操作来实现集合、文档的增删改查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10043447.html</dc:identifier>
</item>
</channel>
</rss>