<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>挖一挖MongoDB的备份与还原（实现指定时间点还原和增量备份还原） - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9832333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9832333.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;一  研究背景需求&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;目前作者所在公司的MongoDB数据库是每天凌晨做一次全库完整备份，但数据库出现故障时，只能保证恢复到全备时间点，比如，00:30 做的完整备份，而出现故障是下午18:00，那么现有的备份机制只可以恢复到00:30，即丢失00:30 – 18:00 的操作数据。&lt;/p&gt;
&lt;p&gt;此外，我们现在的副本集没有delay节点，当出现误操作或需要恢复到指定时间点操作时，目前灾备机制也不支持此操作。&lt;strong&gt;上线这种备份方案，心里总是惶惶的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并且细究mongodump机制原理，此命令在运行过程中并不会把数据库锁死（或建立快照，以保证整个库冻结在一个固定的时间点），实现数据库完整性，而是细化到集合级别，如此，会导致&lt;strong&gt;数据完整性问题&lt;/strong&gt;。 例如，集合A中存放了订单概要信息，集合B中存放了订单的所有明细，那么只有一个订单有完整的明细时才是正确的状态。那么备份时，如果备份集合A处于时间点x，而备份集合B处于x之后的一个时间点y时，可以想象A和B中的数据极有可能不对应而失去意义（部分订单有订单明细而没有订单概要信息）。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二  原理分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;关系型数据库，例如MySQL ,SQL Server 都有事务日志（或bin log），会将数据库的&lt;strong&gt;DML&lt;/strong&gt; &lt;strong&gt;、&lt;/strong&gt; DDL、DCL等操作记录在事务文件中,可以通过日志备份搭建还原体系。MongoDB没有此类机制和数据文件，难以实现。&lt;/p&gt;
&lt;p&gt;但MongoDB 副本集 有通过 oplog（主要记录在local数据库oplog.rs集合中） 实现节点间的同步，此集合记录了数据库的OP操作，记录的是整个mongod实例一段时间内的所有变更（插入/更新/删除）操作。&lt;/p&gt;
&lt;p&gt;是否可以考虑通过oplog.rs集合的备份还原来解决以上问题（数据完整性；不能还原到指定时间点；时效性差。）。&lt;/p&gt;
&lt;p&gt;值得注意的是，oplog为replica set或者master/slave模式专用，standalone模式运行mongodb并不推荐。&lt;/p&gt;
&lt;p&gt;查看mongodb备份命令Mongodump，其中有一个相关参数oplog。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Mongodump&lt;/strong&gt; &lt;strong&gt;中&lt;/strong&gt;&lt;strong&gt;--oplog&lt;/strong&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;--oplog&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Use oplog for taking a point-in-time snapshot&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;该参数的主要作用是我们在导出库集合数据的同时生成一个oplog.bson文件，里面存放了开始进行dump到dump结束之间所有的op log 操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022204059487-1011211891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：--oplog选项只对全库导出有效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;相应的 Mongorestore 中与 &lt;span lang=&quot;EN-US&quot;&gt;Oplog 相关的参数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;oplogReplay&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;replay oplog for point-in-time restore&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;oplogLimit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;only include oplog entries before the provided Timestamp&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;oplogFile&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;oplog file to use for replay of oplog&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;strong&gt;三 验证测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1 场景1  备份还原后，如何保证数据一致性、完整性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Insert数据过程中，备份数据库，&lt;/strong&gt;&lt;strong&gt;为说明问题，数据插入跨越整个备份过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.1&lt;/span&gt; 在不使用&lt;/strong&gt;&lt;strong&gt;--oplog&lt;/strong&gt; &lt;strong&gt;参数下备份还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 向数据库ygtest041602插入数据，源库没有集合order0531、orderdetial&lt;/p&gt;
&lt;p&gt;插入语句：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;for(var i = 0; i &amp;lt; 10000; i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.order0531.insert({a: i});};&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;for(i=0;i&amp;lt;300000;i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.orderdetial.insert({&quot;id&quot;:i,&quot;name&quot;:&quot;shenzheng&quot;,&quot;addr&quot;:&quot;&lt;/em&gt;&lt;em&gt;龙岗&quot;,&quot;date&quot;:new Date()}); };&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 2&lt;/strong&gt;  在上述命令执行期间 执行mongodump 备份&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;./mongodump -h 172.177.XXX.XXX --port 端口 --authenticationDatabase admin -u 用户名 -p 密码 --gzip -o /data/mongodb_back/mongotestdump&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022193435875-1358499411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 还原上述备份文件 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;./mongorestore -h 172.177.XXX.XXX --port&lt;/em&gt; &lt;em&gt;端口  --authenticationDatabase admin -u 用户名 -p 密码  --gzip /data/mongodb_back/mongotestdump&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt; 检查源库Insert 语句， 执行完毕（一定是&lt;em&gt;mongodump&lt;/em&gt;完毕，再&lt;em&gt;insert&lt;/em&gt;结束；但不强调，&lt;em&gt;mongorestore&lt;/em&gt;与&lt;em&gt;insert&lt;/em&gt;的时间关系）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 待语句执行完毕后，比较 源库和 还原库 的数据。&lt;/p&gt;
&lt;p&gt;源库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022192931651-759022497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还原库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022192949700-117475165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到集合orderdetial在两个数据库不一致，有差异。即这种备份还原 无法保证数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.2&lt;/span&gt; 增加 参数--oplog 参数下备份还原&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 删除 上次测试中遗留的集合 和 备份文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 启动insert命令&lt;/p&gt;
&lt;p&gt;&lt;em&gt;for(var i = 0; i &amp;lt; 10000; i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.order0531.insert({a: i});};&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;for(i=0;i&amp;lt;150000;i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.orderdetial.insert({&quot;id&quot;:i,&quot;name&quot;:&quot;shenzheng&quot;,&quot;addr&quot;:&quot;&lt;/em&gt;&lt;em&gt;龙岗&quot;,&quot;date&quot;:new Date()}); };&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 执行备份命令&lt;/p&gt;
&lt;p&gt;&lt;em&gt;./mongodump -h 172.177.XXX.XXX --port&lt;/em&gt; &lt;em&gt;端口  &lt;strong&gt;&lt;span&gt;--oplog&lt;/span&gt;&lt;/strong&gt; --authenticationDatabase admin -u 用户名 –p密码  --gzip -o /data/mongodb_back/mongotestdump&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022193246718-1004427286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从打印结果来看，有对oplog命令的输出，查看备份文件 多了一个 oplog.bson 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022193543945-1497972739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt; 执行还原命令，增加参数 &lt;em&gt; &lt;strong&gt;--oplogReplay&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;./mongorestore -h 172.177.XXX.XXX --port&lt;/em&gt; &lt;em&gt;端口  &lt;span&gt;&lt;strong&gt;--oplogReplay&lt;/strong&gt;&lt;/span&gt; --authenticationDatabase admin -u&lt;/em&gt; &lt;em&gt;用户名 –p&lt;/em&gt; &lt;em&gt;密码  --gzip /data/mongodb_back/mongotestdump&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从执行情况来看，此类还原命令有还原oplog&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022193751032-1037335194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 比对数据&lt;/p&gt;
&lt;p&gt;源库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022193821100-717179977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还原库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022231257417-280126116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本场景测试结论:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然结果数据仍不一致，但从后者的备份还原过程可以看出，有对oplog做单独的处理。&lt;/p&gt;
&lt;p&gt;数据可以保证以oplog结尾为准，实现了多集合（表）的时间一致性（MongoDB本身特性，不保证体现数据库的事务一致性）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2 场景二&lt;/span&gt; &lt;/strong&gt; &lt;span&gt;&lt;strong&gt;还原到指定时间点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022205620887-1590547395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用场景3.1.2 的备份文件，测试还原到备份过程中的某个时刻。从上次备份过程可知，开始时间为2018-05-31T&lt;strong&gt;11:13:46&lt;/strong&gt;.501+0800，结束时间为 2018-05-31T&lt;strong&gt;11:14:12&lt;/strong&gt;.961+0800&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194038869-1836800597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此轮测试还原点选择在此时间段内。时间还原点的选择，假如我们还原到orderdetial 集合&quot;_id&quot; : ObjectId(&quot;5b0f6876c52291864d3485b9&quot;)的插入时的时间点。&lt;/p&gt;
&lt;p&gt;查看此时间点对应的时间和操作序列，在源库local中的oplog.rs 集合查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194114789-1124500179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（oplog.rs集合的数据意义，我们在其他章节介绍，在此不做赘述）&lt;/p&gt;
&lt;p&gt;&quot;ts&quot; : Timestamp(1527736438, 858)&lt;/p&gt;
&lt;p&gt;此文档对应的 &quot;id&quot; : 9719.0，插入时间为2018-05-31T&lt;strong&gt;11:13:58&lt;/strong&gt;.721+0800 【正好，在mongodump的过程中】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 删除还原服务器中的还原库（上面测试遗留的数据库）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 执行还原命令，通过--oplogLimit 参数指定时间点，时间点为上一步查到的Timestamp(1527736438, 858)&lt;/p&gt;
&lt;p&gt;./mongorestore -h 172.177.XXX.XXX --port 端口  &lt;strong&gt;&lt;span&gt;--oplogReplay --oplogLimit&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&quot;1527736438:858&quot;&lt;/strong&gt; --authenticationDatabase admin -u 用户名 -p 密码  /data/mongodb_back/mongotestdump&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194334667-1064396593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 结果验证&lt;/p&gt;
&lt;p&gt;从print 出来的执行过程来看，相同的备份文件，相同的还原环境，添加--oplogLimit &quot;1527736438:858&quot; 参数的 replay Oplog，要小于上次不带--oplogLimit参数的全还原。&lt;/p&gt;
&lt;p&gt;本次还原，添加 --oplogLimit，只还原了 824 KB 的oplog&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T16:55:21.975+0800     replaying oplog&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T16:55:22.724+0800     oplog  85.9KB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T16:55:25.720+0800     oplog  575KB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T16:55:27.231+0800     &lt;span&gt;&lt;strong&gt;oplog  842KB&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T16:55:27.231+0800     done&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; &lt;/em&gt;上次，没有添加 --oplogLimit，默认全还原，所以还原了3.22MB oplog。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:33.770+0800     replaying oplog&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:34.682+0800     oplog  146KB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:40.686+0800     oplog  1.10MB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:49.688+0800     oplog  2.61MB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:52.680+0800     oplog  3.11MB&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:53.246+0800     &lt;strong&gt;&lt;span&gt;oplog  3.22MB&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2018-05-31T11:23:53.246+0800     done&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这也容易理解。全还原一定大于指定时间的部分还原。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据检验 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）此时最大ID为&quot;id&quot; : 9718.0，和参数值对应的ID值连续&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194437156-984267873.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（2）此过程共还原数据9719，低于全还原的63862&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194456708-397329778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;本场景测试结论:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用参数--oplogReplay –oplogLimit 可以将数据库还原到指定时刻。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 场景三 &lt;span&gt;&lt;strong&gt;oplog.rs 集合中导出数据进行还原&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在场景2 中的 oplog.bson 是我们在mongodump 全库时，添加参数--&lt;em&gt;oplog&lt;/em&gt;参数后自动生成的&lt;em&gt;。&lt;/em&gt; 全库备份，受限于性能损耗和资源限制，不能高频率执行和长时间存储。考虑到副本集的oplog保存在&lt;/strong&gt;oplog.rs集合中，此轮测试验证是否只从oplog.rs导出，就可以保证数据连续性。即&lt;strong&gt;从oplog.rs导出的数据是否可以替代mongodump过程中产生的oplog.bson.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于我们从oplog.rs集合中导出MySQL的binlog文件，也类似于SQL Server Log日志，可以实现增量备份与增量还原。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; 在上述场景中继续测试，我们已经执行全库还原，只是时间点还原到&quot;id&quot; : 9718.0 对应的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 删除 上次全备过程中产生的备份文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194608832-671850320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 为增加试验效果，再次在源库插入部分数据&lt;/p&gt;
&lt;p&gt;&lt;em&gt;for(var i = 0; i &amp;lt; 10000; i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.order0531.insert({a: i});};&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;for(i=0;i&amp;lt;200000;i++)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{ db.orderdetial.insert({&quot;id&quot;:i,&quot;name&quot;:&quot;shenzheng&quot;,&quot;addr&quot;:&quot;&lt;/em&gt;&lt;em&gt;龙岗&quot;,&quot;date&quot;:new Date()}); };&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 4&lt;/strong&gt; 将数据库local中集合oplog.rs 导出（建议导出时，增加时间参数，例如一小时内的或大于某时间时刻。注意，此处的测试场景中，我们选择的&lt;em&gt;Timestamp(1527552239,1)，&lt;/em&gt;在我们场景2中的&lt;em&gt;Timestamp(1527736438, 858)&lt;/em&gt;的前面，故意时间重叠）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;./mongodump -h 172.177.XXX.XXX --port&lt;/em&gt; &lt;em&gt;端口 --authenticationDatabase admin -u&lt;/em&gt; &lt;em&gt;用户名 -p&lt;/em&gt; &lt;em&gt;密码 -d local -c oplog.rs  --query '{ts:{$gte:Timestamp(1527552239,1)}}' -o /data/mongodb_back/mongotestoplog&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 5&lt;/strong&gt; 将备份产生的文件local/oplog.rs.bson，copy至还原路径下，并将其&lt;strong&gt;命名为oplog.bson&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;cp ./mongotestoplog/local/oplog.rs.bson ./mongotestdump/oplog.bson&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 6&lt;/strong&gt; 执行还原命令&lt;/p&gt;
&lt;p&gt;./mongorestore -h 172.177.XXX.XXX --port 端口  --oplogReplay --authenticationDatabase admin -u 用户名 –p 密码  /data/mongodb_back/mongotestdump&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 7&lt;/strong&gt; 数据验证&lt;/p&gt;
&lt;p&gt;还原库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194718473-370171854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022194739380-131063434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两者数据一致&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本场景测试结论:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）dumprestor 命令，可以接受从别处而来，除了--oplog之外，可人为获取的从oplog.rs中导出；还原时需重命名（step 5）。&lt;/p&gt;
&lt;p&gt;（2）可以实现数据库的增量备份与增量还原。我们可以设置Job，每小时从集合oplog.rs中导出一份操作日志。然后再利用这些文件中进行还原。注意此处的增量，是针对数据变化的，不是针对上次的全库备份。此概念与关系型数据库中的增量备份还原不同，其实更像关系型数据库中的日志备份和还原。&lt;/p&gt;
&lt;p&gt;（3）oplog有一个非常重要的特性——幂等性（idempotent）。即对一个数据集合，使用oplog中记录的操作重放时，无论被重放多少次，其结果会是一样的。举例来说，如果oplog中记录的是一个插入操作，并不会因为你重放了两次，数据库中就得到两条相同的记录。&lt;/p&gt;
&lt;h2&gt;四 总结 &lt;/h2&gt;
&lt;p&gt;1. MongoDB 不支持事务，无法保证备份还原命令中的事务完整性、业务一致性（无关系数型据库中基于事务日志的重做还原机制）。但结合命令参数--oplog，可以实现数据、业务的时间一致性。&lt;/p&gt;
&lt;p&gt;2. 数据库还原时，结合参数--oplogReplay  --oplogLimit实现指定时间点的还原。&lt;/p&gt;
&lt;p&gt;3. 搭建副本集的MongoDB，定期导出oplog.rs,可以实现增量备份与增量还原。&lt;/p&gt;

</description>
<pubDate>Mon, 22 Oct 2018 16:20:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 研究背景需求 目前作者所在公司的MongoDB数据库是每天凌晨做一次全库完整备份，但数据库出现故障时，只能保证恢复到全备时间点，比如，00:30 做的完整备份，而出现故障是下午18:00，那么现有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9832333.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列——7步集成RabbitMQ - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/springboot-rabbitmq.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/springboot-rabbitmq.html</guid>
<description>&lt;p&gt;RabbitMQ是一种我们经常使用的消息中间件，通过RabbitMQ可以帮助我们实现异步、削峰的目的。&lt;/p&gt;
&lt;p&gt;今天这篇，我们来看看Spring Boot是如何集成RabbitMQ，发送消息和消费消息的。同时我们介绍下死信队列。&lt;/p&gt;
&lt;h3 id=&quot;集成rabbitmq&quot;&gt;集成RabbitMQ&lt;/h3&gt;
&lt;p&gt;集成RabbitMQ只需要如下几步即可&lt;/p&gt;
&lt;p&gt;1、添加maven依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;!--rabbitmq--&amp;gt;

&amp;lt;dependency&amp;gt;

    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

    &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;

&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、添加配置文件application.yaml&lt;/p&gt;
&lt;p&gt;在application.yaml添加配置内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:  rabbitmq:
 host: 192.168.1.161
          port: 5672
 username: guest
          password: guest
          cache:
 channel: size: 10
 listener:
 type: simple
 simple:
 acknowledge-mode: auto
 concurrency: 5
 default-requeue-rejected: true
 max-concurrency: 100
 retry:
 enabled: true #                  initial-interval: 1000ms
 max-attempts: 3 #                  max-interval: 1000ms
 multiplier: 1
                  stateless: true #          publisher-confirms: true&amp;lt;/pre&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里最基本的配置只需要配置&lt;code&gt;host&lt;/code&gt;,&lt;code&gt;port&lt;/code&gt;,&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;四个属性即可&lt;/p&gt;
&lt;p&gt;其他属性都有各自的含义，比如&lt;code&gt;retry&lt;/code&gt;是用于配置重试策略的，&lt;code&gt;acknowledge-mode&lt;/code&gt;是配置消息接收确认机制的。&lt;/p&gt;
&lt;p&gt;3、编写配置类&lt;/p&gt;
&lt;p&gt;编写RabbitConfig配置类，采用Java Configuration的方式配置RabbitTemplate、Exchange和Queue等信息，具体如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.jackie.springbootdemo.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import java.util.HashMap;
import java.util.Map;

@Configuration public class RabbitMQConfig implements InitializingBean {   @Autowired
 SimpleRabbitListenerContainerFactory simpleRabbitListenerContainerFactory;

    @Override
 public void afterPropertiesSet() throws Exception {
 simpleRabbitListenerContainerFactory.setMessageConverter(new Jackson2JsonMessageConverter());
    }   @Bean(&quot;jackson2JsonMessageConverter&quot;)
 public Jackson2JsonMessageConverter jackson2JsonMessageConverter(ConnectionFactory connectionFactory) {
 return new Jackson2JsonMessageConverter();
    }   @Bean(&quot;rabbitTemplate&quot;)
 @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
 public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory,
                                         @Qualifier(&quot;jackson2JsonMessageConverter&quot;) Jackson2JsonMessageConverter jackson2JsonMessageConverter) {
 RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(new Jackson2JsonMessageConverter());
        return template;
    }   // --------------------- 声明队列 ------------------------
 @Bean
 public Queue demoQueue() {
 return new Queue(&quot;demo_queue&quot;);
    }   // --------------------- 声明exchange ------------------------   @Bean
 public DirectExchange demoExchange() {
 return new DirectExchange(&quot;demo_exchange&quot;);
    }   // --------------------- 队列绑定 ------------------------
 @Bean
 public Binding bindingAlbumItemCreatedQueue(DirectExchange demoExchange,
                                                Queue demoQueue) {
 return BindingBuilder.bind(demoQueue).to(demoExchange).with(&quot;100&quot;);
    }   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里声明了Direct模式的Exchange，声明一个Queue，并通过&lt;code&gt;routing-key&lt;/code&gt;为100将&lt;code&gt;demo_queue&lt;/code&gt;绑定到&lt;code&gt;demo_exchange&lt;/code&gt;，这样&lt;code&gt;demo_queue&lt;/code&gt;就可以接收到&lt;code&gt;demo_exchange&lt;/code&gt;发送的消息了。&lt;/p&gt;
&lt;p&gt;4、编写消息发送类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.jackie.springbootdemo.message;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.support.CorrelationData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component public class Sender implements RabbitTemplate.ConfirmCallback {   private RabbitTemplate rabbitTemplate;

    /**
 * 构造方法注入 */ @Autowired
 public Sender(RabbitTemplate rabbitTemplate) {
 this.rabbitTemplate = rabbitTemplate;
        rabbitTemplate.setConfirmCallback(this); //rabbitTemplate如果为单例的话，那回调就是最后设置的内容
 }    public void sendMsg(String content) {
 rabbitTemplate.convertAndSend(&quot;demo_exchange&quot;, &quot;100&quot;, content);
    }   /**
 * 回调 */ @Override
 public void confirm(CorrelationData correlationData, boolean ack, String cause) {
 System.out.println(&quot; 回调id:&quot; + correlationData);
        if (ack) {
 System.out.println(&quot;消息成功消费&quot;);
        } else {
 System.out.println(&quot;消息消费失败:&quot; + cause);
        }
 }   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送内容&lt;code&gt;content&lt;/code&gt;，路由到&lt;code&gt;routing-key&lt;/code&gt;为100上，则我们就可以在&lt;code&gt;demo_queue&lt;/code&gt;队列中看到发送的消息内容了&lt;/p&gt;
&lt;p&gt;confirm函数是回调函数，这里因为没有消费者，且&lt;code&gt;acknoledge-mode&lt;/code&gt;是auto(其他两种值分别是none和manual)，所以ack是false。&lt;/p&gt;
&lt;p&gt;5、编写发送消息测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.jackie.springbootdemo;

import com.jackie.springbootdemo.message.Sender;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class) @SpringBootTest(classes = SpringbootDemoApplication.class) @WebAppConfiguration public class RabbitApplicationTests {     @Autowired
 Sender sender;

   @Test
  public void contextLoads() throws Exception {
 sender.sendMsg(&quot;test&quot;);
    } } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行该测试类，我们可以看到如下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181022230325267-678402861.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、编写消息消费类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.springbootdemo.message;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component public class Receiver {   @RabbitListener(queues = &quot;demo_queue&quot;)
 public void created(String message) {
 System.out.println(&quot;orignal message: &quot; + message);
    }   }  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息消费类也非常简单，添加注解@RabbitListener，指定要监听的队列名称即可&lt;/p&gt;
&lt;p&gt;除了注解@RabbitListener，我们经常还能看到@RabbitHandler，这两个注解可以配合起来使用。&lt;/p&gt;
&lt;p&gt;@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型，形如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RabbitListener(queues = &quot;demo_queue&quot;)  public class Receiver {   @RabbitHandler  public void processMessage1(String message) {
 System.out.println(message);
    }   @RabbitHandler
 public void processMessage2(byte[] message) {
 System.out.println(new String(message));
    } }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、运行消息发送测试类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181022230244641-880222534.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从执行结果可以看到，因为有了消费者，所以这次打印的结果是&quot;消息消费成功&quot;&lt;/p&gt;
&lt;p&gt;而且，我们看到Receiver类将消息消费并打印出消息的内容为&quot;test&quot;。&lt;/p&gt;
&lt;p&gt;代码已经提交至项目&lt;a href=&quot;https://github.com/DMinerJackie/rome&quot;&gt;rome&lt;/a&gt;：https://github.com/DMinerJackie/rome&lt;/p&gt;
&lt;p&gt;本来准备再说说死信队列的，限于篇幅，后面再写吧。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 15:09:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>RabbitMQ是一种我们经常使用的消息中间件，通过RabbitMQ可以帮助我们实现异步、削峰的目的。 今天这篇，我们来看看Spring Boot是如何集成RabbitMQ，发送消息和消费消息的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/springboot-rabbitmq.html</dc:identifier>
</item>
<item>
<title>高可用Redis(十一)：使用redis-trib.rb工具搭建集群 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/9833740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/9833740.html</guid>
<description>&lt;p&gt;环境说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;两台虚拟机，IP地址分别为：192.168.81.100和192.168.81.101
虚拟机系统为：CentOS 7.5
Redis为yum安装，版本为3.2
系统环境：关闭firewalld
Redis Cluster集群节点包括：192.168.81.101机器的9000.9001,9002端口运行的redis-server以及192.168.81.100机器的9000.9001,9002端口运行的redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;h3 id=&quot;ruby环境准备&quot;&gt;1.Ruby环境准备&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;官网下载Ruby源码包，解压，编译，安装，进行软链接&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ruby环境安装redis模块&quot;&gt;2.Ruby环境安装redis模块&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ruby_package]# ruby -v              # ruby安装完成，查看版本
ruby 2.3.7p456 (2018-03-28 revision 63024) [x86_64-linux]
[root@mysql ruby_package]# gem install redis    # 安装ruby操作redis模块
Successfully installed redis-4.0.2
Parsing documentation for redis-4.0.2
Done installing documentation for redis after 0 seconds
1 gem installed
[root@mysql ruby_package]# gem list -- check    # 查看ruby环境已经安装的模块

*** LOCAL GEMS ***

bigdecimal (1.2.8)
did_you_mean (1.0.0)
io-console (0.4.5)
json (1.8.3.1)
minitest (5.8.5)
net-telnet (0.1.1)
power_assert (0.2.6)
psych (2.1.0.1)
rake (10.4.2)
rdoc (4.2.1)
redis (4.0.2, 3.3.0)
test-unit (3.1.5)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取redis-trib.rb工具&quot;&gt;3.获取redis-trib.rb工具&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ruby_package]# rz       # 从Redis官网下载Redis安装包，并上传到虚拟机中
rz waiting to receive.
Starting zmodem transfer.  Press Ctrl+C to cancel.
Transferring redis-3.2.12.tar.gz...
  100%    1515 KB    1515 KB/sec    00:00:01       0 Errors  

[root@mysql ruby_package]# ls
redis-3.2.12.tar.gz  ruby-2.3.7  ruby-2.3.7.tar.gz  rubygems-2.7.7.zip
[root@mysql ruby_package]# tar xf redis-3.2.12.tar.gz       # 对Redis安装包进行解压
[root@mysql ruby_package]# ls
[root@mysql ruby_package]# cd redis-3.2.12/src      # 进入Redis目录的src目录下
[root@mysql src]# ls
adlist.c     asciilogo.h  crc64.h       help.h         Makefile.dep     quicklist.h        release.c      setproctitle.c  t_hash.c      zipmap.c
adlist.h     bio.c        db.c          hyperloglog.c  memtest.c        rand.c             replication.c  sha1.c          t_list.c      zipmap.h
ae.c         bio.h        debug.c       intset.c       mkreleasehdr.sh  rand.h             rio.c          sha1.h          t_set.c       zmalloc.c
ae_epoll.c   bitops.c     debugmacro.h  intset.h       multi.c          rdb.c              rio.h          slowlog.c       t_string.c    zmalloc.h
ae_evport.c  blocked.c    dict.c        latency.c      networking.c     rdb.h              scripting.c    slowlog.h       t_zset.c
ae.h         cluster.c    dict.h        latency.h      notify.c         redisassert.h      sdsalloc.h     solarisfixes.h  util.c
ae_kqueue.c  cluster.h    endianconv.c  lzf_c.c        object.c         redis-benchmark.c  sds.c          sort.c          util.h
ae_select.c  config.c     endianconv.h  lzf_d.c        pqsort.c         redis-check-aof.c  sds.h          sparkline.c     valgrind.sup
anet.c       config.h     fmacros.h     lzf.h          pqsort.h         redis-check-rdb.c  sentinel.c     sparkline.h     version.h
anet.h       crc16.c      geo.c         lzfP.h         pubsub.c         redis-cli.c        server.c       syncio.c        ziplist.c
aof.c        crc64.c      geo.h         Makefile       quicklist.c      redis-trib.rb      server.h       testhelp.h      ziplist.h
[root@mysql src]# cp redis-trib.rb /usr/bin     # 把redis-trib.rb拷贝到/usr/bin目录下
[root@mysql src]# redis-trib.rb                 # 查看redis-trib.rb的帮助文档
Usage: redis-trib &amp;lt;command&amp;gt; &amp;lt;options&amp;gt; &amp;lt;arguments ...&amp;gt;

  create          mysql:port1 ... hostN:portN
                  --replicas &amp;lt;arg&amp;gt;
  check           host:port
  info            host:port
  fix             host:port
                  --timeout &amp;lt;arg&amp;gt;
  reshard         host:port
                  --from &amp;lt;arg&amp;gt;
                  --to &amp;lt;arg&amp;gt;
                  --slots &amp;lt;arg&amp;gt;
                  --yes
                  --timeout &amp;lt;arg&amp;gt;
                  --pipeline &amp;lt;arg&amp;gt;
  rebalance       host:port
                  --weight &amp;lt;arg&amp;gt;
                  --auto-weights
                  --use-empty-masters
                  --timeout &amp;lt;arg&amp;gt;
                  --simulate
                  --pipeline &amp;lt;arg&amp;gt;
                  --threshold &amp;lt;arg&amp;gt;
  add-node        new_host:new_port existing_host:existing_port
                  --slave
                  --master-id &amp;lt;arg&amp;gt;
  del-node        host:port node_id
  set-timeout     host:port milliseconds
  call            host:port command arg arg .. arg
  import          host:port
                  --from &amp;lt;arg&amp;gt;
                  --copy
                  --replace
  help            (show this help)

For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在192.168.81.101虚拟机上创建配置文件并非常用启动redis-server&quot;&gt;4.在192.168.81.101虚拟机上创建配置文件，并非常用启动Redis server&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ~]# ps aux | grep redis-server
root       1684  0.0  0.0 112664   972 pts/0    R+   11:44   0:00 grep --color=auto redis-server
[root@mysql ~]# cd /opt/config/
[root@mysql config]# ls
redis_7000.conf  redis_7001.conf  redis_7002.conf
[root@mysql config]# sed 's/7000/9000/g' redis_7000.conf &amp;gt; redis_9000.conf      # 创建redis_9000.conf配置文件
[root@mysql config]# sed 's/7000/9001/g' redis_7000.conf &amp;gt; redis_9001.conf      # 创建redis_9001.conf配置文件
[root@mysql config]# sed 's/7000/9002/g' redis_7000.conf &amp;gt; redis_9002.conf      # 创建redis_9002.conf配置文件
[root@mysql config]# redis-server /opt/config/redis_9000.conf       # 指定配置文件，启动redis-server
[root@mysql config]# redis-server /opt/config/redis_9001.conf       # 指定配置文件，启动redis-server
[root@mysql config]# redis-server /opt/config/redis_9002.conf       # 指定配置文件，启动redis-server
[root@mysql config]# ps aux | grep redis-server         # 查看已经启动的redis-server
root       1948  0.2  0.3 142916  7572 ?        Ssl  12:21   0:02 redis-server 0.0.0.0:9002 [cluster]
root       1952  0.2  0.3 142916  7560 ?        Ssl  12:21   0:02 redis-server 0.0.0.0:9001 [cluster]
root       1964  0.2  0.3 142916  7356 ?        Ssl  12:21   0:02 redis-server 0.0.0.0:9000 [cluster]
root       6640  0.0  0.0 112664   972 pts/1    R+   12:42   0:00 grep --color=auto redis-server
[root@mysql config]# cat redis_9000.conf        # redis_9000.conf配置文件内容
port 9000
bind 0.0.0.0
daemonize yes
dir '/var/lib/redis'
logfile '/var/log/redis/redis_9000.log'
dbfilename 'redis_9000.data'
cluster-enabled yes
cluster-config-file nodes-9000.conf
cluster-require-full-coverage no
[root@mysql config]# redis-cli -p 9000 cluster nodes        # 查看集群中节点的信息，都只显示自身节点
5eba129e4f4a4be2ffe630fe9fac19ba30f5b419 :9000 myself,master - 0 0 0 connected
[root@mysql config]# redis-cli -p 9001 cluster nodes        # 查看集群中节点的信息，都只显示自身节点
32d2d969c41f4af646b1052f10d69fd29510f3e4 :9001 myself,master - 0 0 0 connected
[root@mysql config]# redis-cli -p 9002 cluster nodes        # 查看集群中节点的信息，都只显示自身节点
6c43b4ddfeaeb3030af397e7469bb0d0b7673979 :9002 myself,master - 0 0 0 connected

使用同样的步骤，在192.168.81.100虚拟机上生成配置文件：redis_9000.conf,redis_9001.conf,redis_9002.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在192.168.81.101虚拟机上使用redis-trib.rb工具构建集群&quot;&gt;5.在192.168.81.101虚拟机上使用redis-trib.rb工具构建集群&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql config]# redis-trib.rb create --replicas 1 127.0.0.1:9000 127.0.0.1:9001 127.0.0.1:9002 192.168.81.100:9000 192.168.81.100:9001 192.168.81.100:9002         # 构建集群，replicas后的参数为集群的节点
&amp;gt;&amp;gt;&amp;gt; Creating cluster
&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:            # 指定master
127.0.0.1:9000
192.168.81.100:9000
127.0.0.1:9001
Adding replica 192.168.81.100:9001 to 127.0.0.1:9000        # 为master添加slave
Adding replica 127.0.0.1:9002 to 192.168.81.100:9000
Adding replica 192.168.81.100:9002 to 127.0.0.1:9001
M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:0-5460 (5461 slots) master
M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:10923-16383 (5461 slots) master
S: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   replicates cb8c114d44d289687798508232d31e0a065fdab5
M: cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000
   slots:5461-10922 (5462 slots) master
S: 71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001
   replicates cf74b2d9570665b74525802462c74cf2e072ef99
S: ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002
   replicates fceba6001b95e2169ddd6622436b213324fe8f77
Can I set the above configuration? (type 'yes' to accept): yes
&amp;gt;&amp;gt;&amp;gt; Nodes configuration updated
&amp;gt;&amp;gt;&amp;gt; Assign a different config epoch to each node
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join..........
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 127.0.0.1:9000)
M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
M: cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots: (0 slots) slave
   replicates cb8c114d44d289687798508232d31e0a065fdab5
M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002
   slots: (0 slots) slave
   replicates fceba6001b95e2169ddd6622436b213324fe8f77
S: 71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001
   slots: (0 slots) slave
   replicates cf74b2d9570665b74525802462c74cf2e072ef99
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是：如果上面的操作中，一直阻塞在'Waiting for the cluster to join'，则是因为meet操作阻塞，可以手动进行meet操作&lt;/p&gt;
&lt;p&gt;具体步骤为：在当前虚拟机上另开启一个命令提示符，进行meet操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ~]# redis-cli -p 9000 cluster meet 127.0.0.1 9001       # 192.168.81.101:9000端口运行的redis-server向192.168.81.101:9001端口运行的redis-server发送meet请求
OK
[root@mysql ~]# redis-cli -p 9000 cluster meet 127.0.0.1 9002       # 192.168.81.101:9000端口运行的redis-server向192.168.81.101:9001端口运行的redis-server发送meet请求
OK
[root@mysql ~]# redis-cli -p 9000 cluster meet 192.168.81.100 9002  # 192.168.81.101:9000端口运行的redis-server向192.168.81.100:9002端口运行的redis-server发送meet请求
OK
[root@mysql ~]# redis-cli -p 9000 cluster meet 192.168.81.100 9001  # 192.168.81.101:9000端口运行的redis-server向192.168.81.100:9001端口运行的redis-server发送meet请求
OK
[root@mysql ~]# redis-cli -p 9000 cluster meet 192.168.81.100 9000  # 192.168.81.101:9000端口运行的redis-server向192.168.81.100:9000端口运行的redis-server发送meet请求
OK
[root@mysql ~]# redis-cli -p 9000 cluster info      # 查看集群的信息
cluster_state:ok                        # 状态为ok
cluster_slots_assigned:16384            # 标记的slot共有16384个
cluster_slots_ok:16384                  # 已分配的slot有16384个
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6                   # 当前集群共有6个节点
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_sent:1890
cluster_stats_messages_received:1890
[root@mysql ~]# redis-cli -p 9000 cluster nodes         # 查看当前集群节点信息
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 master - 0 1539751180759 4 connected 5461-10922
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 slave cb8c114d44d289687798508232d31e0a065fdab5 0 1539751183277 4 connected
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539751181266 2 connected 10923-16383
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539751182272 6 connected
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539751180255 5 connected
cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000 myself,master - 0 0 1 connected 0-5460      &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis-cluster扩容集群&quot;&gt;6.Redis Cluster扩容集群&lt;/h3&gt;
&lt;h4 id=&quot;在192.168.81.100虚拟机上准备新节点&quot;&gt;6.1 在192.168.81.100虚拟机上准备新节点&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@host1 config]# ls
add_slots.sh  redis_9000.conf  redis_9001.conf  redis_9002.conf
[root@host1 config]# sed 's/9000/9003/g' redis_9000.conf &amp;gt; redis_9003.conf  # 生成配置文件
[root@host1 config]# redis-server /opt/config/redis_9003.conf               # 指定配置文件启动redis-server
[root@host1 config]# ps aux | grep redis-server                             # 查看redis-server的进程
root       2553  0.2  0.7 142904  7552 ?        Ssl  12:23   0:12 redis-server 0.0.0.0:9000 [cluster]
root       2557  0.2  0.7 142904  7548 ?        Ssl  12:23   0:13 redis-server 0.0.0.0:9001 [cluster]
root       2561  0.2  0.7 142904  7556 ?        Ssl  12:23   0:13 redis-server 0.0.0.0:9002 [cluster]
root       2596  0.1  0.5 142904  5336 ?        Ssl  13:53   0:00 redis-server 0.0.0.0:9003 [cluster]
root       2600  0.0  0.0 112648   964 pts/0    R+   13:53   0:00 grep --color=auto redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在192.168.81.101虚拟机上生成配置文件手动扩容集群&quot;&gt;6.2 在192.168.81.101虚拟机上生成配置文件，手动扩容集群&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql config]# redis-cli -p 9000 cluster meet 127.0.0.1 9003          # 对新添加节点执行meet操作
OK
[root@mysql config]# redis-cli -p 9000 cluster meet 192.168.81.100 9003     # 对新添加节点执行meet操作
OK
[root@mysql config]# redis-cli -p 9000 cluster nodes            # 查看集群节点信息
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 slave cb8c114d44d289687798508232d31e0a065fdab5 0 1539755696566 4 connected
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539755699589 6 connected
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539755694553 5 connected
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539755697570 7 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 master - 0 1539755694553 4 connected 5461-10922
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539755698572 2 connected 10923-16383
cf74b2d9570665b74525802462c74cf2e072ef99 192.168.81.101:9000 myself,master - 0 0 1 connected 0-5460
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 master - 0 1539755695560 0 connected
[root@mysql config]# redis-cli -p 9000 cluster info         # 查看集群信息
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:8
cluster_size:3
cluster_current_epoch:7
cluster_my_epoch:1
cluster_stats_messages_sent:11829
cluster_stats_messages_received:11829
[root@mysql config]# redis-cli -p 9003 cluster replicate 27266dcfd098dfe2a42361d6ab59edf8fb9f5413            # 新添加节点设置主从关系 
OK
[root@mysql config]# redis-cli -p 9003 cluster nodes    # 查看集群中节点信息
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539756040013 7 connected
2ff22acb1e006b9881abc80238e15b4e3fcefbef 192.168.81.101:9003 myself,slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 0 0 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 master - 0 1539756035980 4 connected 5461-10922
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539756037488 2 connected
cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000 master - 0 1539756040516 1 connected 0-5460
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 slave cb8c114d44d289687798508232d31e0a065fdab5 0 1539756038998 4 connected
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539756041017 2 connected 10923-16383
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 1539756042024 1539756037992 1 connected&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在192.168.81.101虚拟机上生成配置文件使用redis-trib.rb工具扩容集群&quot;&gt;6.3 在192.168.81.101虚拟机上生成配置文件，使用redis-trib.rb工具扩容集群&lt;/h4&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;向集群中添加192.168.81.100:9003和192.168.81.101:9003节点&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;建议使用redis-trib.rb工具，避免新节点已经加入了其他集群，造成故障&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql config]# ls
dump.rdb  redis_9000.conf  redis_9001.conf  redis_9002.conf
[root@mysql config]# sed 's/9000/9003/g' redis_9000.conf &amp;gt; redis_9003.conf      # 生成配置文件
[root@mysql config]# ls
dump.rdb  redis_9000.conf  redis_9001.conf  redis_9002.conf  redis_9003.conf
[root@mysql config]# redis-server /opt/config/redis_9003.conf       # 指定配置文件运行redis-server
[root@mysql config]# ps aux | grep redis-server                     # 查看redis-server的进程信息
root       1948  0.2  0.3 142916  7560 ?        Ssl  12:21   0:13 redis-server 0.0.0.0:9002 [cluster]
root       1952  0.2  0.3 142916  7560 ?        Ssl  12:21   0:12 redis-server 0.0.0.0:9001 [cluster]
root       1964  0.2  0.3 142916  7356 ?        Ssl  12:21   0:12 redis-server 0.0.0.0:9000 [cluster]
root       7348  0.0  0.2 142916  5352 ?        Ssl  13:53   0:00 redis-server 0.0.0.0:9003 [cluster]
root       7352  0.0  0.0 112664   972 pts/0    R+   13:53   0:00 grep --color=auto redis-server
[root@mysql config]# redis-trib.rb add-node 127.0.0.1:9003 192.168.81.100:9003     # 向集群添加节点
[root@mysql config]# redis-cli -p 9000 cluster nodes        # 查看集群的节点信息
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539826328082 7 connected
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539826326067 9 connected 5461-10922
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539826330601 2 connected 10923-16383
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539826331108 6 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539826332115 9 connected
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539826329091 7 connected
cf74b2d9570665b74525802462c74cf2e072ef99 192.168.81.101:9000 myself,master - 0 0 1 connected 0-5460
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539826330098 5 connected
[root@mysql config]# redis-trib.rb reshard 127.0.0.1:9000       # 迁移槽
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 127.0.0.1:9000)
M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: 2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003
   slots: (0 slots) slave
   replicates 27266dcfd098dfe2a42361d6ab59edf8fb9f5413
M: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002
   slots: (0 slots) slave
   replicates fceba6001b95e2169ddd6622436b213324fe8f77
S: cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000
   slots: (0 slots) slave
   replicates 6f369311b0ca4c503f337c4bb23424eed3eeb188
M: 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003
   slots: (0 slots) master
   1 additional replica(s)
S: 71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001
   slots: (0 slots) slave
   replicates cf74b2d9570665b74525802462c74cf2e072ef99
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? 27266dcfd098dfe2a42361d6ab59edf8fb9f5413
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:all

Ready to move 4096 slots.
  Source nodes:
    M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
    M: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
    M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
  Destination node:
    M: 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003
   slots: (0 slots) master
   1 additional replica(s)
  Resharding plan:
    Moving slot 5461 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5462 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5463 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5464 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5465 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5466 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5467 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5468 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5469 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5470 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5471 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5472 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5473 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5474 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5475 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5476 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5477 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5478 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5479 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5480 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5481 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5482 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5483 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5484 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5485 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5486 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5487 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5488 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5489 from 6f369311b0ca4c503f337c4bb23424eed3eeb188
    Moving slot 5490 from 6f369311b0ca4c503f337c4bb23424eed3eeb188

Moving slot 12283 from 127.0.0.1:9001 to 192.168.81.100:9003: 
Moving slot 12284 from 127.0.0.1:9001 to 192.168.81.100:9003: 
Moving slot 12285 from 127.0.0.1:9001 to 192.168.81.100:9003: 
Moving slot 12286 from 127.0.0.1:9001 to 192.168.81.100:9003: 
Moving slot 12287 from 127.0.0.1:9001 to 192.168.81.100:9003: 
[root@mysql config]# redis-cli -p 9000 cluster slots            # 查看集群中槽的信息
1) 1) (integer) 6827
   2) (integer) 10922
   3) 1) &quot;127.0.0.1&quot;
      2) (integer) 9002
      3) &quot;6f369311b0ca4c503f337c4bb23424eed3eeb188&quot;
   4) 1) &quot;192.168.81.100&quot;
      2) (integer) 9000
      3) &quot;cb8c114d44d289687798508232d31e0a065fdab5&quot;
2) 1) (integer) 12288
   2) (integer) 16383
   3) 1) &quot;127.0.0.1&quot;
      2) (integer) 9001
      3) &quot;fceba6001b95e2169ddd6622436b213324fe8f77&quot;
   4) 1) &quot;192.168.81.100&quot;
      2) (integer) 9002
      3) &quot;ac153a3c1fb10d9d502b153c32dec65c85b2f97c&quot;
3) 1) (integer) 0
   2) (integer) 1364
   3) 1) &quot;192.168.81.100&quot;
      2) (integer) 9003
      3) &quot;27266dcfd098dfe2a42361d6ab59edf8fb9f5413&quot;
   4) 1) &quot;127.0.0.1&quot;
      2) (integer) 9003
      3) &quot;2ff22acb1e006b9881abc80238e15b4e3fcefbef&quot;
4) 1) (integer) 5461
   2) (integer) 6826
   3) 1) &quot;192.168.81.100&quot;
      2) (integer) 9003
      3) &quot;27266dcfd098dfe2a42361d6ab59edf8fb9f5413&quot;
   4) 1) &quot;127.0.0.1&quot;
      2) (integer) 9003
      3) &quot;2ff22acb1e006b9881abc80238e15b4e3fcefbef&quot;
5) 1) (integer) 10923
   2) (integer) 12287
   3) 1) &quot;192.168.81.100&quot;
      2) (integer) 9003
      3) &quot;27266dcfd098dfe2a42361d6ab59edf8fb9f5413&quot;
   4) 1) &quot;127.0.0.1&quot;
      2) (integer) 9003
      3) &quot;2ff22acb1e006b9881abc80238e15b4e3fcefbef&quot;
6) 1) (integer) 1365
   2) (integer) 5460
   3) 1) &quot;192.168.81.101&quot;
      2) (integer) 9000
      3) &quot;cf74b2d9570665b74525802462c74cf2e072ef99&quot;
   4) 1) &quot;192.168.81.100&quot;
      2) (integer) 9001
      3) &quot;71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329&quot;
[root@mysql config]# redis-cli -p 9000 cluster nodes            # 查看集群中节点的信息
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539826689921 12 connected
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539826692961 9 connected 6827-10922
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539826693970 2 connected 12288-16383
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539826688916 6 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539826693475 9 connected
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539826690944 12 connected 0-1364 5461-6826 10923-12287
cf74b2d9570665b74525802462c74cf2e072ef99 192.168.81.101:9000 myself,master - 0 0 1 connected 1365-5460
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539826691953 5 connected
[root@mysql config]# redis-cli -p 9000 cluster nodes | grep master      # 只查看master的节点信息
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539826726695 9 connected 6827-10922
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539826728205 2 connected 12288-16383
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539826726192 12 connected 0-1364 5461-6826 10923-12287
cf74b2d9570665b74525802462c74cf2e072ef99 192.168.81.101:9000 myself,master - 0 0 1 connected 1365-5460      &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis-cluster集群收缩&quot;&gt;7.Redis Cluster集群收缩&lt;/h3&gt;
&lt;p&gt;说明：把192.168.81.101:9000这个master及对应slave节点从集群中移除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ~]# redis-cli -p 9000 cluster nodes         # 查看集群中的节点信息
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539827599055 12 connected
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539827597043 9 connected 6827-10922
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539827598049 2 connected 12288-16383
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539827601066 6 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539827596039 9 connected
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539827600062 12 connected 0-1364 5461-6826 10923-12287
cf74b2d9570665b74525802462c74cf2e072ef99 192.168.81.101:9000 myself,master - 0 0 1 connected 1365-5460         # 要移除的节点的槽编号为：1365到5460
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539827595029 5 connected
[root@mysql ~]# redis-trib.rb reshard --from cf74b2d9570665b74525802462c74cf2e072ef99 --to 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 --slots 1366 127.0.0.1:9001    # 迁移槽，从192.168.81.101:9000迁移到集群中别的节点上
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 127.0.0.1:9001)
M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: 71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001
   slots: (0 slots) slave
   replicates cf74b2d9570665b74525802462c74cf2e072ef99
M: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
S: ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002
   slots: (0 slots) slave
   replicates fceba6001b95e2169ddd6622436b213324fe8f77
S: 2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003
   slots: (0 slots) slave
   replicates 27266dcfd098dfe2a42361d6ab59edf8fb9f5413
S: cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000
   slots: (0 slots) slave
   replicates 6f369311b0ca4c503f337c4bb23424eed3eeb188
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.

Ready to move 1366 slots.       # 此次可以迁移1366个槽
  Source nodes:
    M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
  Destination node:
    M: 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
  Resharding plan:
    Moving slot 1365 from cf74b2d9570665b74525802462c74cf2e072ef99
    Moving slot 1366 from cf74b2d9570665b74525802462c74cf2e072ef99
    ...
    Moving slot 2729 from cf74b2d9570665b74525802462c74cf2e072ef99
    Moving slot 2730 from cf74b2d9570665b74525802462c74cf2e072ef99
Do you want to proceed with the proposed reshard plan (yes/no)? yes
Moving slot 1365 from 127.0.0.1:9000 to 192.168.81.100:9003: 
Moving slot 1366 from 127.0.0.1:9000 to 192.168.81.100:9003: 
...
Moving slot 2728 from 127.0.0.1:9000 to 192.168.81.100:9003: 
Moving slot 2729 from 127.0.0.1:9000 to 192.168.81.100:9003: 
Moving slot 2730 from 127.0.0.1:9000 to 192.168.81.100:9003:
[root@mysql ~]# redis-cli -p 9001 cluster nodes             # 查看集群节点信息
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave cf74b2d9570665b74525802462c74cf2e072ef99 0 1539827870363 5 connected
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539827868350 9 connected 6827-10922
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539827872375 12 connected 0-2730 5461-6826 10923-12287
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 myself,master - 0 0 2 connected 12288-16383
cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000 master - 0 1539827873385 1 connected 2731-5460         # 还有2731到5460号槽还没有迁移完
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539827867345 6 connected
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539827869356 12 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539827871370 9 connected
[root@mysql ~]# redis-trib.rb reshard --from cf74b2d9570665b74525802462c74cf2e072ef99 --to 6f369311b0ca4c503f337c4bb23424eed3eeb188 --slots 2730 127.0.0.1:9002     # 迁移槽，把192.168.81.101:9000剩余的槽迁移到别的节点                     
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 127.0.0.1:9002)
M: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
S: cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000
   slots: (0 slots) slave
   replicates 6f369311b0ca4c503f337c4bb23424eed3eeb188
S: ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002
   slots: (0 slots) slave
   replicates fceba6001b95e2169ddd6622436b213324fe8f77
S: 2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003
   slots: (0 slots) slave
   replicates 27266dcfd098dfe2a42361d6ab59edf8fb9f5413
S: 71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001
   slots: (0 slots) slave
   replicates cf74b2d9570665b74525802462c74cf2e072ef99
M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:2731-5460 (2730 slots) master
   1 additional replica(s)
M: fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
M: 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003
   slots:0-2730,5461-6826,10923-12287 (5462 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.

Ready to move 2730 slots.
  Source nodes:
    M: cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000
   slots:2731-5460 (2730 slots) master
   1 additional replica(s)
  Destination node:
    M: 6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
  Resharding plan:
    Moving slot 2731 from cf74b2d9570665b74525802462c74cf2e072ef99
    Moving slot 2732 from cf74b2d9570665b74525802462c74cf2e072ef99
    ...
    Moving slot 5459 from cf74b2d9570665b74525802462c74cf2e072ef99
    Moving slot 5460 from cf74b2d9570665b74525802462c74cf2e072ef99
Do you want to proceed with the proposed reshard plan (yes/no)? yes
Moving slot 2731 from 127.0.0.1:9000 to 127.0.0.1:9002: 
Moving slot 2732 from 127.0.0.1:9000 to 127.0.0.1:9002: 
...
Moving slot 5459 from 127.0.0.1:9000 to 127.0.0.1:9002: 
Moving slot 5460 from 127.0.0.1:9000 to 127.0.0.1:9002: 
[root@mysql ~]# redis-cli -p 9001 cluster nodes     # 查看集群中节点的信息
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539828016103 13 connected
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539828017610 13 connected 2731-5460 6827-10922
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539828016605 12 connected 0-2730 5461-6826 10923-12287
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 myself,master - 0 0 2 connected 12288-16383
cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000 master - 0 1539828013588 1 connected       # 192.168.81.101:9000上已经没有槽了
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539828015601 6 connected
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539828014593 12 connected
cb8c114d44d289687798508232d31e0a065fdab5 192.168.81.100:9000 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539828012582 13 connected
[root@mysql ~]# redis-cli -p 9001 cluster nodes |grep master
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 master - 0 1539828068951 13 connected 2731-5460 6827-10922
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539828071970 12 connected 0-2730 5461-6826 10923-12287
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 myself,master - 0 0 2 connected 12288-16383
cf74b2d9570665b74525802462c74cf2e072ef99 127.0.0.1:9000 master - 0 1539828073980 1 connected
[root@mysql ~]# redis-trib.rb del-node 127.0.0.1:9001 cb8c114d44d289687798508232d31e0a065fdab5        # 先移除192.168.81.101:9000的slave节点
&amp;gt;&amp;gt;&amp;gt; Removing node cb8c114d44d289687798508232d31e0a065fdab5 from cluster 127.0.0.1:9001
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER FORGET messages to the cluster...
&amp;gt;&amp;gt;&amp;gt; SHUTDOWN the node.
[root@mysql ~]# redis-trib.rb del-node 127.0.0.1:9001 cf74b2d9570665b74525802462c74cf2e072ef99        # 移除192.168.81.101:9000节点
&amp;gt;&amp;gt;&amp;gt; Removing node cf74b2d9570665b74525802462c74cf2e072ef99 from cluster 127.0.0.1:9001
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER FORGET messages to the cluster...
&amp;gt;&amp;gt;&amp;gt; SHUTDOWN the node.
[root@mysql ~]# redis-cli -p 9000       # 连接192.168.81.101:9000客户端，显示连接失败
Could not connect to Redis at 127.0.0.1:9000: Connection refused
Could not connect to Redis at 127.0.0.1:9000: Connection refused
not connected&amp;gt; exit
[root@mysql ~]# redis-trib.rb del-node 127.0.0.1:9001 cf74b2d9570665b74525802462c74cf2e072ef99        # 移除192.168.81.101:9000节点，显示移除失败，因为集群中已经没有这个节点了 
&amp;gt;&amp;gt;&amp;gt; Removing node cf74b2d9570665b74525802462c74cf2e072ef99 from cluster 127.0.0.1:9001
[ERR] No such node ID cf74b2d9570665b74525802462c74cf2e072ef99
[root@mysql ~]# redis-cli -p 9002 cluster nodes     # 查看集群中的节点信息
6f369311b0ca4c503f337c4bb23424eed3eeb188 127.0.0.1:9002 myself,master - 0 0 13 connected 2731-5460 6827-10922
ac153a3c1fb10d9d502b153c32dec65c85b2f97c 192.168.81.100:9002 slave fceba6001b95e2169ddd6622436b213324fe8f77 0 1539828535088 6 connected
2ff22acb1e006b9881abc80238e15b4e3fcefbef 127.0.0.1:9003 slave 27266dcfd098dfe2a42361d6ab59edf8fb9f5413 0 1539828539118 12 connected
71f5695dc1f4322c8ea9066d1b3cd8bb0ab7a329 192.168.81.100:9001 slave 6f369311b0ca4c503f337c4bb23424eed3eeb188 0 1539828536098 13 connected
fceba6001b95e2169ddd6622436b213324fe8f77 127.0.0.1:9001 master - 0 1539828537106 2 connected 12288-16383
27266dcfd098dfe2a42361d6ab59edf8fb9f5413 192.168.81.100:9003 master - 0 1539828538114 12 connected 0-2730 5461-6826 10923-12287&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 22 Oct 2018 15:03:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<og:description>环境说明： 两台虚拟机，IP地址分别为：192.168.81.100和192.168.81.101 虚拟机系统为：CentOS 7.5 Redis为yum安装，版本为3.2 系统环境：关闭firewa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/9833740.html</dc:identifier>
</item>
<item>
<title>[原创]分布式系统之缓存的微观应用经验谈（三）【数据分片和集群篇】 - AutumnBing</title>
<link>http://www.cnblogs.com/bsfz/p/9833600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bsfz/p/9833600.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式系统之缓存的微观应用经验谈（三）【数据分片和集群篇】&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　近几个月一直在忙些琐事，几乎年后都没怎么闲过。忙忙碌碌中就进入了2018年的秋天了，不得不感叹时间总是如白驹过隙，也不知道收获了什么和失去了什么。最近稍微休息，买了两本与技术无关的书，其一是 Yann Martel 写的《The High Mountains of Portugal》（葡萄牙的高山），发现阅读此书是需要一些耐心的，对人生暗喻很深，也有足够的留白，有兴趣的朋友可以细品下。好了，下面回归正题，尝试写写工作中缓存技术相关的一些实战经验和思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　在分布式Web程序设计中，解决高并发以及内部解耦的关键技术离不开缓存和队列，而缓存角色类似计算机硬件中CPU的各级缓存。如今的业务规模稍大的互联网项目，即使在最初beta版的开发上，都会进行预留设计。但是在诸多应用场景里，也带来了某些高成本的技术问题，需要细致权衡。本系列主要围绕分布式系统中服务端缓存相关技术，也会结合朋友间的探讨提及自己的思考细节。文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　为了方便独立成文，原谅在内容排版上的一点点个人强迫症。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　第三篇这里尝试谈谈缓存的数据分片（Sharding）以及集群（Cluster）相关方案（具体应用依然以Redis 举例）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另见：分布式系统之缓存的微观应用经验谈（二） 【主从和主备高可用篇】（&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt;）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;一、先分析缓存数据的分片（Sharding）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　（注：由于目前个人工作中大多数情况应用的是Redis 3.x，以下若有特性关联，均是以此作为参照说明。）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　缓存在很多时候同 RDBMS类似，解决数据的分布式存储的基础理念就是把整个数据集按照一定的规则（切分算法）映射到多个节点（node）中，每个 node负责处理整体数据的一个子集。给缓存作 Sharding 设计，围绕基础数据的存储、通信、数据复制和整合查询等，很多时候比较类似 RDBMS中的水平分区（Horizontal Partitioning），事实上很多点在底层原理上是保持一致的。在缓存的分区策略中，最常见的是基于哈希的各种算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1.1 基于 Round Robin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　实现思路是以缓存条目的标识进行哈希取余，如对缓存中的 Key 进行 Hash计算，然后将结果 R 与 node 个数 N 进行取余，即 R%N 用来指定数据归属到的 node索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　个人认为在数据量比较固定并有一定规律的场景下，则可以考虑基于这种方式的设计。在落地实践前需要注意，这种方案看起来简洁高效，但却无法良好的解决 node的弹性伸缩问题，比如数量 N发生变化时均需要重新覆盖计算，存储的数据几乎是重新迁移甚至重置，对数据的支撑本身会有些勉强和局限。另外，早期使用手动进行预分区，后来增加了一些相应的路由策略可进行翻倍扩容等，都可考虑作为实践场景中的某些细小优化和辅助。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1.2 基于 Consistent Hashing&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　实现思路是将 node 进行串联组合形成一个 Hash环，每个 node 均被分配一个 token作为 sign，sign取值范围对应 Hash结果区间，即通过Hash计算时，每个 node都会在环上拥有一个独一无二的位置，此时将缓存中的Key做基本Hash计算，根据计算结果放置在就近的 node 上，且 node 的 sign 大于等于该计算结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　这种策略的优势体现在，当数据更迭较大，动态调整node（增加/删除）只影响整个 Hash环中个别相邻的 node，而对其他 node则无需作任何操作。也就是说，当数据发生大量变动时，可以有效将影响控制在局部区间内，避免了不必要的过多数据迁移，这在缓存的条目非常多、部署的 node也较多的时候，可以有效形成一个真正意义上的分布式均衡。但在架构落地之前，这种方案除了必要的对 node 调整时间的额外控制，还需要权衡下缓存数据的体量与 node 的数量进行比较后的密集度，当这个比值过大时，数据影响也自然过大，这个就是不符合设计初衷的，不仅没有得到应有的优化，反而增加了一定的技术成本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1.3 基于 Range Partitioning&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　实现思路实际是一种增加类似中间件的包装思想，首先将所有的缓存数据统一划分到多个自定义区间（Range），然后将这些 Range逐一绑定到关联服务的各个 node中，每个 Range将在数据变化时进行相应调整以达到均衡负载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　这其实并非是一个完全新颖的策略，但针对大数据的划分和交互做了更多的考虑。以 Redis的 Sharding算法类比，截止目前的集群方案（Redis Cluster，以3.x举例）中，其策略同样包含了 Range这一元素概念。Redis采用虚拟槽（slot）来标记，数据合计 16384个 slot。缓存数据根据 key进行 Hash归类到各个 node绑定的 slot。当动态伸缩 node时，针对 slot做相应的分配，即间接对数据作迁移。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　这种上层的包装，虽然极大地方便了集群的关注点和线性扩展，在目前落地方案里 Redis也已经尽力扩展完善，但依然还是处于半自动状态。集群是分布的 N个 node，如需要伸展为 N+2个node，那么可以手动或者结合其他辅助框架给每个 node进行划分和调整，一般均衡数约为 16384 /(N+2) slot。同样的，Cluster 的Sharding 在实际落地之前，也需要注意到其不适合的场景，并根据实际数据体量和 QPS瓶颈来合理扩展node，同时处理事务型的应用、统计查询等，对比单机自然是效率较低，这时候可能需要权衡规避过多的扩展，越多从来都不代表越稳定或者说性能越高。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;二、谈谈缓存的集群实践与相关细节&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2.1 提下集群的流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　我在之前一篇文章里，主要围绕主从和高可用进行了一些讨论（主从和主备高可用篇：&lt;a href=&quot;https://www.cnblogs.com/bsfz/p/9769503.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/p/9769503.html&lt;/a&gt;），要提出的是 Master-Slave 结构上来说同样算是一种集群的表现形式，而在 Redis Cluster 方案里，则更侧重分布式数据分片集群，性能上能规避一些冗余数据的内存浪费以及木桶效应，并同时具备类似 Sentinel机制的 HA和 Failover等特性（但要注意并非完全替换）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这里同样涉及到运维、架构 、开发等相关，但个人依然侧重于针对架构和开发来做一些讨论。 当然，涉及架构中对网络I/O、CPU的负载，以及某些场景下的磁盘I/O的代价等问题的权衡，其实大体都是相通的，部分可参见之前文章中的具体阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　简单说在集群模式 Redis Cluster 下， node 的角色分为 Master node 和 Slave node，明面上不存在第三角色。 Master node 将被分配一定范围的 slots 作为数据 Sharding 的承载，而 Slave node 则主要负责数据的复制（相关交互细节可参照上一篇） 并进行出现故障时半自动完成故障转移（HA的实现）。node之间的通信依赖一个相对完善的去中心化的高容错协议Gossip， 当扩展node、node不可达、node升级、 slots修改等时， 内部需要经过一段较短时间的反复ping/pong消息通信， 并最终达到集群状态同步一致。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　以 Redis 3.x 举例，假定一共 10 个 node，Master / Slave = 5 / 5，执行基础握手指令 &quot; cluster meet [ip port] &quot;后，就能很快在 cluster nodes里看到相应会话日志信息，在这个基础上，再给每个node 添加指定 Range 的 lots（ addslots指令），就基本完成了 Redis Cluster的基础构建。（当然，如果是侧重运维，一般你可以手动自定义配置，也可以使用 redis-trib.rb来辅助操作，这里不讨论）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2.2 Redis Cluster的部分限制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　Redis node的拓扑结构设计，目前只能采用单层拓扑，即不可直接进行树状延伸扩展node，注意这里是不同于 Redis Mater-Slave 基本模式的，然后记得在上一篇也提到了本人迄今为止也并未有机会在项目中使用，也是作为备用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　对于原有 DB空间的划分基本等同取消，这个有在第一篇设计细节话题中提到过，并且 Redis Cluster 模式下只能默认使用第一个DB， 即索引为0 标识的库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　假如存在大数据表 “Table”，例如 hash、list 等，是不可以直接采用更细粒度的操作来 Sharding 的，即使强制分散到不同 node 中，也会造成 slot 的覆盖错误。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　缓存数据的批量操作无法充分支持，如 mset / mget 并不能直接操作到所有对应 key中，除非是具有相同 slot。 这是由于 Sharding机制原理决定的，举一反三，若是存在事务操作，也存在相关的限制（另外稍微注意，截止目前，不同node 本身也是无法事务关联的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　2.3 Redis Cluster的相关细节考虑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　对于 Redis node 的数量 N 理论上需要保持偶数台，一般不少于6个才能保证组成一个闭环的高可用的集群，这也意味着理想状态至少需要6台服务器来承载，但这里个人在架构设计中，往往场景不是很敏感，那么将设计为 N/2台服务器分布，目的是兼顾成本以及折中照顾到主从之间的 HA机制（HA相关可以参照上一篇里提到的部分延伸，这里尽量避免重复性讨论）。 这里要稍微注意的是，对于机器的配对，尽量保证不要在同一台机器上配置过多的Master，否则会严重影响选举，甚至failover被直接拒绝，无法重建。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　对于 node 之间的消息交互，每次发送的数据均包含 slot数据和集群基础状态，node越多分发的数据也几近是倍增，这个在上面 Sharding 算法里也表明，那么一方面可以针对 node数量进行控制，另一个则是设置合理的消息发送频率，比如在主要配置 cluster-node-timeout上，适当由默认15秒递增 5/10 秒。但是过度调大 cluster_node_timeout相关设置一定会影响到消息交换的实时性，所以我认为这里可以尝试微调，在大多数本身比较均匀分布数据的场景下适当放宽，这样不会对node检测和选举产生较大影响，同时也间接节约了一定网络IO。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　对于数据增长粒度较大的场景，优先控制集群的 node数量，否则同样避免不了一个比较大头的用户指令消耗 和 Gossip维护消息开销（集群内所有 node的ping/pong消息），官方早前就建议控制集群规模不是没有道理的。个人认为真到了需要的场景，必须主动作减法，缩减node数，取而代之使用小的集群来分散业务，而且这也有利于更精确的控制风险和针对性优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　对于集群的伸缩，如项目中应用较多操作的一般是扩容场景，增加新的node 建议跟集群内的已有 node 配置保持一致，并且在完成 cluster meet 后，需要合理控制划分出的 slot 数，一般没有特殊要求，应该都是均匀化。额外要稍微注意的是，新的 node 务必保证是一个干净的node，否则会造成不必要的拓扑错误（这种是可能会导致数据分布复制严重错乱的），当然新增 node这里也可以借助 redis-trib.rb 或者其他第三方包装的方案来辅助操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　对于不在当前 node 的键指令查询，默认是只回复重定向转移响应（redirect / moved）给到调用的客户端（这里特指应用程序端），并不负责转发。这是跟单机是完全不同的，所以即使是使用相关的第三方驱动库（比如JAVA的Jedis、和.Net的 StackExchange.Redis）完成程序端的封闭式控制，也仍旧需要权衡数据的热点分散是否足够集中在各自的node中等细节。当然，假如是 hashset等结构，由于Cluster本身的Sharding机制涉及到不可分散负载，倒是无需过多编码实现，也不用担心性能在这里的损耗。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　本篇先写到这里，下一篇会继续围绕相关主题尝试扩展阐述。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　PS：由于个人能力和经验均有限，自己也在持续学习和实践，文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　个人目前备用地址：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　社区1：&lt;a href=&quot;https://yq.aliyun.com/u/autumnbing&quot; target=&quot;_blank&quot;&gt;https://yq.aliyun.com/u/autumnbing&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　社区2：&lt;a href=&quot;https://www.cnblogs.com/bsfz/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bsfz/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【预留占位：分布式系统之缓存的微观应用经验谈（四）【交互场景篇】&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;End.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>AutumnBing</dc:creator>
<og:description>第三篇这里尝试谈谈缓存的数据分片（Sharding）以及集群（Cluster）相关方案（具体应用依然以Redis 举例）另见：分布式系统之缓存的微观应用经验谈（二） 【主从和主备高可用篇】（ http</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bsfz/p/9833600.html</dc:identifier>
</item>
<item>
<title>Zara带你快速入门WPF(2)---布局篇 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/9833300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/9833300.html</guid>
<description>&lt;p&gt;一.章节目标&lt;/p&gt;
&lt;p&gt;这几章节我们会创建一个完整的Window程序,包括使用DataGrid空间，数据绑定是把.NET类中的数据提供给用户界面的一个重要概念,还允许修改数据,包括.NET4.5新增的INotifyDataErrorInfo接口。Commanding可以把UI的事件映射到代码上。&lt;/p&gt;
&lt;p&gt;TreeView和DataGrid控件是显示数据绑定的UI控件.TreeView控件可以在树形结构中显示数据，其中数据根据用户的选择进行动态加载。通过DataGrid控件学习如何使用过滤、排序、分组，以及.NET4.5中添加的功能----实时成型，它可以实时改变排序或过滤选项。这篇只是简单的说下WPF控件。&lt;/p&gt;
&lt;p&gt;二.简单控件&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TextBox&lt;/td&gt;
&lt;td&gt;用于显示简单无格式文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;RichTextBox&lt;/td&gt;
&lt;td&gt;通过FlowDocument类支持带格式的文本,它与TextBox都派生于TextBoxBase&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Calendar&lt;/td&gt;
&lt;td&gt;显示你年份月份&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DataPicker&lt;/td&gt;
&lt;td&gt;控件会打开Calendar屏幕,提供选择日期&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;PasswordBox&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;输入密码，可以通过PasswordChar修改显示的格式,通过PasswordChanged可以触发输入事件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;ScrollBar&lt;/td&gt;
&lt;td&gt;包含一个Thumb，用户可以从Thumb中选择一个值,如果内容超过这个了,我就可以显示滚动条&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ProgressBar&lt;/td&gt;
&lt;td&gt;可以指示时间较长的操作的进度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Slider&lt;/td&gt;
&lt;td&gt;用户可以移动Thumb,选择一个范围的值,它和ScrollBar,ProgressBar都来源一个基类RanGeBase&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单控件是没有Content属性的控件,例如Button类可以包含任意形状和任意元素。&lt;/p&gt;
&lt;p&gt;三.内容控件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ContentControl有一个content属性,利用Content属性，可以给空间添加任意内容，因为Button类派生自基类ContentControl.所以在这个地方可以添加任何内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如:Button、RepeatButton、toggleButton、CheckBox、RadioButton、Label、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Frame 该控件支持导航、使用Navigate()方法可以导航到一个页面的内容上、如果内容是HTML、就是用WebBrowser控件来显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022195856594-1155080169.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　ListBoxItem 是ListBox的一项 、 ToolTip 创建一个弹窗 、其中UserControl也是内容控件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 四.带标题的内容控件&lt;/p&gt;
&lt;p&gt;带标题的内容控件派生自HeaderContentControl基类。HeaderContentControl类又派生于ContentControl,HeaderContentControl类的Header属性定义了标题的内容，HeaderTemplate属性可对标题金泉完全的定制。HeaderContentControl的控件如表&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Expander                         &lt;/td&gt;
&lt;td&gt;可以创建一个带对话框的“高级”模式，它在默认情况下不显示所有的信息，只有用户展开它。才会显示更多的信息，在未展开下，只显示标题信息，在展开的情况下,显示内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;GroupBox     &lt;/td&gt;
&lt;td&gt;提供了边框和标题来组合控件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;TabItem  &lt;/td&gt;
&lt;td&gt;TabItem的Header属性定义了标题内容,这些内容都是用TabControl的标签显示&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; Expander空间的简单用法如下列代码,把Expander控件的Header属性设置未Click formove 这个文本用于显示扩展，这个控件的内容只有在控件展开的时候才显示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022201124394-257124837.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;另外有两个属性可以修饰Content,HorizontalAlignment与VerticalAlignment 属性就Center、Left、Right&lt;/p&gt;
&lt;p&gt;五.项内容&lt;/p&gt;
&lt;p&gt;&lt;span&gt; ItemsControl类包含一个可以用Items属性访问的数据项列表。派生自ItemsControl的类。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Menu、ContextMenu&lt;/td&gt;
&lt;td&gt;Menu类和ContextMenu类派生自抽象基类MenuBase。把MenuItem元素放在数据项列表和相关联的命令中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;StatusBar&lt;/td&gt;
&lt;td&gt;StatusBar控件通常在应用程序的底部、为用户提供状态信息、可以把StatusBarItem元素放在StatusBar列表中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TreeView&lt;/td&gt;
&lt;td&gt;要分层显示数据项&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ListBox、ComboBox、TabControl&lt;/td&gt;
&lt;td&gt;都有相同的抽象基类Selector、这个基类可以选择数据项&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DataGrid&lt;/td&gt;
&lt;td&gt;显示数据、可定制网格&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面例子说明了Border ViewBox和BulletDecorator类&lt;/p&gt;
&lt;p&gt;ViewBox将子元素拉伸并缩放到可用的空间中。StretchDirection和Streth属性专用于ViewBox的功能，它们允许设置子元素是否双向拉伸，以及是否保持宽高比&lt;/p&gt;
&lt;p&gt;BulletDecorator类用一个项目符号修饰其子元素。子元素可以是任何元素，项目符号也可以是任何元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;StackPanel&amp;gt;
        &amp;lt;Border BorderBrush=&quot;Violet&quot; BorderThickness=&quot;5&quot;&amp;gt;
            &amp;lt;Label&amp;gt;呵呵哒&amp;lt;/Label&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Viewbox StretchDirection=&quot;Both&quot; Stretch=&quot;Uniform&quot;&amp;gt;
            &amp;lt;Label  Width=&quot;79&quot;&amp;gt;么么哒&amp;lt;/Label&amp;gt;
        &amp;lt;/Viewbox&amp;gt;
        &amp;lt;BulletDecorator Height=&quot;99.874&quot;&amp;gt;
            &amp;lt;BulletDecorator.Bullet&amp;gt;
                &amp;lt;Image Width=&quot;196.968&quot; HorizontalAlignment=&quot;Center&quot; Margin=&quot;5,5,-166.968,-51.636&quot;&lt;span&gt;
                       Source=&quot;http://p4.123.sogoucdn.com/imgu/2018/10/20181019163410_194.jpg&quot;/&amp;gt;
            &amp;lt;/BulletDecorator.Bullet&amp;gt;
            &amp;lt;BulletDecorator.Child&amp;gt;
                &amp;lt;TextBlock&amp;gt;案说法&amp;lt;/TextBlock&amp;gt;
            &amp;lt;/BulletDecorator.Child&amp;gt;
        &amp;lt;/BulletDecorator&amp;gt;
    &amp;lt;/StackPanel&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022203321393-143605095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六.布局&lt;/p&gt;
&lt;p&gt;1.StackPanel&lt;/p&gt;
&lt;p&gt;在window程序中只能包含一个子元素。作为其内容。如果要在其中包含多个元素，就可以将StackPanel当作成一个子元素，并将在它当中添加子元素。它是一个简单的控件，可以通过StackPanel控制显示方向。ToolBarPanel类派生于StackPanel&lt;/p&gt;
&lt;p&gt;2.WrapPanel&lt;/p&gt;
&lt;p&gt;WrapPanel将子元素字左右逐个排列,若一个书评行中放不下，就排在下一行，面板的方向可以是水平或是垂直。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;WrapPanel&amp;gt;
        &amp;lt;WrapPanel.Resources&amp;gt;
            &amp;lt;Style TargetType=&quot;Button&quot;&amp;gt;
                &amp;lt;Setter Property=&quot;Margin&quot; Value=&quot;5&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
            &amp;lt;/Style&amp;gt;
        &amp;lt;/WrapPanel.Resources&amp;gt;
        &amp;lt;Button&amp;gt;button&amp;lt;/Button&amp;gt;
        &amp;lt;Button&amp;gt;button&amp;lt;/Button&amp;gt;
        &amp;lt;Button&amp;gt;button&amp;lt;/Button&amp;gt;
    &amp;lt;/WrapPanel&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022205702458-890314400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.Canvas&lt;/p&gt;
&lt;p&gt;Canvas是一个允许显式指定控件位置的面板，它定义了Left、right、top、bottom 属性。这个我们后续详解。&lt;/p&gt;
&lt;p&gt;4.DockPanel&lt;/p&gt;
&lt;p&gt;它非常类似于winform中的停靠功能，DockPanel可以指定排列子空间的区域。Panel定义了Dock附加属性，代码如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022211836538-2103657240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;DockPanel&amp;gt;
        &amp;lt;Border Background=&quot;AliceBlue&quot; Height=&quot;25&quot; DockPanel.Dock=&quot;Top&quot;&amp;gt;
            &amp;lt;TextBlock&amp;gt;menu&amp;lt;/TextBlock&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border Background=&quot;DarkMagenta&quot; DockPanel.Dock=&quot;Top&quot;&amp;gt;
            &amp;lt;TextBlock&amp;gt;ribbon&amp;lt;/TextBlock&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border Background=&quot;LightPink&quot; DockPanel.Dock=&quot;Bottom&quot;&amp;gt;
            &amp;lt;TextBlock&amp;gt;status&amp;lt;/TextBlock&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border Background=&quot;LightPink&quot; DockPanel.Dock=&quot;left&quot;&amp;gt;
            &amp;lt;TextBlock&amp;gt;left side&amp;lt;/TextBlock&amp;gt;
        &amp;lt;/Border&amp;gt;
        &amp;lt;Border Background=&quot;HotPink&quot;&amp;gt;
            &amp;lt;TextBlock&amp;gt;remaining part&amp;lt;/TextBlock&amp;gt;
        &amp;lt;/Border&amp;gt;
    &amp;lt;/DockPanel&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;七.Grid&lt;/p&gt;
&lt;p&gt;使用grid可以在行和列中排序控件，对于每一列可以指定一个ColumnDefintion，对于每一行可以指定一个RowDefintion,在每一列和每一行中都可以指定高度和宽度，其中前面说到的两个属性中分别有一个Width以及Height 依赖属性，其中单位有像素、厘米&lt;/p&gt;
&lt;p&gt;英寸或点为单位定义高度和宽度，或者把它们设置为Auto,根据内容来确定其大小、在为列提供可用控件时，可以将width属性设置为*，要使扩大到两倍，就设置为2.  写个示例大家就了解了。这个grid包含几个label和textbox控件，因为这些控件的父控件是grid，所以可以设置附加column、columnspan、row、rowspan.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;Grid ShowGridLines=&quot;True&quot;&amp;gt;
        &amp;lt;Grid.ColumnDefinitions&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
            &amp;lt;ColumnDefinition/&amp;gt;
        &amp;lt;/Grid.ColumnDefinitions&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition/&amp;gt;
            &amp;lt;RowDefinition/&amp;gt;
            &amp;lt;RowDefinition/&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;
        &amp;lt;Label Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot; Grid.Row=&quot;0&quot;&lt;span&gt;
               VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Content=&quot;Title&quot;/&amp;gt;
        &amp;lt;Label Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; VerticalAlignment=&quot;Center&quot; Content=&quot;firstname:&quot; Margin=&quot;10&quot;/&amp;gt;
        &amp;lt;TextBox Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot; Width=&quot;100&quot; Height=&quot;30&quot;&amp;gt;&amp;lt;/TextBox&amp;gt;
        &amp;lt;Label Grid.Column=&quot;0&quot; Grid.Row=&quot;2&quot; VerticalAlignment=&quot;Center&quot; Content=&quot;lastname:&quot; Margin=&quot;10&quot;/&amp;gt;
        &amp;lt;TextBox Grid.Column=&quot;1&quot; Grid.Row=&quot;2&quot; Width=&quot;100&quot; Height=&quot;30&quot;&amp;gt;&amp;lt;/TextBox&amp;gt;
    &amp;lt;/Grid&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201810/1366751-20181022214059790-1966405700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了发方便看到行和列,把showgridlines属性设置为True;注意：要使Grid的每个单元格有相同的尺寸，可以使用UniformGrid类。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 13:43:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>一.章节目标 这几章节我们会创建一个完整的Window程序,包括使用DataGrid空间，数据绑定是把.NET类中的数据提供给用户界面的一个重要概念,还允许修改数据,包括.NET4.5新增的INoti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/9833300.html</dc:identifier>
</item>
<item>
<title>企业管理系统前后端分离架构设计  系列一  权限模型篇 - 若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9833224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9833224.html</guid>
<description>&lt;p&gt;前段时间分别用vue和react写了两个后台管理系统的模板&lt;a href=&quot;https://github.com/wjkang/vue-quasar-admin&quot;&gt;vue-quasar-admin&lt;/a&gt;和&lt;a href=&quot;https://github.com/wjkang/3YAdmin&quot;&gt;3YAdmin&lt;/a&gt;。两个项目中都实现了基于RBAC的权限控制。因为本职工作是后端开发，比较清楚权限控制一个管理系统应该必须具备的核心功能，而且是可以做到通用的。打算写写关于管理系统前后端分离方面的文章，也是做一个知识的总结，其中会涉及到vue,react,node,.net core等方面的知识。&lt;/p&gt;
&lt;h2 id=&quot;术语描述&quot;&gt;术语描述&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;用户(Subject)：发起操作的主体&lt;/li&gt;
&lt;li&gt;对象(Object)：指操作所针对的客体对象，比如文章或评论&lt;/li&gt;
&lt;li&gt;权限(Permission)：用来指代对某种对象的某一种操作，例如“添加文章的操作”&lt;/li&gt;
&lt;li&gt;权限码：权限的代号，例如用“ARTICLE_ADD”来指代“添加文章的操作”权限&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;权限有时候也可以称为动作或者功能。比如“添加文章”，既可以认为它是一个动作，也可以认为它是一个功能。对象也可以称为资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常用的权限模型&quot;&gt;常用的权限模型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ACL(Access Control List)(访问控制列表)&lt;/li&gt;
&lt;li&gt;DAC(Discretionary Access Control)(自主访问控制)&lt;/li&gt;
&lt;li&gt;MAC(Mandatory Access Control)(强制访问控制)&lt;/li&gt;
&lt;li&gt;RBAC(Role-Based Access Control)(基于角色的访问控制)&lt;/li&gt;
&lt;li&gt;ABAC(Attribute-Based Access Control)(基于属性的访问控制)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;aclaccess-control-list访问控制列表&quot;&gt;ACL(Access Control List)(访问控制列表)&lt;/h2&gt;
&lt;p&gt;ACL是最早也是最基本的一种访问控制机制，它是用来描述用户和权限之间关系的数据列表。它的原理非常简单：每一项资源，都配有一个列表，这个列表记录的就是哪些用户可以对这项资源执行CRUD等操作。当试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确定当前用户可否执行相应的操作。&lt;/p&gt;
&lt;p&gt;例如一个文件对象的 ACL 为 Alice: read,write; Bob: read，这代表 Alice 对该文件既能读又能写，而 Bob 只能读取。&lt;/p&gt;
&lt;p&gt;由于ACL的简单性，使得它几乎不需要任何基础设施就可以完成访问控制。但同时它的缺点也是很明显的，由于需要维护大量的访问权限列表，ACL在性能上有明显的缺陷。另外，对于拥有大量用户与众多资源的应用，管理访问控制列表本身就变成非常繁重的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-ba828024c195bce6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最开始的ACL定义中，用户直接和权限挂钩，数据存储的是用户与权限的关联关系。如果两个用户的权限是一样的，那么就需要分别存储这两个用户与权限的关联关系，也是上面所提到的ACL的缺陷。为了解决这些问题，便有了对ACL设计的改进，相同权限的用户放到同一个分组里，分组与权限挂钩，不再是用户直接与权限挂钩。以及后来出现的RBAC(基于角色的访问控制)，角色与分组也是差不多的概念，角色直接与权限挂钩，用户再与角色进行关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;所以，现在一般说ACL,不再是用户直接和权限挂钩的一种权限控制模型，把它看做一个单纯的访问控制列表即可。列表里维护的可能是用户与权限的关系，也可以是用户组与权限的关系，也可以是角色与权限的关系，甚至是部门，职位等等于权限的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ACL是权限体系中的业务规则。RBAC等权限模型要用到ACL才能工作，ACL服务于RBAC等权限模型，其它权限控制体系里的权限规则也叫ACL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;dacdiscretionary-access-control自主访问控制&quot;&gt;DAC(Discretionary Access Control)(自主访问控制)&lt;/h2&gt;
&lt;p&gt;系统会识别用户，然后根据被操作对象（Subject）的权限控制列表（ACL: Access Control List）或者权限控制矩阵（ACL: Access Control Matrix）的信息来决定用户的是否能对其进行哪些操作，例如读取或修改。&lt;br/&gt;而拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为“自主（Discretionary）”控制。&lt;/p&gt;
&lt;p&gt;因为用户能自主地将自己拥有的权限授予其他用户，所以DAC模型可以任意传递权限，用户能间接获得本不具有的访问权限，因此DAC模型的安全性较低，不能给系统充分的数据保护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-5b576569fed40efa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DAC可以直接使用ACL的物理模型，区别在于，DAC模型中用户可以将自己具备的权限分配给其它用户(程序里的操作就是根据用户ID筛选出权限列表，根据列表为要分配权限的用户构造出新的权限列表并保存)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DAC是传统的UNIX访问控制模型，也是Windows文件系统的访问控制模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-ec0a3418ceadb9c0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows的文件访问权限的设置中，除了用户，还有组。这个组与后面要说到的RABC模型的角色有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7770728/group-vs-role-any-real-difference&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/7770728/group-vs-role-any-real-difference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我认为没必要去划分的太清楚，不管是组还是角色，都是为了更好的管理和分配权限在最原始的ACL模型上做的改进。如果有需要，甚至可以把权限分配到部门，职位上。&lt;/p&gt;
&lt;h2 id=&quot;macmandatory-access-control强制访问控制&quot;&gt;MAC(Mandatory Access Control)(强制访问控制)&lt;/h2&gt;
&lt;p&gt;MAC是为了弥补DAC权限控制过于分散的问题而诞生的。在MAC的设计中，每一个对象都有一些权限标识，每个用户同样也会有一些权限标识，而用户能否对该对象进行操作取决于双方的权限标识的关系，这个限制判断通常是由系统硬性限制的。访问时，系统先对用户的访问许可级别和资源对象的密级进行比较，再决定用户是否可以访问资源对象。用户不能改变自身和资源对象的安全级别，只有系统管理员或管理程序才能 控制资源对象和用户的级别。比如在影视作品中我们经常能看到特工在查询机密文件时，屏幕提示需要“无法访问，需要一级安全许可”，这个例子中，文件上就有“一级安全许可”的权限标识，而用户并不具有。&lt;/p&gt;
&lt;p&gt;MAC非常适合机密机构或者其他等级观念强烈的行业，但对于类似商业服务系统，则因为不够灵活而不能适用。&lt;/p&gt;
&lt;p&gt;MAC可以继续使用DAC的模型，但是要对用户进行等级划分，比如一级，二级，三级。。。，对对象资源也要做划分，比如机密，秘密和最高机密。用户访问的资源的时候，根据用户等级与资源访问级别来做判断，比如一级用户只能访问机密文件，如果访问的是最高机密文件，系统就会拒绝。这一系列规则是优先于DAC的，如果MAC与DAC混用，要先校验MAC再校验DAC。&lt;/p&gt;
&lt;h2 id=&quot;rbacrole-based-access-control基于角色的访问控制&quot;&gt;RBAC(Role-Based Access Control)(基于角色的访问控制)&lt;/h2&gt;
&lt;p&gt;ACL的访问控制机制中，直接维护的是用户与功能的关系，这一系列的关系就是一个权限列表。当很多的用户具有相同功能权限的时候，就要进行繁琐的关联操作。RBAC就是在用户与权限之间引入了角色的概念。用户与角色之间做关联，权限列表维护的是角色与功能的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-217218b2658cb6fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RBAC是目前使用最普遍的权限控制模型。当某些用户具备相同的权限的时候，只需要为这些用户建一个角色，把相应的功能关联到这个角色上，生成角色的权限列表。当有新的用户需要相同权限的时候，把用户关联到这个角色上即可。而当用检查或校验用户的操作权限的时候，查询用户所属角色的权限列表即可。&lt;/p&gt;
&lt;p&gt;当然，RBAC也不是完美的，比如想要为某个用户单独设置某个功能权限，可能需要为这个功能权限单独创建一个角色，然后把特定的用户关联到这个角色上。当想要移除某个用户的特定功能权限的时候，可能需要重新设置角色的功能权限，把特定功能权限从当前角色中移除，建立新的角色并关联特定的功能权限，然后再把新角色与相关的用户做关联(也可以直接在特定功能的程序里校验操作用户)&lt;/p&gt;
&lt;p&gt;这里说一个比较常见的RBAC的错误的用法：那就是直接使用角色做权限判断。比如只有角色A才能做文章的删除操作。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function delPost(postId){
    if(!isRole('A')){
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需求该为角色B也可以删除文章。那就必须修改代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function delPost(postId){
    if(!isRole('A')&amp;amp;&amp;amp;!isRole('B')){
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正确的做法应该是添加&quot;删除文章&quot;这个功能，把这个功能关联到相应的角色上。判断的时候是根据功能去判断而不是角色。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function delPost(postId){
    if(!hasPermission('POST_DEL')){
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对“只有角色A才能做文章的删除操作”这一需求，把这个删除功能关联到角色A上，然后把需要这个操作权限的用户加入到角色A中即可。当别的角色也需要这个操作权限，把功能关联到对应角色上即可，不需要再修改代码。&lt;/p&gt;
&lt;p&gt;在RBAC的核心基础上，还可以做相应的扩展，比如角色继承，角色分组之类的，这些扩展都是为了在一定程度简化权限管理工作。&lt;/p&gt;
&lt;h2 id=&quot;abacattribute-based-access-control基于属性的权限控制&quot;&gt;ABAC(Attribute-Based Access Control)(基于属性的权限控制)&lt;/h2&gt;
&lt;p&gt;RBAC虽然是目前最普遍的权限控制模型。但是某些情况下，RBAC是无法满足并且也实现不了的。比如业务员1和业务员2都属于业务员角色，都有查看客户订单的权限。当有一个需求，要求业务员1只能查看北京地区的客户的订单，业务员2只能查看上海的客户的订单。这单单使用RBAC是无法实现。借助RBAC，可行的做法是，分地区创建角色，然后程序中根据角色做数据的过滤，这种做法缺点之前也提到过，需求变更的时候可能需要每次都修改代码。&lt;/p&gt;
&lt;p&gt;上面业务员查看订单的例子，地区是订单的一个属性，需求就是针对这个地区属性来做订单的查询范围的权限控制。这种权限控制方式就是ABAC(Attribute-Based Access Control)(基于属性的权限控制)，也被一些人称为是权限系统设计的未来。&lt;/p&gt;
&lt;p&gt;不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性是否满足某种条件来进行授权判断的（可以编写简单的逻辑）。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。&lt;/p&gt;
&lt;p&gt;例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。&lt;/p&gt;
&lt;p&gt;ABAC非常的灵活，但是实现也是非常的难。这其中涉及到逻辑的动态执行，数据动态过滤等，更加具体就是动态拼接SQL语句(使用ORM的话就是动态组装对应ORM的查询语句)。&lt;/p&gt;
&lt;p&gt;感兴趣的可以在Github上搜索ABAC，看看不同语言是否已经有现成的解决方案。下面说说我学习到的一种实现方式：&lt;/p&gt;
&lt;p&gt;还是业务员查看订单的例子，在RBAC的基础上，扩展一个实体规则，订单就是实体，也就是针对订单设置一系列的规则。规则存储格式可以是json也可以是xml,甚至是Sql语句，能解析即可。比如北京地区这个规则：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;regionId&quot;:1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上海地区：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;regionId&quot;:3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;regionId&lt;/code&gt; 就是系统里对应区域的Id,也是订单或订单相关表的某个字段。&lt;/p&gt;
&lt;p&gt;保存这个规则的时候，规则内容(就是上面的json),规则实体(也就是订单，表明这个规则是针对订单的)是必须的。也可以加上这个规则是适用增删改查中的一种或多种。&lt;/p&gt;
&lt;p&gt;创建好实体的规则，将规则与角色做关联，也就是将北京地区的规则关联到北京地区角色上，上海地区的规则关联到上海地区角色上。&lt;/p&gt;
&lt;p&gt;后端做权限校验的时候，还是先按RBAC模型的控制方式进行校验(是否具备订单查看权限)，然后根据当前操作对象(也就是实体)，取出用户所属角色关联的对应实体的规则。然后解析规则，动态拼接Sql或者ORM语句。&lt;/p&gt;
&lt;p&gt;没做地区限制(或没配置规则)的时候，Sql可能是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select userId,orderNo,createdDate from T_Order&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置了规则，解析拼接后可能就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select userId,orderNo,createdDate from T_Order where regionId=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是针对地区这个属性实现了动态的权限控制。实际开发过程中，要控制的东西是非常多了，查看字段的控制，数据范围的控制。要满足这些复杂的控制，需要制定一套完整的规则，以及针对规则编写相应的解析程序。比如根据配置的规则，最后解析出来可能是各种Sql语句:&amp;lt;,&amp;gt;,=,like,in,not in等等。&lt;/p&gt;
&lt;p&gt;可以看出，要真正的落地实现ABAC是多么的复杂。每次都要解析规则，对程序的性能也造成的影响，就算使用缓存，命中的概率也是非常的小，因为很多因素都是动态的。&lt;/p&gt;
&lt;p&gt;所以，如果需要根据属性做权限判断的场景不是很多的话，还是建议使用RBAC，然后程序中做判断比较省事省力。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;ACL早期定义中是一种权限控制机制，这种机制直接维护的是用户与功能的关系，功能就是针对对象定义的一些操作，比如增删改查的等。用户与功能的关系列表也称为权限列表或访问控制列表，现在说ACL，一般就是指这个权限列表或访问控制列表，但是里面维护的关系不一定是用户与功能的关系，在RBAC中维护的就是角色与功能的关系。&lt;/p&gt;
&lt;p&gt;RBAC在ACL的基础上加入了角色的概念，权限列表或访问控制列表里维护的不再是用户与功能的关系，而是角色与功能的关系。ACL可以和RBAC混着用，既可以在角色上设置权限，也可以直接给用户设置权限，更加灵活。借助角色的思想，可以在用户组，组织，职位等等上设置权限，以便更好的做好权限管理，也就是将权限设置从单一个体转移到某一类组合上。&lt;/p&gt;
&lt;p&gt;ABAC非常的灵活，也非常的难实现。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ce0944b4a903&quot;&gt;权限系统设计模型分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dinolai.com/notes/others/authorization-models-acl-dac-mac-rbac-abac.html&quot;&gt;Authorization Models: ACL, DAC, MAC, RBAC, ABAC&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 13:31:00 +0000</pubDate>
<dc:creator>若邪</dc:creator>
<og:description>前段时间分别用vue和react写了两个后台管理系统的模板</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9833224.html</dc:identifier>
</item>
<item>
<title>ES6 常用总结(前端开发js技术进阶提升总结） - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9833164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9833164.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、变量声明const和let&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;在ES6之前，我们都是用&lt;strong&gt;var&lt;/strong&gt;关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数的最顶部就在全局作用域的最顶部)。这就是函数变量提升例如：
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022202758103-167816308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不用关心bool是否为true or false。实际上，无论如何str都会被创建声明。(如果未声明,返回的是null)&lt;/p&gt;
&lt;p&gt;而es6之后，我们通常用let和const来声明。let表示变量、const表示常量，let和const都是块级作用域。如何理解这个块级作用域？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个函数内部&lt;/li&gt;
&lt;li&gt;在一个代码块内部&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通常来说{}大括号内的代码块即为let和const的作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022203157632-1160185110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;let&lt;/strong&gt; 的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt; 声明的变量都会被认为是常量，表示它的值被设置完成后就不能再修改了。&lt;/p&gt;
&lt;p&gt;如果const的是一个对象，对象所包含的值是可以被修改的。就是对象所指向的地址没有变就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022203639816-701914286.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、模板字符串&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;es6模板字符简直是开发者的福音，解决了es5在字符串功能上的痛点。&lt;br/&gt;&lt;h4&gt;&lt;span&gt;2.1 基本的字符串格式化&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;将表达式嵌入字符串中进行拼接。用${}来界定。
&lt;pre&gt;
&lt;code&gt;//ES5
var way = 'String'
console.log('ES5:' + way)

//ES6
let way = 'String Template'
console.log('ES6:' + way)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;2.2 多行字符串拼接&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022204651450-1073591580.png&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3 更多方法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022204856562-178328428.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、函数新特性&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;&lt;h4&gt;&lt;span&gt;3.1 函数默认参数&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;在ES5我们给函数定义参数默认值是怎么样？
&lt;pre&gt;
&lt;code&gt;function action(num) {
    num = num || 200;
    
    //当传入num时，num为传入的值
    //当没传入参数时，num即有了默认值200
    return num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但细心观察的同学们肯定会发现，num传入为0的时候就是false，但是我们实际的需求就是要拿到num = 0，此时num = 200 明显与我们的实际想要的效果明显不一样。&lt;/p&gt;
&lt;p&gt;ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function action( num = 200 ){
    console.log(num)
}
action(0);  //0
action();   //200
action(300) //300&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;3.2 箭头函数&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。
&lt;p&gt;箭头函数最直观的三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不需要 function 关键字来创建函数&lt;/li&gt;
&lt;li&gt;省略 return 关键字&lt;/li&gt;
&lt;li&gt;继承当前上下文的 this 关键字&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022205444235-89042790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说个小细节。&lt;/p&gt;
&lt;p&gt;当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var people = name =&amp;gt; 'hello' + name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022205616901-385608841.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来道笔试题：把下面ES5代码简化重构成ES6方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022205729241-1421129214.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四、拓展的对象功能&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;&lt;h4&gt;&lt;span&gt;4.1 对象初始化简写&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022205851201-902102611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022205949114-1283072457.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ES6 对象提供了 &lt;code&gt;Object.assign()&lt;/code&gt; 这个方法来实现浅复制。&lt;/p&gt;
&lt;p&gt;Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210039122-1476283594.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、更方便的数据访问--解构&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程。
&lt;p&gt;ES5我们提取对象中的信息形式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210302257-1282191711.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210357239-668831761.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210431267-1075173165.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;六、Spread Operator 展开运算符&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿&lt;code&gt;...&lt;/code&gt;接下来就展示一下它的用途。
&lt;p&gt;组装对象或者数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210644810-1531040906.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210744541-309714282.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;七、import 和 export&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;&lt;h4&gt;&lt;span&gt;7.1 import导入模块、export导出模块&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022210910876-1218061842.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导入的时候有没有大括号的区别是什么。下面是总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当用&lt;code&gt;export default people&lt;/code&gt;导出时，就用 &lt;code&gt;import people&lt;/code&gt; 导入（不带大括号）。&lt;/li&gt;
&lt;li&gt;一个文件里，有且只能有一个export default。但可以有多个export。&lt;/li&gt;
&lt;li&gt;当用export name 时，就用 &lt;code&gt;import{name}&lt;/code&gt; 导入（记得带上大括号）.&lt;/li&gt;
&lt;li&gt;当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 &lt;code&gt;import people,{name,age}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用 &lt;code&gt;import * asexample&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;八、 Promise&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。
&lt;p&gt;说白了就是用同步的方式去写异步代码。&lt;/p&gt;
&lt;p&gt;发起异步请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022211449893-777716058.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;八、 Generators&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字，有意思的是函数会在每个yield后暂停。&lt;/p&gt;
&lt;p&gt;这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。&lt;/p&gt;
&lt;p&gt;OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022211632467-255058302.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那生成器和迭代器又有什么用处呢？&lt;/p&gt;
&lt;p&gt;围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。&lt;/p&gt;
&lt;p&gt;生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。&lt;/p&gt;
&lt;p&gt;那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022211700079-1040943529.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;十、 async 函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;es6引入了 async 函数，使得异步操作变得更加方便。&lt;/p&gt;
&lt;p&gt;async 函数是什么？一句话，它就是 Generator 函数的语法糖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022211902495-873345351.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。&lt;/p&gt;
&lt;p&gt;async函数对 Generator 函数的改进，体现在以下四点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;内置执行器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更好的语义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更广的适用性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值是 Promise&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;十一、 Class基本语法&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数：
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022211948829-1068620696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;es6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。&lt;/p&gt;
&lt;p&gt;基本上，es6 的%(red)[class]可以看作只是一个语法糖，它的绝大部分功能，es5 都可以做到，新的%(red)[class]写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 es6 的%(red)[class]改写，就是下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181022212029532-690592144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，es5 的构造函数Point，对应 es6 的Point类的构造方法。&lt;/p&gt;
&lt;p&gt;Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。&lt;/p&gt;
&lt;p&gt;es6 的类，完全可以看作构造函数的另一种写法。&lt;/p&gt;
&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;1&quot;&gt;&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;文章内容源自：https://mp.weixin.qq.com/s/TmtZBe38dFU-_AqLFd7t0g&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
<pubDate>Mon, 22 Oct 2018 13:23:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、变量声明const和let 在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数的最顶部就在全局作用域的最顶部)。这就是函数变量提升例如： 不用关心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9833164.html</dc:identifier>
</item>
<item>
<title>WCF入门一[WCF概述] - 今天也要元气满满的哦</title>
<link>http://www.cnblogs.com/xwc1996/p/9813728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwc1996/p/9813728.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、什么是WCF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WCF是使用托管代码建立和运行面向服务(Service Oriented)应用程序的统一框架。它使得开发者能够建立一个跨平台的、安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布 式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ（消息队列）。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。WCF可以支持的协议包括TCP，HTTP，跨进程以及自定义，安全模式则包括SAML， Kerberos，X509，用户/密码，自定义等多种标准与模式。也就是说，在WCF框架下，开发基于SOA的分布式系统变得容易了，微软将所有与此相 关的技术要素都包含在内，掌握了WCF，就相当于掌握了叩开SOA大门的钥匙。&lt;/p&gt;
&lt;p&gt;　　最终目标是通过进程或不同的系统、通过本地网络或是通过Internet收发客户和服务之间的消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、第一个WCF程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1.我们先新建一个项目，选择WCF中的WCF服务应用程序新建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022202946729-685499643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.系统生成了两个默认文件：IService1.cs和Service1.svc，其中IService1.cs是定义接口的，Service1.svc用来实现该接口。在这两个文件中可以看到如下的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码和配置文件中的接口名“IService1”。&lt;/span&gt;
&lt;span&gt;    [ServiceContract]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IService1
    {

        [OperationContract]
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GetData(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);

        [OperationContract]
        CompositeType GetDataUsingDataContract(CompositeType composite);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 在此添加您的服务操作&lt;/span&gt;
&lt;span&gt;    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用下面示例中说明的数据约定将复合类型添加到服务操作。&lt;/span&gt;
&lt;span&gt;    [DataContract]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CompositeType
    {
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; boolValue = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; stringValue = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        [DataMember]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; BoolValue
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; boolValue; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { boolValue =&lt;span&gt; value; }
        }

        [DataMember]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; StringValue
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringValue; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { stringValue =&lt;span&gt; value; }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetData(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You entered: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompositeType GetDataUsingDataContract(CompositeType composite)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (composite == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;composite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (composite.BoolValue)
            {
                composite.StringValue &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Suffix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; composite;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到接口文件IService1.cs里有几个特性分别是：[ServiceContract]、[OperationContract]、[DataContract]、[DataMember]，大致的用途如下：&lt;/p&gt;
&lt;p&gt;　　[ServiceContract]：指明该接口是一个WCF的服务契约，可以被外部的调用，不加则无法被外部调用。&lt;/p&gt;
&lt;p&gt;　　[OperationContract]：指明该方法是一个WCF的方法契约，可以被外部的调用，不加则无法被外部调用。&lt;/p&gt;
&lt;p&gt;　　[DataContract]：数据契约，指明该类是可供服务端和客户端相互传递自定义数据的类型，声明后该类型就可以被序列化在服务端和客户端之间传送。&lt;/p&gt;
&lt;p&gt;　　[DataMember]：数据成员，声明后的属性可以参与到客户端和服务器端的类的属性的序列化，没有声明的不参与序列化。&lt;/p&gt;
&lt;p&gt;　　在Service1.svc中已经实现了接口中的方法，将Service1.svc设置为启动项，后调试会如下所示，这是vs自带的服务测试的工具，不过无法测试异步的服务。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022204713616-2119773192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　双击左侧树状图中的方法GetData(),在上方输入值后点击调用可以下方看到方法返回值，则说明我们的接口成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022205053892-495161824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 三、WCF服务的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1.接下来对我们的WCF程序进行发布到本地文件，发布的过程和WEB的项目发布类似，发布后我们部署到IIS上面。右键浏览Service1.svc出现如下的页面后表明发布成功。&lt;a href=&quot;http://192.168.3.30:7358/Service1.svc?wsdl&quot;&gt;http://192.168.3.30:7358/Service1.svc?wsdl&lt;/a&gt;就是我们需要引用的服务地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022210007011-779788188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意如果无法发布成功，可能是部分的Windows功能没有开启，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022210121318-1285924003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2.新建一个新的控制台应用程序，右键引用-&amp;gt;添加服务引用-&amp;gt;将WCF服务引用地址输入点击确认即可引用成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022210621866-556033471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　引用成功后在Service References文件夹下出现了一个ServiceReference1服务，在控制台程序中引用WCF服务的命名空间using ConsoleApplication2.ServiceReference1;使用如下代码即可访问服务接口。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加WCF的服务命名空间&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; ConsoleApplication2.ServiceReference1;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApplication2
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Service1Client是在添加服务引用后服务器端的Service1在客户端的代理类，一般的格式都是&quot;*Client&quot;这种格式的&lt;/span&gt;
            Service1Client sercive = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Service1Client();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = sercive.GetData(&lt;span&gt;666&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WCF服务返回值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　返回结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/988132/201810/988132-20181022211722131-1448224618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这个随笔是我自己学习流程的一个记录，和大家共勉。&lt;/p&gt;

</description>
<pubDate>Mon, 22 Oct 2018 13:19:00 +0000</pubDate>
<dc:creator>今天也要元气满满的哦</dc:creator>
<og:description>一、什么是WCF WCF是使用托管代码建立和运行面向服务(Service Oriented)应用程序的统一框架。它使得开发者能够建立一个跨平台的、安全、可信赖、事务性的解决方案，且能与已有系统兼容协作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xwc1996/p/9813728.html</dc:identifier>
</item>
<item>
<title>【详解】JNI（Java Native Interface） - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9830129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9830129.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;一提到JNI，多数编程者会下意识地感受到一种无法言喻的恐惧。它给人的第一感觉就是&quot;难&quot;，因为它不是单纯地在JVM环境内操作Java代码，而是跳出虚拟机与其他编程语言进行交互。&lt;/p&gt;
&lt;p&gt;　　你可能至今还没听说过这个技术，但是如果你是一个源码爱好者，或者有翻阅过JDK的一些源码，那你一定有接触过native方法。你是否因为查阅源码直到native方法戛然而止，但又由于它的空方法体，而对底层原理不知所以? 本文就带让你了解JNI。并通过一些案例来自己实现JNI的交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是JNI？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　JNI 全称 Java Native Interface。Java本地方法接口，它是Java语言允许Java代码与C、C++代码交互的标准机制。维基百科是这样解释的：“当应用无法完全用Java编程语言实现的时候，（例如，标准Java类库不支持的特定平台特性或者程序库时），JNI使得编程者能够编写native方法来处理这种情况”。这就意味着，在一个Java应用程序中，我们可以使用我们需要的C++类库，并且直接与Java代码交互，而且在可以被调用的C++程序内，反过来调用Java方法（回调函数）。&lt;/p&gt;

&lt;p&gt;JNI的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　（1）JNI使得一些&quot;过程&quot;无需在Java中实现。例如，硬件敏感的，或者直接与操作系统API关联的命令。&lt;/p&gt;
&lt;p&gt;　　（2）由于使用底层的库，如图形，计算，各种类型的渲染等等，可以提高应用的运行性能。&lt;/p&gt;
&lt;p&gt;　　（3）已经有大量的库已经被实现，编程者可直接使用，不用再自行编写。这里的库指的是用其他编程语言实现的程序库，例如IO流或者线程等底层与OS交互的操作都是由C/C++实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;交互模式如图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181021154613683-200287968.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;301&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要从Java调用C++函数，你需要进行以下操作：　&lt;/p&gt;
&lt;p&gt;　　1. 在Java类中创建一个native方法，此方法被本类其他方法调用&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022200933699-176525069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 创建一个头文件，可以利用javah命令生成。&lt;/p&gt;
&lt;p&gt;　　    在头文件中定义它的签名，如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022201101431-191166134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接口规范：&lt;/p&gt;
&lt;p&gt;　　JNIEXPORT &amp;lt;返回类型&amp;gt; JNICALL Java_&amp;lt;包名&amp;gt;_&amp;lt;类名&amp;gt;_&amp;lt;方法名&amp;gt;(JNIEnv*, &amp;lt;原对象引用&amp;gt;，&amp;lt;参数1&amp;gt;..&amp;lt;参数n&amp;gt;)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;extern &quot;C&quot; 只被C++编译器识别，标明此方法利用C的函数命名协议来编译。&lt;/li&gt;
&lt;li&gt;JNIEXPORT 是JNI必要的修饰符。&lt;/li&gt;
&lt;li&gt;数据类型带有&quot;j&quot;前缀的：jdouble,jobject..等是Java对象或类型在C++中的映射&lt;/li&gt;
&lt;li&gt;JNIEnv* 指向JNI 环境，可以利用其调用所有JNI函数&lt;/li&gt;
&lt;li&gt;jobject 引用当前Java对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　3. 创建一个源文件，实现头文件中定义的接口。实现内容就是Java代码调用的C/C++代码。&lt;/p&gt;
&lt;p&gt;　　4. 编译头文件和源文件生成C/C++动态链接库 .so/.dll 文件&lt;/p&gt;
&lt;p&gt;　　5. 此native方法所在类，加载动态链接库。因为加载链接库要在执行native方法之前，所以此加载过程一般放在静态初始化块内执行。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022203434064-385004316.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　或&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022204944001-1066982563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结一下，从Java代码中调用C/C++代码的&lt;strong&gt;流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　（1）创建一个有native标识的方法，并且从其他Java方法调用它&lt;/p&gt;
&lt;p&gt;　　（2）Java编译器生成字节码&lt;/p&gt;
&lt;p&gt;　　（3）C/C++ 编译器生成动态库  .so文件（Linux）或 .dll文件（Windows）&lt;/p&gt;
&lt;p&gt;　　（4）运行程序，执行字节码&lt;/p&gt;
&lt;p&gt;　　（5）执行到loadLibary或load调用的时候，添加一个 .so文件到这个进程中&lt;/p&gt;
&lt;p&gt;　　（6）执行到native方法的时候，通过方法签名，在已打开的.so文件中进行搜索。&lt;/p&gt;
&lt;p&gt;　　（7）如果链接库内有对应方法，就会被执行，否则程序崩溃&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：由于windows没找到生成动态链接库的工具，又不想安装C/C++开发环境，故以下案例都在以CentOS为操作系统的虚拟机内运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;案例一：从Java调用C++代码输出Hello World&lt;/strong&gt; 　　&lt;/p&gt;
&lt;p&gt;　　此案例所有生成的所有文件如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022201546603-1870358974.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（1）创建JNI文件夹，创建Java文件如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022201645813-1127149709.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里，我们定义了一个native方法，是个空方法体，我们在主函数内对其进行调用。&lt;/p&gt;
&lt;p&gt;　　注：这里使用的是System.load从绝对路径引用动态链接库，当然也可以使用loadLibrary方法，其是从java.library.path对应路径下搜索对应名称的库文件并加载。&lt;/p&gt;
&lt;p&gt;　　（2）编译HelloJNI.java文件，生成类文件&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022202010951-780868247.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）利用JDK提供的JNI命令工具，javah生成 .h头文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022202302199-1425079967.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;104&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：发现Linux环境下，javah居然不能从当前文件夹扫描到类文件，需要指定类路径 其中 -cp 就是-classpath&lt;/p&gt;
&lt;p&gt;　　以下是利用javah生成的头文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022202731416-122982360.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）创建HelloJNI.c文件，编写实现体&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022203025333-924061511.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（5）利用gcc生成动态链接库，注意我们这里有引用到jni.h这个头文件，此文件由JDK提供，另外jni.h还引用了jni_md.h这个文件。必须引入这两个头文件，才能通过编译。&lt;/p&gt;
&lt;p&gt;　　两个文件的所在地，本人JDK的安装路径在/usr/java下，每个人可能都不一样。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022203848518-1494129661.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022204056679-1750410310.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在gcc命令内通过指定（ -I 路径 ）引入库所在的目录，利用前面前面的头文件和源文件编译成动态链接库 hello.so&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022204554489-1761157772.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022204629777-1220595280.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（6）运行java程序&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201810/1313132-20181022204826653-672586463.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;55&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由图可知，我们成功调用了C的代码&lt;/p&gt;

&lt;p&gt; 　&lt;strong&gt;　未完待续... &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;以上只介绍了简单的无参函数调用，接下来，还有&lt;/p&gt;
&lt;p&gt;　　Java有参调用C++代码，&lt;/p&gt;
&lt;p&gt;　　C++代码返回值给Java方法，&lt;/p&gt;
&lt;p&gt;　　C++代码获取native方法所在对象的字段值&lt;/p&gt;
&lt;p&gt;　　C++代码调用Java的其他函数（回调）&lt;/p&gt;

</description>
<pubDate>Mon, 22 Oct 2018 13:09:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言： 一提到JNI，多数编程者会下意识地感受到一种无法言喻的恐惧。它给人的第一感觉就是&quot;难&quot;，因为它不是单纯地在JVM环境内操作Java代码，而是跳出虚拟机与其他编程语言进行交互</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9830129.html</dc:identifier>
</item>
<item>
<title>面向对象基础、类和对象、绑定方法 - SherryStarry</title>
<link>http://www.cnblogs.com/wanlei/p/9830483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/9830483.html</guid>
<description>&lt;h2&gt;回顾：面向过程编程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;是一种之前程序员们设计出来的比较好的编程方法，也是一种编程思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心是过程二字，顾名思义，就是先干什么，再干什么，完成一个事情具有的所有步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;优点：复杂的流程简单化，程序化，一步一步拆分，降低开发难度。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;缺点：扩展性差， 不容易维护。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要使用的场景：对扩展性要求不高的，如Linux内核，shell脚本&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;何为面向对象？&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;核心是‘对象’二字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界而非流程的模拟，是一种“上帝式”的思维方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优点:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.对于指挥者(程序员)来说,不需要再关心具体步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.扩展性,一个单独的个体的特征或行为发生变化时 不会影响到别人&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;缺点:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.程序的复杂度变高,你得需要设计这些对象,注意要避免过度设计得问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.程序得执行结果可控性低&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 什么是对象:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在现实生活中实实在在存在的,具备自己的特征和行为的事物&lt;/span&gt;&lt;br/&gt;&lt;span&gt;反过来说 对象就是 特征和行为(技能)的结合体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一堆具备相同特征和行为的事物的抽象概念,不实际存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; conclusion：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先有类还是先有对象:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;生活中:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;生活中类怎么来的,是通过对象的特征和行为抽取而来,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以是先有对象才有了类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编程中:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;必须是先有类 才能有对象,因为你必须先告诉程序,你这个对象有什么样的特征和行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类的作用:用于描述该类的对象具备什么样的特征和行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 补充说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;站的角度不同，定义出的类是截然不同的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现实中的类并不完全等于程序中的类，比如现实中的公司类，在程序中有时需要拆分成部门类，业务类等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时为了编程需求，程序中也可能会定义现实中不存在的类，比如策略类，现实中并不存在，但是在程序中却是一个很常见的类&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果每个对象的这个属性都相同 才应该定义到类中 比如所有人的学校都相同&lt;/span&gt;
    school = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京大学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 语法: 在类名后加括号 与调用函数写法相同&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; stu = Student()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; # 访问对象的属性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(stu.school)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(Student.school)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改属性的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; stu.school = &quot;清华大学&quot;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(stu.school)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; # 增加属性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; stu.room_num = &quot;1008&quot;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(stu.room_num)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; # 删除属性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; del stu.room_num&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(stu.room_num)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对象 与类的名称空间是独立的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; stu.school = &quot;深圳大学&quot;    # 为对象的属性赋予新的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(Student.school) # 类中的属性不会变化&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; stu.room_num = &quot;1008&quot;   # 为对象增加属性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; # print(Student.room_num) #类中也不会出现新的属性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(stu.__dict__)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(Student.__dict__)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象的属性查找顺序：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;对象自己的名称空间 -&amp;gt; 类的名称空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; __init__称之为初始化函数 它会在创建对象的时候自动执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;创建对象时&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.创建一个空对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.执行__init__函数 并且自动传入了这个对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该函数的作用,就是为对象的属性赋初始值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,color,age,gender):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;狗__init__执行了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self)
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
        self.color &lt;/span&gt;=&lt;span&gt; color
        self.gender &lt;/span&gt;= gender
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在创建对象时,传入参数&lt;/span&gt;
&lt;span&gt;
dog1 &lt;/span&gt;= Dog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大黄&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黄色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
dog2 &lt;/span&gt;= Dog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;二哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;白色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dog1.&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dog2.&lt;span&gt;__dict__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 使用场景 需要为每个对象定制不同的属性值&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;2.__init__在创建对象后自动执行&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;3.第一个self参数 指的是这个对象本身 不需要手动传值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    country &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age,gender):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
        self.gender &lt;/span&gt;=&lt;span&gt; gender

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sleep(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sleeping&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eating&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; p1 = Person(&quot;矮根&quot;,68,&quot;female&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; p2 = Person(&quot;成伟&quot;,18,&quot;female&quot;)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类调用类中函数 与 对象调用的区别&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; p1.sleep()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; p2.sleep()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(Person.sleep)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(p1.sleep)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类调用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Person.sleep(10)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 对象调用&lt;/span&gt;&lt;span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; p1.sleep()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类调用与对象调用的区别&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于类而言 sleep就是一个普通函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对对象而言 sleep是一个绑定方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;绑定方法是什么?&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;是对象与类中的某个函数的绑定关系 就像生活中 我们都会吃饭 我吃饭你不会饱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那么吃饭就是我自己的绑定方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么要把函数进行绑定?&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为对象的行为 通常都需要访问这个对象的数据 或是修改这个对象的数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果没有对象 直接调用函数是没有意义的 在函数中访问不到对象的数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以将对象和函数进行绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特殊之处&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在使用绑定方法时 不需要关心self参数 会自动将这个对象本身传进来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对象调用绑定方法时 最后执行的还是类中的那个函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;练习题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟一个王者荣耀对砍游戏，&lt;/span&gt;&lt;span&gt;两个英雄可以对砍 如果血量小于等于0 就GG，考虑&lt;/span&gt;&lt;span&gt;所需的对象和&lt;/span&gt;&lt;span&gt;英雄的对象。&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hero:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,hero_type,name,blood,q,w,e):
        self.hero_type &lt;/span&gt;=&lt;span&gt; hero_type
        self.blood &lt;/span&gt;=&lt;span&gt; blood
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.q &lt;/span&gt;=&lt;span&gt; q
        self.w &lt;/span&gt;=&lt;span&gt; w
        self.e &lt;/span&gt;=&lt;span&gt; e
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; Q(self,enemy):&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跳起来给你一刀&lt;/span&gt;
         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 对 %s 释放了Q技能 造成%s点伤害，对方剩余血量%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
               %(self.name,enemy.name,self.q,enemy.blood-&lt;span&gt;self.q))
         enemy.blood &lt;/span&gt;-=&lt;span&gt;self.q
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; enemy.blood &amp;lt;=&lt;span&gt; 0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hero %s is GG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;enemy.name)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; W(self,enemy):&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给你一脚&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 对 %s 释放了W技能 造成%s点伤害，对方剩余血量%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
              %(self.name,enemy.name,self.w,enemy.blood-&lt;span&gt;self.w))
        enemy.blood &lt;/span&gt;-=&lt;span&gt;self.w
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; enemy.blood &amp;lt;=&lt;span&gt; 0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hero %s is GG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;enemy.name)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; E(self,enemy):&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 大宝剑&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 对 %s 释放了Q技能 造成%s点伤害，对方剩余血量%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
              %(self.name,enemy.name,self.e,enemy.blood-&lt;span&gt;self.e))
        enemy.blood &lt;/span&gt;-=&lt;span&gt; self.e
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; enemy.blood &amp;lt;=&lt;span&gt; 0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hero %s is GG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;enemy.name)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义英雄的对象&lt;/span&gt;
yashe = Hero(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;战士&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;亚瑟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,200,50,30,100) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;q,w,e 50,30,100&lt;/span&gt;
daji = Hero(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;法师&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;妲己&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,180,10,30,180) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;q,w,e 10,30,180&lt;/span&gt;
&lt;span&gt;
yashe.E(daji)
daji.W(yashe)
yashe.W(daji)
daji.Q(yashe)
yashe.Q(daji)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;亚瑟 对 妲己 释放了Q技能 造成100点伤害，对方剩余血量80
妲己 对 亚瑟 释放了W技能 造成30点伤害，对方剩余血量170
亚瑟 对 妲己 释放了W技能 造成30点伤害，对方剩余血量50
妲己 对 亚瑟 释放了Q技能 造成10点伤害，对方剩余血量160
亚瑟 对 妲己 释放了Q技能 造成50点伤害，对方剩余血量0
Hero 妲己 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; GG
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 22 Oct 2018 13:06:00 +0000</pubDate>
<dc:creator>SherryStarry</dc:creator>
<og:description>一、面向对象编程 回顾：面向过程编程 是一种之前程序员们设计出来的比较好的编程方法，也是一种编程思想。 核心是过程二字，顾名思义，就是先干什么，再干什么，完成一个事情具有的所有步骤。 优点：复杂的流程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/9830483.html</dc:identifier>
</item>
</channel>
</rss>