<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用Travis CI自动部署Hexo到GitHub - Dmego</title>
<link>http://www.cnblogs.com/dmego/p/7664877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dmego/p/7664877.html</guid>
<description>&lt;h4 id=&quot;原文链接转载请注明出处使用travis-ci自动部署hexo到github&quot;&gt;原文链接（转载请注明出处）：&lt;a href=&quot;http://dmego.me/2017/10/13/deylpoy-hexo-with-TravisCI.html&quot;&gt;使用Travis CI自动部署Hexo到GitHub&lt;/a&gt;&lt;/h4&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;hexo + gitPages&lt;/code&gt; 搭建个人博客的人都知道，每当要发表一篇博文，第一步得手动使用 &lt;code&gt;hexo g&lt;/code&gt; 命令生成静态网页，然后还得通过 &lt;code&gt;hexo d&lt;/code&gt; 命令将静态文件推送到GitHub远程仓库,不说麻烦不麻烦，更重要的是有时候环境换了，没有搭建 hexo 环境，想发篇博客的时候就没有可能了。而现在通过 Travis CI 就能自动构建自己的博客。我们只需将写好的 &lt;code&gt;Markdown&lt;/code&gt; 格式的博文&lt;code&gt;push&lt;/code&gt; 到 hexo源文件 分支即可。&lt;/p&gt;
&lt;h2 id=&quot;travis-ci-介绍&quot;&gt;Travis CI 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; 是目前新兴的开源持续集成构建项目，它与 jenkins，GO的很明显的特别在于采用 yaml 格式，简洁清新独树一帜。目前大多数的 github 项目都已经移入到 Travis CI 的构建队列中，据说 Travis CI 每天运行超过 4000 次完整构建。&lt;/p&gt;
&lt;h2 id=&quot;hexo-介绍&quot;&gt;hexo 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;h2 id=&quot;使用-travis-自动构建&quot;&gt;使用 Travis 自动构建&lt;/h2&gt;
&lt;p&gt;我的博客自动部署思路是，将 &lt;code&gt;hexo&lt;/code&gt; 源码 &lt;code&gt;push&lt;/code&gt; 到博客 项目的另外一个分支，&lt;br/&gt;既一个分支放源码，一个分支放静态文件，使用 &lt;code&gt;Travis CI&lt;/code&gt; 自动部署 hexo 源码的分支，构建完成后自动推送到 静态文件的分支上，而这一切都在一个仓库上进行操作。&lt;/p&gt;&lt;p&gt;注意：如果使用的是&lt;code&gt;GitPage&lt;/code&gt;的个人站点来搭建博客的 ，则博客静态文件在 &lt;code&gt;master&lt;/code&gt;分支上；如果使用的是 &lt;code&gt;gitPages&lt;/code&gt; 的项目站点来搭建博客，则博客的静态文件在 &lt;code&gt;gh-pages&lt;/code&gt; 分支上。&lt;/p&gt;
&lt;h3 id=&quot;在github-上生成-access-token&quot;&gt;在GitHub 上生成 Access Token&lt;/h3&gt;
&lt;p&gt;如果想要 让&lt;code&gt;travis CI&lt;/code&gt; 构建完成之后自动 push 到 master 分支，则travis需要有对这个仓库进行操作的权限，此时我们就需要为Travis CI 配置Access Token（访问令牌）。&lt;/p&gt;&lt;p&gt;在GitHub上生成Access Token 的步骤是，点击头像进入设置（Settings）,r然后点击左边菜单栏最下面的&lt;code&gt;Developer settings&lt;/code&gt; 选项，进入后点击左边的 &lt;code&gt;Personal access tokens&lt;/code&gt; 选项，进入后点击右上角的&lt;code&gt;Generate new token&lt;/code&gt; 按钮&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/G0hFA1LkK7.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;点击后就会来到下面的界面，先给 Token 起一个名字，然后为它设置一些权限，其中红框内的权限是必须的，其他可以随意添加。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/5G22L5hCcK.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;点击下面的 &lt;code&gt;create token&lt;/code&gt; 按钮，就会生成一个已经赋予好权限的 token 值，接下来我们Travis CI 网站的配置中。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/fldkB30k3m.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-travis-ci&quot;&gt;配置 Travis CI&lt;/h3&gt;
&lt;p&gt;如果之前从未使用 &lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; 来构建项目，则我们先需要使用GitHub账号来登录网站,登录进来后，会进到如下图界面，如果底下 没有把 GitHub 仓库中的项目加载进来，可以手动点击右上角的 &lt;code&gt;Sync account&lt;/code&gt; 按钮，待到同步完成后将要自动构建的项目开启。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/0IbbdiJh18.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;开启后点击设置图标就可以进行一系列的设置，如下图所示，先开启 &lt;code&gt;General&lt;/code&gt; 里的两项选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Build only if .travis.yml is present&lt;/code&gt;:只有在&lt;code&gt;.travis.yml&lt;/code&gt;文件中配置的分支改变了才构建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Build branch updates&lt;/code&gt;:当分支更新后开始构建&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在 &lt;code&gt;Environment Variables&lt;/code&gt; 一栏里将在 GitHub 下获取的的 &lt;code&gt;Access Token&lt;/code&gt; 值添加进来&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/3b875iHdi4.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加配置文件到hexo源码分支下&quot;&gt;添加配置文件到Hexo源码分支下&lt;/h3&gt;
&lt;p&gt;上面提到的 &lt;code&gt;.travis.yml&lt;/code&gt; 配置文件需要添加到hexo 源码的根目录下，因为Travis CI 在自动构建时需要获取这些配置信息，以此来完成构建任务；这些配置信息主要包括源码分支，静态文件推送分支，仓库地址等信息。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/CaBF4laGji.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;其中主要内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;language: node_js
node_js: stable

# S: Build Lifecycle
install:
  - npm install

#before_script:
 # - npm install -g gulp

script:
  - hexo g

after_script:
  - cd ./public
  - git init
  - git config user.name &quot;dmego&quot; --{GitHub账户名称}
  - git config user.email &quot;zengkai12138@outlook.com&quot; --{Github账户邮箱}
  - git add .
  - git commit -m &quot;Update docs&quot;
  - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master
# E: Build LifeCycle

branches:
  only:
    - hexo --{Hexo源码分支名称}
env:
 global:
   - GH_REF: github.com/dmego/dmego.github.io.git --{仓库地址}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置到这一步就已经把所有配置全部完成，下面就是验证的过程&lt;/p&gt;
&lt;h2 id=&quot;构建并自动部署结果&quot;&gt;构建并自动部署结果&lt;/h2&gt;
&lt;p&gt;将某篇文章中的一个表格增加一行后将修改推送到hexo源码所在的&lt;code&gt;hexo&lt;/code&gt;分支&lt;br/&gt;,然后等Travis CI 构建并自动部署成功后。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/F83mk0a09k.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;点击博文发现表格多了一行。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/171014/hk2hCAma3D.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这样做虽然能很好的实现自动部署的功能，但是有个问题也要注意，就是博客源码公开问题，如果对博客源码不介意的可以直接使用公开仓库，如果介意那就没有办法了，除非使用付费的私有仓库，或者把项目放在&lt;code&gt;Coding&lt;/code&gt;上去，因为上有提供免费的私有仓库。就我个人认为，既然是自己的博客，本来就是要给人看的，博客源码也谈不上存在什么隐私。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 18:22:00 +0000</pubDate>
<dc:creator>Dmego</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dmego/p/7664877.html</dc:identifier>
</item>
<item>
<title>如何训练自己专注力 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7664717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7664717.html</guid>
<description>&lt;blockquote readability=&quot;2.2093023255814&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;原文作者： &lt;a href=&quot;http://leobabauta.com/&quot;&gt;LEO BABAUTA&lt;/a&gt;&lt;br/&gt;原文地址：&lt;a href=&quot;https://zenhabits.net/focus-training/&quot;&gt;How to Train Yourself to Stay Focused&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个常见的问题：在手机上的浏览器标签和应用程序之间来回切换，检查刷新社交媒体，短信和电子邮件，同时思考你必须做的数百万件事情，但一直把要做的事情不断搁置……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次只专注于一项任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且很难摆脱改变、分散专注力的心理习惯，就好像让猴子从一个闪亮的东西跳到另一个闪亮的东西。&lt;/p&gt;
&lt;p&gt;那么，你如何训练你的大脑更加专注呢？有可能更好办法，但我不建议把专注力集中在接近100%的时间。甚至不是80%，也许不是50%。只是比现在更多，这足以让你在一天中看到成效的巨大差异。&lt;/p&gt;
&lt;p&gt;最近我接手了一个教练客户，他最大的改进领域是专注。所以我给了他一个计划，我将在这里与大家分享。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;你为什么要关心这个？在付出任何计划之前最好先考虑一下，因为当事情变得不舒服时，你必须知道为什么。否则你会在第一次冲动下崩溃。&lt;/p&gt;
&lt;p&gt;这很重要，因为不断的转换和分心会导致你的时间被浪费掉，所以这一天过去以后，你几乎没有做任何重要的事情。你照顾那些小的事情时却在大任务上耽搁了，更糟糕的是，浪费了一整天的注意力。你的生命太宝贵，不能浪费，所以你要想好好利用你的每一天。&lt;/p&gt;
&lt;p&gt;一次只专注于某一项任务，至少在某一天，这将有助于你完成重要的事情：写作、编程、学习、打理财务、创造任何类型的东西，等等。这些事情往往会被推迟，但坚持下去会让你在最重要的事情上取得更大的进步。&lt;/p&gt;
&lt;p&gt;如果你感到压力很大，而你又必须做的事情，对你的专注意力不集中感到不满。那么，这一项技能将帮助你在很大程度上扭转这一局面。&lt;/p&gt;
&lt;p&gt;我们来看看怎么做。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;其实相当简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选一个最重要的任务。早上的第一件事，在你打电话或上网之前，想想你需要做些什么。在你的生活和工作中最大的不同是什么？如果你有几个不同，那没关系。现在就随便选一个。你可以稍后再去找其他人。不要把你的时间浪费在优柔寡断上，关键是要用来实践你的任务。今天你选择的这一项任务是你最重要的任务(Most Important Task (MIT))。&lt;/li&gt;
&lt;li&gt;做15分钟的专注区间。一旦你开始一天的工作(也许是准备好了，用餐后，瑜伽/冥想/锻炼，等等)，清除所有的浏览器标签，应用程序，以及你今天不需要的任何东西。开始一个15分钟的计时器。&lt;/li&gt;
&lt;li&gt;你只有两种选择。在这15分钟里，你不能切换到其他任何事情(不查看电子邮件、信息、社交媒体、做其他工作任务、清理办公桌等)。你只能：a)在你的最重要的任务里，或者b)坐在那里什么也不做。那是你唯一的选择。注意你的冲动，但不要跟随它们。&lt;/li&gt;
&lt;li&gt;向一个负责任的伙伴报告。我的教练客户将在很大程度上成功，因为他让我对他负责。找一个能让你负起责任的伴侣。创建一个在线电子表格，或者使用一个他们可以看到的问责应用程序(例如，他向我介绍了&lt;a href=&quot;https://www.committo3.com/&quot;&gt;Commit to 3&lt;/a&gt;)。每天集中专注力区间后，检查一下你做了什么。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就是这样！一天的专注区间至少持续两周。如果你做的很好，每天都要添加第二个专注区间，在两次区间之间休息10分钟。如果你有任何问题，那就在第一个月坚持一个，然后再加第二个。&lt;/p&gt;
&lt;p&gt;在六个星期到两个月的时间里，你应该很擅长做两个15分钟的专注区间，你可以增加第三个。然后是第四次，这很容易。在那里停一会儿，然后在下午再加一个专注区间。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;有了这个简单的方法，我有几个关键的想法拿来分享：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关掉你的网络。比如断开wifi或关闭路由器，或者使用网络拦截器。关掉你的手机。关闭浏览器和所有不需要的应用程序。这是最理想的方法。如果你在做最重要的任务时需要网络，那么关闭所有的标签，只保留一两个与任务相关的标签，不要让自己打开任何其他东西。&lt;/li&gt;
&lt;li&gt;如果你关掉网络，就要把铅笔和纸放在附近。如果你有一个想法，一个你需要记住的任务，你想找的任何东西……把它记在纸上。你可以稍后再看。不要让自己来回切换。&lt;/li&gt;
&lt;li&gt;不要让自己合理地推迟专注区间。很容易就会说，“我会稍后去做”，然后你把它推迟到早上，然后下午，最后你是在晚上8点做的，只是说你做了。这违背了实践的目的。注意你的理性，不要为它们而堕落。&lt;/li&gt;
&lt;li&gt;也就是说，不要追求完美。有些时候你做不到——对我来说，这正是我旅行或招待客人的时候。如果有什么大的事情发生而你没有足够的时间，不要担心错过了一天。尽快回到这个问题上。担心保持连胜势头会适得其反。&lt;/li&gt;
&lt;li&gt;如果15分钟太长，只要做10分钟。如果时间还长，就做5分钟。&lt;/li&gt;
&lt;li&gt;慢慢地增加你的专注区间的次数。不急着做更多的事。专注于建立一个坚实的基础。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好的，你已经获得了训练专注力的方法。现在开始实践吧！&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;“本译文仅供个人研习、欣赏语言之用，谢绝任何转载及用于任何商业用途。本译文所涉法律后果均由本人承担。本人同意简书平台在接获有关著作权人的通知后，删除文章。”&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 13 Oct 2017 17:49:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7664717.html</dc:identifier>
</item>
<item>
<title>canvas图表详解系列（1）：柱状图 - 苏天天</title>
<link>http://www.cnblogs.com/chengduxiaoc/p/7664397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengduxiaoc/p/7664397.html</guid>
<description>
&lt;p&gt;本章建议学习时间4小时&lt;/p&gt;
&lt;p&gt;学习方式：详细阅读，并手动实现相关代码（如果没有canvas基础，需要先学习前面的canvas基础笔记）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习目标&lt;/strong&gt;：此教程将教会大家如何使用canvas绘制各种图表，详细分解步骤，本次讲解柱状图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;柱状图&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;柱状图是前端最基本的图表之一，我们的案例展示效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171014002505387-1618063263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能：横轴年份，纵轴产量，图表会更具年份的多少自动分配柱的宽度，高度会有由低到高的运动效果，当鼠标移入时，当前柱会颜色加深。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;--新建Html文件，写入canvas标签，并且定义绘制图表的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;barChart&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;400&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin:50px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 你的浏览器不支持HTML5 canvas &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装绘制图表的方法&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; goBarChart(dataArr){
            
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用方法，并传入需要显示的数据&lt;/span&gt;
&lt;span&gt;        goBarChart(
                [[&lt;/span&gt;&lt;span&gt;2007&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;750&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2008&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;425&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2009&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;960&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;700&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;800&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2012&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;975&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;375&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;775&lt;/span&gt;&lt;span&gt;]]
        )
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;--在 goBarChart方法中定义需要使用的变量 并获取 canvas上下文 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            //&lt;/span&gt;&lt;span&gt; 声明所需变量&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; canvas,ctx;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表属性&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; cWidth, cHeight, cMargin, cSpace;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; originX, originY;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 柱状图属性&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; bMargin, tobalBars, bWidth, maxValue;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; totalYNomber;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; gradient;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运动相关变量&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ctr, numctr, speed;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移动&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; mousePosition =&lt;span&gt; {};

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得canvas上下文&lt;/span&gt;
            canvas = document.getElementById(&quot;barChart&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(canvas &amp;amp;&amp;amp;&lt;span&gt; canvas.getContext){
                ctx &lt;/span&gt;= canvas.getContext(&quot;2d&quot;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;--初始化图表  （接着上一步的代码写在 goBarChart方法中 ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
            initChart(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initChart(){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表信息&lt;/span&gt;
                cMargin = 30&lt;span&gt;;
                cSpace &lt;/span&gt;= 60&lt;span&gt;;
                cHeight &lt;/span&gt;= canvas.height - cMargin*2 -&lt;span&gt; cSpace;
                cWidth &lt;/span&gt;= canvas.width - cMargin*2 -&lt;span&gt; cSpace;
                originX &lt;/span&gt;= cMargin +&lt;span&gt; cSpace;
                originY &lt;/span&gt;= cMargin +&lt;span&gt; cHeight;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 柱状图信息&lt;/span&gt;
                bMargin = 15&lt;span&gt;;
                tobalBars &lt;/span&gt;=&lt;span&gt; dataArr.length;
                bWidth &lt;/span&gt;= parseInt( cWidth/tobalBars - bMargin );
                maxValue = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;dataArr.length; i++&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; barVal = parseInt( dataArr[i][1&lt;span&gt;] );
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( barVal &amp;gt;&lt;span&gt; maxValue ){
                        maxValue &lt;/span&gt;=&lt;span&gt; barVal;
                    }
                }
                maxValue &lt;/span&gt;+= 50&lt;span&gt;;
                totalYNomber &lt;/span&gt;= 10&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运动相关&lt;/span&gt;
                ctr = 1&lt;span&gt;;
                numctr &lt;/span&gt;= 100&lt;span&gt;;
                speed &lt;/span&gt;= 10&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;柱状图渐变色&lt;/span&gt;
                gradient = ctx.createLinearGradient(0, 0, 0, 300&lt;span&gt;);
                gradient.addColorStop(&lt;/span&gt;0, 'green'&lt;span&gt;);
                gradient.addColorStop(&lt;/span&gt;1, 'rgba(67,203,36,1)'&lt;span&gt;);

            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;--绘制图表的轴和标记 （接着上一步的代码写在 goBarChart方法中 ）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171014004739824-577746361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
            drawLineLabelMarkers(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
            
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawLineLabelMarkers(){
                ctx.translate(&lt;/span&gt;0.5,0.5);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当只绘制1像素的线的时候，坐标点需要偏移，这样才能画出1像素实线&lt;/span&gt;
                ctx.font = &quot;12px Arial&quot;&lt;span&gt;;
                ctx.lineWidth &lt;/span&gt;= 1&lt;span&gt;;
                ctx.fillStyle &lt;/span&gt;= &quot;#000&quot;&lt;span&gt;;
                ctx.strokeStyle &lt;/span&gt;= &quot;#000&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; y轴&lt;/span&gt;
&lt;span&gt;                drawLine(originX, originY, originX, cMargin);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; x轴&lt;/span&gt;
                drawLine(originX, originY, originX+&lt;span&gt;cWidth, originY);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标记&lt;/span&gt;
&lt;span&gt;                drawMarkers();
                ctx.translate(&lt;/span&gt;-0.5,-0.5);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还原位置&lt;/span&gt;
&lt;span&gt;            }
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画线的方法&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawLine(x, y, X, Y){
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(X, Y);
                ctx.stroke();
                ctx.closePath();
            }
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标记&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawMarkers(){
                ctx.strokeStyle &lt;/span&gt;= &quot;#E0E0E0&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制 y&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; oneVal = parseInt(maxValue/totalYNomber);
                ctx.textAlign = &quot;right&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;=totalYNomber; i++&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; markerVal =  i*&lt;span&gt;oneVal;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xMarker = originX-5&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; yMarker = parseInt( cHeight*(1-markerVal/maxValue) ) + cMargin;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(xMarker, yMarker+3,markerVal/maxValue,originY);&lt;/span&gt;
                    ctx.fillText(markerVal, xMarker, yMarker+3, cSpace); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(i&amp;gt;0&lt;span&gt;){
                        drawLine(originX, yMarker, originX&lt;/span&gt;+&lt;span&gt;cWidth, yMarker);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制 x&lt;/span&gt;
                ctx.textAlign = &quot;center&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;tobalBars; i++&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; markerVal = dataArr[i][0&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xMarker = parseInt( originX+cWidth*(i/tobalBars)+bMargin+bWidth/2&lt;span&gt; );
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; yMarker = originY+15&lt;span&gt;;
                    ctx.fillText(markerVal, xMarker, yMarker, cSpace); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标题 y&lt;/span&gt;
&lt;span&gt;                ctx.save();
                ctx.rotate(&lt;/span&gt;-Math.PI/2);
                ctx.fillText(&quot;产 量&quot;, -canvas.height/2, cSpace-10);
&lt;span&gt;                ctx.restore();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标题 x&lt;/span&gt;
                ctx.fillText(&quot;年份&quot;, originX+cWidth/2, originY+cSpace/2+10&lt;span&gt;);
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-- 绘制柱状图（接着上一步的代码写在 goBarChart方法中 ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
            drawBarAnimate(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制柱状图的动画&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制柱形图&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawBarAnimate(mouseMove){
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;tobalBars; i++&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oneVal = parseInt(maxValue/totalYNomber);
                    &lt;span&gt;var&lt;/span&gt; barVal = dataArr[i][1&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; barH = parseInt( cHeight*barVal/maxValue * ctr/&lt;span&gt;numctr );
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = originY -&lt;span&gt; barH;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = originX + (bWidth+bMargin)*i +&lt;span&gt; bMargin;
                    drawRect( x, y, bWidth, barH, mouseMove );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高度减一避免盖住x轴&lt;/span&gt;
                    ctx.fillText(parseInt(barVal*ctr/numctr), x+15, y-8); //&lt;span&gt; 文字
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ctr&amp;lt;&lt;span&gt;numctr){
                    ctr&lt;/span&gt;++&lt;span&gt;;
                    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        ctx.clearRect(&lt;/span&gt;0,0&lt;span&gt;,canvas.width, canvas.height);
                        drawLineLabelMarkers();
                        drawBarAnimate();
                    }, speed);
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制方块&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawRect( x, y, X, Y, mouseMove ){

                ctx.beginPath();
                ctx.rect( x, y, X, Y );
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mouseMove &amp;amp;&amp;amp; ctx.isPointInPath(mousePosition.x, mousePosition.y)){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是鼠标移动的到柱状图上，重新绘制图表&lt;/span&gt;
                    ctx.fillStyle = &quot;green&quot;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    ctx.fillStyle &lt;/span&gt;=&lt;span&gt; gradient;
                    ctx.strokeStyle &lt;/span&gt;=&lt;span&gt; gradient;
                }
                ctx.fill();
                ctx.closePath();

            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;--检测鼠标移动并显示当前项（接着上一步的代码写在 goBarChart方法中 ）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：这里鼠标移动的检测在有文字缩放显示的高清屏幕上会有偏差不准确的情况，而且在高清屏幕中canvas中的文字会略显模糊，以后会专门写一篇如何处理这个问题，大家可以先不管这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测鼠标移动&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; mouseTimer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            canvas.addEventListener(&lt;/span&gt;&quot;mousemove&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
                e &lt;/span&gt;= e ||&lt;span&gt; window.event;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e.layerX || e.layerX==0&lt;span&gt; ){
                    mousePosition.x &lt;/span&gt;=&lt;span&gt; e.layerX;
                    mousePosition.y &lt;/span&gt;=&lt;span&gt; e.layerY;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( e.offsetX || e.offsetX==0&lt;span&gt; ){
                    mousePosition.x &lt;/span&gt;=&lt;span&gt; e.offsetX;
                    mousePosition.y &lt;/span&gt;=&lt;span&gt; e.offsetY;
                }
                
                clearTimeout(mouseTimer);
                mouseTimer &lt;/span&gt;= setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    ctx.clearRect(&lt;/span&gt;0,0&lt;span&gt;,canvas.width, canvas.height);
                    drawLineLabelMarkers();
                    drawBarAnimate(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                },&lt;/span&gt;10&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;--当点击canvas的时候重新刷新图表（接着上一步的代码写在 goBarChart方法中 ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击刷新图表&lt;/span&gt;
            canvas.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                initChart(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;
                drawLineLabelMarkers(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
                drawBarAnimate(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制折线图的动画&lt;/span&gt;
            };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样我们整个代码就编写完成了，为了代码更便于阅读，我们可以将所有方法放到后面，把调用方法的代码放到前面，经过调整的全部代码如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;120&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;barChart&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;400&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin:50px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 你的浏览器不支持HTML5 canvas &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; goBarChart(dataArr){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明所需变量&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; canvas,ctx;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表属性&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; cWidth, cHeight, cMargin, cSpace;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; originX, originY;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 柱状图属性&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; bMargin, tobalBars, bWidth, maxValue;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; totalYNomber;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; gradient;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运动相关变量&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ctr, numctr, speed;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移动&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mousePosition &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {};

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得canvas上下文&lt;/span&gt;
&lt;span&gt;            canvas &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;barChart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(canvas &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; canvas.getContext){
                ctx &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; canvas.getContext(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            initChart(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;
&lt;span&gt;            drawLineLabelMarkers(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
&lt;span&gt;            drawBarAnimate(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制柱状图的动画&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测鼠标移动&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mouseTimer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            canvas.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mousemove&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
                e &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; window.event;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;( e.layerX &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; e.layerX&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; ){
                    mousePosition.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.layerX;
                    mousePosition.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.layerY;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;( e.offsetX &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; e.offsetX&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; ){
                    mousePosition.x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.offsetX;
                    mousePosition.y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.offsetY;
                }
                
                clearTimeout(mouseTimer);
                mouseTimer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    ctx.clearRect(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,canvas.width, canvas.height);
                    drawLineLabelMarkers();
                    drawBarAnimate(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                },&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击刷新图表&lt;/span&gt;
&lt;span&gt;            canvas.onclick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                initChart(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;
&lt;span&gt;                drawLineLabelMarkers(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
&lt;span&gt;                drawBarAnimate(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制折线图的动画&lt;/span&gt;
&lt;span&gt;            };


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表初始化&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initChart(){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图表信息&lt;/span&gt;
&lt;span&gt;                cMargin &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
                cSpace &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
                cHeight &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; canvas.height &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; cMargin&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt; cSpace;
                cWidth &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; canvas.width &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; cMargin&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt; cSpace;
                originX &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; cMargin &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; cSpace;
                originY &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; cMargin &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; cHeight;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 柱状图信息&lt;/span&gt;
&lt;span&gt;                bMargin &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
                tobalBars &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; dataArr.length;
                bWidth &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt( cWidth&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tobalBars - bMargin );&lt;/span&gt;
&lt;span&gt;                maxValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataArr.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; barVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt( dataArr[i][&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] );
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;( barVal &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; maxValue ){
                        maxValue &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; barVal;
                    }
                }
                maxValue &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
                totalYNomber &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运动相关&lt;/span&gt;
&lt;span&gt;                ctr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                numctr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
                speed &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;柱状图渐变色&lt;/span&gt;
&lt;span&gt;                gradient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; ctx.createLinearGradient(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
                gradient.addColorStop(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                gradient.addColorStop(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rgba(67,203,36,1)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制图表轴、标签和标记&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawLineLabelMarkers(){
                ctx.translate(&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当只绘制1像素的线的时候，坐标点需要偏移，这样才能画出1像素实线&lt;/span&gt;
&lt;span&gt;                ctx.font &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12px Arial&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ctx.lineWidth &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                ctx.fillStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ctx.strokeStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; y轴&lt;/span&gt;
&lt;span&gt;                drawLine(originX, originY, originX, cMargin);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; x轴&lt;/span&gt;
&lt;span&gt;                drawLine(originX, originY, originX&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;cWidth, originY);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标记&lt;/span&gt;
&lt;span&gt;                drawMarkers();
                ctx.translate(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还原位置&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画线的方法&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawLine(x, y, X, Y){
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(X, Y);
                ctx.stroke();
                ctx.closePath();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标记&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawMarkers(){
                ctx.strokeStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#E0E0E0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制 y&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt;&lt;span&gt; oneVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt(maxValue&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;totalYNomber);&lt;/span&gt;
&lt;span&gt;                ctx.textAlign &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt;totalYNomber; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; markerVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;  i&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;oneVal;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xMarker &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; originX&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; yMarker &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt( cHeight&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;markerVal&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;maxValue) ) + cMargin;&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(xMarker, yMarker+3,markerVal/maxValue,originY);&lt;/span&gt;
&lt;span&gt;                    ctx.fillText(markerVal, xMarker, yMarker&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, cSpace); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
                        drawLine(originX, yMarker, originX&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;cWidth, yMarker);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制 x&lt;/span&gt;
&lt;span&gt;                ctx.textAlign &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tobalBars; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; markerVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; dataArr[i][&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xMarker &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt( originX&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;cWidth&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;(i&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tobalBars)+bMargin+bWidth&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; );
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; yMarker &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; originY&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
                    ctx.fillText(markerVal, xMarker, yMarker, cSpace); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标题 y&lt;/span&gt;
&lt;span&gt;                ctx.save();
                ctx.rotate(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Math.PI&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2);&lt;/span&gt;
&lt;span&gt;                ctx.fillText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;产 量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;canvas.height&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2, cSpace-10);&lt;/span&gt;
&lt;span&gt;                ctx.restore();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标题 x&lt;/span&gt;
&lt;span&gt;                ctx.fillText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年份&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, originX&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;cWidth&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2, originY+cSpace&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制柱形图&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawBarAnimate(mouseMove){
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tobalBars; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; oneVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt(maxValue&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;totalYNomber);&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; barVal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; dataArr[i][&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; barH &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parseInt( cHeight&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;barVal&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;maxValue * ctr&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;numctr );
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; originY &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; barH;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; originX &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; (bWidth&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;bMargin)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; bMargin;
                    drawRect( x, y, bWidth, barH, mouseMove );  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高度减一避免盖住x轴&lt;/span&gt;
&lt;span&gt;                    ctx.fillText(parseInt(barVal&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;ctr&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;numctr), x+15, y-8); &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt; 文字
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ctr&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;numctr){
                    ctr&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;
                    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        ctx.clearRect(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,canvas.width, canvas.height);
                        drawLineLabelMarkers();
                        drawBarAnimate();
                    }, speed);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制方块&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawRect( x, y, X, Y, mouseMove ){

                ctx.beginPath();
                ctx.rect( x, y, X, Y );
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(mouseMove &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; ctx.isPointInPath(mousePosition.x, mousePosition.y)){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是鼠标移动的到柱状图上，重新绘制图表&lt;/span&gt;
&lt;span&gt;                    ctx.fillStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    ctx.fillStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; gradient;
                    ctx.strokeStyle &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; gradient;
                }
                ctx.fill();
                ctx.closePath();

            }


        }


        goBarChart(
                [[&lt;/span&gt;&lt;span&gt;2007&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;750&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2008&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;425&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2009&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;960&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;700&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;800&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2012&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;975&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;375&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;775&lt;/span&gt;&lt;span&gt;]]
        )


    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，今天就讲到这里，希望大家把代码都自己敲一遍。&lt;/p&gt;


&lt;p&gt;关注公众号，博客更新即可收到推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171011124427824-1210633966.jpg&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Oct 2017 16:55:00 +0000</pubDate>
<dc:creator>苏天天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengduxiaoc/p/7664397.html</dc:identifier>
</item>
<item>
<title>解决Android5.0以下Dialog引起的内存泄漏 - soar.</title>
<link>http://www.cnblogs.com/endure/p/7664320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endure/p/7664320.html</guid>
<description>&lt;p&gt;　　最近项目开发中，开发人员和测试人员均反应在android5.0以下手机上LeakCanary频繁监控到内存泄漏，如下图所示，但凡用到Dialog或DialogFragment地方均出现了内存泄漏。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014004345402-1279207897.png&quot;&gt;&lt;img title=&quot;V3GE@Z_X6XB(D4MBU$%D_8L&quot; border=&quot;0&quot; alt=&quot;V3GE@Z_X6XB(D4MBU$%D_8L&quot; src=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014004345902-802910208.png&quot; width=&quot;423&quot; height=&quot;434&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，存在一个Message实例的obj成员变量，间接引用着Activity的实例，导致Activity无法正常退出。通过Android Monitors内存快照分析，确实有Message实例持有对LoadingDialogFragment的引用，进而导致Activity也无法正常销毁，出现内存泄漏（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014005158855-212817385.png&quot;&gt;&lt;img title=&quot;QQ图片20170928192056&quot; border=&quot;0&quot; alt=&quot;QQ图片20170928192056&quot; src=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014005159465-1806464362.png&quot; width=&quot;860&quot; height=&quot;404&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　参考&lt;a href=&quot;https://github.com/hehonghui/android-tech-frontier/blob/master/issue-25/%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-Square.md&quot;&gt;一个内存泄漏引发的血案&lt;/a&gt;一文，了解到问题发生原因：局部变量的生命周期在Dalvik VM跟ART/JVM中有区别。在DVM中，假如线程死循环或者阻塞，那么线程栈帧中的局部变量假如没有被置为null，那么就不会被回收。 在 VM 中，每一个栈帧都是本地变量的集合，而垃圾回收器是保守的：只要存在一个存活的引用，就不会回收它。在每次循环结束后，本地变量不再可访问，然而本地变量仍持有对 Message 的引用，interpreter/JIT 理论上应该在本地变量不可访问时将其引用置为 null，然而它们并没有这样做，引用仍然存活，而且不会被置为 null，使得它不会被回收。&lt;/p&gt;
&lt;p&gt;　　1、例如HandlerThread中，Looper会不停的从阻塞队列MessageQueue中取Message进行处理。当没有可消费Message对象时，就会开始阻塞，而此时最后一个被取出的Message就会被本地变量引用，一直不会释放引用，哪怕Message已经被recycler（仅仅是清理了内容并放回消息队列）。其实到这一步，只是一个空壳的Message被泄漏，无法回收，毕竟Message实例的内容还是被清理了（demo中的SecondActivity模拟了没有recycler时的泄漏情况，适用于自己实现类似HandlerThread时需要注意的情况）。&lt;/p&gt;
&lt;p&gt;　　2、在Dialog源码中，我们可以看到如下代码片段，包括setOnCancelListener、setOnDismissListener在内的方法，其实都是将设置进来的listener对象（listener对象包含对Activity的引用）放到一个从消息队列中拿到的Message实例中，将listener赋给了Message实例的obj变量。例如mShowMessage，mShowMessage会一直保存这个Message实例，不会再放回消息队列中，因为在sendShowMessage时，Dialog是从消息队列中再次obtain一个Message实例，复制mShowMessage内容进行发送。当然前面这些也不会存在什么问题，mShowMessage也会在Dialog销毁时跟着销毁。&lt;/p&gt;
&lt;p&gt;　　综合1与2，分开来看，一般情况下大家互不干扰。但两者碰撞在一起时，问题就来了。&lt;u&gt;Dialog从消息队列中可能会恰巧取到一个“仍然被某个阻塞中的HandlerThread本地变量引用的Message实例”，然后把listener赋给Message的obj，并一直保存在Dialog实例中（例如mShowMessage），&lt;/u&gt;这样内存泄漏就发生了。就算Dialog销毁，本地变量仍然引用保持着对Message的引用，导致obj变量的指向的listener无法回收，listener又包含对Activity的引用，导致Activity也无法正确回收。&lt;/p&gt;
&lt;p&gt;　　在这种情况下，除非HandlerThread收到新的Message处理，而给本地变量重新赋值从而切断了对上一个Message引用，否则会一直内存泄漏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOnShowListener(@Nullable OnShowListener listener) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (listener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mShowMessage &lt;/span&gt;=&lt;span&gt; mListenersHandler.obtainMessage(SHOW, listener);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            mShowMessage &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendShowMessage() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mShowMessage != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Obtain a new message so this dialog can be re-used&lt;/span&gt;
&lt;span&gt;            Message.obtain(mShowMessage).sendToTarget();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解决方案：我们可以通过提供一个DialogInterface.OnCancelListener的包装类（Dialog其他listener也一样可行），仅包含对真正listener的引用，当Dialog退出后，解除对listener的引用。还有一个办法就是在Handler空闲时发送一个空Message，当然处理Dialog Message的Handler我们无法直接控制（在Dialog内部的私有变量），所以采用包装类方法解决。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DetachableDialogCancelListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DialogInterface.OnCancelListener
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DetachableDialogCancelListener wrap(DialogInterface.OnCancelListener delegate)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DetachableDialogCancelListener(delegate);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DialogInterface.OnCancelListener delegateOrNull;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DetachableDialogCancelListener(DialogInterface.OnCancelListener delegate)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delegateOrNull =&lt;span&gt; delegate;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCancel(DialogInterface dialog)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delegateOrNull != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            delegateOrNull.onCancel(dialog);
            delegateOrNull &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearOnDetach(Dialog dialog)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;=&lt;span&gt; Build.VERSION_CODES.JELLY_BEAN_MR2
                &lt;/span&gt;&amp;amp;&amp;amp; Build.VERSION.SDK_INT &amp;lt;&lt;span&gt; Build.VERSION_CODES.LOLLIPOP)
        {
            dialog.getWindow()
                    .getDecorView()
                    .getViewTreeObserver()
                    .addOnWindowAttachListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewTreeObserver.OnWindowAttachListener()
                    {
                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onWindowAttached()
                        {

                        }

                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onWindowDetached()
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delegateOrNull != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            {
                                delegateOrNull.onCancel(dialog);
                                delegateOrNull &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            }
                        }
                    });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下图所示，通过对内存进行快照，看到确实达到了我们的目的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014005200309-1426486561.png&quot;&gt;&lt;img title=&quot;QQ图片20170928192156&quot; border=&quot;0&quot; alt=&quot;QQ图片20170928192156&quot; src=&quot;http://images2017.cnblogs.com/blog/535813/201710/535813-20171014005200902-1425344726.png&quot; width=&quot;894&quot; height=&quot;420&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　当然，问题并没有因此而结束，当我将所有设置了setOnCancelListener等监听事件的地方都用包装类处理后，仍然收到了LeakCanary的内存泄漏通知。到底是怎么回事呢？通过一番debug，发现在DialogFragment的onActivityCreated中，设置过setOnCancelListener和setOnDismissListener，当自己再去设置时，还是会发生内存泄漏。其实问题就出在默认的设置，虽然我们重新设置了，但在执行默认设置时，仍然有可能会恰巧取到一个“仍然被某个阻塞中的HandlerThread本地变量引用的Message实例”，就算后面被重新设置了，但包含默认listener设置的Message仍然还被HandlerThread的本地变量引用，所以也就内存泄漏了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onActivityCreated(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityCreated(savedInstanceState);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mShowsDialog) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        View view &lt;/span&gt;=&lt;span&gt; getView();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view.getParent() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                        &lt;/span&gt;&quot;DialogFragment can not be attached to a container view&quot;&lt;span&gt;);
            }
            mDialog.setContentView(view);
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Activity activity =&lt;span&gt; getActivity();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (activity != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mDialog.setOwnerActivity(activity);
        }
        mDialog.setCancelable(mCancelable);
        mDialog.setOnCancelListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mDialog.setOnDismissListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (savedInstanceState != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Bundle dialogState &lt;/span&gt;=&lt;span&gt; savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dialogState != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                mDialog.onRestoreInstanceState(dialogState);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，问题既然出在DialogFragment的onActivityCreated默认设置上，那么如果能取消默认的设置，就不会发生内存泄漏。上面这段代码是DialogFragment的源码，不能修改，而super.onActivityCreated又必须调用。如何解决呢？看上面代码的第5行，通过调用setShowsDialog将mShowDialog设置为false，这样super.onActivityCreated就等于不会执行剩余代码逻辑了。在自己的onActivityCreated中，自行实现super类中本应执行的代码逻辑（copy即可），然后将setOnCancelListener和setOnDismissListener通过包装类进行设置，我这里是直接删除了这两行代码，由继承自BaseDialogFragment的子类自行设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseDialogFragment &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DialogFragment
{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onActivityCreated(Bundle savedInstanceState)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;lt;&lt;span&gt; Build.VERSION_CODES.LOLLIPOP)
        {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isShow = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getShowsDialog();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setShowsDialog(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityCreated(savedInstanceState);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setShowsDialog(isShow);

            View view &lt;/span&gt;=&lt;span&gt; getView();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view.getParent() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                            &lt;/span&gt;&quot;DialogFragment can not be attached to a container view&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDialog().setContentView(view);
            }
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Activity activity =&lt;span&gt; getActivity();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (activity != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDialog().setOwnerActivity(activity);
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getDialog().setCancelable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isCancelable());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (savedInstanceState != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Bundle dialogState &lt;/span&gt;= savedInstanceState.getBundle(&quot;android:savedDialogState&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dialogState != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDialog().onRestoreInstanceState(dialogState);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityCreated(savedInstanceState);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，Dialog和DialogFragment在Android5.0以下的内存泄漏问题均得以解决。但该方案并不完美，能够解决内存泄漏的关键，还是通过监听OnWindowAttachListener，在Dialog退出时切断Message实例与真正listener对象的关联。但OnWindowAttachListener需要level18，所以。。。如果有什么好的低版本同样实现，烦请告知，感谢！&lt;/p&gt;
&lt;p&gt;　　如果是使用DialogFragment，可以在onDestory中切断Message实例与真正listener对象的关联。&lt;/p&gt;
&lt;p&gt;　　补充，本文一直在重点分析Dialog如何因为Message产生内存泄漏。而事实上，自己写的HandlerThread中，如果是Android5.0以下，一定要在取出Message用完后，将Message置为null，并且要防止被编译器优化掉，否则也会因为HandlerThread阻塞后，导致Message无法正确释放包含的内容，产生内存泄漏。（可运行本文给出的demo，重现问题）。&lt;/p&gt;
&lt;p&gt;　　demo运行后，打开SecondActivity，发送Message，然后返回，此时Activity应该被销毁，但LeakCanary会提示内存泄漏。将SecondActivity的Handler中取出的msg用完后置为null即可解决。而FourActivity模拟了HandlerThread发生泄漏的情况，可以尝试用本文提出的办法解决，Demo中给出了通过发送一个空消息，回收本地变量引用的Message实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/soar1/DialogLeak&quot; target=&quot;_blank&quot;&gt;demo GitHub地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 16:44:00 +0000</pubDate>
<dc:creator>soar.</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endure/p/7664320.html</dc:identifier>
</item>
<item>
<title>c#中常量、ReadOnly和Static ReadOnly的差异 - 东城慕水</title>
<link>http://www.cnblogs.com/chen-jie/p/10-differences-between-constant-vs-readonly-static-readonly-fields.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-jie/p/10-differences-between-constant-vs-readonly-static-readonly-fields.html</guid>
<description>&lt;p&gt;&lt;strong&gt;不定时更新翻译系列，此系列更新毫无时间规律，文笔菜翻译菜求各位看官老爷们轻喷，如觉得我翻译有问题请挪步原博客地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本博文翻译自：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://www.arungudelli.com/tutorial/c-sharp/10-differences-between-constant-vs-readonly-static-readonly-fields/&quot;&gt;&lt;strong&gt;http://www.arungudelli.com/tutorial/c-sharp/10-differences-between-constant-vs-readonly-static-readonly-fields/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在c#中常量中修饰符使字段或局部变量保持不变。ReadOnly应用于c#中的字段，在初始化后值是常量。Static ReadOnly使ReadOnly字段具有类成员的特性。(可通过类名访问)&lt;/p&gt;
&lt;p&gt;请仔细阅读关于常量和readonly之间的差异的总结，然后我将试着解释后面的每一点。&lt;/p&gt;
&lt;h3 id=&quot;常量与readonly字段在c中的10个主要区别&quot;&gt;常量与Readonly字段在c#中的10个主要区别&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;23.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;const关键字可以应用于字段或局部变量&lt;/td&gt;
&lt;td&gt;readonly关键字只应用于字段而不是局部变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;我们必须在公开的时候分配常量字段&lt;/td&gt;
&lt;td&gt;我们可以在声明或构造函数时指定readonly字段，而不是在任何其他方法中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;没有分配内存，因为在编译后，在IL代码中嵌入了常量值&lt;/td&gt;
&lt;td&gt;为Readonly字段分配的动态内存，可以在我们运行时获得值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;常量在c#中是默认静态的。只能通过类名访问&lt;/td&gt;
&lt;td&gt;Readonly属于需要过类实例访问的对象。要使它成为类成员，我们需要在readonly之前添加static关键字。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;15&quot;&gt;&lt;td&gt;我们可以声明如下所构建的(基本类型)数据类型为常量 Boolean,Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal和string.&lt;/td&gt;
&lt;td&gt;一样不变&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;值是常量(因为它属于类)&lt;/td&gt;
&lt;td&gt;根据使用的构造函数(因为它属于类的对象)，其值可能会有所不同&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;如果我们想要对某些类(非原始类型)声明常量，我们应该将其赋值为null，但是这是没有用的。&lt;/td&gt;
&lt;td&gt;如果声明一个非基本类型(引用类型)，readonly只有引用是不可变的，而不是它包含的对象。(见下面的例子)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;不要使用可能导致dll版本问题时发生变化的const字段(参见示例)&lt;/td&gt;
&lt;td&gt;当在运行时获得的值时，没有dll版本控制问题 Static ReadOnly字段的Const字段不能作为ref或out参数传递&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;c中的常量字段或局部变量&quot;&gt;C#中的常量字段或局部变量:&lt;/h3&gt;
&lt;p&gt;在C#中我们将使用关键字 &quot;&lt;em&gt;const&lt;/em&gt;&quot; 声明常量字段或局部变量.&lt;/p&gt;
&lt;p&gt;当你定义一个常量字段时，它的值必须在声明本身的时候被分配，之后我们不能改变它的值。通过下面的例子来了解它&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Public class Program
        {
           const int fieldConstant = 10; //字段

           static void Main(string[] args)
           {
             const int X = 10, Y = 50; //正确的 //局部变量
             const int Z = X + Y;      //正确的
             const int A = X + GettheValue(); // 错误的
           } 
           public static int GettheValue()
           {
             const int localx=10;
             return 10;
           }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前两行没有任何错误，因为X、Y、Z字段值是在编译时本身进行计算的。但是在第三行中，我们声明了一个变量“A”作为常量，并尝试使用GettheValue()方法在运行时返回值。由于必须在编译时分配常量变量，因此该行不会执行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;c#中的 &lt;strong&gt;字段&lt;/strong&gt; 是在类或结构中直接声明的变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的示例中 &lt;em&gt;fieldConstant&lt;/em&gt; 是一个字段，因为它在程序类中直接声明。&lt;/p&gt;
&lt;p&gt;我们可以将局部变量声明为 &lt;em&gt;const&lt;/em&gt; ，如上面所示的GetTheValue()方法。&lt;/p&gt;
&lt;p&gt;以下构建的值类型可以声明为常量：int, long, char, float, double, decimal, bool, byte, short,string变量也可作为常量&lt;/p&gt;
&lt;p&gt;我们可以将非基原类型赋给null来定义一个常量。但是，将一个常量引用类型声明为null是没有用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            const string constantString = &quot;Hi Iam Constant&quot;; //正确的
            const Program program = new Program(); //错误的
            const Program program1 = null; //正确的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们不能将一个常量变量声明为静态变量，因为默认情况下，常量被视为静态成员。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            ReadonlyConstant r1=new ReadonlyConstant();// 请参阅下面的类声明代码
            Console.WriteLine(r1.ynumber);              //错误的
            Console.WriteLine(ReadonlyConstant.ynumber);//正确的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为默认静态的常量变量，我们无法从类的实例中访问它。所以我们不能将const值作为ref或out参数传递。&lt;/p&gt;
&lt;h3 id=&quot;c中的readonly字段&quot;&gt;C#中的ReadOnly字段:&lt;/h3&gt;
&lt;p&gt;在C#中我们可以将字段声明为ReadOnly而不是局部变量。&lt;/p&gt;
&lt;p&gt;ReadOnly字段可以在声明的时候进行初始化，或者只能在对象创建时只调用一次的构造函数中进行初始化，而不是在任何其他方法中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ReadonlyConstant
    {
        
        public const int numberOfDays = 7; //字段
        public readonly double PI=3.14;             //内联初始化
        
        public readonly int znumber;
        public readonly List&amp;lt;int&amp;gt; readonlyList;

        public ReadonlyConstant()
        {
            znumber= 50;//构造函数初始化          
        }

        public ReadonlyConstant(int x)
        {
             znumber=100;
        }
        
        public NormalMethod()
        {
            //readonly int i=0; 这是错误的
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据使用的构造函数，值可能会有所不同。即，readonly字段属于类的对象。&lt;/p&gt;
&lt;p&gt;现在我们将讨论常量和readonly字段之间的区别，正如在第二个点中提到的，常量字段没有分配内存，而值直接嵌入IL代码中。请参阅下面的IL代码图片。&lt;br/&gt;&lt;img src=&quot;http://speed.arungudelli.com/wp-content/uploads/2017/09/Constant-Readonly-IL-Code.png&quot; alt=&quot;Constant-Readonly-IL-Code&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我使用resharper工具查看了上面的示例程序(ReadonlyConstant.cs)的中间语言(IL)代码。&lt;/p&gt;
&lt;p&gt;正如您可以看到的IL代码的const字段numberOfdays的值(7)直接嵌入IL代码。其中，readonly字段piValue显示为piValue。该值可在运行时获得。&lt;/p&gt;
&lt;p&gt;这就导致了版本控制问题。&lt;/p&gt;
&lt;h3 id=&quot;c中常量字段的版本控制&quot;&gt;C#中常量字段的版本控制:&lt;/h3&gt;
&lt;p&gt;我将上面的示例程序编译为类库(A)，并在另一个项目(B)中使用它作为参考。现在看一下生成的项目B的IL代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://speed.arungudelli.com/wp-content/uploads/2017/09/Readonly-Constant-IL-Code.png&quot; alt=&quot;Readonly and Constant field difference at IL Code&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目B的代码中，在IL代码中嵌入的常量字段数的值。现在的问题是，在源中(A类库的ReadonlyConstant.cs)，常量字段 (numberOfdays )值改为5，并编译并生成一个新的dll&lt;/p&gt;
&lt;p&gt;但是，除非我们编译这个项目，否则这个常量字段的新值不会影响B项目。编译后，新的常量字段值将嵌入到项目B的IL代码中。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们将使用static readonly字段。&lt;/p&gt;
&lt;h3 id=&quot;c中的static-readonly&quot;&gt;C#中的static readonly&lt;/h3&gt;
&lt;p&gt;由于readonly字段值不同，取决于使用的构造函数。为了使它成为类成员(静态成员)和唯一的类，我们将在变量之前添加static关键字，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ReadonlyStatic
{
   public static readonly string x = &quot;Hi&quot;;
   public static readonly string y;

   public ReadonlyStatic()
   {
     //y = &quot;Hello&quot;; 这是错误的
   }

   static ReadonlyStatic()
   {
      y = &quot;Hello&quot;;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以把它作为常量使用，在整个类中，我们将解决dll版本的常量变量问题。可能存在一些性能问题，但不需要构建目标项目，因为值可以在运行时获得。&lt;/p&gt;
&lt;p&gt;如上面的示例所示，我们仅在声明或静态构造函数时分配static readonly字段。&lt;/p&gt;
&lt;h3 id=&quot;c中readonly和static-readonly&quot;&gt;C#中Readonly和Static Readonly:&lt;/h3&gt;
&lt;p&gt;以下是C#中readonly和static readonly字段之间的主要区别。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可以在声明或构造函数的时候分配&lt;/td&gt;
&lt;td&gt;在声明或静态构造函数时可以分配&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;根据使用的构造函数，值可能会不同&lt;/td&gt;
&lt;td&gt;初始化后值将是常量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;在c中何时使用常量和readonly&quot;&gt;在C#中何时使用常量和readonly&lt;/h3&gt;
&lt;p&gt;当值是绝对不变的时候，使用常量，这在时间上是不变的。例如一周的天数是7。这始终是常数。而在使用static readonly时，要避免dll版本问题。&lt;/p&gt;
&lt;p&gt;由于在IL内嵌有不变的值，我们可以使用常量修饰符来获得性能上的好处。&lt;/p&gt;
&lt;p&gt;如果我们想要对类(或对象)的不同实例使用不同的常量值，请使用readonly。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明翻译原文出处(本文章)，原文出处(原博客地址)，然后谢谢观看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果觉得我的翻译对您有帮助，请点击推荐支持：）&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 16:34:00 +0000</pubDate>
<dc:creator>东城慕水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-jie/p/10-differences-between-constant-vs-readonly-static-readonly-fields.html</dc:identifier>
</item>
<item>
<title>c++ 11 移动语义、std::move 左值、右值、将亡值、纯右值、右值引用 - 张东升</title>
<link>http://www.cnblogs.com/zhangdongsheng/p/7664228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangdongsheng/p/7664228.html</guid>
<description>&lt;p&gt;先看看下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rvalue_reference.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HugeMem
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    HugeMem(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size) : sz(size&lt;span&gt;)
    {
        pIntData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[sz];
    }
    HugeMem(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; HugeMem &amp;amp;&lt;span&gt; h) : sz(h.sz)
    {
        pIntData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[sz];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sz; i++&lt;span&gt;)
            pIntData[i] &lt;/span&gt;=&lt;span&gt; h.pIntData[i];
    }
    &lt;/span&gt;~&lt;span&gt;HugeMem()
    {
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; pIntData [];
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;pIntData;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sz;
};

HugeMem GetTemp()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HugeMem(&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _tmain(&lt;span&gt;int&lt;/span&gt; argc, _TCHAR*&lt;span&gt; argv[])
{
    HugeMem a &lt;/span&gt;=&lt;span&gt; GetTemp();
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码拷贝构造函数会被调用两次，一次是从GetTemp函数中有HugeMem()生成的一个临时值用作返回值，另外一次则由临时值构造出main中的变量a。析构函数调用了三次。这个过程如果指针指向非常大的内存时拷贝构造 的代价相当昂贵。而令人堪忧的是：临时变量的生产和销毁以及拷贝构造的发生对于程序员来说基本上是透明的，不会影响程序的正确性，因而即使该问题导致性能不佳，也不易被程序员察觉。&lt;/p&gt;
&lt;p&gt;而关键的问题是，临时对象在构造和释放时，一去一来似乎并没有太大意义，那么我们是否可以在临时对象构造a时不分配内存，即不使用所谓的拷贝构造函数呢？&lt;/p&gt;
&lt;p&gt;那有人又要问了，为什么不用指针会给GetTemp的参数?首先需要指针或引用的方法而不返回值的话，通常需要很多条语句来完成上面的工作。&lt;/p&gt;
&lt;p&gt;例如以下语句：&lt;/p&gt;
&lt;p&gt;Caculate(GetTeam(),SomeOther(mabe(),UseFul(Value,2)));&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;但是如果通过传引用和指针而不返回值的话，那需要多条语句来完成上面的工作：&lt;br/&gt;string * a,vector b;//事先声明一些变量用于传递返回值&lt;br/&gt;...&lt;br/&gt;UseFul(Value,2,a)&lt;br/&gt;SomeOther(maybe(),a,b);&lt;br/&gt;Caculate(GetTemp(),b)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;此时移动语义应运而生。&lt;/p&gt;
&lt;p&gt;要想了解移动语义，则需要从左值和右值说起。&lt;/p&gt;

&lt;p&gt;判断左值和右值的方法有两种&lt;/p&gt;
&lt;p&gt;1.在等号左边的值就称为左值而在等号右边的称为右值&lt;/p&gt;
&lt;p&gt;2.另外在c++中还有一种判别方法就是可以取地址，有名的就是左值，不能取地址，没有名的就是右值&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;a = b + c&lt;/p&gt;
&lt;p&gt;a在等号左边被值为左值&lt;/p&gt;
&lt;p&gt;b+c在等号右边被称为右值&lt;/p&gt;
&lt;p&gt;a有名，可以取地址称为左值&lt;/p&gt;
&lt;p&gt;b+c没名，不可以取地址称为右值&lt;/p&gt;


&lt;p&gt;在c++ 11中右值被分为纯右值和将亡值&lt;/p&gt;
&lt;p&gt;其中纯右值就是c++98中的标准右值用于标记临时变量或不根对象有关的值。&lt;/p&gt;
&lt;p&gt;将亡值是在c++ 11中跟右值引用相关的表达式，这种表达式通常是被移动的对象（移为他用），比如返回右值引用T&amp;amp;&amp;amp;的函数返回值 ,std::move的返回值，或者转换为T&amp;amp;&amp;amp;的类型转换函数的返回值，而剩余的可以标识函数，对象的值都属于左值。&lt;/p&gt;
&lt;p&gt;在c++ 11中，所有的值必须为左值、纯右值、将亡值的三种的任一一种。&lt;/p&gt;

&lt;p&gt;c++ 11中，右值引用就是对一个右值进行引用 的类型，事实上，通常右值不巨有名称，我们只能通过引用来找到他的存在 一般情况下，我们只能从右值表达式获得他的引用&lt;/p&gt;
&lt;p&gt;int &amp;amp;&amp;amp; c = RetValue();&lt;/p&gt;

&lt;p&gt;c++ 98中的引用一般都称为左值引用&lt;/p&gt;
&lt;p&gt;int d = 100;&lt;br/&gt;int &amp;amp; dd = d;//这种是c++98里面的左值引用&lt;/p&gt;


&lt;p&gt;在上面右值引用的例子中,RetValue()在函数返回右值表达式结束后，他的生命也就终结了，而右值引用的声明，又给他“重获新生”，他的生命周期将与他的右值引用c的生命周期一样，只要c还活前些，该右值临时变量都会一直存活下去&lt;/p&gt;
&lt;p&gt;所以相比以下声明&lt;/p&gt;
&lt;p&gt;CObj c = RetValue()&lt;/p&gt;
&lt;p&gt;CObj &amp;amp;&amp;amp; c = RetValue()&lt;/p&gt;
&lt;p&gt;不使用右值引用就会多一次构造和析构&lt;/p&gt;
&lt;p&gt;声明一个右值引用的类型前提是RetValue()返回的是一个右值，通常情况下右值引用是不能够绑定左值的。比如下面的代码是无法通过编译的&lt;/p&gt;
&lt;p&gt;int d = 100;&lt;br/&gt;int &amp;amp; dd = d;//这种是c++98里面的左值引用 &lt;br/&gt;int &amp;amp;&amp;amp; dd2 = d;//无法通过编译 ，编译器提示无法将右值引用绑定到左值&lt;/p&gt;
&lt;p&gt;相应的，是否可以将一个左值引用绑定一个右值呢，例如：&lt;/p&gt;
&lt;p&gt;int &amp;amp; d = 100;//不可以，编译错误&lt;/p&gt;
&lt;p&gt;以上代码说明相应的左值引用无法绑定一个右值&lt;/p&gt;
&lt;p&gt;但是c98有一种常左值引用就是const T&amp;amp;，这在c98里是“万能”引用类型，他可以接受，非常量左值，常量左值，右值对其初始化例如：&lt;/p&gt;
&lt;p&gt;int d = 100;&lt;/p&gt;
&lt;p&gt;const int e  = 100;&lt;/p&gt;
&lt;p&gt;const int &amp;amp; c = d;//接受一个非常量左值&lt;br/&gt;const int &amp;amp; v = e;//接受一个常量左值&lt;br/&gt;const int &amp;amp; z = 3 + 4;//接受一个右值&lt;/p&gt;

&lt;p&gt;int Add(const T &amp;amp; s1,const T &amp;amp; s2);&lt;/p&gt;

&lt;p&gt;void Test(CTestObj &amp;amp;&amp;amp; a) //在函数内部还可以修改引用a 的值&lt;/p&gt;
&lt;p&gt;就本例而言我们可以这样写这个函数&lt;/p&gt;
&lt;p&gt;void Test(CTestObj &amp;amp;&amp;amp; a)&lt;br/&gt;{&lt;br/&gt;     CTestObj b = std::move(a)   ;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;std::move的作用时，强制使一个左值成为右值，使用移动语义的前提是CTestObj还需要添加一个右值引用为参数的移动构造函数。&lt;/p&gt;
&lt;p&gt;这样一来CTestObj类的临时对象（即ReturnValue的返回的临时值）包含一些大块指针，就可以从临时对象中“窃”为已用。事实上右值引用的存在从来就是和移动语义有关。&lt;/p&gt;
&lt;p&gt;假如我们没有为CTestObj声明一个移动构造函数，而只声明一个常量左值为参数的构造函数会发生什么？如同我们前面所说的常量左值引用是一个万能的引用，无论常量左值，非常量左值，右值都可以。那么如果我们不声明移动构造函数，下列语句：&lt;/p&gt;
&lt;p&gt;CTestObj b = std::move(a)&lt;/p&gt;
&lt;p&gt;将调用常量左值引用为参数的拷贝构造函数。这是一种非常安全的设计----移动不成至少还可以执行拷贝。因此程序页会为声明了移动构造函数的类声明一个常量左值引用为参数的拷贝构造函数，以保证移动不成时可以拷贝构造 。&lt;/p&gt;
&lt;p&gt;为了语义完整c++ 11中还存在一个常量右值引用例如：&lt;/p&gt;
&lt;p&gt;const T &amp;amp;&amp;amp; a = ReturnRValue()&lt;/p&gt;
&lt;p&gt;不过常量右值引用一般没有用武之地。&lt;/p&gt;

&lt;p&gt;std::move并不能移动任何东西，他唯一的功能是将左值转化为右值，继而我们可以用右值引用引用这个值，以用于移动语义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rvalue_reference.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Moveable
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Moveable() :i(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)) {}
    &lt;/span&gt;~Moveable() { &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; i;}
    Moveable(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Moveable &amp;amp; s) : i(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(*&lt;span&gt;s.i)) {}
    Moveable(Moveable &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; s) : i(s.i)
    {
        s.i &lt;/span&gt;=&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt; i;
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _tmain(&lt;span&gt;int&lt;/span&gt; argc, _TCHAR*&lt;span&gt; argv[])
{
    Moveable a;
    Moveable c &lt;/span&gt;= a; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会调用拷贝构造函数&lt;/span&gt;
&lt;span&gt;
    Moveable d;
    Moveable e(std::move(d));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会调用移动构造函数&lt;/span&gt;
&lt;span&gt;
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; *d.i &amp;lt;&amp;lt; std::endl;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会出现违规访问此时i指针为nullptr&lt;/span&gt;
    
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是典型的误用std::move的例子，事实上要使用该必须是程序员清楚需要转换的时候。比如上面代码中程序员应该知道被转化为右值的a不可以再使用。我们需要转化为右值引用还是应该是一个确实生命周期即将结束的对象。&lt;/p&gt;
&lt;p&gt;下面是一个正确使用std::move的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rvalue_reference.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HugeMem
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    HugeMem(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size) : sz(size &amp;gt; &lt;span&gt;0&lt;/span&gt; ? size : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int[&lt;/span&gt;&lt;span&gt;sz];
    }
    &lt;/span&gt;~&lt;span&gt;HugeMem()
    {
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; [] c;
    }
    HugeMem(HugeMem &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; hm) : sz(hm.sz), c(hm.c)
    {
        hm.c &lt;/span&gt;=&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sz;
};


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Moveable
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Moveable() :i(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;)),h(&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;) {}
    &lt;/span&gt;~Moveable() { &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; i;}
    Moveable(Moveable &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; s) : i(s.i), h(std::move(s.h))
    {
        s.i &lt;/span&gt;=&lt;span&gt; nullptr;
    }
    HugeMem h;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt; i;
};

Moveable GetTemp()
{
    Moveable temp &lt;/span&gt;=&lt;span&gt; Moveable();
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;huge mem GetTemp:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; temp.h.c &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;

}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _tmain(&lt;span&gt;int&lt;/span&gt; argc, _TCHAR*&lt;span&gt; argv[])
{
    Moveable a(GetTemp());
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;huge mem main:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; @&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; a.h.c &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/174805/201710/174805-20171013234741949-1539399938.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;由结果可以看出移动语义解决了拷贝语文带来的拷贝开销，在拷贝内存较大时，性能犹为明显&lt;/p&gt;
&lt;p&gt;如果没有std::move会怎样？&lt;/p&gt;
&lt;p&gt;因为移动构造函数的参数是 (T &amp;amp;&amp;amp; b)，右值引用参数可以接收的值为非常量右值，其它值都不可以转化为右值引用参数，所以必须要用到std::move&lt;/p&gt;


</description>
<pubDate>Fri, 13 Oct 2017 16:07:00 +0000</pubDate>
<dc:creator>张东升</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangdongsheng/p/7664228.html</dc:identifier>
</item>
<item>
<title>用sed实现wc -c的功能 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/7663831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/7663831.html</guid>
<description>&lt;p&gt;　　sed是所谓的流编辑器，我们经常用它来做一些文本替换的事情，这是sed最擅长的事情，如sed 's/Bob/Tom/g'就是把文章中所有的Bob改成Tom。&lt;/p&gt;
&lt;p&gt;　　sed是图灵完备的，作为sed的粉丝，喜欢用sed做各种sed不擅长的事情，这里实现一下wc -c的功能，也就是统计文章单词数量。&lt;/p&gt;
&lt;p&gt;　　我习惯喜欢加上n和r，n表示每行结束时不会自动打印，r表示正则表达式的扩展方式，我实在很讨厌写那么多\，所以sed基本上我是一定加这两个东西的。&lt;/p&gt;
&lt;p&gt;　　先从sed擅长的开始，先用s命令做替换，把每个单词都替换为单个1。这一步其实很简单，s/[^ \t\r]+/1/g即可，也就是把不是空格的连续匹配替换为1，g是表示对一行中所有满足这样的模式都替换为1，再考虑到正则表达式的贪婪，其实我们的[^ \t\r]+实际上就是指完整的一个单词，熟悉regex替换的应该不难理解。&lt;/p&gt;
&lt;p&gt;　　然后为了整齐，替换为1之后，再把空格都去掉，其实也就是把不是1的去掉，那么紧接着一条s/[^1]+//g即可，然后再用p打印一下。&lt;/p&gt;
&lt;p&gt;　　一口吃不成胖子，先从简单的来，我们可以看一下效果。在此之前先找篇文章，就节选一下google的pixel buds新闻吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # cat 1.txt
American company Google recently announced the release of its Google Pixel 2 phone and other products that work together with the phone.
One of the new products is a pair of wireless earphones Google calls Pixel Buds.
The earphones are seen as the company's answer to competitor Apple's popular AirPod headphones.
At a launch event on October 4, Google said its Pixel Buds were built to provide high-quality sound and hands-free use. All of their operations can be controlled by simply touching the right earphone.
Once the headphones are paired with a Pixel phone, its many features can be used through the Pixel Buds.
One example is Google Assistant, the company's artificial intelligence, or AI, service. Users can now talk directly to Pixel Buds to ask Google Assistant questions, get information or other help. This can all be done without touching the telephone.
The Pixel Buds also can work with Google Translate, the service that provides words and expressions in over 100 languages.
Google product manager Juston Payne demonstrated this feature during the launch event. He was able to talk with someone whose native language is Swedish.
When the person spoke Swedish into the Pixel Buds, the phone's speakers provided the translation in English. The English speaker's response was then translated in real time into Swedish and heard through the Pixel Buds.
linux-p94b:/tmp/testhere # cat wc-w.sed
#!/usr/bin/sed -nrf
s/[^ \t\r]+/1/g
s/[^1]+//g
p
linux-p94b:/tmp/testhere # ./wc-w.sed &amp;lt;1.txt
1111111111111111111111
111111111111111
11111111111111
1111111111111111111111111111111111
1111111111111111111
111111111111111111111111111111111111111
11111111111111111111
111111111111111111111111
11111111111111111111111111111111111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对一下，确实没有错，只是出来了一堆1，而且还是分行的，那么第二步，把这个分行给去掉。当然，加个管道，tr -d '\n'就去掉了，不过我们要的是单个sed解决，那么需要再动一点点脑筋。&lt;/p&gt;
&lt;p&gt;　　我们可以在上面的基础上稍微改动改动，把这些1先缓存进保持空间(hold space)，最后再从保持空间中取出，然后用s/\n//g去掉所有的回车符，再打印。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # cat wc-w.sed
#!/usr/bin/sed -nrf
s/[^ \t\r]+/1/g
s/[^1]+//g
H
$ {
        g
        s/\n//g
        p
}
linux-p94b:/tmp/testhere # ./wc-w.sed &amp;lt;1.txt
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　H命令就是放在保持空间的最后，$是判定输入结束，g是用保持空间的内容替换模式空间。&lt;/p&gt;
&lt;p&gt;　　上面打印出了222个1，离结果222已经很近了。&lt;/p&gt;
&lt;p&gt;　　最后就是如何整合成222了，这里的确是需要一点点技巧了。我们建立以下计数方法：&lt;/p&gt;
&lt;p&gt;　　1..1;1..1;1..1...&lt;/p&gt;
&lt;p&gt;        每一堆1的个数假设为n&lt;sub&gt;k&lt;/sub&gt;,n&lt;sub&gt;k-1&lt;/sub&gt;,...,n&lt;sub&gt;0&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　允许数量为0的堆&lt;/p&gt;
&lt;p&gt;　　每一堆1之间用分号隔开，如果看到有多个分号在一起，那么中间实际上有数量为0的堆&lt;/p&gt;
&lt;p&gt;　　整个计数表示的是n&lt;sub&gt;k&lt;/sub&gt;*10&lt;sup&gt;k&lt;/sup&gt;+n&lt;sub&gt;k-1&lt;/sub&gt;*10&lt;sup&gt;k-1&lt;/sup&gt;+...+n&lt;sub&gt;0&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　很明显，我们十进制表示方法和整个很类似，只是，十进制表示里，每一堆都小于10而已。&lt;/p&gt;
&lt;p&gt;　　于是我们可以创立一个算法，也就是，当我们发现一堆里有10个1，那么我们就可以往高位进1。&lt;/p&gt;
&lt;p&gt;　　很容易证明这个算法可以结束。&lt;/p&gt;
&lt;p&gt;　　假设{n&lt;sub&gt;k&lt;/sub&gt;,n&lt;sub&gt;k-1&lt;/sub&gt;,...,n&lt;sub&gt;0&lt;/sub&gt;}有限序列是非负整数num的一个表示，序列里的每一个数字是一个非负整数，最高位n&lt;sub&gt;k&lt;/sub&gt;大于0，除非num等于0。&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　显然，一个具体整数的表示方法是有限的，实际上，这个k不可能大于num对10取对数，序列中的每一项不可能大于num。&lt;/p&gt;
&lt;p&gt;　　序列可以比较大小，&lt;/p&gt;
&lt;p&gt;　　{m&lt;sub&gt;j&lt;/sub&gt;,m&lt;sub&gt;j-1&lt;/sub&gt;,...,m&lt;sub&gt;0&lt;/sub&gt;}有限序列是num的另外一个表示，那么&lt;/p&gt;
&lt;p&gt;　　{n&lt;sub&gt;k&lt;/sub&gt;,n&lt;sub&gt;k-1&lt;/sub&gt;,...,n&lt;sub&gt;0&lt;/sub&gt;} 〉{m&lt;sub&gt;j&lt;/sub&gt;,m&lt;sub&gt;j-1&lt;/sub&gt;,...,m&lt;sub&gt;0&lt;/sub&gt;} 当且仅当 k &amp;gt; j  或者    k = j且n&lt;sub&gt;k&lt;/sub&gt;=m&lt;sub&gt;k&lt;/sub&gt;...n&lt;sub&gt;k-p&lt;/sub&gt;=m&lt;sub&gt;k-p&lt;/sub&gt;,n&lt;sub&gt;k-p-1&lt;/sub&gt;&amp;gt;m&lt;sub&gt;k-p-1&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　以上比较大小的方法可以把一个非负整数的所有表示串成一个全序集。&lt;/p&gt;
&lt;p&gt;　　之前的算法中，每当升位，其表示都会变的比之前大。因为所有的表示为有限个，而最大的表示则是十进制的表示方法，从而可以知道算法是可以结束得到十进制表示的。&lt;/p&gt;

&lt;p&gt;　　那么我们根据这个，不停的找10个0，每当找到，就进位，最后再把每堆挨个替换为9,8,7,6,5,4,3,2,0，再去掉分号，就完成了。有点费脑子吧，我实现一下如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # cat wc-w.sed
#!/usr/bin/sed -nrf
s/[^ \t\r]+/1/g
s/[^1]+//g
H
$ {
        g
        s/\n//g
        :a
        s/;1111111111/1;/
        s/^1111111111/1;/
        ta
        s/111111111/9/g
        s/11111111/8/g
        s/1111111/7/g
        s/111111/6/g
        s/11111/5/g
        s/1111/4/g
        s/111/3/g
        s/11/2/g
        :b
        s/;;/;0;/g
        tb
        s/;$/;0/
        s/;//g
        /^$/s/^/0/
        p
}
linux-p94b:/tmp/testhere # ./wc-w.sed &amp;lt;1.txt
222
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 13 Oct 2017 16:02:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/7663831.html</dc:identifier>
</item>
<item>
<title>HashMap - 基于哈希表和Map 接口的键值对利器 （JDK 1.7） - romanjoy</title>
<link>http://www.cnblogs.com/romanjoy/p/7259610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/romanjoy/p/7259610.html</guid>
<description>&lt;p&gt;HashMap 的一些认识： (JDK 1.7)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于哈希表的Map接口的非同步实现，定义了键映射到值的规则&lt;/li&gt;
&lt;li&gt;此实现提供所有可选的映射操作，并允许使用null值和null键&lt;/li&gt;
&lt;li&gt;此实现假定哈希函数将元素适当分布在各桶之间，为读取操作提供稳定性能&lt;/li&gt;
&lt;li&gt;迭代时间与实例容量(桶的数量)及其大小(键-值映射关系数)成正比&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;■ 类定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;继承 AbstractMap抽象类，实现了Map接口&lt;/li&gt;
&lt;li&gt;实现 Cloneable接口&lt;/li&gt;
&lt;li&gt;实现 java.io.Serializable 接口，支持序列化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HashMap - “链表散列” (数组+链表)， 数组每一项都是一条链的数据结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/830545/201707/830545-20170730170039677-105967154.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The default initial capacity - MUST be a power of two.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 16&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The maximum capacity - MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The load factor used when none specified in constructor.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The table, resized as necessary. Length MUST Always be a power of two.&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;[] table;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The number of key-value mappings contained in this map.&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The next size value at which to resize (capacity * load factor).&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The load factor for the hash table.&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * The number of times this HashMap has been structurally modified
  * Structural modifications are those that change the number of mappings in
  * the HashMap or otherwise modify its internal structure (e.g.,
  * rehash).  This field is used to make iterators on Collection-views of
  * the HashMap fail-fast.  (See ConcurrentModificationException).
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ 构造器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt; initialCapacity);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
        initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt; loadFactor);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find a power of 2 &amp;gt;= initialCapacity&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; capacity = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (capacity &amp;lt;&lt;span&gt; initialCapacity)
            capacity &lt;/span&gt;&amp;lt;&amp;lt;= 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阈值为容量*负载因子和最大容量+1之间的最小值 以此值作为容量翻倍的依据(不能超过最大容量)&lt;/span&gt;
        threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个2次幂的Entry类型数组 一个桶对应一个Entry对象&lt;/span&gt;
        table = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[capacity];
        useAltHashing &lt;/span&gt;= sun.misc.VM.isBooted() &amp;amp;&amp;amp;&lt;span&gt; 
        (capacity &lt;/span&gt;&amp;gt;=&lt;span&gt; Holder.ALTERNATIVE_HASHING_THRESHOLD);
        init();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    - Entry&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 静态类 默认实现内部Entry接口 (接口中可定义内部接口-Map.Entry接口为Map的内部接口)
  * PS:JDK8中引入default，作用为在接口中定义默认方法实现
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; K key;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key具有引用不可变特性&lt;/span&gt;
&lt;span&gt;    V value;
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;next指向下一个：单向链表，头插入&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
    ……
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ 主要方法&lt;/p&gt;
&lt;p&gt;　put(k, v)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; key不存在返回null，否则返回旧值
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其允许存放null的key和null的value
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当其key为null时，调用putForNullKey方法，放入到table[0]的这个位置（null键只有一个）&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过调用hash方法对key进行哈希，得到哈希之后的数值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其目的是为了尽可能的让键值对可以分不到不同的桶中&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据上一步骤中求出的hash得到在数组中是索引i&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果i处的Entry不为null，则通过其next指针不断遍历e元素的下一个元素。&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
        Object k;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用临时变量k主要用于e.key的赋值，意义有限
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash一致 &amp;amp;&amp;amp; (key引用相同 或 key字符串比较相同)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值变更&lt;/span&gt;
            V oldValue =&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; oldValue;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已存在则选择直接返回旧值&lt;/span&gt;
&lt;span&gt;        }
    }
    modCount&lt;/span&gt;++&lt;span&gt;;
    addEntry(hash, key, value, i);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若key不存在则返回null&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   hash()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK1.7&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object k) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (useAltHashing) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sun.misc.Hashing.stringHash32((String) k);
        }
        h &lt;/span&gt;=&lt;span&gt; hashSeed;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异或就是两个数的二进制形式，按位对比，相同取0，不同取一
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突&lt;/span&gt;
    h ^=&lt;span&gt; k.hashCode();
    h &lt;/span&gt;^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK1.8 扰动函数 -&amp;gt; 散列值优化函数&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把一个数右移16位即丢弃低16为，就是任何小于2^16的数，右移16后结果都为0
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2的16次方再右移刚好就是1 同时int最大值为32位
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任何一个数，与0按位异或的结果都是这个数本身
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为indexFor做准备&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;address&gt; &lt;/address&gt;
&lt;p&gt;   indexFor()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Int范围(2^32)从-2147483648到2147483648，加起来大概40亿空间，内存不能直接读取
  * 用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标
  * @Param h 根据hash方法得到h
  * @Param length 一定是2次幂
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2次幂-1 返回的结果的二进制为永远是都是1 比如 15 -&amp;gt; 1111 (16 -&amp;gt; 10000)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与运算 只有 1 &amp;amp; 1 = 1 正好相当于一个“低位掩码”
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果length-1中某一位为0，则不论h中对应位的数字为几，对应位结果都是0，这样就让两个h取到同一个结果，hash冲突
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时这个操作可以保证索引不会大于数组的大小(见开头的描述)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   addEntry()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法为包访问 package java.util(本包私有性高于子类)&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前容量超过阈值 &amp;amp;&amp;amp; 当前坐标数组非空
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有个优雅的设计在于，若bucketIndex处没有Entry对象，那么新添加的entry对象指向null，从而就不会有链了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
        resize(&lt;/span&gt;2 * table.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量扩容一倍&lt;/span&gt;
        hash = (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash重新计算&lt;/span&gt;
        bucketIndex = indexFor(hash, table.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index重新计算&lt;/span&gt;
&lt;span&gt;    }
    createEntry(hash, key, value, bucketIndex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增Entry元素到数组的制定下标位置&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法为包访问 package java.util&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; createEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定 bucketIndex 索引处的 Entry&lt;/span&gt;
    Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[bucketIndex];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 形成链表，新加入的放入链表头部，最先加入的放入尾部&lt;/span&gt;
    table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
    size&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  remove()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; removeEntryForKey(key);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value);
}


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Removes and returns the entry associated with the specified key
  * in the HashMap.  Returns null if the HashMap contains no mapping
  * for this key.
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; removeEntryForKey(Object key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; prev = table[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于记录该key的前一个元素(默认先从队首开始)&lt;/span&gt;
    Entry&amp;lt;K,V&amp;gt; e = prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从队首开始往队尾遍历
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历key所在链表&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
        Object k;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))) {
            modCount&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;remove属于结构性改造，modCount计数+1&lt;/span&gt;
            size--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前Map的有效元素数量-1&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (prev ==&lt;span&gt; e)
                table[i] &lt;/span&gt;= next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若当前key正好位于队首，则队首指向next&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                prev.next &lt;/span&gt;= next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若当前key不位于队首，则该key之前的元素的next指向该key的下一个元素&lt;/span&gt;
            e.recordRemoval(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LinkedHashMap专用方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续往队尾找&lt;/span&gt;
        prev = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向当前循环元素的上一个元素&lt;/span&gt;
        e = next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一次循环元素&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ HashMap 迭代&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法一&lt;/span&gt;
Iterator&amp;lt;Map.Entry&amp;lt;Integer,Object&amp;gt;&amp;gt; it =&lt;span&gt; map.entrySet().iterator();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
   Map.Entry&lt;/span&gt;&amp;lt;Integer, Object&amp;gt; entry =&lt;span&gt; it.next();
   System.out.println(&lt;/span&gt;&quot;key=&quot; + entry.getKey() + &quot; and value=&quot; +&lt;span&gt; entry.getValue());&lt;br/&gt;&lt;span&gt;//在迭代中可删除 Map 元素也是推荐，避免快速失败&lt;/span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法二&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Integer,Object&amp;gt;&lt;span&gt; entry : map.entrySet()) {
   System.out.println(&lt;/span&gt;&quot;key=&quot; + entry.getKey() + &quot; and value=&quot; +&lt;span&gt; entry.getValue());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;*****  此版本为JDK 1.7，由于笔者水平有限，之后有补充的话会更新此文，请各位看客多多谅解支持  ********&lt;/p&gt;
&lt;p&gt;*****  JDK1.8 的 HashMap 之后会另写一篇   ******&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:47:00 +0000</pubDate>
<dc:creator>romanjoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/romanjoy/p/7259610.html</dc:identifier>
</item>
<item>
<title>HashMap实现原理 - 大大控</title>
<link>http://www.cnblogs.com/huangbw/p/7658959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangbw/p/7658959.html</guid>
<description>&lt;p&gt;学习笔记之HashMap篇，简单学习了解HashMap的实现原理和扩容。&lt;/p&gt;
&lt;p&gt;大家都知道HashMap处理数据很快，时间复杂度O(1)，那么是怎么做到的呢？那就先了解一下常见数据结构。&lt;/p&gt;
&lt;p&gt;一般来说，我们把存储结构分为两种个，顺序存储结构和链式存储结构，那我们就以最常见的两种，数组和链表为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组采用的一段连续的存储单元来存储数据，我们可以通过数组的下表来进行查找数据，时间复杂度为O(1)，如果通过给定的值来查找需要遍历数组，所以时间复杂度为O(n)，当然在有序的情况下我们可以加速这个对比过程，通过二分查找可以实现时间复杂度O(logn)，插入删除元素的话需要一个一个处理元素位置，所以也是O(n)级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表的话存储数据不需要连续的存储单元，只需要在当前数据中存储下一个来实现链表，这样我们无法像数组那样通过下表查找，在查找数据时只能一个一个往后找，所以时间复杂度为O(n)，但是链表的优势就在于插入删除操作只需要处理一下结点的引用就可以了，所以时间复杂度O(1)。&lt;/p&gt;

&lt;p&gt;既然数组和链表各有优势，那我们能不能结合他们的优势呢？哈希表应运而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面说到了数组可以通过下标查找数据，时间复杂度O(1)，哈希表就利用这个优势，所以哈希表的主干就是一个数组，那么问题来了，我知道下标才能快速取啊，然而我现在只有值，怎么通过存储元素的值来确定他的下标呢？这里，我们就要通过哈希函数来把这个元素值映射到对应的下标，至于这个函数，我们就不详细介绍了，简单来说就是取这个元素值的哈希值来做模运算从而获得下表位置，通过这个位置来实现快速读取。说到了哈希函数，这个函数的设计尤为关键，直接影响到性能，因为这个函数设计的不好，可能导致很多数存储在了同一个下标下。那么看到这又该发现问题了，一个下标下怎么存储很多元素呢？这便是哈希冲突的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如上面所讲，哈希冲突就是我们在通过哈希函数来计算下标的时候出现了重复，当一个元素要存进去的时候发现里面已经被占了，这便是哈希冲突，也被叫做哈希碰撞。我们前面也说过了，数组需要连续的存储单元来存储数据，所以再好的哈希函数的设计也不可能做到不出现哈希冲突，所以就出现了几种解决哈希冲突的方法：开放定址法，在散列函数法，还有链地址法。&lt;/p&gt;
&lt;p&gt;我们的HashMap使用的就是链地址法，也就是主干为一个数组，而在每个位置上存放的又是一个链表，这实际上就是一个链表散列的数据结构。这也就是前面我说哈希函数设计的好坏直接影响性能的一个原因，哈希函数的设计原则是要做到计算简单和散列地址分布均匀，分布不均匀导致的结果就是一个位置上出现一个很长的链表，我们找到这个位置再去寻找数据的时候有需要遍历链表上的数据来寻找，这就导致了读取数据的性能下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap的实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们一起看一点源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先来看定义，HashMap类继承了AbstractMap类，实现了Map，Cloneable和Serializable接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * The default initial capacity - MUST be a power of two.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The maximum capacity, used if a higher value is implicitly specified
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * by either of the constructors with arguments.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * The load factor used when none specified in constructor.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看定义的几个常量，DEFAULT_INITIAL_CAPACITY是默认初始容量16，MAXIMUM_CAPACITY最大容量2的30次方，DEFAULT_LOAD_FACTOR默认加载因子0.75。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * The number of key-value mappings contained in this map.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The next size value at which to resize (capacity * load factor).
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If table == EMPTY_TABLE then this is the initial capacity at which the
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; table will be created when inflated.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * The load factor for the hash table.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * The number of times this HashMap has been structurally modified
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * Structural modifications are those that change the number of mappings in
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * the HashMap or otherwise modify its internal structure (e.g.,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * rehash).  This field is used to make iterators on Collection-views of
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * the HashMap fail-fast.  (See ConcurrentModificationException).
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看几个比较重要的变量：&lt;/p&gt;
&lt;p&gt;size是指当前哈希表中键值对的数量，源码中还有size()方法来返回了这个变量size。&lt;/p&gt;
&lt;p&gt;threshold在源码中的注释为The next size value at which to resize (capacity * load factor).如果我没理解错的话threshold是指下一个要进行扩容的值，通常是容量*加载因子。&lt;/p&gt;
&lt;p&gt;loadFactor就是哈希表的加载因子。&lt;/p&gt;
&lt;p&gt;modCount是用来快速失败的一个值，因为HashMap不是线程安全的，所以当多个线程导致了HashMap内部结构发生改变时，需要抛出异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        V value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         * Creates new entry.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         Entry(&lt;span&gt;int&lt;/span&gt; h, K k, V v, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             value =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             next =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             key =&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             hash =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K getKey() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V getValue() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V setValue(V newValue) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             V oldValue =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             value =&lt;span&gt; newValue;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Map.Entry e =&lt;span&gt; (Map.Entry)o;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Object k1 =&lt;span&gt; getKey();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             Object k2 =&lt;span&gt; e.getKey();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (k1 == k2 || (k1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k1.equals(k2))) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 Object v1 =&lt;span&gt; getValue();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 Object v2 =&lt;span&gt; e.getValue();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (v1 == v2 || (v1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; v1.equals(v2)))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Objects.hashCode(getKey()) ^&lt;span&gt; Objects.hashCode(getValue());
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; getKey() + &quot;=&quot; +&lt;span&gt; getValue();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;         * This method is invoked whenever the value in an entry is
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;         * overwritten by an invocation of put(k,v) for a key k that's already
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;         * in the HashMap.
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; recordAccess(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;         * This method is invoked whenever the entry is
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;         * removed from the table.
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; recordRemoval(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一部分代码很长，这是HashMap中的一个内部类Entry，前面我们也说到HashMap是数组加链表的结构，主干数组上每个位置就是Entry，Entry就是HashMap中的一个基本组成元素。&lt;/p&gt;
&lt;p&gt;这段源码中后面的类中的方法就不详细研究了，看一下2-5行定义的几个变量，首先是key和value，每个Entry中就是一个key-value键值对。&lt;/p&gt;
&lt;p&gt;第4行next，这个next存储就是指向下一个Entry的引用，就是通过这个next形成了一个单链表的结构，进而形成了主干数组上放链表的HashMap的结构。&lt;/p&gt;
&lt;p&gt;第5行hash，对key的hashcode值进行hash运算后得到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行代码就是HashMap的主干数组。&lt;/p&gt;
&lt;p&gt;下面看一下HashMap的存取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap中的存取&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; entry =&lt;span&gt; getEntry(key);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; == entry ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V getForNullKey() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先是get方法，当key等于null的时候，调用getForNullKey方法。那我们先来看getForNullKey方法，首先判断当前HashMap的当前元素数量，如果为0返回null，否则的话先定位到主干数组下标为0的位置，然后遍历Entry链表，一个一个找key为null的那一个，如果有，返回对应的value值，如果没有，返回null。&lt;/p&gt;
&lt;p&gt;那当key不是null的时候，调用了一个getEntry的方法，源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Object k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;                 ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和上面的getForNullKey方法很相似，先看size是否为0，然后用hash方法得到hash，然后通过indexFor的方法传入hash和数组长度得到这个key所存储的下标位置，然后遍历Entry数组，寻找那个要找的key，返回这个Entry，如果没有则返回null。&lt;/p&gt;
&lt;p&gt;再回到上面代码，得到这个Entry以后再返回他的value。&lt;/p&gt;
&lt;p&gt;这其中一些细节是没有深入研究的，先明白大体过程，慢慢深入了解细节。&lt;/p&gt;
&lt;p&gt;下面看put方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            inflateTable(threshold);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Object k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || &lt;span&gt;key.equals(k))) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        addEntry(hash, key, value, i);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * Offloaded version of put for null keys
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         addEntry(0, &lt;span&gt;null&lt;/span&gt;, value, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先判断数组是否{}空数组，如果是的话，进行数组填充为数组分配实际存储空间，如果要存储的键值对中key为null，调用putForNullKey方法，大体操作过程就是在下标为0的地方遍历该位置上的Entry链表，如果发现已经存在null这个key，那就覆盖掉以前的value，如果没有，那就创建一个新的Entry接在链表上。&lt;/p&gt;
&lt;p&gt;同样的，如果不为null进行的操作也基本类似，获得hash，通过hash和数组长度获取下标，定位到下标对应的Entry链表遍历对比，已经存在就覆盖，没有就创建新的接在后面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap的扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先得知道什么时候扩容，就是当当前size达到阈值，也就是前面提到的threshold，容量*加载因子时，就要自动扩容了。&lt;/p&gt;
&lt;p&gt;这里要提到的就是resize，重新计算容量，当我们不停地向HashMap中添加元素时，HashMap内部数组无法装下更多元素，就需要扩大数组的长度来装更多的元素，当然，数组无法扩容，所以我们使用的方法就是用一个更大的数组来代替小的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Entry[] oldTable =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         Entry[] newTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        transfer(newTable, initHashSeedAsNeeded(newCapacity));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         table =&lt;span&gt; newTable;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先上resize方法的源码，先引用扩容前的数组，得到长度，然后第4行的if，是判断扩容前的数组是否已经达到最大值MAXIMUM_CAPACITY，也就是2的30次方，如果已经到了，那就修改阈值为Integer.MAX_VALUE，也就是int的最大值2的31次方减1，这样以后就不在扩容了。如果还没达到最大值，那先new一个新的Entry数组，调用transfer方法将数据放入新数组，然后将HashMap中的table属性引用这个新数组，然后得到新的阈值。&lt;/p&gt;
&lt;p&gt;这里使用了transfer方法来拷贝，下面看一下这个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; transfer(Entry[] newTable, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; rehash) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; newTable.length;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e : table) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; e) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 Entry&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rehash) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     e.hash = &lt;span&gt;null&lt;/span&gt; == e.key ? 0&lt;span&gt; : hash(e.key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 e.next =&lt;span&gt; newTable[i];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 newTable[i] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 e =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;transfer方法首先引用了旧的Entry数组，遍历这个旧数组，每循环一次，用Entry对象e获取到这个元素，并且将数组中该位置的Entry对象的引用释放，然后嵌套了一个do-while循环遍历链表，当前上的元素重新计算在新数组中对应的下标，断开与后一个之间的连接，指向目标位置（这样的结果就是发生哈希冲突时元素往同一个下标上位置放的时候会插入到链表头，先放的会放到尾部），然后将该元素放在数组上，e再指向next，直到把链表中的每个元素重新分配，然后外层循环继续循环到旧数组的下一个下标处。&lt;/p&gt;
&lt;p&gt;看起来很乱，通俗点讲就是俩循环遍历了数组上的每个链表上的每个元素，重新计算了他们在新数组的位置并且挪过去。这就是一个rehash再散列的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这一篇就到这，大佬们的支持是我努力学习的动力，哪里有问题请多帮我指正。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:23:00 +0000</pubDate>
<dc:creator>大大控</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangbw/p/7658959.html</dc:identifier>
</item>
<item>
<title>Angular和Spring Boot一起做个项目 - 大明二代</title>
<link>http://www.cnblogs.com/xiao2/p/7663806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao2/p/7663806.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近由于公司人员调整，我不得不去转去做前端，被迫用三周的时间学习Angular，同时需要做一个简单的Web聊天室。对于前端不一点感冒的我而言，其实还算一个不小的挑战。在三周的过程中，我遇到很多的困难，其中一个困难是如何将Aangular和我已会的Java体系相结合。我不太习惯前后端分离，还是希望可以能够将页面和Java代码写在一个项目里，算得上一个落伍的执着吧。&lt;/p&gt;
&lt;p&gt;Angular(包括2和4)是从AngularJs1.x升级而来，但是不提供向下兼容。Anuglar2(和4)和AngularJs1.x的一个很大不同，便是Angular使用了TypeScript，而1.x则使用了JavaScript，也是两者不能兼容的一个很重要的原因(如果有其他的原因的话)。目前现代浏览器均不直接支持TypeScript(可能存在间接支持的情况，不确定的事情还是不要打保票了)，因此，我不能像AngularJs1.x那样，直接将Angular引入到JSP中。查过很多资料，按照别人的思路将Angular和JavaWeb(以SpirngMVC为主)项目结合起来，但是看着别人说是可以跑通的，但是自己怎么跑都不行，就算直接用别人的源代码也行，搞得我相当郁闷。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;虽然通过查找资料没有解决我的问题，但是我还是获得很大收获。TypeScript毕竟是JavaScript的一个超集，本质上还是JavaScript。Angular虽然是用TypeScript写的，但是在编译之后本质上和html、css、js文件没有什么两样，因此我没有必要将Angular的代码放进JavaWeb里面，而是将Angular编译之后的静态文件放入JavaWeb项目中就可以了。&lt;/p&gt;
&lt;p&gt;在我这个项目中我使用Spring Boot作为后端的框架，maven作为构建工具，&lt;a href=&quot;mailto:那么在main目录下使用@angular/cli工具新建一个angular项目&quot;&gt;那么在main目录下使用@angular/cli工具新建一个angular项目&lt;/a&gt;，名字就叫做angular吧。Spring Boot项目中一般将静态资源放在resources目录下的static文件夹中，为了方便编译，可以把Angular中的.angular-cli.json文件中apps下的outDir设置为“../resources/static”。&lt;/p&gt;
&lt;p&gt;Angular页面使用VSCode开发，Spring Boot则使用idea。当我们启动项目或打包的时候需要使用ng build去编译angular代码，由于我修改.angular-cli.json的配置，编译后的代码将不会放在默认的dist目录下，而是在spring boot中的resources的static文件夹中了。&lt;/p&gt;
&lt;h2 id=&quot;源代码&quot;&gt;源代码&lt;/h2&gt;
&lt;p&gt;感谢你容忍我烂到天际的文笔看到现在，这是&lt;a href=&quot;https://github.com/damingerdai/web-qq&quot;&gt;源代码&lt;/a&gt;，希望对你有所帮助。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:19:00 +0000</pubDate>
<dc:creator>大明二代</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiao2/p/7663806.html</dc:identifier>
</item>
</channel>
</rss>