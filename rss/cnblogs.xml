<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>springcloud干货之服务消费者（ribbon） - 陈明羽</title>
<link>http://www.cnblogs.com/cmyxn/p/7704687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmyxn/p/7704687.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;本章介绍springcloud中的服务消费者&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　springcloud服务调用方式有两种实现方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1，restTemplate+ribbon,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2，feign&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　本来想一篇讲完，发现篇幅有点长，所以本章先讲 restTemplate+ribbon，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Feign默认集成了ribbon。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;新一个springboot项目，名字为 eureka-consumer-ribbon &lt;/p&gt;
&lt;p&gt;其pom.xml配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;Dalston.SR1&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　在项目启动类Application上添加@EnableDiscoveryClient注解（上一章提到了@EnableDiscoveryClient和@EnableEurekaServer的区别）向服务中心注册服务，&lt;/p&gt;
&lt;p&gt;并且使用@bean像spring容器中注入一个restTemplate对象，@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableDiscoveryClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
    
    @Bean
    @LoadBalanced
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application.&lt;span&gt;class&lt;/span&gt;).web(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).run(args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties中指定，服务名：eureka-consumer-ribbon，端口为9101，服务注册中心地址为：http://localhost:9001/eureka/&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
spring.application.name=eureka-consumer-&lt;span&gt;ribbon
server.port&lt;/span&gt;=9101&lt;span&gt;
eureka.client.serviceUrl.defaultZone&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9001/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建一个RibbonController类，用来消费eureka-client的服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;@RestController&lt;br/&gt;public class RibbonController {&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　@Autowired&lt;br/&gt;　　RestTemplate restTemplate;&lt;/p&gt;
&lt;p&gt;　　@GetMapping(&quot;/consumer&quot;)&lt;br/&gt;　　public String getMsg() {&lt;/p&gt;&lt;p&gt;　　　　return restTemplate.getForObject(&quot;http://eureka-client/client&quot;, String.class);&lt;br/&gt;　　}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里的请求地址使用http://server-name，来代替http://ip:port，因为在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，这里请求的是eureka-client/client&lt;/p&gt;

&lt;p&gt;使用上一章已经创建的项目eureka-server，eureka-client这俩项目&lt;/p&gt;
&lt;p&gt; 首先：&lt;/p&gt;
&lt;p&gt;　　　   1，启动 eureka-server&lt;/p&gt;
&lt;p&gt;　　　　2，启动 eureka-client 配置文件的端口默认为9002&lt;/p&gt;
&lt;p&gt;　　　　3，修改配置文件的端口为9003，再启动一个eureka-client &lt;/p&gt;
&lt;p&gt;　　　　4，在启动 eureka-consumer-ribbon &lt;/p&gt;

&lt;p&gt;访问http://localhost:9001/，就会发现，已经有eureka-clent服务注册了，而且有两个实例，9002和9003&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986865/201710/986865-20171021153123802-1519786687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　访问 http://localhost:9101/consumer，就会发现已经消费了 eureka-client项目提供的服务，而且ribbon已经默认实现了负载均衡&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/986865/201710/986865-20171021153840396-192043238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/986865/201710/986865-20171021153848818-534123383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　码云：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;&lt;span&gt;&lt;strong&gt;　　GitHub：&lt;/strong&gt;&lt;/span&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　感谢分享：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　翟永超：http://blog.didispace.com/spring-cloud-starter-dalston-1/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　方志鹏：http://blog.csdn.net/forezp/article/details/70148833#t0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎关注本人公众号，扫码发现更多精彩内容&lt;/strong&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0.1&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986865/201710/986865-20171021122633615-875444573.jpg&quot; alt=&quot;&quot; height=&quot;188&quot;/&gt;&lt;/td&gt;
&lt;td&gt; &lt;strong&gt;     &lt;span&gt;本文为原创文章，欢迎转载，转载请注明作者&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 22 Oct 2017 07:27:00 +0000</pubDate>
<dc:creator>陈明羽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmyxn/p/7704687.html</dc:identifier>
</item>
<item>
<title>剖析Prometheus的内部存储机制 - Vovolie</title>
<link>http://www.cnblogs.com/vovlie/p/7709312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vovlie/p/7709312.html</guid>
<description>&lt;p&gt;Prometheus有着非常高效的时间序列数据存储方法，每个采样数据仅仅占用3.5byte左右空间，上百万条时间序列，30秒间隔，保留60天，大概花了200多G（引用官方PPT）。&lt;br/&gt;接下来让我们看看他的原理。&lt;/p&gt;
&lt;p&gt;Prometheus内部主要分为三大块，Retrieval是负责定时去暴露的目标页面上去抓取采样指标数据，Storage是负责将采样数据写磁盘，PromQL是Prometheus提供的查询语言模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022121359974-1659859376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从最原始的抓取数据上来看，基本是这个样子，timestamp是当前抓取时间戳：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022122317099-679260963.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;每个Metric name代表了一类的指标，他们可以携带不同的Labels，每个Metric name + Label组合成代表了一条时间序列的数据。&lt;br/&gt;例如图上的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http_requests_total{status=&quot;200&quot;,method=&quot;GET&quot;}
http_requests_total{status=&quot;404&quot;,method=&quot;GET&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示了两条不同的时间序列。&lt;/p&gt;
&lt;p&gt;在Prometheus的世界里面，所有的数值都是64bit的。每条时间序列里面记录的其实就是64bit timestamp(时间戳) + 64bit value(采样值)。&lt;/p&gt;
&lt;p&gt;而对于时间序列的基本特性来说，通常是过去的数据一般是只读的，是不会变更的，当前时间的数据才会可能在写，模式如下图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022123802818-1668133554.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;根据上面的分析，时间序列的存储似乎可以设计成key-value存储的方式（基于BigTable）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022124604115-2041813967.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;进一步拆分，可以像下面这样子：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022124912568-1762219663.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;上图的第二条样式就是现在Prometheus内部的表现形式了，__name__是特定的label标签，代表了metric name。&lt;/p&gt;
&lt;p&gt;再回顾一下Prometheus的整体流程：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022125438256-1293995688.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;上面提到了K-V存储，当然是使用了LevelDB的引擎，它的特点是顺序读写性能非常高，这是非常符合时间序列的存储的。&lt;/p&gt;
&lt;p&gt;为了得到顺序的时间序列哈希索引值，Prometheus是这样处理的：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022130706787-1063830003.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;FNV哈希算法全名为Fowler-Noll-Vo算法，是以三位发明人Glenn Fowler，Landon Curt Noll，Phong Vo的名字来命名的，最早在1991年提出。&lt;br/&gt;FNV能快速hash大量数据并保持较小的冲突率，它的高度分散使它适用于hash一些非常相近的字符串，比如URL，hostname，文件名，text，IP地址等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1KB Chunks&lt;/p&gt;
&lt;p&gt;在Prometheus的世界中，无论是内存还是磁盘，它都是以1KB单位分成块来操作的。（新出的Prometheus 2.0对存储底层做了很大改动，专门针对SSD的写放大进行了优化，提高SSD的读写性能和读写次数等。）&lt;/p&gt;
&lt;p&gt;整体流程是 抓取数据 -&amp;gt; 写到head chunk，写满1KB，就再生成新的块，完成的块，是不可再变更的 -&amp;gt; 根据配置文件的设置，有一部份chunk会被保留在内存里，按照LRU算法，定期将块写进磁盘文件内。&lt;/p&gt;
&lt;p&gt;注意： 一条时间序列，保存到一个磁盘文件内。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022132056521-1693764367.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;时间序列的保留维护&lt;/p&gt;
&lt;p&gt;在Prometheus的启动选项中，有一项&lt;code&gt;storage.local.retention&lt;/code&gt;可以设置数据自动保留多长时间，例如24h，表示数据超过24小时内的将会自动清除，类似于zabbix的housekeeping功能。&lt;code&gt;storage.local.series-file-shrink-ratio&lt;/code&gt;可以按一定的比例保留数据。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022135511271-1431236627.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;关于Chunk 块编码的剖析&lt;/p&gt;
&lt;p&gt;Prometheus 提供三种不同类型的块编码，用户可以在Prometheus启动时指定最新的编码方式，&lt;code&gt;-storage.local.chunk-encoding-version&lt;/code&gt;，有效值是0，1，2。&lt;/p&gt;
&lt;p&gt;版本0的编码是较老版本上的Prometheus上使用的，新版本已经不再建议使用的。&lt;/p&gt;
&lt;p&gt;版本1是当前版本默认提供的编码方式，它相对于0版有较好的压缩能力，而且在一个块内，有较高的访问速度，当然版本0的编码速度是最快的，但是相对版本1，速度优势不是特别明显。&lt;/p&gt;
&lt;p&gt;版本2提供了一个更高的压缩比例，编码和解码需要耗更多的CPU，当然，这是取决于查询的数据集有多大。通常如果是较少的查询，仅用于存档的数据，可以使用这种编码。&lt;/p&gt;
&lt;p&gt;对比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;1.6&lt;/td&gt;
&lt;td&gt;2.9s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1.3&lt;/td&gt;
&lt;td&gt;2.4&lt;/td&gt;
&lt;td&gt;4.9s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;V0 结构&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022141528818-354100341.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;V1 结构&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022141605599-202801078.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;V2 结构&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022141712834-1378746165.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Prometheus是如何访止数据丢失的呢？例如发生异常关闭或者什么别的情况？它提供了一个Checkpointing功能，对于内存里面的块，Prometheus 使用了一个checkpoint file 去同步写入磁盘，类似于Hbase的WAL原理，当发生crash时，先从checkpoint file去恢复数据。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/440956/201710/440956-20171022142735646-1802101022.png&quot; width=&quot;500&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;3.1084337349398&quot;&gt;
&lt;p&gt;以上内容是根据Prometheus官方人员的一份PPT摘取，原文件在此：&lt;a href=&quot;https://files.cnblogs.com/files/vovlie/copyofprometheusstorage1-160127133731.pdf&quot; class=&quot;uri&quot;&gt;https://files.cnblogs.com/files/vovlie/copyofprometheusstorage1-160127133731.pdf&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Oct 2017 06:32:00 +0000</pubDate>
<dc:creator>Vovolie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vovlie/p/7709312.html</dc:identifier>
</item>
<item>
<title>解析 .Net Core 注入 (1) 注册服务 - 行走即歌</title>
<link>http://www.cnblogs.com/cheesebar/p/7675214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cheesebar/p/7675214.html</guid>
<description>&lt;p&gt;&lt;span&gt;在学习 Asp.Net Core 的过程中，注入可以说是无处不在，对于 .Net Core 来说，它是独立的一个程序集，没有复杂的依赖项和配置文件，所以对于学习 Asp.Net Core 源码的朋友来说，注入作为一个起点非常合适，园子里确实有许多关于注入的博客，不过 .Net Core2.0 已经出来了，注入这一块做了一些 更新，其实有不少 .net 开发人员对微软改来改去这一点不是很满意，加大了学习成本，其实改动分为两种，一种是 Asp.Net Core Mvc 常用 Api 接口的更改（或者配置的更改），这点在 2.0 以来很少有这样的情况了，也就是说 Asp.Net Core Mvc 基本趋于稳定了，另一类就是对代码的优化，前者对研发的跟进造成了很大的伤害值，而后者对于研发而言无关紧要，对于乐于学习源码的程序员而言或许能从中带来许多思考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我打算重新分析 .Net Core2.0 的注入 ，实际发布版本为 .netstandard2.0 程序集为 Microsoft.Extensions.DependencyInjection.dll。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 .Net Core 中，注入描述为为三个过程，注册服务-&amp;gt;创建容器-&amp;gt;创建对象，所以我也会分为三个模块来介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/917105/201710/917105-20171020125955724-174712110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;注入元数据&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果接触过 .Net Core 则或多或少已经接触过注入，下面的代码注册了具有三种生命周期的服务，然后创建一个容器，最后使用容器提供这三个服务的实例对象，我们观察他们的生命周期，看到输出结果基本对 AddTransient 以及 AddSingleton 这两种方式注册的服务具有怎样的生命周期都会有所判断，而 AddScoped 方式注册的服务就复杂一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看到通过 BuilderServiceProvider 方法创建了一个容器，而容器调用 CreateScope 就可以创建了两个具有范围的容器，而 AddScoped 方式注册的服务在不同范围内的生命周期是不一样的，而相同范围下的生命周期和 AddSingleton 是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ITransient { }
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Transient : ITransient { }
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ISingleton { }
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton : ISingleton { }
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IScoped { }
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Scoped : IScoped { }
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        IServiceCollection services &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();
        services &lt;/span&gt;= services.AddTransient&amp;lt;ITransient, Transient&amp;gt;&lt;span&gt;();
        services &lt;/span&gt;= services.AddScoped&amp;lt;IScoped, Scoped&amp;gt;&lt;span&gt;();
        services &lt;/span&gt;= services.AddSingleton&amp;lt;ISingleton, Singleton&amp;gt;&lt;span&gt;();
        IServiceProvider serviceProvider &lt;/span&gt;=&lt;span&gt; services.BuildServiceProvider();
         
        Console.WriteLine(ReferenceEquals(serviceProvider.GetService&lt;/span&gt;&amp;lt;ITransient&amp;gt;(), serviceProvider.GetService&amp;lt;ITransient&amp;gt;&lt;span&gt;()));
        Console.WriteLine(ReferenceEquals(serviceProvider.GetService&lt;/span&gt;&amp;lt;IScoped&amp;gt;(), serviceProvider.GetService&amp;lt;IScoped&amp;gt;&lt;span&gt;()));
        Console.WriteLine(ReferenceEquals(serviceProvider.GetService&lt;/span&gt;&amp;lt;ISingleton&amp;gt;(), serviceProvider.GetService&amp;lt;ISingleton&amp;gt;&lt;span&gt;()));

        IServiceProvider serviceProvider1 &lt;/span&gt;=&lt;span&gt; serviceProvider.CreateScope().ServiceProvider;
        IServiceProvider serviceProvider2 &lt;/span&gt;=&lt;span&gt; serviceProvider.CreateScope().ServiceProvider;

        Console.WriteLine(ReferenceEquals(serviceProvider1.GetService&lt;/span&gt;&amp;lt;IScoped&amp;gt;(), serviceProvider1.GetService&amp;lt;IScoped&amp;gt;&lt;span&gt;()));
        Console.WriteLine(ReferenceEquals(serviceProvider1.GetService&lt;/span&gt;&amp;lt;IScoped&amp;gt;(), serviceProvider2.GetService&amp;lt;IScoped&amp;gt;&lt;span&gt;()));
        Console.WriteLine(ReferenceEquals(serviceProvider1.GetService&lt;/span&gt;&amp;lt;ISingleton&amp;gt;(), serviceProvider2.GetService&amp;lt;ISingleton&amp;gt;&lt;span&gt;()));

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; False
         * True
         * True
         * True
         * False
         * True
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;IServiceCollection&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IServiceCollection : IList&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt;
{
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是一个集合，用来存放用户注册的服务元数据&lt;/p&gt;
&lt;h3&gt;ServiceDescriptor&lt;/h3&gt;
&lt;p&gt;看上面的例子我们如何添加注入应该也能猜到 ServiceDescriptor 包含哪些属性了吧！至少包含一个接口类型、实现类型和生命周期，是的就是如此。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ServiceLifetime Lifetime { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Type ServiceType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Type ImplementationType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ImplementationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt; ImplementationFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一个代码块中，都是使用的是 IServiceCollection 如下签名拓展方法注册服务的，这里我把它称为“服务类型实例类型”（提供一个服务类型，一个实例类型）的注册方式，相应的服务类型和实例类型通过解析泛型参数传递给 ServiceDescriptor 的ServiceType、ImplementationInstance，值得注意的是，创建 ServiceDescriptor 并不会校验实例类型的可创建性（验证其是否是抽象类，接口）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddTransient&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
    &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TService : &lt;span&gt;class&lt;/span&gt;
    &lt;span&gt;where&lt;/span&gt; TImplementation : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(TService), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImplementation));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，微软还提供了“服务实例”（提供一个服务类型，一个实例对象）以及“服务实例工厂”（提供一个服务类型，一个实例对象工厂）的注册方式，前者只供单例服务使用，使用起来也很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.AddTransient&amp;lt;ITransient&amp;gt;(_=&amp;gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Transient());
services.AddSingleton&lt;/span&gt;&amp;lt;ISingleton&amp;gt;(&lt;span&gt;new&lt;/span&gt; Singleton());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于 ServiceDescriptor，还有一个要说的就是服务的生命周期了，使用 AddSingleton、AddScoped、AddTransient 三种方式注册的服务在 ServiceDescriptor 中的 LifeTime 属性分别对应下面这个枚举类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ServiceLifetime
{
    Singleton,
    Scoped,
    Transient
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、Transient：每次从容器 （IServiceProvider）中获取的时候都是一个新的实例&lt;/p&gt;
&lt;p&gt;2、Singleton：每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例&lt;/p&gt;
&lt;p&gt;3、Scoped：每次从同一个容器中获取的实例是相同的、&lt;/p&gt;
&lt;p&gt;关于服务的生命周期，如果还不清楚也没关系，因为接下来会不断的学习它&lt;/p&gt;
&lt;h2&gt;自定义创建容器和创建对象的过程&lt;/h2&gt;
&lt;p&gt;在文章的开头就介绍了该注入框架的三个过程，注册服务-&amp;gt;创建容器-&amp;gt;创建对象，然而注册服务的步骤是非常简单的，将一个个类似 AddTransient、AddSingleton 的方法提供的泛型参数或者实参转换成一个 ServiceDescriptor 对象存储在 IServiceCollection 中，而创建容器和床对象是否也是这样简单呢？如果是，想必很容易写出下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyServiceProvider : IServiceProvider
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ServiceDescriptor&amp;gt; serviceDescriptors = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;Type, &lt;span&gt;object&lt;/span&gt;&amp;gt; SingletonServices = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyServiceProvider(IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt;  serviceDescriptors)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceDescriptors.AddRange(serviceDescriptors);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetService(Type serviceType)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; descriptor = serviceDescriptors.FirstOrDefault(t =&amp;gt; t.ServiceType ==&lt;span&gt; serviceType);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(descriptor == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务‘{serviceType.Name}’未注册&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (descriptor.Lifetime)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ServiceLifetime.Singleton:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SingletonServices.TryGetValue(descriptor.ServiceType,&lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; obj))
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singletonObject =&lt;span&gt; Activator.CreateInstance(descriptor.ImplementationType);
                        SingletonServices.Add(descriptor.ServiceType, singletonObject);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
                    }
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ServiceLifetime.Scoped:
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NotSupportedException($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建失败，暂时不支持 Scoped&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ServiceLifetime.Transient:
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transientObject =&lt;span&gt; Activator.CreateInstance(descriptor.ImplementationType);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; transientObject;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NotSupportedException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建失败，不能识别的 LifeTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionContainerBuilderExtensions
{&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyServiceProvider BuildeMyServiceProvider(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyServiceProvider(services);
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 Scoped 的特殊性，部分人写到这里就戛然而止了，然而还有一个问题，我们知道注册服务的时候可能采取多种方式，这里只给出了&quot;服务实例类型&quot;的情形，稍作修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ServiceLifetime.Singleton:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SingletonServices.TryGetValue(descriptor.ServiceType,&lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; obj))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(descriptor.ImplementationType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singletonObject =&lt;span&gt; Activator.CreateInstance(descriptor.ImplementationType);
            SingletonServices.Add(descriptor.ServiceType, singletonObject);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(descriptor.ImplementationInstance != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            SingletonServices.Add(descriptor.ServiceType, descriptor.ImplementationInstance);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor.ImplementationInstance;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(descriptor.ImplementationFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singletonObject = descriptor.ImplementationFactory.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            SingletonServices.Add(descriptor.ServiceType, singletonObject);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建服务失败，无法找到实例类型或实例&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这里只重写了 Singleton 方式，但是其他的也应如此，实际上可以一直这么写下去，但是作为 C# 开发者就显得有些不优雅，因为这是面向过程（或者说是基于对象）的开开发模式&lt;/p&gt;
&lt;p&gt;此外，微软的注入是不支持属性注入的，但是别忘了，仍然是支持构造函数注入的，要不然这个注入那也太&lt;span class=&quot;ask-title&quot;&gt;鸡助了吧！是的，按照上述的代码段我们可以继续写下去，在解析出实例类型的时候，我们找到它的构造函数，找到构造函数的所有参数，以同样的方式创建参数的实例，这是一个递归的过程，最后回调，仍然可以创建我们需要的对象，但是这一切如何健壮、优雅的实现呢？这就是学习源码原因所在吧！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;ask-title&quot;&gt;微软是如何进一步处理元数据的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;其实上面的代码最主要的问题就是创建容器和创建对象这两个过程过度耦合了，并且存在一个最大的问题，仔细想想每次创建对象的时候都要去翻一遍 ServiceDescriptor 判断它是以“服务实例类型”、“服务实例对象”、“服务实例对象工厂”中的哪种方式注册的，这样就进行了一些不必要的性能消耗，然而这个工作微软是在创建容器的时候完成的。跟随着创建容器的过程我们义无反顾的向源码走去！去哪？寻找微软和如何处理 ServiceDescriptor 的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ask-title&quot;&gt;这里我们遇到的第一个拦路虎就是 ServiceProvider，我们创建的容器最终就是一个这样的类型，看看它是如何创建对象的？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProvider : IServiceProvider, IDisposable, IServiceProviderEngineCallback
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProviderEngine _engine;
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; ServiceProvider(IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; serviceDescriptors, ServiceProviderOptions options)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处省略了一些代码&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (options.Mode)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ServiceProviderMode.Dynamic:
                _engine &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicServiceProviderEngine(serviceDescriptors, callback);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处省略了一些代码&lt;/span&gt;
            &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentOutOfRangeException(nameof(options.Mode));
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetService(Type serviceType) =&amp;gt;&lt;span&gt; _engine.GetService(serviceType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt;&lt;span&gt; _engine.Dispose();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们知道，最终提供对象并非 ServiceProvide，而是它的一个字段  _engine 类型为 IServiceProviderEngine，在 switch 语句中，我只贴出了 Dynamic 这个分支的代码，因为该枚举变量 options 的默认值总是 Dynamic，这里我们仅仅需要知道 ServiceProvider 中提供对象的核心是一个 ServiceProviderEngine，并且它的默认实例是一个 DynamicServiceProviderEngine，因为这次探险我们是去分析微软是如何处理元数据的。这一切肯定在 DynamicServiceProviderEngine 创建过程中完成，所以我们只管寻找它的构造函数，终于，我们在父类 ServiceProviderEngine 找到了！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderEngine : IServiceProviderEngine, IServiceScopeFactory
{
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; CallSiteFactory CallSiteFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ServiceProviderEngine(IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; serviceDescriptors, IServiceProviderEngineCallback callback)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了一些代码&lt;/span&gt;
        CallSiteFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CallSiteFactory(serviceDescriptors);
        CallSiteFactory.Add(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IServiceProvider), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProviderCallSite());
        CallSiteFactory.Add(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IServiceScopeFactory), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceScopeFactoryCallSite());
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CallSiteFactory&lt;/h3&gt;
&lt;p&gt;这里只贴出了该类中三个字段，然而该类型也只有该三个字段，如果这三个字段具体的作用理解了，那么对于微软如何处理元数据这一问题也就知道答案了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallSiteFactory
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; _descriptors;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Dictionary&amp;lt;Type, IServiceCallSite&amp;gt; _callSiteCache = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, IServiceCallSite&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Dictionary&amp;lt;Type, ServiceDescriptorCacheItem&amp;gt; _descriptorLookup = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, ServiceDescriptorCacheItem&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ServiceDescriptorCacheItem
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServiceDescriptor _item;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; _items;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了一些代码&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServiceCallSite
{
    Type ServiceType { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    Type ImplementationType { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第一个字段 _descriptors  是一个元数据集合，我们注册的服务都在这里，然后我们看第三个字段 _descriptorLookup，因为注册服务的时候第一没有验证实例类型的有效性（接口，抽象类等），此外我们可以针对同一个服务进行多册注册，对于多次注册的服务微软又是如何确定创建的对象呢？这对这些问题，微软设计了一个类概括了具体一个服务的所有注册的实例类型 ServiceDescriptorCacheItem，具体针对一个服务，第一次注册的元数据存在 _item 中，后续该服务的所有元数据都存在 _items，而默认的总是认同最后一个元数据。最后最难理解的就是 _callSiteCache 这个字段了，简单的说，它的值 IServiceCallSite 是创建服务实例的依据，包含了服务类型和实例类型。我们知道从 _descriptorLookup 获取的是确定的实例类型，然而这个实例类型的构造函数中的类型如何创建呢，这些都在 IServiceCallSite 中体现，既然说 IServiceCallSite 是创建实例的依据，通过观察这个接口的定义发现也并没有和生命周期相关的属性，有点失望！&lt;/p&gt;
&lt;p&gt;我们回到创建 ServiceProviderEngine 创建 CallSiteFactory 的那一行代码，在创建CallSiteFactory 完成后，它调用了 Add 方法添加了两个键值对。第一行代码的键是啥？ IServiceProvider，是的微软默认的允许 IServiceProvider 提供自己！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CallSiteFactory.Add(&lt;span&gt;typeof&lt;/span&gt;(IServiceProvider), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProviderCallSite());
CallSiteFactory.Add(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IServiceScopeFactory), &lt;span&gt;new&lt;/span&gt; ServiceScopeFactoryCallSite());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 Add 添加的键值对是存储在 _callSiteCache 中的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(Type type, IServiceCallSite serviceCallSite)
{
    _callSiteCache[type] &lt;/span&gt;=&lt;span&gt; serviceCallSite;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们观察 ServiceProviderCallSite、ServiceScopeFactoryCallSite 这两个类型，出了增加了两个不认识的类型，并没有其他收获&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderCallSite : IServiceCallSite
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ServiceType { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IServiceProvider);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ImplementationType { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ServiceProvider);
}
&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceScopeFactoryCallSite : IServiceCallSite
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ServiceType { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IServiceScopeFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ImplementationType { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ServiceProviderEngine);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于注入的一些猜想&lt;/h2&gt;
&lt;p&gt;从上述的学习我们有了一个较为意外的收获，IServiceProvider 是可以提供自己的，这不得不使我们猜想，IServiceProvider 具有怎样的生命周期？如果不断的用一个 IServiceProvider 创建一个新的，如此下去，又是如何？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    IServiceCollection services &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider =&lt;span&gt; services.BuildServiceProvider();

    Console.WriteLine(ReferenceEquals(serviceProvider.GetService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;(), serviceProvider.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;()));

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider1 =&lt;span&gt; serviceProvider.CreateScope().ServiceProvider;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider2 =&lt;span&gt; serviceProvider.CreateScope().ServiceProvider;

    Console.WriteLine(ReferenceEquals(serviceProvider1.GetService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;(), serviceProvider2.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;()));

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider3 = serviceProvider.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider4 = serviceProvider.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider3_1 = serviceProvider3.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider4_1 = serviceProvider4.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;();

    Console.WriteLine(ReferenceEquals(serviceProvider3,serviceProvider4));
    Console.WriteLine(ReferenceEquals(serviceProvider3_1, serviceProvider4_1));
    Console.WriteLine(ReferenceEquals(serviceProvider3, serviceProvider3_1));

    Console.WriteLine(ReferenceEquals(serviceProvider3,serviceProvider));

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; True
     * False
     * True
     * True
     * True
     * False
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里对 CreateScope 我们仅需要知道它创建的是一个具有限定范围的容器即可，我们根据第一个输出结果为 True 和第二个输出结果为 False，从这点看 IServiceProvider 的生命周期和 Scoped 的定义一致，但是由于 IServiceProvider 的特殊性，它可以一直不断的创建自己，并且他们都是同一个对象，但是和最初的 ServiceProvider 都不一样。这让我们又怀疑 IServiceProvider 究竟是不是 Scoped。&lt;/p&gt;
&lt;h5&gt;小结&lt;/h5&gt;
&lt;p&gt;这一节主要介绍了服务的三种生命周期，以及服务是如何注册到元数据的，并且在创建容器的过程中，我们知道了微软是如何进一步处理元数据的，以及创建实例对象的最终依据是 IServiceCallSite，但是想要真正的搞明白 IServiceCallSite 还必须详细的了解创建容器和创建实例的过程。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 06:14:00 +0000</pubDate>
<dc:creator>行走即歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cheesebar/p/7675214.html</dc:identifier>
</item>
<item>
<title>webpack 入门指南 - 菜鸟的飞翔梦</title>
<link>http://www.cnblogs.com/HanJie0824/p/7709489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HanJie0824/p/7709489.html</guid>
<description>&lt;p&gt;很久没有更博了。。。&lt;/p&gt;
&lt;p&gt;这就把最近积累用到的知识点更新到这里。。&lt;/p&gt;
&lt;p&gt;望 共勉&lt;/p&gt;




&lt;p&gt;什么是 webpack？&lt;/p&gt;
&lt;p&gt;webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。&lt;/p&gt;
&lt;p&gt;我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。&lt;/p&gt;
&lt;p&gt;你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。&lt;/p&gt;
&lt;p&gt;webpack的官网是 &lt;a href=&quot;http://webpack.github.io/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://webpack.github.io/&lt;/a&gt; ，文档地址是 &lt;a href=&quot;http://webpack.github.io/docs/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://webpack.github.io/docs/&lt;/a&gt; ，想对其进行更详细了解的可以点进去瞧一瞧。&lt;/p&gt;
&lt;p&gt;webpack 的优势&lt;/p&gt;
&lt;p&gt;其优势主要可以归类为如下几个：&lt;/p&gt;
&lt;p&gt;1. webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。&lt;/p&gt;
&lt;p&gt;2. 能被模块化的不仅仅是 JS 了。&lt;/p&gt;
&lt;p&gt;3. 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。&lt;/p&gt;
&lt;p&gt;4. 扩展性强，插件机制完善，特别是支持 React 热插拔（见 &lt;a href=&quot;https://github.com/gaearon/react-hot-loader&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;react-hot-loader&lt;/a&gt; ）的功能让人眼前一亮。&lt;/p&gt;
&lt;p&gt;我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_226065&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;define([&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'package/lib'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;],&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(lib){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;foo(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;lib.log(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'hello world!'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;foo: foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_859597&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;define(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(require, exports, module){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;someModule = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;someModule&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;anotherModule = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;anotherModule&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);   &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;someModule.doTehAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;anotherModule.doMoarAwesome();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;exports.asplode =&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;someModule.doTehAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;anotherModule.doMoarAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_799498&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;someModule = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;someModule&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;anotherModule = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;anotherModule&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);   &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;someModule.doTehAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;anotherModule.doMoarAwesome();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;exports.asplode =&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;someModule.doTehAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;anotherModule.doMoarAwesome();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样撸码自然更简单，跟回调神马的说 byebye~&lt;/p&gt;
&lt;p&gt;不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。&lt;/p&gt;
&lt;p&gt;安装和配置&lt;/p&gt;
&lt;h2&gt;一. 安装&lt;/h2&gt;
&lt;p&gt;我们常规直接使用 npm 的形式来安装：&lt;/p&gt;
&lt;p class=&quot;VJ_note&quot;&gt;$ npm install webpack -g&lt;/p&gt;
&lt;p&gt;当然如果常规项目还是把依赖写入 package.json 包去更人性化：&lt;/p&gt;
&lt;p class=&quot;VJ_note&quot;&gt;$ npm init&lt;br/&gt;$ npm install webpack --save-dev&lt;/p&gt;
&lt;h2&gt;二. 配置&lt;/h2&gt;
&lt;p&gt;每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。&lt;/p&gt;
&lt;p&gt;我们看看下方的示例：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_956880&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;26&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;27&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;53&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;webpack = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'webpack'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;commonsPlugin =&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;webpack.optimize.CommonsChunkPlugin(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'common.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;module.exports = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;plugins: [commonsPlugin],&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;entry: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;index :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'./src/js/page/index.js'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;output: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;path:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'dist/js/page'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;filename:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'[name].js'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;module: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;loaders: [&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.css$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'style-loader!css-loader'&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.js$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'jsx-loader?harmony'&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.scss$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'style!css!sass?sourceMap'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.(png|jpg)$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'url-loader?limit=8192'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;resolve: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;root:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'E:/github/flux-example/src'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;extensions: [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;''&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.json'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.scss'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;],&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;alias: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;AppStore :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/stores/AppStores.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;ActionType :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/actions/ActionType.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;AppAction :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/actions/AppAction.js'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。&lt;/p&gt;
&lt;p&gt;⑵ entry 是页面入口文件配置，output 是对应输出项配置&lt;em&gt;（即入口文件最终要生成什么名字的文件、存放到哪里）&lt;/em&gt;，其语法大致为：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_509608&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;entry: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;page1:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./page1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;page2: [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;./entry1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./entry2&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;output: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;path:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;dist/js/page&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;filename:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;[name].bundle.js&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。&lt;/p&gt;
&lt;p&gt;⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_601625&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;module: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;loaders: [&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.css$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'style-loader!css-loader'&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.js$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'jsx-loader?harmony'&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.scss$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'style!css!sass?sourceMap'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{ test: /\.(png|jpg)$/, loader:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'url-loader?limit=8192'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上，&quot;-loader&quot;其实是可以省略不写的，多个loader之间用“!”连接起来。&lt;/p&gt;
&lt;p&gt;注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。&lt;/p&gt;
&lt;p&gt;拿最后一个 &lt;a href=&quot;https://github.com/webpack/url-loader&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;url-loader&lt;/a&gt; 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：&lt;/p&gt;
&lt;p class=&quot;VJ_note&quot;&gt;npm install url-loader -save-dev&lt;/p&gt;
&lt;p&gt;配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式&lt;em&gt;（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_184070&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;resolve: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;root:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'E:/github/flux-example/src'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;extensions: [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;''&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.json'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'.scss'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;],&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;alias: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;AppStore :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/stores/AppStores.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;ActionType :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/actions/ActionType.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;AppAction :&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'js/actions/AppAction.js'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;关于 webpack.config.js 更详尽的配置可以参考&lt;a href=&quot;http://webpack.github.io/docs/configuration.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;运行 webpack&lt;/p&gt;
&lt;p&gt;webpack 的执行也很简单，直接执行&lt;/p&gt;
&lt;p class=&quot;VJ_note&quot;&gt;$ webpack --display-error-details&lt;/p&gt;
&lt;p&gt;即可，后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。&lt;/p&gt;
&lt;p&gt;其他主要的参数有：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_952899&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;$ webpack --config XXX.js  &lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;$ webpack --watch  &lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;$ webpack -p   &lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;$ webpack -d   &lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中的 &lt;em&gt;-p&lt;/em&gt; 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb&lt;em&gt;（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;模块引入&lt;/p&gt;
&lt;p&gt;上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。&lt;/p&gt;
&lt;h2&gt;一. HTML&lt;/h2&gt;
&lt;p&gt;直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_979273&quot; class=&quot;syntaxhighlighter html&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;html&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;head&lt;/code&gt; &lt;code class=&quot;html color1&quot;&gt;lang&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;html string&quot;&gt;&quot;en&quot;&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;meta&lt;/code&gt; &lt;code class=&quot;html color1&quot;&gt;charset&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;html string&quot;&gt;&quot;UTF-8&quot;&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;title&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;demo&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;title&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;head&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;body&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;script&lt;/code&gt; &lt;code class=&quot;html color1&quot;&gt;src&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;html string&quot;&gt;&quot;dist/js/page/common.js&quot;&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;script&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;script&lt;/code&gt; &lt;code class=&quot;html color1&quot;&gt;src&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;html string&quot;&gt;&quot;dist/js/page/index.js&quot;&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;script&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;body&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;lt;/&lt;/code&gt;&lt;code class=&quot;html keyword&quot;&gt;html&lt;/code&gt;&lt;code class=&quot;html plain&quot;&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成&amp;lt;style&amp;gt;并标签打到head里。&lt;/p&gt;
&lt;h2&gt;二. JS&lt;/h2&gt;
&lt;p&gt;各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。&lt;/p&gt;
&lt;p&gt;我们再看看编译前的页面入口文件（index.js）：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_887636&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'../../css/reset.scss'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'../../css/allComponent.scss'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;React = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'react'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;AppWrap = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'../component/AppWrap'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;createRedux = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'redux'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;).createRedux;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;Provider = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'redux/react'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;).Provider;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;stores = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'AppStore'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;redux = createRedux(stores);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;App = React.createClass({&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;render:&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&amp;lt;Provider redux={redux}&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;() {&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;&amp;lt;AppWrap /&amp;gt;; }}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&amp;lt;/Provider&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;React.render(&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&amp;lt;App /&amp;gt;, document.body&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。&lt;/p&gt;
&lt;p&gt;其他&lt;/p&gt;
&lt;p&gt;至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。&lt;/p&gt;
&lt;h2&gt;一. shimming&lt;/h2&gt;
&lt;p&gt;在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 &lt;a href=&quot;https://github.com/webpack/exports-loader&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;exports-loader&lt;/a&gt; 来帮忙：&lt;/p&gt;
&lt;pre&gt;
{ test: require.resolve(&quot;./src/js/tool/swipe.js&quot;),  loader: &quot;exports?swipe&quot;}
&lt;/pre&gt;
&lt;p&gt;之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：&lt;/p&gt;
&lt;pre&gt;
require('./tool/swipe.js');
swipe(); 
&lt;/pre&gt;
&lt;h2&gt;二. 自定义公共模块提取&lt;/h2&gt;
&lt;p&gt;在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。&lt;/p&gt;
&lt;p&gt;但有时候我们希望能更加个性化一些，我们可以这样配置：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_603246&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;17&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;CommonsChunkPlugin = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;module.exports = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;entry: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;p1:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./page1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;p2:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./page2&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;p3:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./page3&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;ap1:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./admin/page1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;ap2:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;./admin/page2&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;output: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;filename:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;[name].js&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;plugins: [&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;CommonsChunkPlugin(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;admin-commons.js&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;, [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;ap1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;ap2&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]),&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;CommonsChunkPlugin(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;commons.js&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;, [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;p1&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;p2&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;admin-commons.js&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;






&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;三. 独立打包样式文件&lt;/h2&gt;
&lt;p&gt;有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以&amp;lt;link&amp;gt;标签引入。这时候我们需要 &lt;a href=&quot;https://github.com/webpack/extract-text-webpack-plugin&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;extract-text-webpack-plugin&lt;/a&gt; 来帮忙：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_368505&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;webpack = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'webpack'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;commonsPlugin =&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;webpack.optimize.CommonsChunkPlugin(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'common.js'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;ExtractTextPlugin = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;extract-text-webpack-plugin&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;module.exports = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;plugins: [commonsPlugin,&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;ExtractTextPlugin(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;[name].css&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;)],&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;entry: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最终 webpack 执行后会乖乖地把样式文件提取出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.w2bc.com/upload/201507/16/201507161700552446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四. 使用CDN/远程文件&lt;/h2&gt;
&lt;p&gt;有时候我们希望某些模块走CDN并以&amp;lt;script&amp;gt;的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。&lt;/p&gt;
&lt;p&gt;这时候我们可以在配置文件里使用 externals 属性来帮忙：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_190945&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;externals: {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;jquery&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;jQuery&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。&lt;/p&gt;
&lt;p&gt;我们倒也可以使用 &lt;a href=&quot;https://github.com/ded/script.js&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;script.js&lt;/a&gt; 在脚本中来加载我们的模块：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_546147&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;$script = require(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;scriptjs&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;$script(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;$(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'body'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;).html(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'It works!'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;五. 与 grunt/gulp 配合&lt;/h2&gt;
&lt;p&gt;以 gulp 为示例，我们可以这样混搭：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_540448&quot; class=&quot;syntaxhighlighter js&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;gulp.task(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;webpack&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(callback) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;webpack({&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(err, stats) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(err)&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;throw&lt;/code&gt; &lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;gutil.PluginError(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;webpack&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;, err);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;gutil.log(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;[webpack]&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;, stats.toString({&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;            &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;callback();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当然我们只需要把配置写到 webpack({ ... }) 中去即可，无须再写 webpack.config.js 了。&lt;/p&gt;
&lt;p&gt;更多参照信息请参阅：&lt;a href=&quot;http://webpack.github.io/docs/usage-with-grunt.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;grunt配置&lt;/a&gt; / &lt;a href=&quot;http://webpack.github.io/docs/usage-with-gulp.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;gulp配置&lt;/a&gt; 。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 05:56:00 +0000</pubDate>
<dc:creator>菜鸟的飞翔梦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HanJie0824/p/7709489.html</dc:identifier>
</item>
<item>
<title>Java并发编程之原子变量 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/7709395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/7709395.html</guid>
<description>&lt;p&gt;     原子变量最主要的一个特点就是所有的操作都是原子的，synchronized关键字也可以做到对变量的原子操作。只是synchronized的成本相对较高，需要获取锁对象，释放锁对象，如果不能获取到锁，还需要阻塞在阻塞队列上进行等待。而如果单单只是为了解决对变量的原子操作，建议使用原子变量。关于原子变量的介绍，主要涉及以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子变量的基本概念&lt;/li&gt;
&lt;li&gt;通过AtomicInteger了解原子变量的基本使用&lt;/li&gt;
&lt;li&gt;通过AtomicInteger了解原子变量的基本原理&lt;/li&gt;
&lt;li&gt;AtomicReference的基本使用&lt;/li&gt;
&lt;li&gt;使用FieldUpdater操作非原子变量的字段属性&lt;/li&gt;
&lt;li&gt;经典的ABA问题的解决&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一、原子变量的基本概念&lt;/strong&gt;&lt;br/&gt;     原子变量保证了该变量的所有操作都是原子的，不会因为多线程的同时访问而导致脏数据的读取问题。我们先看一段synchronized关键字保证变量原子性的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Counter {
    private int count;

    public synchronized void addCount(){
        this.count++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的count++操作，线程对象首先需要获取到Counter 类实例的对象锁，然后完成自增操作，最后释放对象锁。整个过程中，无论是获取锁还是释放锁都是相当消耗成本的，一旦不能获取到锁，还需要阻塞当前线程等等。&lt;/p&gt;
&lt;p&gt;对于这种情况，我们可以将count变量声明成原子变量，那么对于count的自增操作都可以以原子的方式进行，就不存在脏数据的读取了。Java给我们提供了以下几种原子类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicInteger和AtomicIntegerArray：基于Integer类型&lt;/li&gt;
&lt;li&gt;AtomicBoolean：基于Boolean类型&lt;/li&gt;
&lt;li&gt;AtomicLong和AtomicLongArray：基于Long类型&lt;/li&gt;
&lt;li&gt;AtomicReference和AtomicReferenceArray：基于引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本文的余下内容中，我们将主要介绍AtomicInteger和AtomicReference两种类型，AtomicBoolean和AtomicLong的使用和内部实现原理几乎和AtomicInteger一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、AtomicInteger的基本使用&lt;/strong&gt;&lt;br/&gt;     首先看它的两个构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private volatile int value;

public AtomicInteger(int initialValue) {
    value = initialValue;
}
public AtomicInteger() {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们在通过构造函数构造AtomicInteger原子变量的时候，如果指定一个int的参数，那么该原子变量的值就会被赋值，否则就是默认的数值0。&lt;/p&gt;
&lt;p&gt;也有获取和设置这个value值的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final int get()
public final void set(int newValue) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这两个方法并不是原子的，所以一般也很少使用，而以下的这些基于原子操作的方法则相对使用的频繁，至于它们的具体实现是怎样的，我们将在本文的后续小节中进行简单的学习。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//基于原子操作，获取当前原子变量中的值并为其设置新值
public final int getAndSet(int newValue)
//基于原子操作，比较当前的value是否等于expect，如果是设置为update并返回true，否则返回false
public final boolean compareAndSet(int expect, int update)
//基于原子操作，获取当前的value值并自增一
public final int getAndIncrement()
//基于原子操作，获取当前的value值并自减一
public final int getAndDecrement()
//基于原子操作，获取当前的value值并为value加上delta
public final int getAndAdd(int delta)
//还有一些反向的方法，比如：先自增在获取值的等等&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们实现一个计数器的例子，之前我们使用synchronized实现过，现在我们使用原子变量再次实现该问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//自定义一个线程类
public class MyThread extends Thread {

    public static AtomicInteger value = new AtomicInteger();

    @Override
    public void run(){
        try {
            Thread.sleep((long) ((Math.random())*100));
            //原子自增
            value.incrementAndGet();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//main函数中启动100条线程并让他们启动
public static void main(String[] args) throws InterruptedException {
    Thread[] threads = new Thread[100];
    for (int i=0;i&amp;lt;100;i++){
        threads[i] = new MyThread();
        threads[i].start();
    }

    for (int j=0;j&amp;lt;100;j++){
        threads[j].join();
    }

    System.out.println(&quot;value:&quot;+MyThread.value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多次运行会得到相同的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171021140747297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，使用原子变量要比使用synchronized要简洁的多并且效率也相对较高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、AtomicInteger的内部基本原理&lt;/strong&gt;&lt;br/&gt;     AtomicInteger的实现原理有点像我们的包装类，内部主要操作的是value字段，这个字段保存就是原子变量的数值。value字段定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private volatile int value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先value字段被volatile修饰，即不存在内存可见性问题。由于其内部实现原子操作的代码几乎类似，我们主要学习下incrementAndGet方法的实现。&lt;/p&gt;
&lt;p&gt;在揭露该方法的实现原理之前，我们先看另一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean compareAndSet(int expect, int update{
     return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;compareAndSet方法又被称为CAS，该方法调用unsave的一个compareAndSwapInt方法，这个方法是native，我们看不到源码，但是我们需要知道该方法完成的一个目标：比较当前原子变量的值是否等于expect，如果是则将其修改为update并返回true，否则直接返回false。当然，这个操作本身就是原子的，较为底层的实现。&lt;/p&gt;
&lt;p&gt;在jdk1.7之前，我们的incrementAndGet方法是这样实现的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法体是一个死循环，current获取到当前原子变量中的值，由于value被修饰volatile，所以不存在内存可见性问题，数据一定是最新的。然后current加一后赋值给next，调用我们的CAS原子操作判断value是否被别的线程修改过，如果还是原来的值，那么将next的值赋值给value并返回next，否则重新获取当前value的值，再次进行判断，直到操作完成。&lt;/p&gt;
&lt;p&gt;incrementAndGet方法的一个很核心的思想是，在加一之前先去看看value的值是多少，真正加的时候再去看一下，如果发现变了，不操作数据，否则为value加一。&lt;/p&gt;
&lt;p&gt;但是在jdk1.8以后，做了一些优化，但是最后还是调用的compareAndSwapInt方法。但基本思想还是没变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、AtomicReference的基本使用&lt;/strong&gt;&lt;br/&gt;     对于一些自定义类或者字符串等这些引用类型，Java并发包也提供了原子变量的接口支持。AtomicReference内部使用泛型来实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private volatile V value;

public AtomicReference(V initialValue) {
    value = initialValue;
}

public AtomicReference() {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关其他的一些原子方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取并设置value的值为newvalue
public final V getAndSet(V newValue) {
    return (V)unsafe.getAndSetObject(this, valueOffset, newValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AtomicReference中少了一些自增自减的操作，但是对于value的修改依然是原子的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、使用FieldUpdater操作非原子变量的字段属性&lt;/strong&gt;&lt;br/&gt;     FieldUpdater允许我们不必将字段设置为原子变量，利用反射直接以原子方式操作字段。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义一个计数器
public class Counter {
    private volatile  int count;

    public int getCount() {
        return count;
    }

    public void addCount(){
        AtomicIntegerFieldUpdater&amp;lt;Counter&amp;gt; updater  = AtomicIntegerFieldUpdater.newUpdater(Counter.class,&quot;count&quot;);
        updater.getAndIncrement(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们创建一百个线程随机调用同一个Counter对象的addCount方法，无论运行多少次，结果都是一百。这种方式实现的原子操作，对于被操作的变量不需要被包装成原子变量，但是却可以直接以原子方式操作它的数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、经典的ABA问题&lt;/strong&gt;&lt;br/&gt;     我们的原子变量都依赖一个核心的方法，那就是CAS。这个方法最核心的思想就是，更改变量值之前先获取该变量当前最新的值，然后在实际更改的时候再次获取该变量的值，如果没有被修改，那么进行更改，否则循环上述操作直至更改操作完成。假如一个线程想要对变量count进行修改，实际操作之前获取count的值为A，此时来了一个线程将count值修改为B，又来一个线程获取count的值为B并将count修改为A，此时第一个线程全然不知道count的值已经被修改两次了，虽然值还是A，但是实际上数据已经是脏的。&lt;/p&gt;
&lt;p&gt;这就是典型的ABA问题，一个解决办法是，对count的每次操作都记录下当前的一个时间戳，这样当我们原子操作count之前，不仅查看count的最新数值，还记录下该count的时间戳，在实际操作的时候，只有在count的数值和时间戳都没有被更改的情况之下才完成修改操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    int count=0;
    int stamp = 1;
    AtomicStampedReference reference = new AtomicStampedReference(count,stamp);
    int next = count++;
    reference.compareAndSet(count, next, stamp, stamp);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AtomicStampedReference 的CAS方法要求传入四个参数，该方法的内部会同时比较count和stamp，只有这两个值都没有发生改变的前提下，CAS才会修改count的值。&lt;/p&gt;
&lt;p&gt;上述我们介绍了有关原子变量的最基本内容，最后我们比较下原子变量和synchronized关键字的区别。&lt;/p&gt;
&lt;p&gt;从思维模式上看，原子变量代表一种乐观的非阻塞式思维，它假定没有别人会和我同时操作某个变量，于是在实际修改变量的值的之前不会锁定该变量，但是修改变量的时候是使用CAS进行的，一旦发现冲突，继续尝试直到成功修改该变量。&lt;/p&gt;
&lt;p&gt;而synchronized关键字则是一种悲观的阻塞式思维，它认为所有人都会和我同时来操作某个变量，于是在将要操作该变量之前会加锁来锁定该变量，进而继续操作该变量。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 05:03:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/7709395.html</dc:identifier>
</item>
<item>
<title>Akka（29）： Http：Server-Side-Api，Low-Level-Api - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/7709377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/7709377.html</guid>
<description>&lt;p&gt;&lt;span&gt; Akka-http针对Connection的两头都提供了方便编程的Api，分别是Server-Side-Api和Client-Side-Api。通过这两个Api可以大大提高编程效率。当然，上期我们提到过，Http-Server是Akka-http的核心部分，所有系统集成功能都是在Server-Side实现的。Akka-http-Server-Side-Api可以说是最先进的Http-Server编程工具，支持：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Full support for &lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_persistent_connection&quot; target=&quot;_blank&quot;&gt;HTTP persistent connections&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Full support for &lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_pipelining&quot; target=&quot;_blank&quot;&gt;HTTP pipelining&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Full support for asynchronous HTTP streaming including “chunked” transfer encoding accessible through an idiomatic API&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Optional SSL/TLS encryption&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WebSocket support&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Server-Side-Api又分两个层次：Low-level-Server-Side-Api和High-level-Server-Side-Api。Low-level-server-api支持HTTP/1.1Server所有功能，包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Connection management&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Parsing and rendering of messages and headers&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Timeout management (for requests and connections)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Response ordering (for transparent pipelining support)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其它Server功能如请求解析request routing，文件服务file serving，数据压缩compression等都放在了High-level-server-api里。Akka-http是基于Akka-stream编写的，所以我们需要从Akka-stream运算模式来理解Akka-http的类型表现形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个Http-Server是绑定在一个Socket上来接收客户端上传的request进行相关的服务提供的。Server对Socket的绑定在Akka-http里的可以Stream形式来表现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;val serverSource: Source[Http.IncomingConnection, Future[Http.ServerBinding]] =&lt;span&gt;
  Http().bind(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, port = &lt;span&gt;8080&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Server-Side Socket绑定实际上就是一个Akka-stream-source：Source[IncomingConnection]：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Creates a [[akka.stream.scaladsl.Source]] of [[akka.http.scaladsl.Http.IncomingConnection]] instances which represents a prospective HTTP server binding
   * on the given `endpoint`.
   *
   * If the given port is 0 the resulting source can be materialized several times. Each materialization will
   * then be assigned a new local port by the operating system, which can then be retrieved by the materialized
   * [[akka.http.scaladsl.Http.ServerBinding]].
   *
   * If the given port is non-zero subsequent materialization attempts of the produced source will immediately
   * fail, unless the first materialization has already been unbound. Unbinding can be triggered via the materialized
   * [[akka.http.scaladsl.Http.ServerBinding]].
   *
   * If an [[ConnectionContext]] is given it will be used for setting up TLS encryption on the binding.
   * Otherwise the binding will be unencrypted.
   *
   * If no `port` is explicitly given (or the port value is negative) the protocol's default port will be used,
   * which is 80 for HTTP and 443 for HTTPS.
   *
   * To configure additional settings for a server started using this method,
   * use the `akka.http.server` config section or pass in a [[akka.http.scaladsl.settings.ServerSettings]] explicitly.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  def bind(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;: String, port: Int =&lt;span&gt; DefaultPortForProtocol,
           connectionContext: ConnectionContext &lt;/span&gt;=&lt;span&gt; defaultServerHttpContext,
           settings:          ServerSettings    &lt;/span&gt;=&lt;span&gt; ServerSettings(system),
           log:               LoggingAdapter    &lt;/span&gt;= system.log)(&lt;span&gt;implicit&lt;/span&gt; fm: Materializer): Source[Http.IncomingConnection, Future[ServerBinding]] =&lt;span&gt; {
    val fullLayer &lt;/span&gt;=&lt;span&gt; fuseServerBidiFlow(settings, connectionContext, log)

    tcpBind(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;, choosePort(port, connectionContext), settings)
      .map(incoming ⇒ {
        val serverFlow &lt;/span&gt;=&lt;span&gt; fullLayer.addAttributes(prepareAttributes(settings, incoming)) join incoming.flow
        IncomingConnection(incoming.localAddress, incoming.remoteAddress, serverFlow)
      })
      .mapMaterializedValue(materializeTcpBind)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;run这个Source[IncomingConnection]产生一串连接Connection： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Represents one accepted incoming HTTP connection.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  final &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IncomingConnection(
    localAddress:  InetSocketAddress,
    remoteAddress: InetSocketAddress,
    flow:          Flow[HttpResponse, HttpRequest, NotUsed]) {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Handles the connection with the given flow, which is materialized exactly once
     * and the respective materialization result returned.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    def handleWith[Mat](handler: Flow[HttpRequest, HttpResponse, Mat])(&lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; fm: Materializer): Mat =&lt;span&gt;
      flow.joinMat(handler)(Keep.right).run()

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Handles the connection with the given handler function.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    def handleWithSyncHandler(handler: HttpRequest ⇒ HttpResponse)(&lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; fm: Materializer): Unit =&lt;span&gt;
      handleWith(Flow[HttpRequest].map(handler))

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Handles the connection with the given handler function.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    def handleWithAsyncHandler(handler: HttpRequest ⇒ Future[HttpResponse], parallelism: Int &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;)(&lt;span&gt;implicit&lt;/span&gt; fm: Materializer): Unit =&lt;span&gt;
      handleWith(Flow[HttpRequest].mapAsync(parallelism)(handler))
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;IncomingConnection类型提供了个handleWith这样的streaming函数进行request到response的转换。用户可以下面的方式提供自定义的转换方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用handleWith传入Flow[HttpRequest,HttpResponse,_]，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def req2Resp: HttpRequest =&amp;gt; HttpResponse = _ =&amp;gt; HttpResponse(entity=&lt;span&gt;
    HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val flow &lt;/span&gt;= Flow.fromFunction(req2Resp)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;提供HttpRequest=&amp;gt;HttpResponse函数传人handleWithSyncHandler：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def syncHandler: HttpRequest =&amp;gt; HttpResponse =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; HttpRequest(HttpMethods.GET,Uri.Path(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),_headers,_entiy,_protocol) =&amp;gt;&lt;span&gt;
      HttpResponse(entity&lt;/span&gt;=&lt;span&gt;
        HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; req: HttpRequest =&amp;gt;&lt;span&gt;
      req.discardEntityBytes() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; important to drain incoming HTTP Entity stream&lt;/span&gt;
      HttpResponse(&lt;span&gt;404&lt;/span&gt;, entity = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown resource!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;提供HttpRequest=&amp;gt;Future[HttpResponse]函数传人handleWithASyncHandler：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def asyncHandler: HttpRequest =&amp;gt; Future[HttpResponse] =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; HttpRequest(HttpMethods.GET,Uri.Path(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),_headers,_entiy,_protocol) =&amp;gt;&lt;span&gt; Future {
      HttpResponse(entity&lt;/span&gt;=&lt;span&gt;
        HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) }

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; req: HttpRequest =&amp;gt;&lt;span&gt; Future {
      req.discardEntityBytes() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; important to drain incoming HTTP Entity stream&lt;/span&gt;
      HttpResponse(&lt;span&gt;404&lt;/span&gt;, entity = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown resource!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;run Source[IncomingConnection,Future[ServerBinding]]返回结果为Future[ServerBinding]：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val futBinding: Future[Http.ServerBinding] =&lt;span&gt;
    connSource.to { Sink.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;{ connection =&amp;gt;&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client address ${connection.remoteAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      connection handleWith flow
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    connection handleWithSyncHandler syncHandler&lt;/span&gt;
&lt;span&gt;      connection handleWithAsyncHandler asyncHandler
    }}.run()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以通过ServerBinding来释放绑定的Socket：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Represents a prospective HTTP server binding.
   *
   * @param localAddress  The local address of the endpoint bound by the materialization of the `connections` [[akka.stream.scaladsl.Source]]
   *
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  final &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServerBinding(localAddress: InetSocketAddress)(&lt;span&gt;private&lt;/span&gt;&lt;span&gt; val unbindAction: () ⇒ Future[Unit]) {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Asynchronously triggers the unbinding of the port that was bound by the materialization of the `connections`
     * [[akka.stream.scaladsl.Source]]
     *
     * The produced [[scala.concurrent.Future]] is fulfilled when the unbinding has been completed.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    def unbind(): Future[Unit] &lt;/span&gt;=&lt;span&gt; unbindAction()
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以调用这个unbind()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  futBinding.flatMap(_.unbind())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;整个示范源代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import akka.actor._
import akka.stream._
import akka.stream.scaladsl._
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import scala.concurrent._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; LowLevelServerApi extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpSys = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actorSystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpMat =&lt;span&gt; ActorMaterializer()
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpEc =&lt;span&gt; httpSys.dispatcher

  val (&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;,port) = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;8088&lt;/span&gt;&lt;span&gt;)
  val connSource: Source[Http.IncomingConnection,Future[Http.ServerBinding]] &lt;/span&gt;=&lt;span&gt;
    Http().bind(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;,port)

  def req2Resp: HttpRequest &lt;/span&gt;=&amp;gt; HttpResponse = _ =&amp;gt; HttpResponse(entity=&lt;span&gt;
    HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val flow &lt;/span&gt;=&lt;span&gt; Flow.fromFunction(req2Resp)

  def syncHandler: HttpRequest &lt;/span&gt;=&amp;gt; HttpResponse =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; HttpRequest(HttpMethods.GET,Uri.Path(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),_headers,_entiy,_protocol) =&amp;gt;&lt;span&gt;
      HttpResponse(entity&lt;/span&gt;=&lt;span&gt;
        HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; req: HttpRequest =&amp;gt;&lt;span&gt;
      req.discardEntityBytes() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; important to drain incoming HTTP Entity stream&lt;/span&gt;
      HttpResponse(&lt;span&gt;404&lt;/span&gt;, entity = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown resource!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }

  def asyncHandler: HttpRequest &lt;/span&gt;=&amp;gt; Future[HttpResponse] =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; HttpRequest(HttpMethods.GET,Uri.Path(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),_headers,_entiy,_protocol) =&amp;gt;&lt;span&gt; Future {
      HttpResponse(entity&lt;/span&gt;=&lt;span&gt;
        HttpEntity(ContentTypes.`text&lt;/span&gt;/html(UTF-&lt;span&gt;8&lt;/span&gt;)`,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h&amp;gt; Hello World! &amp;lt;/h&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) }

    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; req: HttpRequest =&amp;gt;&lt;span&gt; Future {
      req.discardEntityBytes() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; important to drain incoming HTTP Entity stream&lt;/span&gt;
      HttpResponse(&lt;span&gt;404&lt;/span&gt;, entity = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown resource!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
  }

  val futBinding: Future[Http.ServerBinding] &lt;/span&gt;=&lt;span&gt;
    connSource.to { Sink.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;{ connection =&amp;gt;&lt;span&gt;
        println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client address ${connection.remoteAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      connection handleWith flow
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    connection handleWithSyncHandler syncHandler&lt;/span&gt;
&lt;span&gt;      connection handleWithAsyncHandler asyncHandler
    }}.run()

  println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server running at $interface $port. Press any key to exit ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  scala.io.StdIn.readLine()

  futBinding.flatMap(_.unbind())
    .onComplete(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; httpSys.terminate())
  
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 05:02:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/7709377.html</dc:identifier>
</item>
<item>
<title>Spring装配Bean之XML装配bean - wuxiwei</title>
<link>http://www.cnblogs.com/wxw16/p/7705219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxw16/p/7705219.html</guid>
<description>&lt;p&gt;在Spring刚出现的时候，XML是描述配置的主要方式，在Spring的名义下，我们创建了无数行XML代码。在一定程度上，Spring成为了XML的同义词。&lt;br/&gt;现在随着强大的自动化配置和Java代码的配置出现，XML不再是唯一选择，也不应该是首选，学习XML配置，更多用于维护已有的XML的配置。&lt;/p&gt;
&lt;h3 id=&quot;创建xml配置规范&quot;&gt;创建XML配置规范&lt;/h3&gt;
&lt;p&gt;在使用XML配置前，需要创建一个新的配置规范，就像JavaConfig需要我们创建带有 @Configuration注解的类，而在XML配置中，需要创建一个新的XML配置文件，并且要以&amp;lt;beans&amp;gt;元素为根。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;;
  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context&quot;&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出基本的XML配置就已经比JavaConfig复杂很多。用来装配bean的最基本的XML元素包含在spring-beans模式中，在上面这个XML文件中，它被定义为根命名空间。&amp;lt;beans&amp;gt;是该模式中过的一个元素，它是所有Spring配置文件的根元素。&lt;/p&gt;
&lt;h3 id=&quot;声明一个简单的bean&quot;&gt;声明一个简单的&amp;lt;bean&amp;gt;&lt;/h3&gt;
&lt;p&gt;使用spring-beans模式中的另外一个元素：&amp;lt;bean&amp;gt;，该元素类似于JavaConfig中的 @Bean注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean class=&quot;soundsystem.SgtPeppers&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为没有明确的给定ID，所以这个bean会根据全限定类名来进行命名。在本例中bean的ID将会是“soundsystem.SgtPeppers#0”。其中，“#0”是一个计数的形式，用来区别相同类型的其它bean。如果再有一个就是“#1”。&lt;br/&gt;尽管自动话的bean命名方式方便，但是稍引用就会认为自动产生的名字就没有多大的用处了。因此最好的办法还是用id属性，为每个bean设置一个自己的选择的名字：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出XML中不再需要直接负责创建SgtPeppers的实例，在基于JavaConfig的配置中，我们需要自己实例化。当Spring发现这个&amp;lt;bean&amp;gt;元素时，默认调用SgtPeppers默认的构造器来创建bean。&lt;/p&gt;
&lt;h3 id=&quot;借助构造器注入初始化bean&quot;&gt;借助构造器注入初始化bean&lt;/h3&gt;
&lt;p&gt;在Spring XML配置中，只有一种声明bean的方式：使用元素并指定Class属性。在XML中声明ID是，会有多种配置方案，具体到构造器的注入，分为两个基本的配置方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&amp;lt;constructor-arg&amp;gt;元素&lt;/li&gt;
&lt;li&gt;使用spring 3.0所引入的c-命名空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;构造器注入bean引用，现在我们已经声明了compactDisc bean，并且SgtPeppers类实现了compactDisc接口，所以实际上我们已经有了一个可以注入到CDPlayer bean中的bean。我们所需要做的就是在XML中声明CDPlayer并通过ID引用compactDisc：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;CDPlayer&quot;&amp;gt;
    &amp;lt;constructor-arg ref=&quot;compactDisc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为替代的方案，也可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中引入的，它是在XML中更为简洁的描述构造器参数的方式。要使用它的话，需要在XML的顶部声明其模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans”;
  xmlns:c=“http://www.springframework.org/shcema/c&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;;&quot;;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这之后我们就可以它来声明构造器的参数了，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;CDPlayer&quot;&amp;gt;
    &amp;lt;c:cd-ref=&quot;compactDisc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然c-命名空间的方式简练很多。具体看下写法，“c:“表示c-命名空间的前缀，“cd”表示构造器参数名（忘记的可以看下：Spring装配Bean之组件扫描和自动装配），“-ref“表示注入bean引用。&lt;br/&gt;这里的cd直接引用了构造器参数的名称，可以利用参数在整个参数列表中的位置信息作为替代方案实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;CDPlayer&quot;&amp;gt;
    &amp;lt;c:_0-ref=&quot;compactDisc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个c-命名空间表示方法看起来比上面的更加怪异，我们将参数名用“0”表示，也就是参数的索引。因为XML中不允许数字作为第一个字符，所以用下划线作为前缀。使用索引来标识构造器参数感觉比使用名字更好一些，只要保存相同的顺序，就可以随意重命名参数名，如果有多个构造参数，这个方式更有用处。因为现在就一个参数，甚至可以不用标识。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;CDPlayer&quot;&amp;gt;
    &amp;lt;c:_-ref=&quot;compactDisc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将是最怪异的表示方法。&lt;/p&gt;
&lt;h3 id=&quot;将字面量注入到构造器中&quot;&gt;将字面量注入到构造器中&lt;/h3&gt;
&lt;p&gt;前面我们所做的DI通常指的是类型的装配，也就是将对象的引用装配到依赖于它的其它对象中，而有时需要引入的只是一个字面量的配置对象。现在需要创建一个新的CompactDisc实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package soundsystem;

public class BlankDisc implements CompactDisc {

  private String title;
  private String artist;

  public BlankDisc(String title, String artist) {
    this.title = title;
    this.artist = artist;
  }

  public void play() {
    System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SgtPeppers中，参数都是硬编码的，但是这个CompactDisc实现不同，所以XML配置也会不同：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
    &amp;lt;constructor-arg value=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot;/&amp;gt;
     &amp;lt;constructor-arg value=&quot;The Beatles&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次用&amp;lt;constructor-arg&amp;gt;元素进行构造器参数的注入。但是这次我们没有使用“ref”属性，而是使用了value属性，通过该属性表明给定的要以字面量的形式注入到构造器中。&lt;br/&gt;下面用c-命名空间的方式实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
    &amp;lt;c:_title=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot;/&amp;gt;
     &amp;lt;c:_artist=&quot;The Beatles&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，装配字面量与装配引用的区别在于属性名中去掉了“-ref“的后缀。与之类似，用参数索引实现方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
    &amp;lt;c:_0=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot;/&amp;gt;
     &amp;lt;c:_1=&quot;The Beatles&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在装配bean引用和字面量值方面，两种实现方式的功能是相同的。但是有一种情况是&amp;lt;constructor-arg&amp;gt;能够实现，c-命名空间却无法做到。&lt;/p&gt;
&lt;h3 id=&quot;装配集合&quot;&gt;装配集合&lt;/h3&gt;
&lt;p&gt;假设BlankDisc构造函数中新增一个List类型的参数，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package soundsystem;

import java.util.List;

import soundsystem.CompactDisc;

public class BlankDisc implements CompactDisc {

  private String title;
  private String artist;
  private List&amp;lt;String&amp;gt; tracks;

  public BlankDisc(String title, String artist, List&amp;lt;String&amp;gt; tracks) {
    this.title = title;
    this.artist = artist;
    this.tracks = tracks;
  }

  public void play() {
    System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);
    for (String track : tracks) {
      System.out.println(&quot;-Track: &quot; + track);
    }
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在声明bean的时候，我们必须要提前准备一个列表，最简单的方式就是直接设置为null。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
    &amp;lt;constructor-arg value=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot;/&amp;gt;
     &amp;lt;constructor-arg value=&quot;The Beatles”/&amp;gt;
    &amp;lt;constructor-arg&amp;gt;&amp;lt;null/&amp;gt;&amp;lt;constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;null/&amp;gt;元素所做的事情，就是将null作为参数传递到构造器，但这并不是解决问题的办法，虽然在注入器能够正常执行，但是调用play()方法的时候，就会出现异常。&lt;br/&gt;合理的处理方案，我们可以利用元素将其声明为一个列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
  &amp;lt;constructor-arg value=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot; /&amp;gt;
  &amp;lt;constructor-arg value=&quot;The Beatles&quot; /&amp;gt;
  &amp;lt;constructor-arg&amp;gt;
    &amp;lt;list&amp;gt;
      &amp;lt;value&amp;gt;Sgt. Pepper's Lonely Hearts Club Band&amp;lt;/value&amp;gt;
      &amp;lt;value&amp;gt;With a Little Help from My Friends&amp;lt;/value&amp;gt;
      &amp;lt;value&amp;gt;Lucy in the Sky with Diamonds&amp;lt;/value&amp;gt;
      &amp;lt;value&amp;gt;Getting Better&amp;lt;/value&amp;gt;
      &amp;lt;value&amp;gt;Fixing a Hole&amp;lt;/value&amp;gt;
    &amp;lt;/list&amp;gt;
  &amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&amp;lt;list&amp;gt;元素是&amp;lt;constructor-arg&amp;gt;的子元素，这表明一个包含值的列表将会传递到构造器中。其中，&amp;lt;value&amp;gt;表示每个元素。与之类似，我们可以用代替&amp;lt;value&amp;gt;，实现bean引用列表的装配。&lt;br/&gt;在装配集合方面，&amp;lt;constructor-arg&amp;gt;比c-命名空间的属性更具优势，目前使用c-命名空间的方式不能实现装配集合的功能。&lt;/p&gt;
&lt;h3 id=&quot;设置属性&quot;&gt;设置属性&lt;/h3&gt;
&lt;p&gt;前面所有类完全是通过构造器注入的，没有使用属性的Setter方法，下面我们看下使用Spring XML实现属性注入。假设属性注入CDPlayer如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package soundsystem;
import org.springframework.beans.factory.annotation.Autowired;

import soundsystem.CompactDisc;
import soundsystem.MediaPlayer;

public class CDPlayer implements MediaPlayer {
  private CompactDisc compactDisc;

  @Autowired
  public void setCompactDisc(CompactDisc compactDisc) {
    this.compactDisc = compactDisc;
  }

  public void play() {
    compactDisc.play();
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有个需要考虑的问题，到底是构造器注入还是属性注入呢？作为一个通用的规则，对强依赖使用构造依赖，而可选的依赖使用属性注入。之前的BlankDisc属于强依赖，因此构造器注入是正确的方案。不过对于CDPlayer来说，对CompactDisc的依赖不能是强依赖的，因为即便没有把CompactDisc装入进去，CDPlayer依然具有某些功能。因此这样是可行的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsysten.CDPlayer&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建bean的时候不会出现任何的问题，但是CDPlayer开始工作的时候就会出现异常。此时，我们可以注入CDPlayer的compactDisc属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&amp;gt;
  &amp;lt;property name=&quot;compactDisc&quot; ref=&quot;compactDisc&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;property&amp;gt;元素为属性的Setter方法所提供的功能，和&amp;lt;constructor-arg&amp;gt;元素为构造器所提供的功能是一样的。在本例中，它引入了ID为compactDisc的bean（通过ref属性），并将其注入到compactDisc属性中。&lt;br/&gt;同样的Spring为&amp;lt;property&amp;gt;提供了简介的p-命名空间的替代方案。引入p-命名空间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd”&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用p-命名空间，装配compactDisc属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cdPlayer&quot;
        class=&quot;soundsystem.CDPlayer&quot;
        p:compactDisc-ref=&quot;compactDisc&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命名空间中属性所遵循的命名约定与c-命名空间中的属性类似。&lt;/p&gt;
&lt;h3 id=&quot;将字面量注入到属性中&quot;&gt;将字面量注入到属性中&lt;/h3&gt;
&lt;p&gt;属性也可以注入字面量，这与构造器参数非常类似。我们将BlankDisc bean，通过属性注入的方式进行配置，而不是构造器的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package soundsystem;

import java.util.List;

import soundsystem.CompactDisc;

public class BlankDisc implements CompactDisc {

  private String title;
  private String artist;
  private List&amp;lt;String&amp;gt; tracks;

  public void setTitle(String title) {
    this.title = title;
  }

  public void setArtist(String artist) {
    this.artist = artist;
  }

  public void setTracks(List&amp;lt;String&amp;gt; tracks) {
    this.tracks = tracks;
  }

  public void play() {
    System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);
    for (String track : tracks) {
      System.out.println(&quot;-Track: &quot; + track);
    }
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在它不在是强制要求我们装配任何属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;reallyBlankDisc&quot; class=&quot;soundsystem.BlankDisc&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然在装配的时候不设置这些属性，CD播放的时候不能正常播放，所以还是通过&amp;lt;property&amp;gt;元素的value属性实现属性注入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot;
        class=&quot;soundsystem.BlankDisc&quot;&amp;gt;
    &amp;lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot; /&amp;gt;
    &amp;lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&amp;gt;
    &amp;lt;property name=&quot;tracks&quot;&amp;gt;
      &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;Sgt. Pepper's Lonely Hearts Club Band&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;With a Little Help from My Friends&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Lucy in the Sky with Diamonds&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Getting Better&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Fixing a Hole&amp;lt;/value&amp;gt;
      &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出与之前&amp;lt;constructor-arg&amp;gt;元素装配tracks是完全一样的。另一种可选方案是p-命名空间的属性来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;compactDisc&quot;
        class=&quot;soundsystem.BlankDisc&quot;
        p:title=&quot;Sgt. Pepper's Lonely Hearts Club Band&quot;
        p:artist=&quot;The Beatles&quot;&amp;gt;
    &amp;lt;property name=&quot;tracks&quot;&amp;gt;
      &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;Sgt. Pepper's Lonely Hearts Club Band&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;With a Little Help from My Friends&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Lucy in the Sky with Diamonds&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Getting Better&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Fixing a Hole&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;She's Leaving Home&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Being for the Benefit of Mr. Kite!&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Within You Without You&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;When I'm Sixty-Four&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Lovely Rita&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Good Morning Good Morning&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;A Day in the Life&amp;lt;/value&amp;gt;
      &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与c-命名空间一样，装配bean引用与装配字面量的唯一区别在于是否带有“-ref”后缀，同样的p-命名空间也没有实现装配集合的功能。&lt;/p&gt;
&lt;p&gt;转载请注明出处。&lt;br/&gt;作者：wuxiwei&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/wxw16/p/7705219.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/wxw16/p/7705219.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 04:19:00 +0000</pubDate>
<dc:creator>wuxiwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxw16/p/7705219.html</dc:identifier>
</item>
<item>
<title>详解变量声明加 var 和不加 var 的区别 - Raychan</title>
<link>http://www.cnblogs.com/wx1993/p/7709240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wx1993/p/7709240.html</guid>
<description>&lt;p&gt;&lt;span&gt;在全局作用域中声明变量加 var 关键字和不加 var ，js 引擎都会将这个变量声明为全局变量，在实际代码运行时，两种声明方式的变量的行为也几乎是一致的。但是在全局作用域下是否声明一个变量的时候加 var 和不加 var，js 引擎具体执行了哪些操作呢，其效果又是否完全一致？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们看在一个函数体内（局部作用域）声明变量，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明不加 var&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo (a) {
  console.log(a &lt;/span&gt;+ b) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b is not defined&lt;/span&gt;
  b =&lt;span&gt; a
}

foo(&lt;/span&gt;2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【分析】&lt;/strong&gt;执行 foo(2) 的时候，我们具体看 foo 函数，首先打印了 a + b 的值，然后声明了一个 b 变量（没有使用var关键字），并将传入的 a 赋值给 b，&lt;/span&gt;&lt;span&gt;因为 &lt;strong&gt;js 引擎按照代码顺序编译和执行代码&lt;/strong&gt;，因此在打印 a + b 的时候，在任何作用域中都是无法找到 b 变量的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在执行 foo(2) 表达式的时候 js 引擎具体的的操作过程如下：&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在当前作用域中查找名为 foo 的函数(RHS)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进入 foo函数体，&lt;strong&gt;首先 JS 引擎在执行前会对整个脚本文件的声明部分做完整分析（包括局部变量），从而确定变量的作用域。&lt;/strong&gt;因此第一步搜集变量，发现在函数作用域中这里只有作为参数的局部变量 a，&lt;strong&gt;提升到作用域顶部&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将 2 赋值给参数变量 a（a = 2, LHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查找 console 对象（RHS），发现是内置函数，在 console 对象下查找 log 函数（RHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在当前作用域中查找变量 a，并获取 a 的值为（a = 2, RHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在当前作用域中查找变量 b，未找到该变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将 a 和 b 的查找结果传入 console.log() 函数，打印结果（ b 未定义，抛出错误: b is not defined）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;继续执行 b = a。&lt;strong&gt;首先获取变量 a 的值（a = 2, LHS）, 然后在当前作用域中查找变量 b（RHS），未找到，到上一层作用域（全局作用域）中查找（RHS）&lt;/strong&gt;，未找到，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;在全局作用作用域中创建一个名称为 b 的变量，并将其返回给引擎（注意：严格模式下禁止自动或隐式地创建全局变量）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将 a 的值（2）赋值给全局变量 b（ b = a, LHS）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;再看第二个例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明加 var&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo (a) {
  console.log(b) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
  console.log(a + b) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a
}

foo(&lt;/span&gt;2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【分析】执行 foo(2) 的时候，我们看 js 引擎具体做了哪些操作？&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在当前作用域中查找名为 foo 的函数（RHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进入 foo 函数体，&lt;strong&gt;搜集变量，发现声明了局部变量 a 和 b，因此将 a 和 b 提升到函数作用域的顶部（此时 b 的值为 undefined）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;参数赋值，将 2 赋值给变量 a（a = 2, LHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查找 console 对象（RHS），发现是内置函数，在 console 对象下查找 log 函数（RHS）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在当前作用域中查找变量 b（RHS），发现已经声明，但是值为 undefined ，传给log()函数，执行打印，输出结果（b is not defined）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重复第4步 RHS 查找 console.log() 函数，查找变量 a 的值（a = 2, RHS）；查找变量b的值（b = undefined, RHS），将 a 和 b 的值传入 console.log()，执行运算，输出结果(2 + undefined，结果 NaN)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过上述在函数体内声明变量的资历，已经可以看出来 js 引擎在处理这两种情况的区别，在全局作用域中的也是如此，而且理解起来更为简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看两个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(a) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
a = 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;声明变量 a 的时候没有加 var，因此 js 引擎默认将变量 a 声明为全局变量（值为 undefined）并提升到作用域顶部（为什么在console.log() 中可以访问到 a），但是此时的赋值操作需要等到 console.log() 方法执行完之后才会执行，因此在 console.log(a) 打印的结果会是 undefined&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(a) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的输出结果仍旧是 undefined，但是和上面的例子不同的是， js 引擎并没有主动的去创建变量 a，而是直接将变量 a 搜集到全局变量的集合中，并将 a 提升到作用域顶部。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;补充知识点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/maoguiyou/article/details/51736171&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;LHS 和 RHS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yxz-turing/p/4735934.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;全局变量和局部变量&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/caoruiy/p/4418348.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;作用域、作用域链、预解析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.jb51.net/article/55200.htm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;更多变量声明是否加 var 的区别&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 04:04:00 +0000</pubDate>
<dc:creator>Raychan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wx1993/p/7709240.html</dc:identifier>
</item>
<item>
<title>开始Java8之旅（四） --四大函数接口 - 祈求者-</title>
<link>http://www.cnblogs.com/invoker-/p/7709052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/invoker-/p/7709052.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;  Java8中函数接口有很多,大概有几十个吧,具体究竟是多少我也数不清,所以一开始看的时候感觉一脸懵逼,不过其实根本没那么复杂,毕竟不应该也没必要把一个东西设计的很复杂。&lt;/p&gt;
&lt;h2 id=&quot;几个单词&quot;&gt;几个单词&lt;/h2&gt;
&lt;p&gt;  在学习了解之前,希望大家能记住几个单词,掌握这几个单词,什么3，40个官方的函数接口都是小问题了,不信的话接着往下看啦。ok，那这几个单词呢分别是&lt;code&gt;supplier 提供者&lt;/code&gt;,&lt;code&gt;consumer 消费者&lt;/code&gt;,&lt;code&gt;function 函数&lt;/code&gt;,&lt;code&gt;operation 运算符&lt;/code&gt;,&lt;code&gt;binary 二元（就是数学里二元一次方程那个二元,代表2个的意思）,双重的&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  函数接口,你可以理解为对一段行为的抽象,简单点说可以在方法就是将一段行为作为参数进行传递,这个行为呢,可以是一段代码,也可以是一个方法,那你可以想象在java8之前要将一段方法作为参数传递只能通过匿名内部类来实现,而且代码很难看,也很长,函数接口就是对匿名内部类的优化。&lt;br/&gt;  虽然类库中的基本函数接口特别多,但其实总体可以分成四类,就好像阿拉伯数字是无限多的,但总共就10个基本数字一样,理解了这4个,其他的就都明白了。&lt;/p&gt;
&lt;h2 id=&quot;functio接口&quot;&gt;Functio接口&lt;/h2&gt;
&lt;p&gt;   function,顾名思义,函数的意思,这里的函数是指数学上的函数哦,你也可以说是严格函数语言中的函数,例如haskell里的,他接受一个参数,返回一个值,永远都是这样,是一个恒定的,状态不可改变的方法。其实想讲函数这个彻底将明白可以再开一篇博客了,所以这里不详细的说了。&lt;br/&gt;   上面说到,函数接口是对行为的抽象,因此我方便大家理解,就用java中的方法作例子。&lt;/p&gt;
&lt;p&gt;   Fcuntion接口是对接受一个T类型参数,返回R类型的结果的方法的抽象,通过调用apply方法执行内容。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Operation{

&lt;span class=&quot;co&quot;&gt;/* &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    下面这个方法接受一个int类型参数a,返回a+1,符合我上面说的接受一个参数,返回一个值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    所以呢这个方法就符合Function接口的定义,那要怎么用呢,继续看例子 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a){
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;;
}

&lt;span class=&quot;co&quot;&gt;/* &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    该方法第二个参数接受一个function类型的行为,然后调用apply，对a执行这段行为&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;oper&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a, Function&amp;lt;Integer,Integer&amp;gt; action){
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; action.&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;(a);
}

&lt;span class=&quot;co&quot;&gt;/* 下面调用这个oper方法,将addOne方法作为参数传递 */&lt;/span&gt;
pulic &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args){
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; y = &lt;span class=&quot;fu&quot;&gt;oper&lt;/span&gt;(x,x -&amp;gt; &lt;span class=&quot;fu&quot;&gt;addOne&lt;/span&gt;(x));&lt;span class=&quot;co&quot;&gt;//这里可以换成方法引用的写法 int y = oper(x,Operation::addOne)&lt;/span&gt;
    System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;x= &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, y = &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x, y); &lt;span class=&quot;co&quot;&gt;// 打印结果 x=1, y=2&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;/* 当然你也可以使用lambda表达式来表示这段行为,只要保证一个参数,一个返回值就能匹配 */&lt;/span&gt;
     y = &lt;span class=&quot;fu&quot;&gt;oper&lt;/span&gt;(x, x -&amp;gt; x + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; ); &lt;span class=&quot;co&quot;&gt;// y = 4&lt;/span&gt;
     y = &lt;span class=&quot;fu&quot;&gt;oper&lt;/span&gt;(x, x -&amp;gt; x * &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; ); &lt;span class=&quot;co&quot;&gt;// y = 3    &lt;/span&gt;
}

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1132218/201710/1132218-20171022113126068-360024306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的箭头指向的位置就是形参,可以看到第二个箭头的Lambda表达式指向了Funtion接口&lt;/p&gt;
&lt;h2 id=&quot;consumer-接口&quot;&gt;Consumer 接口&lt;/h2&gt;
&lt;p&gt;Consumer 接口翻译过来就是消费者,顾名思义，该接口对应的方法类型为接收一个参数，没有返回值，可以通俗的理解成将这个参数'消费掉了'，一般来说使用Consumer接口往往伴随着一些期望状态的改变或者事件的发生,例如最典型的forEach就是使用的Consumer接口，虽然没有任何的返回值，但是却向控制台输出了语句。&lt;br/&gt;Consumer 使用accept对参数执行行为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        Consumer&amp;lt;String&amp;gt; printString = s -&amp;gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(s);
        printString.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;helloWorld!&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//控制台输出 helloWorld!&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;supplier-接口&quot;&gt;Supplier 接口&lt;/h2&gt;
&lt;p&gt;Supplier 接口翻译过来就是提供者,和上面的消费者相反，该接口对应的方法类型为不接受参数，但是提供一个返回值，通俗的理解为这种接口是无私的奉献者，不仅不要参数，还返回一个值,使用get()方法获得这个返回值&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        Supplier&amp;lt;String&amp;gt; getInstance = () -&amp;gt; &lt;span class=&quot;st&quot;&gt;&quot;HelloWorld!&quot;&lt;/span&gt;;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(getInstance.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;());
        &lt;span class=&quot;co&quot;&gt;// 控偶值台输出 HelloWorld&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;predicate-接口&quot;&gt;Predicate 接口&lt;/h2&gt;
&lt;p&gt;predicate 谓语接口，顾名思义，中文中的‘是’与‘不是’是中文语法的谓语，同样的该接口对应的方法为接收一个参数，返回一个Boolean类型值，多用于判断与过滤，当然你可以把他理解成特殊的Funcation，但是为了便于区分语义，还是单独的划了一个接口，使用test()方法执行这段行为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        Predicate&amp;lt;Integer&amp;gt; predOdd = integer -&amp;gt; integer % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(predOdd.&lt;span class=&quot;fu&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;));
        &lt;span class=&quot;co&quot;&gt;//控制台输出 5&lt;/span&gt;
    }
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;其他的接口&quot;&gt;其他的接口&lt;/h2&gt;
&lt;p&gt;介绍完正面这四种最基本的接口，剩余的接口就可以很容易的理解了，java8中定义了几十种的函数接口，但是剩下的接口都是上面这几种接口的变种，大多为限制参数类型，数量，下面举几个例子。&lt;/p&gt;
&lt;h3 id=&quot;类型限制接口&quot;&gt;类型限制接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;参数类型,例如&lt;code&gt;IntPredicate,LongPredicate, DoublePredicate&lt;/code&gt;，这几个接口，都是在基于Predicate接口的，不同的就是他们的泛型类型分别变成了Integer,Long,Double,&lt;code&gt;IntConsumer,LongConsumer, DoubleConsumer&lt;/code&gt;比如这几个,对应的就是&lt;code&gt;Consumer&amp;lt;Integer&amp;gt;,Consumer&amp;lt;Long&amp;gt;,Consumer&amp;lt;Double&amp;gt;&lt;/code&gt;,其余的是一样的道理，就不再举例子了&lt;/li&gt;
&lt;li&gt;返回值类型，和上面类似，只是命名的规则上多了一个To,例如&lt;code&gt;IntToDoubleFunction,IntToLongFunction,&lt;/code&gt; 很明显就是对应的&lt;code&gt;Funtion&amp;lt;Integer,Double&amp;gt;&lt;/code&gt; 与&lt;code&gt;Fcuntion&amp;lt;Integer,Long&amp;gt;&lt;/code&gt;，其余同理，另外需要注意的是，参数限制与返回值限制的命名唯一不同就是To,简单来说,前面不带To的都是参数类型限制,带To的是返回值类型限制，对于没有参数的函数接口，那显而易见只可能是对返回值作限制。例如&lt;code&gt;LongFunction&amp;lt;R&amp;gt;&lt;/code&gt;就相当于&lt;code&gt;Function&amp;lt;Long,R&amp;gt;&lt;/code&gt; 而多了一个To的&lt;code&gt;ToLongFunction&amp;lt;T&amp;gt;&lt;/code&gt;就相当于&lt;code&gt;Function&amp;lt;T,Long&amp;gt;&lt;/code&gt;，也就是对返回值类型作了限制。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;数量限制接口&quot;&gt;数量限制接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;有些接口需要接受两名参数,此类接口的所有名字前面都是附加上Bi,是&lt;code&gt;Binary&lt;/code&gt;的缩写，开头也介绍过这个单词了，是二元的意思，例如&lt;code&gt;BiPredicate,BiFcuntion&lt;/code&gt;等等,而由于java没有多返回值的设定，所以Bi指的都是参数为两个&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;operator接口&quot;&gt;Operator接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;此类接口只有2个分别是&lt;code&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/code&gt; 一元操作符接口,与&lt;code&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/code&gt;二元操作符接口，这类接口属于Function接口的简写，他们只有一个泛型参数，意思是Funtion的参数与返回值类型相同,一般多用于操作计算，计算 a + b的BiFcuntion如果限制条件为Integer的话 往往要这么写&lt;code&gt;BiFunction&amp;lt;Integer,Integer,Integer&amp;gt;&lt;/code&gt; 前2个泛型代表参数，最后一个代表返回值，看起来似乎是有点繁重了,这个时候就可以用&lt;code&gt;BinaryOperator&amp;lt;Integer&amp;gt;&lt;/code&gt;来代替了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是各种类型的接口的示意图，相信只要真正理解了，其实问题并不大&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1132218/201710/1132218-20171022113528209-533855154.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java8中的lambda表达式,并不是完全闭包，lambda表达式对值封闭，不对变量封闭。简单点来说就是局部变量在lambda表达式中如果要使用，必须是声明final类型或者是隐式的final例如&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt;;
Consumer&amp;lt;Integer&amp;gt; print = () -&amp;gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(num);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是可以的,虽然num没有被声明为final，但从整体来看，他和final类型的变量的表现是一致的，可如果是这样的代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt;;
num ++;
Consumer&amp;lt;Integer&amp;gt; print = () -&amp;gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(num);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则无法通过编译器，这就是对值封闭(也就是栈上的变量封闭)&lt;br/&gt;如果上文中的num是实例变量或者是静态变量就没有这个限制。&lt;br/&gt;看到这里，自然而然就会有疑问为什么会这样？或者说为什么要这么设计。理由有很多，例如函数的不变性，线程安全等等等，这里我给一个简单的说明&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么局部变量会有限制而静态变量和全局变量就没有限制，因为局部变量是保存在栈上的，而众所周知，栈上的变量都隐式的表现了它们仅限于它们所在的线程，而静态变量与实例变量是保存在静态区与堆中的，而这两块区域是线程共享的，所以访问并没有问题。&lt;/li&gt;
&lt;li&gt;现在我们假设如果lambda表达式可以局部变量的情况，实例变量存储在堆中，局部变量存储在栈上，而lambda表达式是在另外一个线程中使用的，那么在访问局部变量的时候，因为线程不共享，因此lambda可能会在分配该变量的线程将这个变量收回之后，去访问该变量。所以说，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了。&lt;/li&gt;
&lt;li&gt;严格保证这种限制会让你的代码变得无比安全，如果你学习或了解过一些经典的函数式语言的话，就会知道不变性的重要性，这也是为什么stream流可以十分方便的改成并行流的重要原因之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇介绍了四大函数接口和他们引申出的各类接口，终点是对不同种类行为的封装导致了设计出不同的函数接口，另外在使用函数接口或者lambda表达式的时候，要注意lambda对值封闭这个特性。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Oct 2017 03:53:00 +0000</pubDate>
<dc:creator>祈求者-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/invoker-/p/7709052.html</dc:identifier>
</item>
<item>
<title>jemalloc 快速上手攻略 - 喜欢兰花山丘</title>
<link>http://www.cnblogs.com/life2refuel/p/7706253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/life2refuel/p/7706253.html</guid>
<description>&lt;p&gt;&lt;strong&gt;引言 - 赠送个 Cygwin (加精)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Cygwin&lt;/strong&gt; 有它存在的合理性. 至少比 wine 好太多了. 它主要功能是在winds上面简易的模拟出linux环境, 比虚拟机&lt;/p&gt;
&lt;p&gt;轻量一点点. 坑也不少, 难卸载, api模拟也只是粗模拟, 对于linux系统级别很多api使用不一致. 当然及其适合刚开始学&lt;/p&gt;
&lt;p&gt;习linux开发同学尝试. linux 搞多了, 可能还真不一定比 winds 好. 否则也不会那么多程序员用起了 Mac X.&lt;/p&gt;
&lt;p&gt;　　作为一名开发者, 语言层面可有鄙视链. 系统层面最好少点. 很容易被打脸. 切身体会. 每一个经历历史存活的&lt;/p&gt;
&lt;p&gt;系统都是无数顶级门派, 大佬的逆天武学. 学的其一都能逆天 ~~~&lt;/p&gt;
&lt;p&gt;　　搞回正题. 首先看下面两个链接.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Cygwin :&lt;/strong&gt; &lt;a title=&quot;http://www.cygwin.com/&quot; href=&quot;http://www.cygwin.com/&quot; target=&quot;_blank&quot;&gt;http://www.cygwin.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;apt-cyg :&lt;/strong&gt; &lt;a title=&quot;https://github.com/transcode-open/apt-cyg&quot; href=&quot;https://github.com/transcode-open/apt-cyg&quot; target=&quot;_blank&quot;&gt;https://github.com/transcode-open/apt-cyg&lt;/a&gt;　　&lt;/p&gt;
&lt;p&gt;　　第一个是软件实体, 下载下来能装x64就装x64. 第二个是 Cygwin 中 等同于 Ubuntu 中 apt-get, Centos中 yum...&lt;/p&gt;

&lt;p&gt;　　Cygwin 安装过程注意点分享.&lt;/p&gt;
&lt;p&gt;　　　　1. 过程中需要选择下载源, 默认第一个试试, 不行就挨个换换.&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171021210742427-1007000198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我这里选择了第一个也是有源的. 这个图片之前会让我们设置软件安装位置, 包的下载位置.&lt;/p&gt;
&lt;p&gt;　　　　经验: 软件安装位置不要放在系统C盘. 我学生阶段默认安装到C盘. 后面就winds原生程序控制不了C盘了.&lt;/p&gt;
&lt;p&gt;　　　　包下载位置和 setup-x86_64.exe 按照包同一级别最好&lt;/p&gt;
&lt;p&gt;　　　　Cygwin 软件目录&lt;/p&gt;
&lt;p&gt;　　　　| -&amp;gt; xxxx 这个位置&lt;/p&gt;
&lt;p&gt;　　　　| -&amp;gt; setup-x86_64.exe&lt;/p&gt;
&lt;p&gt;　　　　2. 点击下一步进入包的选择过程, &lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171021211139865-1251520656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这个步骤选择你所有感兴趣的包. 例如 gcc new version , gdb, autoconf, autogen, gawk, grep, sed, unzip, tar 当然还有 vim ....&lt;/p&gt;
&lt;p&gt;　　　　3. 随后下载安装等待个30-1h 就安装好了. 在桌面上面打开就ok! &lt;/p&gt;
&lt;p&gt;　　　　　　开始我们的享受 ~~~  &lt;/p&gt;
&lt;p&gt;　　　　　　假如你想再按照其它插件, 继续点击第一步下载下来的 setup-x86_64.exe 继续进行上面的第二步操作. &lt;/p&gt;
&lt;p&gt;　　　　4. 扩展操作, 没有 apt-get 总是不爽, 我们为我们的Cygwin 安装个&lt;/p&gt;
&lt;p&gt;　　　　　　这里用的是  &lt;strong&gt;apt-cyg &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd
&lt;/span&gt;&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/transcode-open/apt-cyg/archive/master.zip&lt;/span&gt;
&lt;span&gt;unzip&lt;/span&gt; master.&lt;span&gt;zip&lt;/span&gt;
&lt;span&gt;rm&lt;/span&gt; -rf master.&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;
cd apt&lt;/span&gt;-cyg-&lt;span&gt;master
&lt;/span&gt;&lt;span&gt;install&lt;/span&gt; apt-cyg /&lt;span&gt;bin

# hello world apt&lt;/span&gt;-&lt;span&gt;cyg
apt&lt;/span&gt;-cyg --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　恭喜我们到这里基本搞定了 Cygwin 环境.  以后单纯在配置低的硬件下面学习再也不求人了. &lt;/p&gt;
&lt;p&gt;　　扯一点, 假如高校需要教学生linux使用. 单纯的纯linux环境其实不一定太好. 因为费时费力, 进入核心还很麻烦. 因为linux版本&lt;/p&gt;
&lt;p&gt;　　也很多. 倒不如直接进入一个好的模拟开发模块, 忽略版本. 那么实战开发中也难以纯linux办公. 缺的有点多 ~~ o(╥﹏╥)o &lt;/p&gt;
&lt;p&gt;　　当然 - 真的 - 能学习Linux 真的很幸运. 程序开发中最美的结晶, 自由女神的象征 ~_~ &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言 - jemalloc 搞起来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　jemalloc 的介绍部分可以参照, 魅族CTO大佬的博客.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;技术专辑：内存管理&lt;/strong&gt; : &lt;a title=&quot;http://tinylab.org/memory-management-album-1/&quot; href=&quot;http://tinylab.org/memory-management-album-1/&quot; target=&quot;_blank&quot;&gt;http://tinylab.org/memory-management-album-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　我们这里只是科普实战篇, 如何在项目中跑起来. jemalloc 传说中最强最前沿的内存分配模型. &lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;jemalloc github&lt;/strong&gt; : &lt;a title=&quot;https://github.com/jemalloc/jemalloc/&quot; href=&quot;https://github.com/jemalloc/jemalloc/&quot; target=&quot;_blank&quot;&gt;https://github.com/jemalloc/jemalloc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　源码全部在上面我们找到release发布版本, 找个最新的下载下来. 随后编译使用了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;winds 跑起来 &amp;lt;- &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先看下面 jemalloc 中内嵌的说明 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
How to build jemalloc &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Windows
&lt;/span&gt;=================================

&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. Install Cygwin with at least the following packages:
   &lt;/span&gt;*&lt;span&gt; autoconf
   &lt;/span&gt;*&lt;span&gt; autogen
   &lt;/span&gt;*&lt;span&gt; gawk
   &lt;/span&gt;*&lt;span&gt; grep
   &lt;/span&gt;*&lt;span&gt; sed

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. Install Visual Studio &lt;span&gt;2015&lt;/span&gt; with Visual C++

&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. Add Cygwin\bin to the PATH environment variable

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;. Open &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VS2015 x86 Native Tools Command Prompt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
   (note: x86&lt;/span&gt;/x64 doesn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t matter at this point)&lt;/span&gt;

&lt;span&gt;5&lt;/span&gt;&lt;span&gt;. Generate header files:
   sh &lt;/span&gt;-c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CC=cl ./autogen.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;6&lt;/span&gt;. Now the project can be opened and built &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Visual Studio:
   msvc\jemalloc_vc2015.sln&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过引言, 我们安装好了 Cygwin. 后面都是人话. 我们都懂. 直接进入第6步&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171021215414443-1512539749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我这里采用 Best New CL 2017 编译 static 静态库的发布版本. 默认x64位. &lt;/p&gt;
&lt;p&gt;　　扯一点题外话, 服务器开发尽量用静态库. 动态库部署调试安全都不太好. &lt;strong&gt;通过才学会爱 ~ &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　编译成功后, 找出来我们生成的内容. 例如我这里是 jemalloc-vc141-Release-static.lib 和自己找出来的 include&lt;/p&gt;
&lt;p&gt;　　需要注意的是 记住将 strings.h 也添加进来. &lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171021231627396-1841927279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　 核心, jemalloc 部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　 a) 添加包含目录&lt;/p&gt;
&lt;p&gt;　     项目右击 -&amp;gt; [属性] -&amp;gt; [VC++ 目录] -&amp;gt; [包含目录]&lt;/p&gt;
&lt;p&gt;　     $(ProjectDir)&lt;/p&gt;

&lt;p&gt;     b) 添加引用库&lt;/p&gt;
&lt;p&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [VC++ 目录] -&amp;gt; [库目录]&lt;/p&gt;
&lt;p&gt;　　 $(ProjectDir)&lt;/p&gt;
&lt;p&gt;　　&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [链接器] -&amp;gt; [输入]&lt;/p&gt;
&lt;p&gt;        jemalloc-vc141-Release-static.lib&lt;/p&gt;

&lt;p&gt;　c)  添加预编译处理器　　&lt;/p&gt;
&lt;p&gt;　　 项目右击 -&amp;gt; [属性] -&amp;gt; [C/C++]-&amp;gt; [预处理器] -&amp;gt; [预处理器定义]&lt;/p&gt;
&lt;p&gt;        JEMALLOC_EXPORT=&lt;br/&gt;        JEMALLOC_STATIC&lt;/p&gt;

&lt;p&gt;　 d 一些编译警告处理&lt;/p&gt;
&lt;p&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [C/C++] -&amp;gt; [常规] -&amp;gt; [调试信息格式] -&amp;gt; [程序数据库 (/Zi)]&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [C/C++] -&amp;gt; [高级] -&amp;gt; [编译为] -&amp;gt; [编译为C代码/TC]&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [C/C++] -&amp;gt; [代码生成] -&amp;gt; [运行库] -&amp;gt; [多线程/MT]&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [链接器] -&amp;gt; [常规] -&amp;gt; [启用增量链接] -&amp;gt; [否 (/INCREMENTAL:NO)]&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [链接器] -&amp;gt; [系统] -&amp;gt; [子系统] -&amp;gt; [控制台]&lt;br/&gt;        项目右击 -&amp;gt; [属性] -&amp;gt; [链接器] -&amp;gt; [命令行] -&amp;gt; /LTCG&lt;/p&gt;
&lt;p&gt;        [Release]&lt;br/&gt;        - [控制台]&lt;br/&gt;        | [否 (/INCREMENTAL:NO)]&lt;br/&gt;        | [程序数据库 (/Zi)]&lt;/p&gt;

&lt;p&gt;　　其中备注一下, + 表示添加, - 表示减少, | 表示保持不变不用动. &lt;/p&gt;

&lt;p&gt;　　到这里winds上面前戏真的做足了!!! 我们搞个下面代码测试一下 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;jemalloc/jemalloc.h&amp;gt;

&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试 jemalloc hello world
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[]) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * piyo = je_malloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; piyo) {
        puts(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;je_malloc sizeof int is error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_FAILURE;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;piyo = %p, %d.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, piyo, *&lt;span&gt;piyo);
    je_free(piyo);

    piyo &lt;/span&gt;= je_calloc(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; piyo) {
        puts(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;je_calloc is error!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_FAILURE;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;piyo = %p, %d.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, piyo, *&lt;span&gt;piyo);

    piyo &lt;/span&gt;= je_realloc(piyo, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; piyo) {
        puts(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;je_realloc is error!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_FAILURE;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;piyo = %p, %d.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, piyo, *&lt;span&gt;piyo);
    je_free(piyo);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_SUCCESS;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　系统啪啪啪的奔跑起来了 ~&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171021233847099-44308586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;linux 部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我这里采用的Ubuntu环境跑上面 main.c &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd ~/桌面&lt;br/&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/jemalloc/jemalloc/releases/download/5.0.1/jemalloc-5.0.1.tar.bz2&lt;/span&gt;
tar -jxvf jemalloc-5.0.1.tar.bz2&lt;span&gt;
cd jemalloc&lt;/span&gt;-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;1&lt;br/&gt;sudo apt-get install autogen autoconf&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
./autogen.sh&lt;br/&gt;&lt;/span&gt;&lt;span&gt;make&lt;/span&gt; -&lt;span&gt;j2
sudo &lt;/span&gt;&lt;span&gt;make&lt;/span&gt; &lt;span&gt;install&lt;br/&gt;sudo ldconfig&lt;br/&gt;rm -rf jemalloc-5.0.1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意安装 jemalloc 不要放在共享目录中. 例如可以放在桌面上. 因为安装过程中需要建立&lt;/p&gt;
&lt;p&gt; ln -sf libjemalloc.so.2 lib/libjemalloc.so&lt;/p&gt;
&lt;p&gt;软链在共享目录的分区情况下会出问题(因为我的Ubuntu 是在 VMWare 中, 共享目录无法软链). &lt;/p&gt;
&lt;p&gt;　　那我们开始编译搞起 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gcc&lt;/span&gt; -g -Wall -o main.out main.c -ljemalloc -DJEMALLOC_NO_DEMANGLE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171022004446834-1923802580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里关于jemalloc的部署开发环境就已经搭建完毕. &lt;/p&gt;
&lt;p&gt;　　当然了, 如果配置已经很ok. 可以不用加 -ljemalloc 因为已经在系统路径下面可以找见.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正文 - 实际中包装 jemalloc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　jemalloc 库核心在于替换c runtime lib 的malloc. 为性能要求高的程序引入一层内存池加速和内存碎片的优化.&lt;/p&gt;
&lt;p&gt;　　在实际项目开发中还需要封装一层. 请收看我下面的封装模块 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stdext.h &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:false;&quot;&gt;
#ifndef _H_STDEXIT
#define _H_STDEXIT

/*
 stdxxx.h 扩展库

 主要功能 : 扩展内存分配

 */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;

//
// free_ext - free 包装函数
// ptr      : 通过下面函数分配的内存, 必须通过这个函数销毁
// return   : void
//
extern void free_ext(void * ptr);

//
// malloc_ext - malloc 包装, 封装一些业务特性代码
// size     : 分配的内存字节
// return   : 返回可使用的内存地址.
//
extern void * malloc_ext(size_t size);

//
// calloc_ext - calloc 包装, 封装一些特殊业务
// num      : 数量
// size     : 大小
// return   : 返回可用内存地址, 并且置0
//
extern void * calloc_ext(size_t num, size_t size);

//
// realloc_ext - realoc 包装函数, 封装一些特殊业务
// ptr      : 重新分配的内存首地址, NULL 等同于 malloc
// size     : 重新分配的内存大小
// return   : 返回重新分配好的新地址内容
//
extern void * realloc_ext(void * ptr, size_t size);

//
// 开启全局配置 free / malloc 功能
//
#if !defined(_NO_STDEXT_)

#   undef  free
#   undef  malloc
#   undef  calloc
#   undef  realloc

#   define free    free_ext
#   define malloc  malloc_ext
#   define calloc  calloc_ext
#   define realloc realloc_ext

#endif

#endif//_H_STDEXIT&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;系统级别的小包装,在需要的地方直接引入 #include &amp;lt;stdext.h&amp;gt; 其它代码还是 malloc free那样保持不变, 就使用起来了, 很方便.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stdext.c&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现层面非常粗暴, 没有引入内存cookie机制. 直接采用默认 Release new / delete 方式. 很直接很方便~ &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;jemalloc/jemalloc.h&amp;gt;

//
// 编译导入
// gcc -I./structc/system 编译链接不了 -ljemalloc
//
#define _NO_STDEXT_
#include &quot;stdext.h&quot;

//
// free_ext - free 包装函数
// ptr      : 通过下面函数分配的内存, 必须通过这个函数销毁
// return   : void
//
inline void 
free_ext(void * ptr) {
    je_free(ptr);
}

// 简单错误信息打印
static inline void _ext(void * ptr, size_t size) {
    fprintf(stderr, &quot;alloc error ptr = %p, size = %zu!\n&quot;, ptr, size);
    fflush(stderr);
    abort();
}

//
// malloc_ext - malloc 包装, 封装一些业务特性代码
// size     : 分配的内存字节
// return   : 返回可使用的内存地址.
//
inline void * 
malloc_ext(size_t size) {
    void * ptr = je_malloc(size);
    if (NULL == ptr)
        _ext(ptr, size);
    return ptr;
}

//
// calloc_ext - calloc 包装, 封装一些特殊业务
// num      : 数量
// size     : 大小
// return   : 返回可用内存地址, 并且置0
//
inline void * 
calloc_ext(size_t num, size_t size) {
    void * ptr = je_calloc(num, size);
    if (NULL == ptr)
        _ext(ptr, num * size);
    return ptr;
}

//
// realloc_ext - realoc 包装函数, 封装一些特殊业务
// ptr      : 重新分配的内存首地址, NULL 等同于 malloc
// size     : 重新分配的内存大小
// return   : 返回重新分配好的新地址内容
//
inline void * 
realloc_ext(void * ptr, size_t size) {
    void * nptr = je_realloc(ptr, size);
    if (NULL == nptr) {
        je_free(ptr);   // 可有可无, 内存模块已经是未定义行为的边缘了
        _ext(ptr, size);   
    }
    return ptr;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意一下. 上面所有代码至少保证了 winds, linux 使用正常.  而在linux gcc 环境有个坑就是.&lt;/p&gt;
&lt;p&gt;单纯的用 gcc -I 导入头文件目录. 会诱发生成的stdext.o 没有引入 jemalloc 相关指向代码. &lt;/p&gt;
&lt;p&gt;我的解决方案是重新编译, 去掉编译的 -I当前stdext.c 所在目录, 为stdext.o重新来一个.&lt;/p&gt;
&lt;p&gt;　　更加核心的可以看这个项目, 一个围绕 c 数据结构搭建一套基础项目架构, 内嵌了jemalloc跨平台使用的细节部分.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;structc&lt;/strong&gt; : &lt;a title=&quot;https://github.com/wangzhione/structc&quot; href=&quot;https://github.com/wangzhione/structc&quot; target=&quot;_blank&quot;&gt;https://github.com/wangzhione/structc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　到这里关于 jemalloc 完全攻略已经完毕. 扫盲基本 Over ~_~  　　　　 　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记 - 跑pc性能服务必备吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　错误是难免的欢迎指正. 修改 :)&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;http://music.163.com/#/m/song?id=65642&amp;amp;userid=16529894&quot; href=&quot;http://music.163.com/#/m/song?id=65642&amp;amp;userid=16529894&quot; target=&quot;_blank&quot;&gt;一生何求 : &lt;/a&gt;http://music.163.com/#/m/song?id=65642&amp;amp;userid=16529894&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/532523/201710/532523-20171022112845896-803566910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Oct 2017 03:36:00 +0000</pubDate>
<dc:creator>喜欢兰花山丘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/life2refuel/p/7706253.html</dc:identifier>
</item>
</channel>
</rss>