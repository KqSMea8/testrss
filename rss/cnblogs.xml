<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用VS Code开发asp.net core (下) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8450409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8450409.html</guid>
<description>&lt;p&gt;第一部分: &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/8450179.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/8450179.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是基于Windows10的.&lt;/p&gt;
&lt;h2&gt;Debugging javascript&lt;/h2&gt;
&lt;p&gt;打开wwwroot/js/site.js, 写一段简单的js代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($) {
    $(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;'#myButton').on('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            alert(&lt;/span&gt;'Hello world!'&lt;span&gt;);
        });
    });
})(jQuery);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193456827-368357743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以设置断点, 但是由于整个项目是用于服务器端的. 而js文件是用于客户端开发的, 我们需要一种方法来调试js文件.&lt;/p&gt;
&lt;p&gt;这里我们就需要安装一个扩展: Chrome Debugger.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193728968-1753704114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开launch.json, 可以直接打开文件, 也可以如下图方式打开:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216193834609-1448054966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右下角的Add Configuration:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216194008624-1259862840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改配置的端口和目录:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&quot;configurations&quot;&lt;span&gt;: [
        {
            &lt;/span&gt;&quot;type&quot;: &quot;chrome&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;request&quot;: &quot;launch&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;name&quot;: &quot;Launch Chrome&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;url&quot;: &quot;http://localhost:&lt;span&gt;5000&lt;/span&gt;&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;webRoot&quot;: &quot;${workspaceFolder}&lt;span&gt;/wwwroot&lt;/span&gt;&quot;&lt;span&gt;
        },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在About.cshtml里面添加一个button:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myButton&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;My Button&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Debugger中运行Launch Chome:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195156406-286329980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行后, 弹出浏览器, 但是页面无法显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195412156-1918072500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为Chrome Debugger仅仅运行客户端的代码. 而服务器段的代码买有运行.&lt;/p&gt;
&lt;p&gt;所以还需要在另外的命令行执行dotnet run命令.&lt;/p&gt;
&lt;p&gt;然后再次运行Chrome Launch. 这次运行成功了&lt;/p&gt;
&lt;p&gt;点击About页面的My Button, 断点并没有响应. 切换到代码页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195815718-1641836304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到断点被灰掉了, 这是因为debugger并未找到这段代码.&lt;/p&gt;
&lt;p&gt;这是因为dotnet run运行的是Production环境:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216195920374-1357235543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而看下代码_Layout.cshtml:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216200024234-629318560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序只有在Development环境下才会包含site.js.&lt;/p&gt;
&lt;p&gt;这时可以打开bundleconfig.json, 把sourceMap属性设置成true. 并且安装这个包: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet add package BuildBundlerMinifier
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行dotnet clean 和 dotnet build&lt;/p&gt;
&lt;p&gt;这是一种办法, 但是我更想直接调试site.js, 所以可以在命令行设置一下临时的环境变量:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
set ASPNETCORE_ENVIRONMENT=Development
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行dotnet run.&lt;/p&gt;
&lt;p&gt;这时刷新后再点击按钮, 就可以触发断点了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216200811093-1150378998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外还可以使用浏览器自带的debugger.&lt;/p&gt;
&lt;h2&gt;Debug Typescript&lt;/h2&gt;
&lt;p&gt;在wwwroot/js里面添加test.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Test {
    constructor(private msg: string) {

    }
    show() {
        alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要为项目配置一下Typescript:&lt;/p&gt;
&lt;p&gt;建立一个tsconfig.json文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;compileOnSave&quot;: true,
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;es5&quot;,
        &quot;sourceMap&quot;: true,
        &quot;module&quot;: &quot;commonjs&quot;
    },
    &quot;include&quot;: [
        &quot;wwwroot/js/*.ts&quot;
    ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候, ts文件还不能编译, 因为typescript还没有被安装. 也就是说tsc命令还不能用.&lt;/p&gt;
&lt;p&gt;所以需要安装typescript:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install typescript -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时在项目目录执行tsc命令就可以生成js文件了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216203034218-503828171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是, 如果更改了test.ts文件, 保存后. 并没有生成新的js文件. 这是因为在保存的时候vscode不知道应该做什么.&lt;/p&gt;
&lt;p&gt;可以在项目build之前进行tsc这个命令, 所以修改csproj文件, 添加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Target &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;PrecompileScript&quot;&lt;/span&gt;&lt;span&gt; BeforeTargets&lt;/span&gt;&lt;span&gt;=&quot;BeforeBuild&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Exec &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;tsc&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行dotnet build, 就可以看到生成了新的test.js文件.&lt;/p&gt;

&lt;p&gt;针对sqlite, 没有太好的办法, 到&lt;a href=&quot;http://sqlite.org/download.html&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;下载工具, 使用命令行sqlite3.&lt;/p&gt;
&lt;p&gt;针对sqlserver, 需要安装一个mssql扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205254734-1805030111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我本机有一个localdb实例的数据库.&lt;/p&gt;
&lt;p&gt;在项目建立一个test.sql文件, 打开文件后会自动安装sql tools service:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205447140-741866174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择连接字符串, MSSQL Connect:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205621593-719995259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为现在还没有建立任何连接字符串, 所以这时它会让你建立一个:&lt;/p&gt;
&lt;p&gt;首先输入Server Name:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205835687-1877059535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入数据库名:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216205926609-423429386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择登陆方式, 我选择integrated:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210016124-379047259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后输入这个档案的名字: SalesDB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210132077-1103503235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确定后, VSCode就会开始尝试连接该数据库, 成功后会有提示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216210905749-466402249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vscode右下角状态栏也会有显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211009640-511833025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时再写sql语句就会有智能提示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211118124-283708197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后执行这个sql语句: 可以先看看有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211226359-1864401161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+Shift+E是执行sql语句的命令. 执行后的结果如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211321218-1459183885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面所配置的Sql连接字符串实际上是保存在了UserSettings里面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216211541343-1834815707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于mysql和postgresql等, 需要安装vscode-database这个扩展. 这里就先不介绍了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建新文件: Advanced New File 扩展 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搜索并安装advanced new file扩展, 这两个哪个都行. 我安装的是带横线的那个:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064552249-73463435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Command Palette可以看到创建新文件的快捷键是Ctrl+Alt+N.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064810859-1837207768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择相对的路径:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217064923718-23430551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择后输入文件名即可, 这时可以带着目录结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065136906-887487233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果目录结构中的目录不存在, 那么它也会自动被创建. 点击Enter就会创建新文件个所需的目录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先安装ESLint:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065554843-311830478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你没有安装eslint库的话还需要通过npm来进行全局安装:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g eslint
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要添加一个eslint的配置文件, 选择Create .eslintrc.json文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217065738968-1632724647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的文件如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070147656-481765981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就可以看到eslint扩展起作用了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070101077-907243182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体ESLint的内容, 请查看官方文档.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TSLint扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装tslint扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070346593-42591807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过npm安装tslint:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g tslint
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下tslint有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070520765-892671292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择创建tslint.json文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070610124-289826690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找一个ts文件试一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070641624-428784628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tslint也起作用了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bower扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装Bower扩展&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070801421-1178060497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好后, 在Command Palette中输入并选择Bower命令会出下如下选项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217070959046-1311346493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你使用bower, 那么这里的命令你应该比较熟悉.&lt;/p&gt;
&lt;p&gt;这里比较有用的一个命令是Bower Search and Install. 选择后, 搜索一个包例如 underscore:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217071209062-1634829686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Install as Dependency:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217071246593-1829667972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后, 该包会出现在bower.json文件中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML格式化扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vscode在不安装扩展的情况下xml文件是无法被自动格式化的.&lt;/p&gt;
&lt;p&gt;可以安装扩展Xml Tools:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217072409171-1429528481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后, 查看它都有哪些命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217072547171-501675231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, 如果想格式化xml文件, 直接使用vscode默认的格式化文件命令(Shift+Alt+F)即可, 它会按照项目的配置进行格式化.&lt;/p&gt;
&lt;p&gt;其他类型的文件如果需要格式化, 可以在扩展市场搜索安装, 自行研究一下即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest Client扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装Rest Client扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073439109-1754178008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后创建一个文件, 例如叫 httptest, 之后选择该文件的language mode:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073555937-1393801892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Http:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073625796-204070443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在文件中写一个http的地址:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073700874-1788415790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写完http地址后, 在地址的上方会出现一个链接: Send Request, 点击这个链接, 就会发送请求, 请求响应后, 在右侧可以看到返回的结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217073756484-1544823136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里还可以添加请求的各种参数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217074031093-480907570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求的结果可以保存到文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180217074346796-1257451852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样这里可以发送 POST, PUT, DELETE等请求.&lt;/p&gt;

&lt;p&gt;VSCode的扩展太多了, 可以选择Poppular Extensions或者Recommend Extensions去安装并研究一下.&lt;/p&gt;
&lt;p&gt;这个文章就写这些了, 谢谢&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 23:45:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8450409.html</dc:identifier>
</item>
<item>
<title>client / page / offset / screen X / Y - ITBoy-Men</title>
<link>http://www.cnblogs.com/DB-IT/p/8451301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DB-IT/p/8451301.html</guid>
<description>&lt;p&gt;1.clientX / clientY&lt;/p&gt;
&lt;p&gt;　　相对于可视窗口左上角，不包括菜单栏与滚动条&lt;/p&gt;
&lt;p&gt;2.pageX / pageY&lt;/p&gt;
&lt;p&gt;　　相对于网页左上角，不包括菜单栏，包括滚动条&lt;/p&gt;
&lt;p&gt;3.offsetX / offsetY&lt;/p&gt;
&lt;p&gt;　　IE特有！&lt;/p&gt;
&lt;p&gt;　　以元素盒子模型的内容区域的左上角为参考点,如果有boder,可能出现负值。&lt;/p&gt;
&lt;p&gt;4.screenX / screenY&lt;/p&gt;
&lt;p&gt;　　相对于屏幕左上角&lt;/p&gt;

&lt;p&gt;pageX和clientX ,这个两个比较容易搞混,&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pageX:与滚动条移动有关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;clientX:与滚动条移动无关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1334180/201802/1334180-20180216233723327-1049562109.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 15:43:00 +0000</pubDate>
<dc:creator>ITBoy-Men</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DB-IT/p/8451301.html</dc:identifier>
</item>
<item>
<title>树莓派小车（二）树莓派、小车和红外线模块连接（多图） - 李汉祥</title>
<link>http://www.cnblogs.com/lihanxiang/p/8451299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihanxiang/p/8451299.html</guid>
<description>&lt;h3 id=&quot;正文之前&quot;&gt;正文之前&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上一篇文章介绍了小车底盘以及驱动板的安装，这一次来讲一讲树莓派与驱动板以及红外线模块的安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;h4 id=&quot;树莓派的gpio引脚定义&quot;&gt;1. 树莓派的GPIO引脚定义：&lt;/h4&gt;
&lt;p&gt;树莓派的GPIO引脚共分为两种类型，一种是PHYSICAL NUMBERING&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-97eb8f7e9277fedc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PHYSICAL NUMBERING&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单纯地用从下至上，从左至右的顺序来定义引脚。&lt;/p&gt;
&lt;p&gt;在我们的小车中：&lt;/p&gt;
&lt;p&gt;黄色的GPIO接口连接L298N驱动板以及其他模块如红外线模块等等，&lt;/p&gt;
&lt;p&gt;黑色的Ground接口连接红外线模块上的GND接口，&lt;/p&gt;
&lt;p&gt;红色的5V供电接口连接L298N驱动板上的+5V接口。&lt;/p&gt;
&lt;p&gt;另外一种引脚定义方式是GPIO NUMBERING&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-80416d6b4bae1e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;GPIO NUMBERING&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用特殊（未知）的方式来标记GPIO接口&lt;/p&gt;
&lt;p&gt;黄色的GPIO接口连接L298N驱动板以及其他模块如红外线模块等等，&lt;/p&gt;
&lt;p&gt;黑色的Ground接口连接红外线模块上的GND接口，&lt;/p&gt;
&lt;p&gt;红色的5V供电接口连接L298N驱动板上的+5V接口。&lt;/p&gt;
&lt;p&gt;我采用的是&lt;strong&gt;第二种&lt;/strong&gt;，关于如何设置哪一种类型以及编写代码驱动小车，将会在树莓派小车系列之三中介绍。&lt;/p&gt;
&lt;h4 id=&quot;连接驱动板和树莓派&quot;&gt;2. 连接驱动板和树莓派：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-a63511fe483baf40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;连接红外线模块和树莓派&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-3af0a03c1589d4dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;四路探测红外线模块&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我购买的是四路探测红外线模块，先拿其中两个红外线接发器来做前方探测。&lt;/p&gt;
&lt;p&gt;在模块电路板中，每个与红外线探测器相连的接口共有三种口，分别是：VCC，GND，IN（1，2，3，4）&lt;/p&gt;
&lt;p&gt;在模块电路板与树莓派相连的接口中，也有三种口：VCC，GND，OUT（1，2，3，4）&lt;/p&gt;
&lt;p&gt;在电路板与红外探测器之间连接时，按照对应接口：&lt;/p&gt;
&lt;p&gt;VCC - VCC GND - GND IN - OUT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-77bea3452c18b1f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;接口1和4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在电路板与树莓派之间连接时，按照对应接口：&lt;/p&gt;
&lt;p&gt;VCC - 3.3V GND - GND OUT - GPIO&lt;/p&gt;
&lt;p&gt;将OUT1和OUT4接在GPIO22 和 GPIO24（读者随意，只要是GPIO口就行）&lt;/p&gt;
&lt;h4 id=&quot;将红外线模块固定在车底部&quot;&gt;3.将红外线模块固定在车底部&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-db8e76a94f4e57b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;红外线模块&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;在小车的第二层放上树莓派和充电宝，小车就全部组装完毕了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3426615-a83a02ce183c9a26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;整辆小车&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于小车的组装就完成了，在下一篇文章中将会给出驱动小车的Python代码。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 15:39:00 +0000</pubDate>
<dc:creator>李汉祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihanxiang/p/8451299.html</dc:identifier>
</item>
<item>
<title>JAVAEE——BOS物流项目03：学习计划、messager、menubutton、登陆拦截器、信息校验和取派员添加功能 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/8451297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/8451297.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;jQuery easyUI messager&lt;/span&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n alert&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n confirm&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n show&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;jQuery easyUI menubutton&lt;/span&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;span&gt;、自定义拦截器实现用户未登录自动跳转到登录页面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 创建拦截器&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 注册拦截器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;span&gt;、基于&lt;/span&gt;&lt;span&gt;ajax&lt;/span&gt;&lt;span&gt;实现用户修改密码功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n easyUI&lt;span&gt;中&lt;/span&gt;&lt;span&gt;validatebox&lt;/span&gt;&lt;span&gt;校验功能&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;发送&lt;/span&gt;ajax&lt;span&gt;请求&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 服务端修改数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5&lt;span&gt;、基础设置部分需求分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6&lt;span&gt;、创建基础设置部分数据表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 取派员表&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 区域表&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 分区表&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 定区表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7&lt;span&gt;、取派员添加功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;扩展&lt;/span&gt;validatebox&lt;span&gt;校验规则&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 页面调整、提交表单&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 服务端操作数据库&lt;/p&gt;


&lt;h2&gt;2.1 &lt;strong&gt;alert&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216232829093-576922964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 &lt;strong&gt;confirm&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216232839827-1456266097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.3 &lt;strong&gt;show&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216232844140-634679751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 制作菜单 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;iconCls:'icon-help',menu:'#mm'&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;easyui-menubutton&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;控制面板&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用div元素制作下拉菜单 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;alert(1111)&quot;&lt;/span&gt;&lt;span&gt; data-options&lt;/span&gt;&lt;span&gt;=&quot;iconCls:'icon-edit'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;修改密码&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;联系管理员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu-sep&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;退出系统&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;4.1 &lt;strong&gt;编写拦截器类&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;需要继承&lt;/span&gt;struts2&lt;span&gt;框架的&lt;/span&gt;MethodFilterInterceptor&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216232925702-633404366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;提供工具类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * BOS项目的工具类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhaoqx
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BOSUtils {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取session对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HttpSession getSession(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServletActionContext.getRequest().getSession();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取登录用户对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; User getLoginUser(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (User) getSession().getAttribute(&quot;loginUser&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自定义的拦截器，实现用户未登录自动跳转到登录页面
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhaoqx
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BOSLoginInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MethodFilterInterceptor{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拦截方法&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; String doIntercept(ActionInvocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从session中获取用户对象&lt;/span&gt;
        User user =&lt;span&gt; BOSUtils.getLoginUser();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有登录，跳转到登录页面&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放行&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.invoke();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;4.2 &lt;strong&gt;配置拦截器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;struts.xml&lt;span&gt;中配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册自定义拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bosLoginInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.itheima.bos.web.interceptor.BOSLoginInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定哪些方法不需要拦截 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;excludeMethods&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义拦截器栈 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;myStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bosLoginInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;myStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 全局结果集定义 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;global-results&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;global-results&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/common/index.jsp&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233032890-1315868576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5.1 &lt;strong&gt;easyUI&lt;span&gt;中&lt;/span&gt;&lt;span&gt;validatebox&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;提供的校验规则：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、非空校验&lt;/span&gt;required=&quot;required&quot;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、使用&lt;/span&gt;&lt;span&gt;validType&lt;/span&gt;&lt;span&gt;指定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;email: &lt;span&gt;正则表达式匹配电子邮件规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;url: &lt;span&gt;正则表达式匹配的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;length[0,100]: &lt;span&gt;在&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;字符允许。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;remote['http://.../action.do','paramName']: &lt;span&gt;发送&lt;/span&gt;&lt;span&gt;ajax&lt;/span&gt;&lt;span&gt;请求做验证值&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;“true”&lt;/span&gt;&lt;span&gt;当成功。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;cellpadding&lt;/span&gt;&lt;span&gt;=3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;新密码：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input  &lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; data-options&lt;/span&gt;&lt;span&gt;=&quot;validType:'length[4,6]'&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;txtNewPass&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Password&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;txt01 easy      ui-validatebox&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;确认密码：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; data-options&lt;/span&gt;&lt;span&gt;=&quot;validType:'length[4,6]'&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;txtRePass&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Password&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;txt01 easyui-validatebox&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.2 &lt;strong&gt;为确定按钮绑定事件&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为确定按钮绑定事件&lt;/span&gt;
        $(&quot;#btnEp&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行表单校验&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; v = $(&quot;#editPasswordForm&quot;).form(&quot;validate&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(v){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单校验通过，手动校验两次输入是否一致&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; v1 = $(&quot;#txtNewPass&quot;&lt;span&gt;).val();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; v2 = $(&quot;#txtRePass&quot;&lt;span&gt;).val();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(v1 ==&lt;span&gt; v2){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两次输入一致，发送ajax请求&lt;/span&gt;
                    $.post(&quot;userAction_editPassword.action&quot;,{&quot;password&quot;:v1},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data == '1'&lt;span&gt;){
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改成功，关闭修改密码窗口&lt;/span&gt;
                            $(&quot;#editPwdWindow&quot;).window(&quot;close&quot;&lt;span&gt;);
                        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改密码失败，弹出提示&lt;/span&gt;
                            $.messager.alert(&quot;提示信息&quot;,&quot;密码修改失败！&quot;,&quot;error&quot;&lt;span&gt;);
                        }
                    });
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两次输入不一致，弹出错误提示&lt;/span&gt;
                    $.messager.alert(&quot;提示信息&quot;,&quot;两次密码输入不一致！&quot;,&quot;warning&quot;&lt;span&gt;);
                }
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.3 &lt;strong&gt;服务端处理&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：在UserAction中创建修改密码方法editPassword
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修改当前用户密码
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String editPassword() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        String f &lt;/span&gt;= &quot;1&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前登录用户&lt;/span&gt;
        User user =&lt;span&gt; BOSUtils.getLoginUser();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            userService.editPassword(user.getId(),model.getPassword());
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            f &lt;/span&gt;= &quot;0&quot;&lt;span&gt;;
            e.printStackTrace();
        }
        ServletActionContext.getResponse().setContentType(&lt;/span&gt;&quot;text/html;charset=utf-8&quot;&lt;span&gt;);
        ServletActionContext.getResponse().getWriter().print(f);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }

第二步：在UserService中提供修改密码方法
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据用户id修改密码
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; editPassword(String id, String password) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用MD5加密密码&lt;/span&gt;
        password =&lt;span&gt; MD5Utils.md5(password);
        userDao.executeUpdate(&lt;/span&gt;&quot;user.editpassword&quot;&lt;span&gt;, password,id);
    }

第三步：在BaseDao中提供通用更新方法
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行更新&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeUpdate(String queryName, Object... objects) {
        Session session &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getSessionFactory().getCurrentSession();
        Query query &lt;/span&gt;=&lt;span&gt; session.getNamedQuery(queryName);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object object : objects) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为HQL语句中的？赋值&lt;/span&gt;
            query.setParameter(i++&lt;span&gt;, object);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行更新&lt;/span&gt;
&lt;span&gt;        query.executeUpdate();
    }

第四步：在User.hbm.xml中定义更新语句
&lt;/span&gt;&amp;lt;query name=&quot;user.editpassword&quot;&amp;gt;&lt;span&gt;
        UPDATE User SET password &lt;/span&gt;= ? WHERE id = ?
&amp;lt;/query&amp;gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;整个&lt;/span&gt;BOS&lt;span&gt;项目分为基础设置、取派、中转、路由、报表、财务等部分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;基础设置部分对应需要规格说明书的&lt;/span&gt;2.6&lt;span&gt;章节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233223093-1748112075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.1 &lt;strong&gt;基础档案设置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;主要是针对本系统中的一些自定义项，需要参照录入，并作为统计分析和计算的维度，用户根据自己的需要动态设置的基础档案；对于自定义的档案支持多级定义；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本模块在其他的系统中也可以称为&lt;/span&gt;“数据字典”。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233229609-610237370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.2 &lt;strong&gt;收派标准&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;将承接的货物，按照重量和体积两个标准，双纬度定义货物的标准。以便将不同标准的货物分给不同收取和派送能力的人员。由运营部门制定。&lt;/p&gt;


&lt;h2&gt;6.3 &lt;strong&gt;班车设置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;将设置的线路和车辆建立对应关系。&lt;/p&gt;

&lt;h2&gt;6.4 &lt;strong&gt;取派员设置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;小件员设置主要是设置小件员和快递员的资源信息，主要是为了自动下单和取派任务件使用；包括增加小件员的交通工具和通讯设备，以及取派的重量和体积标准。&lt;/p&gt;
&lt;p&gt;使用角色为各级组织机构的系统管理人员在添加。&lt;/p&gt;
&lt;p&gt;取派设置中包括小件员的替班信息设置。&lt;/p&gt;
&lt;p&gt;以及被替班人信息的查询功能。&lt;/p&gt;

&lt;h2&gt;6.5 &lt;strong&gt;区域设置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;此功能区域为行政区域列表，为价格、商务网站、工作单始发站、目的站等来源的基础数据。&lt;/p&gt;

&lt;h2&gt;6.6 &lt;strong&gt;管理分区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;区域是由国家划分的行政区域，区域往往很大，不规则，不便于进行物人员分配。对于区域要进行细分，产生分区。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对管理分区进行维护&lt;/span&gt;,&lt;span&gt;为定区管理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;自动下单等后续操作提供基础数据支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打算引入一个复制功能按钮，用来增加信息基本相同的数据。&lt;/p&gt;

&lt;h2&gt;6.7 &lt;strong&gt;管理定区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;定区是物流分配的基本单位，可以将客户信息、取派员信息、分区信息进行关联，为自动分单提供基础数据。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233250187-35234979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.8 &lt;strong&gt;时间管理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上班时间的管理&lt;/span&gt;,&lt;span&gt;根据取派人员的可上班时间&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;将区域取派任务在不同时限分配给不同的取派人员。建议时间管理由总公司部门管理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;固化出各种上班时间点。下级厅点只有调用权限&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;没有修改权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233255843-1362090114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用myeclipse反转生成： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233313781-500350776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/base/staff.jsp&lt;/p&gt;

&lt;h2&gt;7.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;第一步：扩展一个手机号的校验规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
                    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
                                $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = /^1[3|4|5|7|8][0-9]{9}$/&lt;span&gt;;
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩展手机号校验规则&lt;/span&gt;
&lt;span&gt;                                    $.extend($.fn.validatebox.defaults.rules, { 
                                        telephone: { 
                                            validator: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value,param){ 
                                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reg.test(value);
                                        }, 
                                            message: &lt;/span&gt;'手机号输入有误！'&lt;span&gt; 
                                        }
                                        }); 
                                    });
                            &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：为手机号输入框应用规则&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233454984-238471030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233459952-459008199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;第三步：为保存按钮绑定事件，提交表单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为保存按钮绑定事件&lt;/span&gt;
                                    $(&quot;#save&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单校验，如果通过，提交表单&lt;/span&gt;
                                        &lt;span&gt;var&lt;/span&gt; v = $(&quot;#addStaffForm&quot;).form(&quot;validate&quot;&lt;span&gt;);
                                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(v){
                                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$(&quot;#addStaffForm&quot;).form(&quot;submit&quot;);没刷新页面&lt;/span&gt;
                                            $(&quot;#addStaffForm&quot;&lt;span&gt;).submit();
                                        }
                                    });
&lt;/span&gt;&amp;lt;form id=&quot;addStaffForm&quot; action=&quot;staffAction_add.action&quot; method=&quot;post&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;PDA&lt;span&gt;不勾选不会往后台输出值，所以要设置一个默认值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1135185/201802/1135185-20180216233528109-1878182200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;7.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建取派员对应的&lt;/span&gt;Action&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Dao&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Feb 2018 15:37:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/8451297.html</dc:identifier>
</item>
<item>
<title>Leetcode:Merge Sorted Array - 罗梁</title>
<link>http://www.cnblogs.com/xmxj0707/p/8451294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmxj0707/p/8451294.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;br/&gt;Note:&lt;br/&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Solution(object):
    def merge(self, nums1, m, nums2, n):
        &quot;&quot;&quot;
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        i = 0
        j = 0
        k = 0
        while(i &amp;lt; m + n and j &amp;lt; n):
            while(i &amp;lt; m + k and nums1[i] &amp;lt; nums2[j]): #先寻找比nums数组中所有的数都小的数，然后插入进去
                i += 1
            if i == m + k: # 说明剩余的数都比原来的nums1大，直接替换就行了。
                break;
            nums1.insert(i,nums2[j])
            del(nums1[-1])
            k += 1
            j += 1
        while(j &amp;lt; n):
            nums1[i] = nums2[j]
            i += 1
            j += 1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 16 Feb 2018 15:35:00 +0000</pubDate>
<dc:creator>罗梁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmxj0707/p/8451294.html</dc:identifier>
</item>
<item>
<title>在ConcurrentModificationException异常上的联想 - 呼呼呼呼呼65</title>
<link>http://www.cnblogs.com/huhu1203/p/8445827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huhu1203/p/8445827.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.什么是ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家都听说过快速报错fast-fail吧，fast-fail的发生就是说明发生了ConcurrentModificationException异常。其实发生这种异常的事件有两种，一种是在Iterator在迭代过程中，出现删除或者增加Collection中的元素的时候。另一种是多线程情况下，一个线程在用Iterator迭代Collection元素时，另一个线程却在给这个Collection增加或者删除元素。大家也许看出来了，两种情况其实都是在Iterator迭代元素过程中增加或者删除元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.制造ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是制造ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    List list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.add(&lt;/span&gt;1&lt;span&gt;);
        list.add(&lt;/span&gt;2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.listIterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.add(&lt;/span&gt;3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;Thread-0&quot;&lt;span&gt; java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:&lt;/span&gt;901&lt;span&gt;)
    at java.util.ArrayList$Itr.next(ArrayList.java:&lt;/span&gt;851&lt;span&gt;)
    at dp.Cme.run(Cme.java:&lt;/span&gt;17&lt;span&gt;)
    at java.lang.Thread.run(Thread.java:&lt;/span&gt;745)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;确实是发生错误了，点击错误信息，调到了下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;大概意思是Collection中的元素与开始遍历的时候传来的个数不相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那到底是什么调用了上面的方法？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
           checkForComodification();
           &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;= SubList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size)
                  &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
           Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset + i &amp;gt;=&lt;span&gt; elementData.length)
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
           cursor &lt;/span&gt;= i + 1&lt;span&gt;;
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[offset + (lastRet =&lt;span&gt; i)];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那我们在next（）方法后面，仿照CAS机制中的ABA问题，先添加元素然后删除元素，行不行呢？（这样做毫无意义）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是不行的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
    checkForComodification();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
           SubList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
           cursor &lt;/span&gt;=&lt;span&gt; lastRet;
           lastRet &lt;/span&gt;= -1&lt;span&gt;;
           expectedModCount &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modCount;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为remove中也调用了上面的那个方法。但是我们可以用一种方法，在遍历的过程中把需要删除的对象保存到一个集合中，等遍历结束后再调用removeAll()方法来删除，或者使用iterator.remove()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步的集合类（Hashtable和Vector），同步的封装类（使用Collections.synchronizedMap()方法和Collections.synchronizedList()方法返回的对象）可以创建出线程安全的Map和List。但是有些因素使得它们不适合高并发的系统。它们仅有单个锁，对整个集合加锁，以及为了防止ConcurrentModificationException异常经常要在迭代的时候要将集合锁定一段时间，这些特性对可扩展性来说都是障碍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.为什么用CopyOnWriteArrayList代替ArrayList，就不会产生ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从字面意思上可以看出来复制出来一份来操作，然后写道原先的ArrayList中。这样说肯定不行，我们看看源码，验证字面意思对不对？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然在迭代的时候能add，我们先看看add的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
*1、获取互斥锁
*2、Copy当前元素数组创建新数组，数组内存空间增1
*3、添加元素
*4、请求容器数据数组内存地址变更为新数组地址
*5、释放互斥锁
*6、返回结果
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lock;
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Object[] elements &lt;/span&gt;=&lt;span&gt; getArray();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; elements.length;
            Object[] newElements &lt;/span&gt;= Arrays.copyOf(elements, len + 1&lt;span&gt;);
            newElements[len] &lt;/span&gt;=&lt;span&gt; e;
            setArray(newElements);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那还有一个问题，在调用Iterator的next方法，结果会是什么样的呢？边add边迭代吗？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是消除ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    List list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CopyOnWriteArrayList();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.add(&lt;/span&gt;1&lt;span&gt;);
        list.add(&lt;/span&gt;2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.listIterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.add(&lt;/span&gt;3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme2 cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme2();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看看原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; COWIterator&amp;lt;E&amp;gt;(getArray(), 0&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; COWIterator&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Snapshot of the array &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object[] snapshot;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Index of element to be returned by subsequent call to next.  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cursor;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; COWIterator(Object[] elements, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCursor) {
            cursor &lt;/span&gt;=&lt;span&gt; initialCursor;
            snapshot &lt;/span&gt;=&lt;span&gt; elements;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor &amp;lt;&lt;span&gt; snapshot.length;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor &amp;gt; 0&lt;span&gt;;
        }

        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; hasNext())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) snapshot[cursor++&lt;span&gt;];
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;并发场景下对容器的添加操作是通过在容器内部数据数组的副本来完成的。对容器的迭代使用的是容器原始数据数组因为迭代不会产生修改，因此多个线程可以同时对容器进行迭代，而不会对彼此干扰或影响修改容器的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.为什么用ConcurrentHashMap代替hashMap，就不会产生ConcurrentModificationException？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cme表示ConcurrentModificationException
 * 目的是制造ConcurrentModificationException
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cme &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    Map list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        list.put(&lt;/span&gt;'1',1&lt;span&gt;);
        list.put(&lt;/span&gt;'2',2&lt;span&gt;);

        Iterator itr &lt;/span&gt;=&lt;span&gt; list.values().iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (itr.hasNext()) {
            System.out.println(itr.next());
            list.put(&lt;/span&gt;'3',3&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Cme cm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cme();
        Thread thread_1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(cm);
        thread_1.start();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;Thread-0&quot;&lt;span&gt; java.util.ConcurrentModificationException
    at java.util.HashMap$HashIterator.nextNode(HashMap.java:&lt;/span&gt;1437&lt;span&gt;)
    at java.util.HashMap$ValueIterator.next(HashMap.java:&lt;/span&gt;1466&lt;span&gt;)
    at dp.Cme.run(Cme.java:&lt;/span&gt;19&lt;span&gt;)
    at java.lang.Thread.run(Thread.java:&lt;/span&gt;745)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看看原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode() {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt;[] t;
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((next = (current = e).next) == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (t = table) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; {} &lt;span&gt;while&lt;/span&gt; (index &amp;lt; t.length &amp;amp;&amp;amp; (next = t[index++]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是期望值与传进来的元素数量不相等所导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;由于map是key-&lt;span&gt;value形式的，并且map是有自己的空间的，所以在put的时候，并不影响。
在迭代时是如何保证遍历出原来的map的value的，具体原因我会再深入，及时修改文章。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6.hashtable怎么就不能代替在多线程情况下的hashMap?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hashtable和ConcurrentHashMap都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。也就是说代替是可以代替，但是在解决线程安全的同时降低了性能，所以选用ConcurrentHashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.为什么要在多线程下使用hashMap呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是废话。线程不安全你还偏要用，非得跟自己过不去吗？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/kobejayandy/article/details/16834311&quot;&gt;CocurrentHashMap和Hashtable的区别&lt;/a&gt;         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/dove_knowledge/article/details/71023512&quot; target=&quot;_blank&quot;&gt;Iterator&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/ybygjy/article/details/38147779&quot; target=&quot;_blank&quot;&gt;JCIP_5_01_CopyOnWriteArrayList为什么不会产生ConcurrentModificationException&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;link_title&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/1e9cf0ac07f4&quot; target=&quot;_blank&quot;&gt;老生常谈，HashMap的死循环&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.jianshu.com/p/f3f6b12330c1&quot; target=&quot;_blank&quot;&gt;理解和解决Java并发修改异常ConcurrentModificationException&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原创不易，转载请注明地址&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 制造ConcurrentModificationException异常&quot; href=&quot;http://www.cnblogs.com/huhu1203/p/8445827.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/huhu1203/p/8445827.html&lt;/a&gt; ，如有问题，请指正！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 15:28:00 +0000</pubDate>
<dc:creator>呼呼呼呼呼65</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huhu1203/p/8445827.html</dc:identifier>
</item>
<item>
<title>数学对于人类意味着什么 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/8450327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/8450327.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/8450327.html 

　　作者：窗户

　　QQ：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个话题是个很常见的话题，也是一个很难说明的问题。每当闲着无事的时候，我都会去思考一下关于数学的问题。正值假期，我有很多的时间来思考。&lt;/p&gt;
&lt;p&gt;　　昨天大年三十，母校老师问了我一个微分方程y''+py'+qy=Ae&lt;sup&gt;r&lt;/sup&gt;&lt;sup&gt;x&lt;/sup&gt;的解法问题，当然在此之前也问过我类似的方程的解答问题，虽然我已经很久没有去想微分方程的解析解问题，但是依稀还记得微分方程的一些知识。于是用纸张比划了很多，一通推导，关于此类方程的解法，引申出了线性空间、基、解空间的问题乃至比这个更复杂的高阶问题的解答。自己觉得还算满意，庆幸还没有完全把此类问题还给老师。过程中回忆起了一般的n阶齐次常微分方程归约到一元n次方程，以及后面的常函数项是形如Ax&lt;sup&gt;n&lt;/sup&gt;e&lt;sup&gt;r&lt;/sup&gt;&lt;sup&gt;x&lt;/sup&gt;之和的形式的解法，这是拓展的形式。&lt;/p&gt;
&lt;p&gt;　　从古埃及尼罗河泛滥丈量土地开始，人类就已经在为了技术的需要探索数学。中国在古代的时候，为了建筑、丈量的需要，也诞生了很多技术，辅助着也产生了一些应用上的数学。这些产生的数学都是应用上的数学。然而古希腊却是古数学的一个奇葩，他们脱离了远古社会中生产力低下的现实，而开始在数学的石器时代就开始去探索数学的本质，其代表作《几何原本》是考虑数学应该是先建立公理，再通过演绎法来建立所有的命题，而不是只去考虑当时的实用性。我至今无法理解为什么古希腊数学家会有如此抽象的想法，虽然不得不说其数学思想还是有很多的缺陷，但毕竟是人类记录历史里第一次思考数学的本质。&lt;/p&gt;
&lt;p&gt;　　我们从小学就开始做数学应用题，这是很科学的，因为不可能一上来就教小学生什么叫公理，什么叫peano算术系统，因为这个太抽象。人类最开始研究数学就是这样从实际应用来出发的，以及后面很多时候数学的进步也是为了实际应用来建模。我们做数学应用题，做着做着，发现那种鸡兔同笼这样的问题开始就要用所谓的技巧了，这个很不方便，于是我们学习了方程，此类问题的解决手段一下子变的简单。那么从简单应用题到一元一次方程就是一个数学的进步。&lt;/p&gt;
&lt;p&gt;　　到了初中，我们的数学开始变的抽象起来，应用题越来越少，题目越来越多的是纯数学。这就是开始训练演绎的手段了。到了高中，所有的一切进一步升华。&lt;/p&gt;
&lt;p&gt;　　到了大学，接触到了数学分析，又是一种什么样的情景呢?数学分析在整个数学中有个非常重要的作用，大多数学生是学到数学分析的时候才第一次真正意义上明白了数学的严格性，因为数学分析第一步则是学习实数。虽然到了初中，所有的学生都已经明白了什么叫实数，可完全没有深入的去明白实数系统是如何建立的，也没有明白诸如3.1415926...这样的表示的意义，当然，我们现在明白，它其实是用一个级数的极限来表示一个数。实数系的学习可能是很多人对于数学永远痛苦的回忆之一，因为人生第一次明白了数学的严格性，严格性带来的痛苦是，可能一个定理的证明花费半天甚至一天时间。而封闭曲线的定义恐怕要让很多人绞尽脑汁。&lt;/p&gt;
&lt;p&gt;　　然而，真实的数学发展却未必是按我们学习的方向。实数系的建立是在微积分发展了之后才开始建立的，甚至当时已经有微分方程的研究了。而微积分建立之初是为了力学的研究，Newton和Leibniz希望通过一种通用的手段来解决力学问题。微积分建立的基础在最开始的百年是不牢固的，一些基础性的问题并没有考虑清楚，所以牛顿曾经被红衣大主教驳的哑口无言，而直到Cauthy完备了实数系基础理论，才让微积分站的住脚。&lt;/p&gt;
&lt;p&gt;　　一元五次方程的求解问题、三大尺规作图问题、多n边形的尺规作图问题，这些问题曾缠绕了数学家很多年，特别是三大尺规作图问题，数学家被困扰了一两千年。而Galois的抽象代数则成功的把这些问题最终规避为一个问题。&lt;/p&gt;
&lt;p&gt;　　二十世纪为数理逻辑的世纪，这个世纪里发展了很多与数理逻辑相关的学科，包括计算理论。曾经的三大数学危机带来了新的思维，带来了数学的发展，这最后一大数学危机正是给数理逻辑准备的，而数理逻辑，则是数学的本质所在了，在数理逻辑逻辑里看来，计算10*10=100，和解决P?=NP问题，还真未必有什么本质区别。&lt;/p&gt;
&lt;p&gt;　　然而我们还是要问一下，数学对于人类到底意味着什么？&lt;/p&gt;
&lt;p&gt;　　人类一代代生存、一代代思考，过程中遇到了问题，数学是为了解决问题的。我们总是不断的把实际情况抽象化，客观上使用数学建模，无论那叫不叫数学建模。人们期望有种通用的方法解决所遇到的一类问题，于是我们就有了算术，有了平面几何。数学的发展就是为了不断的总结，不断的抽象，以希望提炼出精华，从而得到更一般的工具。&lt;/p&gt;
&lt;p&gt;　　另一方面，发展数学本身的时候，我们会遇到一些数学难题，以及所建立出来的数学（比如曾经的微积分）存在着很多的底层问题，这都需要人们要去解决。数学难题往往推动着数学的发展，而数学底层的问题就更大，数学如果站不住脚，在此之上的工具是不可靠的。&lt;/p&gt;
&lt;p&gt;　　有些人曾经问我，解决哥德巴赫猜想有什么作用？这似乎是民科最感兴趣的数学问题，因为它简单易懂，不需要很高的数学修养就可以明白。于是有些人就认为这其实是一个解决了也没有多大意义的问题。然而我要说的是，解决任何一个数学问题可能都是有意义的，因为解决它的过程中，我们可能造出了新的数学工具，从而对于解决其他的问题有意义。比如四色问题和单群分类问题都是通过计算机解决的，因为实在太复杂，计算机相对方便干重复而枯燥的事情，这就给了我们一个新的启发。&lt;/p&gt;
&lt;p&gt;　　我觉得数学对于人类的意义，是在于人类可以用统一、可靠的手段解决一类问题，而每当遇到问题的时候，我们都可以使用数学建模，从而使用那同一类的解决手段，使之有理可循，让我们从完全的经验化中走出，而向理论化、工具化发展。远古社会，数学为我们提供基础算术，从而有了度量手段；工业社会来了，数学为我们提供了微积分等一系列工具；信息时代来了，数学为我们提供了计算理论、递归论、图论这样的工具，也为我们提供了算法这样的东西；AI时代来了，数学一样为我们所有的算法模型提供最基本的数学保障。P?=NP的问题，甚至可能改变未来的社会格局。总之，数学是个取之不尽的大仓库。从这个方面来看，我是反对奥数的，因为总觉得它是希望问题复杂化，在我看来意义并不大，仿佛是数学杂技。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 14:35:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/8450327.html</dc:identifier>
</item>
<item>
<title>使用VS Code开发asp.net core (上) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8450179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8450179.html</guid>
<description>&lt;p&gt;本文是基于Windows10的.&lt;/p&gt;
&lt;p&gt;下载地址: &lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;insider 版下载地址: &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot; target=&quot;_blank&quot;&gt;https://code.visualstudio.com/insiders/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个版本可以同时安装在系统中.&lt;/p&gt;
&lt;p&gt;安装过程就不介绍了.&lt;/p&gt;

&lt;p&gt;1.可以点击图标打开vscode&lt;/p&gt;
&lt;p&gt;2.如果安装的时候勾选了注册到Path, 那么可以在命令行输入code来打开vscode.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135404702-1031473833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Git集成&lt;/h2&gt;
&lt;p&gt;使用git随便clone一个项目下来, 然后用vscode打开项目, 随便打开某个文件, 添加几行代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135812218-1732291166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9-11行是我新添加的, 左边&lt;span&gt;绿色&lt;/span&gt;的竖条(点击就会看到明细)就表示这几行是新添加的.&lt;/p&gt;
&lt;p&gt;然后修改一下h1的标题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216135932765-433837279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改的地方左边会出现&lt;span&gt;蓝色&lt;/span&gt;的竖条(点击就会看到明细). 表示这行发生了变化.&lt;/p&gt;
&lt;p&gt;这次再删除两行代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140112109-526449999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边会出现一个&lt;span&gt;红色&lt;/span&gt;的箭头, 鼠标可以放在这个箭头上, 然后点击一下查看明细, 就可以看到删除的代码行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140203984-1001069912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击vscode左边的Source Control按钮:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140417234-183857668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按钮图标上的1表示有一个文件有变化. 文件上还有undo, stage按钮. 点击文件后可以看到文件变化前后的对比明细.&lt;/p&gt;
&lt;p&gt;左侧上方还有很多功能菜单就不一一介绍了.&lt;/p&gt;
&lt;h2&gt;配置VSCode&lt;/h2&gt;
&lt;p&gt;打开File-Preferences-&lt;strong&gt;Settings&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216140908577-1931781330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141131687-996914008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的是VSCode默认的设置, 如果想要修改某些设置, 就把他们复制到右侧窗口, 保存后会立即生效.&lt;/p&gt;
&lt;p&gt;在上图中, 我设置了终端命令行为采用外部的命令行程序, 并且使用git的bash作为命令行程序. 保存后会立即生效, 无需重启VSCode.&lt;/p&gt;
&lt;p&gt;注意右侧文件上方, 目前修改的是User Settings. 也就是当前登录用户的配置.&lt;/p&gt;
&lt;p&gt;如果只想针对某个项目(文件夹)进行设置的话, 那么可以点击Workspace Settings. 这时候, 该目录会自动生成一个文件: vscode/settings.json, 所有修改的设置都会保存在这个文件里面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141524734-839434953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了Settings, 还可以配置&lt;strong&gt;快捷键&lt;/strong&gt;, 点击Preferences-Keyboard Shortcuts (Ctrl+K, S):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141731499-811246851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后点击文件上方的keybindings.json:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216141950999-161695263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也会出现类似的配置画面.&lt;/p&gt;
&lt;p&gt;左边的菜单, 如果不需要的话也可以隐藏起来, 鼠标右键点击Hide即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142242202-284370893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示所有命令&lt;/strong&gt;: &lt;span&gt;Ctrl+Shift+P&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142457749-1121916549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索并打开文件: &lt;span&gt;Ctrl+P&lt;/span&gt;. 随着输入就会自动过滤文件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142754265-1121812605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装扩展&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;点击Extensions按钮图标, 进入扩展页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216142956109-1749329911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用各种排序方法展示扩展, 然后点击扩展, 安装然后点击reload重启vscode即可.&lt;/p&gt;
&lt;p&gt;这里我们必须要安装C#扩展.&lt;/p&gt;
&lt;p&gt;去掉过滤条件, 就可以看到安装好的扩展了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143214140-56820590.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;


&lt;p&gt;安装asp.net core环境:&lt;/p&gt;
&lt;p&gt;打开网站 &lt;a href=&quot;https://www.microsoft.com/net&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/net&lt;/a&gt;, 点击download.&lt;/p&gt;
&lt;p&gt;然后选择下载.net core.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143500234-2138457368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后安装即可. 如果你已经安装vs2017, 可能就不需要再安装这个了.&lt;/p&gt;
&lt;p&gt;打开命令行: 输入dotnet --version检查安装.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216143647515-1002329764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功, 版本为2.1.4&lt;/p&gt;
&lt;h2&gt;建立asp.net core 项目&lt;/h2&gt;
&lt;p&gt;用命令行找个地方, 建立目录, 然后执行一下dotnet new --help命令, 查看一下建项目的帮助:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144000734-1907039252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我建立一个不带用户验证的mvc项目:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet new mvc --auth None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144209702-1178934639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行输入 code . 就会用vscode打开该目录:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216144358515-41550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些就是生成文件.&lt;/p&gt;
&lt;p&gt;打开后, vscode会自动安装C#依赖.&lt;/p&gt;
&lt;p&gt;如果VSCode上方有任何选择提示, 请选择Yes或者Restore.&lt;/p&gt;
&lt;p&gt;试一下项目是否正确:&lt;/p&gt;
&lt;p&gt;打开命令行: Ctrl+Shift+C或者在VSCode内打开命令行: Ctrl+Shift+`&lt;/p&gt;
&lt;p&gt;内置的默认命令行是Powershell, 我不是很喜欢它的速度, 所以可以通过之前讲的修改settings的方法把它改成Commmand Prompt.&lt;/p&gt;
&lt;p&gt;执行命令dotnet run:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216145550296-450066323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行成功, 打开浏览器, 可以看到项目的画面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216145619140-1682152655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码导航.&lt;/p&gt;
&lt;p&gt;使用F12来导航代码, 这个和vs是一样的.&lt;/p&gt;
&lt;p&gt;打开Program.cs 鼠标选中22行左右的StartUp这个单词, 然后按F12. 就会导航到Startup这个类.&lt;/p&gt;
&lt;p&gt;点击类或方法上面的Reference, 可以查看对其的引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150011734-2138542336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用Alt+左右方向键, 来导航的前一个或者下一个动作画面.&lt;/p&gt;
&lt;p&gt;按住Shift+F12可以看到它的所有的引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150243171-65147476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上点击鼠标右键, 都会有相应的菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150347077-313473643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一个重要的导航方法就是 使用Ctrl+P, 通过文件名来查找文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150459156-59260252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;添加文件&lt;/h2&gt;
&lt;p&gt;可以使用这个图标按钮来添加文件, 也可以使用菜单, 或者鼠标右键, 这个就不详细讲了.&lt;/p&gt;
&lt;p&gt;这里添加一个TestController.cs:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216150850952-457795324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开该文件, 开始编写代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151002749-427452876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚刚输入了names, 然后出现了两个貌似一样的提示...其实他们是不一样的, 第一个表示的是C#关键字namespace. 第二个表示的是namespace代码片段.&lt;/p&gt;
&lt;p&gt;所以选中第二个, 再输入命名空间的名字, 就会出现这段代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151237499-1280515502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立TestController, 继承于Controller:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151447515-777154355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候Controller并没有被识别出来. 当然可以点击左边黄色的图标, 来选择引用.&lt;/p&gt;
&lt;p&gt;但是我们可以使用快捷键Ctrl+. 来进行Quick Fix快速修复, 选择引用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151709952-1035672654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216151750374-1947677742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码段 Snippets&lt;/h2&gt;
&lt;p&gt;打开User Snippets菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216152200906-1897613791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择C#:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216152243281-1537448306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把里面注释的文字留下, 复制其中那段代码并修改称自己的代码段:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;&lt;span&gt;con&lt;/span&gt;&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class &lt;span&gt;$1&lt;/span&gt;Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t&lt;span&gt;$0&lt;/span&gt;&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a Controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码段的名字叫Create Controller, 输入con后将会调用该代码段, 代码段中$1的位置需要用户输入Controller的名字, 输入完成后按Tab光标将会留在$0的位置.&lt;/p&gt;
&lt;p&gt;您可以试一下, 肯定是好用的.&lt;/p&gt;
&lt;p&gt;但是这样输入的时候会稍显不友好, 因为没有提示, 那么可以将用户输入的部分改成这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;con&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class &lt;span&gt;${1: ControllerName}&lt;/span&gt;Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155303749-1956189405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就好多了.&lt;/p&gt;
&lt;p&gt;这个在代码段输入的变量也可以被引用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &quot;Create Controller&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;con&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public class ${1: ControllerName}Controller: Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t// 建立了&lt;span&gt;${1: ControllerName}&lt;/span&gt;Controller&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155227812-448309395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再建立一个Action的代码段:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &quot;Create Action&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;prefix&quot;: &quot;act&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;body&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;public IActionResult ${1: ActionName}()&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;{&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t// 建立了${1: ActionName} Action Method&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\t$0&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;\treturn View();&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;}&quot;&lt;span&gt;
        ],
        &lt;/span&gt;&quot;description&quot;: &quot;Create a controller&quot;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装snippet扩展.&lt;/h2&gt;
&lt;p&gt;去vscode扩展画面可以搜索snippet关键字就可以看到各种snippet扩展:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216155543718-1015743213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Html Zen coding&lt;/span&gt;: &lt;/h2&gt;
&lt;p&gt;zen coding是一种编写html和css的方法, 很快捷. &lt;/p&gt;
&lt;p&gt;打开Views/Home/About.cshtml, 然后在空白处输入div然后按Tab:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160623249-2000710133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后完整的div标签就出来了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160651234-36504889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zen coding允许你使用&lt;span&gt;css选择器&lt;/span&gt;进行更复杂的结构化写法, 例如输入 div&amp;gt;p&amp;gt;ul&amp;gt;li:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160813749-1456239410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后立即按Tab, 就会出现下列代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160848906-173137808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想&lt;span&gt;重复5个&lt;/span&gt;li, 那么输入 div&amp;gt;p&amp;gt;ul&amp;gt;li*5:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216160950234-33930066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想加上class属性, div&amp;gt;p&amp;gt;ul.list-group&amp;gt;li.list-group-item*5:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216161103390-689137209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个建立bootstrap form的例子,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
form&amp;gt;(.form-group&amp;gt;label+input.form-control)*4+.form-group&amp;gt;input[type=submit].form-control
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就会生成下面的form:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216161259577-1583655035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中+表示下一个元素中括号可以写其他属性.&lt;/p&gt;
&lt;h2&gt;添加移除asp.net core项目引用.&lt;/h2&gt;
&lt;p&gt;可以通过编辑.csproj文件来添加或者移除项目引用.&lt;/p&gt;

&lt;p&gt;注意这里并没有智能提示, 最好是在Nuget网站搜索好相关包之后填写进来.&lt;/p&gt;
&lt;p&gt;编辑结束之后, vscode会提示进行restore, 这就相当于在命令行执行dotnet restore命令.&lt;/p&gt;
&lt;p&gt;此外, 也可以通过命令行来添加nuget包, 使用dotnet add package xxx命令来添加nuget包:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216162415781-1896227834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, csproj文件里就会出现AutoMapper的PackageReference:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216162542921-488540064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Build项目&lt;/h2&gt;
&lt;p&gt;使用命令dotnet build来进行此操作.&lt;/p&gt;
&lt;p&gt;运行项目使用dotnet run.&lt;/p&gt;
&lt;p&gt;项目中.vscode目录下有个tasks.json文件, 打开它:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163135484-504060657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有一个task叫做build, 命令是dotnet, 参数是build和项目文件.&lt;/p&gt;
&lt;p&gt;如果执行VSCode命令&lt;span&gt;Ctrl+Shift+B&lt;/span&gt;, 选择build就会执行此命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163345327-1669095971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163404984-287363752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个launch.json和它也差不多, 一会再说.&lt;/p&gt;
&lt;h2&gt;Debugging&lt;/h2&gt;
&lt;p&gt;看一下Debugging画面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163602406-1755888031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下来选单里面两个配置就来自launch.json.&lt;/p&gt;
&lt;p&gt;点击&lt;span&gt;绿色箭头&lt;/span&gt;就可以debugging (F5也行).  当然也可以start without debugging (Ctrl+F5), 这时浏览器会自动打开主页:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216163837656-1323590590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开HomeController.cs设置一个断点:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164206531-134036987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按F5开始并debug项目, 点击About菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164325546-1998291894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到命中了断点, 打开Debug画面, 里面有丰富的信息. &lt;/p&gt;
&lt;p&gt;可以添加watch:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216164446640-759088141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样也可以在RazorView里面设置断点.&lt;/p&gt;
&lt;p&gt;通过这些可以看到vscode的debug体验很好, 不必任何一款IDE差多少. 所以vscode绝不是一个高级编辑器这么简单.&lt;/p&gt;
&lt;h2&gt;Build Watcher .&lt;/h2&gt;
&lt;p&gt;还有另外一种方式可以, 它允许对项目持续的Build.&lt;/p&gt;
&lt;p&gt;首先打开csproj文件, 添加一个watcher tool:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;AutoMapper&quot; Version=&quot;6.2.2&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.All&quot; Version=&quot;2.0.5&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;DotNetCliToolReference Include=&quot;Microsoft.VisualStudio.Web.CodeGeneration.Tools&quot; Version=&quot;2.0.2&quot; /&amp;gt;
    &lt;span&gt;&amp;lt;DotNetCliToolReference Include=&quot;Microsoft.DotNet.Watcher.Tools&quot; Version=&quot;2.0.0&quot; /&amp;gt;&lt;/span&gt;
  &amp;lt;/ItemGroup&amp;gt;  

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它就是一个nuget包.&lt;/p&gt;
&lt;p&gt;然后执行 dotnet restore.&lt;/p&gt;
&lt;p&gt;它的用法就是在dotnet xxx命令之间加上watch, 例如 dotnet watch run.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165437765-1885743092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后我更改一下HomeController About方法里面的Message:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165729890-2050349913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到项目被停止, 重新Build, 然后又开始了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165649015-1381496541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;dotnet watch run配合Debugging.&lt;/h2&gt;
&lt;p&gt;看一下Debug里面的.net core Attach启动项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165833468-647087019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击绿色箭头后出现如下选项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216165918765-1283366726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的dotnet watch run正在运行, 这时候我还想进行debug, 那么就可以选择dotnet exec这个选项, 它会执行dotnet watch run实时build出来的dll. 这两个动作是在不同的进程执行的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216170242281-2077617522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置断点试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180216170334562-682583622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很好.&lt;/p&gt;
&lt;p&gt;如果不想debug了, 点击红色插头即可停止, 并且不影响dotnet watch run的运行.&lt;/p&gt;

&lt;p&gt;剩下有一半内容, 过一两天再写.&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 09:08:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8450179.html</dc:identifier>
</item>
<item>
<title>前端小白的个人习惯和笔记(一) - 房东家的猫</title>
<link>http://www.cnblogs.com/fangdongdemao/p/8450218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fangdongdemao/p/8450218.html</guid>
<description>&lt;p&gt;已经敲代码这么久,分享一下自己的小习惯(可能有点乱有点杂)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;win+S&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以说是window用户的神器,可以随意开启全局的软件,配合cmd使用,&lt;code&gt;alt+F4&lt;/code&gt;直接关闭这样就省下按鼠标的时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ctrl+shift+tab&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在webstorm中快速打开本项目文件也可以直接打开cmd,不会打开webstorm自带的cmd我 习惯使用&lt;code&gt;alt+F12&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;alt+tab&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个切换窗口你们可以用的特别多,但是&lt;code&gt;ctrl+alt+tab&lt;/code&gt;你们肯定用的少吧,这个你们用多了,就发现还是比&lt;code&gt;alt+tab&lt;/code&gt;好用的,特别你开启很多窗口的时候&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ctrl+shift+esc&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启任务管理器你们肯定知道&lt;code&gt;ctrl+alt+.&lt;/code&gt;可是我是68的键盘没有&lt;code&gt;.&lt;/code&gt;表示很无奈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ctrl+w&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关闭网页用chrome浏览器用多了,蛋疼的是不能双击关闭网页,后来知道可以按滚纶关闭,但是,我鼠标不怎么样,还是这个比较方便&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ctrl+c&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个你不会以为我要跟你说复制,呵呵,这个是webstorm中回到行首,解决了一部分不喜欢的方向键的烦恼&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ctrl+tab或ctrl+1,2,3&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速切换浏览器窗口,可以只是强迫症来的时候用的多,或者吃饭一只手的时候可以用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;直接上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180216123710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于英语单词还是比较吃力的我,简直是我人生的福音,&lt;strong&gt;超超超级好用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;phpstorm多窗口&lt;code&gt;alt+窗口&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决用习惯了webstorm快速转移phpstorm,当然少不了快键键了,直接上图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180216124735.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你要查看自己的id,直接在cmd输入&lt;code&gt;ipconfig&lt;/code&gt;完美解决&lt;/p&gt;
&lt;p&gt;下包&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在用webstorm打开cmd&lt;code&gt;alt+F12&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm init
npm install 包名  --save  //save把包信息放在package
dower install 包名  //直接在本文件夹下面生成包,你要是怕麻烦可以用这个下包工具&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其实你也可以直接报npm的下载地址改成淘宝镜像,在安装路径npm文件夹下&lt;code&gt;npmrc&lt;/code&gt;文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ctrl+shift+F10&lt;/code&gt; webstorm直接打开浏览器如果是js文件就会直接打开控制台&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl+A两次&lt;/code&gt; 在用oneNote的时候你会发现ctrl+A会全选一行内容,两次就会全选全部内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F11&lt;/code&gt; 全屏--看视频专用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;win+左/右&lt;/code&gt; 分屏,可以适合边看文档边敲代码&lt;/p&gt;
&lt;p&gt;win+上 全屏&lt;/p&gt;
&lt;p&gt;win+下 最小化(这个是不是很贴心又解决了用鼠标的烦恼呀)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Fn+F6&lt;/code&gt; 关闭电脑触屏版&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;糖在不改变其所在位置的语法结构的前提下实现了运行时等价,之所以叫语法糖,是因为加糖后的代码写的很爽,代码更简洁流畅语义自然&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;例如:for循环,三元表达式---&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u014440483/article/details/78570569&quot;&gt;解决node_modules卡顿问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得乱的话可以看下面的这张图简要的写了一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180216144258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt+F1&lt;/code&gt;第七个 所在的文件路径(最新版webstorm好像不行)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl+shift+左.右&lt;/code&gt; 目录调大调小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl+F12&lt;/code&gt; 查找定义多少函数等目录(这么高级的功能我还没怎么用过)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alt+左.右&lt;/code&gt; 窗口文件左右切换(这么好用还是经常忘记真的不应该)&lt;/p&gt;
&lt;p&gt;Alt+1  打开关闭项目窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;itar&lt;/code&gt; 遍历一个for循环&lt;/p&gt;
&lt;p&gt;cc:ie6 兼容ie6(然后改成7,8就行了,不相当于兼容ie6,7,8)&lt;/p&gt;
&lt;p&gt;自定义代码块保存路径 找到c盘安装目录&lt;code&gt;config/template&lt;/code&gt;里面就是的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/4ae03de3e091df3eff9e6b35.html&quot;&gt;给桌面时间添加秒&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不管什么时候要不断保持学习的态度&lt;/p&gt;
&lt;p&gt;再与产品经理打交道&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;
&lt;p&gt;第三方选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;你可以问清楚对方的真实需求,给出一个你可以做到的方案,而不是直接拒绝对方的方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;在工作和生活中,不要把所有事情的解决方案都放在:不(第一选择,要赢)或者是(第二选择,认怂)上,如果只存在两种选择,很容易就进入一种推拉的环境中,实际上是可以考虑第三选择.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;第三选择并不是某一方的妥协,他的核心思想是创造力,找到新的出路,让双方协同找到一个大家都能接受的新方案&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;js基础部分&quot;&gt;js基础部分&lt;/h3&gt;
&lt;p&gt;一、         数据类型&lt;/p&gt;
&lt;p&gt;1)       Number 数据类型&lt;/p&gt;
&lt;p&gt;2)      String  字符串(双引号, 单引号)&lt;/p&gt;
&lt;p&gt;3)      Boolean 布尔数据类型(true, false)&lt;/p&gt;
&lt;p&gt;4)      undefined  变量未初始化(没有给变量赋值)&lt;/p&gt;
&lt;p&gt;5)      null 变量未引用(值为空)&lt;/p&gt;
&lt;p&gt;6)      object  对象     array 数组&lt;/p&gt;
&lt;p&gt;二、         算术运算符&lt;/p&gt;
&lt;p&gt;1)     两个数字类型变量相加或相减，得到一个数字类型&lt;/p&gt;
&lt;p&gt;2)     一个数字类型和一个字符串相加，得到一个字符串&lt;/p&gt;
&lt;p&gt;3)     一个数字类型和一个非数字类型的字符串得到NaN&lt;/p&gt;
&lt;p&gt;三、         Math对象&lt;/p&gt;
&lt;p&gt;1)     Math.ceil()  天花板函数  向上取整(1.1---2)&lt;/p&gt;
&lt;p&gt;2)     Math.floor() 地板函数   向下取整(1.1---1)&lt;/p&gt;
&lt;p&gt;3)     Math.max()   Math.min()&lt;/p&gt;
&lt;p&gt;4)     Math.pow(n1,n2)    n1的n2次方&lt;/p&gt;
&lt;p&gt;5)     Math.round()    四舍五入&lt;/p&gt;
&lt;p&gt;6)     Math.random()   [0,1)的随机数&lt;/p&gt;
&lt;p&gt;四、         数据类型转换&lt;/p&gt;
&lt;p&gt;1.     数字类型转字符串&lt;/p&gt;
&lt;p&gt;a)     Strong()    b)变量.toString()&lt;/p&gt;
&lt;p&gt;1.     字符串转数字类型&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Number()  &lt;/li&gt;
&lt;li&gt;数字类型和小数类型字符串,转换成数字,&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非数字字符串,转换成NaN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;parseInt()&lt;/li&gt;
&lt;li&gt;数字开头的字符串,转换之后得到前面的数字&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非数字---NaN    小数---取整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;parseFloat&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;跟parseInt同理,不同点是 小数---小数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.     转布尔类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;  数字和字符串       true  &lt;/li&gt;
&lt;li&gt;  undefined null  0   false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.     逻辑运算符&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;&amp;amp;与  ||或   !非&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等号运算符&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;“==”  只判断内容不判断数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;“===” 判断内容还判断数字类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;“!==” 不仅判断内容还判断数字类型&lt;/li&gt;
&lt;li&gt;条件判断&lt;/li&gt;
&lt;li&gt;If(条件){true内容}else{false内容}&lt;/li&gt;
&lt;li&gt;If(条件){true的内容false执行下面内容}else if(条件){true的内容}else{}&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;While(条件表达式){true循环执行,false,循环终止}&lt;/li&gt;
&lt;li&gt;Break语句    只要代码遇到break,程序立即停止&lt;/li&gt;
&lt;li&gt;Continue      跳出本次循环,整个循环继续执行&lt;/li&gt;
&lt;li&gt;Switch(条件){循环体}&lt;/li&gt;
&lt;li&gt;三元表达式&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;  表达式?true:false;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;优先级&lt;/li&gt;
&lt;li&gt;()优先级最高  一元运算符++  -- !&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;/  %  +    -&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果我们想把函数内部的值赋值为外部,必须使用return;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果没有return或者return没有值,那么返回值都是undefined&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;//隐式全局变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//隐式全局变量
function fn(){
    //b和c都是隐式全局变量
    var a = b = c = 1;
    //e和f都是隐式全局变量(分号相当于换行)
    var d = 1;e =2;f=3;
    //g和i都不是隐式全局变量
    var g = 1,h= 2,i=3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对象本身没有length,所以不能用for循环遍历&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;11. for(var k in aaa){ // console.log(k); // //aaa.k代表aaa这个对象的k属性的值，并不是k对应的变量值的属性。 //// console.log(aaa.k); // //aaa[k],代表的是aaa这个对象中k这个变量值对应的属性值。 // console.log(aaa[k]); // }&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调用函数的时候，传参的过程其实就是用实参给形参赋值的过程&lt;/li&gt;
&lt;li&gt;   当参数为值类型的时候，函数内和函数外的两个变量完全不同，仅仅只是存的值一样而已，修改时互不影响&lt;/li&gt;
&lt;li&gt;   当参数为引用类型的时候，函数内和函数外的两个变量不同，但是共同指向同一个对象，在函数内修改对象数据时会影响外部&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    var num = 1;
    fn1(num);
    console.log(num);
    function fn1(aaa){
        aaa = aaa*10;
    }
    //复杂数据类型
   var obj = new Object();
    obj.name = &quot;张三&quot;;
   fn2(obj);
    console.log(obj);
    function fn2(object){
       object.name = &quot;李四&quot;;
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;五 判断数组和转换数组。&lt;/p&gt;
&lt;p&gt;Instanceof:  是一个关键字。    判断A是否是B类型。&lt;/p&gt;
&lt;p&gt;布尔类型值 = A Instanceof B ;&lt;/p&gt;
&lt;p&gt;Array.isArray() //HTML5中新增    判断是不是数组&lt;/p&gt;
&lt;p&gt;布尔类型值 = Array.isArray(变量) ;&lt;/p&gt;
&lt;p&gt;调用者：Array            参数：变量(被检测值)          返回值：布尔类型   &lt;/p&gt;
&lt;p&gt;toString()       //把数组转换成字符串，每一项用,分割&lt;/p&gt;
&lt;p&gt;字符串  =  数组.toString();&lt;/p&gt;
&lt;p&gt;valueOf()       //返回数组对象本身&lt;/p&gt;
&lt;p&gt;数组本身 = 数组.valueOf();&lt;/p&gt;
&lt;p&gt;Join               //根据每个字符把数组元素连起来变成字符串&lt;/p&gt;
&lt;p&gt;字符串  =  数组.join(变量);&lt;/p&gt;
&lt;p&gt;变量可以有可以没有。不写默认用逗号分隔，无缝连接用空字符串。&lt;/p&gt;
&lt;p&gt;六 数组增删和换位置（原数组讲被修改）&lt;/p&gt;
&lt;p&gt;push() &lt;/p&gt;
&lt;p&gt;pop()  &lt;/p&gt;
&lt;p&gt;unshift() &lt;/p&gt;
&lt;p&gt;shift()  &lt;/p&gt;
&lt;p&gt;reverse()&lt;/p&gt;
&lt;p&gt;sort(); &lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;给数组排序，返回排序后的数组。如何排序看参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;从小到大排序后的数组 =  数组1.sort(function(a,b){   return a-b;});&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无参：按照数组元素的首字符对应的Unicode编码值从小到大排列数组元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;带参：必须为函数（回调函数--callback）。函数中带有两个参数，代表数组中的          前后元素。如果计算后（a-b），返回值为负数，a排b前面。等于0不动。        返回值为正数，a排b后面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;concat() &lt;/p&gt;
&lt;p&gt;slice()&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新数组 = 数组1.slice(索引1，索引2);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;splice()&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;删除或替换当前数组的某些项目，参数start,deleteCount,options(要替换的项目)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新数组 = 数组1.splice(起始索引，结束索引，替换内容);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;indexOf()、lastIndexOf()  &lt;/p&gt;
&lt;p&gt;迭代方法 不会修改原数组&lt;/p&gt;
&lt;p&gt;every()、filter()、forEach()、map()、some()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数组/boolean/无 = 数组.every/filter/forEach/map/some(
                            function(element,index,arr){
                                            程序和返回值；                       
   }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 这个属于ES6的内容我还是在后面详细介绍吧&lt;/p&gt;
&lt;p&gt;清空数组&lt;/p&gt;
&lt;p&gt;var array = [1,2,3,4,5,6];&lt;/p&gt;
&lt;p&gt;array.splice(0,array.length); //删除数组中所有项目&lt;/p&gt;
&lt;p&gt;array.length = 0; //length属性可以赋值，其它语言中length是只读&lt;/p&gt;
&lt;p&gt;array = [];  //推荐&lt;/p&gt;
</description>
<pubDate>Fri, 16 Feb 2018 07:13:00 +0000</pubDate>
<dc:creator>房东家的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fangdongdemao/p/8450218.html</dc:identifier>
</item>
<item>
<title>DaemonSet 案例分析 - 每天5分钟玩转 Docker 容器技术（130） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8449209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8449209.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;本节详细分析两个 k8s 自己的 DaemonSet：&lt;/span&gt;&lt;code&gt;kube-flannel-ds&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;kube-proxy&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;下面我们通过分析 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-flannel-ds&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来学习 DaemonSet。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得之前是如何部署 flannel 网络的吗？我们执行了如下两个命令：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;flannel 的 DaemonSet 就定义在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-flannel.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180215053858624-504869558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：配置文件的完整内容要复杂些，为了更好地学习 DaemonSet，这里只保留了最重要的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① DaemonSet 配置文件的语法和结构与 Deployment 几乎完全一样，只是将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kind&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DaemonSet&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② hostNetwork 指定 Pod 直接使用的是 Node 的网络，相当于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker run --network=host&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。考虑到 flannel 需要为集群提供网络连接，这个要求是合理的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;containers&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义了运行 flannel 服务的两个容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们再来分析另一个 DaemonSet &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-proxy&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;由于无法拿到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-proxy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 YAML 文件，只能运行如下命令查看其配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl edit daemonset kube-proxy --namespace=kube-system&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180215053918234-849859794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样为了便于理解，这里只保留了最重要的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;kind: DaemonSet&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定这是一个 DaemonSet 类型的资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② &lt;/span&gt;&lt;code&gt;&lt;span&gt;containers&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-proxy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;status&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是当前 DaemonSet 的运行时状态，这个部分是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl edit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;特有的。其实 Kubernetes 集群中每个当前运行的资源都可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl edit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看其配置和运行状态，比如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl edit deployment nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下节我们讨论如何运行自己的 DaemonSet。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 23:22:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8449209.html</dc:identifier>
</item>
</channel>
</rss>