<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CI脚本异常退出问题定位 - BookShu</title>
<link>http://www.cnblogs.com/styshoo/p/7797175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/styshoo/p/7797175.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;　　在CI脚本中，使用类似如下脚本进行项目编译的计时，但在执行过程中，有时会出现CI脚本(命名为ci.sh)未完全执行的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash -e

sleep_time=$1

start_time=`date  &quot;+%s&quot;`
# do sth, this sleep would simulate project compilation
sleep $sleep_time
end_time=`date  &quot;+%s&quot;`

process_time=`expr \( end_time - start_time \)`
echo &quot;---- process time(sec) are: &quot; $process_time &quot;seconds&quot;

# ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　这个脚本，只是模拟我们在CI中的程序，项目编译前计时，项目编译后再次计时，通过sleep休眠来模拟CI中项目编译锁消耗的时间，然后计算出消耗的时间。这个简化的脚本逻辑很简单，我们通过以下命令来调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ./ci.sh
---- process time(sec) are:  2 seconds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　这样执行好像并不会出错，那实际CI中为什么会出错呢？&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;　　首先，我们发现，当出现脚本未完全执行完成时，不会打印“process time(sec) are”这一句，也就是说错误是这句之前引起的。&lt;br/&gt;　　另外，细心的朋友还会发现，在脚本的首行，我们给bash使用了-e参数，这个参数的作用就是，一旦shell脚本中任何一行出现了错误，shell脚本就停止运行。所谓的出现错误，也就是这行语句的返回值为非零。那么，CI脚本未完全执行的原因，很可能就是因为某一行语句出现了错误，导致脚本直接退出。&lt;br/&gt;　　通过增加打印“echo $?”来打印上一行语句的执行结果，很快定位到报错的语句在计算处理时间的这一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;process_time=`expr \( end_time - start_time \)`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　这一行看起来十分普通，只是简单的用终止时间减去开始时间，然后赋值给process_time。为什么会返回非0值呢？&lt;br/&gt;　　原来，expr命令有一个小小的trick，当expr表达式中的计算结果为0时，expr命令就会返回1，而不是通常的0。在我们实际的CI任务中，一旦某个项目编译时间非常短，在1秒钟内完成，那么起止时间系统，其差值也就为0，因此，expr就会返回非零值，而CI脚本也会因此而退出。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 22:51:00 +0000</pubDate>
<dc:creator>BookShu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/styshoo/p/7797175.html</dc:identifier>
</item>
<item>
<title>iOS 中的 Delayed Transition - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7796629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7796629.html</guid>
<description>&lt;p&gt;Android 的动画体系中,存在一类由 &lt;strong&gt;TransitionManager. beginDelayedTransition&lt;/strong&gt; 管理的动画.这个方法,很特殊.执行此方法后,其后续的 UI 变化,不会立即作用到视图上,而是等下一次更新周期到来时,以动画的形式批量作用到视图上.&lt;/p&gt;
&lt;p&gt;至少在我看来,这种设定很新颖.写法也很自然.除此之外,它能批量执行多个 UI 属性值变化的特性,也让人眼前一亮.&lt;/p&gt;
&lt;p&gt;iOS 动画,用的最多的也最顺手的是 &lt;strong&gt;animateWithDuration&lt;/strong&gt;, 总感觉它有点 &lt;strong&gt;Delayed Transition&lt;/strong&gt; 的感觉,应该也可以实现类似的执行批量动画的效果.以前,大都是在 Block 里面写某一个视图,某一个属性的变化后的值.那加入里面,同时写多个视图的多个属性变化的值,会发生什么事呢?&lt;/p&gt;
&lt;p&gt;竟然真的是,会批量执行多个动画效果,很酷.感兴趣的,可以自己跑下代码.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/801860/201711/801860-20171107023644263-569979730.gif&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;oc&quot;&gt;
&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIView * viewA = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 100, 100)];
    viewA.backgroundColor = [UIColor redColor];
    [self.view addSubview:viewA];

    UIView * viewB = [[UIView alloc] initWithFrame:CGRectMake(0, 100, 100, 100)];
    viewB.backgroundColor = [UIColor blueColor];
    [self.view addSubview:viewB];

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [UIView animateWithDuration:3 animations:^{
            viewA.frame = CGRectMake(100, 150, 30, 100);
            viewA.backgroundColor = [UIColor orangeColor];

            viewB.frame = CGRectMake(200, 30, 100, 20);
            viewB.backgroundColor = [UIColor grayColor];
        }];
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外,Android 动画的 Scene 设定,也会特别,让我对动画的理解又进了一层.Scene 中,存储的是视图的状态视图,而不是一个图片形式的截图.所以,基于两个 Scene,可以做到节点级别的动画切换. Android 中的Scenne,会在 id 相同的节点间加动画效果.如此,也就能解决了我一直以来的一个困惑: 基于图片, 为什么有些 App 可以实现那么复杂精确的动画效果?==&amp;gt; 因为根本就不是以图片来记录视图某一瞬间的状态的,而是真的会记录下视图的完整状态信息.&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/transitions/transitions.html&quot; class=&quot;uri&quot;&gt;https://developer.android.com/training/transitions/transitions.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 18:38:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7796629.html</dc:identifier>
</item>
<item>
<title>逆向课程第二讲,寻找main入口点 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7796373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7796373.html</guid>
<description>&lt;h2&gt;一丶识别各个程序的入口点&lt;/h2&gt;
&lt;p&gt;入门知识,识别各个应用程序的入口点&lt;/p&gt;
&lt;p&gt;(举例识别VC 编译器生成,以及VS编译生成的Debug版本以及Release版本)&lt;/p&gt;
&lt;h2&gt;1.识别VC6.0 Debug版本&lt;/h2&gt;
&lt;p&gt;1.1 首先,新建一个VC debug版本的程序,然后F5运行,可以看到栈回溯窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107004124044-1554368794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2 而后通过栈回溯窗口,点击mainCRTStarup,查看main函数之前会调用什么API&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107004238669-352237988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确定之后,OD打开查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107004630309-1548447012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到调用API的位置,但是怎么确定那个是入口点,我们知道,  VC中的main函数是3个参数,那么我们只需要找到&lt;/p&gt;
&lt;p&gt;三个push 然后一个Call的位置,则可以确定,(确定也是要你F7跟进去,看看代码是不是main函数的代码,或者参数传参是什么)&lt;/p&gt;
&lt;p&gt;1.3确定main入口点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005008716-1582613305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图可以看到,三个push,然后一个Call,那么我们跟进去查看,因为是Debug版本,所以已经提示出来参数是什么了&lt;/p&gt;
&lt;p&gt;所以直接可以确定了.&lt;/p&gt;
&lt;p&gt;1.4 F7跟进去查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005147247-1675799815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以直接确定使我们的入口点&lt;/p&gt;
&lt;p&gt;IDA查看一次&lt;/p&gt;
&lt;p&gt;步骤和前边一样,先看入口点特征,Debug版本特征是调用API GetVersion&lt;/p&gt;
&lt;p&gt;所以IDA中查看.&lt;/p&gt;
&lt;p&gt;1.查看文本视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005426169-1617501902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.展开文本视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005446700-1319661936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里提示你要CTRL +  加号 展开&lt;/p&gt;
&lt;p&gt;展开查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005532059-724989218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3.根据特征,读取代码,确定main位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005606872-543948751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是Debug所以有符号显示 下面直接看Release版本&lt;/p&gt;
&lt;h2&gt;2.查看VC6.0 Release版本&lt;/h2&gt;
&lt;p&gt;首先,特征是一样的,都是调用GetVersion&lt;/p&gt;
&lt;p&gt;那么现在直接OD打开去分析.(当然IDA也可以,都是工具)&lt;/p&gt;
&lt;p&gt;1.一样,先找特征&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005949075-227244482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.找到之后,因为我们写的是main,所以判断是main,只要找到三个push一个Call即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107005927716-37239719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 已经找到了 F7 跟进去查看.&lt;/p&gt;
&lt;p&gt;3.确认是不是.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107010115294-1311840219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,因为是Release版本,所以都给优化没了.确实使我们写的代码&lt;/p&gt;

&lt;h2&gt;3.查看VS系列 Debug版本(没个版本不一样,所以先看下特征这里是 VS 2015)&lt;/h2&gt;
&lt;p&gt;1.栈回溯,确定入口点特征&lt;/p&gt;
&lt;p&gt;首先第一步,还是编写一段代码&lt;/p&gt;
&lt;p&gt;然后通过栈回溯,查看入口的特征.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107011725528-1108214793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我觉着,这个是入口点的特征,而在tmainCRTStartup里面调用的wmain&lt;/p&gt;
&lt;p&gt;那么此时OD打开的时候可以分析遇到的第二个call,然后在第二个call里面跟进去.&lt;/p&gt;
&lt;p&gt;通过栈回溯,可以看到会调用这种API,而下方的截图则会调用wmain,所以OD打开,不断的跟,也是三个push 一个Call&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107011556872-621367497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.OD分析&lt;/p&gt;
&lt;p&gt;因为是Debug版本,有跳转表,也可以看到符号信息,所以直接跳转过来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107011947809-877225582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转过来之后(看下图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012019919-219178063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到确实是两个Call,也就是我们上面分析的,然后进入第二个Call&lt;/p&gt;
&lt;p&gt;3.确定入口点位置&lt;/p&gt;
&lt;p&gt;F7跟进去,查找三个push  一个Call&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012223341-1230369370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了,我们跟进去查看,看看是否是入口点,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012252075-114380056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进去之后发现又有一层跳转表,没关系,F8 走过去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012327341-805766350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟过来之后则会发现确实使我们入口点写的代码了&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;4. VS系列,查看Release版本&lt;/h2&gt;
&lt;p&gt;Release版本是一样的,直接IDA打开查看(换着工具看)&lt;/p&gt;
&lt;p&gt;1.进去IDA,打开入口点,CTRL + 加号展开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012836981-2121338882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CTRL + 加号展开不做演示,同上面分析一样.&lt;/p&gt;
&lt;p&gt;查看反汇编&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107012958325-1586891840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现IDA直接跟过来的就是这个,那么此时好办了,我们知道main在它的下面,那么直接寻找三个push 一个Call即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107013048825-1394407103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;找到了,双击_main确认一下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171107013112450-1613647898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们刚才写的代码已经出来了&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 17:33:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7796373.html</dc:identifier>
</item>
<item>
<title>Android模仿iOS iMessages10照片选择器的实现 - CKTim</title>
<link>http://www.cnblogs.com/cxk1995/p/7791312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxk1995/p/7791312.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;不知不觉已经接近半年多没有写过博客了，这段时间，也是我刚好毕业走出校园的时间，由于学习工作的原因，一直没有真正静下心来写下些什么东西。&lt;/span&gt;&lt;span&gt;这个星期刚入了小米笔记本pro的坑，本着新电脑新生活的理念嘻嘻--，我决定把&lt;/span&gt;&lt;span&gt;这半年来在工作遇到的一些技术难点分享出来，同时也加深自己的一些理解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、效果展示：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示，是Android端参考iOS iMessages10照片选择器所实现的一个效果：（就是一个小相机+最近照片列表的效果）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                          &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171106224756528-310712452.gif&quot; alt=&quot;&quot;/&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171106001335451-1507890871.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、实现思路：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚开始看到这样的一种功能时，我相信很多Android开发程序员都会菊花一紧吧，初看会让人觉得很难实现（可能我比较菜），但其实我们仔细分析下，并没有想象中那么难，首先我们可以先构思一下布局要如何去实现，让自己有一个大概的思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;滑动列表我们顺其自然的想到用Recycleview来实现，关于小相机+相册和拍照按钮这两个我们可以尝试用添加头部的方式添加到Recycleview里面去，以此达到整体的滑动效果，这样想想似乎很完美，没有毛病，接下来就想办法把小相机弄出来就好了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚开始我就是上面这样的一种思路，大概效果也根据这个思路实现了出来，&lt;span&gt;但是这里有一个问题我们忽略掉了，就是Recycleview的复用问题，如果小相机作为头部添加到Recycleview里面去，当滑动列表，小相机从不可见变为可见时，因为复用会导致每次都去重新加载这个小相机，导致滑动非常卡，体验非常不好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种布局体验不好，那我们就换一种实现方式，我相信很多人也都想到了，把相册和拍照按钮+小相机+Recycleview的三个布局顺序排放，在它们的外面嵌套一层Horizontalscrollview，这样同样能达到我们的目的，&lt;span&gt;但这种方式同样有一个小坑，Horizontalscrollview和Recycleview相互嵌套会使得Recycleview显示不全（只显示一行）&lt;/span&gt;，不过这个问题我们可以通过动态计算Recycleview的宽度来解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总体思路有了，我们就一步一步来实现我们所需要的效果吧，首先要讲的也是本篇最为重要的一个点，就是小相机的实现方式，其实也就是对Android Camera2的使用，关于Camera2我就不做过多的介绍了，它其实就是安卓5.0开始（API Level 21）的一个新的相机API，可以用来完全控制安卓相机设备。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、小相机的实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.首先我们应该在布局文件中定义一个TextureView，这个TextureView主要用来装载显示我们所获取到的相机数据，通俗一点来讲，这个TextureView就是我们的小相机啦，这里TextureView的宽高可以由我们自己来设定，但是这里需要注意一点，&lt;span&gt;宽高应该按照一定的比例来设定，不然相机数据会被拉伸，例如我们可以使用4：3或者16：9的比例来设定&lt;/span&gt;，布局代码简单如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;TextureView
     android:id&lt;/span&gt;=&quot;@+id/textureView&quot;&lt;span&gt;
     android:layout_width&lt;/span&gt;=&quot;90dp&quot;&lt;span&gt;
     android:layout_height&lt;/span&gt;=&quot;160dp&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.接下来要先初始化TextureView，首先让TextureView所在的Activity继承TextureView.SurfaceTextureListener这个接口，这个接口需要重写四个方法，分别为：onSurfaceTextureAvailable、onSurfaceTextureSizeChanged、onSurfaceTextureDestroyed、onSurfaceTextureUpdated，重写后调用如下代码进行初始化TextureView：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initTextureView() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们这里顺便new一个handler出来，后面会用到&lt;/span&gt;
        mCameraThread = &lt;span&gt;new&lt;/span&gt; HandlerThread(&quot;CameraThread&quot;&lt;span&gt;);
        mCameraThread.start();
        mCameraHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(mCameraThread.getLooper());

        mTextureView.setSurfaceTextureListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.重写的这四个方法中，看名字我们也大概猜到它的意思了，这里我们主要看的是onSurfaceTextureAvailable这个方法，这个方法也是我们最核心的一个方法，当Activity接收到这个方法的回调时，则代表我们的TextureView已准备就绪，此时可以进行相关的相机设置并打开我们的相机获取数据，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
　　 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * *****************************TextureView.SurfaceTextureListener******************************
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onSurfaceTextureAvailable(SurfaceTexture surface, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当SurefaceTexture可用的时候，设置相机参数并打开相机&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;

        setupCamera(width, height);
        openCamera(mCameraId);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onSurfaceTextureSizeChanged(SurfaceTexture surface, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onSurfaceTextureDestroyed(SurfaceTexture surface) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onSurfaceTextureUpdated(SurfaceTexture surface) {

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.接下来我们看setupCamera这个方法里面是如何配置相机的，直接看代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setupCamera(&lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取摄像头的管理者CameraManager&lt;/span&gt;
        CameraManager manager =&lt;span&gt; (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有摄像头&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String cameraId : manager.getCameraIdList()) {
                CameraCharacteristics characteristics &lt;/span&gt;=&lt;span&gt; manager.getCameraCharacteristics(cameraId);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是后置摄像头，这个判断是检测哪一个是前置摄像头并进行相关记录（为了后面可以点击切换前后摄像头）&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (characteristics.get(CameraCharacteristics.LENS_FACING) ==&lt;span&gt; CameraCharacteristics.LENS_FACING_FRONT) {
                    mCameraIdFront &lt;/span&gt;=&lt;span&gt; cameraId;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    mCameraId &lt;/span&gt;=&lt;span&gt; cameraId;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取StreamConfigurationMap，它是管理摄像头支持的所有输出格式和尺寸&lt;/span&gt;
                StreamConfigurationMap map =&lt;span&gt; characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据TextureView的尺寸设置预览尺寸&lt;/span&gt;
                mPreviewSize = getOptimalSize(map.getOutputSizes(SurfaceTexture.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;), width, height);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取相机支持的最大拍照尺寸&lt;/span&gt;
                mCaptureSize = Collections.max(Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)), &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Size&amp;gt;&lt;span&gt;() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Size lhs, Size rhs) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Long.signum(lhs.getWidth() * lhs.getHeight() - rhs.getHeight() *&lt;span&gt; rhs.getWidth());
                    }
                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此ImageReader用于拍照所需&lt;/span&gt;
&lt;span&gt;                setupImageReader();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; getOptimalSize这个方法作用是根据TextureView的尺寸大小来获取一个合适的预览尺寸，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择sizeMap中大于并且最接近width和height的size&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Size getOptimalSize(Size[] sizeMap, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height) {
        List&lt;/span&gt;&amp;lt;Size&amp;gt; sizeList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Size option : sizeMap) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (width &amp;gt;&lt;span&gt; height) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (option.getWidth() &amp;gt; width &amp;amp;&amp;amp; option.getHeight() &amp;gt;&lt;span&gt; height) {
                    sizeList.add(option);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (option.getWidth() &amp;gt; height &amp;amp;&amp;amp; option.getHeight() &amp;gt;&lt;span&gt; width) {
                    sizeList.add(option);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sizeList.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Collections.min(sizeList, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Size&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Size lhs, Size rhs) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Long.signum(lhs.getWidth() * lhs.getHeight() - rhs.getWidth() *&lt;span&gt; rhs.getHeight());
                }
            });
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sizeMap[0&lt;span&gt;];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;setupImageReader是对ImageReader的一个简单配置，&lt;span&gt;在ImageReader这里我们可以获取到小相机所拍摄到的照片，可以在这里进行相关存储照片等操作&lt;/span&gt;，这里我把拍完的照片（如何拍照请看后面）保存到了SD卡根目录的/ifreegroup/CameraV2/文件夹中，&lt;span&gt;需要注意的一点是：这里如果保存完后想进行一些刷新界面的操作，需要使用Handler和Message的方式，不要直接在setOnImageAvailableListener回调中进行，不然会报错，&lt;/span&gt;代码代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ImageReader mImageReader;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setupImageReader() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2代表ImageReader中最多可以获取两帧图像流&lt;/span&gt;
        mImageReader =&lt;span&gt; ImageReader.newInstance(mCaptureSize.getWidth(), mCaptureSize.getHeight(),
                ImageFormat.JPEG, &lt;/span&gt;2&lt;span&gt;);&lt;br/&gt;　　　　　
        mImageReader.setOnImageAvailableListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImageReader.OnImageAvailableListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onImageAvailable(ImageReader reader) {
                Image mImage &lt;/span&gt;=&lt;span&gt; reader.acquireNextImage();
                ByteBuffer buffer &lt;/span&gt;= mImage.getPlanes()[0&lt;span&gt;].getBuffer();
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[buffer.remaining()];
                buffer.get(data);
                String path &lt;/span&gt;= Environment.getExternalStorageDirectory() + &quot;/ifreegroup/CameraV2/&quot;&lt;span&gt;;
                File mImageFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(path);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mImageFile.exists()) {
                    mImageFile.mkdir();
                }
                String timeStamp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
                String fileName &lt;/span&gt;= path + &quot;IMG_&quot; + timeStamp + &quot;.jpg&quot;&lt;span&gt;;
                FileOutputStream fos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(fileName);
                    fos.write(data, &lt;/span&gt;0&lt;span&gt;, data.length);

                    Message msg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
                    msg.what &lt;/span&gt;=&lt;span&gt; CAPTURE_OK;
                    msg.obj &lt;/span&gt;=&lt;span&gt; fileName;
                    mCameraHandler.sendMessage(msg);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            fos.close();
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
                mImage.close();
            }
        }, mCameraHandler);

        mCameraHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(Message msg) {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.handleMessage(msg);
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (msg.what) {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CAPTURE_OK:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片已经保存好了，在这里做你想做的事&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        };
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.到这里我们的相机已经配置完毕了，一切准备就绪，接下来就去打开相机吧，这里指的是使用Camera2 API 打开我们的相机数据，而不是指调用打开我们的系统相机，关于怎么打开相机，这里分装成了一个方法openCamera(mCameraId)，也就是我们上面在onSurfaceTextureAvailable所调用的方法，这个方法又是怎样的呢，我们也直接来看代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openCamera(String CameraId) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取摄像头的管理者CameraManager&lt;/span&gt;
        CameraManager manager =&lt;span&gt; (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查权限&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.CAMERA) !=&lt;span&gt; PackageManager.PERMISSION_GRANTED) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开相机，第一个参数指示打开哪个摄像头，第二个参数stateCallback为相机的状态回调接口，第三个参数用来确定Callback在哪个线程执行，为null的话就在当前线程执行&lt;/span&gt;
            manager.openCamera(CameraId, mStateCallback, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CameraAccessException e) {
            e.printStackTrace();
        }
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; CameraDevice.StateCallback mStateCallback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CameraDevice.StateCallback() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onOpened(CameraDevice camera) {
            mCameraDevice &lt;/span&gt;=&lt;span&gt; camera;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相机已打开，此时可以开启我们的小相机预览&lt;/span&gt;
&lt;span&gt;            startPreview();
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDisconnected(CameraDevice camera) {
            camera.close();
            mCameraDevice &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onError(CameraDevice camera, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; error) {
            camera.close();
            mCameraDevice &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    };            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6.配置好了相机，也打开了相机，接下来就去开启我们的小相机预览吧，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startPreview() {
        SurfaceTexture mSurfaceTexture &lt;/span&gt;=&lt;span&gt; mTextureView.getSurfaceTexture();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mSurfaceTexture != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置TextureView的缓冲区大小&lt;/span&gt;
&lt;span&gt;            mSurfaceTexture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Surface显示预览数据&lt;/span&gt;
            Surface mSurface = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Surface(mSurfaceTexture);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建CaptureRequestBuilder，TEMPLATE_PREVIEW比表示预览请求&lt;/span&gt;
                mCaptureRequestBuilder =&lt;span&gt; mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Surface作为预览数据的显示界面&lt;/span&gt;
&lt;span&gt;                mCaptureRequestBuilder.addTarget(mSurface);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建相机捕获会话，第一个参数是捕获数据的输出Surface列表，第二个参数是CameraCaptureSession的状态回调接口，当它创建好后会回调onConfigured方法，第三个参数用来确定Callback在哪个线程执行，为null的话就在当前线程执行&lt;/span&gt;
                mCameraDevice.createCaptureSession(Arrays.asList(mSurface, mImageReader.getSurface()), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CameraCaptureSession.StateCallback() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onConfigured(CameraCaptureSession session) {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建捕获请求&lt;/span&gt;
                            mCaptureRequest =&lt;span&gt; mCaptureRequestBuilder.build();
                            mCameraCaptureSession &lt;/span&gt;=&lt;span&gt; session;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置反复捕获数据的请求，这样预览界面就会一直有数据显示&lt;/span&gt;
                            mCameraCaptureSession.setRepeatingRequest(mCaptureRequest, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, mCameraHandler);

                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                            e.printStackTrace();
                        }
                    }

                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onConfigureFailed(CameraCaptureSession session) {

                    }
                }, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CameraAccessException e) {
                e.printStackTrace();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;7.如何拍照呢？也很简单，这里我也分装成了一个方法capture()，每次拍照只需要调用这个方法就行了，&lt;span&gt;这里有一点需要注意一下，就是前置摄像头拍完照后照片会变歪，所以需要我们自己手动旋转一下，&lt;/span&gt;代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拍照方向&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SparseIntArray ORIENTATION = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparseIntArray();

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        ORIENTATION.append(Surface.ROTATION_0, &lt;/span&gt;90&lt;span&gt;);
        ORIENTATION.append(Surface.ROTATION_90, &lt;/span&gt;0&lt;span&gt;);
        ORIENTATION.append(Surface.ROTATION_180, &lt;/span&gt;270&lt;span&gt;);
        ORIENTATION.append(Surface.ROTATION_270, &lt;/span&gt;180&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; capture() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mCameraDevice == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CaptureRequest.Builder mCaptureBuilder =&lt;span&gt; mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rotation =&lt;span&gt;activity.getWindowManager().getDefaultDisplay().getRotation();
            mCaptureBuilder.addTarget(mImageReader.getSurface());
            &lt;/span&gt;&lt;span&gt;//CameraFront是自定义的一个boolean值，用来&lt;/span&gt;&lt;span&gt;判断是不是前置摄像头，是的话需要旋转180°，不然拍出来的照片会歪了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CameraFront) {
                mCaptureBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATION.get(Surface.ROTATION_180));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                mCaptureBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATION.get(rotation));
            }

            CameraCaptureSession.CaptureCallback CaptureCallback &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CameraCaptureSession.CaptureCallback() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCaptureCompleted(CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result) {
                    unLockFocus();
                }
            };
            mCameraCaptureSession.stopRepeating();
            mCameraCaptureSession.capture(mCaptureBuilder.build(), CaptureCallback, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unLockFocus() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            mCaptureRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mCameraCaptureSession.capture(mCaptureRequestBuilder.build(), null, mCameraHandler);&lt;/span&gt;
            mCameraCaptureSession.setRepeatingRequest(mCaptureRequest, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, mCameraHandler);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CameraAccessException e) {
            e.printStackTrace();
        }
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8.如果你跟着上面一步一步的敲下来，那么你的小相机估计也能看到后置摄像头数据并实现拍照保存照片了~ ，如果不行，好好在回去校对看有没有哪里写错了吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.前后摄像头的切换功能，关于这个实现非常简单，已知我们前面在配置相机的时候已经对前摄像头的ID进行了记录，我们只需要重新的调用 setupCamera()和openCamera()这两个方法重新刷新下界面就可以了，代码如下：（代码中mCameraIdFront是前置摄像头ID，mCameraId是后置摄像头ID，想要打开哪个摄像头，只需要将相关ID传入openCamera(id)这个方法里面就可以了）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; CameraFront;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; switchCamera() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mCameraDevice != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mCameraDevice.close();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CameraFront) {
            setupCamera(width, height);
            openCamera(mCameraId);
            CameraFront &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            setupCamera(width, height);
            openCamera(mCameraIdFront);
            CameraFront &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;10.这里有个小坑，&lt;span&gt;就是在小相机在已经加载好的情况下，如果你在其他地方调用到了系统相机，当你回到小相机页面时，你会发现小相机没有了预览数据，所以这里我还定义了一个刷新相机界面的方法，同样是调用 setupCamera()和openCamera()这两个方法，供我们在必要合适的时候重新刷新一下小相机数据，防止其黑屏，&lt;/span&gt;代码如下所示，代码里的mCameraId是我们前面获取到的后置摄像头ID，这里表示刷新后默认先打开后置摄像头&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshCamera() {
        setupCamera(width, height);
        openCamera(mCameraId);
        CameraFront &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;到这里，我们的小相机基本功能已经可以使用了，接下来只需要把Recycleview列表加上去就好了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;四、Recycleview列表显示最近保存的照片：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.这里主要是提供一个可以获取最近保存到手机图片的方法，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt; getNearImags(Context context) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
        ArrayList&lt;/span&gt;&amp;lt;String&amp;gt; img_path = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取SDcard卡的路径&lt;/span&gt;
        String sdcardPath =&lt;span&gt; Environment.getExternalStorageDirectory().toString();

        ContentResolver mContentResolver &lt;/span&gt;=&lt;span&gt; context.getContentResolver();
        Cursor mCursor &lt;/span&gt;=&lt;span&gt; mContentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA},
                MediaStore.Images.Media.MIME_TYPE &lt;/span&gt;+ &quot;=? OR &quot; + MediaStore.Images.Media.MIME_TYPE + &quot;=?&quot;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[]{&quot;image/jpeg&quot;, &quot;image/gif&quot;}, MediaStore.Images.Media._ID + &quot; DESC&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取ipg和gif图片，并按图片ID降序排列&lt;/span&gt;

        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (mCursor.moveToNext()) {
            count&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉不需要的图片，只获取拍照后存储照片的相册里的图片&lt;/span&gt;
            String path =&lt;span&gt; mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DATA));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只取前30张&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (count &amp;gt; 30&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        mCursor.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; img_path;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;五、动态计算RecycleView的宽度：&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recycleview的LayoutManager我使用的是StaggeredGridLayoutManager，设置的是两行，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;photoRecycleView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.HORIZONTAL));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列表总共两行并且是固定的，这就比较好办了，我们获取拿到的照片总数，然后看其能不能被2整除，可以的话只要除以2然后乘以每一个item的宽度就是Recycleview的宽度了，如果不可以被2整除，那么还需要再加多一个item的宽度，代码如下：（这里的128dp是我默认的每一个item的宽度）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态计算recycleview高度&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (getNearImags(context) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; getNearImags(context).size();
            ViewGroup.LayoutParams mParams &lt;/span&gt;=&lt;span&gt; photoRecycleView.getLayoutParams();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size % 2 == 0&lt;span&gt;) {
                mParams.width &lt;/span&gt;= ScreenUtil.dip2px(128) * size / 2&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                mParams.width &lt;/span&gt;= ScreenUtil.dip2px(128) * (size / 2) + 1&lt;span&gt;;
            }
            photoRecycleView.setLayoutParams(mParams);
        }
        photoRecycleView.setAdapter(adapter);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;到这里，关于Android模仿iOS iMessages10照片选择器的实现思路大概就是这样了，这个过程中遇到的坑也都进行了红色标注，因为是集成在项目里面的，暂时还没有DEMO，如果有其他的问题，欢迎大家一起讨论~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ：471497226@qq.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 17:05:00 +0000</pubDate>
<dc:creator>CKTim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxk1995/p/7791312.html</dc:identifier>
</item>
<item>
<title>玩玩Qt（一） - bearyin</title>
<link>http://www.cnblogs.com/yxfangcs/p/7796003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxfangcs/p/7796003.html</guid>
<description>&lt;p&gt;最近在看一些关于游戏引擎的东西，本来是有几个游戏的小点子，其实实现起来还挺麻烦的，想找个游戏引擎看看能不能码起来。辗转之后发现了很多2D引擎，其中国产的要数cocos2dx用的好像是比较广泛，但是好多人对此褒贬不一。于是下了准备试试到底怎么样，无奈搞了一早上，也有点小成果，但是想实现起来貌似还得花点功夫，想想还是找其他的算了。正好之前用过Qt，于是重新捡起来。&lt;/p&gt;

&lt;p&gt;在Qt上想要渲染性能好点，我想还是得用OpenGL这一类东西的，之前一直对OpenGL这类东西不是很清楚，于是研究了不少时间。我想很多人对这个什么显示服务器，OpenGL等等这些东西也是云里雾里的，先来聊聊这些东西，丰富一下知识。&lt;/p&gt;
&lt;p&gt;1、关于显示服务器，最近看的最多的就是Ubuntu17.10把默认显示服务器改成了wayland这个东西。根据我的理解，有了显示服务器，我们才可以用窗口系统，显示服务器的客户端就是窗口系统，显示服务器为我们的窗口系统提供画面绘制，输入事件等功能，至于输入事件，常见的就是鼠标键盘事件了。&lt;/p&gt;
&lt;p&gt;2、然后就是OpenGL，OpenGL是一个跨平台的图形接口，OpenGL是和显卡有关系的，只有显卡提供支持，才可以用OpenGL的，当然OpenGL是和显卡厂商有协商的。有了OpenGL，我们就可以用显卡来处理关于图形图像的东西，然后交给显示服务器进行显示。&lt;/p&gt;
&lt;p&gt;3、但是这边有个问题需要注意，就是OpenGL不能直接和显示服务器进行通信，也就是说我们用OpenGL处理的图形图像是不能直接给显示服务器的，这中间得有一个东西来进行处理，这个中间件根据平台，windows上叫做wgl，linux上叫做glx，macos上是agl。好了，现在我们就可以用窗口来显示OpenGL处理的图形了，也就是我们常说的用OpenGL来进行渲染。&lt;/p&gt;
&lt;p&gt;4、之后为了将wgl，glx，agl这些东西统一起来，实现平台统一，就诞生了glfw，glu等东西，这些东西封装了wgl，glx，agl并且结合了各平台的显示服务器来创建窗口，可以让我们用一套代码来实现跨平台使用OpenGL在窗口中进行渲染。&lt;/p&gt;
&lt;p&gt;5、然后问题又来了，因为OpenGL在各个操作系统上的接口有的不一致，如果在不同平台上编译可能不相互兼容，让人用着不爽。于是又诞生了glew和glad这类东西来实现各个操作系统OpenGL接口的统一，结合上面提到的，就可以实现全面的跨平台了，是不是很爽。&lt;/p&gt;

&lt;p&gt;现在我们知道了，至少要做到上面的前3点，才可以用GPU加速渲染，我们再来看看这些东西的应用，其实无非就是各种引擎和图形库，比如：&lt;/p&gt;
&lt;p&gt;1、Cocos2dx直接使用了第4点的glfw，加上OpenGL实现了UI和绘图等等东西，变成一套游戏引擎。&lt;/p&gt;
&lt;p&gt;2、Qt就比较牛了，他自己实现了第4、5两点，所以实现了跨平台。 但是没有独立出来，所以咱们也不能用。&lt;/p&gt;

&lt;p&gt;但是Qt不都是用OpenGL渲染的，Qt中的显示分为三类，QWidget，QGraphics，QQuick。&lt;/p&gt;
&lt;p&gt;1、QWidget这一类中，基本上控件的实现都是对各个平台上的对应的控件的封装。QWidget中使用QWindow来创建窗口，而单独的QWindow内是不能使用系统插件的，只提供窗口，所以理论上QWIndow中是可以直接用OpenGL来进行绘图的。Qt为了以后的发展和2D，3D绘图性能的提升以应对游戏等开发需求，在Qt5.0以后将QWidget系的东西从gui模块中单独抽出来作为widgets模块，这也在情理之中。&lt;/p&gt;
&lt;p&gt;2、Qt为了提升针对大量简单组件的渲染性能，创造了QGraphics这一类东西，但是他们仍然是属于widgets模块的，也不一定是用OpenGL渲染，如果想用OpenGL渲染，是需要在QWidget和OpenGL搭一个桥梁，这就是QGLWidget。&lt;/p&gt;
&lt;p&gt;3、QQuick这一类东西是正真使用OpenGL来进行渲染的，而且还提供了多线程渲染支持，Qt为了方便使用，只提供了qml的接口，暴露出的也就QQuickItem这一个用于自定义控件的类。实际中，在类unix的环境下，QQuick中所有控件也是提供C++接口来实现编程的，只是Qt文档中没有，也没有对应的Qt模块，需要自己包含头文件。这类头文件都是Qt私有的，头文件格式基本都是*_p.h。并且还要链接QtQuick相关的QtQuickTemplate2和QtQuickControls2库。比如下面是在mac下的一段直接用QQuick C++的控件使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_cfecedd4-946e-463b-a705-088668aed103&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cfecedd4-946e-463b-a705-088668aed103&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cfecedd4-946e-463b-a705-088668aed103&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;QGuiApplication&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;QQmlApplicationEngine&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QQuickView&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QQuickItem&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;QObject&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QtQuick/private/qquickimage_p.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QtQuick/private/qquickrectangle_p.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QtQuickTemplates2/private/qquickbutton_p.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QtQuickTemplates2/private/qquicklabel_p.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    QGuiApplication app(argc, argv);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    QQuickView view;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     view.resize(&lt;span&gt;600&lt;/span&gt;, &lt;span&gt;800&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     QQuickItem* parentItem =&lt;span&gt; view.contentItem();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     QQuickImage* imgItem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQuickImage(parentItem);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     imgItem-&amp;gt;setSource(QUrl::fromLocalFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Users/Bearyin/Pictures/P30429-143922.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     imgItem-&amp;gt;setSize(QSizeF(&lt;span&gt;600&lt;/span&gt;, &lt;span&gt;800&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     QObject::connect(&amp;amp;view, &amp;amp;QQuickView::widthChanged, [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         imgItem-&amp;gt;&lt;span&gt;setSize(view.size());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     QObject::connect(&amp;amp;view, &amp;amp;QQuickView::heightChanged, [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         imgItem-&amp;gt;&lt;span&gt;setSize(view.size());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     QQuickRectangle* rectItem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQuickRectangle;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     rectItem-&amp;gt;setSize(QSizeF(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     rectItem-&amp;gt;setColor(QColor(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     QQuickLabel* labelItem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQuickLabel;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     labelItem-&amp;gt;setText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     labelItem-&amp;gt;setColor(QColor(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    labelItem-&amp;gt;setPosition(QPointF(200, 200));&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     labelItem-&amp;gt;setSize(QSize(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     labelItem-&amp;gt;&lt;span&gt;setBackground(rectItem);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     QQuickButton* btItem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQuickButton(parentItem);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     btItem-&amp;gt;setSize(QSizeF(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     btItem-&amp;gt;setPosition(QPointF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     btItem-&amp;gt;&lt;span&gt;setBackground(labelItem);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     btItem-&amp;gt;setText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     QObject::connect(btItem, &amp;amp;QQuickButton::clicked, [&amp;amp;&lt;span&gt;](){
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         rectItem-&amp;gt;setColor(QColor(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    view.show();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; app.exec();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这是pro文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_efc6395d-d781-4cd2-9c24-b8ff0bd68f3a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_efc6395d-d781-4cd2-9c24-b8ff0bd68f3a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_efc6395d-d781-4cd2-9c24-b8ff0bd68f3a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; QT +=&lt;span&gt; quick
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; CONFIG += c++&lt;span&gt;11&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; QT_PRIVATE += core-&lt;span&gt;private&lt;/span&gt; gui-&lt;span&gt;private&lt;/span&gt; qml-&lt;span&gt;private&lt;/span&gt; quick-&lt;span&gt;private&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; DEFINES +=&lt;span&gt; QT_DEPRECATED_WARNINGS
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; SOURCES +=&lt;span&gt; main.cpp
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; qnx: target.path = /tmp/$${TARGET}/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;: unix:!android: target.path = /opt/$${TARGET}/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; !isEmpty(target.path): INSTALLS +=&lt;span&gt; target
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; INCLUDEPATH +=&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtQuick.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;QtQuick \
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtQuickTemplates2.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;QtQuickTemplates2 \
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtQml.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtCore.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtGui.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtQuick.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; /Users/Bearyin/Software/Qt5.&lt;span&gt;9.2&lt;/span&gt;/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/clang_64/lib/QtQuickTemplates2.framework/Versions/&lt;span&gt;5&lt;/span&gt;/Headers/&lt;span&gt;5.9&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; LIBS += -framework QtQuickTemplates2
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 我这边的运行结果大概是这样的，里面图片等路径自行修改一下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;330&quot; height=&quot;363&quot;/&gt;&lt;/p&gt;

&lt;p&gt;介绍了这么多，其实现在看看这个游戏写不写已经无所谓了，我们可以来玩玩Qt了，学习一下里面的些东西。但是光看代码感觉有点无味，于是我想了个主意来激励一下自己：把QtQuick从Qt中剥离出来。&lt;/p&gt;
&lt;p&gt;如果能剥离出来，再进行一些改进，这样我相信QtQuick是完全可以成为一个好的游戏引擎来单独使用的。所以下一篇就等我什么时候有进展再来和大家说说。另外文中只是我自己的见解，如果有错误和疑问，烦请指出。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 16:32:00 +0000</pubDate>
<dc:creator>bearyin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxfangcs/p/7796003.html</dc:identifier>
</item>
<item>
<title>DTO – 服务实现中的核心数据 - 超越自我，挑战无极限</title>
<link>http://www.cnblogs.com/hxqcom/p/7795867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hxqcom/p/7795867.html</guid>
<description>
&lt;p&gt;       在一个Web服务的实现中，我们常常需要访问数据库，并将从数据库中所取得的数据显示在用户页面中。这样做的一个问题是：用于在用户页面上展示的数据和从数据库中取得的数据常常具有较大区别。在这种情况下，我们常常需要向服务端发送多个请求才能将用于在页面中展示的数据凑齐。&lt;/p&gt;
&lt;p&gt;　　一个解决该问题的方法就是根据不同需求使用不同的数据表现形式。在一个服务实现中较为常见的数据表现形式有MO（Model Object，在有些上下文中也被称为VO，Value Object）和DTO（Data Transfer Object）。MO用来表示从数据库中读取的数据，而DTO则用来表示在网络上所传输的数据。&lt;/p&gt;
&lt;p&gt;　　在本文中，我们将讨论如何在一个Web服务的实现中使用DTO及MO，并会对其它一些相关数据表现形式，如View Model等进行简单地介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why DTO?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　无论是桌面应用还是Web服务，其内部的数据表现都是非常重要的。在一个初学者了解一个系统的时候，其首先需要了解整个系统中的各个组件的作用，然后再了解系统中的Workflow，即在执行业务逻辑时各个组件是如何协同工作的。在了解了这两部分之后，该初学者需要做的事情就是详细地梳理一遍数据是如何在整个系统中流动的，即是整理并理解数据流（Dataflow）的过程。而在真正理解了数据流后，该初学者才具有了在系统中开发的能力。&lt;/p&gt;
&lt;p&gt;　　整理数据流的过程是一个逐步细化的过程：从鉴别数据结构到该数据结构中的每个属性到底是如何使用的。在整个数据流中，任何一个属性值的改变都可能会导致数据的处理方式发生变化。&lt;/p&gt;
&lt;p&gt;　　在整理数据流的时候我们要做什么样的事情呢？首先我们需要鉴别出到底哪些数据会在各个组件之间进行传送，在传送过程中进行了什么样的转化，这些数据是如何构建出来的，又由它构建了哪些数据，最终这些数据是否被持久化到了本地存储中等等。&lt;/p&gt;
&lt;p&gt;　　而在整理数据流的过程中，数据的转化常常是最难理解的部分。一个数据类型的定义常常与其运行环境有关。例如在一个电子商务网站中，一个表示商品的类Product可能包含了该商品的所有信息：商品的名称，品牌，详细介绍，价格等。在用户使用电脑浏览器浏览的时候，这些信息都将被显示在页面上。但是在用户使用手机进行浏览时，我们就需要考虑如何为这些手机用户节省流量的问题。一种节省用户手机流量的方法就是首先显示商品的简略信息，并在用户决定查看商品的详细介绍时再从服务端下载商品的详细信息。在这种情况下，包含商品所有信息的类Product将不再是适合传输的数据结构。&lt;/p&gt;
&lt;p&gt;　　而问题不仅仅出在需要将数据结构拆分的情况下，更可能出现在数据合并的情况中。例如网页的UE为了提高用户体验，要求在产品页面中直接将该商品品牌的详细信息显示在页面中。在这种情况下，我们就需要在表示商品的类Product中添加一个记录该商品品牌的域brand。但是在数据库中，表示商品的类Product可能仅仅记录了商品品牌的ID。因此在业务逻辑中，我们就需要将Product和其对应的Brand合并在一起。&lt;/p&gt;
&lt;p&gt;　　甚至说，我们可以将事情弄得更复杂一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232334231-1926124245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的图中，我们展示了数据在一个系统中可能存在的多种不同表现形式。在图片的中央位置的是一个服务器，多种客户端都将从它那里获得产品信息。就像前面所说，为了节省客户端的流量，服务端向移动客户端所发送的数据将是产品信息在服务端中的简略版本。而在一个浏览器访问该产品的时候，表示商品品牌的信息将内嵌在产品信息之中，以提供更好的用户体验。除了与客户端通讯，服务端之间也可能产生信息的交换。在该交换过程中，表示产品的Product以及表示品牌的Brand则彼此独立地在服务端之间传递。而就一个运行在远端的Agent而言，其可能仅仅需要一个Product的ID来监控产品在生产制作方面的状态。&lt;/p&gt;
&lt;p&gt;　　而这一切数据都应当从系统的数据库中得到。数据库中的数据不可能同时存储并维护这一系列数据结构，因此在一个复杂的系统中，数据库中的数据表示与系统中所传输的数据之间常常是不同的数据结构。常见的情况则是将其分为两类：一类用来访问数据库，在系统中表现数据库中所记录的数据，叫MO，即Model Object；另一类用来在网络中传输，叫DTO，即Data Transfer Object。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务中的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;MO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在了解了我们为什么需要DTO和MO等数据的不同表示之后，就让我们来看看这些数据表示在一个Web服务中是如何工作的。&lt;/p&gt;
&lt;p&gt;　　先让我们从最简单的Web服务分层开始说起。一个最简单的Web服务主要分为数据访问层（DAL），业务逻辑层以及表现层三个部分。其中表现层是运行在客户端的，而其它两个层次则运行在服务端。当数据从DAL层读取出来的时候，其所记录的数据与数据库中所记录的数据是一致的，因此它们就是我们这篇文章中讨论的MO。而在传输给客户端的时候，这些数据可能会和MO不同，因此其为DTO：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232458903-1466582592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就让我们放大一下数据访问层，来看看数据访问层中MO所在的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232545278-1527484862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先要强调的是，实现数据访问层的方式有很多种，而上图所展示的仅仅是一种基于Repository模式的实现。通过Repository来实现DAL是一种最为常见的数据访问层实现方式。就像上图所展示的那样，在一个基于Repository模式的实现中，数据访问层将拥有一系列Repository实例。这些Repository实例依赖于系统所使用的ORM来将数据库中的数据转化为Java类实例。这些Java类实例实际上就是在该数据访问层所提供给业务逻辑层的MO。&lt;/p&gt;
&lt;p&gt;　　而DTO则用于在服务与客户之间以及服务和服务之间进行数据的传递。在这些传递过程中，对DTO的需求可能是多种多样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232618169-289456304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的图片展示了一段Product这种类型的DTO在服务端和客户端以及服务端之间进行交互的过程。在该流程中，所需要传递的DTO并不相同：在使用浏览器读取和保存有关Product的信息时，两者的数据表现形式可能会有一些细微的差别。而在保存完毕后，服务可能会将新的Product作为负载来向其它服务器发送请求，而此时所使用的Product的表示又可能与前两种略有差别。如果为这些细微的差别定义很多不同的DTO，那么系统对数据的管理可能会遇到一系列麻烦。例如在一个复杂的系统中，DTO可能会按照下面的方式在系统中流转：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog2015/126867/201503/310029153575518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上图中，我们展示了一个DTO在依次流转过多个服务的情况。如果在DTO依次传递的过程中使用了不同的DTO表示，那么一个服务所需要的DTO可能和另一个服务中所拥有的DTO并不匹配。这便是DTO反过来会影响到架构设计的一个最简单的例子，却也是DTO管理中最常见的问题，那就是DTO的表现形式过多。如果为所有的不同需求都创建一个DTO，那么一个概念所对应的DTO可能多达5，6种，非常难于管理。这种管理上的困难常常存在于如何指定某个服务所需要使用的DTO种类，以及在更改DTO时需要同时修改一系列DTO的情况中。&lt;/p&gt;
&lt;p&gt;　　为了防止DTO由于不同的需求而衍生出过多的种类，服务实现中常常允许DTO中的数据包含一些冗余。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逐步添加你的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么我们该如何向系统中添加DTO呢？答案是，根据情况决定。在项目的一开始，数据库中所存储的数据与页面所需要显示的数据常常是一致的，因此在这种情况下，我们并不需要DTO的帮助。而在所需要的数据和数据库所记录的数据不再一样的时候，我们就需要考虑是否需要在项目中添加DTO了。这时软件开发人员就需要问自己：这种所需要的数据与数据库中的数据不一致的情况是否常常出现？如果答案是“是”，那么我们就需要开始着手准备添加对DTO的支持。&lt;/p&gt;
&lt;p&gt;　　在系统中添加DTO主要有以下几部分工作需要完成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加DTO类。&lt;/li&gt;
&lt;li&gt;添加从MO到DTO的转化逻辑。&lt;/li&gt;
&lt;li&gt;将原本对MO的使用转换为对DTO的使用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　相信读者最先注意到的就是第三点。可以想象到的是，如果将整个系统的MO替换成DTO，那么它的影响面将会非常大，而且非常容易出错。因此在一个大型项目中，我们常常需要预先判断DTO的必要性，进而尽早地添加DTO。&lt;/p&gt;
&lt;p&gt;　　让我们回过头来看看第一个任务应该如何完成。在一个系统中，DTO常常用来传输数据，因此其自身往往不带有任何逻辑。这也便是这些DTO常常被定义成JavaBean的原因。以JavaBean的形式来定义DTO带来了一个巨大的好处，那就是很多第三方类库都提供了生成JavaBean的功能。在这种情况下，软件开发人员只需要通过一系列描述性语言来描述这些DTO即可。这其中最常用的便是JAXB。&lt;/p&gt;
&lt;p&gt;　　在使用JAXB时，软件开发人员只需要在.xsd文件中编写一系列描述性信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:complexType &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Address&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:sequence&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;street&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;city&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;state&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:sequence&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;country&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:NMTOKEN&quot;&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;=&quot;US&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:complexType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么在JAXB运行完毕后，相应的Java类型就将被生成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@XmlAccessorType(AccessType.FIELD)
@XmlType(name = &quot;Address&quot;, propOrder = {
    &quot;name&quot;,
    &quot;street&quot;,
    &quot;city&quot;,
    &quot;state&quot;
})
public class Address {
    protected String name;
    protected String street;
    ……
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String country;

    public String getName() {
        return name;
    }

    public void setName(String value) {
        this.name = value;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String value) {
        this.street = value;
    }
    ……
    public String getCountry() {
        if (country == null) {
            return &quot;US&quot;;
        } else {
            return country;
        }
    }

    public void setCountry(String value) {
        this.country = value;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　是不是很简单？在知道了如何创建一个DTO之后，我们就需要考虑如何将MO转化成为DTO。当然，这依然有第三方工具可以帮助我们完成这个事情。一个较为著名的工具就是Dozer。使用Dozer也很简单，在它的配置文件里面标明需要相互转换的两个类型即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.egoods.mo.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.edoods.dto.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行时，Dozer会使用反射来对这两个类型中的各个同名属性进行匹配并赋值。如果两个类型中拥有不同名的属性，那么软件开发人员可以显式地指定相互匹配的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.egoods.mo.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.edoods.dto.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;owner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　除此之外，Dozer还支持非常多的转换功能，在这里我们便不一一进行介绍了。&lt;/p&gt;
&lt;p&gt;　　在有这些工具的辅助下，为系统添加DTO已经变得简单多了。在对DTO的日常维护中，我们可能需要添加一些新的DTO，或者更改已有的DTO。在这种情况下，我们只需要更改对DTO进行描述的文件并更新Dozer的配置文件即可。当然，如果在Dozer中使用了自定义转换逻辑，那么软件开发人员还需要更新相应的转换逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;贫血的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　DTO中只包含数据，并没有包含任何行为。“这我知道”，或许你会说。&lt;/p&gt;
&lt;p&gt;　　但是千万不要大意。这常常会导致你陷入贫血模型的陷阱中。在服务端的业务逻辑实现以及客户端的页面逻辑中，我们有时需要指定对这些数据的操作逻辑。从面向对象设计的角度来说，某些逻辑实际上就应该定义在这些类型中。但是由于DTO本身没有定义这些逻辑，因此我们需要在这些类型之外定义它们，例如在一个Helper类中为这些类型定义一系列辅助函数。&lt;/p&gt;
&lt;p&gt;　　一个最简单的示例就是对数据有效性的检查。例如在一个Person类中，我们使用一个整型数据记录了该人物的年龄：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person {&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;age;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;……&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; }&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;那么在业务逻辑中，我们就需要检查该域是否被设置为负数。由于DTO是使用工具自动生成的，因此这些检查逻辑无法放在该DTO类中。作为一种变通方式，我们需要写一个辅助类来完成该功能。但随着这种需求越来越多，对这些辅助功能的管理将越来越困难。此时你就将完全陷入到贫血模型的陷阱中。&lt;/p&gt;
&lt;p&gt;　　也就是说，DTO的主要职责是为了传输数据，但它并不擅长，甚至是不适合在业务逻辑中表示一个复杂概念。一个复杂概念常常与一些可重用的复杂逻辑关联，但这正是DTO所不能办到的。&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，我们可以在服务端添加一个业务逻辑表现，即BO（Business Object）。在这种情况下，MO将不会直接转化为DTO，而是转化为BO。在所有业务处理完毕并需要将数据发送给客户的时候，BO将转化为DTO以进行传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog2015/126867/201503/310037510296478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而在客户端，我们同样可以引入一层新的更适合于页面逻辑的数据表现。这种数据表现被称为VM（ViewModel），即为了表观展示所定义的模型。有时候，有些类库提供了更为简单的方法，例如YUI和ExtJS所提供的Mixin功能。&lt;/p&gt;
&lt;p&gt;　　当然，在添加这些数据展现形式之前，软件开发人员需要仔细考量添加这些模型所需要的工作量和所带来效益之间的平衡。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>超越自我，挑战无极限</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hxqcom/p/7795867.html</dc:identifier>
</item>
<item>
<title>Struts2+Spring+Hibernate实现员工管理增删改查功能（一）之ssh框架整合 - 姜飞祥</title>
<link>http://www.cnblogs.com/smfx1314/p/7795837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smfx1314/p/7795837.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言        转载请标明出处：http://www.cnblogs.com/smfx1314/p/7795837.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本项目是我写的一个练习，目的是回顾ssh框架的整合以及使用。项目介绍：此项目主要有前台管理员通过登录进入员工管理系统页面，之后可以对员工列表进行常规的增删改查。以及部门列表的增删改查。IDE使用的是eclipse，个人感觉比较好用，不过最近我正在研究idea,数据库是mysql，前台主要以bootstrap为主。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这点是直接摘抄的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;struts 控制用的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hibernate 操作数据库的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring 用解耦的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Struts 、 spring 、 Hibernate 在各层的作用&lt;/p&gt;
&lt;p&gt;1 ） struts 负责 web 层 .&lt;/p&gt;
&lt;p&gt;ActionFormBean 接收网页中表单提交的数据，然后通过 Action 进行处理，再 Forward 到对应的网页。&lt;/p&gt;
&lt;p&gt;在 struts-config.xml 中定义 &amp;lt;action-mapping&amp;gt;, ActionServlet 会加载。&lt;/p&gt;
&lt;p&gt;2 ） spring 负责业务层管理，即 Service （或 Manager).&lt;/p&gt;
&lt;p&gt;1 ． service 为 action 提供统计的调用接口，封装持久层的 DAO.&lt;/p&gt;
&lt;p&gt;2 ．可以写一些自己的业务方法。&lt;/p&gt;
&lt;p&gt;3 ．统一的 javabean 管理方法&lt;/p&gt;
&lt;p&gt;4 ．声明式事务管理&lt;/p&gt;
&lt;p&gt;5. 集成 Hiberante&lt;/p&gt;
&lt;p&gt;3 ） Hiberante ，负责持久化层，完成数据库的 crud 操作&lt;/p&gt;
&lt;p&gt;hibernate 为持久层，提供 OR/Mapping 。&lt;/p&gt;
&lt;p&gt;它有一组 .hbm.xml 文件和 POJO, 是跟数据库中的表相对应的。然后定义 DAO ，这些是跟数据库打交道的类，它们会使用 PO 。&lt;/p&gt;
&lt;p&gt;在 struts+spring+hibernate 的系统中，&lt;/p&gt;
&lt;p&gt;对象的调用流程是： jsp-&amp;gt; Action － &amp;gt; Service -&amp;gt;DAO -&amp;gt;Hibernate 。&lt;/p&gt;
&lt;p&gt;数据的流向是 ActionFormBean 接受用户的数据， Action 将数据从 ActionFromBean 中取出，封装成 VO 或 PO,&lt;/p&gt;
&lt;p&gt;再调用业务层的 Bean 类，完成各种业务处理后再 forward 。而业务层 Bean 收到这个 PO 对象之后，会调用 DAO 接口方法，进行持久化操作。&lt;/p&gt;

&lt;p&gt; spring:Aop管理事务控制,IoC管理各个组件的耦合,DaoTemplate作为常规持久层的快速开发模板!&lt;/p&gt;
&lt;p&gt;struts:控制层Action,页面标签和Model数据,调用业务层&lt;/p&gt;
&lt;p&gt;Hibernate:负责数据库和对象的映射,负责DAO层(Data Access Object:数据访问)&lt;/p&gt;

&lt;p&gt;spring整合hibernate和struts，只要在配好了applicationContext.xml,在struts的action中直接调用就可以了。hibernate访问数据库的操作都在spring中实现了，spring的调用又在stuts的action中实现了。这个ssh框架就连到了一起……&lt;/p&gt;

&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里关于mysql的表我就不贴出来了，这个大家可以根据实体类进行创建，我创建的是emp和dept表，他们之间是一对多关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，关于jsp页面中的*.js，你可以根据jsp中的路径自己创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于内容过多，今天我先说下ssh框架的整合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来让我们看下目录结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106225702513-1230093656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第一步，导入jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230503309-438800691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230519825-727129475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：我们看下index.jsp页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;&lt;br/&gt;pageEncoding=&quot;UTF-8&quot;%&amp;gt;&lt;br/&gt;&amp;lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&amp;gt;&lt;br/&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;IE=edge&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;${pageContext.request.contextPath }/utilLib/bootstrap.min.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;div_from_aoto&quot; style=&quot;width: 500px;&quot;&amp;gt;&lt;br/&gt;&amp;lt;form action=&quot;${pageContext.request.contextPath }/user_login.action&quot; method=&quot;post&quot;&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&amp;lt;input class=&quot;input_from&quot; type=text name=&quot;username&quot; placeholder=&quot; 请输入用户名&quot;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;p class=&quot;help-block&quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot; &amp;gt;密码&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&amp;lt;input class=&quot;input_from&quot; type=password name=&quot;password&quot; placeholder=&quot; 请输入密码&quot;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;p class=&quot;help-block&quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot; &amp;gt;&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&lt;br/&gt;&amp;lt;button class=&quot;btn btn-success&quot; style=&quot;width:120px;&quot; &amp;gt;确认&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/form&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;上面主要使用了bootstrap框架。当然，登录页面我做的比较简单，你也可以根据自己的感觉去写效果&lt;/p&gt;
&lt;p&gt;第三步是配置文件，首先我们配置web.xml&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&amp;gt;&lt;br/&gt;&amp;lt;display-name&amp;gt;ssh-day02&amp;lt;/display-name&amp;gt;&lt;br/&gt;&amp;lt;welcome-file-list&amp;gt;&lt;br/&gt;&amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;&lt;br/&gt;&amp;lt;/welcome-file-list&amp;gt;&lt;br/&gt;&amp;lt;!-- 加载spring监听器 --&amp;gt;&lt;br/&gt;&amp;lt;listener&amp;gt;&lt;br/&gt;&amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;&lt;br/&gt;&amp;lt;/listener&amp;gt;&lt;br/&gt;&amp;lt;!-- 加载spring的配置文件applicationContext.xml --&amp;gt;&lt;br/&gt;&amp;lt;context-param&amp;gt;&lt;br/&gt;&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;&lt;br/&gt;&amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;&lt;br/&gt;&amp;lt;/context-param&amp;gt;&lt;br/&gt;&amp;lt;!-- 解决no session问题 --&amp;gt;&lt;br/&gt;&amp;lt;filter&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;OpenSessionInviewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;filter-class&amp;gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&amp;lt;/filter-class&amp;gt;&lt;br/&gt;&amp;lt;/filter&amp;gt;&lt;br/&gt;&amp;lt;filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;OpenSessionInviewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;&amp;lt;/filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置Struts --&amp;gt;&lt;br/&gt;&amp;lt;filter&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;&lt;br/&gt;&amp;lt;/filter&amp;gt;&lt;br/&gt;&amp;lt;filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;&amp;lt;/filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;!-- 设置session有效时间 --&amp;gt;&lt;br/&gt;&amp;lt;!-- &amp;lt;session-config&amp;gt;&lt;br/&gt;&amp;lt;session-timeout&amp;gt;1&amp;lt;/session-timeout&amp;gt;&lt;br/&gt;&amp;lt;/session-config&amp;gt; --&amp;gt;&lt;br/&gt;&amp;lt;/web-app&amp;gt;&lt;/p&gt;
&lt;p&gt;都是些基本的配置，no session配置是后边两张表进行关联查询时session提前关闭的问题&lt;/p&gt;
&lt;p&gt;第四步：把对应的包类创建出来，方便我们在applicationContext.xml中配置bean实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230957559-1870342981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们开始配置applicationContext.xml&lt;/p&gt;
&lt;p&gt;主要是创建数据库连接池，创建sessionFactory ，配置hibernate属性以及声明式事务，aop（我这块没有用到，就没有配置）,以及bean的实例化配置&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;br/&gt;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;br/&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&lt;br/&gt;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;&lt;br/&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&lt;br/&gt;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans&lt;br/&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;br/&gt;http://www.springframework.org/schema/tx&lt;br/&gt;http://www.springframework.org/schema/tx/spring-tx.xsd&lt;br/&gt;http://www.springframework.org/schema/aop&lt;br/&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;br/&gt;http://www.springframework.org/schema/context&lt;br/&gt;http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt; &amp;lt;!-- 整合hibernate --&amp;gt;&lt;br/&gt;&amp;lt;!-- 1.配置数据库--&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/ssh2&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;user&quot; value=&quot;root&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;password&quot; value=&quot;1234&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置sessionFactory --&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;&lt;br/&gt;&amp;lt;!-- 数据源 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate基本属性 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;&lt;br/&gt;&amp;lt;props&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;/props&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate映射文件 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;mappingResources&quot;&amp;gt;&lt;br/&gt;&amp;lt;list&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/User.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/Emp.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/Dept.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/list&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate事务 --&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 开启事务 --&amp;gt;&lt;br/&gt;&amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!-- 配置aop --&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/beans&amp;gt;&lt;/p&gt;
&lt;p&gt;然后在引入Struts2的配置文件&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;br/&gt;&amp;lt;!DOCTYPE struts PUBLIC&lt;br/&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;&lt;br/&gt;&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;&lt;br/&gt;&amp;lt;struts&amp;gt;&lt;br/&gt;&amp;lt;package name=&quot;ssh-day02&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/package&amp;gt;&lt;br/&gt;&amp;lt;/struts&amp;gt;&lt;/p&gt;
&lt;p&gt;注意，上面把hibernate的配置文件和spring进行了整合，所有没有单独创建hibernate的配置文件。&lt;/p&gt;
&lt;p&gt;到这里，ssh的配置基本完成。运行成功就是一个登陆页面&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 15:28:00 +0000</pubDate>
<dc:creator>姜飞祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smfx1314/p/7795837.html</dc:identifier>
</item>
<item>
<title>Cocoapods安装过程 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/7795811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/7795811.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;strong&gt;Ruby&lt;/strong&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gem -v&lt;/p&gt;
&lt;p&gt;gem update --system&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有权限去升级&lt;/strong&gt;&lt;strong&gt;Ruby ?&lt;/strong&gt;&lt;strong&gt;就输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo gem update --system&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;换掉&lt;/strong&gt;&lt;strong&gt;Ruby&lt;/strong&gt;&lt;strong&gt;镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先移除现有的Ruby镜像&lt;/p&gt;
&lt;p&gt;gem sources --remove &lt;a href=&quot;https://rubygems.org/&quot;&gt;https://rubygems.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加国内最新镜像源&lt;/p&gt;
&lt;p&gt;gem source -a &lt;a href=&quot;https://gems.ruby-china.org/&quot;&gt;https://gems.ruby-china.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看当前镜像&lt;/p&gt;
&lt;p&gt;gem sources -l&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;strong&gt;CocoaPods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo gem install cocoapods&lt;/p&gt;
&lt;p&gt;如果报错&lt;/p&gt;
&lt;p&gt;sudo gem install -n /usr/local/bin cocoapods&lt;/p&gt;

&lt;p&gt;4.初始化repos文件&lt;/p&gt;
&lt;p&gt;pod repo add master &lt;a href=&quot;https://github.com/CocoaPods/Specs.git&quot;&gt;https://github.com/CocoaPods/Specs.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报错用这个&lt;/p&gt;
&lt;p&gt;pod setup&lt;/p&gt;

&lt;p&gt;5.安装过程中出现报错&lt;/p&gt;
&lt;p&gt;报错类型1:&lt;/p&gt;
&lt;p&gt;[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master --progress&lt;/p&gt;

&lt;p&gt;Cloning into 'master'...&lt;/p&gt;
&lt;p&gt;fatal: unable to access 'https://github.com/CocoaPods/Specs.git/': Could not resolve host: github.com&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因可能是：&lt;/strong&gt;github.com没有被主机给解析&lt;/p&gt;
&lt;p&gt;解决方法：在本地手动指定&lt;a href=&quot;http://github.com&quot;&gt;github.com&lt;/a&gt;的IP地址&lt;/p&gt;

&lt;p&gt;编辑文件etc/hosts&lt;/p&gt;
&lt;p&gt;sudo vi /etc/hosts&lt;/p&gt;

&lt;p&gt;添加github的地址&lt;/p&gt;
&lt;p&gt;::1             localhost&lt;/p&gt;
&lt;p&gt;192.30.255.112  github.com&lt;/p&gt;


&lt;p&gt;报错类型2:&lt;/p&gt;
&lt;p&gt;[!] /usr/bin/git clone 'https://github.com/CocoaPods/Specs.git' master --depth=1&lt;/p&gt;

&lt;p&gt;Cloning into 'master'...&lt;/p&gt;

&lt;p&gt;fatal: unable to access 'https://github.com/CocoaPods/Specs.git/': Could not resolve host: &lt;a href=&quot;http://github.com&quot;&gt;github.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因可能是：安装多个&lt;/strong&gt;&lt;strong&gt;Xcdoe&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;xcode&lt;/strong&gt;&lt;strong&gt;路径问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：sudo xcode-select -switch /Applications/Xcode.app/&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在终端里输入下方命令可以知道&lt;/strong&gt;&lt;strong&gt;Xcode&lt;/strong&gt;&lt;strong&gt;的路径：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;xcode-select -p&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 15:21:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/7795811.html</dc:identifier>
</item>
<item>
<title>【经验分享(续篇)】Trachtenberg system(特拉亨伯格速算系统) - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前有篇文章简单地介绍了Trachtenberg系统的乘法计算方法，地址在&lt;a href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7411297.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。针对一些特定的数字，Trachtenberg还发展出了更快的计算方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来介绍乘数为11的速算方法。它的计算规则我们可称之为“邻居法则”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从右至左，把每一位数和其右侧相邻位置的数字相加，取其个位。若所得值大于9，则将其十位则带到下一位计算（这个进位最多也只有1）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以以后碰到和11相乘，直接写结果就成了，举个栗子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如633 x 11:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数字，所以直接记作3；这里衍生出一条规则，所求值的第1位等于被乘数的第1位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/===lw_pic_up_sina===1476084307.3164&quot;&gt;&lt;span&gt;&lt;img title=&quot;1&quot; src=&quot;http://s4.sinaimg.cn/middle/001K43yhzy75vEliXMDb3&amp;amp;amp;690&quot; alt=&quot;1&quot; width=&quot;308&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：3 + 3 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vEllxE622&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0000&quot; src=&quot;http://s3.sinaimg.cn/middle/001K43yhzy75vEllxE622&amp;amp;amp;690&quot; alt=&quot;SNAG-0000&quot; width=&quot;280&quot; height=&quot;121&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位： 6 + 3 = 9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElofyI74&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0001&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75vElofyI74&amp;amp;amp;690&quot; alt=&quot;SNAG-0001&quot; width=&quot;290&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：左侧没数字了，计作0，so，0 + 6 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElr4qj27&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0002&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75vElr4qj27&amp;amp;amp;690&quot; alt=&quot;SNAG-0002&quot; width=&quot;311&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;计算的时候，也可以习惯性的也在被乘数前加个0，这个看起来更顺眼：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vEltN7j31&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0003&quot; src=&quot;http://static2.photo.sina.com.cn/middle/001K43yhzy75vEltN7j31&amp;amp;amp;690&quot; alt=&quot;SNAG-0003&quot; width=&quot;395&quot; height=&quot;126&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个例子相邻两数的和没有超过9的，所以我决定再来个栗子，计算1754 x 11。当相邻两数的和大于9时，我们在写结果的时候，可以顺手在前面用一个小点标记一下，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElwKD3bd&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0004&quot; src=&quot;http://s14.sinaimg.cn/middle/001K43yhzy75vElwKD3bd&amp;amp;amp;690&quot; alt=&quot;SNAG-0004&quot; width=&quot;577&quot; height=&quot;113&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：7 + 5 = 12，这里的记作“.2”（相当于12）， 所以要第4位就是：1 + 7 + 1 = 9。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么样？够简单吧？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;12的乘法规则和11一样简单：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位乘2后再加上右邻那位的值，取其个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;直接来看栗子：413 x 12&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第1位（右起，下同）：3 x 2 + 0 = 6. 3的右侧没数值，直接乘2即可。为方便计算，我们在被乘数的前面补个零，这样对于初学者来说，最后一位的计算不至于被轻易忽略。老手的话，直接脑补即可，以后对于前面补0的操作，不再做专门的说明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqozzbb1&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0006&quot; src=&quot;http://s2.sinaimg.cn/middle/001K43yhzy75wSqozzbb1&amp;amp;amp;690&quot; alt=&quot;SNAG-0006&quot; width=&quot;451&quot; height=&quot;134&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第2位：1 x 2 + 3 = 5&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqrU8S8e&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0007&quot; src=&quot;http://static15.photo.sina.com.cn/middle/001K43yhzy75wSqrU8S8e&amp;amp;amp;690&quot; alt=&quot;SNAG-0007&quot; width=&quot;375&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第3位：4 x 2 + 1 = 9&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqu9p9ab&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0008&quot; src=&quot;http://s12.sinaimg.cn/middle/001K43yhzy75wSqu9p9ab&amp;amp;amp;690&quot; alt=&quot;SNAG-0008&quot; width=&quot;365&quot; height=&quot;82&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第4位：0 x 2 + 4 = 4&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqxcVk6a&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0009&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75wSqxcVk6a&amp;amp;amp;690&quot; alt=&quot;SNAG-0009&quot; width=&quot;427&quot; height=&quot;85&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎么样？还是看到数字直接写结果，比传统的计算简单多了吧？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;照例要解决“乘2加邻居”后带来的进位问题。由于这项操作最大值只有27（9 x 2 + 9），所以进位最大是2。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再来个栗子：63247 x 12&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第1位：7 x 2 + 0 = 14，留下4，将1进位。还记得我们上一节讲过的前面标个小点来表示有进位的做法么？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqGbrBeb&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0010&quot; src=&quot;http://s12.sinaimg.cn/middle/001K43yhzy75wSqGbrBeb&amp;amp;amp;690&quot; alt=&quot;SNAG-0010&quot; width=&quot;397&quot; height=&quot;88&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第2位：4 x 2 + 7 = 15 + 1 = 16。留6，将1进位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqIRtof2&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0011&quot; src=&quot;http://static3.photo.sina.com.cn/middle/001K43yhzy75wSqIRtof2&amp;amp;amp;690&quot; alt=&quot;SNAG-0011&quot; width=&quot;514&quot; height=&quot;99&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第3位：2 x 2 + 4 = 8 + 1 = 9&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqLXhq0c&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0012&quot; src=&quot;http://static13.photo.sina.com.cn/middle/001K43yhzy75wSqLXhq0c&amp;amp;amp;690&quot; alt=&quot;SNAG-0012&quot; width=&quot;439&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第4位：3 x 2 + 2 = 8&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第5位：6 x 2 + 3 = 15。留5，将1进位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第6位：0 x 2 + 6 = 6 + 1 = 7。注意此时所得的值如果大于9，则直接将进位写到下1位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqO9u43c&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0013&quot; src=&quot;http://s13.sinaimg.cn/middle/001K43yhzy75wSqO9u43c&amp;amp;amp;690&quot; alt=&quot;SNAG-0013&quot; width=&quot;289&quot; height=&quot;78&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们讲5、6、7这三个数的乘法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你有这本书，请翻到第28页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来讲6。擦，为什么要先讲6？请往下看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6的乘法规则有两条，先讲第一条：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位加上右侧邻位的一半，保留个位，若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这个“右侧邻位的一半”的取半操作，准确的说法是“取半求整”，就是碰到1、3、5、7、9这些奇数的时候，取其一半的整数部分。比如5的一半是2.5，我们只取2，其它依此类推。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上栗子吧：计算 622084 x 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：4 + 0 / 2 = 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xEZXeqk50&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0014&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xEZXeqk50&amp;amp;amp;690&quot; alt=&quot;SNAG-0014&quot; width=&quot;275&quot; height=&quot;94&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：8 + 4 / 2 = 10, 取0，将1进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF00NbE36&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0015&quot; src=&quot;http://s7.sinaimg.cn/middle/001K43yhzy75xF00NbE36&amp;amp;amp;690&quot; alt=&quot;SNAG-0015&quot; width=&quot;272&quot; height=&quot;87&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：0 + 1  + 8 / 2 = 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0qsRh27&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0016&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75xF0qsRh27&amp;amp;amp;690&quot; alt=&quot;SNAG-0016&quot; width=&quot;262&quot; height=&quot;77&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：2 + 0 / 2 = 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位：2 + 2 / 2 = 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6位：6 + 2 / 2 = 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第7位：0 + 6 / 2 = 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0toCc58&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0017&quot; src=&quot;http://s9.sinaimg.cn/middle/001K43yhzy75xF0toCc58&amp;amp;amp;690&quot; alt=&quot;SNAG-0017&quot; width=&quot;268&quot; height=&quot;84&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，这并不是乘6的全部规则，完整的规则是：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位加上右侧邻位的一半，如果这个数是奇数，那要先加5. 所得值保留个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;直接上栗子：计算 443052 x 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数字了，所以直接得2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0uVU82c&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0024&quot; src=&quot;http://s13.sinaimg.cn/middle/001K43yhzy75xF0uVU82c&amp;amp;amp;690&quot; alt=&quot;SNAG-0024&quot; width=&quot;868&quot; height=&quot;203&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：注意这一位是5，要先加5，再加右侧的一半，5 + 5 + 2 / 2 = 11, 保留1， 将十位上的1进位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0yfqP4b&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0018&quot; src=&quot;http://static12.photo.sina.com.cn/middle/001K43yhzy75xF0yfqP4b&amp;amp;amp;690&quot; alt=&quot;SNAG-0018&quot; width=&quot;890&quot; height=&quot;223&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：0  + 1 + 5 / 2 = 3。注意5 / 2的取半求整操作。另外，对有进位的情况，建议养成先加进位的习惯，如在本例中看到0，心里直接说“1”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0QCfv59&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0019&quot; src=&quot;http://static10.photo.sina.com.cn/middle/001K43yhzy75xF0QCfv59&amp;amp;amp;690&quot; alt=&quot;SNAG-0019&quot; width=&quot;911&quot; height=&quot;249&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：3是奇数，所以要先加5：3 + 5 + 0  / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0TOEg70&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0025&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xF0TOEg70&amp;amp;amp;690&quot; alt=&quot;SNAG-0025&quot; width=&quot;815&quot; height=&quot;171&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位：4 + 3 / 2 = 5. 注意，在练习时要养成一个良好的习惯，不要去想“3的一半是1，4加1等于5”，做取半操作应该直接报出结果。比较理想的状况是心里想“4，5”，在刚开始练习的阶段，也可以想“4，1，5”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF17Fp630&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0021&quot; src=&quot;http://s1.sinaimg.cn/middle/001K43yhzy75xF17Fp630&amp;amp;amp;690&quot; alt=&quot;SNAG-0021&quot; width=&quot;785&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6位：4 + 4 / 2 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1dm7H7d&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0022&quot; src=&quot;http://static14.photo.sina.com.cn/middle/001K43yhzy75xF1dm7H7d&amp;amp;amp;690&quot; alt=&quot;SNAG-0022&quot; width=&quot;747&quot; height=&quot;178&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第7位：0  + 4 / 2 = 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1goMk44&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0023&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75xF1goMk44&amp;amp;amp;690&quot; alt=&quot;SNAG-0023&quot; width=&quot;788&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看到这里，或许有童鞋会问，这和传统算法比，好像没什么优势啊？而且貌似更复杂了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看起来是这个样子！传统算法中，是用乘法口诀将两数相乘，再处理进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但我认为，Trachtenberg算法最大的优势是进位简单，因为最大只有一。而且相对而言，将乘法转化成了加法，亦更为简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，有吃瓜群众指出，你这特么滴还有除法，敢说简单？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;亲，取半的操作辣么简单，难道你也怕？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面请翻到35页，我们开始学习7的乘法规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7的乘法规则和6很相似：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数乘2后加上右侧邻位的一半，如果这个数是奇数，那要在乘2后加5。所得值保留个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们来看栗子：计算3412 x 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数据，所以直接乘2，得4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1jFQI80&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0026&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xF1jFQI80&amp;amp;amp;690&quot; alt=&quot;SNAG-0026&quot; width=&quot;864&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：1是奇数，所以先乘2再加5，1 x 2 + 5 + 2 / 1 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1H3uOda&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0027&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75xF1H3uOda&amp;amp;amp;690&quot; alt=&quot;SNAG-0027&quot; width=&quot;859&quot; height=&quot;201&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：注意1取半求整后是0，4 x 2 + 1 / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1Kfhtb7&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0028&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75xF1Kfhtb7&amp;amp;amp;690&quot; alt=&quot;SNAG-0028&quot; width=&quot;872&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：3 x 2 + 5 + 4 / 2 = 13. 留3，将1进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1MWYib2&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0029&quot; src=&quot;http://static3.photo.sina.com.cn/middle/001K43yhzy75xF1MWYib2&amp;amp;amp;690&quot; alt=&quot;SNAG-0029&quot; width=&quot;412&quot; height=&quot;169&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位： 0 x 2 + 1 + 3 / 2 = 2，养成先加进位的习惯&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1Sa0I54&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0030&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75xF1Sa0I54&amp;amp;amp;690&quot; alt=&quot;SNAG-0030&quot; width=&quot;854&quot; height=&quot;197&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我们来讲5的乘法规则。它有点像6和7规则的杂交版，但更简单：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;取被乘数的每一位右侧邻位的一半，如果当前位是奇数，则再加5&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这回连进位都不需要考虑，因为把最大的数9取半求整后是4，即使要再加5，也只能是9。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们照例用一个栗子来理解这条规则：计算436 x 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：6是偶数，而其右侧没有数字，所以写作0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1ZDQK2a&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0031&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75xF1ZDQK2a&amp;amp;amp;690&quot; alt=&quot;SNAG-0031&quot; width=&quot;462&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：3是奇数，5 + 6 / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF204nm78&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0032&quot; src=&quot;http://static9.photo.sina.com.cn/middle/001K43yhzy75xF204nm78&amp;amp;amp;690&quot; alt=&quot;SNAG-0032&quot; width=&quot;726&quot; height=&quot;162&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：4是偶数，所以只取 3 / 1, 得1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：0是偶数，所以只取 4 / 2, 得2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF24SUX43&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0033&quot; src=&quot;http://static4.photo.sina.com.cn/middle/001K43yhzy75xF24SUX43&amp;amp;amp;690&quot; alt=&quot;SNAG-0033&quot; width=&quot;343&quot; height=&quot;117&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下就是，在5的乘法中，被乘数的每一位数只是用来判断是不是要加5，并不参与运算。&lt;/span&gt; 所以算起来要简单多了。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 15:06:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</dc:identifier>
</item>
<item>
<title>深入理解JavaScript中的继承：原型链篇 - envision</title>
<link>http://www.cnblogs.com/envision/p/JavaScript.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/envision/p/JavaScript.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;原型是一个对象，当我调用一个对象的方法时，如果该方法没有在对象里面，就会从对象的原型去寻找。JavaScript就是通过层层的原型，形成原型链。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　任何对象都可以有原型，当我们创建对象的时候，会自动为对象添加一个属性，这个属性就是原型，我们无法访问到他，但在firefox和chrome中可以通过一个非标准的属性__proto__（双下划线）来访问到原型（或通过Object.getPrototypeOf来访问）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们先从以下代码入手&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　var&lt;/span&gt; foo =&lt;span&gt; {};
　　&lt;/span&gt;console.log(foo.toString()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [object Object]　　&lt;br/&gt;&lt;span&gt;　　console.log(foo.__proto__); &lt;span&gt;// object { ... }  这里指向Object.prototype&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　foo里面明明没有toString方法，但我却能调用，这就是原型链的作用。当我调用foo.toString时，由于在里面找不到toString方法，那么我从__proto__属性里面去找，找到后并调用。上面的代码中我们就是从Object.prototype中找到了toString方法。你可能会很困惑，prototype是什么？我们不要被prototype所迷惑，他只是一个存放属性的容器而已，你可以如下这样做来实现继承（但尽量不要这么做）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Bar() {}
Bar.test &lt;/span&gt;=&lt;span&gt; {
  say: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
       console.log(&lt;/span&gt;'say test'&lt;span&gt;);     
    }  
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar();
foo.say(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变继承的对象&lt;/span&gt;
&lt;span&gt;
foo.__proto__ &lt;/span&gt;=&lt;span&gt; Bar.test;
foo.say() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; say test&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　　&lt;span&gt;在上面的代码中我们通过new的形式来创建一个对象，在new的过程中对象会将__proto__指向函数的prototype，由于prototype中是没有say函数的，所以调用会报错，但是之后我们强行改变了继承的对象，将foo的继承对象改为Bar.test，所以我们就能调用say函数了。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　我想你已经明白个大概了，prototype事实上并没有什么特殊的，硬要说有什么特殊的话，他只是被JavaScript默认为原型属性的存放点而已，他本质上只是个对象，原型链的重点就在于__proto__，你可以试着把__proto__当作桥梁，当我在对象内部找不到属性时，我就会通过这座桥梁到对面的对象里去寻找属性，直到找到为止或者对象里没有桥梁时才停下来。JavaScript就是通过这样的方式来形成原型链，实现继承的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后说一下，__proto__只是方便我们查看对象的原型而已，大家不要通过修改__proto__来实现继承的关系，而是要用如构造函数之类的方式来实现继承，这个我会放到以后的文章去说。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（ps:&lt;span&gt;可能有动手能力强的同学会自己去测试，发现__proto__里面也有__proto__，一直循环下去，无穷无尽，但事实上你去获取的时候你会发现Object.__proto__.__proto__.__proto__的值是null，也就是没有原型。&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 14:23:00 +0000</pubDate>
<dc:creator>envision</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/envision/p/JavaScript.html</dc:identifier>
</item>
</channel>
</rss>