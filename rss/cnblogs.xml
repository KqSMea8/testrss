<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaWeb项目架构之Kafka分布式日志队列 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/8422632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/8422632.html</guid>
<description>&lt;p&gt;架构、分布式、日志队列，标题自己都看着唬人，其实就是一个日志收集的功能，只不过中间加了一个Kafka做消息队列罢了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/109211/201802/109211-20180206153320123-1622886397.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;kafka介绍&quot;&gt;kafka介绍&lt;/h2&gt;
&lt;p&gt;Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。&lt;/p&gt;
&lt;h4 id=&quot;特性&quot;&gt;特性&lt;/h4&gt;
&lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。&lt;/li&gt;
&lt;li&gt;高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。&lt;/li&gt;
&lt;li&gt;支持通过Kafka服务器和消费机集群来分区消息。&lt;/li&gt;
&lt;li&gt;支持Hadoop并行数据加载。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;主要功能&quot;&gt;主要功能&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发布和订阅消息流，这个功能类似于消息队列，这也是kafka归类为消息队列框架的原因&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以容错的方式记录消息流，kafka以文件的方式来存储消息流&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以再消息发布的时候进行处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;h4 id=&quot;消息传输流程&quot;&gt;消息传输流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/109211/201802/109211-20180206153328373-1825184798.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;相关术语介绍&quot;&gt;相关术语介绍&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Broker&lt;/strong&gt;&lt;br/&gt;Kafka集群包含一个或多个服务器，这种服务器被称为broker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topic&lt;/strong&gt;&lt;br/&gt;每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition&lt;/strong&gt;&lt;br/&gt;Partition是物理上的概念，每个Topic包含一个或多个Partition.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Producer&lt;/strong&gt;&lt;br/&gt;负责发布消息到Kafka broker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer&lt;/strong&gt;&lt;br/&gt;消息消费者，向Kafka broker读取消息的客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer Group&lt;/strong&gt;&lt;br/&gt;每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka安装&quot;&gt;Kafka安装&lt;/h2&gt;
&lt;h4 id=&quot;环境&quot;&gt;环境&lt;/h4&gt;
&lt;p&gt;Linux、JDK、Zookeeper&lt;/p&gt;
&lt;h4 id=&quot;下载二进制程序&quot;&gt;下载二进制程序&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;wget https://archive.apache.org/dist/kafka/0.10.0.1/kafka_2.11-0.10.0.1.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf kafka_2.11-0.10.0.1.tgz
cd kafka_2.11-0.10.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;目录说明&quot;&gt;目录说明&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;bin 启动,停止等命令
config 配置文件
libs 类库&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参数说明&quot;&gt;参数说明&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#########################参数解释##############################

broker.id=0  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样

port=9092 #当前kafka对外提供服务的端口默认是9092

host.name=192.168.1.170 #这个参数默认是关闭的

num.network.threads=3 #这个是borker进行网络处理的线程数

num.io.threads=8 #这个是borker进行I/O处理的线程数

log.dirs=/opt/kafka/kafkalogs/ #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个

socket.send.buffer.bytes=102400 #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能

socket.receive.buffer.bytes=102400 #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘

socket.request.max.bytes=104857600 #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小

num.partitions=1 #默认的分区数，一个topic默认1个分区数

log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天

message.max.byte=5242880  #消息保存的最大值5M

default.replication.factor=2  #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务

replica.fetch.max.bytes=5242880  #取消息的最大直接数

log.segment.bytes=1073741824 #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件

log.retention.check.interval.ms=300000 #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除

log.cleaner.enable=false #是否启用log压缩，一般不用启用，启用的话可以提高性能

zookeeper.connect=192.168.1.180:12181,192.168.1.181:12181,192.168.1.182:1218 #设置zookeeper的连接端口、如果非集群配置一个地址即可

#########################参数解释##############################&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;启动kafka&quot;&gt;启动kafka&lt;/h4&gt;
&lt;p&gt;启动kafka之前要启动相应的zookeeper集群、自行安装，这里不做说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#进入到kafka的bin目录
./kafka-server-start.sh -daemon ../config/server.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;kafka集成&quot;&gt;Kafka集成&lt;/h2&gt;
&lt;h4 id=&quot;环境-1&quot;&gt;环境&lt;/h4&gt;
&lt;p&gt;spring-boot、elasticsearch、kafka&lt;/p&gt;
&lt;h4 id=&quot;pom.xml引入&quot;&gt;pom.xml引入：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- kafka 消息队列 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.kafka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-kafka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.1.RELEASE&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;生产者&quot;&gt;生产者&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.HashMap;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Map;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.kafka.clients.producer.ProducerConfig;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.kafka.common.serialization.StringSerializer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Value;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.annotation.EnableKafka;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.core.DefaultKafkaProducerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.core.KafkaTemplate;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.core.ProducerFactory;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 生产者&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建者 科帮网&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建时间 2018年2月4日&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableKafka&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KafkaProducerConfig {

    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.producer.servers}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String servers;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.producer.retries}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; retries;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.producer.batch.size}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; batchSize;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.producer.linger}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; linger;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.producer.buffer.memory}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bufferMemory;


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;producerConfigs&lt;/span&gt;() {
        Map&amp;lt;String, Object&amp;gt; props = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;BOOTSTRAP_SERVERS_CONFIG&lt;/span&gt;, servers);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;RETRIES_CONFIG&lt;/span&gt;, retries);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;BATCH_SIZE_CONFIG&lt;/span&gt;, batchSize);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;LINGER_MS_CONFIG&lt;/span&gt;, linger);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;BUFFER_MEMORY_CONFIG&lt;/span&gt;, bufferMemory);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;KEY_SERIALIZER_CLASS_CONFIG&lt;/span&gt;, StringSerializer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ProducerConfig.&lt;span class=&quot;fu&quot;&gt;VALUE_SERIALIZER_CLASS_CONFIG&lt;/span&gt;, StringSerializer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; props;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ProducerFactory&amp;lt;String, String&amp;gt; &lt;span class=&quot;fu&quot;&gt;producerFactory&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; DefaultKafkaProducerFactory&amp;lt;&amp;gt;(&lt;span class=&quot;fu&quot;&gt;producerConfigs&lt;/span&gt;());
    }

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; KafkaTemplate&amp;lt;String, String&amp;gt; &lt;span class=&quot;fu&quot;&gt;kafkaTemplate&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KafkaTemplate&amp;lt;String, String&amp;gt;(&lt;span class=&quot;fu&quot;&gt;producerFactory&lt;/span&gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;消费者&quot;&gt;消费者&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mport java.&lt;span class=&quot;fu&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;HashMap&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;import java.util.Map;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.kafka.clients.consumer.ConsumerConfig;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.kafka.common.serialization.StringDeserializer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Value;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.annotation.EnableKafka;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.config.KafkaListenerContainerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.core.ConsumerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.core.DefaultKafkaConsumerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 消费者&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建者 科帮网&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建时间 2018年2月4日&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableKafka&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KafkaConsumerConfig {
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.servers}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String servers;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.enable.auto.commit}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; enableAutoCommit;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.session.timeout}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String sessionTimeout;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.auto.commit.interval}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String autoCommitInterval;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.group.id}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String groupId;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.auto.offset.reset}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String autoOffsetReset;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${kafka.consumer.concurrency}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; concurrency;
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; KafkaListenerContainerFactory&amp;lt;ConcurrentMessageListenerContainer&amp;lt;String, String&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;kafkaListenerContainerFactory&lt;/span&gt;() {
        ConcurrentKafkaListenerContainerFactory&amp;lt;String, String&amp;gt; factory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentKafkaListenerContainerFactory&amp;lt;&amp;gt;();
        factory.&lt;span class=&quot;fu&quot;&gt;setConsumerFactory&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;consumerFactory&lt;/span&gt;());
        factory.&lt;span class=&quot;fu&quot;&gt;setConcurrency&lt;/span&gt;(concurrency);
        factory.&lt;span class=&quot;fu&quot;&gt;getContainerProperties&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setPollTimeout&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1500&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; factory;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ConsumerFactory&amp;lt;String, String&amp;gt; &lt;span class=&quot;fu&quot;&gt;consumerFactory&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; DefaultKafkaConsumerFactory&amp;lt;&amp;gt;(&lt;span class=&quot;fu&quot;&gt;consumerConfigs&lt;/span&gt;());
    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;consumerConfigs&lt;/span&gt;() {
        Map&amp;lt;String, Object&amp;gt; propsMap = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;BOOTSTRAP_SERVERS_CONFIG&lt;/span&gt;, servers);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;ENABLE_AUTO_COMMIT_CONFIG&lt;/span&gt;, enableAutoCommit);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;AUTO_COMMIT_INTERVAL_MS_CONFIG&lt;/span&gt;, autoCommitInterval);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;SESSION_TIMEOUT_MS_CONFIG&lt;/span&gt;, sessionTimeout);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;KEY_DESERIALIZER_CLASS_CONFIG&lt;/span&gt;, StringDeserializer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;VALUE_DESERIALIZER_CLASS_CONFIG&lt;/span&gt;, StringDeserializer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;GROUP_ID_CONFIG&lt;/span&gt;, groupId);
        propsMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;AUTO_OFFSET_RESET_CONFIG&lt;/span&gt;, autoOffsetReset);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; propsMap;
    }

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Listener &lt;span class=&quot;fu&quot;&gt;listener&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Listener&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;日志监听&quot;&gt;日志监听&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import org.apache.kafka.clients.consumer.ConsumerRecord;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.Logger;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.LoggerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.kafka.annotation.KafkaListener;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Component;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.itstyle.es.common.utils.JsonMapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itstyle.es.log.entity.SysLogs;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itstyle.es.log.repository.ElasticLogRepository;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 扫描监听&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建者 科帮网&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建时间 2018年2月4日&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Listener {
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Logger logger = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;  ElasticLogRepository elasticLogRepository;
    
    &lt;span class=&quot;fu&quot;&gt;@KafkaListener&lt;/span&gt;(topics = {&lt;span class=&quot;st&quot;&gt;&quot;itstyle&quot;&lt;/span&gt;})
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;listen&lt;/span&gt;(ConsumerRecord&amp;lt;?, ?&amp;gt; record) {
        logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;kafka的key: &quot;&lt;/span&gt; + record.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;());
        logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;kafka的value: &quot;&lt;/span&gt; + record.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(record.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;itstyle_log&quot;&lt;/span&gt;)){
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                SysLogs log = JsonMapper.&lt;span class=&quot;fu&quot;&gt;fromJsonString&lt;/span&gt;(record.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(), SysLogs.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;kafka保存日志: &quot;&lt;/span&gt; + log.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;());
                elasticLogRepository.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(log);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;测试日志传输&quot;&gt;测试日志传输&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * kafka 日志队列测试接口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
   &lt;span class=&quot;fu&quot;&gt;@GetMapping&lt;/span&gt;(value=&lt;span class=&quot;st&quot;&gt;&quot;kafkaLog&quot;&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@ResponseBody&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;kafkaLog&lt;/span&gt;() {
        SysLogs log = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SysLogs&lt;/span&gt;();
        log.&lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;红薯&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setOperation&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;开源中国社区&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.itstyle.es.log.controller.kafkaLog()&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setIp&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;192.168.1.80&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setGmtCreate&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Timestamp(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date().&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;()));
        log.&lt;span class=&quot;fu&quot;&gt;setExceptionDetail&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;开源中国社区&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setParams&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{'name':'码云','type':'开源'}&quot;&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setDeviceType&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setPlatFrom&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setLogType&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setDeviceType&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;200000&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setUserId&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        log.&lt;span class=&quot;fu&quot;&gt;setTime&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt;)&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//模拟日志队列实现&lt;/span&gt;
        String json = JsonMapper.&lt;span class=&quot;fu&quot;&gt;toJsonString&lt;/span&gt;(log);
        kafkaTemplate.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;itstyle&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;itstyle_log&quot;&lt;/span&gt;,json);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;;
   }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;kafka与redis&quot;&gt;Kafka与Redis&lt;/h2&gt;
&lt;p&gt;之前简单的介绍过，&lt;a href=&quot;https://blog.52itstyle.com/archives/2320/&quot; title=&quot;JavaWeb项目架构之Redis分布式日志队列&quot;&gt;JavaWeb项目架构之Redis分布式日志队列&lt;/a&gt;，有小伙伴们聊到， Redis PUB/SUB没有任何可靠性保障，也不会持久化。当然了，原项目中仅仅是记录日志，并不是十分重要的信息，可以有一定程度上的丢失&lt;/p&gt;
&lt;p&gt;Kafka与Redis PUB/SUB之间最大的区别在于Kafka是一个完整的分布式发布订阅消息系统，而Redis PUB/SUB只是一个组件而已。&lt;/p&gt;
&lt;h4 id=&quot;使用场景-1&quot;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Redis PUB/SUB&lt;br/&gt;消息持久性需求不高、吞吐量要求不高、可以忍受数据丢失&lt;/li&gt;
&lt;li&gt;Kafka&lt;br/&gt;高可用、高吞吐、持久性、多样化的消费处理模型&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;开源项目源码参考httpsgitee.com52itstylespring-boot-elasticsearch&quot;&gt;开源项目源码(参考)：&lt;a href=&quot;https://gitee.com/52itstyle/spring-boot-elasticsearch&quot; class=&quot;uri&quot;&gt;https://gitee.com/52itstyle/spring-boot-elasticsearch&lt;/a&gt;&lt;/h5&gt;
</description>
<pubDate>Tue, 06 Feb 2018 07:34:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smallSevens/p/8422632.html</dc:identifier>
</item>
<item>
<title>img标签实现和背景图一样的显示效果——object-fit和object-positon - web喵神</title>
<link>http://www.cnblogs.com/libo0125ok/p/8422617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/libo0125ok/p/8422617.html</guid>
<description>&lt;p&gt;不知大家在做前端页面的时候，有没有遇到类似这样的问题：有一个不是正方形的图片，可能是宽度大于高度的，也可能是高度大于宽度的，而你又并不想用背景图的方式来做，要实现用img标签来让此图片显示出一个正方形的且不变形的效果。即如下图：只显示图片中间部分（红框部分）&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1048036/201802/1048036-20180206151830857-1002784823.jpg&quot; alt=&quot;&quot; width=&quot;342&quot; height=&quot;473&quot;/&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下面我们便来简单讨论如何实现让长方形图片显示出正方形的效果，首先我们本次讨论中用到的两张图片的原图就是上面的两张图片（一张宽度大于高度，另一张高度大于宽度）&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1、背景图显示正方形效果的做法&lt;/h2&gt;
&lt;p&gt;首先还是从背景图的做法说起，遇到类似的问题，我们大部分人首先想到的是，能用背景图片做的话，就直接用背景图片来做了，至少我是这么想的。那么用背景图的方式是怎么做的，代码还是写一下如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;背景图的做法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        .bg-img1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(&quot;images/img1.jpg&quot;) center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; contain&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        .bg-img2 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(&quot;images/img2.jpg&quot;) center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; cover&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;背景图的做法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-img1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-img2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;页面效果如下图：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1048036/201802/1048036-20180206153343295-869322764.jpg&quot; alt=&quot;&quot; width=&quot;199&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然：背景图还可以实现很多其他效果，只需要background-size属性使用不同的值就可以实现不同的效果，例如：cover，contain，这里就不再一一赘述，因为我们重点要说的是关于img标签显示图片的问题。&lt;/p&gt;
&lt;h2&gt;2、img标签显示正方形效果的做法&lt;/h2&gt;
&lt;p&gt;首先、也是需要设置img标签的宽度和高度是一致的，另外需要用到一个关键的css属性——object-fit:cover。下面还是直接贴出代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;img标签的做法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        .img-1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            object-fit&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; cover&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        .img-2 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            object-fit&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; cover&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;img标签的做法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/img1.jpg&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;img-1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;images/img2.jpg&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;img-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1048036/201802/1048036-20180206152601607-2109490969.jpg&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;445&quot;/&gt;&lt;br/&gt;至此，已经实现了我们开头说的需求。&lt;/p&gt;
&lt;h2&gt;3、object-fit的其它值&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;那么object-fit属性还有哪些值呢？&lt;/strong&gt;&lt;br/&gt;　　object-fit: fill;&lt;br/&gt;　　object-fit: contain;&lt;br/&gt;　　object-fit: cover;&lt;br/&gt;　　object-fit: none;&lt;br/&gt;　　object-fit: scale-down;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;fill:&lt;/strong&gt; 中文释义“填充”。默认值。替换内容拉伸填满整个contentbox,不保证保持原有的比例。&lt;br/&gt;&lt;strong&gt;contain:&lt;/strong&gt; 中文释义“包含”。保持原有尺寸比例。保证替换内容尺寸一定可以在容器里面放得下。因此，此参数可能会在容器内留下空白。&lt;br/&gt;&lt;strong&gt;cover:&lt;/strong&gt; 中文释义“覆盖”。保持原有尺寸比例。保证替换内容尺寸一定大于容器尺寸，宽度和高度至少有一个和容器一致。因此，此参数可能会让替换内容（如图片）部分区域不可见（上面讲解的例子就是如此）。&lt;br/&gt;&lt;strong&gt;none:&lt;/strong&gt; 中文释义“无”。保持原有尺寸比例。同时保持替换内容原始尺寸大小。&lt;br/&gt;&lt;strong&gt;scale-down:&lt;/strong&gt; 中文释义“降低”。就好像依次设置了none或contain, 最终呈现的是尺寸比较小的那个。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面我们来测试一下每一个属性值显示的效果，为了更明显的看出区别，我们换另外一张图片。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;每个img标签都设置的 width:200px 和 width:200px，再加上设置的object-fit属性的不同值，效果图如下：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1048036/201802/1048036-20180206152833826-393488812.jpg&quot; alt=&quot;&quot; width=&quot;918&quot; height=&quot;486&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、object-position属性&lt;/h2&gt;
&lt;p&gt;object-position要比object-fit单纯的多，就是控制图片在盒子中显示位置的。默认值是50% 50%，也就是居中效果，所以，无论上一节object-fit值为那般，图片都是水平垂直居中的。因此，下次要实现尺寸大小不固定图片的垂直居中效果，可以试试object-fit.&lt;/p&gt;&lt;p&gt;与background-position类似，object-position的值类型为&amp;lt;position&amp;gt;类型值。也就是说，CSS3的相对坐标设定样式支持的。&lt;br/&gt;这里就不再代码实验了，自己可以动手试试。&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：目前IE应该还不支持object-fit和object-position属性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本博客根据阅读了张鑫旭的一篇博客后，自己动手实验后写的，张鑫旭的这篇博客地址是：&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2015/03/css3-object-position-object-fit/&quot; target=&quot;_blank&quot;&gt;http://www.zhangxinxu.com/wordpress/2015/03/css3-object-position-object-fit/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 06 Feb 2018 07:32:00 +0000</pubDate>
<dc:creator>web喵神</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/libo0125ok/p/8422617.html</dc:identifier>
</item>
<item>
<title>查询操作  -- Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8422534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8422534.html</guid>
<description>&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;查询操作是Django的ORM框架中最重要的内容之一。我们建立模型、保存数据为的就是在需要的时候可以查询得到数据。Django自动为所有的模型提供了一套完善、方便、高效的API，一些重要的，我们要背下来，一些不常用的，要有印象，使用的时候可以快速查找参考手册。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本节的内容基于如下的一个博客应用模型：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Blog(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
    tagline &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.name

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Author(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)
    email &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.EmailField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.name

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Entry(models.Model):
    blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Blog, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    headline &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;)
    body_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()
    pub_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()
    mod_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()
    authors &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ManyToManyField(Author)
    n_comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()
    n_pingbacks &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()
    rating &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.headline&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设模型位于&lt;code&gt;mysite/blog/models.py&lt;/code&gt;文件中，那么创建对象的方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Blog
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
&amp;gt;&amp;gt;&amp;gt; b.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在后台，这会运行一条SQL的INSERT语句。如果你不显式地调用save()方法，Django不会立刻将该操作反映到数据库中。save()方法没有返回值，它可以接受一些额外的参数。&lt;/p&gt;
&lt;p&gt;如果想要一行代码完成上面的操作，请使用&lt;code&gt;creat()&lt;/code&gt;方法，它可以省略save的步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = Blog.objects.create(name='Beatles Blog', tagline='All the latest Beatles news.')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用save()方法，保存对数据库内已有对象的修改。例如如果已经存在b5对象在数据库内：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b5.name = 'New name'
&amp;gt;&amp;gt;&amp;gt; b5.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在后台，这会运行一条SQL的UPDATE语句。如果你不显式地调用save()方法，Django不会立刻将该操作反映到数据库中。&lt;/p&gt;
&lt;h2 id=&quot;保存外键和多对多字段&quot;&gt;1. 保存外键和多对多字段&lt;/h2&gt;
&lt;p&gt;保存一个外键字段和保存普通字段没什么区别，只是要注意值的类型要正确。下面的例子，有一个Entry的实例entry和一个Blog的实例&lt;code&gt;cheese_blog&lt;/code&gt;，然后把&lt;code&gt;cheese_blog&lt;/code&gt;作为值赋给了entry的blog属性，最后调用save方法进行保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Entry
&amp;gt;&amp;gt;&amp;gt; entry = Entry.objects.get(pk=1)
&amp;gt;&amp;gt;&amp;gt; cheese_blog = Blog.objects.get(name=&quot;Cheddar Talk&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.blog = cheese_blog
&amp;gt;&amp;gt;&amp;gt; entry.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多对多字段的保存稍微有点区别，需要调用一个&lt;code&gt;add()&lt;/code&gt;方法，而不是直接给属性赋值，但它不需要调用save方法。如下例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Author
&amp;gt;&amp;gt;&amp;gt; joe = Author.objects.create(name=&quot;Joe&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(joe)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一行语句内，可以同时添加多个对象到多对多的字段，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; john = Author.objects.create(name=&quot;John&quot;)
&amp;gt;&amp;gt;&amp;gt; paul = Author.objects.create(name=&quot;Paul&quot;)
&amp;gt;&amp;gt;&amp;gt; george = Author.objects.create(name=&quot;George&quot;)
&amp;gt;&amp;gt;&amp;gt; ringo = Author.objects.create(name=&quot;Ringo&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(john, paul, george, ringo)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你指定或添加了错误类型的对象，Django会抛出异常。&lt;/p&gt;

&lt;p&gt;想要从数据库内检索对象，你需要基于模型类，通过管理器（Manager）构造一个查询结果集（QuerySet）。&lt;/p&gt;
&lt;p&gt;每个QuerySet代表一些数据库对象的集合。它可以包含零个、一个或多个过滤器（filters）。Filters缩小查询结果的范围。在SQL语法中，一个QuerySet相当于一个SELECT语句，而filter则相当于WHERE或者LIMIT一类的子句。&lt;/p&gt;
&lt;p&gt;通过模型的Manager获得QuerySet，每个模型至少具有一个Manager，默认情况下，它被称作&lt;code&gt;objects&lt;/code&gt;，可以通过模型类直接调用它，但不能通过模型类的实例调用它，以此实现“表级别”操作和“记录级别”操作的强制分离。如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects
&amp;lt;django.db.models.manager.Manager object at ...&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Foo', tagline='Bar')
&amp;gt;&amp;gt;&amp;gt; b.objects
Traceback:
...
AttributeError: &quot;Manager isn't accessible via Blog instances.&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;检索所有对象&quot;&gt;1. 检索所有对象&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;all()&lt;/code&gt;方法，可以获取某张表的所有记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; all_entries = Entry.objects.all()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;过滤对象&quot;&gt;2. 过滤对象&lt;/h2&gt;
&lt;p&gt;有两个方法可以用来过滤QuerySet的结果，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;filter(**kwargs)&lt;/code&gt;：返回一个根据指定参数查询出来的QuerySet&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exclude(**kwargs)&lt;/code&gt;：返回除了根据指定参数查询出来结果的QuerySet&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，&lt;code&gt;**kwargs&lt;/code&gt;参数的格式必须是Django设置的一些字段格式。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.filter(pub_date__year=2006)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.all().filter(pub_date__year=2006)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;链式过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;filter和exclude的结果依然是个QuerySet，因此它可以继续被filter和exclude，这就形成了链式过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(
...     headline__startswith='What'
... ).exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(
...     pub_date__gte=datetime(2005, 1, 30)
... )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（这里需要注意的是，当在进行跨关系的链式过滤时，结果可能和你想象的不一样，参考下面的跨多值关系查询）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被过滤的QuerySets都是唯一的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一次过滤，你都会获得一个全新的QuerySet，它和之前的QuerySet没有任何关系，可以完全独立的被保存，使用和重用。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q1 = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q2 = q1.exclude(pub_date__gte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q3 = q1.filter(pub_date__gte=datetime.date.today())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中的q2和q3虽然由q1得来，是q1的子集，但是都是独立自主存在的。同样q1也不会受到q2和q3的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QuerySets都是懒惰的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个创建QuerySets的动作不会立刻导致任何的数据库行为。你可以不断地进行filter动作一整天，Django不会运行任何实际的数据库查询动作，直到QuerySets被提交(evaluated)。&lt;/p&gt;
&lt;p&gt;简而言之就是，只有碰到某些特定的操作，Django才会将所有的操作体现到数据库内，否则它们只是保存在内存和Django的层面中。这是一种提高数据库查询效率，减少操作次数的优化设计。看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q = q.filter(pub_date__lte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q = q.exclude(body_text__icontains=&quot;food&quot;)
&amp;gt;&amp;gt;&amp;gt; print(q)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子，看起来执行了3次数据库访问，实际上只是在print语句时才执行1次访问。通常情况，QuerySets的检索不会立刻执行实际的数据库查询操作，直到出现类似print的请求，也就是所谓的evaluated。&lt;/p&gt;
&lt;h2 id=&quot;检索单一对象&quot;&gt;3. 检索单一对象&lt;/h2&gt;
&lt;p&gt;filter方法始终返回的是QuerySets，那怕只有一个对象符合过滤条件，返回的也是包含一个对象的QuerySets，这是一个集合类型对象，你可以简单的理解为Python列表，可迭代可循环可索引。&lt;/p&gt;
&lt;p&gt;如果你确定你的检索只会获得一个对象，那么你可以使用Manager的get()方法来直接返回这个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; one_entry = Entry.objects.get(pk=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在get方法中你可以使用任何filter方法中的查询参数，用法也是一模一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：使用get()方法和使用filter()方法然后通过[0]的方式分片，有着不同的地方。看似两者都是获取单一对象。但是，&lt;strong&gt;如果在查询时没有匹配到对象，那么get()方法将抛出DoesNotExist异常&lt;/strong&gt;。这个异常是模型类的一个属性，在上面的例子中，如果不存在主键为1的Entry对象，那么Django将抛出&lt;code&gt;Entry.DoesNotExist&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;类似地，&lt;strong&gt;在使用get()方法查询时，如果结果超过1个，则会抛出MultipleObjectsReturned异常&lt;/strong&gt;，这个异常也是模型类的一个属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以：get()方法要慎用！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它queryset方法&quot;&gt;4. 其它QuerySet方法&lt;/h2&gt;
&lt;p&gt;大多数情况下，需要从数据库中查找对象时，使用all()、 get()、filter() 和exclude()就行。针对QuerySet的方法还有很多，都是一些相对高级的用法。&lt;/p&gt;
&lt;h2 id=&quot;queryset使用限制&quot;&gt;5. QuerySet使用限制&lt;/h2&gt;
&lt;p&gt;使用类似Python对列表进行切片的方法可以对QuerySet进行范围取值。它相当于SQL语句中的LIMIT和OFFSET子句。参考下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:5]      # 返回前5个对象
&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[5:10]    # 返回第6个到第10个对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：不支持负索引！例如 Entry.objects.all()[-1]是不允许的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常情况，切片操作会返回一个新的QuerySet，并且不会被立刻执行。但是有一个例外，那就是指定步长的时候，查询操作会立刻在数据库内执行，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:10:2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若要获取单一的对象而不是一个列表（例如，SELECT foo FROM bar LIMIT 1），可以简单地使用索引而不是切片。例如，下面的语句返回数据库中根据标题排序后的第一条Entry：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它相当于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0:1].get()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果没有匹配到对象，那么第一种方法会抛出IndexError异常，而第二种方式会抛出DoesNotExist异常。&lt;/p&gt;
&lt;p&gt;也就是说在使用get和切片的时候，要注意查询结果的元素个数。&lt;/p&gt;
&lt;h2 id=&quot;字段查询&quot;&gt;6. 字段查询&lt;/h2&gt;
&lt;p&gt;字段查询其实就是filter()、exclude()和get()等方法的关键字参数。&lt;br/&gt;其基本格式是：&lt;code&gt;field__lookuptype=value&lt;/code&gt;，&lt;strong&gt;注意其中是双下划线&lt;/strong&gt;。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__lte='2006-01-01')
#　相当于：
SELECT * FROM blog_entry WHERE pub_date &amp;lt;= '2006-01-01';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的字段必须是模型中定义的字段之一。但是有一个例外，那就是ForeignKey字段，你可以为其添加一个“_id”后缀（单下划线）。这种情况下键值是外键模型的主键原生值。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog_id=4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你传递了一个非法的键值，查询函数会抛出TypeError异常。&lt;/p&gt;
&lt;p&gt;Django的数据库API支持20多种查询类型，下面介绍一些常用的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exact：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认类型。如果你不提供查询类型，或者关键字参数不包含一个双下划线，那么查询类型就是这个默认的exact。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.get(headline__exact=&quot;Cat bites dog&quot;)
# 相当于
# SELECT ... WHERE headline = 'Cat bites dog';
# 下面两个相当
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id__exact=14)  # Explicit form
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id=14)         # __exact is implied&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;iexact：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不区分大小写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(name__iexact=&quot;beatles blog&quot;)
# 匹配&quot;Beatles Blog&quot;, &quot;beatles blog&quot;,甚至&quot;BeAtlES blOG&quot;.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;contains：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示包含的意思！大小写敏感！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.get(headline__contains='Lennon')
# 相当于
# SELECT ... WHERE headline LIKE '%Lennon%';
# 匹配'Today Lennon honored'，但不匹配'today lennon honored'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;icontains：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;contains的大小写不敏感模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;startswith和endswith&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以什么开头和以什么结尾。大小写敏感！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;istartswith和iendswith&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是不区分大小写的模式。&lt;/p&gt;
&lt;h2 id=&quot;跨越关系查询&quot;&gt;7. 跨越关系查询&lt;/h2&gt;
&lt;p&gt;Django提供了强大并且直观的方式解决跨越关联的查询，它在后台自动执行包含JOIN的SQL语句。要跨越某个关联，只需使用关联的模型字段名称，并使用双下划线分隔，直至你想要的字段（可以链式跨越，无限跨度）。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 返回所有Blog的name为'Beatles Blog'的Entry对象
# 一定要注意，返回的是Entry对象，而不是Blog对象。
# objects前面用的是哪个class，返回的就是哪个class的对象。
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__name='Beatles Blog')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反之亦然，如果要引用一个反向关联，只需要使用模型的小写名!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取所有的Blog对象，前提是它所关联的Entry的headline包含'Lennon'
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(entry__headline__contains='Lennon')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你在多级关联中进行过滤而且其中某个中间模型没有满足过滤条件的值，Django将把它当做一个空的（所有的值都为NULL）但是合法的对象，不会抛出任何异常或错误。例如，在下面的过滤器中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.filter(entry__authors__name='Lennon')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Entry中没有关联任何的author，那么它将当作其没有name，而不会因为没有author 引发一个错误。通常，这是比较符合逻辑的处理方式。唯一可能让你困惑的是当你使用&lt;code&gt;isnull&lt;/code&gt;的时候：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.filter(entry__authors__name__isnull=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将返回Blog对象，它关联的entry对象的author字段的name字段为空，以及Entry对象的author字段为空。如果你不需要后者，你可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.filter(entry__authors__isnull=False,entry__authors__name__isnull=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;跨越多值的关系查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的filter和exclude的关键字参数只有一个，这种情况很好理解。但是当关键字参数有多个，且是跨越外键或者多对多的情况下，那么就比较复杂，让人迷惑了。我们看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个跨外键、两个过滤参数的查询。此时我们理解两个参数之间属于-与“and”的关系，也就是说，过滤出来的BLog对象对应的entry对象必须同时满足上面两个条件。这点很好理解。也就是说&lt;strong&gt;上面要求至少有一个entry同时满足两个条件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，看下面的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把两个参数拆开，放在两个filter调用里面，按照我们前面说过的链式过滤，这个结果应该和上面的例子一样。可实际上，它不一样，Django在这种情况下，将两个filter之间的关系设计为-或“or”，这真是让人头疼。&lt;/p&gt;
&lt;p&gt;多对多关系下的多值查询和外键foreignkey的情况一样。&lt;/p&gt;
&lt;p&gt;但是，更头疼的来了，exclude的策略设计的又和filter不一样！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.exclude(entry__headline__contains='Lennon',entry__pub_date__year=2008,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会排除headline中包含“Lennon”的Entry和在2008年发布的Entry，中间是一个-和“or”的关系！&lt;/p&gt;
&lt;p&gt;那么要排除同时满足上面两个条件的对象，该怎么办呢？看下面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.exclude(
entry=Entry.objects.filter(
    headline__contains='Lennon',
    pub_date__year=2008,
),
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（有没有很坑爹的感觉？所以，建议在碰到跨关系的多值查询时，尽量使用Q查询）&lt;/p&gt;
&lt;h2 id=&quot;使用f表达式引用模型的字段&quot;&gt;8. 使用F表达式引用模型的字段&lt;/h2&gt;
&lt;p&gt;到目前为止的例子中，我们都是将模型字段与常量进行比较。但是，如果你想将模型的一个字段与同一个模型的另外一个字段进行比较该怎么办？&lt;/p&gt;
&lt;p&gt;使用Django提供的F表达式！&lt;/p&gt;
&lt;p&gt;例如，为了查找comments数目多于pingbacks数目的Entry，可以构造一个&lt;code&gt;F()&lt;/code&gt;对象来引用pingback数目，并在查询中使用该F()对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import F
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django支持对F()对象进行加、减、乘、除、取模以及幂运算等算术操作。两个操作数可以是常数和其它F()对象。例如查找comments数目比pingbacks两倍还要多的Entry，我们可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了查询rating比pingback和comment数目总和要小的Entry，我们可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以在F()中使用双下划线来进行跨表查询。例如，查询author的名字与blog名字相同的Entry：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(authors__name=F('blog__name'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于date和date/time字段，还可以加或减去一个timedelta对象。下面的例子将返回发布时间超过3天后被修改的所有Entry：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import timedelta
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F()对象还支持&lt;code&gt;.bitand()&lt;/code&gt;、&lt;code&gt;.bitor()&lt;/code&gt;、&lt;code&gt;.bitrightshift()&lt;/code&gt;和&lt;code&gt;.bitleftshift()&lt;/code&gt;4种位操作，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; F('somefield').bitand(16)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;主键的快捷查询方式pk&quot;&gt;9. 主键的快捷查询方式：pk&lt;/h2&gt;
&lt;p&gt;pk就是&lt;code&gt;primary key&lt;/code&gt;的缩写。通常情况下，一个模型的主键为“id”，所以下面三个语句的效果一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id__exact=14) # Explicit form
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id=14) # __exact is implied
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(pk=14) # pk implies id__exact&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以联合其他类型的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Get blogs entries with id 1, 4 and 7
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(pk__in=[1,4,7])
# Get all blog entries with id &amp;gt; 14
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(pk__gt=14)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以跨表操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__id__exact=3) 
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__id=3) 
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__pk=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（&lt;strong&gt;当主键不是id的时候，请注意了！&lt;/strong&gt;）&lt;/p&gt;
&lt;h2 id=&quot;在like语句中转义百分符号和下划线&quot;&gt;10. 在LIKE语句中转义百分符号和下划线&lt;/h2&gt;
&lt;p&gt;在原生SQL语句中&lt;code&gt;%&lt;/code&gt;符号有特殊的作用。Django帮你自动转义了百分符号和下划线，你可以和普通字符一样使用它们，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='%')
# 它和下面的一样
# SELECT ... WHERE headline LIKE '%\%%';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缓存与查询集&quot;&gt;11. 缓存与查询集&lt;/h2&gt;
&lt;p&gt;每个QuerySet都包含一个缓存，用于减少对数据库的实际操作。理解这个概念，有助于你提高查询效率。&lt;/p&gt;
&lt;p&gt;对于新创建的QuerySet，它的缓存是空的。当QuerySet第一次被提交后，数据库执行实际的查询操作，Django会把查询的结果保存在QuerySet的缓存内，随后的对于该QuerySet的提交将重用这个缓存的数据。&lt;/p&gt;
&lt;p&gt;要想高效的利用查询结果，降低数据库负载，你必须善于利用缓存。看下面的例子，这会造成2次实际的数据库操作，加倍数据库的负载，同时由于时间差的问题，可能在两次操作之间数据被删除或修改或添加，导致脏数据的问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print([e.headline for e in Entry.objects.all()])
&amp;gt;&amp;gt;&amp;gt; print([e.pub_date for e in Entry.objects.all()])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了避免上面的问题，好的使用方式如下，这只产生一次实际的查询操作，并且保持了数据的一致性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; queryset = Entry.objects.all()
&amp;gt;&amp;gt;&amp;gt; print([p.headline for p in queryset]) # 提交查询
&amp;gt;&amp;gt;&amp;gt; print([p.pub_date for p in queryset]) # 重用查询缓存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;何时不会被缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些操作不会缓存QuerySet，例如切片和索引。这就导致这些操作没有缓存可用，每次都会执行实际的数据库查询操作。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; queryset = Entry.objects.all()
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # 查询数据库
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # 再次查询数据库&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果已经遍历过整个QuerySet，那么就相当于缓存过，后续的操作则会使用缓存，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; queryset = Entry.objects.all()
&amp;gt;&amp;gt;&amp;gt; [entry for entry in queryset] # 查询数据库
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # 使用缓存
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # 使用缓存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的这些操作都将遍历QuerySet并建立缓存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [entry for entry in queryset]
&amp;gt;&amp;gt;&amp;gt; bool(queryset)
&amp;gt;&amp;gt;&amp;gt; entry in queryset
&amp;gt;&amp;gt;&amp;gt; list(queryset)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：简单的打印QuerySet并不会建立缓存，因为&lt;code&gt;__repr__()&lt;/code&gt;调用只返回全部查询集的一个切片。&lt;/p&gt;

&lt;p&gt;普通filter函数里的条件都是“and”逻辑，如果你想实现“or”逻辑怎么办？用Q查询！&lt;/p&gt;
&lt;p&gt;Q来自&lt;code&gt;django.db.models.Q&lt;/code&gt;，用于封装关键字参数的集合，可以作为关键字参数用于filter、exclude和get等函数。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db.models import Q
Q(question__startswith='What')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用“&amp;amp;”或者“|”或“~”来组合Q对象，分别表示与或非逻辑。它将返回一个新的Q对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Q(question__startswith='Who')|Q(question__startswith='What')
# 这相当于：
WHERE question LIKE 'Who%' OR question LIKE 'What%'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Q(question__startswith='Who') | ~Q(pub_date__year=2005)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以这么使用，默认情况下，以逗号分隔的都表示AND关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Poll.objects.get(
Q(question__startswith='Who'),
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
# 它相当于
# SELECT * from polls WHERE question LIKE 'Who%'
AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当关键字参数和Q对象组合使用时，Q对象必须放在前面，如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Poll.objects.get(
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),question__startswith='Who',)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果关键字参数放在Q对象的前面，则会报错。&lt;/p&gt;

&lt;p&gt;要比较两个模型实例，只需要使用python提供的双等号比较符就可以了。在后台，其实比较的是两个实例的主键的值。下面两种方法是等同的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; some_entry == other_entry
&amp;gt;&amp;gt;&amp;gt; some_entry.id == other_entry.id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果模型的主键不叫做“id”也没关系，后台总是会使用正确的主键名字进行比较，例如，如果一个模型的主键的名字是“name”，那么下面是相等的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; some_obj == other_obj
&amp;gt;&amp;gt;&amp;gt; some_obj.name == other_obj.name&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;删除对象使用的是对象的&lt;code&gt;delete()&lt;/code&gt;方法。该方法将返回被删除对象的总数量和一个字典，字典包含了每种被删除对象的类型和该类型的数量。如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e.delete()
(1, {'weblog.Entry': 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以批量删除。每个QuerySet都有一个delete()方法，它能删除该QuerySet的所有成员。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__year=2005).delete()
(5, {'webapp.Entry': 5})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，有可能不是每一个对象的delete方法都被执行。如果你改写了delete方法，为了确保对象被删除，你必须手动迭代QuerySet进行逐一删除操作。&lt;/p&gt;
&lt;p&gt;当Django删除一个对象时，它默认使用SQL的ON DELETE CASCADE约束，也就是说，任何有外键指向要删除对象的对象将一起被删除。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = Blog.objects.get(pk=1)
# 下面的动作将删除该条Blog和所有的它关联的Entry对象
b.delete()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种级联的行为可以通过的ForeignKey的&lt;code&gt;on_delete&lt;/code&gt;参数自定义。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;delete()&lt;/code&gt;是唯一没有在管理器上暴露出来的方法。这是刻意设计的一个安全机制，用来防止你意外地请求类似&lt;code&gt;Entry.objects.delete()&lt;/code&gt;的动作，而不慎删除了所有的条目。如果你确实想删除所有的对象，你必须明确地请求一个完全的查询集，像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.all().delete()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;虽然没有内置的方法用于复制模型的实例，但还是很容易创建一个新的实例并将原实例的所有字段都拷贝过来。最简单的方法是将原实例的pk设置为None，这会创建一个新的实例copy。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save() # blog.pk == 1
#
blog.pk = None
blog.save() # blog.pk == 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在使用继承的时候，情况会变得复杂，如果有下面一个Blog的子类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThemeBlog(Blog):
    theme &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)

django_blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; ThemeBlog(name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Django'&lt;/span&gt;, tagline&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Django is easy'&lt;/span&gt;, theme&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'python'&lt;/span&gt;)
django_blog.save() &lt;span class=&quot;co&quot;&gt;# django_blog.pk == 3&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于继承的工作机制，你必须同时将pk和id设为None：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;django_blog.pk = None
django_blog.id = None
django_blog.save() # django_blog.pk == 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于外键和多对多关系，更需要进一步处理。例如，Entry有一个ManyToManyField到Author。 复制条目后，您必须为新条目设置多对多关系，像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;entry = Entry.objects.all()[0] # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry.save()
entry.authors.set(old_authors)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于OneToOneField，还要复制相关对象并将其分配给新对象的字段，以避免违反一对一唯一约束。 例如，假设entry已经如上所述重复：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;detail = EntryDetail.objects.all()[0]
detail.pk = None
detail.entry = entry
detail.save()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;update()&lt;/code&gt;方法可以批量为QuerySet中所有的对象进行更新操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 更新所有2007年发布的entry的headline
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只可以对普通字段和ForeignKey字段使用这个方法。若要更新一个普通字段，只需提供一个新的常数值。若要更新ForeignKey字段，需设置新值为你想指向的新模型实例。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(pk=1)
# 修改所有的Entry，让他们都属于b
&amp;gt;&amp;gt;&amp;gt; Entry.objects.all().update(blog=b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;update方法会被立刻执行，并返回操作匹配到的行的数目（有可能不等于要更新的行的数量，因为有些行可能已经有这个新值了）。唯一的约束是：只能访问一张数据库表。你可以根据关系字段进行过滤，但你只能更新模型主表的字段。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(pk=1)
# Update all the headlines belonging to this Blog.
&amp;gt;&amp;gt;&amp;gt; Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意的是update()方法会直接转换成一个SQL语句，并立刻批量执行。它不会运行模型的save()方法，或者产生&lt;code&gt;pre_save&lt;/code&gt;或&lt;code&gt;post_save&lt;/code&gt;信号（调用&lt;code&gt;save()&lt;/code&gt;方法产生）或者服从&lt;code&gt;auto_now&lt;/code&gt;字段选项。如果你想保存QuerySet中的每个条目并确保每个实例的save()方法都被调用，你不需要使用任何特殊的函数来处理。只需要迭代它们并调用save()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for item in my_queryset:
    item.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;update方法可以配合F表达式。这对于批量更新同一模型中某个字段特别有用。例如增加Blog中每个Entry的pingback个数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，与filter和exclude子句中的F()对象不同，在update中你不可以使用F()对象进行跨表操作，你只可以引用正在更新的模型的字段。如果你尝试使用F()对象引入另外一张表的字段，将抛出FieldError异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# THIS WILL RAISE A FieldError
&amp;gt;&amp;gt;&amp;gt; Entry.objects.update(headline=F('blog__name'))&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;利用本节一开始的模型，一个Entry对象e可以通过blog属性&lt;code&gt;e.blog&lt;/code&gt;获取关联的Blog对象。反过来，Blog对象b可以通过&lt;code&gt;entry_set&lt;/code&gt;属性&lt;code&gt;b.entry_set.all()&lt;/code&gt;访问与它关联的所有Entry对象。&lt;/p&gt;
&lt;h2 id=&quot;一对多外键&quot;&gt;1. 一对多（外键）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;正向查询:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接通过圆点加属性，访问外键对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog # 返回关联的Blog对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意的是，对外键的修改，必须调用save方法进行保存，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = some_blog
&amp;gt;&amp;gt;&amp;gt; e.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一个外键字段设置有&lt;code&gt;null=True&lt;/code&gt;属性，那么可以通过给该字段赋值为None的方法移除外键值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = None
&amp;gt;&amp;gt;&amp;gt; e.save() # &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第一次对一个外键关系进行正向访问的时候，关系对象会被缓存。随后对同样外键关系对象的访问会使用这个缓存，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog)  # 访问数据库，获取实际数据
&amp;gt;&amp;gt;&amp;gt; print(e.blog)  # 不会访问数据库，直接使用缓存的版本&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意QuerySet的&lt;code&gt;select_related()&lt;/code&gt;方法会递归地预填充所有的一对多关系到缓存中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.select_related().get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog)  # 不会访问数据库，直接使用缓存
&amp;gt;&amp;gt;&amp;gt; print(e.blog)  # 不会访问数据库，直接使用缓存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;反向查询:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个模型有ForeignKey，那么该ForeignKey所指向的外键模型的实例可以通过一个管理器进行反向查询，返回源模型的所有实例。默认情况下，这个管理器的名字为&lt;code&gt;FOO_set&lt;/code&gt;，其中FOO是源模型的小写名称。该管理器返回的查询集可以用前面提到的方式进行过滤和操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entry_set.all() # Returns all Entry objects related to Blog.
# b.entry_set is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entry_set.filter(headline__contains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entry_set.count()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在ForeignKey字段的定义中，通过设置&lt;code&gt;related_name&lt;/code&gt;来重写&lt;code&gt;FOO_set&lt;/code&gt;的名字。举例说明，如果你修改Entry模型&lt;code&gt;blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)&lt;/code&gt;，那么上面的例子会变成下面的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entries.all() # Returns all Entry objects related to Blog.
# b.entries is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entries.filter(headline__contains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entries.count()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用自定义的反向管理器:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，用于反向关联的RelatedManager是该模型默认管理器的子类。如果你想为一个查询指定一个不同的管理器，你可以使用下面的语法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Entry(models.Model):
    &lt;span class=&quot;co&quot;&gt;#...&lt;/span&gt;
    objects &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.Manager()  &lt;span class=&quot;co&quot;&gt;# 默认管理器&lt;/span&gt;
    entries &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; EntryManager()    &lt;span class=&quot;co&quot;&gt;# 自定义管理器&lt;/span&gt;

b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Blog.objects.get(&lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
b.entry_set(manager&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'entries'&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，指定的自定义反向管理器也可以调用它的自定义方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b.entry_set(manager='entries').is_published()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;处理关联对象的其它方法:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了在前面定义的QuerySet方法之外，ForeignKey管理器还有其它方法用于处理关联的对象集合。下面是每个方法的概括。&lt;/p&gt;
&lt;p&gt;add(obj1, obj2, ...)：添加指定的模型对象到关联的对象集中。&lt;/p&gt;
&lt;p&gt;create(**kwargs)：创建一个新的对象，将它保存并放在关联的对象集中。返回新创建的对象。&lt;/p&gt;
&lt;p&gt;remove(obj1, obj2, ...)：从关联的对象集中删除指定的模型对象。&lt;/p&gt;
&lt;p&gt;clear()：清空关联的对象集。&lt;/p&gt;
&lt;p&gt;set(objs)：重置关联的对象集。&lt;/p&gt;
&lt;p&gt;若要一次性给关联的对象集赋值，使用set()方法，并给它赋值一个可迭代的对象集合或者一个主键值的列表。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，e1和e2可以是完整的Entry实例，也可以是整数的主键值。&lt;/p&gt;
&lt;p&gt;如果clear()方法可用，那么在将可迭代对象中的成员添加到集合中之前，将从&lt;code&gt;entry_set&lt;/code&gt;中删除所有已经存在的对象。如果clear()方法不可用，那么将直接添加可迭代对象中的成员而不会删除所有已存在的对象。&lt;/p&gt;
&lt;p&gt;这节中的每个反向操作都将立即在数据库内执行。所有的增加、创建和删除操作也将立刻自动地保存到数据库内。&lt;/p&gt;
&lt;h2 id=&quot;多对多&quot;&gt;2. 多对多&lt;/h2&gt;
&lt;p&gt;多对多关系的两端都会自动获得访问另一端的API。这些API的工作方式与前面提到的“反向”一对多关系的用法一样。&lt;/p&gt;
&lt;p&gt;唯一的区别在于属性的名称：定义ManyToManyField的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上'_set' （和一对多关系一样）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;e = Entry.objects.get(id=3)
e.authors.all() # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains='John')
#
a = Author.objects.get(id=5)
a.entry_set.all() # Returns all Entry objects for this Author.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与外键字段中一样，在多对多的字段中也可以指定&lt;code&gt;related_name&lt;/code&gt;名。&lt;/p&gt;
&lt;p&gt;（注：在一个模型中，如果存在多个外键或多对多的关系指向同一个外部模型，必须给他们分别加上不同的&lt;code&gt;related_name&lt;/code&gt;，用于反向查询）&lt;/p&gt;
&lt;h2 id=&quot;一对一&quot;&gt;3. 一对一&lt;/h2&gt;
&lt;p&gt;一对一非常类似多对一关系，可以简单的通过模型的属性访问关联的模型。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; EntryDetail(models.Model):
    entry &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.OneToOneField(Entry, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    details &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()

ed &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; EntryDetail.objects.get(&lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
ed.entry &lt;span class=&quot;co&quot;&gt;# Returns the related Entry object.&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同之处在于反向查询的时候。一对一关系中的关联模型同样具有一个管理器对象，但是该管理器表示一个单一的对象而不是对象的集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;e = Entry.objects.get(id=2)
e.entrydetail # 返回关联的EntryDetail对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有对象赋值给这个关系，Django将抛出一个DoesNotExist异常。&lt;br/&gt;可以给反向关联进行赋值，方法和正向的关联一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;e.entrydetail = ed&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;反向关联是如何实现的&quot;&gt;4. 反向关联是如何实现的？&lt;/h2&gt;
&lt;p&gt;一些ORM框架需要你在关系的两端都进行定义。Django的开发者认为这违反了DRY (Don’t Repeat Yourself)原则，所以在Django中你只需要在一端进行定义。&lt;/p&gt;
&lt;p&gt;那么这是怎么实现的呢？因为在关联的模型类没有被加载之前，一个模型类根本不知道有哪些类和它关联。&lt;/p&gt;
&lt;p&gt;答案在&lt;code&gt;app registry&lt;/code&gt;！在Django启动的时候，它会导入所有&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中的应用和每个应用中的模型模块。每创建一个新的模型时，Django会自动添加反向的关系到所有关联的模型。如果关联的模型还没有导入，Django将保存关联的记录并在关联的模型导入时添加这些关系。&lt;/p&gt;
&lt;p&gt;由于这个原因，将模型所在的应用都定义在&lt;code&gt;INSTALLED_APPS&lt;/code&gt;的应用列表中就显得特别重要。否则，反向关联将不能正确工作。&lt;/p&gt;
&lt;h2 id=&quot;通过关联对象进行查询&quot;&gt;5. 通过关联对象进行查询&lt;/h2&gt;
&lt;p&gt;涉及关联对象的查询与正常值的字段查询遵循同样的规则。当你指定查询需要匹配的值时，你可以使用一个对象实例或者对象的主键值。&lt;/p&gt;
&lt;p&gt;例如，如果你有一个id=5的Blog对象b，下面的三个查询将是完全一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.filter(blog=b) # 使用对象实例
Entry.objects.filter(blog=b.id) # 使用实例的id
Entry.objects.filter(blog=5) # 直接使用id&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果你发现需要编写的Django查询语句太复杂，你可以回归到手工编写SQL语句。Django对于编写原生的SQL查询有许多选项。&lt;/p&gt;
&lt;p&gt;最后，需要注意的是Django的数据库层只是一个数据库接口。你可以利用其它的工具、编程语言或数据库框架来访问数据库，Django没有强制指定你非要使用它的某个功能或模块。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 07:19:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8422534.html</dc:identifier>
</item>
<item>
<title>Java基础系列--Executor框架（一） - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/8393618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/8393618.html</guid>
<description>&lt;p&gt;原创作品，可以转载，但是请标注出处地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java基础系列--Executor框架&quot; href=&quot;http://www.cnblogs.com/V1haoge/p/8393618.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/V1haoge/p/8393618.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一、Executor框架介绍&lt;/p&gt;
&lt;p&gt;　　Executor框架是JDK1.5之后出现的，位于juc包中，是并发程序设计的工具之一。各个版本以来一直在进行修正。&lt;/p&gt;
&lt;p&gt;　　Executor是执行者之意，表示任务的执行者，这里的任务指的是新的线程任务（实现Runnable接口的执行任务）。&lt;/p&gt;
&lt;p&gt;　　整个Executor执行者框架包括多个接口和类，甚至还涉及到阻塞队列的使用，协同实现任务的执行。&lt;/p&gt;
&lt;p&gt;　　下面是简单的Executor框架的类结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/592104/201802/592104-20180206145456873-717139285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的类结构中我们可以看到Executor接口是整个框架的祖接口，它大致规划了框架的结构，并定义了执行方法execute()，这个方法需要一个Runnable作为入参，表示执行一个线程任务。从这里也可以看出来这个框架的主要思想：将要执行的任务和具体的执行进行解耦，任务的内容单独定义为一个线程，任务的执行交给该框架进行，只需要将任务提交给框架即可（这个后面会提到）。Runnable入参就表示定义为单独线程的任务内容，execute方法则是执行任务，整个框架定义的就是这样一个任务执行器。&lt;/p&gt;
&lt;p&gt;二、Executor接口&lt;/p&gt;
&lt;p&gt;　　Executor接口是整个框架的总接口，正如上面所述，它描述了框架的主要实现思想：任务内容与执行的解耦。其源码很短，我们可以看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util.concurrent;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Executor {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * Executes the given command at some time in the future.  The command
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * may execute in a new thread, in a pooled thread, or in the calling
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * thread, at the discretion of the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Executor} implementation.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; command the runnable task
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; RejectedExecutionException if this task cannot be
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * accepted for execution
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if command is null
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个单独的接口，其内部只有一个execute()方法。我们看看其注释：在将来某一时刻执行给定的指令，可能会在一个新的线程、或一个线程池中的线程、或在正调用的线程中执行，这取决于Executor接口的具体实现。&lt;/p&gt;
&lt;p&gt;　　注意：这个方法中的入参任务指令是必不可少的，不可传null，否则会报NullPointerException（空指针异常）。&lt;/p&gt;
&lt;p&gt;三、ExecutorService接口&lt;/p&gt;
&lt;p&gt;　　ExecutorService接口继承了Executor接口，Executor接口仅仅描述了思想，定义了一个执行器，ExecutorService接口在其基础上进一步丰富了框架的接口，为框架定义了更多内容，包括：任务的提交，执行器的终止关闭等。&lt;/p&gt;
&lt;p&gt;3.1 终止方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List&amp;lt;Runnable&amp;gt; shutdownNow();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上源码，ExecutorService中定义了两个终止方法，这两个方法并不完全相同，第一个方法shutDown()的作用是终止新任务的接收，已接收的任务却需要继续执行。这是保证已提交任务全部执行的终止方法。第二个shutDownNow()方法属于强效终止方法，它会试图停止正在执行的线程任务，并且不再执行处于等待状态的其他任务，并且会将这些任务以列表的方式返回。&lt;/p&gt;
&lt;p&gt;　　注意：第二个方法的试图停止，并不一定会停止，因为其实现会使用Thread.interrupt()方法来进行线程任务中断执行，但是如果任务线程不会响应该中断，则不会被终止。&lt;/p&gt;
&lt;p&gt;3.2 任务提交方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt;&lt;span&gt; task);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt;&lt;span&gt; submit(Runnable task, T result);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     Future&amp;lt;?&amp;gt; submit(Runnable task);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这三个任务提交方法采用方法重载的方式定义，其实均是对execute方法的再封装，对其进行扩展而来。因为execute方法只能接受Runnable入参，切无返回值。submit提交任务却拥有返回值，而且可以接收两种格式的任务，Callable和Runnable两种。不同的方法参数和返回值也略有不同。&lt;/p&gt;
&lt;p&gt;　　第一种方法接收一个Callable入参，任务执行成功会返回一个表示该任务的Future，通过其get方法可获取到在Callable任务中指定的返回内容。&lt;/p&gt;
&lt;p&gt;　　第二种方法接收一个Runnable入参和一个指定的返回值，任务执行成功会返回一个表示该任务的Future，通过其get方法可以获取到之前的入参result的值，即入参result即为预设的返回值。&lt;/p&gt;
&lt;p&gt;　　第三种方法接收一个Runnable入参，任务执行成功会返回一个表示该任务的Future，通过get方法可得到null。&lt;/p&gt;
&lt;p&gt;　　我们通过下面的实例来进行验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         ExecutorService executor =&lt;span&gt; Executors.newCachedThreadPool();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方法：入参为Callable&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         Future&amp;lt;String&amp;gt; result1 = executor.submit(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task2&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处的task2即为返回的内容，即future.get()的值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种方法：入参为Runnable和T&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Future&amp;lt;String&amp;gt; result2 = executor.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(&quot;mmp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         },&quot;task1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处的task1即为返回的内容，即future.get()的值
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三种方法：入参为Runnable&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Future&amp;lt;?&amp;gt; result3 = executor.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 System.out.println(&quot;nnd&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        System.out.println(result1.get());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        System.out.println(result2.get());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        System.out.println(result3.get());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_93db1c10-7058-478d-b1fc-b56dc0a0d499&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93db1c10-7058-478d-b1fc-b56dc0a0d499&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93db1c10-7058-478d-b1fc-b56dc0a0d499&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task2
mmp
task1
nnd
&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从上面的结果中也可以看出三个方法的不同之处。&lt;/p&gt;
&lt;p&gt;3.3 invokeAny方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks,&lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException, TimeoutException;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一种方法表示执行给定的任务列表中的任务，如果某个任务成功完成，没有任何异常，则将该任务的结果返回，一旦成功或者异常被返回之后，任务列表中其他任务则取消执行，那么可以看出返回的必定是第一个执行成功的任务的结果或者最后一个任务的执行异常。&lt;/p&gt;
&lt;p&gt;　　第二个方法是在第一个方法的基础上加上一个超时限制，如果在超时期满之前完成了某个任务则返回该任务的结果，其余同上。&lt;/p&gt;
&lt;p&gt;　　注意：这里写到一旦成功或者异常被返回，其实这里如果第一个任务执行的时候出现了异常，则同样会被返回，同样其他任务取消执行。&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         ExecutorService executor =&lt;span&gt; Executors.newCachedThreadPool();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;Callable&amp;lt;String&amp;gt;&amp;gt; callables = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task2&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task4&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         String s =&lt;span&gt; executor.invokeAny(callables);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        System.out.println(s);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_0e9c51e9-2f69-4ebf-ac17-2247a3965991&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e9c51e9-2f69-4ebf-ac17-2247a3965991&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3.4 invokeAll方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException;
    &lt;/span&gt;&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks,&lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt; InterruptedException;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两个方法和3.3的两个方法结构类似，第一个方法表示执行给定的任务列表中的任务，当列表中的所有任务执行完毕之后，返回所有任务的结果组成的列表，此时列表中所有的Future中的isDone均为true，表示所有任务均被执行。&lt;/p&gt;
&lt;p&gt;　　第二个方法同样在第一个方法的基础上加上了时限限制，表示在所有任务完成或者时限到期之后将所有任务的结果组成列表返回，此时列表中所有的Future中的isDone均为true&lt;/p&gt;
&lt;p&gt;　　注意：如果时限期满导致返回结果的话，那些未执行的任务的结果中是null，而isDone仍然为true，状态为6-INTERRUPTED（中断），而执行成功的任务的结果状态为2-COMPLETING（完成）&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         ExecutorService executor =&lt;span&gt; Executors.newCachedThreadPool();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         List&amp;lt;Callable&amp;lt;String&amp;gt;&amp;gt; callables = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callable() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; Object call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callable() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; Object call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task2&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         callables.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callable() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; Object call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;task3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = executor.invokeAll(callables,1900L&lt;span&gt;,TimeUnit.MICROSECONDS);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(Future&amp;lt;String&amp;gt;&lt;span&gt; future:futures){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            System.out.println(future.get());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试第一个方法就将22行第二个和第三个参数去掉即可，这里设置1900毫秒在我的电脑上正好能有几率测试到完成一部分就超时的情况，其执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_fa0a994f-600b-40ce-980c-d1cc4e7d0749&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fa0a994f-600b-40ce-980c-d1cc4e7d0749&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fa0a994f-600b-40ce-980c-d1cc4e7d0749&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1
task2
    at java.util.concurrent.FutureTask.report(FutureTask.java:&lt;/span&gt;121&lt;span&gt;)
    at java.util.concurrent.FutureTask.get(FutureTask.java:&lt;/span&gt;192&lt;span&gt;)
    at xxxTest.main(xxxTest.java:&lt;/span&gt;135)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其返回结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/592104/201801/592104-20180131172831937-1853618141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;













&lt;p&gt;　　全部成功的结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_f378dedc-68a0-4aca-bb7e-82e349106339&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f378dedc-68a0-4aca-bb7e-82e349106339&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f378dedc-68a0-4aca-bb7e-82e349106339&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1
task2
task3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/592104/201801/592104-20180131173205453-484693210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;













&lt;p&gt;四、AbstractExecutorService&lt;/p&gt;
&lt;p&gt;　　这是一个抽象类，实现了ExecutorService接口。这是ExecutorService的默认实现，我们来看下AbstractExecutorService中实现的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/592104/201801/592104-20180131180556093-1238210334.png&quot; alt=&quot;&quot;/&gt;4.1 newTaskFor方法&lt;/p&gt;
&lt;p&gt;　　可以从中看出，AbstractExecutorService实现了之前我们介绍的ExecutorService中的大部分方法，包括三个任务提交方法，两个invokeAny和两个invokeAll方法，其中doInvokeAny方法是私有方法，被invokeAny调用，只是多出了两个newTaskFor方法。&lt;/p&gt;
&lt;p&gt;　　newTaskFor方法是做什么的呢？&lt;/p&gt;
&lt;p&gt;　　我们来看看源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt;&lt;span&gt; newTaskFor(Runnable runnable, T value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;T&amp;gt;&lt;span&gt;(runnable, value);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt;&lt;span&gt; callable) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;T&amp;gt;&lt;span&gt;(callable);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，这两个newTaskFor是使用给定的参数组建一个FutureTask实例并返回。所以它的作用就是提供任务执行结果Future，只是这里提供的是FutureTask类型的Future，如果我们需要使用别的RunnableFuture的实现类型（FutureTask就是RunnableFuture的实现之一），我们可以自定义。&lt;/p&gt;
&lt;p&gt;　　这两个方法被submit方法所调用，用于在任务执行之前，将其包装起来，然后调用execute执行即可，之前我们看过，execute的入参是Runnable类型，此处FutureTask的超接口RunnableFuture就实现了Runnable接口。所以可以直接将包装过的任务直接作为execute的入参进行执行。&lt;/p&gt;
&lt;p&gt;4.2 submit提交方法&lt;/p&gt;
&lt;p&gt;　　下面我们就来看看三个submit方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt;&lt;span&gt; submit(Runnable task) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        execute(ftask);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ftask;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt;&lt;span&gt; submit(Runnable task, T result) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         RunnableFuture&amp;lt;T&amp;gt; ftask =&lt;span&gt; newTaskFor(task, result);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        execute(ftask);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ftask;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt;&lt;span&gt; task) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         RunnableFuture&amp;lt;T&amp;gt; ftask =&lt;span&gt; newTaskFor(task);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        execute(ftask);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ftask;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参考之前ExecuteService中的介绍和实例，我们可以轻松理解这里代码的含义，首先判断任务是否为null，若是null，则抛出空指针，否则使用newTaskFor将任务（和返回值）封装成为FutureTask，再将其作为入参调用execute进行任务执行。最后将之前封装的FutureTask作为返回值返回。&lt;/p&gt;
&lt;p&gt;4.3 invokeAny方法&lt;/p&gt;
&lt;p&gt;　　这里实现了invokeAny，核心是doInvokeAny方法，我们可以看下源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * the main mechanics of invokeAny.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; T doInvokeAny(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; tasks,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                               &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException, TimeoutException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (tasks == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ntasks =&lt;span&gt; tasks.size();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ntasks == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;(ntasks);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         ExecutorCompletionService&amp;lt;T&amp;gt; ecs =
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For efficiency, especially in executors with limited
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; parallelism, check to see if previously submitted tasks are
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; done before submitting more of them. This interleaving
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; plus the exception mechanics account for messiness of main
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop.&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record exceptions so that if we fail to obtain any
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; result, we can throw the last exception we got.&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             ExecutionException ee = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : 0L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             Iterator&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; it =&lt;span&gt; tasks.iterator();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start one task for sure; the rest incrementally&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            futures.add(ecs.submit(it.next()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             --&lt;span&gt;ntasks;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; active = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 Future&amp;lt;T&amp;gt; f =&lt;span&gt; ecs.poll();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (ntasks &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         --&lt;span&gt;ntasks;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        futures.add(ecs.submit(it.next()));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         ++&lt;span&gt;active;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (active == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         f =&lt;span&gt; ecs.poll(nanos, TimeUnit.NANOSECONDS);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeoutException();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         nanos = deadline -&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                         f =&lt;span&gt; ecs.take();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (f != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     --&lt;span&gt;active;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; f.get();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException eex) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         ee =&lt;span&gt; eex;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException rex) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                         ee = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException(rex);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ee == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 ee = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ee;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, size = futures.size(); i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 futures.get(i).cancel(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　解析：&lt;/p&gt;
&lt;p&gt;　　　　1.参数校验，主要是看任务列表是否存在任务&lt;/p&gt;
&lt;p&gt;　　　　2.优先执行一个任务，这个任务为任务列表tasks中的首个任务（30行），然后进入一个无限循环（当然会有退出条件）。&lt;/p&gt;
&lt;p&gt;　　　　3.从执行器Executor的阻塞队列中移除队头的元素，并将该元素返回，如果队列为空队列，则这里返回值为null，此时会将优先提交的任务元素返回（35行），然后执行第53行。&lt;/p&gt;
&lt;p&gt;　　　　4.执行器执行首个任务，执行56行，等待任务执行完成，如果任务执行成功，会在此处直接退出整个方法，一旦该任务执行出错，则会产生异常，并将异常保存在ee中（58行，60行），然后继续进行循环。&lt;/p&gt;
&lt;p&gt;　　　　5.再次执行35行代码发现返回值为null，则会判断任务列表中的未执行任务数ntasks（该值初始为任务列表总任务数，但会随着任务的提交执行而逐渐递减，它的值就是任务列表中未提交执行的任务的数量）是否为0，此时该值一定不为0，则会执行38-40行代码，再次提交一个执行任务，然后会再次下一次循环，这次循环类似第4点。&lt;/p&gt;
&lt;p&gt;　　　　6.一旦某个任务执行成功，就会将该任务的执行结果返回，但是一旦某个任务执行失败，则继续执行下个任务，如果所有任务都执行失败，则会将最后一个任务的失败异常抛出（这个异常将保存在ee中，一直到循环结束，由67行抛出）。&lt;/p&gt;
&lt;p&gt;　　　　7.最后取消其他正在执行的任务（70-71行）。&lt;/p&gt;
&lt;p&gt;　　总结：该方法会返回任务列表中第一个执行成功的任务的执行结果或者是抛出异常，一旦抛出了异常，表示任务全部被执行，但是全部失败。一旦某个任务执行成功，则剩下的任务将不会再执行，而且会取消其他正在执行的任务。&lt;/p&gt;
&lt;p&gt;　　注意：对于有超时限制的情况，会执行44-49行代码，每个任务执行时都会进行超时判断，一旦超时期满，则抛出超时异常，并在最后取消所有正在执行的任务（70-71行）。&lt;/p&gt;
&lt;p&gt; 4.4 invokeAll方法&lt;/p&gt;
&lt;p&gt;　　AbstractExecutorService中的两个invokeAll是分开实现的。如前所述，该方法用于执行一个任务列表，确保所有任务全部执行，也即All之意。　　&lt;/p&gt;
&lt;p&gt;　　这里就先看到这里，更多内容下篇再写吧。&lt;/p&gt;

</description>
<pubDate>Tue, 06 Feb 2018 07:01:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V1haoge/p/8393618.html</dc:identifier>
</item>
<item>
<title>分布式事务一致性实现的方式总结 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8419430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8419430.html</guid>
<description>&lt;p&gt;　　因为最近项目正在做重构，而这次重构实质上比原来更接近于SOA化和微服务的思想。对于我们金融交易来说，数据结果的准确性是重中之重。所以今天总结一下分布式事务的实现方法，下次组内周会给大家统一一下概念。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;刚性事务和柔性事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　刚性事务：严格遵循ACID原则（原子性、一致性、隔离性、持久性）的事务。基本上指的是本地数据库事务。根据CAP原则，分布式下的事务都不是刚性事务。&lt;/p&gt;

&lt;p&gt;　　柔性事务：遵循CAP理论或者其变种BASE理论的事务。分布式事务基本上都是柔性事务。&lt;/p&gt;

&lt;p&gt;　　因为刚性事务基本上等价于本地数据库事务，而柔性事务基本上等价于分布式事务。只是一个是按照事务严格性来区分，一个是按使用场景来区分。所以平时除了用来做对比，很少直接提刚性事务和柔性事务的概念。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分布式事务理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　分布式事务：在分布式环境下，各个操作步骤并不在同一台机器上，需要保证所有动作都有一个统一的结果的一组操作。&lt;/p&gt;

&lt;p&gt;　　CAP原则（记得在之前的博客中多次写过）：分布式环境下，数据一致性、服务可用性、分区容错性三者最多只能满足其中二者。&lt;/p&gt;
&lt;p&gt;　　　　数据一致性（consistency）:这里的一致性是强一致性，又叫线性一致性。即一个写操作成功，而读出的必须是写操作后的新数据。而写操作失败读出的必须是写操作前的旧数据。&lt;/p&gt;
&lt;p&gt;　　　　服务可用性（availability）:所有的操作在一定时间内都能得到响应。&lt;/p&gt;
&lt;p&gt;　　　　分区容错性（partition-tolerance）:在网络分区环境下，被分割的节点仍然能对外提供服务。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1112728/201802/1112728-20180206125226529-124532860.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;选    择&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;说    明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;AP&lt;/td&gt;
&lt;td&gt;分隔的节点同时对外服务但不能相互通信，将导致状态不一致，即不能满足C&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;网络分区的情况下为达成C，请求只能一直等待，即不满足A&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CA&lt;/td&gt;
&lt;td&gt;在一定时间内要达到节点状态一致，要求不能出现网络分区，则不能满足P&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　BASE理论：这是基于CAP理论权衡之后的结果。核心思想是即使无法做到强一致性，但可以使用一些技术手段达到最终一致。BASE是Basically Available(基本可用)、Soft state(软状态)、Eventually consistent(最终一致性)的缩写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分布式事务一致性实现方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决分布式一致性问题，前人在性能和数据一致性的权衡过程中总结了许多经典的协议和算法。比较著名的有：2PC、3PC、TCC、Paxos、Raft、Zab、ISR。除了这些之外，业界用的最多的其实是基于MQ实现的。&lt;/p&gt;

&lt;p&gt;　　2PC（Two Phase Commit）两阶段提交:一般说的两阶段提交是基于XA协议的。另外JTA协议的也比较常见。&lt;/p&gt;
&lt;p&gt;　　XA是一个分布式事务协议。它大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2都实现了XA接口。MySQL对XA的支持不是很好。而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1112728/201802/1112728-20180206134438435-1884813985.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　两阶段提交的优点是：原理简单、实现方便。缺点是同步阻塞、单点问题、数据不一致。&lt;/p&gt;

&lt;p&gt;　　3PC(Three Phrase Commit)三阶段提交：分为CanCommit、PreCommit、Do Commit 三个阶段。就是把两阶段提交的Phase 1分成两个，预提交的时候如果有参与者返回No或者超时则中断事务。&lt;/p&gt;
&lt;p&gt;　　三阶段提交的优点是降低参与者阻塞范围，并能够在出现单点故障后继续达成一致。缺点是因为preCommit阶段，在这个阶段如果出现网络分区，协调者无法与参与者正常通信，参与者仍然会进行实物提交，造成数据不一致。&lt;/p&gt;

&lt;p&gt;　　TCC(Try-Confirm-Cancel)&lt;/p&gt;
&lt;p&gt;　　　　Try:完成所有的检查，预留必须资源&lt;/p&gt;
&lt;p&gt;　　　　Confirm:使用Try阶段预留的资源执行业务，如果执行出现异常，要重试&lt;/p&gt;
&lt;p&gt;　　　　Cancel:释放Try阶段预留资源&lt;/p&gt;
&lt;p&gt;　　　　TCC能够对分布式事务中的各个资源进行分别锁定，分别提交与释放。适用于严格一致、执行时间短、实时性要求高的场景。&lt;/p&gt;

&lt;p&gt;　　Paxos算法：之前看过《从Paxos到Zookeeper》那本书，没怎么看明白。实现比较复杂，Zookeeper就是用这个来实现的分布式一致性。Paxos算法、Raft协议和Zab（Zookeeper Atomic Broadcast）协议都是一种通过多数投票来保证主备数据一致性的。&lt;/p&gt;

&lt;p&gt;　　ISR（In-Sync Replicas）机制：Kafka使用了这个机制来保证数据一致性。ISR认为对于2f+1个副本来说，多数投票机制要求最多只能允许f个副本发生故障，如果要支持2个副本的容错，则需要至少维持5个副本。&lt;/p&gt;

&lt;p&gt;　　基本MQ实现是一种异步确保型的实现方案。将同步阻塞的事务变成异步的，避免了对数据库事务的争用。&lt;/p&gt;

&lt;p&gt;跑题时间：&lt;/p&gt;
&lt;p&gt;　　咖啡就像是有毒的爱情，入口香滑，然后就是心力交瘁、辗转难眠，远离咖啡~&lt;/p&gt;

&lt;p&gt;　　坚强是最容易的事情，当自己想哭的时候，却发现没有一个肩膀可以靠着哭，就只能将眼泪强忍回去，笑着走进来~&lt;/p&gt;

&lt;p&gt;　　我最爱的人是我的“生死劫”。一生的最爱也是一生的最坏。当我心怀执念淌过绝情池水，伤痕累累的来到断念的彼岸。我仍然感激上苍安排的一切。如果有来世，我依然会相信爱，只是再也不要爱上你~&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 06:57:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8419430.html</dc:identifier>
</item>
<item>
<title>【Spring】HttpMessageConverter的作用及替换 - weknow619</title>
<link>http://www.cnblogs.com/weknow619/p/8422382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weknow619/p/8422382.html</guid>
<description>&lt;p&gt;相信使用过Spring的开发人员都用过@RequestBody、@ResponseBody注解，可以直接将输入解析成Json、将输出解析成Json，但HTTP 请求和响应是基于文本的，意味着浏览器和服务器通过交换原始文本进行通信，而这里其实就是HttpMessageConverter发挥着作用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HttpMessageConverter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Http请求响应报文其实都是字符串，当请求报文到java程序会被封装为一个ServletInputStream流，开发人员再读取报文，响应报文则通过ServletOutputStream流，来输出响应报文。&lt;/p&gt;
&lt;p&gt;从流中只能读取到原始的字符串报文，同样输出流也是。那么在报文到达SpringMVC / SpringBoot和从SpringMVC / SpringBoot出去，都存在一个字符串到java对象的转化问题。这一过程，在SpringMVC / SpringBoot中，是通过HttpMessageConverter来解决的。HttpMessageConverter接口源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; HttpMessageConverter&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; canRead(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz, MediaType mediaType);

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; canWrite(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz, MediaType mediaType);

    List&lt;/span&gt;&amp;lt;MediaType&amp;gt;&lt;span&gt; getSupportedMediaTypes();

    T read(Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; clazz, HttpInputMessage inputMessage)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotReadableException;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; write(T t, MediaType contentType, HttpOutputMessage outputMessage)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotWritableException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面以一例子来说明，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/test&quot;&lt;span&gt;)
@ResponseBody
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test(@RequestBody String param) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;param '&quot; + param + &quot;'&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在请求进入test方法前，会根据@RequestBody注解选择对应的HttpMessageConverter实现类来将请求参数解析到param变量中，因为这里的参数是String类型的，所以这里是使用了StringHttpMessageConverter类，它的canRead()方法返回true，然后read()方法会从请求中读出请求参数，绑定到test()方法的param变量中。&lt;/p&gt;
&lt;p&gt;同理当执行test方法后，由于返回值标识了@ResponseBody，SpringMVC / SpringBoot将使用StringHttpMessageConverter的write()方法，将结果作为String值写入响应报文，当然，此时canWrite()方法返回true。&lt;/p&gt;
&lt;p&gt;借用下图简单描述整个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1044046/201802/1044046-20180206143222779-539113237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Spring的处理过程中，一次请求报文和一次响应报文，分别被抽象为一个请求消息HttpInputMessage和一个响应消息HttpOutputMessage。&lt;/p&gt;
&lt;p&gt;处理请求时，由合适的消息转换器将请求报文绑定为方法中的形参对象，在这里同一个对象就有可能出现多种不同的消息形式，如json、xml。同样响应请求也是同样道理。&lt;/p&gt;
&lt;p&gt;在Spring中，针对不同的消息形式，有不同的HttpMessageConverter实现类来处理各种消息形式，至于各种消息解析实现的不同，则在不同的HttpMessageConverter实现类中。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;替换@ResponseBody默认的HttpMessageConverter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里使用SpringBoot演示例子，在SpringMVC / SpringBoot中@RequestBody这类注解默认使用的是jackson来解析json，看下面例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {

    @RequestMapping(&lt;/span&gt;&quot;/testt&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User testt() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;name&quot;, 18&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer phone;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String username, Integer age) {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器访问/user/testt返回如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1044046/201802/1044046-20180206144700701-1612448264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是使用jackson解析的结果，现在来改成使用fastjson解析对象，这里就是替换默认的HttpMessageConverter，就是将其改成使用FastJsonHttpMessageConverter来处理Java对象与HttpInputMessage/HttpOutputMessage间的转化。&lt;/p&gt;
&lt;p&gt;首先新建一配置类来添加配置FastJsonHttpMessageConverter，Spring4.x开始推荐使用Java配置加注解的方式，也就是无xml文件，SpringBoot就更是了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.serializer.SerializerFeature;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.support.config.FastJsonConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.web.HttpMessageConverters;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.HttpMessageConverter;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpMessageConverterConfig {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入Fastjson解析json，不使用默认的jackson
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须在pom.xml引入fastjson的jar包，并且版必须大于1.2.10&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpMessageConverters fastJsonHttpMessageConverters() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、定义一个convert转换消息的对象&lt;/span&gt;
        FastJsonHttpMessageConverter fastConverter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastJsonHttpMessageConverter();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、添加fastjson的配置信息&lt;/span&gt;
        FastJsonConfig fastJsonConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastJsonConfig();

        SerializerFeature[] serializerFeatures &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SerializerFeature[]{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    输出key是包含双引号
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                SerializerFeature.QuoteFieldNames,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    是否输出为null的字段,若为null 则显示该字段
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                SerializerFeature.WriteMapNullValue,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    数值字段如果为null，则输出为0&lt;/span&gt;
&lt;span&gt;                SerializerFeature.WriteNullNumberAsZero,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     List字段如果为null,输出为[],而非null&lt;/span&gt;
&lt;span&gt;                SerializerFeature.WriteNullListAsEmpty,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    字符类型字段如果为null,输出为&quot;&quot;,而非null&lt;/span&gt;
&lt;span&gt;                SerializerFeature.WriteNullStringAsEmpty,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Boolean字段如果为null,输出为false,而非null&lt;/span&gt;
&lt;span&gt;                SerializerFeature.WriteNullBooleanAsFalse,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Date的日期转换器&lt;/span&gt;
&lt;span&gt;                SerializerFeature.WriteDateUseDateFormat,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    循环引用&lt;/span&gt;
&lt;span&gt;                SerializerFeature.DisableCircularReferenceDetect,
        };

        fastJsonConfig.setSerializerFeatures(serializerFeatures);
        fastJsonConfig.setCharset(Charset.forName(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、在convert中添加配置信息&lt;/span&gt;
&lt;span&gt;        fastConverter.setFastJsonConfig(fastJsonConfig);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、将convert添加到converters中&lt;/span&gt;
        HttpMessageConverter&amp;lt;?&amp;gt; converter =&lt;span&gt; fastConverter;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpMessageConverters(converter);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将字符串类型的值如果是null就返回“”，数值类型的如果是null就返回0，重启应用，再次访问/user/testt接口，返回如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1044046/201802/1044046-20180206145346904-1165310730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到此时null都转化成“”或0了。&lt;/p&gt;

</description>
<pubDate>Tue, 06 Feb 2018 06:55:00 +0000</pubDate>
<dc:creator>weknow619</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weknow619/p/8422382.html</dc:identifier>
</item>
<item>
<title>浅析调用JSR303的validate方法, 验证失败时抛出ConstraintViolationException - 陈扬天</title>
<link>http://www.cnblogs.com/fengwenzhee/p/8422362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengwenzhee/p/8422362.html</guid>
<description>&lt;p&gt;废话不多说，直接进入正题：如何使用JSR303的validate，进行数据校验，失败后直接抛出异常加入流转信息中，并在form页面提示出来。&lt;/p&gt;
&lt;p&gt;首先我们为了启用验证，需要向&lt;/p&gt;
&lt;p&gt;项目中添加Bean验证的实现。本列选择Hibernate Validator框架来提供验证功能。可以像下面的示例那样将该项目作为一个Maven依赖添加到当前项目中。此外，Hibernate Validator会将Bean Validation API作为一个船只依赖添加到项目中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;5.1.1.Final&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在表单页面引入如下标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用该标签下的form:form进行数据验证的绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;form:form id=&quot;inputForm&quot; modelAttribute=&quot;article&quot; action=&quot;${ctx}/cms/article/save&quot; method=&quot;post&quot; class=&quot;form-horizontal&quot;&amp;gt;
                
                &amp;lt;div class=&quot;control-group&quot;&amp;gt;
                        &amp;lt;label class=&quot;control-label&quot;&amp;gt;摘要:&amp;lt;/label&amp;gt;
                        &amp;lt;div class=&quot;controls&quot;&amp;gt;
                                &amp;lt;form:textarea path=&quot;description&quot; htmlEscape=&quot;false&quot; rows=&quot;4&quot; maxlength=&quot;200&quot; class=&quot;input-xxlarge&quot;/&amp;gt;
                        &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;form-actions&quot;&amp;gt;
                        &amp;lt;shiro:hasPermission name=&quot;cms:article:edit&quot;&amp;gt;&amp;lt;input id=&quot;btnSubmit&quot; class=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;保 存&quot;/&amp;gt; &amp;lt;/shiro:hasPermission&amp;gt;
                        &amp;lt;input id=&quot;btnCancel&quot; class=&quot;btn&quot; type=&quot;button&quot; value=&quot;返 回&quot; onclick=&quot;history.go(-1)&quot;/&amp;gt;
                &amp;lt;/div&amp;gt;
        &amp;lt;/form:form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上我只是简单举了一个字段为description（简介/描述）的数据验证例子 其实这里的maxlength=&quot;200&quot;，我们完全可以忽略它，因为前段的验证始终是不安全的，而且我们在后台进行的验证因为整合了jsr303变的异常的简洁，我们只需要在需要验证的&lt;/p&gt;
&lt;p&gt;表单实体的get方法上加上一行注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@Length(min=0, max=5)
        public String getDescription() {
                return description;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　//这行注解的意思是最小长度是0，最大长度是5&lt;/p&gt;
&lt;p&gt;然后在控制层写上验证失败加入流转信息并返回form页的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 @RequestMapping(value = &quot;save&quot;)
        public String save(Article article, Model model, RedirectAttributes redirectAttributes) {
                if (!beanValidator(model, article)){
                        return form(article, model);
                }
                articleService.save(article);
                addMessage(redirectAttributes, &quot;保存文章'&quot; + StringUtils.abbr(article.getTitle(),50) + &quot;'成功&quot;);
                String categoryId = article.getCategory()!=null?article.getCategory().getId():null;
                return &quot;redirect:&quot; + adminPath + &quot;/cms/article/?repage&amp;amp;category.id=&quot;+(categoryId!=null?categoryId:&quot;&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们进入beanValidator(model,article)这个方法一探究竟：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
         * 服务端参数有效性验证
         * @param object 验证的实体对象
         * @param groups 验证组
         * @return 验证成功：返回true；严重失败：将错误信息添加到 message 中
         */
        protected boolean beanValidator(Model model, Object object, Class&amp;lt;?&amp;gt;... groups) {
                try{
                        BeanValidators.validateWithException(validator, object, groups);
                }catch(ConstraintViolationException ex){
                        List&amp;lt;String&amp;gt; list = BeanValidators.extractPropertyAndMessageAsList(ex, &quot;: &quot;);
                        list.add(0, &quot;数据验证失败：&quot;);
                        addMessage(model, list.toArray(new String[]{}));
                        return false;
                }
                return true;
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
 * JSR303 Validator(Hibernate Validator)工具类.
 * 
 * ConstraintViolation中包含propertyPath, message 和invalidValue等信息.
 * 提供了各种convert方法，适合不同的i18n需求:
 * 1. List&amp;lt;String&amp;gt;, String内容为message
 * 2. List&amp;lt;String&amp;gt;, String内容为propertyPath + separator + message
 * 3. Map&amp;lt;propertyPath, message&amp;gt;
 * 
 * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator
 * @author calvin
 * @version 2013-01-15
 */
public class BeanValidators {

        /**
         * 调用JSR303的validate方法, 验证失败时抛出ConstraintViolationException.
         */
        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
        public static void validateWithException(Validator validator, Object object, Class&amp;lt;?&amp;gt;... groups)
                        throws ConstraintViolationException {
                Set constraintViolations = validator.validate(object, groups);
                if (!constraintViolations.isEmpty()) {
                        throw new ConstraintViolationException(constraintViolations);
                }
        }

/**
         * 辅助方法, 转换ConstraintViolationException中的Set&amp;lt;ConstraintViolations&amp;gt;为List&amp;lt;propertyPath +separator+ message&amp;gt;.
         */
        public static List&amp;lt;String&amp;gt; extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {
                return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);
        }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
         * 添加Model消息
         * @param message
         */
        protected void addMessage(Model model, String... messages) {
                StringBuilder sb = new StringBuilder();
                for (String message : messages){
                        sb.append(message).append(messages.length&amp;gt;1?&quot;&amp;lt;br/&amp;gt;&quot;:&quot;&quot;);
                }
                model.addAttribute(&quot;message&quot;, sb.toString());
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后我们要做的就是在form页面把model中的错误信息展示出来就行了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;top.$.jBox.closeTip();&amp;lt;/script&amp;gt;
&amp;lt;c:if test=&quot;${not empty content}&quot;&amp;gt;
        &amp;lt;c:if test=&quot;${not empty type}&quot;&amp;gt;&amp;lt;c:set var=&quot;ctype&quot; value=&quot;${type}&quot;/&amp;gt;&amp;lt;/c:if&amp;gt;&amp;lt;c:if test=&quot;${empty type}&quot;&amp;gt;&amp;lt;c:set var=&quot;ctype&quot; value=&quot;${fn:indexOf(content,'失败') eq -1?'success':'error'}&quot;/&amp;gt;&amp;lt;/c:if&amp;gt;
        &amp;lt;div id=&quot;messageBox&quot; class=&quot;alert alert-${ctype} hide&quot;&amp;gt;&amp;lt;button data-dismiss=&quot;alert&quot; class=&quot;close&quot;&amp;gt;×&amp;lt;/button&amp;gt;${content}&amp;lt;/div&amp;gt; 
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;if(!top.$.jBox.tip.mess){top.$.jBox.tip.mess=1;top.$.jBox.tip(&quot;${content}&quot;,&quot;${ctype}&quot;,{persistent:true,opacity:0});$(&quot;#messageBox&quot;).show();}&amp;lt;/script&amp;gt;
&amp;lt;/c:if&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　例子展示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1167306/201802/1167306-20180206143949810-296678600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这种验证方法是每次都会向服务器发送一次请求，如果一些简单的验证不需要向后台区请求，我们可以使用自定义的validate在前端完成简单的数据验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$(&quot;#inputForm&quot;).validate({
                                submitHandler: function(form){
                    if ($(&quot;#categoryId&quot;).val()==&quot;&quot;){
                        $(&quot;#categoryName&quot;).focus();
                        top.$.jBox.tip('请选择归属栏目','warning');
                    }else if (CKEDITOR.instances.content.getData()==&quot;&quot; &amp;amp;&amp;amp; $(&quot;#link&quot;).val().trim()==&quot;&quot;){
                        top.$.jBox.tip('请填写正文','warning');
                    }else{
                        loading('正在提交，请稍等...');
                        form.submit();
                    }
                                },
                                errorContainer: &quot;#messageBox&quot;,
                                errorPlacement: function(error, element) {
                                        $(&quot;#messageBox&quot;).text(&quot;输入有误，请先更正。&quot;);
                                        if (element.is(&quot;:checkbox&quot;)||element.is(&quot;:radio&quot;)||element.parent().is(&quot;.input-append&quot;)){
                                                error.appendTo(element.parent().parent());
                                        } else {
                                                error.insertAfter(element);
                                        }
                                }
                        });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1167306/201802/1167306-20180206145104857-357564007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 06:51:00 +0000</pubDate>
<dc:creator>陈扬天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengwenzhee/p/8422362.html</dc:identifier>
</item>
<item>
<title>Android Training Note - 梦和远方</title>
<link>http://www.cnblogs.com/liuyu0529/p/8422073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyu0529/p/8422073.html</guid>
<description>&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;google为了让广大Android开发者能够高效地创建优质的app，专门针对开发者提供了Training板块，这个板块的学习资料是最一手的，来自google android工程师之手的。这个资料是每一个Android开发者都应该学习的手册，并且它是不断更新的。链接： &lt;br/&gt;&lt;a href=&quot;https://developer.android.com/training/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://developer.android.com/training/index.html&lt;/span&gt;&lt;/a&gt; &lt;br/&gt;中文版：&lt;br/&gt;&lt;a href=&quot;http://hukai.me/android-training-course-in-chinese/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://hukai.me/android-training-course-in-chinese/index.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;&lt;span&gt;版本适配&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Tip:为了能在几个Android版本中都能提供最好的特性和功能，你应该在你的app中使用Android &lt;span class=&quot;Apple-tab-span&quot;&gt;Support &lt;span class=&quot;Apple-tab-span&quot;&gt;Library，它能&lt;/span&gt;&lt;/span&gt;使你的app能在旧平台上使用最近的几个平台的APIs。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;适配不同的系统版本俩种方法：&lt;/p&gt;
&lt;div&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;指定最小和目标API级别，具体来说，&amp;lt;uses-sdk&amp;gt; &lt;span class=&quot;Apple-tab-span&quot;&gt;元素中的 &lt;span class=&quot;Apple-tab-span&quot;&gt;minSdkVersion和 &lt;span class=&quot;Apple-tab-span&quot;&gt;targetSdkVersion属性，标明在设计和测试app时，最低兼容API的级别和最高适用的API级别(这个最高的级别是需要通过你的测试的)。随着新版本Android的发布，一些风格和行为可能会改变，为了能使你的app能利用这些变化，而且能适配不同风格的用户的设备，你应该设置 &lt;span class=&quot;Apple-tab-span&quot;&gt;targetSdkVersion &lt;span class=&quot;Apple-tab-span&quot;&gt;的值去匹配最新的可用Android版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在运行时检查系统版本。&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        @SuppressLint(&quot;NewApi&quot;)
        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
                getMenuInflater().inflate(R.menu.activity_main, menu);
                // 如果运行的环境 (部署到什么版本的手机 )大于3.0
                if (android.os.Build.VERSION.SDK_INT &amp;gt; 11) {
                        SearchView searchView = (SearchView) menu.findItem(
                                        R.id.action_search).getActionView();
                        searchView.setOnQueryTextListener(this);// 搜索的监听
                } 
                return true;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;Note:当解析XML资源时，Android会忽略当前设备不支持的XML属性。所以你可以安全地使用较新版本的XML属性&lt;/p&gt;
&lt;p&gt;而不需要担心旧版本Android遇到这些代码时会崩溃。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;国际化&lt;/p&gt;
&lt;p&gt;为了支持多国语言，在 &lt;span class=&quot;Apple-tab-span&quot;&gt;res/ &lt;span class=&quot;Apple-tab-span&quot;&gt;中创建一个额外的 &lt;span class=&quot;Apple-tab-span&quot;&gt;values &lt;span class=&quot;Apple-tab-span&quot;&gt;目录以连字符和ISO国家代码结尾命名，比如 &lt;span class=&quot;Apple-tab-span&quot;&gt;values-es/是为语言代码为&quot;es&quot;的区域设置的简单的资源文件的目录。Android会在运行时根据设备的区域设置，加载相应的资源。详见Providing&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;app/build.gradle&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Android &lt;span class=&quot;Apple-tab-span&quot;&gt;Studio使用Gradle &lt;span class=&quot;Apple-tab-span&quot;&gt;编译运行Android工程. &lt;span class=&quot;Apple-tab-span&quot;&gt;工程的每个模块以及整个工程都有一个build.gradle文件。通常你只需要关&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注模块的build.gradle文件，该文件存放编译依赖设置，包括defaultConfig设置：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;compiledSdkVersion &lt;span class=&quot;Apple-tab-span&quot;&gt;是&lt;span&gt;你的应用将要编译的目标Android版本&lt;/span&gt;，此处默认为你的SDK已安装的最新Android版本(目前应该是4.1或更高版本，如果你没有安装一个可用Android版本，就要先用SDKManager来完成安装)，你仍然可以使用较老的版本编译项目，但把该值设为最新版本，使你可以使用Android的最新特性，同时可以在最新的设备上优化应用来提高用户体验。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;targetSdkVersion &lt;span class=&quot;Apple-tab-span&quot;&gt;表示你&lt;span&gt;测试过你的应用支持的最高Android版本&lt;/span&gt;(同样用API &lt;span class=&quot;Apple-tab-span&quot;&gt;level)表示).当Android发布最新版本后，你应该在最新版本的Android测试你的应用同时更新target &lt;span class=&quot;Apple-tab-span&quot;&gt;sdk到Android最新版本，以便充分利用Android新版本的特性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;布局&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;可选的布局文件：在&lt;span&gt;XML中定义界面布局而不是在运行时去动态生成布局是有多个原因的&lt;/span&gt;，其中最重要的一个原因是这样可以使得你为不同大小的屏幕创建不同的布局文件。例如，你可以创建创建2个版本的布局文件，告诉系统在小的屏幕上使用其中一个布局文件，在大的屏幕上使用另外一个布局文件。&lt;/li&gt;
&lt;li&gt;于字符串 &lt;span class=&quot;Apple-tab-span&quot;&gt;@string/edit_message，该字符串资源与id使用了相同的名称（edit_message）。然而，对于资源的引用是区分类型的（比如id和字符串），因此，使用相同的名称不会引起冲突&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当你在用户界面定义一个文本的时候，&lt;span&gt;你应该把每一个文本字符串列入资源文件&lt;/span&gt;。对于所有字符串值，字符串资源能够单独的修改，在资源文件里你可以很容易的找到并且做出相应的修改。通过选择定义每个字符串，还允许您对不同语言本地化应用程序。&lt;/li&gt;
&lt;li&gt;android:layout_weight，“两份伏特加酒，一份咖啡利口酒”，意思就是这个酒中伏特加酒占三分之二。(请注意，使用权重的前提一般是给View的宽或者高的大小设置为0dp，然后系统根据上面的权重规则来计算View应该占据的空间。但是很多情况下，如果给View设置了match_parent的属性，那么上面计算权重时则不是通常的正比，而是反比，也就是权重值大的反而占据空间小）&lt;/li&gt;
&lt;/ul&gt;
使用字符资源：&lt;/div&gt;
&lt;div&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;代码中：String &lt;span class=&quot;Apple-tab-span&quot;&gt;hello &lt;span class=&quot;Apple-tab-span&quot;&gt;= &lt;span class=&quot;Apple-tab-span&quot;&gt;getResources().getString(R.string.hello_world);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;布局中：android:text=&quot;@string/hello_world&quot; &lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;屏幕适配&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)&lt;/p&gt;
&lt;p&gt;4种普遍分辨率：低精度(ldpi), &lt;span class=&quot;Apple-tab-span&quot;&gt;中精度(mdpi), &lt;span class=&quot;Apple-tab-span&quot;&gt;高精度(hdpi), &lt;span class=&quot;Apple-tab-span&quot;&gt;超高精度(xhdpi)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;res/layout-large/ &lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;xhdpi: &lt;span class=&quot;Apple-tab-span&quot;&gt;2.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hdpi: &lt;span class=&quot;Apple-tab-span&quot;&gt;1.5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mdpi: &lt;span class=&quot;Apple-tab-span&quot;&gt;1.0 &lt;span class=&quot;Apple-tab-span&quot;&gt;(基准)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ldpi: &lt;span class=&quot;Apple-tab-span&quot;&gt;0.75&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note:低密度(ldpi)资源是非必要的，当你提供了hdpi的图像，系统会把hdpi的图像按比例缩小一半，去适配ldpi的屏幕。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;Activity&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为让新启动的activity能查询，&lt;span&gt;定义key为一个public型的常量，通常使用应用程序包名作为前缀来定义意图键是很好的做法&lt;/span&gt;。在应用程序与其他应用程序进行交互时仍可以确保意图键唯一。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1517897008795_2810&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;Java&quot; data-theme=&quot;default&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public final static String EXTRA_MESSAGE =&quot;com.mycompany.myfirstapp.MESSAGE&quot;;
    Intent intent = new Intent(this, DisplayMessageActivity.class);
    EditText editText = (EditText) findViewById(R.id.edit_message);
    String message = editText.getText().toString();
    intent.putExtra(EXTRA_MESSAGE,message);

    TextView textView = new TextView(this);
    textView.setTextSize(40);
    textView.setText(message);
    //  Set     the     text    view    as      the     activity        layout
    setContentView(textView);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;使你的activity有一个透明背景:&amp;lt;activity &lt;span class=&quot;Apple-tab-span&quot;&gt;android:theme=&quot;@android:style/Theme.Translucent&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不像其他编程范式一样：程序从 &lt;span class=&quot;Apple-tab-span&quot;&gt;main() &lt;span class=&quot;Apple-tab-span&quot;&gt;方法开始启动。Android系统根据生命周期的不同阶段唤起对应的回调函数来执行代码。系统存在启动与销毁一个activity的一套有序的回调函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;如何实现一个符合用户期待的app，你需要注意下面几点：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;当使用你的app的时候，不会因为有来电通话或者切换到其他app而导致程序crash。&lt;/li&gt;
&lt;li&gt;当用户没有激活某个组件的时候不要消耗宝贵的系统资源。&lt;/li&gt;
&lt;li&gt;当离开你的app并且一段时间后返回，不要丢失用户的使用进度。&lt;/li&gt;
&lt;li&gt;当设备发送屏幕旋转的时候，不会crash或者丢失用户的使用进度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;activity生命周期&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;onCreate里面尽量少做事情，避免程序启动太久都看不到界面&lt;/li&gt;
&lt;li&gt;通常，你不应该使用onPause()来保存用户改变的数据 &lt;span class=&quot;Apple-tab-span&quot;&gt;(例如填入表格中的个人信息) &lt;span class=&quot;Apple-tab-span&quot;&gt;到永久存储(File或者DB你确认用户期待那些改变能够被自动保存的时候(例如正在撰写邮件草稿)，你可以把那些数据存到永久存储 &lt;span class=&quot;Apple-tab-span&quot;&gt;。应该避免在onPause()时执行CPU-intensive &lt;span class=&quot;Apple-tab-span&quot;&gt;的工作，例如写数据到DB，因为它会导致切换到下一个activity变应该把那些heavy-load的工作放到onStop()去做)。如果你的activity实际上是要被Stop，那么你应该为了切换的顺畅而减少在OnPause()方法里面的工作量。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;请注意，系统每次调用这个方法（onResume）时，activity都处于最前台，包括第一次创建的时候。所以，你应该实现onResume()来初始化那些你在onPause方法里面释放掉的组件，并执行那些activity每次进入Resumed &lt;span class=&quot;Apple-tab-span&quot;&gt;state都需要的初始化动作 &lt;span class=&quot;Apple-tab-span&quot;&gt;(例如开始动画与初始化那些只有在获取用户焦点时才需要的组件)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;因为系统在activity停止时会在内存中保存了Activity实例。&lt;span&gt;有些时候你不需要实现onStop(),onRestart()甚至是onStart()方法.因为大多数的activity相对比较简单，activity会自己停止与重启，你只需要使用onPause()来停止正在运行的动作并断开系统资源链接。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重新创建Activity&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;通常来说，跳转到其他的activity或者是点击Home都会导致当前的activity执行onSaveInstanceState，因为这种情况下的activity都是有可能会被destory并且是需要保存状态以便后续恢复使用的，而从跳转的activity点击back回到前一个activity，那么跳转前的activity是执行退栈的操作，所以这种情况下是不会执行onSaveInstanceState的，因为这个activity不可能存在需要重建的操作。&lt;/li&gt;
&lt;li&gt;当系统开始停止你的Activity时，只有在Activity实例会需要重新创建的情况下才会调用到onSaveInstanceState()(1) &lt;span class=&quot;Apple-tab-span&quot;&gt;，在这个方法里面可以指定额外的状态数据到Bunde中。如果这个Activity被destroyed然后这个实例又需要被重新创建时，系统会传递在 &lt;span class=&quot;Apple-tab-span&quot;&gt;(1) &lt;span class=&quot;Apple-tab-span&quot;&gt;中的状态数据到 &lt;span class=&quot;Apple-tab-span&quot;&gt;onCreate()与 &lt;span class=&quot;Apple-tab-span&quot;&gt;onRestoreInstanceState().&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;onRestoreInstanceState()方法会在 &lt;span class=&quot;Apple-tab-span&quot;&gt;onStart() &lt;span class=&quot;Apple-tab-span&quot;&gt;方法之后执行. &lt;span class=&quot;Apple-tab-span&quot;&gt;系统仅仅会在存在需要恢复的状态信息时才会调用 &lt;span class=&quot;Apple-tab-span&quot;&gt;onRestoreInstanceState() &lt;span class=&quot;Apple-tab-span&quot;&gt;，因此你不需要检查 &lt;span class=&quot;Apple-tab-span&quot;&gt;Bundle &lt;span class=&quot;Apple-tab-span&quot;&gt;是否为null。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public   void    onSaveInstanceState(Bundle      savedInstanceState)     {
//      Save    the     user's  current game    state
        savedInstanceState.putInt(STATE_SCORE,  mCurrentScore);
        savedInstanceState.putInt(STATE_LEVEL,  mCurrentLevel);
        super.onSaveInstanceState(savedInstanceState);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        //      Always  call    the     superclass      so      it      can     restore the     view    hierarchy
        super.onRestoreInstanceState(savedInstanceState);
        //      Restore state   members from    saved   instance
        mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
        mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;p&gt;&lt;span&gt;建立隐式的Intent&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;尽管Android系统会确保每一个确定的intent会被系统内置的app(such as the Phone, Email, or Calendar app)之一接收，但是你还是应该在触发一个intent之前做验证是否有App接受这个intent的步骤。&lt;/p&gt;
&lt;p&gt;Caution: 如果你触发了一个intent，而且没有任何一个app会去接收这个intent，那么你的app会crash。&lt;/p&gt;
&lt;p&gt;为了验证是否有合适的activity会响应这个intent，需要执行queryIntentActivities() 来获取到能够接收这个intent的所有activity的list。如果返回的List非空，那么你才可以安全的使用这个intent。例如：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
PackageManager packageManager = getPackageManager();
List&amp;lt;ResolveInfo&amp;gt; activities = packageManager.queryIntentActivities(intent, 0);
boolean isIntentSafe = activities.size() &amp;gt; 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果 isIntentSafe 是 true , 那么至少有一个app可以响应这个intent。如果是 false 则说明没有app可以handle这个intent。Note:&lt;span&gt;你必须在第一次使用之前做这个检查&lt;/span&gt;，若是不可行，则应该关闭这个功能。如果你知道某个确切的app能够handle这个intent，你也应该提供给用户去下载这个app的链接。?&lt;/p&gt;
&lt;p&gt;一个完整的例子，演示了如何创建一个intent来查看地图，验证有app可以handle这个intent,然后启动它。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// Build the intent
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
// Verify it resolves
PackageManager packageManager = getPackageManager();
List&amp;lt;ResolveInfo&amp;gt; activities = packageManager.queryIntentActivities(mapIntent, 0);
boolean isIntentSafe = activities.size() &amp;gt; 0;
// Start an activity if it's safe
if (isIntentSafe) {
    startActivity(mapIntent);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;如果用户希望每次都弹出选择界面，而且每次都不确定会选择哪个app启动，例如分享功能，用户选择分享到哪个app都是不确定的，这个时候，需要强制弹出选择的对话框。（这种情况下用户不能选择默认启动的app）。为了显示chooser, 需要使用createChooser()来创建Intent&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Intent intent = new Intent(Intent.ACTION_SEND);
...
// Always use string resources for UI text. This says something like &quot;Share this photo with&quot;
String title = getResources().getText(R.string.chooser_title);
// Create and start the chooser
Intent chooser = Intent.createChooser(intent, title);
startActivity(chooser);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/827512/201802/827512-20180206141024123-1090042763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就列出了可以响应 createChooser() 中Intent的app，并且指定了标题。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;

&lt;p&gt;&lt;span&gt;被别的应用启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你的app的功能对别的app也有用，那么你的app应该做好响应的准备。例如，如果你创建了一个social app，它可以分享messages 或者 photos 给好友，那么最好你的app能够接收 ACTION_SEND  的intent,这样当用户在其他app触发分享功能的时候，你的app能够出现在待选对话框。&lt;/p&gt;
&lt;p&gt;为了使得其他的app能够启动你的activity，你需要在你的manifest文件的 &amp;lt;activity&amp;gt; 标签下添加 &amp;lt;intent-filter&amp;gt; 的属性。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例如，这个有intent filter的activity，当数据类型为文本或图像时会处理 ACTION_SEND 的intent。&lt;/p&gt;
&lt;div id=&quot;wiz_cm_1517897008794_312&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;Java&quot; data-theme=&quot;default&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;activity android:name=&quot;ShareActivity&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;android.intent.action.SEND&quot;/&amp;gt;
        &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&amp;gt;
        &amp;lt;data android:mimeType=&quot;text/plain&quot;/&amp;gt;
        &amp;lt;data android:mimeType=&quot;image/*&quot;/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    // Get the intent that started this activity
    Intent intent = getIntent();
    Uri data = intent.getData();
    // Figure out what to do based on the intent type
    if (intent.getType().indexOf(&quot;image/&quot;) != -1) {
        // Handle intents with image data ...
    } else if (intent.getType().equals(&quot;text/plain&quot;)) {
        // Handle intents with text ...
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;详情看：Intent过滤（92P）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;Fragment&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;你可以把fragment想象成activity中一个模块化的部分，它拥有自己的生命周期，接收自己的输入事件，可以在acvitity运行过程中添加或者移除（有点像&quot;子activity&quot;，你可以在不同的activities里面重复使用）可以使用包含action &lt;span class=&quot;Apple-tab-span&quot;&gt;bar的 &lt;span class=&quot;Apple-tab-span&quot;&gt;v7 &lt;span class=&quot;Apple-tab-span&quot;&gt;appcompat library。v7 &lt;span class=&quot;Apple-tab-span&quot;&gt;appcompat &lt;span class=&quot;Apple-tab-span&quot;&gt;library &lt;span class=&quot;Apple-tab-span&quot;&gt;兼容Android2.1(API &lt;span class=&quot;Apple-tab-span&quot;&gt;level &lt;span class=&quot;Apple-tab-span&quot;&gt;7)，也包含了Fragment &lt;span class=&quot;Apple-tab-span&quot;&gt;APIs。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;和activity其中一个区别是当你创建Fragment的时候，你必须重写onCreateView()回调方法来定义你的布局。事实上，这是使Fragment运行起来，唯一一个需要你重写的回调方法&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                 &amp;lt;fragment    android:name=&quot;com.example.android.fragments.ArticleFragment&quot;
                                        android:id=&quot;@+id/article_fragment&quot;
                                        android:layout_weight=&quot;2&quot;
                                        android:layout_width=&quot;0dp&quot;
                                        android:layout_height=&quot;match_parent&quot;    /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;当你用XML布局文件的方式将Fragment添加进activity时，你的Fragment是不能被动态移除的&lt;/li&gt;
&lt;li&gt;运用fragment（特别是那些你在运行时添加的）的一个很重要的规则就是在布局中你必须有一个容器view，fragment的layout将会放在这个view里面。&lt;/li&gt;
&lt;li&gt;用addToBackStack()，当你移除或者替换一个fragment并把它放入返回栈中时，被移除的fragment的生命周期是stopped(不是destoryed).当用户返回重新恢复这个fragment,它的生命周期是restarts。如果你没把fragment放入返回栈中，那么当他被移除或者替换时，它的生命周期是destoryed。&lt;/li&gt;
&lt;li&gt;addToBackStack()方法提供了一个可选的String参数为事务指定了一个唯一的名字。这个名字不是必须的，除非你打算用FragmentManager.BackStackEntry &lt;span class=&quot;Apple-tab-span&quot;&gt;APIs来进行一些高级的fragments操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;经常地，你想fragment之间能相互交互，比如基于用户事件改变fragment的内容。所有fragment之间的交互需要通过他们关联的activity，两个fragment之间不应该直接交互。&lt;/li&gt;
&lt;/ul&gt;
Fragments之间的交互&lt;/div&gt;
&lt;p&gt;&lt;span&gt;定义一个接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了让fragment与activity交互，你可以在Fragment &lt;span class=&quot;Apple-tab-span&quot;&gt;类中定义一个接口，并且在activity中实现这个接口。Fragment在他们生命周期的onAttach()方法中捕获接口的实现，然后调用接口的方法来与Activity交互。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class HeadlinesFragment extends ListFragment {
        OnHeadlineSelectedListener mCallback;

        //      Container       Activity        must    implement       this    interface
        public interface OnHeadlineSelectedListener {
            public void onArticleSelected(int position);
        }

        @Override
        public void onAttach(Activity activity) {
            super.onAttach(activity);
            try {
                mCallback = (OnHeadlineSelectedListener) activity;
            } catch (ClassCastException e) {
                throw new ClassCastException(activity.toString()
                        + &quot;     must    implement       OnHeadlineSelectedListener&quot;);
            }
        }
                ...
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现在Fragment就可以通过调用 &lt;span class=&quot;Apple-tab-span&quot;&gt;OnHeadlineSelectedListener &lt;span class=&quot;Apple-tab-span&quot;&gt;接口实例的   mCallback &lt;span class=&quot;Apple-tab-span&quot;&gt;中的 &lt;span class=&quot;Apple-tab-span&quot;&gt;onArticleSelected() &lt;span class=&quot;Apple-tab-span&quot;&gt;（也可以是其它方法）方法与activity传递消息。举个例子，在fragment中的下面的方法在用户点击列表条目时被调用，fragment &lt;span class=&quot;Apple-tab-span&quot;&gt;用回调接口来传递事件给父Activity.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        mCallback.onArticleSelected(position);
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;实现接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了接收回调事件，宿主activity必须实现在Fragment中定义的接口。举个例子，下面的activity实现了上面例子中的接口。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public static class MainActivity extends Activity
            implements HeadlinesFragment.OnHeadlineSelectedListener {
                ...

        public void onArticleSelected(int position) {
            //  The     user    selected        the     headline        of      an      article from    the     HeadlinesFragment
            //  Do      something       here    to      display that    article
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;数据存储&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;写Shared Preference：通过类似putInt()与putString()方法来传递keys与values。然后执行commit() 来提交改变. (&lt;span&gt;后来有建议除非是出于线程同&lt;/span&gt;&lt;span&gt;步的需要，否则请使用apply()方法来替代commit()，因为后者有可能会卡到UI Thread&lt;/span&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;存储在内部还是外部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有的Android设备都有两个文件存储区域：&quot;internal&quot; 与 &quot;external&quot; 存储。 那两个名称来自于早先的Android系统中，当时的大多设备都内置了不可变的内存（internal storage)，然后再加上一个类似SD card（external storage）这样可以卸载的存储部件。后来有一些设备把&quot;internal&quot; 与&quot;external&quot; 的部分都做成不可卸载的内置存储了，虽然如此，但是这一整块还是从逻辑上有被划分为&quot;internal&quot;与&quot;external&quot;的。只是现在不再以是否可以卸载来区分了。 下面列出了两者的区别：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;Internal storage:&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;总是可用的&lt;/li&gt;
&lt;li&gt;这里的文件默认是只能被你的app所访问的。&lt;/li&gt;
&lt;li&gt;当用户卸载你的app的时候，系统会把internal里面的相关文件都清除干净。&lt;/li&gt;
&lt;li&gt;Internal是在你想确保不被用户与其他app所访问的最佳存储区域。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;External storage:&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;ul&gt;&lt;li&gt;并不总是可用的，因为用户有时会通过USB存储模式挂载外部存储器，当取下挂载的这部分后，就无法对其进行访问了。&lt;/li&gt;
&lt;li&gt;是大家都可以访问的，因此你可能会失去保存在这里的文件的访问控制权。&lt;/li&gt;
&lt;li&gt;当用户卸载你的app时，系统仅仅会删除external根目录（getExternalFilesDir()）下的相关文件。&lt;/li&gt;
&lt;li&gt;External是在你不需要严格的访问权限并且你希望这些文件能够被其他app所共享或者是允许用户通过电脑访问时的最佳存储区域。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Tip: 尽管app是默认被安装到internal storage的，你还是可以通过在程序的manifest文件中声明android:installLocation 属性来指定程序也可以被安装到external storage。当某个程序的安装文件很大且用户的internal storage空间大于external storage时，他们会倾向与将该程序安装到external storage。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;你可以执行openFileOutput() 来获取一个 FileOutputStream 用于写文件到internal目录&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    String filename = &quot;myfile&quot;;
    String string = &quot;Hello world!&quot;;
    FileOutputStream outputStream;
    try{
        outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
        outputStream.write(string.getBytes());
        outputStream.close();
    } catch(Exception e){
        e.printStackTrace();
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果，你需要缓存一些文件，你可以使用createTempFile()。例如：下面的方法从URL中抽取了一个文件名，然后再在程序的internal缓存目录下创建了一个以这个文件名命名的文件。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public File getTempFile(Context context, String url) {
    File file;
    try {
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) {
        // Error while creating file
    }
    return file;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;p&gt;你使用MODE_PRIVATE ，那么这些文件就不可能被其他app所访问&lt;/p&gt;

&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;尽管external storage对于用户与其他app是可修改的，那么你可能会保存下面两种类型的文件。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;ul&gt;&lt;li&gt;Public files :这些文件对与用户与其他app来说是public的，当用户卸载你的app时，这些文件应该保留。例如，那些被你的app拍摄的图片或者下载的文件。&lt;/li&gt;
&lt;li&gt;Private files: 这些文件应该是被你的app所拥有的，它们应该在你的app被卸载时删除掉。尽管由于存储在external  storage，那些文件从技术上而言可以被用户与其他app所访问，但实际上那些文件对于其他app是没有意义的。因此，当用户卸载你的app时，系统会删除你的app的private目录。例如，那些被你的app下载的缓存文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你想要保存文件为public形式的，请使用getExternalStoragePublicDirectory()方法来获取一个 File 对象来表示存储在external storage的目录。这个方法会需要你带有一个特定的参数来指定这些public的文件类型，以便于与其他public文件进行分类。参数类型包括DIRECTORY_MUSIC 或者 DIRECTORY_PICTURES. 如下:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public File getAlbumStorageDir(String albumName) {
    // Get the directory for the user's public pictures directory.
    File file = new File(Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, &quot;Directory not created&quot;);
    }
    return file;
}
&lt;/pre&gt;&lt;/div&gt;

 &lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;如果你想要保存文件为私有的方式，你可以通过执行getExternalFilesDir() 来获取相应的目录，并且传递一个指示文件类型的参数。每一个以这种方式创建的目录都会被添加到external storage封装你的app目录下的参数文件夹下（如下则是albumName）。这下面的文件会在用户卸载你的app时被系统删除。如下示例：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public File getAlbumStorageDir(Context context, String albumName) {
    // Get the directory for the app's private pictures directory.
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, &quot;Directory not created&quot;);
    }
    return file;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;请记住，getExternalFilesDir() 方法会创建的目录会在app被卸载时被系统删除。如果你的文件想在app被删除时仍然保留，请使用getExternalStoragePublicDirectory().&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;不管你是使用 getExternalStoragePublicDirectory() 来存储可以共享的文件，还是使用 getExternalFilesDir() 来储存那些对与你的app来说是私有的文件，有一点很重要，那就是你要使用那些类似 DIRECTORY_PICTURES  的API的常量。那些目录类型参数可以确保那些文件被系统正确的对待。例如，那些以 DIRECTORY_RINGTONES  类型保存的文件就会被系统的media scanner认为是ringtone而不是音乐。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查询剩余空间&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;如果你事先知道你想要保存的文件大小，你可以通过执行getFreeSpace() or getTotalSpace() 来判断是否有足够的空间来保存文件，从而避免发生IOException。&lt;/p&gt;
&lt;p&gt;那些方法提供了当前可用的空间还有存储系统的总容量。然而，系统并不能保证你可以写入通过 getFreeSpace() 查询到的容量文件， 如果查询的剩余容量比你的文件大小多几MB，或者说文件系统使用率还不足90%，这样则可以继续进行写的操作，否则你最好不要写进去。&lt;/p&gt;
&lt;p&gt;Note：&lt;span&gt;你并没有被强制要求在写文件之前一定有要去检查剩余容量。你可以尝试先做写的动作，然后通过捕获&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; 。这种做法仅适合于你事先并不知道你想要写的文件的确切大小。例如，如果在把PNG图片转换成JPEG之前，你并不知道最终生成的图片大小是多少。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;删除文件&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;p&gt;你应该在不需要使用某些文件的时候，删除它。删除文件最直接的方法是直接执行文件的 delete() 方法。&lt;/p&gt;
&lt;p&gt;myFile.delete();&lt;/p&gt;
&lt;p&gt;如果文件是保存在internal storage，你可以通过 Context 来访问并通过执行 deleteFile() 进行删除&lt;/p&gt;
&lt;p&gt;myContext.deleteFile(fileName);&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;Note: 当用户卸载你的app时，android系统会删除以下文件：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;所有保存到internal storage的文件。&lt;/li&gt;
&lt;li&gt;所有使用getExternalFilesDir()方式保存在external storage的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;然而，通常来说，你应该手动删除所有通过 getCacheDir() 方式创建的缓存文件，以及那些不会再用到的文件。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就像保存文件到设备的internal storage 一样，Android会保存db到你的程序的private的空间上。你的数据是受保护的，因为那些区域默认是私有的，不可被其他程序所访问。&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;Note：因为那些操作可能是很耗时的，请确保你在background thread（AsyncTask or IntentService）里面去执行 getWritableDatabase() 或者 getReadableDatabase() 。&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;和查询信息一样，删除数据同样需要提供一些删除标准。DB的API提供了一个防止SQL注入的机制来创建查询与删除标准。&lt;/p&gt;
&lt;p&gt;SQL Injection：(随着B/S模式应用开发的发展，使用这种模式编写应用程序的程序员也越来越多。但是由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即&lt;span&gt;SQL注入&lt;/span&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个机制把查询语句划分为选项条款与选项参数两部分。条款部分定义了查询的列的特征，参数部分用来测试是否符合前面的条款。因为处理的结果与通常的SQL语句不同，这样可以避免SQL注入问题。&lt;/p&gt;
&lt;/div&gt;





&lt;p&gt;&lt;span&gt;Android图像和动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;高效显示Bitmap&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;42&quot;&gt;
&lt;ul&gt;&lt;li&gt;移动设备的系统资源有限。Android设备对于单个程序至少需要16MB的内存。程序应该在这个最低内存限制下最优化程序的效率。当然，大多数设备的都有更高的限制需求。&lt;/li&gt;
&lt;li&gt;在过去, 一个比较流行的内存缓存的实现方法是使用软引用(SoftReference)或弱引用(WeakReference)bitmap缓存, 然而这是不推荐的。从Android 2.3 (API Level 9) 开始，GC变得更加频繁的去释放soft/weak references，这使得他们就显得效率低下。而且在Android 3.0 (API Level 11)之前，备份的bitmap是存放在native memory 中，它不是以可预知的方式被释放，这样可能导致程序超出它的内存限制而崩溃。&lt;/li&gt;
&lt;li&gt;在上面的例子中, 有1/8的程序内存被作为Cache. 在一个常见的设备上(hdpi)，最小大概有4MB (32/8). 如果一个填满图片的GridView组件放置在800x480像素的手机屏幕上，大概会花费1.5MB (800x480x4 bytes), 因此缓存的容量大概可以缓存2.5页的图片内容.、&lt;/li&gt;
&lt;/ul&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;磁盘缓存可以用来保存那些已经处理好的位图，并且在那些图片在内存缓存中不可用时减少加载的次数。当然从磁盘读取图片会比从内存要慢，而且读取操作需要在后台线程中处理，因为磁盘读取操作是不可预期的。&lt;/p&gt;
&lt;p&gt;Note:如果图片被更频繁的访问到，也许使用 ContentProvider 会更加的合适，比如在Gallery程序中。&lt;/p&gt;
&lt;p&gt;内存缓存的检查是可以在UI线程中进行的，磁盘缓存的检查需要在后台线程中处理。磁盘操作永远都不应该在UI线程中发生。当图片处理完成后，最后的位图需要添加到内存缓存与磁盘缓存中，方便之后的使用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;处理配置改变(Handle Configuration Changes)：详情请看P162&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了测试上面的效果，尝试在保留Fragment与没有这样做的情况下旋转屏幕。你会发现当你保留缓存时,从内存缓存中重新绘制几乎没有延迟的现象. 内存缓存中没有的图片可能在存在磁盘缓存中.如果两个缓存中都没有，则图像会像平时一样被处理。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Android管理bitmap memory的演变进程&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;在Android 2.2 (API level 8)以及之前, 当GC发生时, 你的应用的线程是会stopped的. 这导致了一个滞后，它会降低效率. 在Android 2.3上，添加了并发GC的机制, 这意味着在一个bitmap不再被引用到之后，内存会被立即回收.&lt;/li&gt;
&lt;li&gt;在Android 2.3.3 (API level 10)以及之前, 一个bitmap的像素级数据是存放在native内存中的. 这些数据与bitmap本身是隔离的, bitmap本身是被存放在Dalvik heap中。在native内存中的pixel数据的释放是不可预测的，这意味着有可能导致一个程序容易超过它的内存限制并Crash。 自Android 3.0 (API Level 11)起, pixel数据则是与bitmap本身一起存放在dalvik heap中。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;在Android 3.0及以上版本管理内存：详情请看P165&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Android 3.0 (API Level 11) 引进了BitmapFactory.Options.inBitmap. 如果这个值被设置了，decode方法会在加载内容的时候去重用已经存在的bitmap. 这意味着bitmap的内存是被重新利用的，这样可以提升性能, 并且减少了内存的分配与回收。然而，使用inBitmap有一些限制。特别是在Android 4.4 (API level 19)之前，只支持同等大小的位图。详情请查看inBitmap文档.&lt;/p&gt;
&lt;p&gt;后面的不是很懂，日后再看&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;添加动画&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;滥用动画或者在错误时机使用动画也是有害的，例如：他们造成了延迟。这节课程告诉你如何应用常用动画类型来提升易用性，在不给用户用户增加烦恼的前提下提升性能。&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;俩个view间渐变&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;渐变动画（也叫消失）通常指渐渐的淡出某个 UI 组件，同时同步地淡入另一个。在你 App 想切换内容或 view的情况下，这种动画很有用。渐变简短不易察觉，它也能提供从一个界面到下一个之间流畅的转换。当你不使用它们，不管怎么样转换经常感到生硬而仓促。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;将 config_shortAnimTime 系统属性暂存到一个成员变量里。这个属性为动画定义了一个标准的“短”持续时间。对于微妙或者快速发生的动画，这是个很理想的时间段。config_longAnimTime 和 config_mediumAnimTime 也行，如果你想用的话。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    // 获取并缓存系统默认的“短”时长
    mShortAnimationDuration = getResources().getInteger(
            android.R.integer.config_shortAnimTime);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;对于淡入的 view，设置 alpha 值为 0 并且设置 visibility 为 VISIBLE（要记得他起初被设置成了 GONE）。这让iew 可见了但是它是透明的。&lt;/li&gt;
&lt;li&gt;对于淡入的 view，把 alpha 值从 0 动态改变到 1。同时，对于淡出的 view，把 alpha 值从 1 动态变到 0。&lt;/li&gt;
&lt;li&gt;使用 Animator.AnimatorListener 中的 onAnimationEnd()，设置淡出 view 的 visibility 为 GONE。即使 alpha 值为0，也要把 view 的 visibility 设置成 GONE 来防止 view 占据布局空间，还能把它从布局计算中忽略，加速处理过程。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    // 设置内容View为0%的不透明度，但是状态为“可见”，
    // 因此在动画过程中是一直可见的（但是为全透明）。
    mContentView.setAlpha(0f);
    mContentView.setVisibility(View.VISIBLE);
    // 开始动画内容View到100%的不透明度，然后清除所有设置在View上的动画监听器。
    mContentView.animate()
            .alpha(1f)
            .setDuration(mShortAnimationDuration)
            .setListener(null);
    // 加载View开始动画逐渐变为0%的不透明度，
    // 动画结束后，设置可见性为GONE（消失）作为一个优化步骤
    //（它将不再参与布局的传递等过程）
    mLoadingView.animate()
            .alpha(0f)
            .setDuration(mShortAnimationDuration)
            .setListener(new AnimatorListenerAdapter() {
                @Override
                public void onAnimationEnd(Animator animation) {
                    mLoadingView.setVisibility(View.GONE);
                }
            });
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;wiz_cm_1517897008792_5782&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;Java&quot; data-theme=&quot;default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
   @Override
    public void onBackPressed() {
        if (mPager.getCurrentItem() == 0) {
            // 如果用户当前正在看第一步（也就是第一页），那就要让系统来处理返回按钮。
            //这个是结束（finish()）当前活动并弹出回退栈。
            super.onBackPressed();
        } else {
            // 否则，返回前一页
            mPager.setCurrentItem(mPager.getCurrentItem() - 1);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;viewpager滑动动画用PageTransformer自定义动画&lt;/p&gt;




&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span&gt;Android网络连接和云服务&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管理网络&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;在执行网络操作之前检查设备当前连接的网络连接信息是个好习惯。这样可以防止你的程序在无意间连接使用了非意向的网络频道。如果网络连接不可用，你的应用应该优雅的做出响应。&lt;span&gt;为了检测网络连接，我们需要使用到下面两个类：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;ConnectivityManager: 它会回答关于网络连接状态的查询，并在网络连接改变时通知应用程序。&lt;/li&gt;
&lt;li&gt;NetworkInfo: 描述一个给定网络类型(就本节而言是移动网络或Wi-Fi)的网络接口的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public boolean isOnline() {
    ConnectivityManager connMgr = (ConnectivityManager)
            getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
    return (networkInfo != null &amp;amp;&amp;amp; networkInfo.isConnected());
}

private static final String DEBUG_TAG = &quot;NetworkStatusExample&quot;;
...
    ConnectivityManager connMgr = (ConnectivityManager)
        getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
    boolean isWifiConn = networkInfo.isConnected();
    networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
    boolean isMobileConn = networkInfo.isConnected();
    Log.d(DEBUG_TAG, &quot;Wifi connected: &quot; + isWifiConn);
    Log.d(DEBUG_TAG, &quot;Mobile connected: &quot; + isMobileConn);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div&gt;






&lt;/div&gt;
</description>
<pubDate>Tue, 06 Feb 2018 06:04:00 +0000</pubDate>
<dc:creator>梦和远方</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyu0529/p/8422073.html</dc:identifier>
</item>
<item>
<title>MVVM之旅（1）创建一个最简单的MVVM程序 - Zeek</title>
<link>http://www.cnblogs.com/SilveryBullet/p/8418401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SilveryBullet/p/8418401.html</guid>
<description>&lt;p&gt;这是MVVM之旅系列文章的第一篇，许多文章和书喜欢在开篇介绍某种技术的诞生背景和意义，但是我觉得对于程序员来说，一个能直接运行起来的程序或许能够更直观的让他们了解这种技术。在这篇文章里，我将带领大家一步一步创建一个最简单的MVVM程序，程序虽然简单，但是却涵盖了MVVM的基本要素，对于那些还不是很了解MVVM的读者来说，相信这会是一个很好的入门。&lt;/p&gt;
&lt;p&gt;程序的功能非常简单：两个按钮一个文本框，点击某个按钮就把某个按钮上的文字显示到文本框里。&lt;/p&gt;
&lt;h3&gt;传统做法的问题&lt;/h3&gt;
&lt;p&gt;对于如此简单的问题，传统的做法就是一句话的事，双击Button，在xaml.cs文件的事件响应函数里写下下面这样一行代码就行了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.textBox1.Text = button1.Content.ToString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种做法很简单，但是却暴露了一个很严重的问题:this.textBox1是对视图元素的一个强引用，这样的代码把视图和逻辑完全耦合在了一起（如果没有textBox1这个具体的视图对象实例，这行逻辑代码根本编译不过去，逻辑离不开视图，这就耦合了）。这样的代码在小软件里没啥问题，但是当软件变大变复杂的时候问题就来了：在大型软件开发里，大家都是相互分工合作，各自负责自己的模块，有人负责界面设计，有人负责后台逻辑，如果代码这样写，那美工的新版界面还没有画好的时候，我后台的逻辑岂不是不能写不能测试了？ &lt;/p&gt;
&lt;h3&gt;视图和逻辑分开早已是共识&lt;/h3&gt;
&lt;p&gt;把软件的视图界面和逻辑分开并不是MVVM的发明，上世纪80年代MVC就把视图层和逻辑层分开（加上数据层，构成了经典的三层架构），后来的MVP在MVC的基础上做了改进，使得程序之间的耦合性再次降低，微软以MVP为基础，考虑到WPF的特性，推出了纯数据驱动的MVVM框架。&lt;/p&gt;
&lt;p&gt;这里要特别提一下数据驱动，MVVM让我们的编程方式从原来的消息驱动、事件驱动转成了更加高效的数据驱动，这是跟MVC、MVP完全不一样的。也因此，MVVM里的ViewModel并不等同于在MVC和MVP里做逻辑处理的Controller和Presenter，它更像一个数据格式化器，它的任务就是把来源不同的各种数据进行处理，然后按照一定的格式提供给View。 &lt;/p&gt;
&lt;h3&gt;MVVM的做法&lt;/h3&gt;
&lt;p&gt;既然MVVM是继承了MVC、MVP这种经典的三层架构的风格，那么它肯定将视图层（V-View）和逻辑层（VM-ViewModel，这里只是借鉴了逻辑层这样经典的一个概念，把ViewModel翻译成逻辑层并不合适，但是业务逻辑一般确实也是在这里做的）做了解耦，因为我们这个例子非常小，所以暂时不涉及数据层（M-Model）。&lt;/p&gt;
&lt;p&gt;我们先建一个WPF的项目，项目里添加Views和ViewModels两个文件夹。顾名思义，Views文件夹里存放所有的View，ViewModels文件夹里存放对应的ViewModel：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/401239/201802/401239-20180206094306404-265991780.jpg&quot;&gt;&lt;img title=&quot;QQ截图20180206091702&quot; src=&quot;https://images2017.cnblogs.com/blog/401239/201802/401239-20180206094306763-526810562.jpg&quot; alt=&quot;QQ截图20180206091702&quot; width=&quot;240&quot; height=&quot;170&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我们将两个按钮一个文本框放到ChildWindow里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/401239/201802/401239-20180206094307029-1505465499.jpg&quot;&gt;&lt;img title=&quot;QQ截图20180206092119&quot; src=&quot;https://images2017.cnblogs.com/blog/401239/201802/401239-20180206094307248-42057383.jpg&quot; alt=&quot;QQ截图20180206092119&quot; width=&quot;240&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么接下来问题来了：点击Button并且改变TextBox里内容这个事情，如果不能在ChildWindow.xaml.cs里通过响应Button的click事件来完全，那要怎么做呢？或者说的再简单一点，不准你在xaml.cs文件后面写代码,你要怎么实现这个事情？（Xaml文件代表的是我们的视图，xaml.cs里写代码非常容易造成视图和逻辑的耦合，如果我们想彻底解耦视图层和逻辑层，那么直接让xaml纯负责视图，我的逻辑部分完全写在另外的地方是非常简单有效的办法。Android就是这么干的，而且更彻底，Android开发里使用纯XML文件代表视图，它压根就不提供xml.cs这种东西让你写代码，你想要使用视图里的元素，你得在其他地方使用&lt;em&gt;findViewById&lt;/em&gt;来找）。&lt;/p&gt;
&lt;p&gt;MVVM给的答案就是：绑定（Binding）+命令（ICommand）。 &lt;/p&gt;
&lt;h3&gt;添加绑定(Binding)&lt;/h3&gt;
&lt;p&gt;MVVM把View放在Xaml文件里，把逻辑放在ViewModel里，然后通过绑定让指定的View和ViewModel关联在一起。你要处理什么业务逻辑都在ViewModel里写，业务逻辑处理完了要更新View的时候也不是直接用“this.xxxView.某属性=xxx”这样的句式来更新（其实你想这样更新也做不到，因为ViewModel为了和View解耦，里面根本就不会持有View对象的引用）而是通过更改ViewModel里和View绑定的相关属性来修改View。&lt;/p&gt;
&lt;p&gt;把ChildWindow和ChildWindowViewModel绑定在一起很简单，在ChileWindow.Xaml里设置DataContext就行了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;MVVMDemo.Views.ChildWindow&quot;&lt;/span&gt;&lt;span&gt;
        ...
        xmlns:vm&lt;/span&gt;&lt;span&gt;=&quot;clr-namespace:MVVMDemo.ViewModels&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window.DataContext&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;vm:ChildWindowViewModel&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window.DataContext&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做了之后View和ViewModel就绑定在了一起。不过,因为我们在点击Button之后要改变TextBox的显示内容，所以我们还得把TextBox的Text属性跟ViewModel做绑定，我们先在ChildWindowViewModel里建一个TextBox1Text属性用来给TextBox的对象做绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChildWindowViewModel
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TextBox1Text { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把textBox1的Text属性和它绑定在一起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;textBox1&quot;&lt;/span&gt;&lt;span&gt;  Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding TextBox1Text}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 添加命令(ICommand)&lt;/h3&gt;
&lt;p&gt;绑定工作做好了接下来就要添加命令了。因为我们不能直接在xaml.cs文件里写click事件的响应，所以响应点击按钮这个事情是通过命令（ICommand）来实现的。&lt;/p&gt;
&lt;p&gt;我们先在ViewModel里添加一个ICommand属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICommand Button1Cmd
{
    &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DelegateCommand((obj) =&amp;gt;&lt;span&gt;
            {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;button1点击之后要做的事情写在这里&lt;/span&gt;
&lt;span&gt;    
            });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后同样把这个ICommand属性和button1的Command属性绑定在一起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; Command&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Button1Cmd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做了之后只要点击button1,就会自动执行Button1Cmd里的代码。在这个Button1Cmd属性里，我们看到有个DelegateCommand类，这是在MVVM使用频率超高的一个基础类。因为ICommand只是一个接口，DelegateCommand帮助我们做了一些在MVVM里非常基础公共的事情，使得我们可以直接在Button1Cmd里如此简洁的写命令代码（说实话，微软没把这个类写进类库里我都感觉奇怪）。&lt;/p&gt;
&lt;p&gt;DelegateCommand的代码如下（文章末尾的源代码里还提供了它的泛型版本）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DelegateCommand : ICommand
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; executeAction;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; canExecuteFunc;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler CanExecuteChanged;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DelegateCommand(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; execute)
            : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(execute, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DelegateCommand(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; execute, Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; canExecute)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (execute == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            executeAction &lt;/span&gt;=&lt;span&gt; execute;
            canExecuteFunc &lt;/span&gt;=&lt;span&gt; canExecute;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanExecute(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (canExecuteFunc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; canExecuteFunc(parameter);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (executeAction == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            executeAction(parameter);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 测试命令&lt;/h3&gt;
&lt;p&gt;我们删掉MainWindow，把App.xaml里的StartUri设为ChildWindow的路径，让程序运行的时候直接启动ChildWindow：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;MVVMDemo.App&quot;&lt;/span&gt;&lt;span&gt;
             ...
             StartupUri&lt;/span&gt;&lt;span&gt;=&quot;Views/ChildWindow.xaml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在DelegateCommand里添加一行弹出消息提示框的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DelegateCommand((obj) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;button1点击之后要做的事情写在这里&lt;/span&gt;
                        System.Windows.MessageBox.Show(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button1 click!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;span&gt;
                    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击button1，看到了如下弹出的消息框，证明Button绑定的命令确实传到ViewModel里来了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/401239/201802/401239-20180206113311420-447576278.jpg&quot;&gt;&lt;img title=&quot;QQ截图20180206105524&quot; src=&quot;https://images2017.cnblogs.com/blog/401239/201802/401239-20180206113311701-1991482735.jpg&quot; alt=&quot;QQ截图20180206105524&quot; width=&quot;240&quot; height=&quot;144&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt; 绑定元素属性TextBox1Text&lt;/h3&gt;
&lt;p&gt;那我们接下来在这里去修改TextBox1Text的值，因为TextBox1Text这个属性已经和ChildWindow里的textBox1的Text属性做了绑定，所以按照我的想法，如果我在ViewModel里修改了TextBox1Text的值，textBox1显示的数字就会跟着改变。&lt;/p&gt;
&lt;p&gt;按照这个思路我们添加了如下的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DelegateCommand((obj) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;button1点击之后要做的事情写在这里
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Windows.MessageBox.Show(&quot;button1 click!&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试代码&lt;/span&gt;
                        &lt;span&gt;this&lt;/span&gt;.TextBox1Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button1 click!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行，点击button1，结果却什么事情都没有发生，并没有出现我们期待的textBox1里出现“button1 click!”的字样，为什么呢？明明确实执行了这行代码，View和ViewModel之间的绑定也确实做好了,TextBox1Text的改变为什么不能自动改变textBox1的值？&lt;/p&gt;
&lt;p&gt;答案是这样的：我们虽然把ViewModel的属性跟View元素的属性做了绑定，如果想让ViewModel里的属性发生变化之后View里对应的元素也跟着变，你得手动通知它。&lt;/p&gt;
&lt;p&gt;为什么需要我们手动去通知，微软为什么不把这种东西都做到框架里面去？&lt;/p&gt;
&lt;p&gt;你想啊，View的界面里有这么多元素，每个元素都有这么多属性，而我需要改变的属性只有那么几个，我不能因为我要改变这几个属性而把所有的属性都附加上这种功能把，这样太浪费资源了。另外，自己去手动通知代码也非常简单，都是可以重复利用的。&lt;/p&gt;
&lt;h3&gt; 添加通知INotifyPropertyChanged&lt;/h3&gt;
&lt;p&gt;因为每个属性要通知界面都要实现这个通知接口，所以可想而知，这是一个要重复做很多次的事情。为了让我们以后更加省心，我们把这个通知接口的实现放到基类ViewModelBase里去，让所有的ViewModel继承这个基类就行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewModelBase : INotifyPropertyChanged
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; PropertyChangedEventHandler PropertyChanged;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RaisePropertyChanged(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; propertyName)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (PropertyChanged != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                PropertyChanged.Invoke(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyChangedEventArgs(propertyName));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在ChildWindowViewModel继承ViewModelBase，改写一下TextBox1Text属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; textBox1Text;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; TextBox1Text
{
    &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.textBox1Text;
    }
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.textBox1Text =&lt;span&gt; value;
        RaisePropertyChanged(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TextBox1Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在TextBox1Text的set里添加了RaisePropertyChanged(&quot;TextBox1Text&quot;);这样一行，这就是告诉系统，如果我这个属性发生了改变，就去通知界面里一个叫“TextBox1Text”的属性（不过他只负责通知到位，通知到了之后你要做什么它就不管了）。&lt;/p&gt;
&lt;p&gt;再次运行程序，点击button1，我们发现textBox1就如愿以偿的发生了改变：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/401239/201802/401239-20180206113312138-1881225268.png&quot;&gt;&lt;img title=&quot;QQ图片20180206112528&quot; src=&quot;https://images2017.cnblogs.com/blog/401239/201802/401239-20180206113312451-1190372379.png&quot; alt=&quot;QQ图片20180206112528&quot; width=&quot;240&quot; height=&quot;119&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用同样的方式去处理button2，效果一样的。&lt;/p&gt;
&lt;h3&gt; 结语&lt;/h3&gt;
&lt;p&gt;至此，我们这个全世界最简单的MVVM程序的功能就已经都实现了。通过绑定和命令实现了一个最简单却非常具有代表性的操作：界面点击操作，后台处理逻辑，处理好了以后把结果更新在界面里，也抽象出来了DelegateCommand和ViewModelBase两个通用类。它很好的解耦了视图和逻辑：大家可以看到，我们的ChildWindowViewModel里面没有任何和View相关的代码，因此完全可以单独拿来出测试；我们的ChildWindow.xaml.cs文件里没有一行代码，ChildWindow完完全全就是一个视图界面，你也可以对他单独操作。&lt;/p&gt;
&lt;p&gt;而且更重要的是：我的ChildWindowViewModel只要第一次去设置好和ChildWindow绑定的属性，以后就再也不用跟View打交道了，我以后所以对View的操作都变成了对ViewModel里属性的操作，我只要知道我要写的逻辑最后要赋值给那个属性就行了，至于那个属性最终会以什么样的形式绑定呈现在界面上，我完全不关心。这不是程序员梦寐以求的事情么？&lt;/p&gt;
&lt;p&gt;对于美工来说一样解脱了，以前一个大的项目组里虽然有程序员，也有专门的美工，但很多时候的工作是这样的：程序员说这里需要一个蓝色的按钮，美工就去切一个按钮给程序员，程序员把这张图片设置成按钮的背景，接着要信息显示的背景图片又得找美工要，然后自己写程序把图片样式颜色都调好。但是现在却可以变成这样：项目经理说这个View要显示一个人的各种具体信息（年龄性别名字等等等之类的），然后美工可以拿起Blend这样的工具，按照自己的想法把这整个View的界面画好，然后直接就向贴纸一样贴在程序员写的ViewModel里，程序员什么都不用改，指定一下DataContext和绑定属性就可以直接用了，这样的合作多么畅快人心！&lt;/p&gt;
&lt;p&gt;另外，MVVM虽然是微软为了WPF量身定做提出来的，但是它的思想却非常具有启发性，它通过绑定让视图和逻辑层之间的解耦比MVP还彻底，所以现在不止WPF，Android、IOS、前端开发都在研究MVVM。但是毕竟MVVM是微软为了WPF量身定做的，所以总的来看，还是WPF对MVVM的实现最为自然简洁优雅。深入了解MVVM的思想和实现对提高WPF的编程水平有巨大的帮助，如果还是使用MFC、Winform时代的思想来写WPF程序，那就真的是白白浪费了WPF这个如此先进的技术，有种用屠龙刀在切牛肉的既视感。&lt;/p&gt;
&lt;p&gt;文章代码下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/SilveryBullet/MVVMDemo.rar&quot;&gt;MVVMDemo.rar&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 05:57:00 +0000</pubDate>
<dc:creator>Zeek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SilveryBullet/p/8418401.html</dc:identifier>
</item>
<item>
<title>知识点干货—多线程同步【6】之synchronized - laoxiao79</title>
<link>http://www.cnblogs.com/laoxiao79/p/8421994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoxiao79/p/8421994.html</guid>
<description>&lt;p&gt;&lt;strong&gt;“明日复明日，明日何其多。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;我生待明日，万事成蹉跎。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;世人若被明日累，春去秋来老将至。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;朝看水东流，暮看日西坠。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;百年明日能几何？请君听我明日歌。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;明日复明日，明日何其多！&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;日日待明日，万世成蹉跎。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;世人皆被明日累，明日无穷老将至。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;晨昏滚滚水东流，今古悠悠日西坠。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;百年明日能几何？请君听我明日歌。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这首《明日歌》是明朝的钱福所写。大意是，&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;明天又一个明天，明天何等的多。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;我的一生都在等待明日，什么事情都没有进展。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;世人和我一样辛苦地被明天所累，一年年过去马上就会老。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;早晨看河水向东流逝，傍晚看太阳向西坠落才是真生活。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;百年来的明日能有多少呢？请诸位听听我的《明日歌》。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这首诗七次提到“明日”，诗人在作品中告诫和劝勉人们要牢牢地抓住稍纵即逝的今天，要珍惜时间，今日的事情今日做，不要拖到明天，不要蹉跎岁月。不要把任何计划和希望寄托在未知的明天。诗歌的意思浅显，语言明白如话，说理通俗易懂。给人的启示是：世界上的许多东西都能尽力争取和失而复得，只有时间难以挽留。人的生命只有一次，时间永不回头。不要今天的事拖明天，明天拖后天，要“今天的事，今日毕”。告诫我们不要学寒号鸟，要珍惜时间，不要把事情都放到明天，今天的事情今天搞定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续总结多线程同步常用的方法或者类，之前介绍了CountDownLatch，CyclicBarriar和Exchanger，Phaser 以及Semaphore，这次介绍一个大家比较熟悉的关键字--synchronized。大多数人应该或多或少的使用过它，那我们对它是所有用法都彻底了解吗？这个就不见的了，今天我们就全方位的介绍一下它。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;1、定义&lt;/h2&gt;
&lt;p&gt;先看一下百度百科给出的定义：“synchronized--Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。”&lt;br/&gt;什么意思呢？就是说synchronized是Java中用来对对象和方法或者代码块进行加锁的一种方法，借助它可以在多线程并发时，保证同一时刻只有一个线程执行某个同步方法或代价块，这样能充分保证线程按顺序执行，保证它们同步进行，按照我们的逻辑使多线程按我们的心意来依次执行，这也是一种解决多线程同步的方法。&lt;/p&gt;
&lt;h2 id=&quot;对象锁和类锁的概念&quot;&gt;2、对象锁和类锁的概念&lt;/h2&gt;
&lt;p&gt;在使用synchronized前，我们要先理解两个概念，对象锁和类锁。&lt;/p&gt;
&lt;p&gt;对象锁&lt;br/&gt;对象锁是指Java为临界区（指程序中的一个代码段）synchronized(Object)语句指定的对象进行加锁。它用于程序片段或者method上，此时将获得对象的锁，所有想要进入该对象的synchronized的方法或者代码段的线程都必须获取对象的锁，如果没有，则必须等其他线程释放该锁。&lt;br/&gt;当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。&lt;/p&gt;
&lt;p&gt;类锁&lt;br/&gt;实际上是没有这个概念的，但是为了区分对象锁的不同使用场景，我们增加了一个类锁这样的概念。对象锁指的是对象的某个方法或代码块进行加锁，那类锁指的是针对类方法或者类变量进行加锁。由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态方法被申明为synchronized，此类所有的实例化对象在调用此方法，共用同一把锁，所以我们称之为类锁。&lt;br/&gt;在程序中可以尝试用以下方式获取类锁&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;synchronized (xxx.class) {...}
synchronized (Class.forName(&quot;xxx&quot;)) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时获取类锁和对象锁是可以的，并不会产生问题。但使用类锁时要格外注意，因为一旦产生类锁的嵌套获取的话，就会产生死锁，因为每个class在内存中都只能生成一个Class实例对象。&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;3、使用方法&lt;/h2&gt;
&lt;p&gt;了解了对象锁和类锁后，我们知道了synchronized可以用于多个场景，既可以修改代码块和方法，还可以用来修饰类方法和类。虽然锁针的对象不同，但它们的含义是一样的。&lt;/p&gt;
&lt;p&gt;synchronized具体有如下四种使用场景：&lt;br/&gt;（1）、修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。多个线程在同时使用这个对象的此代码块时会遇到对象锁，需要进行同步等待；&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class DemoThread implements Runnable {

    private static int count;

    public DemoThread() {
        count = 0;
    }

    public  void run() {
        synchronized(this) {
            for (int i = 0; i &amp;lt; 5; i++) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public int getCount() {
        return count;
    }
}

DemoThread demoThread = new DemoThread();
Thread thread1 = new Thread(demoThread, &quot;DemoThread1&quot;);
Thread thread2 = new Thread(demoThread, &quot;DemoThread2&quot;);

thread1.start();
thread2.start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DemoThread1:0 
DemoThread1:1 
DemoThread1:2 
DemoThread1:3 
DemoThread1:4 
DemoThread2:5 
DemoThread2:6 
DemoThread2:7 
DemoThread2:8 
DemoThread2:9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：当两个并发线程(thread1和thread2)同事访问同一个对象(demoThread)中的synchronized代码块时，在同一时刻只能有一个线程执行，另一个线程阻塞在synchronized位置，必须等待正在访问的线程执行完这个代码块以后才能执行该代码块。所以才会看到这样的结果，开始只有DemoThread1的Log，DemoThread1执行完成后才能看到DemoThread的Log。&lt;/p&gt;
&lt;p&gt;这里需要注意一下，当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。也就是说如果thread1正在访问synchronized修饰的代码块，thread2虽然此时无法访问这个代码块，但它可以访问其他的代码块。&lt;/p&gt;
&lt;p&gt;（2）、修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象。在多线程执行时和同步代码块相同，针对的是某个对象；&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DemoThread implements Runnable {
    private static int count;

    public DemoThread() {
        count = 0;
    }

    public synchronized void run() {
        for (int i = 0; i &amp;lt; 5; i++) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public int getCount() {
        return count;
    }
}

DemoThread demoThread = new DemoThread();
Thread thread1 = new Thread(demoThread, &quot;DemoThread1&quot;);
Thread thread2 = new Thread(demoThread, &quot;DemoThread2&quot;);

thread1.start();
thread2.start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DemoThread1:0 
DemoThread1:1 
DemoThread1:2 
DemoThread1:3 
DemoThread1:4 
DemoThread2:5 
DemoThread2:6 
DemoThread2:7 
DemoThread2:8 
DemoThread2:9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到他们的执行结果是相同的。既然结果相同，那修饰代码块和修改方法名有什么区别呢？&lt;br/&gt;这个问题也是synchronized的缺陷。&lt;br/&gt;synchronized的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待，这问题一旦出现就是是一个致命的问题。既然无法完全避免这种缺陷，那么就应该将风险降到最低。同步代码块就是为了降低风险而存在的。因为如果某一线程调用synchronized修饰的代码方法，那么当某个线程进入了这个方法之后，这个对象其他同步方法都不能被其他线程访问了。假如这个方法需要执行的时间很长，那么其他线程会一直阻塞，影响到系统的性能。而如果这时用synchronized来修饰代码块，情况就不同了，这个方法加锁的对象是某个对象，跟执行这行代码的对象或者承载这个方法的对象没有关系，那么当一个线程执行这个方法时，其他同步方法仍旧可以访问，因为他们持有的锁不一样。&lt;/p&gt;
&lt;p&gt;（3）、修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。多线程在使用此方法时，会涉及到类锁。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DemoThread implements Runnable {
    private static int count;

    public DemoThread() {
        count = 0;
    }

    public synchronized static void method() {
        for (int i = 0; i &amp;lt; 5; i ++) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public synchronized void run() {
        method();
    }
}
DemoThread demoThread = new DemoThread();
Thread thread1 = new Thread(demoThread, &quot;DemoThread1&quot;);
Thread thread2 = new Thread(demoThread, &quot;DemoThread2&quot;);

thread1.start();
thread2.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DemoThread1:0 
DemoThread1:1 
DemoThread1:2 
DemoThread1:3 
DemoThread1:4 
DemoThread2:5 
DemoThread2:6 
DemoThread2:7 
DemoThread2:8 
DemoThread2:9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果和上两例相同。DemoThread1和DemoThread2是DemoThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。&lt;/p&gt;
&lt;p&gt;（4）、修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。多线程使用此类时涉及到类锁。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DemoThread implements Runnable {
    private static int count;

    public DemoThread() {
        count = 0;
    }

    public static void method() {
        synchronized(DemoThread.class) {
            for (int i = 0; i &amp;lt; 5; i ++) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public synchronized void run() {
        method();
    }
}
DemoThread demoThread = new DemoThread();
Thread thread1 = new Thread(demoThread, &quot;DemoThread1&quot;);
Thread thread2 = new Thread(demoThread, &quot;DemoThread2&quot;);

thread1.start();
thread2.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DemoThread1:0 
DemoThread1:1 
DemoThread1:2 
DemoThread1:3 
DemoThread1:4 
DemoThread2:5 
DemoThread2:6 
DemoThread2:7 
DemoThread2:8 
DemoThread2:9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果也是相同的。synchronized作用于一个类时，是给这个类加锁，类的所有对象用的是同一把锁。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;synchronized对于使用过的人来说应该比较好理解，也更容易学习它的高级用法，运用起来会显得很轻松；对于没有使用过的，可能只是停留在理解概念的层面，实际在使用时还是不太好下手，不知在何时何地来使用。所以解决不熟悉的唯一办法就是要勇敢大胆的去使用它，不要怕出错，多实践和多练习，这样才能很好的掌握它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1325889/201802/1325889-20180206134634498-1317437722.jpg&quot;/&gt;&lt;br/&gt;本公众号将以推送Android各种技术干货或碎片化知识，以及整理老司机日常工作中踩过的坑涉及到的经验知识为主，也会不定期将正在学习使用的新技术总结出来进行分享。每天一点干货小知识把你的碎片时间充分利用起来。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 05:47:00 +0000</pubDate>
<dc:creator>laoxiao79</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoxiao79/p/8421994.html</dc:identifier>
</item>
</channel>
</rss>