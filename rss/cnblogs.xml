<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Steeze框架之入门使用 - 程序人生♨︎</title>
<link>http://www.cnblogs.com/springwind2006/p/8397238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springwind2006/p/8397238.html</guid>
<description>&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;
&lt;p&gt;steeze是一个优雅、简洁而又高效的PHP开源框架，在整合了知名框架ThinkPHP和Laravel优点的同时，重写了底层架构，增强了功能实现。支持swoole模型运行，支持容器、模型、依赖注入、中间件、路由配置、自定义模板引擎功能，支持多模块独立配置和集成开发，同时支持WEB和Cli两种运行模式。&lt;/p&gt;
&lt;h2 id=&quot;二安装及配置环境变量&quot;&gt;二、安装及配置环境变量&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/springwind2006/p/8372797.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/springwind2006/p/8372797.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三入门使用&quot;&gt;三、入门使用&lt;/h2&gt;
&lt;p&gt;配置好运行环境之后，进入Storage/Conf目录，打开route.php文件&lt;br/&gt;输入如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
return [
    'default' =&amp;gt; [
        '/'=&amp;gt; function(){
            return 'Hello world!';
        },
    ]
];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后打开浏览器，访问：&lt;a href=&quot;http://localhost/&quot; class=&quot;uri&quot;&gt;http://localhost/&lt;/a&gt;&lt;br/&gt;此时输出“Hello world!”&lt;/p&gt;
&lt;p&gt;也可以通过配置控制器的方式，进入app/Home/Controller目录&lt;br/&gt;新建一个控制器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
namespace App\Home\Controller;
use Library\Controller;

class Demo extends Controller{
    // 外部访问的方法名称
    public function hello(){
        return 'Hello world!';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Storage/Conf/route.php文件中配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
return [
    'default' =&amp;gt; [
        '/hello'=&amp;gt; 'Demo/hello@home',
    ]
];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后打开浏览器，访问：&lt;a href=&quot;http://localhost/hello%EF%BC%8C%E6%AD%A4%E6%97%B6%E8%BE%93%E5%87%BA%E2%80%9CHello&quot; class=&quot;uri&quot;&gt;http://localhost/hello，此时输出“Hello&lt;/a&gt; world!”&lt;/p&gt;
&lt;p&gt;更多参考手册：&lt;a href=&quot;http://steeze.cn/docs/startup/index/&quot; class=&quot;uri&quot;&gt;http://steeze.cn/docs/startup/index/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 23:01:00 +0000</pubDate>
<dc:creator>程序人生♨︎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/springwind2006/p/8397238.html</dc:identifier>
</item>
<item>
<title>Azure Powershell获取指定订阅下的虚拟机信息（ARM） - 铭的随记</title>
<link>http://www.cnblogs.com/stonehe/p/8395959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stonehe/p/8395959.html</guid>
<description>
&lt;p&gt;为方便Azure用户导出已创建虚拟机的相关信息，特编写如下脚本：&lt;/p&gt;

&lt;p&gt;详情脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登陆Azure Account&lt;/span&gt;
Add-AzureRmAccount -&lt;span&gt;EnvironmentName AzureChinaCloud

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置订阅ID&lt;/span&gt;
&lt;span&gt;$sub&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Select&lt;/span&gt;-AzureRmSubscription -Subscription &lt;span&gt;$sub&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置Excel格式&lt;/span&gt;
&lt;span&gt;$excel&lt;/span&gt; = New-Object -&lt;span&gt;ComObject Excel.Application
&lt;/span&gt;&lt;span&gt;$workbook&lt;/span&gt; = &lt;span&gt;$excel&lt;/span&gt;&lt;span&gt;.Workbooks.add()
&lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt; = &lt;span&gt;$workbook&lt;/span&gt;.worksheets.Item(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,1) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$excel&lt;/span&gt;.Visible = &lt;span&gt;$true&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$b&lt;/span&gt; = 1 ; &lt;span&gt;$b&lt;/span&gt; &lt;span&gt;-le&lt;/span&gt; 14 ; &lt;span&gt;$b&lt;/span&gt;++&lt;span&gt;)
{
 &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,&lt;span&gt;$b&lt;/span&gt;).font.bold = &lt;span&gt;$true&lt;/span&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;$sheet.cells.item(1,$b).borders.LineStyle = $lineStyle::xlDashDot&lt;/span&gt;
 &lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,&lt;span&gt;$b&lt;/span&gt;).borders.ColorIndex = &lt;span&gt;$colorIndex&lt;/span&gt;::&lt;span&gt;xlColorIndexAutomatic
 &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,&lt;span&gt;$b&lt;/span&gt;).borders.weight = &lt;span&gt;$borderWeight&lt;/span&gt;::&lt;span&gt;xlMedium
}
  
&lt;/span&gt;&lt;span&gt;$x&lt;/span&gt; = 2
&lt;span&gt;$lineStyle&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;microsoft.office.interop.excel.xlLineStyle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;-as&lt;/span&gt;&lt;span&gt; [type]
&lt;/span&gt;&lt;span&gt;$colorIndex&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;microsoft.office.interop.excel.xlColorIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;-as&lt;/span&gt;&lt;span&gt; [type]
&lt;/span&gt;&lt;span&gt;$borderWeight&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;microsoft.office.interop.excel.xlBorderWeight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;-as&lt;/span&gt;&lt;span&gt; [type]
&lt;/span&gt;&lt;span&gt;$chartType&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;microsoft.office.interop.excel.xlChartType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;-as&lt;/span&gt;&lt;span&gt; [type]
&lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,1) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,2) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,3) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,4) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;资源组&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,5) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;位置&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,6) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;订阅ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,7) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内网IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,8) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内网IP保留状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,9) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;配置信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,10) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,11) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DNS域名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,12) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公网IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,13) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公网IP保留状态&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;$sheet&lt;/span&gt;.cells.item(1,14) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;目标端口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义变量&lt;/span&gt;
&lt;span&gt;$vms&lt;/span&gt; = Get-AzureRmVM -&lt;span&gt;Status
&lt;/span&gt;&lt;span&gt;$vmCount&lt;/span&gt; = &lt;span&gt;$vms&lt;/span&gt;&lt;span&gt;.Count
&lt;/span&gt;&lt;span&gt;$nics&lt;/span&gt; = Get-&lt;span&gt;AzureRmNetworkInterface
&lt;/span&gt;&lt;span&gt;$pips&lt;/span&gt; = Get-&lt;span&gt;AzureRmPublicIpAddress
&lt;/span&gt;&lt;span&gt;$nsgs&lt;/span&gt; = Get-&lt;span&gt;AzureRmNetworkSecurityGroup
Write&lt;/span&gt;-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;$currentSub&lt;/span&gt; = (Get-&lt;span&gt;AzureRmContext).Subscription.Name

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义方法&lt;/span&gt;
&lt;span&gt;Function&lt;/span&gt; GetResourceNameFromResourceId(&lt;span&gt;$resourceId&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$resourceId&lt;/span&gt;.Substring(&lt;span&gt;$resourceId&lt;/span&gt;.LastIndexOf('/') + 1&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取变量Value&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0; &lt;span&gt;$i&lt;/span&gt; &lt;span&gt;-lt&lt;/span&gt; &lt;span&gt;$vmCount&lt;/span&gt;; &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;)
 {
    &lt;/span&gt;&lt;span&gt;$vm&lt;/span&gt; = &lt;span&gt;$vms&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;$nicResourceId&lt;/span&gt; = &lt;span&gt;$vm&lt;/span&gt;.NetworkProfile.NetworkInterfaces[0&lt;span&gt;].Id
    &lt;/span&gt;&lt;span&gt;$nicInterfaces&lt;/span&gt; = GetResourceNameFromResourceId(&lt;span&gt;$nicResourceId&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;$nic = Get-AzureRmNetworkInterface -Name $nicInterfaces -ResourceGroupName $vm.ResourceGroupName&lt;/span&gt;
    &lt;span&gt;$nic&lt;/span&gt; = &lt;span&gt;$nics&lt;/span&gt; | where {&lt;span&gt;$_&lt;/span&gt;.Name &lt;span&gt;-eq&lt;/span&gt;  &lt;span&gt;$nicInterfaces&lt;/span&gt; &lt;span&gt;-and&lt;/span&gt; &lt;span&gt;$_&lt;/span&gt;.ResourceGroupName &lt;span&gt;-eq&lt;/span&gt; &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.ResourceGroupName}
    &lt;/span&gt;&lt;span&gt;$ipResourceId&lt;/span&gt; = &lt;span&gt;$nic&lt;/span&gt;.IpConfigurations[0&lt;span&gt;].PublicIpAddress.Id
    &lt;/span&gt;&lt;span&gt;$ipAddress&lt;/span&gt; = GetResourceNameFromResourceId(&lt;span&gt;$ipResourceId&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;$pip&lt;/span&gt; = &lt;span&gt;$pips&lt;/span&gt; | where {&lt;span&gt;$_&lt;/span&gt;.Name &lt;span&gt;-eq&lt;/span&gt; &lt;span&gt;$ipAddress&lt;/span&gt; &lt;span&gt;-and&lt;/span&gt; &lt;span&gt;$_&lt;/span&gt;.ResourceGroupName &lt;span&gt;-eq&lt;/span&gt; &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.ResourceGroupName}
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,1) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.name
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,2) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;虚拟机(ARM)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,3) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.PowerState
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,4) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.ResourceGroupName        
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,5) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.Location
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,6) = &lt;span&gt;$currentSub&lt;/span&gt;
    &lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,7) = &lt;span&gt;$nic&lt;/span&gt;.IpConfigurations[0&lt;span&gt;].PrivateIpAddress
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,8) = &lt;span&gt;$nic&lt;/span&gt;.IpConfigurations[0&lt;span&gt;].PrivateIpAllocationMethod        
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,9) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.HardwareProfile.VmSize
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,10) = &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.StorageProfile.OsDisk.OsType.ToString()
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,11) = &lt;span&gt;$pip&lt;/span&gt;&lt;span&gt;.DnsSettings.Fqdn
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,12) = &lt;span&gt;$pip&lt;/span&gt;&lt;span&gt;.IpAddress
    &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,13) = &lt;span&gt;$pip&lt;/span&gt;&lt;span&gt;.PublicIpAllocationMethod

    &lt;/span&gt;&lt;span&gt;$nsgResourceId&lt;/span&gt; = &lt;span&gt;$nic&lt;/span&gt;.NetworkSecurityGroup[0&lt;span&gt;].Id
    &lt;/span&gt;&lt;span&gt;$nsgName&lt;/span&gt; = GetResourceNameFromResourceId(&lt;span&gt;$nsgResourceId&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;$nsg = Get-AzureRmNetworkSecurityGroup -Name $nsgName -ResourceGroupName $vm.ResourceGroupName&lt;/span&gt;
    &lt;span&gt;$nsg&lt;/span&gt; = &lt;span&gt;$nsgs&lt;/span&gt; | where {&lt;span&gt;$_&lt;/span&gt;.Name &lt;span&gt;-eq&lt;/span&gt;  &lt;span&gt;$nsgName&lt;/span&gt; &lt;span&gt;-and&lt;/span&gt; &lt;span&gt;$_&lt;/span&gt;.ResourceGroupName &lt;span&gt;-eq&lt;/span&gt; &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.ResourceGroupName}
    
    &lt;/span&gt;&lt;span&gt;$ports&lt;/span&gt; = &lt;span&gt;$nsg&lt;/span&gt;&lt;span&gt;.SecurityRules.DestinationPortRange
    &lt;/span&gt;&lt;span&gt;$portCount&lt;/span&gt; = &lt;span&gt;$ports&lt;/span&gt;&lt;span&gt;.Count
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$j&lt;/span&gt;=0; &lt;span&gt;$j&lt;/span&gt; &lt;span&gt;-lt&lt;/span&gt; &lt;span&gt;$portCount&lt;/span&gt;; &lt;span&gt;$j&lt;/span&gt;++&lt;span&gt;)
      {
        &lt;/span&gt;&lt;span&gt;$port&lt;/span&gt; = &lt;span&gt;$ports&lt;/span&gt;[&lt;span&gt;$j&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;$sheet&lt;/span&gt;.cells.item(&lt;span&gt;$x&lt;/span&gt;,14) = &lt;span&gt;$port&lt;/span&gt;
        
        &lt;span&gt;$x&lt;/span&gt;++&lt;span&gt;
      }
 } 
&lt;/span&gt;&lt;span&gt;$range&lt;/span&gt; = &lt;span&gt;$sheet&lt;/span&gt;&lt;span&gt;.usedRange
&lt;/span&gt;&lt;span&gt;$range&lt;/span&gt;.EntireColumn.AutoFit() | out-&lt;span&gt;null

&lt;/span&gt;&lt;span&gt;$uri&lt;/span&gt;=&lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.VM.OSVirtualHardDisk.MediaLink.AbsoluteUri
&lt;/span&gt;&lt;span&gt;$location&lt;/span&gt;=Get-AzureDisk | Where-Object {&lt;span&gt;$_&lt;/span&gt;.MediaLink &lt;span&gt;-eq&lt;/span&gt; &lt;span&gt;$uri&lt;/span&gt;}| Select-Object Location
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出项及格式见下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1219679/201802/1219679-20180201005347500-1162287247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;1.运行脚本期间可能会出现如下报错，忽略即可，不影响最终的结果统计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1219679/201802/1219679-20180201005858828-155163546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.该脚本运行前，需要事先定义好订阅&lt;/p&gt;
&lt;p&gt;3.该脚本输出的为一个Excel表格，输出期间不要关闭正在运行的Excel&lt;/p&gt;
&lt;p&gt;4.如果需要对指定Azure账号下的所有订阅进行统计，可参考如下脚本的遍历订阅方法，参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/tomholl/2016/11/22/dumping-details-of-azure-virtual-machines-to-csvexcel/&quot;&gt;https://blogs.msdn.microsoft.com/tomholl/2016/11/22/dumping-details-of-azure-virtual-machines-to-csvexcel/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;param&lt;/span&gt;&lt;span&gt;(
    [string]&lt;/span&gt;&lt;span&gt;$tenantId&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
    [string]&lt;/span&gt;&lt;span&gt;$file&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Azure-ARM-VMs.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
) 

Add&lt;/span&gt;-AzureRmAccount -&lt;span&gt;EnvironmentName AzureChinaCloud

Get&lt;/span&gt;-&lt;span&gt;AzureRmSubscription
&lt;/span&gt;&lt;span&gt;$vmobjs&lt;/span&gt; = @&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$sub&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$subs&lt;/span&gt;&lt;span&gt;)
{
    
    Write&lt;/span&gt;-Host Processing subscription &lt;span&gt;$sub&lt;/span&gt;&lt;span&gt;.SubscriptionName

    try
    {

        Select&lt;/span&gt;-AzureRmSubscription -SubscriptionId &lt;span&gt;$sub&lt;/span&gt;.SubscriptionId -ErrorAction &lt;span&gt;Continue&lt;/span&gt;

        &lt;span&gt;$vms&lt;/span&gt; = Get-&lt;span&gt;AzureRmVm 

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$vm&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$vms&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;$vmInfo&lt;/span&gt; = [pscustomobject]@&lt;span&gt;{
                'Subscription'&lt;/span&gt;=&lt;span&gt;$sub&lt;/span&gt;&lt;span&gt;.SubscriptionName
                'Mode'&lt;/span&gt;=&lt;span&gt;'ARM'
                'Name'&lt;/span&gt;=&lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.Name
                'ResourceGroupName' &lt;/span&gt;= &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.ResourceGroupName
                'Location' &lt;/span&gt;= &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.Location
                'VMSize' &lt;/span&gt;= &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.HardwareProfile.VMSize
                'Status' &lt;/span&gt;= &lt;span&gt;$null&lt;/span&gt;&lt;span&gt;
                'AvailabilitySet' &lt;/span&gt;= &lt;span&gt;$vm&lt;/span&gt;&lt;span&gt;.AvailabilitySetReference.Id }
        
            &lt;/span&gt;&lt;span&gt;$vmStatus&lt;/span&gt; = &lt;span&gt;$vm&lt;/span&gt; | Get-AzureRmVM -&lt;span&gt;Status
            &lt;/span&gt;&lt;span&gt;$vmInfo&lt;/span&gt;.Status = &lt;span&gt;$vmStatus&lt;/span&gt;.Statuses[1&lt;span&gt;].DisplayStatus

            &lt;/span&gt;&lt;span&gt;$vmobjs&lt;/span&gt; += &lt;span&gt;$vmInfo&lt;/span&gt;&lt;span&gt;

        }  
    }
    catch
    {
        Write&lt;/span&gt;-Host &lt;span&gt;$error&lt;/span&gt;[0&lt;span&gt;]
    }
}

&lt;/span&gt;&lt;span&gt;$vmobjs&lt;/span&gt; | Export-Csv -NoTypeInformation -Path &lt;span&gt;$file&lt;/span&gt;&lt;span&gt;
Write&lt;/span&gt;-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VM list written to $file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 31 Jan 2018 16:56:00 +0000</pubDate>
<dc:creator>铭的随记</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stonehe/p/8395959.html</dc:identifier>
</item>
<item>
<title>64位内核第一讲,和32位内核的区别 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8395870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8395870.html</guid>
<description>

&lt;p&gt;双击调试配置请查看 连接: &lt;a href=&quot;https://www.cnblogs.com/aliflycoris/p/5877323.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/aliflycoris/p/5877323.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一丶编译的区别.&lt;/h2&gt;
&lt;p&gt;首先,还是使用WDK7.1.7600编写. 但是编译的时候,要使用x64来编译. 其代码框架不变.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180131222708203-1530326138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.驱动加载&lt;/h3&gt;
&lt;p&gt;　　驱动加载的程序还是使用普通的驱动加载即可.但是64位(win7),微软推出了两种新的方式.&lt;/p&gt;
&lt;p&gt;1.DSE&lt;/p&gt;
&lt;p&gt;2.KPP&lt;/p&gt;
&lt;p&gt;　　DSE: 这个机制是 驱动强制签名,也就是说你编写的驱动,都要进行签名.才可以加载.&lt;/p&gt;
&lt;p&gt;　　KPP: 内核补丁保护, 比如我们说的SSDT表,(ring3 -&amp;gt; ring0 中专表)在XP下是可以HOOK的,现在,这些都被保护了,只要你更改了系统的核心源码,直接蓝屏.&lt;/p&gt;
&lt;h3&gt;2.去掉KPP保护.&lt;/h3&gt;
&lt;p&gt;在编写的64为内核驱动, 如果我们的系统是安全模式启动,则没有DSE保护.也就是说不用签名.&lt;/p&gt;
&lt;p&gt;现在有工具可以直接去使用.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180131223912796-546285118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个选项是,点击之后,你的系统启动则是在安全模式启动.&lt;/p&gt;
&lt;p&gt;第二个选项是, 点击之后,你的驱动可以添加一个测试签名.&lt;/p&gt;

&lt;h3&gt;3.注意的问题&lt;/h3&gt;
&lt;p&gt;如果进行了上面来了两个步骤,我们的驱动还是不能加载,那么这也是一个坑. 微软说了,在PE文件中,你的驱动必须有签名检查.&lt;/p&gt;
&lt;p&gt;正确的姿势:&lt;/p&gt;
&lt;p&gt;　　首先,编写驱动的source文件加上命令行选项.&lt;/p&gt;
&lt;p&gt;　　LINKER_FLAGS = /INTEGRITYCHECK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180131224352453-1316355014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;且必须放在最下面, 加了这个选项,那么你的驱动,可以使用微软提供的HOOK函数了.&lt;/p&gt;

&lt;h2&gt;二丶64位GDT表&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201802/1197364-20180201001518562-1371856723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 首先,地址变大了,变成了48位的地址,其高位是FFFF,属于是符号扩展.&lt;/p&gt;
&lt;p&gt;IDT 也是变大了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201802/1197364-20180201004245500-65282468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其内核中的结构体也变大了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201802/1197364-20180201004319468-869947059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不光这个结构体,还有里面的,有兴趣的自己解析一下查看.&lt;/p&gt;
&lt;h2&gt;三丶SSDT表的寻找,以及SSDT加密&lt;/h2&gt;
&lt;p&gt;我们知道 ring3 -&amp;gt; ring0 会通过SSDT表进行中专,&lt;/p&gt;
&lt;p&gt;其EIP 会存放在 msr寄存器中.  xp下是174 175 176&lt;/p&gt;
&lt;p&gt;现在查看AMD的CPU指令,会发现. 进0环会调用SystemCall命令.&lt;/p&gt;
&lt;p&gt;其MSR寄存器是在 C000081  C000082 C000083&lt;/p&gt;
&lt;p&gt;其EIP会存放在82里面.&lt;/p&gt;
&lt;p&gt;那么我们可以 使用指令.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rdmsr&lt;/span&gt; C00082
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读取三环进0环的地址. 对其解析.&lt;/p&gt;

&lt;p&gt;因符号文件没有下载完全.所以还暂时没有办法解析.&lt;/p&gt;
&lt;p&gt;SSDT加密算法是 模块首地址 + 当前表中的地址&amp;gt;&amp;gt;4  .我们要计算地址的时候.只需要将SSDT表中的内容的函数地址&amp;lt;&amp;lt;4位加上模块首地址即可.&lt;/p&gt;

</description>
<pubDate>Wed, 31 Jan 2018 16:47:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8395870.html</dc:identifier>
</item>
<item>
<title>九宫格（原生） - MS-LY</title>
<link>http://www.cnblogs.com/MaShuai666/p/8395638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaShuai666/p/8395638.html</guid>
<description>&lt;p&gt;相信很多初学者，对九宫格也有所疑惑，那么本次分享就对初学者进行解惑！&lt;/p&gt;

&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;9&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            * &lt;/span&gt;{&lt;span&gt;
                margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
                padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
            }&lt;span&gt;
            html &lt;/span&gt;{&lt;span&gt;
                overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
            }&lt;span&gt;
            ul &lt;/span&gt;{&lt;span&gt;
                list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
            }&lt;span&gt;
            #box &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
                margin&lt;/span&gt;:&lt;span&gt; 20px auto&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 640px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 640px&lt;/span&gt;;&lt;span&gt;
                border&lt;/span&gt;:&lt;span&gt; 1px solid #eee&lt;/span&gt;;
            }&lt;span&gt;
            #box li &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                line-height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
                font-size&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
                font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;&lt;span&gt;
                background&lt;/span&gt;:&lt;span&gt; #eee&lt;/span&gt;;
            }&lt;span&gt;
            #box .active &lt;/span&gt;{&lt;span&gt;
                z-index&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
                color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
                background&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS代码&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1、先布局（找规律），然后用JS利用定位实现布局&lt;/p&gt;
&lt;p&gt;2、拖拽原理（onmousedown,onmousemove,onmouseup）　&lt;/p&gt;
&lt;p&gt;3、拖拽的过程，物体的offsetLeft和offsetTop一直在变化&lt;/p&gt;
&lt;p&gt;4、俩个物体交换的时候需要达到一定的条件，并且要交换下标。&lt;/p&gt;
&lt;p&gt;5、一个函数中的this在其他函数中使用会影响，所以可定义that(自定义)，将this赋值给that，然后使用that。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oBox = document.getElementById('box'&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aLi  =&lt;span&gt; oBox.children;

                
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; aLi.length; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 布局&lt;/span&gt;
                    aLi[i].style.left = 210 * (i % 3) + 10 + 'px'&lt;span&gt;;
                    aLi[i].style.top  &lt;/span&gt;= 210 * Math.floor(i / 3) + 10 + 'px'&lt;span&gt;;


                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加拖拽功能&lt;/span&gt;
                    aLi[i].index =&lt;span&gt; i;
                    aLi[i].onmousedown &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = ev ||&lt;span&gt; window.event;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iX = e.clientX - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offsetLeft;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iY = e.clientY - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offsetTop;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setCapture) {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setCapture();
                        }
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oThat = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加class名称&lt;/span&gt;
                        &lt;span&gt;this&lt;/span&gt;.className = 'active'&lt;span&gt;;
                        document.onmousemove &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = ev ||&lt;span&gt; window.event;
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iL = e.clientX -&lt;span&gt; iX;
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iT = e.clientY -&lt;span&gt; iY;

                            oThat.style.left &lt;/span&gt;= iL + 'px'&lt;span&gt;;
                            oThat.style.top  &lt;/span&gt;= iT + 'px'&lt;span&gt;;



                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换位置的条件&lt;/span&gt;
                            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; aLi.length; j++&lt;span&gt;) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(
                                        oThat &lt;/span&gt;!=&lt;span&gt; aLi[j]
                                    &lt;/span&gt;&amp;amp;&amp;amp;  oThat.offsetLeft + oThat.offsetWidth &amp;gt; aLi[j].offsetLeft + aLi[j].offsetWidth / 2
                                    &amp;amp;&amp;amp;  oThat.offsetTop + oThat.offsetHeight &amp;gt; aLi[j].offsetTop + aLi[j].offsetHeight / 2
                                    &amp;amp;&amp;amp;  oThat.offsetLeft &amp;lt; aLi[j].offsetLeft + aLi[j].offsetWidth / 2
                                    &amp;amp;&amp;amp;  oThat.offsetTop &amp;lt; aLi[j].offsetTop + aLi[j].offsetHeight / 2&lt;span&gt;
                                ) {
                                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iCurIndex =&lt;span&gt; oThat.index;
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换位置&lt;/span&gt;
                                    aLi[j].style.left = 210 * (iCurIndex % 3) + 10 + 'px'&lt;span&gt;;
                                    aLi[j].style.top  &lt;/span&gt;= 210 * Math.floor(iCurIndex / 3) + 10 + 'px'&lt;span&gt;;
                                    aLi[j].style.transform &lt;/span&gt;= 'rotate(360deg)'&lt;span&gt;;

                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换下标&lt;/span&gt;
                                    oThat.index =&lt;span&gt; aLi[j].index;
                                    aLi[j].index &lt;/span&gt;=&lt;span&gt; iCurIndex;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                }
                            }
                        };
                        document.onmouseup &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                            document.onmousemove &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            document.onmouseup &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(oThat.releaseCapture) {
                                oThat.releaseCapture();
                            }

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去掉class名称&lt;/span&gt;
                            oThat.className = ''&lt;span&gt;;

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置当前拖拽元素的位置&lt;/span&gt;
                            oThat.style.left = 210 * (oThat.index % 3) + 10 + 'px'&lt;span&gt;;
                            oThat.style.top  &lt;/span&gt;= 210 * Math.floor(oThat.index / 3) + 10 + 'px'&lt;span&gt;;
                        };

                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    };
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 31 Jan 2018 16:16:00 +0000</pubDate>
<dc:creator>MS-LY</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MaShuai666/p/8395638.html</dc:identifier>
</item>
<item>
<title>浅析final关键字 - 孫先森</title>
<link>http://www.cnblogs.com/STDBK/p/8395475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/STDBK/p/8395475.html</guid>
<description>&lt;p&gt;final单词字面意思是“最终的，不可更改的”。所以在java中final关键字表示终态，即最终的状态，“这个东西不能被改变”。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;final关键字可以用来修饰类、方法、数据(包括成员变量、局部变量与方法参数)。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;(1)final类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;final关键字修饰的类是不能被继承的。在这里插入一些个人想法，当一个类被修饰为final时，代表它无法被继承，即不能被扩展，所以从设计的角度来考虑，自己写的类一般不要修饰为final；而对于辅助性的类为了不让外部破坏内部数据，可以修饰为final，这些只是个人想法，如果有错，望指正！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;(2)final方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　final关键字修饰的方法不能被重写。可能会使用final方法的两个原因：一是给方法”上锁”，防止继承类修改它；二是程序执行效率考虑，编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;(3)final成员变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;当final关键字修饰成员变量时，表示该成员变量只能进行一次赋值操作，并且在生存期内不可以改变它的值。final成员变量必须在声明时进行初始化或者在构造器中进行初始化，否则编译器会报错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;(4)final局部变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　final修饰局部变量时只能初始化(赋值)一次，并且在生存期内不可以改变它的值。与成员变量不同，final局部变量在声明时可以不初始化，只需要保证在使用之前初始化赋值即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;(5)final参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;当final关键字修饰参数时比较复杂，final修饰方法参数时，是在调用方法传递参数时候初始化的。参数被声明为final，若是基本参数，那它就是一个常量，在调用方法传递参数后不能被修改；若是一个引用变量，那么它在调用方法传递参数后就不能被修改指向另一个对象，但可以修改该引用所指对象的内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;(1)如果一个类被修饰为final，结果只是禁止继承，没有更多的限制。所以其数据成员可以是final的，也可以不是，取决于我们的具体选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)final类中的所有方法被默认为final方法，如果一个类不能被继承，则其内部的方法不会被重写，所以编译器默认final类中的方法是final方法(final类中的方法你添加final修饰符不会增加任何效果。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;想一想：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在创建一个类时，可以同时用final关键字与abstract关键字修饰吗？&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 31 Jan 2018 15:54:00 +0000</pubDate>
<dc:creator>孫先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/STDBK/p/8395475.html</dc:identifier>
</item>
<item>
<title>JavaScript ES6 module 模块 - 方木一</title>
<link>http://www.cnblogs.com/polk6/p/js-ES6-module.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/polk6/p/js-ES6-module.html</guid>
<description>&lt;p&gt;在使用JavaScript开发大型项目时，模块开发概念是一个必须考虑的问题。其目的就是通过命名空间对各类业务对象进行一定的封装，防止命名冲突。&lt;/p&gt;
&lt;p&gt;本篇着重介绍ES6 module中的export和import概念。&lt;/p&gt;


&lt;p&gt;在ES6之前，JavaScript本身没有模块支持，但社区创造了令人印象深刻的解决方案。两个最重要的（也是不相容的）标准是：&lt;strong&gt;AMD&lt;/strong&gt; 和 &lt;strong&gt;CommonJS&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;1.1 AMD&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：AMD，全称为Asynchronous Module Definition，即异步模块定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：其模块和依赖都可以进行异步加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 定义AMD模块
define('User/UserGrid', // 模块ID
    ['UserM'], // 依赖文件
    function(userM) { // 初始化函数，依赖文件以参数形式加入
    }
);

// 使用AMD模块
require(['User/UserGrid'],
    function(userGrid) {
    }
);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.2 CommonJS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：CommonJS模块规范初衷是用于node.js服务器端，以提供额外的功能，如：IO、文件系统等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;①同步加载；只有加载完成，才能执行后面的操作。&lt;/p&gt;
&lt;p&gt;②缓存加载；第一次加载时会把内容存入缓存，以后的加载都是从缓存获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js(定义模块)
exports.add = function(a, b) {
    return a + b;
};

// app.js(使用模块)
var math = require('./math');

var rs = math.add(1, 2);
console.log(rs);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解更多AMD 与 CommonJS 知识可参考此文章：&lt;a href=&quot;https://addyosmani.com/writing-modular-js/&quot; target=&quot;_blank&quot;&gt;Writing Modular JavaScript With AMD, CommonJS &amp;amp; ES Harmony&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;ES6 module 结合了CommonJS和AMD的优点：类似CommonJS，具有简洁的语法，对循环依赖的支持；类似AMD，支持异步加载和有条件的模块加载。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ES6 module 使用 export 导出模块的内容，并使用 import 导入模块的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.1 浏览器原声支持&lt;/h2&gt;
&lt;p&gt;使用之前，先看下各浏览器对原生ES6 module的支持情况：Chrome61及61+、Edge16及16+版本都已支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/153475/201801/153475-20180105151759815-580610057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用方式：&lt;/h3&gt;
&lt;p&gt;以Chrome为例，在引入ES6 module 的JS文件时，使用属性 type=&quot;module&quot; 即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script type=&quot;module&quot; src=&quot;js/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;module&quot; src=&quot;js/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.2 export 导出（定义模块）&lt;/h2&gt;
&lt;p&gt;创建ES6模块时，可使用&lt;strong&gt;export&lt;/strong&gt;关键字导出(对外提供)模块的内容，如函数、对象以及原始变量等等。&lt;/p&gt;
&lt;p&gt;export 导出方案有2种：Named exports（命名导出；每个模块可有多个）和 Default exports（默认导出；每个模块只能一个）。&lt;/p&gt;
&lt;h3&gt;1) Named exports 命名导出&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：使用&lt;span&gt;&lt;strong&gt; export + 名称 &lt;/strong&gt;&lt;/span&gt;的形式导出模块的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在 import 导入过程中，需指定这些名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 1)声明时导出
export var myVar1 = 'a';
export let myVar2 = 'b';
export const MY_CONST = 'c';
export function myFunc() {}

// 2)声明后导出
var myVar3 = 'a';
export { myVar3 };

// 3)别名导出
var myVar4 = 'a';
export { myVar4 as myVar };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js
export function add(a, b) {
    return a + b;
}

// app.js：导入含有命名导出的模块时，需要指定成员名称
import { add } from './math.js';
console.log(add(1, 2)); // =&amp;gt; 3

// demo.html
&amp;lt;script type=&quot;module&quot; src=&quot;js/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;module&quot; src=&quot;js/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2) Default exports 默认导出&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：使用 &lt;span&gt;&lt;strong&gt;&lt;span&gt;export default&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 导出模块默认的内容，每个模块只能有一个 export default。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 1)声明时导出
export default expression;
export default function () {}

// 2)别名设置为default导出
export default function name1() {}
export { name1 as default };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：默认导出声明的是一个表达式，通常没有名字，导入时需指定模块名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js
export function add(a, b) {
    return a + b;
}
export default function cube(x) {
    return x * x * x;
}

// app.js：导入默认导出的模块时，需要指定模块名称
import cube from './math.js';
console.log(cube(3)); // =&amp;gt; 27
// 若想同时导入含有默认导出、命名导出的模块，只需要导入时用','隔开
// import cube, { add } from './math.js';

// demo.html
&amp;lt;script type=&quot;module&quot; src=&quot;js/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;module&quot; src=&quot;js/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.3 import 导入模块&lt;/h2&gt;
&lt;p&gt;使用 import 可导入创建的模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 1)导入模块的默认导出内容
import defaultExport from 'module-name';

// 2)导入模块的命名导出内容
import { export1, export2 } from 'module-name';
import { export as alias } from 'module-name'; // 修改别名
import * as name from 'module-name'; // 导入模块内的所有命名导出内容

// 3)导入模块的默认导出、命名导出
import defaultExport, { export1, export2 } from 'module-name';
import defaultExport, * as name from 'module-name';
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1) 导入默认导出&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：导入默认导出的模块时，需要指定模块名称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js
export default function cube(x) {
    return x * x * x;
}

// app.js：导入默认导出的模块时，需要指定模块名称
import cube from './math.js';
console.log(cube(3)); // =&amp;gt; 27
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2) 导入命名导出&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：导入模块时可使用&lt;strong&gt;&lt;span&gt;大括号包含指定命名成员&lt;/span&gt;&lt;/strong&gt;；也可以用  &lt;span&gt;&lt;strong&gt;* as moduleName&lt;/strong&gt;&lt;/span&gt; 的形式把此模块的所有命名导出作为某个对象的成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js
export function add(a, b) {
    return a + b;
}

// app.js：指定使用math模块的add命名导出
import { add } from './math.js';
console.log(add(1, 2)); // =&amp;gt; 3

// 导入所有的命名导出为math对象的成员
import * as math from './math.js'; console.log(math.add(1, 2)); // =&amp;gt; 27
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3) 仅导入模块&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：仅导入模块时，只会执行模块的全局函数，不会导入任何成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// math.js
export function add(a, b) {
    return a + b;
}
(function() {
    console.log('hello math.js');
})();

// app.js
import { add } from './math.js'; // =&amp;gt; hello math.js
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ECMAScript 6 modules: the final syntax ：&lt;a href=&quot;http://2ality.com/2014/09/es6-modules-final.html%20&quot; target=&quot;_blank&quot;&gt;http://2ality.com/2014/09/es6-modules-final.html &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MDN export ：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MDN import：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 31 Jan 2018 15:49:00 +0000</pubDate>
<dc:creator>方木一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/polk6/p/js-ES6-module.html</dc:identifier>
</item>
<item>
<title>浅谈Android进阶之路 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/8395424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/8395424.html</guid>
<description>&lt;p&gt;过去十年是移动互联网蓬勃发展的黄金期，相信每个人也都享受到了移动互联网红利，在此期间，移动互联网经历了曙光期、成长期、成熟期、现在来说已经进入饱和期。依然记得在 2010-2013 年期间，从事移动开发工作不知有多火，有工作 1-2 年经验的开发者薪资基本是上万，对招的人专业素质要求也不高，入门即可。从 2016 年底至今来看，局面而是另外一番景象，移动开发市场过度饱和，市场上充斥着太多初级开发者，网上一直流传着移动互联网的寒冬，很多开发者找工作都没以前好找，一些岗位常常面临着百里挑一景象，没有个三五年经验，现在 HR 都是刷刷的翻过。&lt;/p&gt;
&lt;p&gt;那么不禁要反问一句，现在从事移动开发，无论是 Android 还是 IOS，未来还有发展空间吗？还有随着移动开发越来越向大前端靠拢，甚至原本一些属于原生开发者的岗位也被前端开发人员胜任，想想在本来拥挤的房间里，还要分割本来属于自己那么点空间给他人用，变得更拥挤了，那滋味肯定是不好受了，那么未来我们的容身之地又在哪里呢？&lt;/p&gt;
&lt;p&gt;笔者是从 2013 年底开始从事移动开发，刚毕业那么还是从事服务端开发，写着&lt;strong&gt;.NET&lt;/strong&gt; 技术栈代码，至今也有接近 5 年的经验了。我想说，如果仅仅停留在表面的框架上，仅仅停留在使用别人的轮子上，而对于里面实现机制和原理不求甚解的话，那是很容易被淘汰的。但是如果，在移动开发上有一门深度的技能，比如在 Android 中你对移动架构有一定独特的见解，在性能优化上有一定的造诣，对于Android 系统体系有着清晰的认知，并且在一个行业积累了丰富的行业经验，也是亮点所在，那基本就是属于吃香的类型了。所以简单来说，对于一个概念不能停留在使用层面，要深入研究里面构造如何，为何会有这么一个概念，如果没有这个概念，那又会是呈现什么样的局面呢？开发编程也是一样，要追寻的是编程的道，而不是编程的术，别看现在各种流行框架大行其道，要是深入研究下去，一层一层拨开，你也会惊讶里面的实现机制无外乎就那么几种，套来套去，只不过一些开源库作者或组织封装的好而已。&lt;/p&gt;
&lt;p&gt;基于目前市场表现，我们都知道下一个风口是 AI，但是作为一个移动开发者如何在即将来临的 AI 时代吃口红利呢。我的回答是：致力于做一个终身学习者，追本溯源去探寻代码世界哪些不变的道，你又会说了，哪些是道呢，简单举例下，比如编程思想、常用的设计模式、设计原则、算法和数据结构、网络通信机制、操作系统、重构原则、架构思维等等。同时在目前发展情形下，也越来越趋向全栈工程师的路线，借用之前在网上看到一篇文章的图，想进阶全栈工程师之路看需要哪些技能，如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-3714518fd821854b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;全栈工程师技能&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到技能被分成基础软技能、技术软硬技能，不仅要熟悉移动端开发套路，还要对大前端技术栈也有一定要掌握，同时对于服务端开发流程也要了解，我们很多从事移动开发人员，基本一开始就是从移动端入手，对于服务端开发很多时候是没有概念，这些跟那种从服务端开发转型做移动开发相比起来就处于一定的劣势了，有些甚至不知道 Restful 是什么，还以为是一种框架呢，其实这仅仅只是服务端约定好的接口编码风格而已。&lt;/p&gt;
&lt;h3 id=&quot;进阶之路&quot;&gt;进阶之路&lt;/h3&gt;
&lt;p&gt;为何会想起写这么一篇文章呢，一方面这几天工作需要，组内正好想规划 2018 年 Android 技术路线，简单来说就是目前我们组处在什么样的水平程度，目前所做项目用的技术处在什么阶段，在未来一年内，项目技术迭代该如何走，走到什么程度。另一方面是从事 Android 开发这几年，一直也没好好规划自己的技术路线，想认真整理下未来进阶之路。我们都知道 Android 技术体系一直很庞大，刚开始学的时候基本是从一个点一个点开始，没有系统全局观概念，同时也是学不过来，从做上层应用开始，到做 Framework 层，然后再到系统层做驱动开发各个层面的开发者都有，绝大部分开发者都是从应用层开发，往往做到 Framework 层就浅尝辄止了，一直以来，做Android 开发有这么两个说法，如果是做应用开发，往应用架构方向发展比较合适，如果是做系统层开发，往往底层驱动比较合适。&lt;/p&gt;
&lt;p&gt;看张图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-fc8c899c6451efc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Android高级进阶&quot;/&gt;&lt;/p&gt;
&lt;p&gt;挑些图中几个点简单来谈谈自己的一些想法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;移动架构是 2017 移动技术年度TOP5话题之一，从中就体会到架构是有多火，记得刚开始学 Android 时候，哪有现在那么框架，那时候谈架构的更多是在服务端开发，比如多层架构，有展示层、业务逻辑层、数据访问层这就是最简单的三层模式，Android系统则是基于事件驱动响应机制设计的单页面架构，其实跟浏览器中的窗口页面是一样的， 系统中一直有个消息轮询监听机制，哪个事件被触发了，相应的响应代码进行处理，这些处理操作是被提前注册到系统中。&lt;/p&gt;
&lt;p&gt;最早开始的开发模式基本是基于Android 系统自带 MVC 模式，Activity 基本类似于Control 的作用了，View 和Mode 互相耦合，后来才演化出现在主流的 MVP、MVVM 模式，顺便提一句，MVVM 模式其实是在微软 WPF 技术体系中提出来。&lt;/p&gt;
&lt;p&gt;图中显示两个方面：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;展示层： MVC、MVP、MVVM、Clean、Flux、Android Architecture Components&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;架构层：模块化-&amp;gt;组件化-&amp;gt;插件化-&amp;gt;沙盒/双开技术，比如可以双开微信，类似Docker， 每个页面都是插件，类似Vue.js中每个页面都是组件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说，一个APP 是需要从三个方面被关注的，业务功能、符合逻辑的交互、性能响应。如果我们在使用一个 APP 时候，经常滑动时经常卡顿、时不时崩溃、有些功能设计简直非常规，比如在 Web 网站有树层级等面包屑点击，你非要在手机也搞一个类似树级点击加载，那是不是有点强人所难了，我上拉下拉、左滑右滑不行吗，非要通过点击才行吗？那么性能优化核心是什么呢？追求快、稳、省、小，关注卡顿、内存泄漏和崩溃、代码质量和逻辑、安装包大小四个方面。想进一步的了解的话，可以查阅下笔者这篇文章《&lt;a href=&quot;https://www.jianshu.com/p/9755da0f4e8f&quot;&gt;Android APP 性能优化的一些思考&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;APP安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;APP从代码安全、到传输安全，再到存储安全。代码可以通过混淆、加固来保证、传输安全基本基于加密算法和Token来保证传输的唯一性、存储应用不可逆加密算法进行设置、所以掌握一些密码学理论尤为重要，起码要知道哈希散列算法，对称加密和非对称加密等一些常见的加密算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础进阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们平常在工作中碰到的View滑动冲突问题、其实通过掌握View工作机制和Android触摸事件体系就能轻易解决掉，常见解决方式有外部拦截法和内部拦截法，基于横坐标滑动距离与纵坐标滑动距离相减得出的值，判断出是左右滑动还是上下滑动。还有对于需要开发绚丽的动画效果，那么对于视图动画和属性动画一些特性必须有一定的了解。JNI 和 NDK 开发也是比较常见，特别对于一些做 SDK 项目为主的，这一块开发流程也是需要掌握，Android 中的四大组件工作机制其实底层应用的是Binder机制，我们不妨从 AIDL 这个接口来了解 Binder。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续集成编译环境是敏捷开发中很重要的一个组成部分，它能够有效地提高整个团队的生产效率，最大化的减少人为的出错的可能。比如，通过代码的持续提交，可以减少代码合并的痛苦，更快地与其他人代码集成，通过集成编译，能够及早地发现代码库存在的错误，并支持产品、测试等人员及时取包进行功能验证，所以对于Git、Gradle工具、Jenkins服务器需要掌握起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今年可以说是 Kotlin 年，在 Google IO 之后 Kotlin 着实风光了一把，开发者对于效率的追求是 Kotlin 如此受欢迎的最大原因，而它的势头也很不错，跨平台的野心让更多人有了使用它的理由，如今看起来，它甚至比 Swift 更有前途。既然 Kotlin 已然成为 Android 世界的头等公民，与 Java 完全兼容，我们有什么理由不去拥抱它呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大前端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实移动端开发也是属于前端开发，只不过原来我们所指的前端往往都是Web的前端开发人员，开发的是网站，而移动端何尝不是一种展示载体，同样有入口，只不过相比网站端移动端具体天然的可移动性、可便捷性等特性。随着 H5 兴起，原生能实现的功能同样在 H5 端也能实现，并且在体验性方面也逐渐提高，并且H5天生就具有动态性和跨平台，这也是 H5 能够一时潮流的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些设计原创才是本质，才是不变的，才是我们需要真正要掌握的，开发语言特性、开发框架发展实在是太快了，我们更不上，不是有这么一句话吗，封装具体变化的，抽象起来就行，去追寻哪些不变的内容。掌握一种设计模式其实也就掌握一种解决方案，这些都是前人总结的知识结晶，基本都是基于特定领域解决特定的问题，我们需要学会在前人肩膀上解决问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近微服务火的一塌糊涂，虽然我们基本是做移动端开发，但是基于全栈发展的趋势，对于服务端开发势必要了解，可能没有实战项目让你真刀真枪的干，但是对于微服务的结构理论、服务与服务之间通信、聚合是什么样的流程也是需要有所耳闻，在自己擅长领域深入专研的同时横向扩展关注也是需要的，不能关起门来闭门造车，两耳不闻窗外事那是不行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阅读源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于Android源码和第三方库源码阅读，可以根据自己感兴趣的类型，选择相应的源码库或模块，给自己约定一个时间点，看完之后最后有个流程图，哪些是核心类，类与类之间都有什么关系，这些开源代码实现的机制是什么，用到哪些解决思想，这些要点最终可以通过文章输出，我觉得输出倒逼输入是一种很不错的学习方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动AI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI，也称人工智能，1956年，在&lt;strong&gt;达特茅斯学院&lt;/strong&gt;举行的一次会议上正式确立了&lt;strong&gt;人工智能&lt;/strong&gt;的研究领域。会议的参加者在接下来的数十年间是AI研究的领军人物，他们中有许多人预言，经过一代人的努力，与人类具有同等智能水平的机器将会出现。现在来看AI这个概念很早就存在了，之前没发展很大原因是基础设施不够完善、研究成本高，现在能够大力发展是基于我们的网络带宽变大、计算机性能提升、计算成本降低等等因素备齐了。AI是需要通过算法来落地，那么对于算法理论背景就是数学，所以想进阶AI开发，就需要去学习相关数学知识，特别是线性代数和概率论这两门，是支撑很多算法的理论知识。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;总的来说，技术发展能推动社会的进步，解放生产力，进而提高人的社会生产效率，创造价值。技术落地是需要商业应用场景配合，如何配合呢，就是通过每个不同商业模式来实现。最终一门技术是需要与具体使用业务紧密结合起来，如果脱离技术谈业务显得空洞，脱离业务谈技术显得偏理论，最好是两者相结合。这也就要求我们这些从事软件开发人员在追求技术积累的同时要注重业务积累，让业务驱动技术发展，用技术手段来解决实际业务问题，在技术积累中，辨别哪些是不变的道，哪些又是一时流行的而已，这就需要练就一双火眼金睛了。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 15:39:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/8395424.html</dc:identifier>
</item>
<item>
<title>一道360 crackme的分析 - bamb00</title>
<link>http://www.cnblogs.com/goodhacker/p/8395240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodhacker/p/8395240.html</guid>
<description>&lt;p&gt;该crackme主要实现都在so中，用ida加载libqihoo.so，出现以下错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223042062-833108211.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223054578-2147384262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个错误说明是节区头部表格的表项大小错误，第二个错误是指节区头部表格的大小或偏移值错误。不管它，点击“Yes”继续加载。找到JNI_OnLoad函数，发现该函数已经加密：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223119031-1825627825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道so 文件加载时首先会查看 .init 或 .init_array 段是否存在，如果存在那么就先运行这段的内容，如果不存在的话那么就检查是否存在JNI_OnLoad，存在则执行。所以JNI_OnLoad的解密可能在 .init 或 .init_array 段中。&lt;br/&gt;因为 .init 或者 .init_array 在 IDA 动态调试的时候是不会显示出来的，所以需要静态分析出这两段的偏移量然后动态调试的时候计算出绝对位置，然后在 make code（快捷键：c），这样才可以看到该段内的代码内容。&lt;br/&gt;查看 .init_array 段的地址有两种办法：&lt;br/&gt;（1）.可以使用 IDA 加载 .so 文件，按ctrl+s快捷键查看 “Segments” 视图，这里会列出不同类型的代码段信息，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223138265-1580378770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）.可以使用二进制工具 readelf 来查看 .so 文件的结构，在 OS X 上面可以使用 greadelf 代替。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223151187-872765132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上述（1）可以看出，并没有显示该so的.init 或者 .init_array段，所以我们需要对该so进行修复。&lt;br/&gt;因为节区头部表的偏移值e_shoff为0x2118c(在0x20h处），所以根据ELF文件的结构，从该偏移值开始到文件结尾的数据为整个节区头部表。由于节区头部表项的大小（e_shentsize)固定为0x28，所以我们可以由:(0x214fb - 0x2118c + 1)/0x28 = 0x16 得出真正的节区头部表项数目(e_shnum)为0x16。&lt;br/&gt;下面再来看e_shstrndx字段，我们从ELF文件中可以明显地看出，字符串表节区为最后一个节区，所以它的索引值应当为0x15。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223211062-1552034277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上述规则将对应数值修改好后保存文件，然后再次加载修复后的so文件，已经不会报错了，按ctrl+s快捷键也可以查看到.init_array段信息了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223230984-520491704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDA 定位到.init_array段，可以看到.init_array段会执行__gnu_armfini_26函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223250671-161685888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该函数含义大量花指令，为了便于分析，我们在该函数下断点，对其进行动态调试。通过动态调试，我们会发现该so中花指令与真实指令的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223307109-1806545325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;__gnu_armfini_26函数清除花指令后的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BL __gnu_armfini_30
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R4, R0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R0, #0x28 &lt;span&gt;;&lt;/span&gt;&lt;span&gt; '('&lt;/span&gt;
BL sysconf &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 获取系统的cpu个数和可用的cpu个数&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R4, #0x8A00
BIC R0, R4, #0xFF0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R2, #&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BIC R0, R0, #0xF
BL __gnu_arm_fini_06
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R1, #0x8A00
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R4
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BL __gnu_armfini_29
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R4, #0x8A00
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R4
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BL sub_B6E37614&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中调用的__gnu_armfini_29函数比较可疑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224324765-159300300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;_arm_aeabi_6去掉花指令后是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;102&quot;&gt;
&lt;pre&gt;
&lt;span&gt;STMFD SP!, {R3-R8,R10,LR}
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R4, R0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R5, R1    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;0000000C&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R8, R2
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R3, #&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

:loc_B6EFDA74
STRB R3, [R8,R3]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;0x00 将r8开始的地址依次填充0-0x99&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R3, R3, #&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;0+1&lt;/span&gt;
&lt;span&gt;CMP&lt;/span&gt;&lt;span&gt; R3, #0x100
BNE loc_B6EFDA74
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R3, #&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R6, R3
STRB R3, [R8,#0x100]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8+#0x100地址处的内容置0&lt;/span&gt;
STRB R3, [R8,#0x101]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8+#0x101地址处的内容置0&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R7, R8
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt; R10, R8, #0x100    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8:BEF9C6F4, R10:BEF9C7F4&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R3

:loc_B6EFD914
LDRB R2, [R4,R0]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;r2=0x96,0xE6,0x57&lt;/span&gt;
LDRB R3, [R7]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R3=0x00, R3=0xC2,0x00&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R0, R0, #&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r0=0x01, 0x02, 0x03&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt; R1, R5    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R1=R5=0x0C&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R2, R2, R3    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R2 = R2+R3=0xC6+0x00, R2 = R2+R3=0x96+0xC2=0x158, R2 = R2+R3=0xE6+0x00=0xE6&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R6, R2, R6    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R6 = R2+R6=0xC6+0x00, R6 = R2+R6=0x158+0xC6=0x21E, R6 = R2+R6=0xE6+0x01E=0x104&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; R6, R6, #0xFF    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R6 = 0xC6, 0x01E, 0x004&lt;/span&gt;
LDRB R2, [R8,R6]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r2=0x00, 0xEF, 0xE9&lt;/span&gt;
STRB R2, [R7],#&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;STR R0，[R1], #8 将R0中的字数据写入以R1为地址的存储器 中，并将新地址R1＋8写入R1。&lt;/span&gt;
STRB R3, [R8,R6]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r3=0x00, 0xC2, 0x00&lt;/span&gt;
BL __aeabi_idivmod    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;执行完后r1=r0=0x01,0x02,0x03&lt;/span&gt;
&lt;span&gt;CMP&lt;/span&gt; R7, R10    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r7=0xC2,r10=0x00 &lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; R0, R1, #0xFF    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r0:0x01&lt;/span&gt;
&lt;span&gt;BNE loc_B6EFD914
LDMFD SP!, {R3-R8,R10,PC}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这实际上就是RC4算法的第一个步骤（参考：https://www.jianshu.com/p/fcfdcc3ff9d5）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/*&lt;br/&gt;初始化状态向量S和临时向量T，供keyStream方法调用&lt;br/&gt;*/&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; initial() { 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;256&lt;/span&gt;;++&lt;span&gt;i){ 
        S[i]&lt;/span&gt;=&lt;span&gt;i; 
        T[i]&lt;/span&gt;=K[i%&lt;span&gt;keylen]; 
    } 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;_gnu_arm_message函数具有rc4算法的典型特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224418546-1359129603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;_gnu_armfini_29这个函数解密从0x75EEC6DC地址开始，大小为0x8AEC内存区域的数据，实际上是对地址为“基址0x75ED5000+0x176dc”，大小为0x8AEC的内存区域数据进行解密。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224433218-128421651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224447656-1300969751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解密完毕后将该so dump下来，dump的起始地址及大小可以通过ida的Modules菜单获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224503218-438379998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dump脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static main(void)
{
auto fp, begin, end, ptr;
fp &lt;/span&gt;= fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\\dump.so&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
begin &lt;/span&gt;= &lt;span&gt;0x75ED5000&lt;/span&gt;&lt;span&gt;;
end &lt;/span&gt;= begin + &lt;span&gt;0x23000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ptr = begin; ptr &amp;lt; end; ptr ++&lt;span&gt; )
fputc(Byte(ptr), fp);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;按快捷键“shift+F2”打开脚本编写窗口写入上述脚本代码，点击“Run&quot;运行该代码就可以在D盘根目录看到dump下来的so文件dump.so。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用IDA打开dump.so，定位到JNI_OnLoad函数，按“C”键，将数据转换成代码，按”F5“查看反编译的伪代码，按“Y”键修正变量类型，得到如下的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224541562-565658618.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们知道RegisterNatives的函数原型是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
jint RegisterNatives(jclass clazz, &lt;span&gt;const&lt;/span&gt; JNINativeMethod*&lt;span&gt; methods,jint nMethods)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二个参数是JNINativeMethod结构体&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
　　&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; name;
　　&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; signature;
　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; fnPtr;
} JNINativeMethod;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结构体的第三个参数是函数指针，该结构体的偏移地址为0x22004，定位到该偏移地址处发现没有正常把函数指针解析出来，需要进一步调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224647218-440124959.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;重新打开libqihoo.so，在 __gnu_armfini_29函数处下断点，进行动态调试。按F9运行到这里后，函数会进行内存区块解密，解密完成之后，在Modules菜单中找到libqihoo.so，点开，我们就可以看到“verify”和“JNI_OnLoad”函数了，分别下断点（注意，一定要在解密完之后，即执行完__gnu_arm_message函数后再下断点），如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224703718-1769979765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再按F9就来到了JNI_OnLoad函数处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224721015-1299614566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定位到JNINativeMethod结构体地址，从ida中我们可以看到该结构体函数指针指向verify函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224733453-1638684610.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;继续F9，执行到verify函数。&lt;br/&gt;在verify函数中调用了__gnu_Unwind_8和__gnu_Unwind_6函数。&lt;br/&gt;__gnu_Unwind_8函数的作用是将jstring转换成为c/c++中的char*&lt;br/&gt;从java程序中传过去的String对象在本地方法中对应的是jstring类型，jstring类型和c中的char*不同，所以如果你直接当做char*使用的话，就会出错。因此在使用之前需要将jstring转换成为c/c++中的char*，这里使用JNIEnv提供的方法转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; java jstring turn to c/c++ char* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;char&lt;/span&gt;* jstringToChar(JNIEnv*&lt;span&gt; env, jstring jstr)
{ 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* pStr =&lt;span&gt; NULL;
    jclass jstrObj &lt;/span&gt;= (*env)-&amp;gt;FindClass(env, &quot;java/lang/String&quot;&lt;span&gt;);
    jstring encode &lt;/span&gt;= (*env)-&amp;gt;NewStringUTF(env, &quot;utf-8&quot;&lt;span&gt;);
    jmethodID methodId &lt;/span&gt;= (*env)-&amp;gt;GetMethodID(env, jstrObj, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;&lt;span&gt;);
    jbyteArray byteArray &lt;/span&gt;= (jbyteArray)(*env)-&amp;gt;&lt;span&gt;CallObjectMethod(env, jstr, methodId, encode);
    jsize strLen &lt;/span&gt;= (*env)-&amp;gt;&lt;span&gt;GetArrayLength(env, byteArray);
    jbyte &lt;/span&gt;*jBuf = (*env)-&amp;gt;&lt;span&gt;GetByteArrayElements(env, byteArray, JNI_FALSE);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jBuf &amp;gt; 0&lt;span&gt;)
    {
        pStr &lt;/span&gt;= (&lt;span&gt;char&lt;/span&gt;*)malloc(strLen + 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pStr)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        }
        memcpy(pStr, jBuf, strLen);
        pStr[strLen] &lt;/span&gt;= 0&lt;span&gt;;
    }
    env&lt;/span&gt;-&amp;gt;ReleaseByteArrayElements(byteArray, jBuf, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pStr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际上上述转换的字符串就是用户输入的用户名、邮箱以及序列号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在__gnu_Unwind_6函数中会判断用户输入的序列号长度是否为8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224945312-361974330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用__gnu_Unwind_1函数，此函数又有很多花指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225005812-719313284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次调用_gnu_armfini_29函数，通过前面的分析我们知道这是一个RC4加解密函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225019640-2132287394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里实际上是取“用户名+邮箱”组成的字符串的的前四个字节进行加密，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225035296-711506956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就是一个比较关键的函数__gnu_Unwind_4了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225050343-275696637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数实际上是实现了SHA1加密算法，以下为该算法初始化缓冲区时的特征：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225106140-144495833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;__gnu_Unwind_4将”用户名+邮箱“组成的字符串（包括前四个被RC4算法加密过的字符）进行SHA1加密后，通过__gnu_Unwind_11函数与用户输入的序列号进行对比，从而判断是否破解成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225119546-1297073529.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225131781-859003127.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附：其它方法&lt;br/&gt;我们重新打开一个ida，加载libqihoo.so，按快捷键“shift+F2”打开脚本编写窗口编写脚本对该内存区域进行解密。如下图所示：&lt;/p&gt;
&lt;p&gt;这样得到的就是完全解密的so文件了。&lt;br/&gt;脚本内容:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; idaapi

def rc4(data, key):
&lt;/span&gt;&quot;&quot;&quot;RC4 encryption and decryption method.&quot;&quot;&quot;&lt;span&gt;
S, j, out &lt;/span&gt;= list(range(256)), 0&lt;span&gt;, []

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i in range(256&lt;span&gt;):
j &lt;/span&gt;= (j + S[i] + ord(key[i % len(key)])) % 256&lt;span&gt;
S[i], S[j] &lt;/span&gt;=&lt;span&gt; S[j], S[i]

i &lt;/span&gt;= j = 0
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; ch in data:
i &lt;/span&gt;= (i + 1) % 256&lt;span&gt;
j &lt;/span&gt;= (j + S[i]) % 256&lt;span&gt;
S[i], S[j] &lt;/span&gt;=&lt;span&gt; S[j], S[i]
out.append(chr(ord(ch) &lt;/span&gt;^ S[(S[i] + S[j]) % 256&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;.join(out)

key&lt;/span&gt;=idaapi.get_many_bytes(0x20434,12&lt;span&gt;)
addr&lt;/span&gt;= 0x176dc&lt;span&gt;;
data&lt;/span&gt;=idaapi.get_many_bytes(addr,0x8aec&lt;span&gt;)
decode&lt;/span&gt;=&lt;span&gt;rc4(data,key)
idaapi.patch_bytes(addr, decode)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 31 Jan 2018 14:53:00 +0000</pubDate>
<dc:creator>bamb00</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodhacker/p/8395240.html</dc:identifier>
</item>
<item>
<title>中小研发团队架构实践之统一应用分层 - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</guid>
<description>&lt;h2 id=&quot;magicdomid2&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-OAU9reFCIyvYUWQ2&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;一、写在前面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层这件事情看起来很简单，但每个程序员都有自己的一套，哪怕是初学者。如何让一家公司的几百个应用采用统一的分层结构，并得到大部分程序员的认同呢？这可不是件简单的事情，接下来以我们真实案例与大家一起探讨，先问大家两个技术问题：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid4&quot; class=&quot;list-start-number1 font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-5ylaBPK6ZygoPtjT&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;服务的调用代码你觉得放到哪一层好呢？A表现层；B业务逻辑层；C数据层；D公共层。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid5&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-HeMBlRPKIWq6lyur&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;如何组织好VO(View Object视图对象)、BO(Business Object业务对象)、DO(Data Object数据对象)、DTO(Data Transfer Object数据传输对象)呢？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;不同的人会有不同的答案，所以要&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;统一&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;公司应用分层，以减少开发维护学习成本。统一应用分层要可大可小、&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;简单易用、&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;支持多种场景，我们采用IPO方式：I是Input、O是Output、P是Process，一进一出一处理。&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;应用系统的本质是机器，是处理设备，一进一出一处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid7&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-RySHmuawNgSOEzRp&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223816218-344903290.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;span&gt;                                                                  &lt;strong&gt;IPO&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;原理图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid9&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-t6D71njO4gZzkZbv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;二、统一逻辑架构&lt;/span&gt;&lt;/h2&gt;
&lt;div id=&quot;magicdomid10&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-BLBKtNgc2I2SCbe5&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223838546-1466285923.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;                                         统一应用分层的逻辑架构图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;职责说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid13&quot; class=&quot;gutter-author-3423802 table-div&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;div class=&quot;iframe-container&quot;&gt;
&lt;div class=&quot;shadow-table&quot;&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;层英文名&lt;/td&gt;
&lt;td&gt;中文名&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PresentationLayer&lt;/td&gt;
&lt;td&gt;表现层文件夹&lt;/td&gt;
&lt;td&gt;上层向用户提供服务，负责视图展示。项目类型包括WebSite、WebForm、MVC、WCF、WebService等。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BusinessLayer&lt;/td&gt;
&lt;td&gt;业务逻辑层文件夹&lt;/td&gt;
&lt;td&gt;中间逻辑处理，负责应用系统的业务逻辑的处理。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DataLayer&lt;/td&gt;
&lt;td&gt;数据访问层文件夹&lt;/td&gt;
&lt;td&gt;下层调用服务，负责数据资源提供方如数据库、SOA、OpenAPI的交互。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;EntityLayer&lt;/td&gt;
&lt;td&gt;实体层文件夹&lt;/td&gt;
&lt;td&gt;VO：View Object视图对象；&lt;br/&gt;DTO：Data Transfer Object数据传输对象；&lt;br/&gt;BO：Business Object业务对象；&lt;br/&gt;DO：Data Object数据对象；&lt;br/&gt;在实际项目中，为简化设计可进行裁剪，BO和DO为可选，DTO属于服务项目类型，VO属于网站项目类型，也不会同时存在。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CommonLayer&lt;/td&gt;
&lt;td&gt;公共层文件夹&lt;/td&gt;
&lt;td&gt;工具类库，负责提供应用系统中常用的操作。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TestLayer&lt;/td&gt;
&lt;td&gt;测试层文件夹&lt;/td&gt;
&lt;td&gt;单元测试（可选），负责对其它类库的自动化单元测试。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;magicdomid14&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-Hdj1daU6AJzQvXlL&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;文件夹分层法：应用分层采用文件夹方式的优点是可大可小、简单易用、统一规范，可以包括5个项目，也可以包括50个项目，以满足所有业务应用的多种不同场景；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid15&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-Cwbs0zCLHJqWOGz8&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;调用规约：在开发过程中，需要遵循分层架构的约束，禁止跨层次的调用；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid16&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-a2Me3eY6KB3NtepK&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;下层为上层服务：以用户为中心，以目标为导向。上层（业务逻辑层）需要什么，下层（数据访问层）提供什么，而不是下层（数据访问层）有什么，就向上层（业务逻辑层）提供什么；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid17&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-ublfpKOchCDEy5kU lineguid-gc9w8ZmLcY7pRRjR lineguid-aPcH2RckSOBmqh5i&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;实体层规约：DO是数据表对象，不是数据访问层对象，不是只能给数据访问层使用；DTO是网络传输对象，不是表现层对象，不是只能给表现层使用；BO是内存计算逻辑对象，不是业务逻辑层对象，不是只能给业务逻辑层使用 。&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;如果仅限定在本层访问，则导致单个应用内大量没有价值的对象转换。以用户为中心来设计实体类，可以减少无价值重复对象和无用转换；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid18&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-2M0YFmDlRfUtdejF&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;U型访问：下行时表现层是Input，业务逻辑层是Process，数据访问层是Output。上行时数据访问层是Input，业务逻辑层是Process,  表现层就Output。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 id=&quot;magicdomid19&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-o0GVP94e5kr2XHF4&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;三、我们的具体规范&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;        此规范我们用了四年，牵涉几百个应用，200多个研发人员，是一个成功的实践。接下来就借用本文&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;提供下载的TripOrderService、TripSellerMVCSite这两个Demo&lt;span class=&quot;author-3423802&quot;&gt;来进行具体规范的说明，&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;以下是截图：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid21&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-Z0N6MtzErqcRz3dS&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223910500-1784436339.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid22&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-pFoxDYfCaWtXzBFv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223924468-715036767.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid23&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-qd10e7gTFhe5qKK5&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.1、&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;项目命名规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.{项目职责英文名全称}，如：Trip.Seller.DTO。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid25&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-AQ8sqW7Lur3o9AfF&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.2、业务逻辑层的项目规范&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid26&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-7qJkzSRxowY0JA7y&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223945015-728845028.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、项目名的命名规则：{产品线英文名全称}.{子系统英文名全称&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;+应用名}&lt;span class=&quot;author-3423802&quot;&gt;.xxxBusiness，如上图的Trip.Order.Business。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、类名以Logic结尾，如上图的OrderLogic.cs。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid30&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-1E8nDlgbpSXbDKaJ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.3、数据操作项目&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid31&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-fGYtDcIJpM5mNUsq&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224002406-1860863187.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、各数据操作项目名根据使用什么数据库进行分类，然后以DB为结尾，具体命名规则是：{产品线英文名全称}.{子系统英文名全称+应用名}.{使用什么数据库}DB，如上图的Trip.Seller.MSSQLDB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、如果涉及到多个数据库访问的，那么数据操作项目下的类文件需要按数据库名称（以DB为结尾）创建文件夹分开，如上图的TripOrderDB文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;3、建议在应用中使用SQL语句，不使用存储过程。在数据库中不新增存储过程，但旧的存储过程可以继续使用和修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;4、分页建议使用数据库（如SQLServer）的最新特性进行分页，并将每个分页SQL直接写到应用中。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid37&quot; class=&quot;font-size-4 gutter-author-3423802 heading-1 locate lineguid-AwzWhLWSSfhdBy3Q&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.4、实体类项目&lt;span class=&quot;author-3423802 b font-size-4&quot;&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid38&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-smsiCgcpp6Gg6Jv2&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;数据传输对象&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;DTO&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid39&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-m8TGevpWbw4DjfHk&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-3 upload-image img-a9RxZW4fjDfWb2DR image-width-275 image-height-306&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/CsPh1kBAD8sTAp0X/%E5%9B%BE8_%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%A1%B9%E7%9B%AE%E4%B9%8BDTO%E8%A7%84%E8%8C%83.png!thumbnail&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-UK0SKE9sQcqMM3vk&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131225027906-930059743.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;1、DTO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.DTO，如上图的Trip.Order.DTO&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;2、请求参数DTO实体类、响应DTO实体类存放规范以及其命名规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;      a、请求参数DTO实体类放在Request文件夹下，且命名规则为：以Request结尾，如上图的SearchOrderRequest.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;       b、响应DTO实体类放在Response文件夹下，且命名规则为：以Response结尾，如上图的SearchOrderResponse.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;       c、如果请求参数DTO实体类或响应DTO实体类的属性中有对象或枚举，那么这些对象所属的类、枚举放在DTO项目的Common文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;3、如果请求参数DTO实体类、响应DTO实体类有基类要继承，那么建议为基类取名为RequestBase.cs、ResponseBase.cs。且这些基类直接放在DTO项目的Common文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid47&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-8cWH6bsZXcUXCved&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;视图对象VO规范&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid48&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-Ha9x6hdFURNrPbko&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224045437-1180834418.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、VO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.ViewModel，如上图的Trip.Seller.ViewModel。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、各VO实体类，我们用Controller名作为文件夹名进行分开，如上图的Order文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、VO实体类名的命名建议：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;     a、请求参数VO实体类以Input/Form/Query结尾，如上图的SearchOrderInput.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;     b、响应VO实体类以Output/List/Result结尾，如上图的SearchOrderOutput.cs。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid55&quot; class=&quot;font-size-4 gutter-author-3423802 list-div heading-1 locate lineguid-BRtEc8C8lVNwX5Ia&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;业务对象BO规范（可选）&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;BO实体类名以Model&lt;span class=&quot;author-3423802&quot;&gt;为结尾：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid57&quot; class=&quot;font-size-4 gutter-author-3423802 line-left locate lineguid-JE3KCe33lOuwq06s&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224123796-1421783543.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;1、BO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.BO，如上图的Trip.Order.BO;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;2、以Model结尾，如上图的OrderModel.cs；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;3、为了简化设计，BO项目为可选，可在DO项目里建文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid62&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-4u5df5Hk4udw6Uxo&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;数据对象DO规范（可选）&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid63&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-9ZfG5d8G8OnxtGUf&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224145125-368030097.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、DO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.Entity，如上图的Trip.Seller.Entity；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、如果涉及到多个数据库访问的，那么需要按数据库名称（以DB为结尾）创建文件夹分开，如上图的TripOrderDB文件夹；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、表名+Entity结尾，如上图的OrderEntity.cs；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;4、DO是数据表对象，供&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;单表&lt;span class=&quot;author-3423802&quot;&gt;CURD操作。对于多表查询请求对象和返回对象，可&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;定义新对象或&lt;span class=&quot;author-3423802&quot;&gt;使用现有对象（DTO/BO）来完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid69&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 heading-1 locate lineguid-NTfjkqxZGatlkBU1&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;3.5、数据库连接配置规范&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid70&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-x117VI52Zq6vWQn0&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224235796-641906963.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、数据库连接的配置必须读写分离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、数据库连接字符串建议加密处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、数据库连接配置名的命名规则：{以DB为结尾的数据库名称}_读写类型，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;TripOrderDB_SELECT、TripOrderDB_INSERT。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid76&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-Th8nuC0Wm1dFXrCg&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.6、配置文件方面的规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid77&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-vfsgHTNoZw5L2FMj&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224307328-1815702971.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;gutter-author-3423802 line-left locate lineguid-vfsgHTNoZw5L2FMj&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224318421-657930216.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、所有配置文件（除Web.config文件外）都必须放到Config文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;所有配置文件（除Web.config&lt;span class=&quot;author-3423802&quot;&gt;文件外）按不同环境区分开，具体命名规则是：{功能模块英文名}.{环境英文简称名}.config，其中本地环境的英文简称名是Dev，测试环境的英文简称名是Test，正式环境的英文简称名是Prod，如上图的AppSetting.Dev.config。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;3、保持Web.config&lt;span class=&quot;author-3423802&quot;&gt;配置文件的干净，只留环境设置节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid83&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-RVo7J9KCw2LfGSfv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.7、静态资源文件方面的规范&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid84&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-9v8kUH0xwpo2p6ti&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224333828-321333919.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;1、公共的静态资源文件（css、js、image等）放在另外的静态站点中，统一由前端进行开发和维护。一般，css文件放在css文件夹下，js文件放在js文件夹下，image图片文件放在img文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、与某项业务有关的js文件可以放到各自业务项目的表现层PresentationLayer下，以方便开发人员调试，js文件可放在项目的js文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;3、静态资源文件必须使用版本号管理，以防更新后由于客户端浏览器缓存而导致站点使用的依然是旧版本的静态资源文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-ngsPIZIsDlllibMY&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/js/order.js?v=@AppSetting.StaticFileVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;四、写在最后&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;h3 id=&quot;magicdomid91&quot; class=&quot;font-size-7 gutter-author-3423802 heading-1 locate lineguid-kotVnOpVyzxvRIRQ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;4.1、问题回答&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;服务的调用代码应该放到哪一层呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;A表现层、B业务逻辑层 、C数据层、D公共层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;我们的规范是统一放到数据资源访问层即C。上层提供服务，下层调用服务，中间处理业务逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;如何组织好VO(View Object视图对象)、BO(Business Object业务对象)、DO(Data Object数据对象)、DTO(Data Transfer Object数据传输对象)呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;通常有两种做法，限定访问范围和不限定&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;访问&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;范围，实际项目中可根据需要选择、折中或裁剪。我们使用后者，将EntityLayer作为通用对象放到左侧，具体可参考实体层规约：“DO是数据表对象，不是数据访问层对象，不是只能给数据访问层使用；DTO是网络传输对象，不是表现层对象，不是只能给表现层使用；BO是内存计算逻辑对象，不是业务逻辑层对象，不是只能给业务逻辑层使用 。如果仅限定在本层访问，则导致单个应用内大量没有价值的对象转换。以用户为中心来设计实体类，可以减少无价值重复对象和无用转换。”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例代码的编写需要注意些什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12&quot;&gt;&lt;span&gt;答：&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例的代码要想写好，非常不容易，很容易引起&lt;span class=&quot;author-3423802&quot;&gt;争议，很难让所有人满意。我们&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;在具体实践时遵循以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid101&quot; class=&quot;list-start-number1 font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-MOxnuFneYLdA4YGm&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例的主要价值是明确层的职责和交互，每个层的职责是什么，哪些要干，哪些不要干，以及层与层之间依赖和交互；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid102&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-oxWbDt5BocWwdBjq&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;私人定制：减少通用帮助类的编写，如果每一个应用中有大量相同的帮助类，这在架构层面上是有问题。在我们的几百个线上应用中，尽管减少通用的代码，包括分页帮助类、数据库帮助类、缓存帮助类、MQ帮助类、日志帮助类、AOP帮助类、线程帮助类。业务应用的重点是为业务服务，每一个应用都是特别的，都需要私人定制，极少有通用的代码，如果有，那么应该由框架或组件专门解决；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid103&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-I0zRdSo99pJgNrRI&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;少即是多：应用的场景多，参考人员多，每个人想法不同，牵涉的时间长，所以尽量只做大家都认同的规范、正确的事情，要自底向上、要减少有争议的代码范例，否则一个错误将会放大百倍、一个有争议的规范将会很难推行。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid104&quot; class=&quot;font-color-12 gutter-author-3423802 list-div locate lineguid-OqOPX8QTG17Nfhsx&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;4&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;追求简单：代码编写可分为三个层次，简单、复杂、简单。第一简单是不知道的简单，第二个复杂是知道后的复杂，第三个简单是知道后有取舍的简单。范例代码要追求简单，既可轻松扩展支持复杂场景，又要简单到初级程序员也能操作。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid105&quot; class=&quot;font-color-12 gutter-author-3423802 list-div locate lineguid-nsO5rwwWsvfLQTwG lineguid-wVUlRoBWZqb1zMCs&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;5&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt; 内聚大于解耦：内聚是什么，内聚是部门内有共同的目标，然后大家紧密合作。解耦是什么，解耦是部门间各自职责明确，然后减少不必要的连接。一个应用如同一个部门，应有一个共同的目标和职责，然后大家紧密合作。换句话说，应用内部应减少不必要契约接口（如同公司间才签约合同），减少不必要的依赖注入实现，减少不必要且代价过大的解耦。一切以简单实用为主，以应用价值输出、应用的目标（接口或界面）为导向。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid106&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-PYASinuDFGblFuuw&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-7&quot;&gt;&lt;span&gt;4.2、Demo下载&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;



</description>
<pubDate>Wed, 31 Jan 2018 14:45:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——29. 优先考虑泛型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8394876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8394876.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参数化声明并使用JDK提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。&lt;/p&gt;
&lt;p&gt;考虑条目 7中的简单堆栈实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Object-based collection - a prime candidate for generics
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是&lt;code&gt;E&lt;/code&gt;（条目 68）。&lt;/p&gt;
&lt;p&gt;下一步是用相应的类型参数替换所有使用的Object类型，然后尝试编译生成的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Initial attempt to generify Stack - won't compile!
public class Stack&amp;lt;E&amp;gt; {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new E[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public E pop() {
        if (size == 0)
            throw new EmptyStackException();
        E result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }
    ... // no changes in isEmpty or ensureCapacity
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:8: generic array creation
        elements = new E[DEFAULT_INITIAL_CAPACITY];
                   ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如条目 28所述，你不能创建一个不可具体化类型的数组，例如类型&lt;code&gt;E&lt;/code&gt;。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个Object数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:8: warning: [unchecked] unchecked cast
found: Object[], required: E[]
        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
                       ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给&lt;code&gt;push&lt;/code&gt;方法的元素，它们是&lt;code&gt;E&lt;/code&gt;类型的，所以未经检查的强制转换不会造成任何伤害。&lt;/p&gt;
&lt;p&gt;一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack可以干净地编译，并且可以在没有显式强制转换或担心ClassCastException异常的情况下使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// The elements array will contain only E instances from push(E).
// This is sufficient to ensure type safety, but the runtime
// type of the array won't be E[]; it will always be Object[]!
@SuppressWarnings(&quot;unchecked&quot;)
public Stack() {
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消除Stack中的泛型数组创建错误的第二种方法是将属性元素的类型从&lt;code&gt;E []&lt;/code&gt;更改为&lt;code&gt;Object []&lt;/code&gt;。 如果这样做，会得到一个不同的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:19: incompatible types
found: Object, required: E
        E result = elements[--size];
                           ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过将从数组中检索到的元素转换为&lt;code&gt;E&lt;/code&gt;来将此错误更改为警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:19: warning: [unchecked] unchecked cast
found: Object, required: E
        E result = (E) elements[--size];
                               ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为E是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个&lt;code&gt;pop&lt;/code&gt;方法上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Appropriate suppression of unchecked warning
public E pop() {
    if (size == 0)
        throw new EmptyStackException();

    // push requires elements to be of type E, so cast is correct
    @SuppressWarnings(&quot;unchecked&quot;) E result =
        (E) elements[--size];

    elements[size] = null; // Eliminate obsolete reference
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为&lt;code&gt;E []&lt;/code&gt;类型，清楚地表明它只包含E实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组; 第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（条目 32）：数组的运行时类型与编译时类型不匹配（除非E碰巧是Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。&lt;/p&gt;
&lt;p&gt;下面的程序演示了泛型Stack类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用String的&lt;code&gt;toUpperCase&lt;/code&gt;方法不需要显式强制转换，而自动生成的强制转换将保证成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Little program to exercise our generic Stack
public static void main(String[] args) {
    Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    for (String arg : args)
        stack.push(arg);
    while (!stack.isEmpty())
        System.out.println(stack.pop().toUpperCase());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子似乎与条目 28相矛盾，条目 28中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java本身生来并不支持列表，所以一些泛型类型（如ArrayList）必须在数组上实现。 其他的泛型类型，比如HashMap，是为了提高性能而实现的。&lt;/p&gt;
&lt;p&gt;绝大多数泛型类型就像我们的Stack示例一样，它们的类型参数没有限制：可以创建一个&lt;code&gt;Stack &amp;lt;Object&amp;gt;&lt;/code&gt;，&lt;code&gt;Stack &amp;lt;int []&amp;gt;&lt;/code&gt;，&lt;code&gt;Stack &amp;lt;List &amp;lt;String &amp;gt;&amp;gt;&lt;/code&gt;或者其他任何对象的Stack引用类型。 请注意，不能创建基本类型的堆栈：尝试创建&lt;code&gt;Stack&amp;lt;int&amp;gt;&lt;/code&gt;或&lt;code&gt;Stack&amp;lt;double&amp;gt;&lt;/code&gt;将导致编译时错误。 这是Java泛型类型系统的一个基本限制。 可以使用基本类型的包装类（条目 61）来解决这个限制。&lt;/p&gt;
&lt;p&gt;有一些泛型类型限制了它们类型参数的允许值。 例如，考虑&lt;code&gt;java.util.concurrent.DelayQueue&lt;/code&gt;，它的声明如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DelayQueue&amp;lt;E extends Delayed&amp;gt; implements BlockingQueue&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型参数列表（&lt;code&gt;&amp;lt;E extends Delayed&amp;gt;&lt;/code&gt;）要求实际的类型参数&lt;code&gt;E&lt;/code&gt;是&lt;code&gt;java.util.concurrent.Delayed&lt;/code&gt;的子类型。 这使得&lt;code&gt;DelayQueue&lt;/code&gt;实现及其客户端可以利用&lt;code&gt;DelayQueue&lt;/code&gt;元素上的&lt;code&gt;Delayed&lt;/code&gt;方法，而不需要显式的转换或ClassCastException异常的风险。 类型参数E被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型[JLS，4.10]，因此创建&lt;code&gt;DelayQueue &amp;lt;Delayed&amp;gt;&lt;/code&gt;是合法的。&lt;/p&gt;
&lt;p&gt;总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 12:55:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8394876.html</dc:identifier>
</item>
</channel>
</rss>