<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【详记MySql问题大全集】三、安装之后没有my.ini配置文件怎么办 - 在7楼</title>
<link>http://www.cnblogs.com/RayWang/p/9347874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RayWang/p/9347874.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;系列目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、安装MySql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、安装并破解Navicat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、没有my.in配置文件怎么办&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、设置MySql的大小写敏感&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、重置MySql登陆密码&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;之前说过，Windows操作系统中，我们安装Mysql有两个选择：一是下载MSI点击运行，利用windows系统安装程序的方法按部就班的来安装；二是下载ZIP，解压出来就能立即使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在使用ZIP安装时，安装好之后默认是没有my.ini配置文件的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721180254921-1373434363.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们想修改数据库的配置信息如 wait_timeout、interactive_timeout、max_connections 或大小写敏感时，却找不到my.ini 配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这时，还可以通过命令行来修改配置信息，但重启mysql后修改会失效，配置会回归默认值，所以这种方式治标不治本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里提供了另一种方法，解决的基本思路是：先删除Mysql服务，然后自己新建一个my.ini文件，最后使用命令行重新初始化mysql服务，同时指定新建的my.ini作为服务默认的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是详细步骤：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  1. 删除MySql服务&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开cmd（记得”使用管理员身份“打开），如果没有配置环境变量，请cd（切换目录）到mysql程序下的bin文件夹下（详细步骤参见第一章~）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
D:\MySql\bin&amp;gt;sc delete MySql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721180956238-756390584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;MySql&quot;为服务名称，你的MysSql服务不一定是这个名称，可以打开电脑的服务窗口查看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除完成之后，最好去电脑的服务窗口看下，如果找不到MySql服务，说明已经已经删除成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还能看到MySql服务，可以手动右击选择”停止“，服务停止之后就会自动消失了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  2. 新建my.ini配置文件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在mysql程序的根目录下，新建一个my.ini空白文件，用记事本打开，将以下内容复制进去，保存：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_654671b5-4aa7-4a0e-b9ca-25d5ba90a571&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_654671b5-4aa7-4a0e-b9ca-25d5ba90a571&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_654671b5-4aa7-4a0e-b9ca-25d5ba90a571&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# For advice on how to change settings please see
# http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html&lt;/span&gt;
# *** DO NOT EDIT THIS FILE. It&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s a template which will be copied to the&lt;/span&gt;
# *** &lt;span&gt;default&lt;/span&gt; location during install, and will be replaced &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you
# &lt;/span&gt;***&lt;span&gt; upgrade to a newer version of MySQL.
[client]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt; =&lt;span&gt; utf8mb4
[mysql]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt; =&lt;span&gt; utf8mb4
[mysqld]
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-client-handshake =&lt;span&gt; FALSE
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-server =&lt;span&gt; utf8mb4
collation&lt;/span&gt;-server =&lt;span&gt; utf8mb4_bin
init_connect&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET NAMES utf8mb4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
# Remove leading # and &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; to the amount of RAM &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the most important data
# cache &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; MySQL. Start at &lt;span&gt;70&lt;/span&gt;% of total RAM &lt;span&gt;for&lt;/span&gt; dedicated server, &lt;span&gt;else&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;%&lt;span&gt;.
innodb_buffer_pool_size &lt;/span&gt;=&lt;span&gt; 128M
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
# These are commonly &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;, remove the # and &lt;span&gt;set&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; required.
basedir &lt;/span&gt;=&lt;span&gt; D:\MySQL
datadir &lt;/span&gt;=&lt;span&gt; D:\MySQL\data
port &lt;/span&gt;= &lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
# server_id &lt;/span&gt;=&lt;span&gt; .....
# Remove leading # to &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; options mainly useful &lt;span&gt;for&lt;/span&gt;&lt;span&gt; reporting servers.
# The server defaults are faster &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; transactions and fast SELECTs.
# Adjust sizes &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; needed, experiment to find the optimal values.
join_buffer_size &lt;/span&gt;=&lt;span&gt; 128M
sort_buffer_size &lt;/span&gt;=&lt;span&gt; 16M
read_rnd_buffer_size &lt;/span&gt;=&lt;span&gt; 16M 
sql_mode&lt;/span&gt;=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721181935464-1021696430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中basedir 和 datadir 根据实际MySql安装的位置进行修改。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  3. 重新生成data文件，同时绑定my.ini配置文件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;删除之前生成的data文件，如果有重要的数据表，请先备份好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到cmd，重新生成data文件。&lt;/span&gt;&lt;span&gt;运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
D:\MySql\bin&amp;gt;mysqld --initialize-insecure --user=mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，”..\my.ini“是新建的配置文件的位置，也可以写成绝对路径”D:\MySql\my.ini“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该命令需要执行大概一分钟左右，完成后会在MySql程序文件夹下重新生成名称为data的文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721161536791-1925390961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721161409303-1309991773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 4. 重新安装mysql服务&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;安装MySql服务，同时设置绑定my.ini配置文件。命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
D:\MySql\bin&amp;gt;mysqld --install &lt;span class=&quot;hljs-string&quot;&gt;&quot;MySql80&quot; --defaults-file=&lt;span class=&quot;hljs-string&quot;&gt;&quot;d:/mysql/my.ini&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“MySql80”是服务名称，80表示8.0版本，当然，也可以自己取别的名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180723030116654-491816554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果提示安装成功，这时打开电脑的”服务“窗口，可以找到新添加的MySql80服务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180723030238352-1764266832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 5. 启动服务&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里有两种启动服务的方式：1）服务窗口启动；2）cmd启动&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 5.1 服务窗口启动&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;直接右击服务项，选择启动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180723030400819-1018699553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 5.2 cmd命令启动&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
D:\MySql\bin&amp;gt;net start mysql80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;等待20秒左右，如果启动成功，是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180723030528154-1488904511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果不成功：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721190848727-995086161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这时可能是my.ini配置文件中的某些配置有问题。你可以修改ini文件内容，然后从头按步骤再试一遍。&lt;/p&gt;
&lt;h2&gt; 6. 重新设置密码&lt;/h2&gt;
&lt;p&gt;删除了data文件和服务之后，之前的密码就失效了，所以需要重新设置密码。&lt;/p&gt;
&lt;h3&gt; 6.1 登陆mysql&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
D:\MySql\bin&amp;gt;mysql -u root -p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时密码为空，不需要填写，直接回车：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721164016760-1532553965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果这里没有登陆成功，请移步下一章”重置MySql密码“~&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 6.2 修改root用户密码&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（敲黑板）这里有个需要注意的地方，在8.0之后的版本，修改root用户密码的命令是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ALTER USER &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED WITH mysql_native_password BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你的密码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;之前的版本是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
update mysql.user &lt;span&gt;set&lt;/span&gt; authentication_string=password(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; user=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;我这里安装的是8.0.11，所以是第一个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721164941997-329979520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 6.3 退出MySQL&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; exit
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  6.4 使用修改后的密码重新登陆&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里的命令和之前是一样的，就不写了，密码记得要填刚才设置的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180721165732693-467799897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;现在已经成功绑定了my.ini配置文件了，如果需要自定义配置，可以打开文件进行相应的配置设置，修改后重启服务即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果修改后，重启服务报错，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180723033912661-1901629121.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有一种可能：你修改的配置与服务初始化时的配置有冲突，这时只能从头开始，在初始化的时候绑定my.ini文件 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一章要讲的的“设置MySql大小写敏感”就是~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 23:18:00 +0000</pubDate>
<dc:creator>在7楼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RayWang/p/9347874.html</dc:identifier>
</item>
<item>
<title>[ARCH] 1、virtualbox中安装archlinux+i3桌面，并做简单美化 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9380485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9380485.html</guid>
<description>&lt;p&gt;星期六, 28. 七月 2018 02:42上午 - beautifulzzzz&lt;br/&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装archlinux系统&quot;&gt;1、安装ArchLinux系统&lt;/h3&gt;
&lt;p&gt;安装Arch主要看其wiki，比较详细～ 中文的我主要参考：&lt;a href=&quot;https://www.linuxidc.com/Linux/2017-12/149838.htm&quot;&gt;一步步教你如何安装 Arch Linux&lt;/a&gt;，具体细的流程倒是忘了，大致操作如下：&lt;/p&gt;
&lt;p&gt;我是在virtualbox中安装的，因此只要下载IOS，不用制作U盘了～&lt;/p&gt;
&lt;p&gt;对于新手，我比较推荐仔细看wiki，同时结合上面的文章尝试～如果你用ubuntu尝试安装过树莓派，会发现差不多～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 新系统ping百度报错，发现需要配置网络：ping Temporary failure in name resolution，解决方法是&lt;a href=&quot;https://blog.csdn.net/r8l8q8/article/details/76516523&quot;&gt;ArchLinux安装图文教程&lt;/a&gt;第11节配置网络；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 用上面的方法有时候会出现源不行安装失败的情况，我从&lt;a href=&quot;https://blog.csdn.net/r8l8q8/article/details/76516523&quot;&gt;ArchLinux安装图文教程&lt;/a&gt;发现需要更换中国源，然后再安装，更新源的方法见：&lt;a href=&quot;https://blog.csdn.net/kxp9545/article/details/76136190&quot;&gt;【为archlinux选择国内镜像】&lt;/a&gt;，中国的源速度很快2M/s,不用10分钟就OK了；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 安装好命令行版之后，重启系统，也要修改源！不然安装X等不好！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;更新源也需要wget:
可调用pacman -S wget的时候报错：

error: failed to init transaction (unable to lock database)” 错误

pacman 在更新软件包数据库前，比如安装软件包时会创建一个文件锁 /var/lib/pacman/db.lck。该文件会阻止其他 pacman 实例在同一时间修改软件包数据库。如果 pacman 在更新数据库时收到干扰，旧锁会一直存在。如果确认 pacman没有在运行，那么删掉文件锁：

# rm /var/lib/pacman/db.lck
https://blog.csdn.net/rocky_03/article/details/69934729&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装i3桌面&quot;&gt;2、安装I3桌面&lt;/h3&gt;
&lt;p&gt;用arch当然用i3！具体步骤如下：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1）安装i3窗口管理器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  pacman -S i3&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2）安装 lightdm 显示管理器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  pacman -S lightdm-gtk-greeter&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3）然后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  systemctl enable lightdm
  systemctl start lightdm&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4）登陆进i3之后会自动加载配置向导，基本上一路next即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;i3安装好之后比较丑，基本的操作都在其官网上：&lt;a href=&quot;https://i3wm.org/docs/userguide.html&quot; class=&quot;uri&quot;&gt;https://i3wm.org/docs/userguide.html&lt;/a&gt;&lt;br/&gt;i3的美化可以参考这一个：&lt;a href=&quot;https://keyin.me/posts/beautifull-i3/&quot; class=&quot;uri&quot;&gt;https://keyin.me/posts/beautifull-i3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看下最后的成果的（虽然才优化10%，简洁和炫酷已经可以感受到了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180728/ARCH.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Arch Wiki 安装指导文档： &lt;a href=&quot;https://wiki.archlinux.org/index.php/Installation_guide&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ArchLinux 官网：&lt;a href=&quot;https://www.archlinux.org&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一步步教你如何安装 Arch Linux：&lt;a href=&quot;https://www.linuxidc.com/Linux/2017-12/149838.htm&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ArchLinux安装图文教程：&lt;a href=&quot;https://blog.csdn.net/r8l8q8/article/details/76516523&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为archlinux选择国内镜像：&lt;a href=&quot;https://blog.csdn.net/kxp9545/article/details/76136190&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;给妹子看的 Arch Linux 桌面日常安装：&lt;a href=&quot;https://bigeagle.me/2014/06/archlinux-install-for-beginners/&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;i3 User’s Guide：&lt;a href=&quot;https://i3wm.org/docs/userguide.html&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;体验I3之美：&lt;a href=&quot;https://keyin.me/posts/beautifull-i3/&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Arch Linux 安装、配置、美化和优化：&lt;a href=&quot;https://www.cnblogs.com/bluestorm/p/5929172.html&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Archlinux下i3wm与urxvt的配置：&lt;a href=&quot;https://www.cnblogs.com/vachester/p/5649813.html&quot;&gt;GO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 27 Jul 2018 18:46:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9380485.html</dc:identifier>
</item>
<item>
<title>ASP.NET全栈开发日志模块之操作日志的设计 - Gxqsd</title>
<link>http://www.cnblogs.com/Gxqsd/p/9380325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gxqsd/p/9380325.html</guid>
<description>&lt;p&gt;应用程序中的日志大致分为三种&lt;/p&gt;
&lt;p&gt;第一种：用于生产模式下追中bug的异常日志。（这类日志相信大家都懂）&lt;/p&gt;
&lt;p&gt;第二种：用于记录重要操作的行为日志。（这类日志主要作用是溯源，行为主要有三种：增、删、改）&lt;/p&gt;
&lt;p&gt;第三种：用于记录历史浏览的消息日志。（这类日志主要记录用户的浏览痕迹）&lt;/p&gt;
&lt;p&gt;消息日志和行为日志有点相似，都有溯源的作用，但它们区别很明显。&lt;/p&gt;
&lt;p&gt;消息日志记录的是所有操作信息，比如 “gxqsd 登录了 系统 2018-7-27 23:46:10” , &quot;gxqsd 访问了用户管理首页&quot;, “gxqsd 查看了 liming 的个人信息”，总而言之他更像一句话，也像是浏览记录，我们针对每一个消息日志存储一个Url就能依次回溯。（所以消息日志不包含对数据的操作，那属于行为日志）&lt;/p&gt;
&lt;p&gt;行为日志主要是记录数据的变化，比如 &quot;gxqsd 新增了一个角色 &quot; 这时候触发了新增操作，我们希望将这个行为记录下来，如果只是记录了 “gxqsd 新增了一个角色” 那显然他就有点像消息日志了，但它又不能用于做历史记录。所以作为行为日志最重要的是要记录数据的变化。因此针对 &quot;gxqsd 新增了一个角色”，正确的办法应是将新增的角色实体信息存储下来。&lt;/p&gt;
&lt;p&gt;接下来用一张简单的图来描述数据库表之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180727235738555-1793207853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们定义一个日志记录表Logging，每一行数据表示一条行为日志。用LogDataDetial表示行为日志的详细信息&lt;/p&gt;
&lt;p&gt;其中Logging表中TargetId表示实体操作的目标对象，比如&quot;gxqsd create a new user&quot; TableName 则是&quot;User&quot; 而TargetId则表示这个新增的用户的Id，通过Table和TargetId我们最终就能在追溯的时候定位到具体实体。&lt;/p&gt;
&lt;p&gt;LogDataDetail表就挺简单的了，Logging表示每一条行为日志，而每一个行为日志所改变的数据是以实体为单位的，实体又有多个字段，为了能详细追踪实体数据的变化，LogDataDetail将实体的每一个属性分解成犹如键值对的形式。又通过LogId将他们与具体行为日志关联起来。而每一个Logging又与操作用户关联起来。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Jul 2018 16:11:00 +0000</pubDate>
<dc:creator>Gxqsd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gxqsd/p/9380325.html</dc:identifier>
</item>
<item>
<title>JAVAEE——宜立方商城08：Zookeeper+SolrCloud集群搭建、搜索功能切换到集群版、Activemq消息队列搭建与使用 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9380299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9380299.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、solr&lt;span&gt;集群搭建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;span&gt;使用&lt;/span&gt;solrj&lt;span&gt;管理&lt;/span&gt;&lt;span&gt;solr&lt;/span&gt;&lt;span&gt;集群&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、把搜索功能切换到集群版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、添加商品同步索引库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) Activemq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;b) 发送消息&lt;/p&gt;
&lt;p&gt;c) 接收消息&lt;/p&gt;



&lt;p&gt;SolrCloud(solr &lt;span&gt;云&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Solr&lt;/span&gt;&lt;span&gt;提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用&lt;/span&gt; &lt;span&gt;SolrCloud&lt;/span&gt;&lt;span&gt;。当一个系统的索引数据量少的时候是不需要使用&lt;/span&gt;SolrCloud&lt;span&gt;的，当索引量很大，搜索请求并发很高，这时需要使用&lt;/span&gt;SolrCloud来满足这些需求。&lt;/p&gt;
&lt;p&gt; SolrCloud&lt;span&gt;是基于&lt;/span&gt;&lt;span&gt;Solr&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt;的分布式搜索方案，它的主要思想是使用&lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt;作为集群的配置信息中心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;它有几个特色功能：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）集中式的配置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）自动容错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）近实时搜索&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）查询时自动负载均衡&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235242313-726804257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.1. 物理结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;三个&lt;/span&gt;Solr&lt;span&gt;实例（ 每个实例包括两个&lt;/span&gt;&lt;span&gt;Core&lt;/span&gt;&lt;span&gt;），组成一个&lt;/span&gt;&lt;span&gt;SolrCloud&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.2. 逻辑结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;索引集合包括两个&lt;/span&gt;Shard&lt;span&gt;（&lt;/span&gt;&lt;span&gt;shard1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;shard2&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;shard1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;shard2&lt;/span&gt;&lt;span&gt;分别由三个&lt;/span&gt;&lt;span&gt;Core&lt;/span&gt;&lt;span&gt;组成，其中一个&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;两个&lt;/span&gt;&lt;span&gt;Replication&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;是由&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;选举产生，&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;控制每个&lt;/span&gt;&lt;span&gt;shard&lt;/span&gt;&lt;span&gt;上三个&lt;/span&gt;&lt;span&gt;Core&lt;/span&gt;&lt;span&gt;的索引数据一致，解决高可用问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户发起索引请求分别从&lt;/span&gt;shard1&lt;span&gt;和&lt;/span&gt;&lt;span&gt;shard2&lt;/span&gt;&lt;span&gt;上获取，解决高并发问题。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;3.2.1. collection&lt;/h3&gt;
&lt;p&gt;Collection&lt;span&gt;在&lt;/span&gt;&lt;span&gt;SolrCloud&lt;/span&gt;&lt;span&gt;集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个&lt;/span&gt;&lt;span&gt;Shard&lt;/span&gt;&lt;span&gt;（分片），它们使用相同的配置信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：针对商品信息搜索可以创建一个&lt;/span&gt;collection&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; collection=shard1+shard2+....+shardX&lt;/p&gt;

&lt;h3&gt;3.2.2. Core&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;每个&lt;/span&gt;Core&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Solr&lt;/span&gt;&lt;span&gt;中一个独立运行单位，提供 索引和搜索服务。一个&lt;/span&gt;&lt;span&gt;shard&lt;/span&gt;&lt;span&gt;需要由一个&lt;/span&gt;&lt;span&gt;Core&lt;/span&gt;&lt;span&gt;或多个&lt;/span&gt;&lt;span&gt;Core&lt;/span&gt;&lt;span&gt;组成。由于&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;由多个&lt;/span&gt;&lt;span&gt;shard&lt;/span&gt;&lt;span&gt;组成所以&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;一般由多个&lt;/span&gt;&lt;span&gt;core&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2.3. Master&lt;span&gt;或&lt;/span&gt;&lt;span&gt;Slave&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Master&lt;span&gt;是&lt;/span&gt;master-slave&lt;span&gt;结构中的&lt;/span&gt;&lt;span&gt;主结点（通常说主服务器），&lt;/span&gt;Slave&lt;span&gt;是&lt;/span&gt;&lt;span&gt;master-slave&lt;/span&gt;&lt;span&gt;结构中的从结点（通常说从服务器或备服务器）。同一个&lt;/span&gt;&lt;span&gt;Shard&lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;存储的数据是一致的，这是为了达到高可用目的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2.4. Shard&lt;/h3&gt;
&lt;p&gt;Collection&lt;span&gt;的逻辑分片。每个&lt;/span&gt;&lt;span&gt;Shard&lt;/span&gt;&lt;span&gt;被化成一个或者多个&lt;/span&gt;&lt;span&gt;replication&lt;/span&gt;&lt;span&gt;，通过选举确定哪个是&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;3.3. &lt;span&gt;需要实现的&lt;/span&gt;solr&lt;span&gt;集群架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235248135-557474197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Zookeeper&lt;span&gt;作为集群的管理工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、集群管理：容错、负载均衡。&lt;/p&gt;
&lt;p&gt;2、配置文件的集中管理&lt;/p&gt;
&lt;p&gt;3、集群的入口&lt;/p&gt;

&lt;p&gt;&lt;span&gt;需要实现&lt;/span&gt;zookeeper &lt;span&gt;高可用。需要搭建集群。建议是奇数节点。需要三个&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;服务器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;搭建&lt;/span&gt;solr&lt;span&gt;集群需要&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;台服务器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;搭建伪分布式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要三个&lt;/span&gt;zookeeper&lt;span&gt;节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要四个&lt;/span&gt;tomcat&lt;span&gt;节点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;建议虚拟机的内容&lt;/span&gt;1G&lt;span&gt;以上。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    CentOS-6.5-i386-bin-DVD1.iso&lt;/p&gt;
&lt;p&gt;jdk-7u72-linux-i586.tar.gz&lt;/p&gt;
&lt;p&gt;    apache-tomcat-7.0.47.tar.gz&lt;/p&gt;
&lt;p&gt;    zookeeper-3.4.6.tar.gz&lt;/p&gt;
&lt;p&gt;    solr-4.10.3.tgz&lt;/p&gt;

&lt;h2&gt;5.1. Zookeeper&lt;span&gt;集群搭建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：需要安装&lt;/span&gt;jdk&lt;span&gt;环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：把&lt;/span&gt;zookeeper&lt;span&gt;的压缩包上传到服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：解压缩。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：把&lt;/span&gt;zookeeper&lt;span&gt;复制三份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# mkdir /usr/local/solr-cloud&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper01&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper02&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper03&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：在每个&lt;/span&gt;zookeeper&lt;span&gt;目录下创建一个&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：在&lt;/span&gt;data&lt;span&gt;目录下创建一个&lt;/span&gt;&lt;span&gt;myid&lt;/span&gt;&lt;span&gt;文件，文件名就叫做“&lt;/span&gt;&lt;span&gt;myid&lt;/span&gt;&lt;span&gt;”。内容就是每个实例的&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;。例如&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost data]# echo 1 &amp;gt;&amp;gt; myid&lt;/p&gt;
&lt;p&gt;[root@localhost data]# ll&lt;/p&gt;
&lt;p&gt;total 4&lt;/p&gt;
&lt;p&gt;-rw-r--r--. 1 root root 2 Apr  7 18:23 myid&lt;/p&gt;
&lt;p&gt;[root@localhost data]# cat myid&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：修改配置文件。把&lt;/span&gt;conf&lt;span&gt;目录下的&lt;/span&gt;&lt;span&gt;zoo_sample.cfg&lt;/span&gt;&lt;span&gt;文件改名为&lt;/span&gt;&lt;span&gt;zoo.cfg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235259292-695279666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;710&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;server.1=192.168.25.132:2881:3881&lt;/p&gt;
&lt;p&gt;server.2=192.168.25.132:2882:3882&lt;/p&gt;
&lt;p&gt;server.3=192.168.25.132:2883:3883&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;第八步：启动每个&lt;/span&gt;zookeeper&lt;span&gt;实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动&lt;/span&gt;bin/zkServer.sh start&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看&lt;/span&gt;zookeeper&lt;span&gt;的状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bin/zkServer.sh status&lt;/p&gt;

&lt;h2&gt;5.2. Solr&lt;span&gt;集群的搭建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：创建四个&lt;/span&gt;tomcat&lt;span&gt;实例。每个&lt;/span&gt;&lt;span&gt;tomcat&lt;/span&gt;&lt;span&gt;运行在不同的端口。&lt;/span&gt;&lt;span&gt;8180&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;8280&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;8380&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;8480&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：部署&lt;/span&gt;solr&lt;span&gt;的&lt;/span&gt;&lt;span&gt;war&lt;/span&gt;&lt;span&gt;包。把单机版的&lt;/span&gt;&lt;span&gt;solr&lt;/span&gt;&lt;span&gt;工程复制到集群中的&lt;/span&gt;&lt;span&gt;tomcat&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：为每个&lt;/span&gt;solr&lt;span&gt;实例创建一个对应的&lt;/span&gt;&lt;span&gt;solrhome&lt;/span&gt;&lt;span&gt;。使用单机版的&lt;/span&gt;&lt;span&gt;solrhome&lt;/span&gt;&lt;span&gt;复制四份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：需要修改&lt;/span&gt;solr&lt;span&gt;的&lt;/span&gt;&lt;span&gt;web.xml&lt;/span&gt;&lt;span&gt;文件。把&lt;/span&gt;&lt;span&gt;solrhome&lt;/span&gt;&lt;span&gt;关联起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：配置&lt;/span&gt;solrCloud&lt;span&gt;相关的配置。每个&lt;/span&gt;&lt;span&gt;solrhome&lt;/span&gt;&lt;span&gt;下都有一个&lt;/span&gt;&lt;span&gt;solr.xml&lt;/span&gt;&lt;span&gt;，把其中的&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;及端口号配置好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235310797-348876458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第六步：让&lt;/span&gt;zookeeper&lt;span&gt;统一管理配置文件。需要把&lt;/span&gt;&lt;span&gt;solrhome/collection1/conf&lt;/span&gt;&lt;span&gt;目录上传到&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;。上传任意&lt;/span&gt;&lt;span&gt;solrhome&lt;/span&gt;&lt;span&gt;中的配置文件即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用工具上传配置文件：&lt;/span&gt;/root/solr-4.10.3/example/scripts/cloud-scripts/zkcli.sh&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;710&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;./zkcli.sh -zkhost 192.168.25.132:2181,192.168.25.132:2182,192.168.25.132:2183 -cmd upconfig -confdir /usr/local/solr-cloud/solrhome01/collection1/conf -confname myconf&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;查看&lt;/span&gt;zookeeper&lt;span&gt;上的配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;zookeeper&lt;span&gt;目录下的&lt;/span&gt;&lt;span&gt;bin/zkCli.sh&lt;/span&gt;&lt;span&gt;命令查看&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;上的配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost bin]# &lt;span&gt;./zkCli.sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[zk: localhost:2181(CONNECTED) 0] &lt;span&gt;ls /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[configs, zookeeper]&lt;/p&gt;
&lt;p&gt;[zk: localhost:2181(CONNECTED) 1] &lt;span&gt;ls /configs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[myconf]&lt;/p&gt;
&lt;p&gt;[zk: localhost:2181(CONNECTED) 2] &lt;span&gt;ls /configs/myconf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[admin-extra.menu-top.html, currency.xml, protwords.txt, mapping-FoldToASCII.txt, _schema_analysis_synonyms_english.json, _rest_managed.json, &lt;span&gt;solrconfig.xml&lt;/span&gt;, _schema_analysis_stopwords_english.json, stopwords.txt, lang, spellings.txt, mapping-ISOLatin1Accent.txt, admin-extra.html, xslt, synonyms.txt, scripts.conf, update-script.js, velocity, elevate.xml, admin-extra.menu-bottom.html, clustering, &lt;span&gt;schema.xml]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[zk: localhost:2181(CONNECTED) 3]&lt;/p&gt;
&lt;p&gt;退出：&lt;/p&gt;
&lt;p&gt;[zk: localhost:2181(CONNECTED) 3] quit&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;710&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;使用以下命令连接指定的&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;服务：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;./zkCli.sh -server 192.168.25.132:2183&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;第七步：修改&lt;/span&gt;tomcat/bin&lt;span&gt;目录下的&lt;/span&gt;&lt;span&gt;catalina.sh&lt;/span&gt; &lt;span&gt;文件，关联&lt;/span&gt;&lt;span&gt;solr&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把此配置添加到配置文件中：&lt;/p&gt;
&lt;p&gt;JAVA_OPTS=&quot;-DzkHost=192.168.25.132:2181,192.168.25.132:2182,192.168.25.132:2183&quot;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235414941-1496310384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第八步：启动每个&lt;/span&gt;tomcat&lt;span&gt;实例。要&lt;/span&gt;保证zookeeper&lt;span&gt;集群是启动状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第九步：访问集群&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235422432-1653278827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第十步：创建新的&lt;/span&gt;Collection&lt;span&gt;进行分片处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http://192.168.25.132:8180/solr/admin/collections?action=CREATE&amp;amp;name=collection2&amp;amp;numShards=2&amp;amp;replicationFactor=2&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235428772-558364492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235502474-1672640905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第十一步：删除不用的&lt;/span&gt;Collection&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http://192.168.25.132:8180/solr/admin/collections?action=DELETE&amp;amp;name=collection1&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235507827-558217709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;6.1. 添加文档&lt;/h2&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：把&lt;/span&gt;solrJ&lt;span&gt;相关的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包添加到工程中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;SolrServer&lt;span&gt;对象，需要使用&lt;/span&gt;&lt;span&gt;CloudSolrServer&lt;/span&gt;&lt;span&gt;子类。构造方法的参数是&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;的地址列表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第三步：需要设置&lt;/span&gt;DefaultCollection&lt;span&gt;属性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：创建一&lt;/span&gt;SolrInputDocument&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第五步：向文档对象中添加域&lt;/p&gt;
&lt;p&gt;第六步：把文档对象写入索引库。&lt;/p&gt;
&lt;p&gt;第七步：提交。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSolrCloudAddDocument() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：把solrJ相关的jar包添加到工程中。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是zookeeper的地址列表，使用逗号分隔&lt;/span&gt;
&lt;span&gt;        CloudSolrServer solrServer = &lt;span&gt;new&lt;/span&gt; CloudSolrServer(&quot;192.168.25.132:2181,192.168.25.132:2182,192.168.25.132:2183&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：需要设置DefaultCollection属性。&lt;/span&gt;
        solrServer.setDefaultCollection(&quot;collection2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：创建一SolrInputDocument对象。&lt;/span&gt;
        SolrInputDocument document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolrInputDocument();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：向文档对象中添加域&lt;/span&gt;
        document.addField(&quot;item_title&quot;, &quot;测试商品&quot;&lt;span&gt;);
        document.addField(&lt;/span&gt;&quot;item_price&quot;, &quot;100&quot;&lt;span&gt;);
        document.addField(&lt;/span&gt;&quot;id&quot;, &quot;test001&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：把文档对象写入索引库。&lt;/span&gt;
&lt;span&gt;        solrServer.add(document);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：提交。&lt;/span&gt;
&lt;span&gt;        solrServer.commit();

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;6.2. 查询文档&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个&lt;/span&gt;CloudSolrServer&lt;span&gt;对象，其他处理和单机版一致。&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt; xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt; xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans4.2.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context4.2.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx4.2.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util4.2.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 单机版solr服务配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;bean id=&quot;httpSolrServer&quot; class=&quot;org.apache.solr.client.solrj.impl.HttpSolrServer&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;baseURL&quot; value=&quot;http://192.168.25.132:8080/solr&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 集群版solr服务 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;cloudSolrServer&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.apache.solr.client.solrj.impl.CloudSolrServer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;zkHost&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;192.168.25.132:2181,192.168.25.132:2182,192.168.25.132:2183&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultCollection&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;collection2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;8. &lt;/span&gt;&lt;strong&gt;全局异常处理&lt;/strong&gt; &lt;/p&gt;
&lt;h2&gt;8.1. 处理思路&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235625427-521798721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;8.2. 创建全局异常处理器&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GlobalExceptionReslover &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerExceptionResolver {

    Logger logger &lt;/span&gt;= LoggerFactory.getLogger(GlobalExceptionReslover.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
            Exception ex) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写日志文件&lt;/span&gt;
        logger.error(&quot;系统发生异常&quot;&lt;span&gt;, ex);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发邮件、发短信
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Jmail：可以查找相关的资料
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要在购买短信。调用第三方接口即可。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示错误页面&lt;/span&gt;
        ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
        modelAndView.addObject(&lt;/span&gt;&quot;message&quot;, &quot;系统发生异常，请稍后重试&quot;&lt;span&gt;);
        modelAndView.setViewName(&lt;/span&gt;&quot;error/exception&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;8.3. Springmvc&lt;/span&gt;&lt;span&gt;中配置异常处理器&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235645582-430024695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt;方案一：在&lt;/span&gt;taotao-manager&lt;span&gt;中，添加商品的业务逻辑中，添加一个同步索引库的业务逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;缺点：业务逻辑耦合度高，业务拆分不明确&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案二：业务逻辑在&lt;/span&gt;taotao-search&lt;span&gt;中实现，调用服务在&lt;/span&gt;&lt;span&gt;taotao-manager&lt;/span&gt;&lt;span&gt;实现。业务逻辑分开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;缺点：服务之间的耦合度变高。服务的启动有先后顺序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案三：使用消息队列。&lt;/span&gt;MQ&lt;span&gt;是一个消息中间件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235812115-1456628460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;MQ&lt;span&gt;是一个消息中间件，&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kafka&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;10.1. &lt;span&gt;什么是&lt;/span&gt;ActiveMQ&lt;/h2&gt;
&lt;p&gt;ActiveMQ &lt;span&gt;是&lt;/span&gt;&lt;span&gt;Apache&lt;/span&gt;&lt;span&gt;出品，最流行的，能力强劲的开源消息总线。&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt; &lt;span&gt;是一个完全支持&lt;/span&gt;&lt;span&gt;JMS1.1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;J2EE 1.4&lt;/span&gt;&lt;span&gt;规范的&lt;/span&gt; &lt;span&gt;JMS Provider&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;尽管&lt;/span&gt;&lt;span&gt;JMS&lt;/span&gt;&lt;span&gt;规范出台已经是很久的事情了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是&lt;/span&gt;&lt;span&gt;JMS&lt;/span&gt;&lt;span&gt;在当今的&lt;/span&gt;&lt;span&gt;J2EE&lt;/span&gt;&lt;span&gt;应用中间仍然扮演着特殊的地位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;多种语言和协议编写客户端。语言&lt;/span&gt;&lt;span&gt;: Java, C, C++, C#, Ruby, Perl, Python, PHP&lt;/span&gt;&lt;span&gt;。应用协议&lt;/span&gt;&lt;span&gt;: OpenWire,Stomp REST,WS Notification,XMPP,AMQP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;完全支持&lt;/span&gt;&lt;span&gt;JMS1.1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;J2EE 1.4&lt;/span&gt;&lt;span&gt;规范&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;持久化&lt;/span&gt;&lt;span&gt;,XA&lt;/span&gt;&lt;span&gt;消息&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;事务&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;对&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;的支持&lt;/span&gt;&lt;span&gt;,ActiveMQ&lt;/span&gt;&lt;span&gt;可以很容易内嵌到使用&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;的系统里面去&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而且也支持&lt;/span&gt;&lt;span&gt;Spring2.0&lt;/span&gt;&lt;span&gt;的特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;通过了常见&lt;/span&gt;&lt;span&gt;J2EE&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;如&lt;/span&gt; &lt;span&gt;Geronimo,JBoss 4, GlassFish,WebLogic)&lt;/span&gt;&lt;span&gt;的测试&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;其中通过&lt;/span&gt;&lt;span&gt;JCA 1.5 resource adaptors&lt;/span&gt;&lt;span&gt;的配置&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可以让&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;span&gt;可以自动的部署到任何兼容&lt;/span&gt;&lt;span&gt;J2EE 1.4&lt;/span&gt; &lt;span&gt;商业服务器上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;支持多种传送协议&lt;/span&gt;&lt;span&gt;:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;span&gt;支持通过&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;journal&lt;/span&gt;&lt;span&gt;提供高速的消息持久化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;span&gt;从设计上保证了高性能的集群&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;点对点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. &lt;span&gt;支持&lt;/span&gt;&lt;span&gt;Ajax&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9. &lt;span&gt;支持与&lt;/span&gt;&lt;span&gt;Axis&lt;/span&gt;&lt;span&gt;的整合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10. &lt;span&gt;可以很容易得调用内嵌&lt;/span&gt;&lt;span&gt;JMS provider,&lt;/span&gt;&lt;span&gt;进行测试&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;10.2. ActiveMQ&lt;span&gt;的消息形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于消息的传递有两种类型：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一种是点对点的&lt;/strong&gt;&lt;/span&gt;，即一个生产者和一个消费者一一对应；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;另一种是发布&lt;/span&gt;/&lt;span&gt;订阅模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。&lt;/p&gt;
&lt;p&gt;JMS&lt;span&gt;定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;· &lt;span&gt;StreamMessage -- Java&lt;/span&gt;&lt;span&gt;原始值的数据流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;· &lt;span&gt;MapMessage--&lt;/span&gt;&lt;span&gt;一套名称&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;值对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;· &lt;span&gt;TextMessage--&lt;/span&gt;&lt;span&gt;一个字符串对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;· &lt;span&gt;ObjectMessage--&lt;/span&gt;&lt;span&gt;一个序列化的&lt;/span&gt; &lt;span&gt;Java&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;· &lt;span&gt;BytesMessage--&lt;/span&gt;&lt;span&gt;一个字节的数据流&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进入&lt;/span&gt;http://activemq.apache.org/&lt;span&gt;下载&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235847090-2142099641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用的版本是&lt;/span&gt;5.12.0&lt;/p&gt;

&lt;h2&gt;11.1. 安装环境：&lt;/h2&gt;
&lt;p&gt;1、&lt;span&gt;需要&lt;/span&gt;jdk&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;安装&lt;/span&gt;Linux&lt;span&gt;系统。生产环境都是&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;11.2. 安装步骤&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：&lt;/span&gt; &lt;span&gt;把&lt;/span&gt;ActiveMQ &lt;span&gt;的压缩包上传到&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二步：解压缩。&lt;/p&gt;
&lt;p&gt;第三步：启动。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;bin&lt;span&gt;目录下的&lt;/span&gt;&lt;span&gt;activemq&lt;/span&gt;&lt;span&gt;命令启动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost bin]# ./activemq start&lt;/p&gt;
&lt;p&gt;关闭：&lt;/p&gt;
&lt;p&gt;[root@localhost bin]# ./activemq stop&lt;/p&gt;
&lt;p&gt;查看状态：&lt;/p&gt;
&lt;p&gt;[root@localhost bin]# ./activemq status&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：如果&lt;/span&gt;ActiveMQ&lt;span&gt;整合&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;使用不要使用&lt;/span&gt;&lt;span&gt;activemq-all-5.12.0.jar&lt;/span&gt;&lt;span&gt;包。建议使用&lt;/span&gt;&lt;span&gt;5.11.2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;进入管理后台：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://192.168.25.168:8161/admin&quot;&gt;&lt;span&gt;http://192.168.25.168:&lt;/span&gt;&lt;span&gt;8161&lt;/span&gt;&lt;span&gt;/admin&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户名：&lt;/span&gt;admin&lt;/p&gt;
&lt;p&gt;&lt;span&gt;密码：&lt;/span&gt;admin&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235904774-687291728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;11.3. 解决405&lt;span&gt;问题：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;hosts&lt;span&gt;文件，配置机器名和&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;的映射关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;机器名：&lt;/span&gt;/etc/sysconfig/network&lt;span&gt;文件中定义了机器名：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235909734-1293472790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Host&lt;span&gt;文件的配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235912791-775041612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重新启动Activemq&lt;span&gt;的服务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235919407-1057088714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;12.1. Queue&lt;/h2&gt;
&lt;h3&gt;12.1.1. Producer&lt;/h3&gt;
&lt;p&gt;生产者：生产消息，发送端。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把&lt;/span&gt;jar&lt;span&gt;包添加到工程中。使用&lt;/span&gt;&lt;span&gt;5.11.2&lt;/span&gt;&lt;span&gt;版本的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180727235925888-1211520580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一步：创建&lt;/span&gt;ConnectionFactory&lt;span&gt;对象，需要指定服务端&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;及端口号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：使用&lt;/span&gt;ConnectionFactory&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：开启连接，调用&lt;/span&gt;Connection&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;Connection&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Destination&lt;/span&gt;&lt;span&gt;对象（&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;），此处创建一个&lt;/span&gt;&lt;span&gt;Queue&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：创建一个&lt;/span&gt;Message&lt;span&gt;对象，创建一个&lt;/span&gt;&lt;span&gt;TextMessage&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第八步：使用&lt;/span&gt;Producer&lt;span&gt;对象发送消息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第九步：关闭资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueueProducer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;brokerURL服务器的ip及端口号&lt;/span&gt;
        ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;tcp://192.168.25.168:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：使用ConnectionFactory对象创建一个Connection对象。&lt;/span&gt;
        Connection connection =&lt;span&gt; connectionFactory.createConnection();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：开启连接，调用Connection对象的start方法。&lt;/span&gt;
&lt;span&gt;        connection.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：使用Connection对象创建一个Session对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数：是否开启事务。true：开启事务，第二个参数忽略。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。&lt;/span&gt;
        Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数：队列的名称。&lt;/span&gt;
        Queue queue = session.createQueue(&quot;test-queue&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：使用Session对象创建一个Producer对象。&lt;/span&gt;
        MessageProducer producer =&lt;span&gt; session.createProducer(queue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：创建一个Message对象，创建一个TextMessage对象。&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;TextMessage message = new ActiveMQTextMessage();
        message.setText(&quot;hello activeMq,this is my first test.&quot;);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TextMessage textMessage &lt;/span&gt;= session.createTextMessage(&quot;hello activeMq,this is my first test.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步：使用Producer对象发送消息。&lt;/span&gt;
&lt;span&gt;        producer.send(textMessage);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第九步：关闭资源。&lt;/span&gt;
&lt;span&gt;        producer.close();
        session.close();
        connection.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;12.1.2. Consumer&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;消费者：接收消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;ConnectionFactory&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：从&lt;/span&gt;ConnectionFactory&lt;span&gt;对象中获得一个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：开启连接。调用&lt;/span&gt;Connection&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;Connection&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Destination&lt;/span&gt;&lt;span&gt;对象。和发送端保持一致&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;，并且队列的名称一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第七步：接收消息。&lt;/p&gt;
&lt;p&gt;第八步：打印消息。&lt;/p&gt;
&lt;p&gt;第九步：关闭资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueueConsumer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：创建一个ConnectionFactory对象。&lt;/span&gt;
        ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;tcp://192.168.25.168:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：从ConnectionFactory对象中获得一个Connection对象。&lt;/span&gt;
        Connection connection =&lt;span&gt; connectionFactory.createConnection();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：开启连接。调用Connection对象的start方法。&lt;/span&gt;
&lt;span&gt;        connection.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：使用Connection对象创建一个Session对象。&lt;/span&gt;
        Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。&lt;/span&gt;
        Queue queue = session.createQueue(&quot;test-queue&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：使用Session对象创建一个Consumer对象。&lt;/span&gt;
        MessageConsumer consumer =&lt;span&gt; session.createConsumer(queue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：接收消息。&lt;/span&gt;
        consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    TextMessage textMessage &lt;/span&gt;=&lt;span&gt; (TextMessage) message;
                    String text &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消息的内容&lt;/span&gt;
                    text =&lt;span&gt; textMessage.getText();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步：打印消息。&lt;/span&gt;
&lt;span&gt;                    System.out.println(text);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待键盘输入&lt;/span&gt;
&lt;span&gt;        System.in.read();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第九步：关闭资源&lt;/span&gt;
&lt;span&gt;        consumer.close();
        session.close();
        connection.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;12.2. Topic&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;12.2.1. Producer&lt;/h3&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：创建&lt;/span&gt;ConnectionFactory&lt;span&gt;对象，需要指定服务端&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;及端口号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：使用&lt;/span&gt;ConnectionFactory&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：开启连接，调用&lt;/span&gt;Connection&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;Connection&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Destination&lt;/span&gt;&lt;span&gt;对象（&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;），此处创建一个&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：创建一个&lt;/span&gt;Message&lt;span&gt;对象，创建一个&lt;/span&gt;&lt;span&gt;TextMessage&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第八步：使用&lt;/span&gt;Producer&lt;span&gt;对象发送消息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第九步：关闭资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTopicProducer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; brokerURL服务器的ip及端口号&lt;/span&gt;
        ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;tcp://192.168.25.168:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：使用ConnectionFactory对象创建一个Connection对象。&lt;/span&gt;
        Connection connection =&lt;span&gt; connectionFactory.createConnection();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：开启连接，调用Connection对象的start方法。&lt;/span&gt;
&lt;span&gt;        connection.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：使用Connection对象创建一个Session对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。&lt;/span&gt;
        Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数：话题的名称。&lt;/span&gt;
        Topic topic = session.createTopic(&quot;test-topic&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：使用Session对象创建一个Producer对象。&lt;/span&gt;
        MessageProducer producer =&lt;span&gt; session.createProducer(topic);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：创建一个Message对象，创建一个TextMessage对象。&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * TextMessage message = new ActiveMQTextMessage(); message.setText(
         * &quot;hello activeMq,this is my first test.&quot;);
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        TextMessage textMessage &lt;/span&gt;= session.createTextMessage(&quot;hello activeMq,this is my topic test&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步：使用Producer对象发送消息。&lt;/span&gt;
&lt;span&gt;        producer.send(textMessage);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第九步：关闭资源。&lt;/span&gt;
&lt;span&gt;        producer.close();
        session.close();
        connection.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;12.2.2. Consumer&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;消费者：接收消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;ConnectionFactory&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：从&lt;/span&gt;ConnectionFactory&lt;span&gt;对象中获得一个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：开启连接。调用&lt;/span&gt;Connection&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;Connection&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Destination&lt;/span&gt;&lt;span&gt;对象。和发送端保持一致&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;，并且话题的名称一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：使用&lt;/span&gt;Session&lt;span&gt;对象创建一个&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第七步：接收消息。&lt;/p&gt;
&lt;p&gt;第八步：打印消息。&lt;/p&gt;
&lt;p&gt;第九步：关闭资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTopicConsumer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步：创建一个ConnectionFactory对象。&lt;/span&gt;
        ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;tcp://192.168.25.168:61616&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：从ConnectionFactory对象中获得一个Connection对象。&lt;/span&gt;
        Connection connection =&lt;span&gt; connectionFactory.createConnection();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：开启连接。调用Connection对象的start方法。&lt;/span&gt;
&lt;span&gt;        connection.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步：使用Connection对象创建一个Session对象。&lt;/span&gt;
        Session session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.AUTO_ACKNOWLEDGE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。&lt;/span&gt;
        Topic topic = session.createTopic(&quot;test-topic&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步：使用Session对象创建一个Consumer对象。&lt;/span&gt;
        MessageConsumer consumer =&lt;span&gt; session.createConsumer(topic);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步：接收消息。&lt;/span&gt;
        consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    TextMessage textMessage &lt;/span&gt;=&lt;span&gt; (TextMessage) message;
                    String text &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消息的内容&lt;/span&gt;
                    text =&lt;span&gt; textMessage.getText();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步：打印消息。&lt;/span&gt;
&lt;span&gt;                    System.out.println(text);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
        System.out.println(&lt;/span&gt;&quot;topic的消费端03。。。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待键盘输入&lt;/span&gt;
&lt;span&gt;        System.in.read();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第九步：关闭资源&lt;/span&gt;
&lt;span&gt;        consumer.close();
        session.close();
        connection.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 27 Jul 2018 16:01:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9380299.html</dc:identifier>
</item>
<item>
<title>Python学习：17.Python面向对象（四、属性（特性），成员修饰符） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9380280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9380280.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;一、属性（特性）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;普通方法去执行的时候，后面需要加括号，特性方法执行的时候和静态字段一样不需要不需要加括号.&lt;/p&gt;
&lt;p&gt;特性方法不和字段同名.&lt;/p&gt;
&lt;p&gt;特性方法不能传参数.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;获取特性&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ret1 &lt;/span&gt;=&lt;span&gt; obj.start()
ret2 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.name)


输出结果：
alexsel gd
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;设置特性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;设置特性方法的时候，所需要加的装饰器名字规则是，你所设置特性方法名字点setter（例如：@end.setter）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果需要使用设置特性的的方法，就需要这个点前面名字和所要设置特性的方法同名，就像这里的end&lt;/span&gt;
&lt;span&gt;    @end.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self,value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(value)
        self.name &lt;/span&gt;=&lt;span&gt; value

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取特性,获取特性的时候，拿到的是@Property的返回值&lt;/span&gt;
ret2 =&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置特性，设置特性的时候，会执行@end.setter下面的方法，这个'aaa'就传递给value&lt;/span&gt;
obj.end = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ret1 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret1)


输出结果：
alexsel gd
aaa
aaa gd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个特性在python中不是特别常用，因为我们一般可以使用普通的方法代替特性方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、成员修饰符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;首先介绍‘__’，这个在命名之前添加就会变成私有的，只有在类的内部才能访问。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;命名的时候前面添加__，只有在类的内部才能访问，在外部无法访问&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.book)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.__book) #这种无法拿到字段&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在外部也无法调用类私有方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;obj.__end()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;通过内部方法调用拿到字段&lt;/span&gt;
&lt;span&gt;obj.start()


输出结果：
alexsel
book
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;私有的属性只有自己可以访问，当某个类继承这个类之后，也无法访问父类的私有属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)
        self.&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;()


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar(Foo):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子类继承父类，也无法调用父类的私有属性&lt;/span&gt;
&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Bar()
obj.start()

输出结果：
报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态方法也是如此&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
obj.start()


输出结果：
add&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python成员修饰符有两种，一种是共有的，一种是私有的，共有的都可以访问，私有的只有自己可以访问，或者在外部间接访问。&lt;/p&gt;
&lt;p&gt;但是还有一种强行访问私有属性的方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj._Foo__book)


输出结果：
book&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然可以使用，但是不推荐这种使用方法。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:55:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9380280.html</dc:identifier>
</item>
<item>
<title>数素数 (20) - cxq2016</title>
<link>http://www.cnblogs.com/cxq2016/p/9380275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxq2016/p/9380275.html</guid>
<description>&lt;p&gt;
&lt;h3&gt;数素数 (20)&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;pat-detail-info&quot; readability=&quot;7.5826086956522&quot;&gt;时间限制 1000 ms 内存限制 32768 KB 代码长度限制 100 KB 判断程序 Standard (来自 &lt;a class=&quot;link-green&quot; href=&quot;https://www.nowcoder.com/profile/59&quot;&gt;小小&lt;/a&gt;)&lt;/div&gt;
&lt;div class=&quot;module-body&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;subject-des&quot; readability=&quot;20&quot;&gt;
&lt;h3&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
令Pi表示第i个素数。现任给两个正整数M &amp;lt;= N &amp;lt;= 10000，请输出PM到PN的所有素数。
&lt;/pre&gt;
&lt;br/&gt;&lt;h3&gt;&lt;strong&gt;输入描述:&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
输入在一行中给出M和N，其间以空格分隔。
&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;输出描述:&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。
&lt;/pre&gt;
&lt;br/&gt;&lt;h3&gt;&lt;strong&gt;输入例子:&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
5 27
&lt;/pre&gt;
&lt;br/&gt;&lt;h3&gt;&lt;strong&gt;输出例子:&lt;/strong&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5&quot;&gt;
11 13 17 19 23 29 31 37 41 43&lt;p&gt;47 53 59 61 67 71 73 79 83 89&lt;/p&gt;&lt;p&gt;97 101 103
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
const int M=104735;
int f[M];
void isPrime(){
        f[1]=1;
        for(int i=2;i*i&amp;lt;=M;i++){
                if(!f[i]){
                        for(int j=2;j*i&amp;lt;=M;j++){
                                f[j*i]=1;
                        }
                }
        }
}
                        
int main(){
        isPrime();
        int m,n,i,j;
        cin&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n;
        int cnt=0;
        if(m==1&amp;amp;&amp;amp;n==1){
                cout&amp;lt;&amp;lt;2&amp;lt;&amp;lt;endl;
                return 0;
        }
        for(i=2;cnt&amp;lt;m-1;i++){
                if(!f[i]){
                        cnt++;
                }               
        }
        cnt=0;
        for(j=i+1;cnt&amp;lt;n-m+1;j++){
                
                if(!f[j]){
                        cout&amp;lt;&amp;lt;j;
                        cnt++;
                        if(cnt%10==0||cnt==n-m+1) cout&amp;lt;&amp;lt;endl;
                        else cout&amp;lt;&amp;lt;&quot; &quot;;
                }
        }
        return 0;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:54:00 +0000</pubDate>
<dc:creator>cxq2016</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxq2016/p/9380275.html</dc:identifier>
</item>
<item>
<title>TDD尝试：nodejs单元测试 - freephp</title>
<link>http://www.cnblogs.com/freephp/p/9380257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freephp/p/9380257.html</guid>
<description>&lt;p&gt;&lt;span&gt;单元测试是最小化的测试方式，也是&lt;/span&gt;TDD&lt;span&gt;的做法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TDD&lt;span&gt;概念如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/782095/201807/782095-20180727234735947-66104101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;通过测试反馈推进开发，&lt;/span&gt;ruby&lt;span&gt;是推崇这种编程方式的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;nodejs&lt;span&gt;有如下常用单元测试模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.mocha&lt;/p&gt;
&lt;p&gt;Mocha&lt;span&gt;是一个基于&lt;/span&gt;&lt;span&gt;node.js&lt;/span&gt;&lt;span&gt;和浏览器的集合各种特性的&lt;/span&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;span&gt;测试框架，并且可以让异步测试也变的简单和有趣。&lt;/span&gt;&lt;span&gt;Mocha&lt;/span&gt;&lt;span&gt;的测试是连续的，在正确的测试条件中遇到未捕获的异常时，会给出灵活且准确的报告。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install -g mocha
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const assert = require(&quot;assert&quot;&lt;span&gt;);

describe(&lt;/span&gt;'Array', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    describe(&lt;/span&gt;'#indexOf()', () =&amp;gt;&lt;span&gt; {
        it(&lt;/span&gt;'should return -1 when the value is not present', () =&amp;gt;&lt;span&gt;{
            assert.equal(&lt;/span&gt;-1, [1,2,3].indexOf(5&lt;span&gt;));
            assert.equal(&lt;/span&gt;-1, [1,2,3].indexOf(0&lt;span&gt;));
        });
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;describe里面第一个参数为输出展示该测试段的目标，第二个参数为回调，里面写需要测试的case。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进行测试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mocha filename
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;可以用于测试&lt;/span&gt;utils&lt;span&gt;里面封装的常用函数，个人认为适合一些非&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;请求类代码测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.should&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
require(&quot;should&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = &quot;tonny&quot;&lt;span&gt;;

 

describe(&lt;/span&gt;&quot;Name&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

    it(&lt;/span&gt;&quot;The name should be tonny&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

        name.should.eql(&lt;/span&gt;&quot;tonny&quot;&lt;span&gt;);

    });

});

 

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;

};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; zhaojian = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(name);

 

describe(&lt;/span&gt;&quot;InstanceOf&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

    it(&lt;/span&gt;&quot;Zhaojian should be an instance of Person&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

        zhaojian.should.be.an.&lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt;(Person);

    });

 

    it(&lt;/span&gt;&quot;Zhaojian should be an instance of Object&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

        zhaojian.should.be.an.&lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt;(Object);

    });

});

describe(&lt;/span&gt;&quot;Property&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

    it(&lt;/span&gt;&quot;Zhaojian should have property name&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

        zhaojian.should.have.property(&lt;/span&gt;&quot;name&quot;&lt;span&gt;);

    });

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;should&lt;span&gt;的用法让测试代码可读性更强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.supertest&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于&lt;/span&gt;http&lt;span&gt;请求测试。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; request = require('supertest'&lt;span&gt;);
const express &lt;/span&gt;= require('express'&lt;span&gt;);

&lt;/span&gt;const app =&lt;span&gt; express();

app.get(&lt;/span&gt;'/user', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res){
  res.send(&lt;/span&gt;200, { name: 'tobi'&lt;span&gt; });
});

request(app)
  .get(&lt;/span&gt;'/user'&lt;span&gt;)
  .expect(&lt;/span&gt;'Content-Type', /json/&lt;span&gt;)
  .expect(&lt;/span&gt;'Content-Length', '20'&lt;span&gt;)
  .expect(&lt;/span&gt;200&lt;span&gt;)
  .end(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err, res){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
  });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;之前我们遇到的中间件检查问题，就可以通过这个模块来进行不同&lt;/span&gt;case&lt;span&gt;的测试，保证接口逻辑上无偏差。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;4.istanbul &lt;span&gt;代码覆盖率检查工具&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用法&lt;/span&gt; :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
istanbul cover filename
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;命令行模式会显示覆盖率情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后会生成&lt;/span&gt;coverage&lt;span&gt;文件夹，里面有&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;方式生成的覆盖率报表。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实单元测试在一些业务相对稳定，但是逻辑情况比较复杂的项目中可以对于一些重要的代码进行全覆盖测试，代码的稳健不光是靠编程技术和思维，也需要一定的辅助测试，在多人团队协作开发中愈发重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单元测试和编程语言类型&lt;span&gt;无关&lt;/span&gt;，它是一种良好的&lt;span&gt;编程习惯&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:48:00 +0000</pubDate>
<dc:creator>freephp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freephp/p/9380257.html</dc:identifier>
</item>
<item>
<title>Python全栈工程师（异常（高级）、运算符重载） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9380227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9380227.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;ParisGabriel&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象的属性管理函数:&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;getattr(&lt;/strong&gt;&lt;/span&gt;obj, name[,default)&lt;br/&gt;　　　　从对象&lt;strong&gt;得到对象&lt;/strong&gt;的&lt;strong&gt;属性&lt;/strong&gt;，getattr（x， “y”） 等同于x， y &lt;strong&gt;当&lt;/strong&gt;属性&lt;br/&gt;　　　　&lt;strong&gt;不存在时&lt;/strong&gt; 如果&lt;strong&gt;给&lt;/strong&gt;出&lt;strong&gt;default&lt;/strong&gt;参数则&lt;strong&gt;返回default&lt;/strong&gt;&lt;br/&gt;　　　　如果&lt;strong&gt;没&lt;/strong&gt;有&lt;strong&gt;给出default&lt;/strong&gt; ，&lt;strong&gt;则&lt;/strong&gt;产生一个&lt;strong&gt;AttributeError错误&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;hasattr&lt;/span&gt;&lt;/strong&gt;（obj， name）用&lt;strong&gt;给定&lt;/strong&gt;的&lt;strong&gt;name返回&lt;/strong&gt;对象obj&lt;strong&gt;是否有此属性&lt;/strong&gt;&lt;br/&gt;　　　　此种做法可以&lt;strong&gt;避免&lt;/strong&gt;在&lt;strong&gt;getattr&lt;/strong&gt;（obj，name）时引发&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;setattr&lt;/strong&gt;&lt;/span&gt;(obj, name, value) &lt;strong&gt;给&lt;/strong&gt;对象obj的名为name的&lt;br/&gt;　　　　&lt;strong&gt;属性设置相应的值&lt;/strong&gt;value, set(x, 'y', v) 等同于 x.y = v&lt;/p&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;delattr&lt;/strong&gt;&lt;/span&gt;(obj, name) &lt;strong&gt;删除&lt;/strong&gt;对象obj中的name&lt;strong&gt;属性&lt;/strong&gt;&lt;br/&gt;,　　　　 delattr(x, 'y') 等同于 del x.y&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


d &lt;/span&gt;=&lt;span&gt; Dog()
d.color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;白色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

v &lt;/span&gt;= getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于 v = d.color&lt;/span&gt;
v = getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出错,没有d.kinds属性&lt;/span&gt;
v = getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这个属性&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v= '没有这个属性'&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
setattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;京巴&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于d.kinds ='京巴'&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
delattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于 del d.kinds&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异常（高级）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;可以用于异常的语句&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;try-except&lt;/span&gt;&lt;/strong&gt; # &lt;strong&gt;捕获异常&lt;/strong&gt;，得到通知&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;try-finally&lt;/span&gt;&lt;/strong&gt; # 左任何流程（正常/异常）都必须&lt;strong&gt;执行要执行的语句&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;raise&lt;/strong&gt;&lt;/span&gt; # &lt;strong&gt;发送异常&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;assert&lt;/strong&gt;&lt;/span&gt; # 根据条件&lt;strong&gt;发送异常&lt;/strong&gt;通知&lt;br/&gt;&lt;strong&gt;&lt;span&gt;with&lt;/span&gt; 语句：&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;语法&lt;/strong&gt;：&lt;br/&gt;　　　　with 表达式1[as 变量1]， 表达式2[as 变量2]....&lt;br/&gt;　　&lt;strong&gt;作用&lt;/strong&gt;：&lt;br/&gt;　　　　使用与对资源进行访问的场合，确保使用过程中&lt;strong&gt;不管&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;是否&lt;/strong&gt;发生&lt;strong&gt;异常都会执行&lt;/strong&gt;必要的&lt;span&gt;&lt;strong&gt;“清理操作”&lt;/strong&gt;&lt;/span&gt;，并&lt;strong&gt;释放资源&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;（如： 文件使用后自动关闭，线程中锁的自动获取和释放等）&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;说明&lt;/strong&gt;：&lt;br/&gt;　　　　执行表达式，&lt;span&gt;as&lt;/span&gt;子句中的&lt;strong&gt;变量绑定生成的对象&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;with语句&lt;/strong&gt;并&lt;strong&gt;不改变异常&lt;/strong&gt;的状态&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; with语句打开文件和自动关闭&lt;/span&gt;


&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
            int(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出现异常&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件操作过程中错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; try-finally语句打开文件和关闭&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件操作过程中错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改原来的copy文件功能&lt;/span&gt;
&lt;span&gt;
src_filename &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入源文件路径名: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
dst_filename &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入目标文件路径名: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    with open(src_filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as src,\
            open(dst_filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as dst:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开源文件用来读数据&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                    b &lt;/span&gt;= src.read(4096&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; b:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已经再也读不到数据了&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
                    dst.write(b)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;环境管理器：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;类内有&lt;span&gt;__enter__&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;__exit__&lt;/span&gt;&lt;/strong&gt;实例&lt;strong&gt;方法&lt;/strong&gt;的类&lt;strong&gt;被称为环境管理器&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;能&lt;/strong&gt;够用&lt;span&gt;&lt;strong&gt;with&lt;/strong&gt;&lt;/span&gt;进行&lt;strong&gt;管理的&lt;/strong&gt;对象&lt;strong&gt;必须是环境管理器&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;__enter__&lt;/span&gt;将在&lt;strong&gt;进入with语句时被调&lt;/strong&gt;用并返回由as变量绑定的对象&lt;br/&gt;　　　　&lt;span&gt;__exit__&lt;/span&gt;将在&lt;strong&gt;离开with语句时被调用&lt;/strong&gt;，且&lt;strong&gt;可以用参数来判断&lt;/strong&gt;在&lt;br/&gt;　　　　&lt;strong&gt;离开&lt;/strong&gt;with语句&lt;strong&gt;时是否有异常&lt;/strong&gt;发生&lt;strong&gt;并&lt;/strong&gt;作出相应的&lt;strong&gt;处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个自定义的类创建的对象能够使用ｗｉｔｈ语句&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;此类的对象可用于ｗｉｔｈ语句进行管理&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经进入ｗｉｔｈ语句中，资源分配成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;&amp;lt;&amp;lt;-- 此处返回的对象将由as变量绑定&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(self, exc_type, exc_val, exc_tb):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;离开ｗｉｔｈ语句,资源释放成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; exc_type &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当离开ｗｉｔｈ语句时没有异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;有异常发生　异常类型：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,exc_type , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  exc_val)


with A() as a:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是ｗｉｔｈ语句中的语句&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;故意制造的异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;运算符重载：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;什么是运算符重载&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;让自定义的类生成的对象（实例）能够使用运算符进行操作&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　1.让&lt;span&gt;自定义&lt;/span&gt;的类的实例&lt;span&gt;能&lt;/span&gt;够运行&lt;span&gt;运算符操作&lt;/span&gt;&lt;br/&gt;　　　　2.让程序简洁易读&lt;br/&gt;　　　　3.对定义对象&lt;strong&gt;将运算符赋予新的运算规则&lt;/strong&gt;&lt;br/&gt;　&lt;strong&gt;　说明：&lt;/strong&gt;&lt;br/&gt;　　　　运算符重载方法的参数已经有固定含义，不建议改变原有的含义&lt;br/&gt;　　　　算数运算符重载：&lt;/p&gt;&lt;p&gt;方法名 　　　　　　 　　　　 运算符和表达式 　　　　　　 说明&lt;br/&gt;&lt;span&gt;__add__&lt;/span&gt;(self, rhs) 　　 　　　　  self + rsh 　　　　　　　　 加法&lt;br/&gt;&lt;span&gt;__sub__&lt;/span&gt;(self, rhs) 　　　　　　   self - rsh 　　　　　　　　  减法&lt;br/&gt;&lt;span&gt;__mul__&lt;/span&gt;(self, rhs) 　　　　　　   self * rsh 　　　　　　　　  乘法&lt;br/&gt;&lt;span&gt;__truediv__&lt;/span&gt;(self, rhs) 　　　　     self / rsh 　　　　　　　　   除法&lt;br/&gt;&lt;span&gt;__floordiv__&lt;/span&gt;(self, rhs) 　　　　     self // rsh 　　　　　　        地板除&lt;br/&gt;&lt;span&gt;__mod__&lt;/span&gt;(self, rhs) 　　　　　　  self % rsh 　　　　　　　    求模&lt;br/&gt;&lt;span&gt;__pow__&lt;/span&gt;(self, rhs) 　　　　          self ** rsh 　　　　　　　　  幂&lt;/p&gt;
&lt;p&gt;rhs（self hand side） &lt;span&gt;右手边&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyNumber:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, val):
        self.data &lt;/span&gt;=&lt;span&gt; val

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self, rsh):
        v &lt;/span&gt;= self.data +&lt;span&gt; rsh.data
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; MyNumber(v)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;&lt;span&gt;(self, rsh):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyNumber(self.data -&lt;span&gt; rsh.data)


n1 &lt;/span&gt;= MyNumber(100&lt;span&gt;)
n2 &lt;/span&gt;= MyNumber(200&lt;span&gt;)
n3 &lt;/span&gt;= n1 + n2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于　n3 = n1.__add__(n2)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; n3 = n1.__add__(n2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(t(n1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n1 - n2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;反向算术运算符的重载&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;当&lt;/strong&gt;运算符的&lt;strong&gt;左侧为内建类型,右侧为自义类型&lt;/strong&gt;的对象&lt;strong&gt;进行算术运算&lt;/strong&gt;符运算&lt;strong&gt;时&lt;/strong&gt;,&lt;strong&gt;会出现&lt;span&gt;TypeError&lt;/span&gt;错误,&lt;/strong&gt;&lt;br/&gt;　　因&lt;strong&gt;无法修改内建类&lt;/strong&gt;的代码来实现运算符重载,&lt;strong&gt;此时需要使用反向&lt;/strong&gt;算术运算符&lt;strong&gt;重载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反向算术运算符重载&lt;br/&gt;方法名 　　　　　　　　　　 运算符和表达式                         说明&lt;br/&gt;&lt;span&gt;__radd__&lt;/span&gt;(self, lhs) 　　　　　　 lhs + self 　　　　　　　 　 加法&lt;br/&gt;&lt;span&gt;__rsub__&lt;/span&gt;(self, lhs) 　　　　　　 lhs - self 　　　　　　　  　 减法&lt;br/&gt;&lt;span&gt;__rmul__&lt;/span&gt;(self, lhs)　　　　　　  lhs * self　　　　　　　   　 乘法&lt;br/&gt;&lt;span&gt;__rtruediv__&lt;/span&gt;(self, lhs)　　　　　lhs / self 　　　　　　  　 　 除法&lt;br/&gt;&lt;span&gt;__rfloordiv__&lt;/span&gt;(self, lhs)　　　　   lhs // self　　　　　　 　  　 地板除&lt;br/&gt;&lt;span&gt;__rmod__&lt;/span&gt;(self, lhs) 　　　　       lhs % self 　　　　　　        取模(求余)&lt;br/&gt;&lt;span&gt;__rpow__&lt;/span&gt;(self, lhs)　　　　　    lhs ** self 　　　　　　　  　 幂&lt;/p&gt;
&lt;p&gt;lhs(left hand side) 右手边&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意返向算述运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__mul__&lt;/span&gt;&lt;span&gt;(self, rhs):

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta *&lt;span&gt; rhs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__mul__　被到调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__rmul__&lt;/span&gt;&lt;span&gt;(self, lhs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__rmul__　被到调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta * lhs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向传参&lt;/span&gt;
&lt;span&gt;

L1 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])
L2 &lt;/span&gt;= MyList(range(4, 7&lt;span&gt;))
L3 &lt;/span&gt;= 2 * L1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; L1.__rmul__(2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L3)

L5 &lt;/span&gt;= L1 * 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; L5 = L1.__mul__(2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(L5)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 1, 2, 3])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复合赋值算术运算符的重载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　以&lt;strong&gt;复合赋值&lt;/strong&gt;算术运算符 x += y 为例,此运算会&lt;strong&gt;优先调用x.&lt;span&gt;__iadd__&lt;/span&gt;(y) 方法&lt;/strong&gt;,&lt;br/&gt;　　如果&lt;strong&gt;&lt;span&gt;没有&lt;/span&gt;__iadd__&lt;/strong&gt;方法&lt;strong&gt;时会&lt;/strong&gt;将复合赋值运算&lt;strong&gt;拆解为 x = x + y&lt;/strong&gt;,然后&lt;strong&gt;调用x = x.&lt;span&gt;__add__&lt;/span&gt;(y)&lt;/strong&gt; 方法&lt;br/&gt;　　如果再&lt;strong&gt;不存在 &lt;span&gt;__add__&lt;/span&gt;&lt;/strong&gt;方法则会触发&lt;strong&gt;&lt;span&gt;TypeError&lt;/span&gt;异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其它复合赋值运算符也具有相同的规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;复合赋值算术运算符重载&lt;br/&gt;　　方法名　　　　　　　　　 运算符和表达式 　　　　　　 说明&lt;br/&gt;&lt;span&gt;__iadd__&lt;/span&gt;(self, lhs)　　　　　　 lhs += self 　　　　　　　　 加法&lt;br/&gt;&lt;span&gt;__isub__&lt;/span&gt;(self, lhs) 　　　　　　 lhs -= self 　　　　　　　　 减法&lt;br/&gt;&lt;span&gt;__imul__&lt;/span&gt;(self, lhs) 　　　　　　 lhs *= self 　　　　　　　　 乘法&lt;br/&gt;&lt;span&gt;__itruediv__&lt;/span&gt;(self,lhs) 　　　　　lhs /= self 　　　　　　　　  除法&lt;br/&gt;&lt;span&gt;__ifloordiv__&lt;/span&gt;(self, lhs)　　　　   lhs //= self 　　　　　　　　 地板除&lt;br/&gt;&lt;span&gt;__imod__&lt;/span&gt;(self, lhs)　　　　　　lhs %= self　　　　　　 　　 取模(求余)&lt;br/&gt;&lt;span&gt;__ipow__&lt;/span&gt;(self, lhs) 　　　　　　lhs **= self　　　　　　　　 幂&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.beta = [x for x in lst]&lt;/span&gt;
        self.bata =&lt;span&gt; list(lst)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iadd__&lt;/span&gt;&lt;span&gt;(self, rhs):
        self.beta &lt;/span&gt;+= rhs.beta  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; id不变&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta + rhs.beta)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; id会不变&lt;/span&gt;
&lt;span&gt;

L &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(lst):
    lst &lt;/span&gt;+= MyList([4, 5, 6&lt;span&gt;])


f1(L)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;复合赋值算术运算符重载&lt;br/&gt;　　方法名 　　　　　　　　　　 运算符和表达式 　　　　 　　 说明&lt;br/&gt;&lt;span&gt;__lt__&lt;/span&gt;(self, rhs) 　　　　　　　　   self &amp;lt; rhs 　　　　　       　   小于&lt;br/&gt;&lt;span&gt;__le__&lt;/span&gt;(self, rhs) 　　　　　　　　  self &amp;lt;= rhs 　　　　　      　  小于等于&lt;br/&gt;&lt;span&gt;__gt__&lt;/span&gt;(self, rhs) 　　　　　　　　  self &amp;gt; rhs 　　　　　　　  　 大于&lt;br/&gt;&lt;span&gt;__ge__&lt;/span&gt;(self, rhs) 　　　　　　　　 self &amp;gt;= rhs 　　　　　　        大于等于&lt;br/&gt;&lt;span&gt;__eq__&lt;/span&gt;(self, rhs) 　　　　　　　　 self == rhs 　　　　　　        等于&lt;br/&gt;&lt;span&gt;__ne__&lt;/span&gt;(self, rhs) 　　　　　　　　 self != rhs 　　　　　　         不等于&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意比较运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.data ==&lt;span&gt; rhs.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.data &amp;gt;&lt;span&gt; rhs.data


L1 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])
L2 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L1 == L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(L1 &amp;gt; L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(L1 == L2)  # 如果没有__eq__　方法判断两个对象的id&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(L1 &amp;gt; L2)  # 如果没有__gt__　方法报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__invert__(self) ~ self 取反(一元运算符)&lt;br/&gt;__and__(self, rhs) self &amp;amp; rhs 位与&lt;br/&gt;__or__(self, rhs) self | rhs 位或&lt;br/&gt;__xor__(self, rhs) self ^ rhs 位异或&lt;br/&gt;__lshift__(self, rhs) self &amp;lt;&amp;lt; rhs 左移&lt;br/&gt;__rshift__(self, rhs) self &amp;gt;&amp;gt; rhs 右移&lt;/p&gt;
&lt;p&gt;反向位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__rand__(self, lhs) lhs &amp;amp; self 位与&lt;br/&gt;__ror__(self, lhs) lhs | self 位或&lt;br/&gt;__rxor__(self, lhs) lhs ^ self 位异或&lt;br/&gt;__rlshift__(self, lhs) lhs &amp;lt;&amp;lt; self 左移&lt;br/&gt;__rrshift__(self, lhs) lhs &amp;gt;&amp;gt; self 右移&lt;/p&gt;
&lt;p&gt;复合赋值位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__iand__(self, rhs) self &amp;amp;= rhs 位与&lt;br/&gt;__ior__(self, rhs) self |= rhs 位或&lt;br/&gt;__ixor__(self, rhs) self ^= rhs 位异或&lt;br/&gt;__ilshift__(self, rhs) self &amp;lt;&amp;lt;= rhs 左移&lt;br/&gt;__irshift__(self, rhs) self &amp;gt;&amp;gt;= rhs 右移&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;一元运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__invert__(self) ~ self 取反(一元运算符)&lt;br/&gt;__pos__(self) + self 正号&lt;br/&gt;__neg__(self) - self 负号&lt;/p&gt;
&lt;p&gt;语法:&lt;br/&gt;def __xxx__(self):&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意一元运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__neg__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList((-x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__pos__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList((abs(x) &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; L = []&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for x in self.beta:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     if x &amp;gt; 0:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         L.append(x)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     else:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         L.append(-x)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return MyList(L)&lt;/span&gt;
&lt;span&gt;

L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
L2 &lt;/span&gt;= -&lt;span&gt;L1
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([-1, 2, -3, 4, -5])&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实现用正号运算符返回全部元素为正数的自定义列表&lt;/span&gt;
L3 = +&lt;span&gt; L1
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 4, 5])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;in / not in 运算符重载&lt;br/&gt;重载方法:&lt;br/&gt;def __contains__(self, e):&lt;br/&gt;....&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; in  not in 重载&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__contains__&lt;/span&gt;&lt;span&gt;(self, e):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta


L1 &lt;/span&gt;= MyList([1, 2, -3, 4, -5&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(3 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(4 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(5 &lt;span&gt;in&lt;/span&gt; L1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;索引和切片运算符的重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__getitem__(self, i) x = self[i] 索引/切片取值&lt;br/&gt;__setitem__(self, i, val) self[i] = val 索引/切片赋值&lt;br/&gt;__delitem__(self, i) del self[i] 删除索引/切片&lt;/p&gt;
&lt;p&gt;作用:&lt;br/&gt;让自定义的类的对象能够支持索引和切片操作&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意 索引/切片 运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;索引i的值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[i]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, i, v):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__setitem__被调用, i=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)
        self.data[i] &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.data[i]


L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
v &lt;/span&gt;= L1[2]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v = 3&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(v)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
L1[1] = 2
&lt;span&gt;print&lt;/span&gt;(L1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, -4, 5])&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; L1[3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 5])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slice 函数:&lt;br/&gt;作用:&lt;br/&gt;用于创建一个slice切片对象,此对象存储切片的信息&lt;br/&gt;格式:&lt;br/&gt;slice(start=None, stop=None, step=None)&lt;br/&gt;slice对象的属性&lt;br/&gt;s.start 切片的起始值, 默认为None&lt;br/&gt;s.stop 切片的终止值, 默认为None&lt;br/&gt;s.step 切片的步长, 默认为None&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意 索引/切片 运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;索引i的值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(i) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; int:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在进行索引操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; type(i) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; slice:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在进行切片操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;起始值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.start)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;终止值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.stop)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;步长值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.step)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[i]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, i, v):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__setitem__被调用, i=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)
        self.data[i] &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.data[i]


L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
L2 &lt;/span&gt;= L1[::2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特性属性 @property&lt;br/&gt;实现其它语言所拥有的 getter 和 setter 的功能&lt;/p&gt;
&lt;p&gt;作用:&lt;br/&gt;用来模拟一个属性&lt;br/&gt;通过@property 装饰器可以对模拟属性的取值和赋值加以控制&lt;br/&gt;示例见:&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, s):
        self.&lt;/span&gt;&lt;span&gt;__score&lt;/span&gt; = s  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 私有属性,不让其它人任意修改成绩&lt;/span&gt;
&lt;span&gt;
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; score(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;伪装模拟私有一个成绩属性　并返回成绩&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;&lt;span&gt;

    @score.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; score(self, v):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;实现设置者setter , 对用户的复制加以限制&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;assert&lt;/span&gt; 0 &amp;lt;= v &amp;lt;= 100, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成绩不合法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__score&lt;/span&gt; =&lt;span&gt; v


s &lt;/span&gt;= Student(59&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s.score)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 希望有一个属性能得到成绩　　虚拟属性不能复制&lt;/span&gt;
s.score = 80  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过s.score　来修改成绩&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(s.score)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改成功　s.score看似属性　是模拟属性　实际内部已经被替换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题:&lt;br/&gt;L = [1, 2, 3]&lt;br/&gt;def f1(lst):&lt;br/&gt;lst += [4, 5, 6]&lt;/p&gt;
&lt;p&gt;f1(L)&lt;br/&gt;print(L) # [1, 2, 3, 4, 5, 6] 为什么&lt;/p&gt;
&lt;p&gt;L = (1, 2, 3)&lt;br/&gt;def f1(lst):&lt;br/&gt;lst += (4, 5, 6) # lst = lst + (4, 5, 6)&lt;br/&gt;f1(L)&lt;br/&gt;print(L) # (1, 2, 3) 为什么&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;1. 实现两个自定义的列表相加&lt;br/&gt;class MyList:&lt;br/&gt;.... 此处自己实现&lt;br/&gt;L1 = MyList([1, 2, 3])&lt;br/&gt;L2 = MyList(range(4, 7))&lt;br/&gt;L3 = L1 + L2&lt;br/&gt;print(L3) # MyList([1, 2, 3, 4, 5, 6])&lt;br/&gt;L4 = L2 + L1&lt;br/&gt;print(L4) # MyList([4, 5, 6, 1, 2, 3])&lt;br/&gt;L5 = L1 * 2&lt;br/&gt;print(L5) # MyList([1, 2, 3, 1, 2, 3])&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;练习:&lt;br/&gt;实现有序集合类 OrderSet() 能实现两个集合的交集 &amp;amp;,全集 |,&lt;br/&gt;补集 - 对称补集 ^, ==/!= , in/ not in 等操作&lt;br/&gt;要求集合内部用 list 存储&lt;br/&gt;class OrderSet:&lt;br/&gt;...&lt;br/&gt;s1 = OrderSet([1, 2, 3, 4])&lt;br/&gt;s2 = OrderSet([3, 4, 5])&lt;br/&gt;print(s1 &amp;amp; s2) # OrderSet([3, 4])&lt;br/&gt;print(s1 | s2) # OrderSet([1, 2, 3, 4, 5])&lt;br/&gt;print(s1 ^ s2) # OrderSet([1, 2, 5])&lt;br/&gt;if OrderSet([1, 2, 3]) != OrderSet([3, 4, 5]):&lt;br/&gt;print(&quot;不相等&quot;)&lt;br/&gt;if s2 == OrderSet(3, 4, 5):&lt;br/&gt;print('s2 == OrderSet(3, 4, 5) is True')&lt;br/&gt;if 2 in s1:&lt;br/&gt;print(&quot;2在 s1中&quot;)&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:37:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9380227.html</dc:identifier>
</item>
<item>
<title>神奇的C语言，这才是C语言大牛操作，作为面试题，怕是秒杀众人 - C语言叶子编程</title>
<link>http://www.cnblogs.com/yezibiancheng/p/9380198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yezibiancheng/p/9380198.html</guid>
<description>&lt;p class=&quot;imgbox&quot;&gt;&lt;img class=&quot;image-loaded&quot; src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/31afafd8362f9173374c948c03d59007x457x454x14.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/31afafd8362f9173374c948c03d59007x457x454x14.jpeg&quot; data-width=&quot;457&quot; data-height=&quot;454&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;13542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然下面列出来的几点都是C的基础用法，只不过是这些用法可能平时不会被注意。所以很多东西第一次看到的时候，可能会觉得很怪异，但是细细想想就能很好的理解，也就能更好的清楚C语言的一些特性。但是在具体的编码过程当中，我还是希望都能老老实实规规矩矩的。因为程序员不需要太多棱角，把代码写得规范整洁比耍小聪明要重要得多。下面我列举了5个例子说明一些问题，如果你是老手看到这些就一笑而过吧，如果是新手，我相信还是会得到一些启发的。&lt;/p&gt;
&lt;p&gt;1. #和##在宏中的作用，以及带参宏，参数的传递问题。&lt;/p&gt;
&lt;p&gt;2. 结构体中域的偏移位置的计算问题。&lt;/p&gt;
&lt;p&gt;3. 结构体的定义以及初始化的用法。&lt;/p&gt;
&lt;p&gt;4. 数组和指针在运算中的等价关系。&lt;/p&gt;
&lt;p&gt;5. 数组在栈中的“变异”。&lt;/p&gt;
&lt;p&gt;1. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/808e5a6dc57961b0a4cc0793d527d907x640x431x22.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/808e5a6dc57961b0a4cc0793d527d907x640x431x22.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;431&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;22050&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 预编译中#是将右边的参数转成一个字符串，##是将左右两边的参数连接成一个字符串。例子是#的用法。&lt;/p&gt;
&lt;p&gt;B) 宏当中的参数其实是以逗号(,)分隔的，其他的字符其实都被看成同一个参数，但是换行和空白其实被处理过了，使参数在同一个行中。有兴趣的自己多做些测试吧，这个用法可以用于要写包含特殊字符的字符串，免得要写很多的转义字符()，但是中间不能有逗号，呵呵~&lt;/p&gt;
&lt;p&gt;2. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/423b4c87cf122c46b9b3b01eed7827dcx640x429x21.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/423b4c87cf122c46b9b3b01eed7827dcx640x429x21.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;429&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;20743&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) &amp;amp;((struct _st*)0)-&amp;gt;b 的作用是输出_st结构体中b的偏移。为什么用0当成指针呢，其实很好理解：如果一个_st结构体的地址是0，那么b的地址其实就是b在结构体中的偏移。&lt;/p&gt;
&lt;p&gt;B) 其实按理，如果先做((struct _st*)0)-&amp;gt;b运算，那么程序肯定异常，所以编译器还是做了优化的，具体编译器怎么做的，我也没深究。&lt;/p&gt;
&lt;p&gt;3. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/968e2adb7814a66a2e8bd5a6a4c4fbe9x640x460x25.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/968e2adb7814a66a2e8bd5a6a4c4fbe9x640x460x25.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;460&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;24579&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 在结构体的初始化时，可以指定域进行初始化，如例子中的.c = 1,顺序可以颠倒，这样做的好处就是可读性较强，对于大结构的初始化，在阅读时很方便。缺点就是低版本的编译器可能不支持。&lt;/p&gt;
&lt;p&gt;B) 在结构体的声明中，可以指定域的大小，如例子中的int a : 1; 说明a只暂用一个bit，充分展示了C对二进制处理反面的亲和力。&lt;/p&gt;
&lt;p&gt;C) 为什么s.c输出是-1，而不是1，其实很简单，因为0xFFFFFFFF表示的是-1，那么一个1bit大小的变量，所有位上面都是1，那么它也表示-1。所以编码的过程中，有符号和无符号混用其实是很危险的一件事情。&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/96117b6bba63a1c082b6aab914fabf4dx640x407x30.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/96117b6bba63a1c082b6aab914fabf4dx640x407x30.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;407&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;30474&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/d388a5960c63fb8a4cae5de1dd48517dx640x442x25.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/d388a5960c63fb8a4cae5de1dd48517dx640x442x25.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;442&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;25408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 0[a] = 'x';是什么玩意儿？如果写成a[0]='x';其实你就明白是什么意思了，但是说白了，a[0]和0[a]在编译器看来是一样的。因为数组在做[]运行时，其实是做指针的加法运行：a[0]等价于*(a+0)。所以0[a]也就等价于*(0+a)是完全正确的。&lt;/p&gt;
&lt;p&gt;5. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/f25967dd7f57f4650e51438fc1e2ee46x640x401x22.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/f25967dd7f57f4650e51438fc1e2ee46x640x401x22.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;401&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;22396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 为什么两行的结果会不一样？在一般情况下，按我的理解，一个数组a，&amp;amp;a和&amp;amp;a[0]的值是一样的。但是当a在形参当中时就不一样了。例子中，func函数中的a，其实a变量是在func函数的栈当中，在func内部，a其实已经被转化成char *a，所以&amp;amp;a是表示指针变量a在栈中的地址，而&amp;amp;a[0]表示的是指针指向的内存空间的第一个元素的地址，其实也就是调用者传入的数组的第一个元素的地址。不知道我说明白了没有！！&lt;/p&gt;
&lt;p&gt;B) 这个可能比较难理解，关键是明白一点，在数组作为形参时，是被转换成指针看待的。&lt;/p&gt;
&lt;p&gt;我有一个微信公众号，经常会分享一些C语言/C++技术相关的干货；如果你喜欢我的分享，可以用微信搜索“C语言学习部落”关注&lt;/p&gt;
&lt;p&gt;欢迎大家加入千人交流答疑裙：627+012+464&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:26:00 +0000</pubDate>
<dc:creator>C语言叶子编程</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yezibiancheng/p/9380198.html</dc:identifier>
</item>
<item>
<title>[图解Java]Condition - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/9380091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/9380091.html</guid>
<description>&lt;h2&gt;图解Condition&lt;/h2&gt;
&lt;h3&gt;0. demo&lt;/h3&gt;
&lt;p&gt;我先给出一个demo, 这样大家就可以根据我给的这段代码, 边调试边看源码了. 还是那句话: 注意&quot;My&quot; , 我把ReentrantLock类 改名为了 &quot;MyReentrantLock&quot;类 , &quot;Lock&quot;类 改名为了&quot;MyLock&quot;类. 大家粘贴我的代码的时候, 把相应的&quot;My&quot;都去掉就好了, 否则会编译报错哦.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.Scanner;
import java.util.concurrent.locks.Condition;
import java.util.function.Supplier;

public class ConditionTest {
    static final Scanner scanner = new Scanner(System.in);
    static volatile String cmd = &quot;&quot;;
    private static MyReentrantLock lock = new MyReentrantLock(true);
    private static Condition condition = lock.newCondition();

    public static void main(String[] args) {
        for (String name : new String[]{&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;, &quot;w6&quot;})
            new Thread(() -&amp;gt; func(() -&amp;gt; lock, name)).start();
        new Thread(() -&amp;gt; signalOne(() -&amp;gt; lock, &quot;s&quot;)).start();

        while (scanner.hasNext()) {
            cmd = scanner.nextLine();
        }
    }

    public static void func(Supplier&amp;lt;MyLock&amp;gt; myLockSupplier, String name) {
        blockUntilEquals(() -&amp;gt; cmd, name);
        myLockSupplier.get().lock();

        System.out.println(name + &quot;阻塞等待...&quot;);
        try {
            condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;释放了&quot; + name);

        myLockSupplier.get().unlock();
    }

    public static void signalOne(Supplier&amp;lt;MyLock&amp;gt; myLockSupplier, String name) {
        while (true) {
            blockUntilEquals(() -&amp;gt; cmd, name);
            myLockSupplier.get().lock();
            condition.signal();
            System.out.println(&quot;通知唤醒了一个等待...&quot;);
            myLockSupplier.get().unlock();
        }
    }

    private static void blockUntilEquals(Supplier&amp;lt;String&amp;gt; cmdSupplier, final String expect) {
        while (!cmdSupplier.get().equals(expect))
            quietSleep(1000);
        clearCmd();
    }

    private static void quietSleep(int mills) {
        try {
            Thread.sleep(mills);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void clearCmd() {
        cmd = &quot;&quot;;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用例子在下面. &lt;/p&gt;
&lt;p&gt;首先输入w1, 让线程1执行await() . 然后输入w2, 让线程2执行await(). 然后输入w3, 让线程3执行await().&lt;/p&gt;
&lt;p&gt;接下来输入3次 s, 没输入一次s, 并按下回车, 就会signal通知一个await等待.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727172514983-545531193.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1. 开始图解Condition&lt;/h3&gt;
&lt;p&gt;想用ReentrantLock的Condition, 那么就首先要有个ReentrantLock锁.&lt;/p&gt;
&lt;p&gt;实例化一个锁, ReentrantLock里只有一个成员变量sync.&lt;/p&gt;
&lt;p&gt;sync实例里面有四个成员变量.&lt;/p&gt;
&lt;p&gt;分别表示:&lt;/p&gt;
&lt;p&gt;          1. state - 锁计数器&lt;/p&gt;
&lt;p&gt;          2. exclusiveOwnerThread - 锁的持有线程&lt;/p&gt;
&lt;p&gt;          3. head - `等待队列`的头结点.&lt;/p&gt;
&lt;p&gt;          4. tail - 指向`等待队列`的最后一个元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727173553916-1338431673.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后咱们实例化了一个Condition. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727174242628-890690893.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当咱们输入w1后, 第一个线程就申请了锁, 并且申请成功.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727174621075-238210493.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后就执行到了await()方法.&lt;/p&gt;
&lt;p&gt;将线程1封装为Node节点, 然后waitState置为-2.  -2的含义是Condition.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727175723594-203858123.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; await()方法内部的第一个步骤就是把当前线程(线程1)插入到了`条件队列`中.&lt;/p&gt;

&lt;p&gt;然后就开始释放当前线程(线程1)的锁了, 而且是完全释放, 一次就释放掉全部重入次数哦, 也就是直接让state等于0. &lt;/p&gt;
&lt;p&gt;释放完锁了, 然后挂起线程1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183733969-1750615281.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后让线程2进行await.( 也就是前面的demo程序中在控制台输入了w2.)&lt;/p&gt;
&lt;p&gt;线程2执行await()之前当然是先获取锁了.&lt;/p&gt;
&lt;p&gt;由于此时, 锁是空闲的. 所以线程2成功获取到了锁. 淡橙色的阴影部分为变化的内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183910474-39681418.jpg&quot; alt=&quot;&quot; height=&quot;600px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;获取锁之后, 线程2就该执行await()了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727184019742-1836066772.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如上图, 将线程封装为Node, 然后尾插到`条件队里`中, 只是await() 方法的第一步.&lt;/p&gt;
&lt;p&gt;然后的操作, 就是完全释放线程2的锁, 然后挂起线程.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183505897-1988515706.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果这个时候咱们在上面demo程序的控制台输入&quot;s&quot;, 那么就会让线程s 申请锁, 申请成功后, 就会执行signal.&lt;/p&gt;
&lt;p&gt;首先是线程s申请锁成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727184812042-617800133.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 线程s成功获取了锁以后, 就是该执行signal()了.&lt;/p&gt;
&lt;p&gt; 首先将`条件队列`里的第一个节点脱离出来:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727185904919-705350543.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后把waitState从-2改为0 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727221819704-1473450189.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后要做的就是把从`条件队列`中脱离出来的Node(就是线程1对应的Node节点), 尾插到`等待队列`中.&lt;/p&gt;
&lt;p&gt;但是`等待队列`此时还未被初始化, 所以插入到`等待队列`之前, 要把`等待队列`初始化了. 见下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727222821455-1777207639.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; `等待队列`初始化完了. 接下来就是把线程1对应的Node, 尾插到`等待队列`中了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727223747076-1197743443.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后将当前尾插的那个节点的前驱的waitState置为-1.  -1表示下一个节点等待着被唤醒. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727224343294-1374168491.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt; &lt;/p&gt;
&lt;p&gt;接下来就是线程s会执行到unlock(). 然后就会释放锁, 之后就是唤醒`等待队列`中的第一个线程.&lt;/p&gt;
&lt;p&gt;如此就介绍完了signal()&lt;/p&gt;

&lt;p&gt;一个signal命令, 就把一个await的线程从`条件队列中`移到了`等待队列`中. 到了等待队列中之后, 剩下的就是跟&quot;锁解锁后, 唤醒下一个执行&quot;这样的步骤一样了.&lt;/p&gt;
&lt;p&gt;我觉得await方法就是将线程尾插到`条件队列`中. signal()方法就是把条件队列中的第一个元素, 尾插入到`等待队列`中.&lt;/p&gt;
&lt;p&gt;所以我觉得不必往下分析了.&lt;/p&gt;
&lt;p&gt;也可能是我理所当然了, 有问题的话之后再补充.&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 14:59:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/9380091.html</dc:identifier>
</item>
</channel>
</rss>