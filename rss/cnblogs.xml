<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>首个应用到大规模真实工业场景的神经网络控制系统在谷歌上线了 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/9503262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/9503262.html</guid>
<description>&lt;p&gt;&lt;span&gt;      即便深度学习和其它机器学习方法近几年已经取得了不小的发展，但是把它们直接应用在真实工业场景中、让它们直接控制工业系统还未曾见到。深度学习本身缺乏鲁棒性、面对新状况难以预测行为等一些特性固然是重要的掣肘之处，如何让算法逐步提高控制范围、协调与人类的协作方式也是难题。DeepMind 和谷歌最近就做出了新一步尝试，取得了不小的成功，然后在 DeepMind 博客上进行了介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233017793-1925826638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们人类社会面对的许多紧迫问题中，有许多问题还在变得越来越复杂，所有人都急切地想要找到好的解决方法。对于 DeepMind 和谷歌来说，他们相信如果人类可以把 AI 作为探寻新知识的工具加以利用，找到解决方法就会容易得多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2016 年时，DeepMind 和谷歌联手开发了一个基于 AI 的动作推荐系统，向负责维护、调节冷却系统的数据中心运营人员推荐不同状况下的应对方法，它让谷歌当时已经具有很高能源效率的推荐系统数据中心向前更进了一步。他们的出发点也很简单，为了应对全球气候变化，大型能耗场所的一点点小改进也能在在减少能源消耗、减少二氧化碳排放方面有重大影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      最近，DeepMind 把这个系统升级到了一个全新的级别上：不再像原来的系统那样向人类推荐一些动作，然后由人类去完成，AI 系统现在会直接控制数据中心的冷却系统，当然了它也仍然受到数据中心运营人员的专业监控。这是首个基于云的控制系统，已经在多个谷歌的数据中心中安静地运行、持续地节省能源。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;工作方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     每隔 5 分钟，这个基于云的 AI 会从数据中心的数千个传感器中采集数据，获得数据中心冷却系统的状态快照，然后把它输入深度神经网络。这个网络会预测各种可能的操作的不同组合会如何影响数据中心的能量消耗。然后 AI 就会就会在满足鲁棒安全性限制的条件下判断出一组能够最小化能源消耗的动作。这些动作的判断结果接下来会被发回给数据中心，由本地的控制系统验证并执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233047904-1670913403.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这种系统运行的想法其实来自于在数据中心使用原来那个 AI 推荐系统的操作人员。他们告诉 DeepMind 的研究人员们，虽然系统给他们教了一些最新最好的操作技巧，比如让冷却介质覆盖更多的设备，而不是更少，但是实现这些推荐操作其实需要花费非常多的操作精力和长期规划。所以他们自然地就很想知道，能不能不需要人来出力就达到类似的能源节省效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       现在他们就可以很高兴地宣布，答案是能。谷歌的一位数据库操作人员表示：「我们希望可以节省能源，同时也降低操作人员的工作强度。自动化的系统就可以让我们以更高的频率执行更细粒度的行动，同时出的错误还更少。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;兼顾安全性和可靠性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      谷歌的数据中心里一般都有上千台服务器，它们支撑着谷歌搜索、Gmail、YouTube 等用户们每天都会使用的服务。确保这些服务可以可靠、高效地运行是最关键的一件事。DeepMind 和谷歌一起设计 AI 智能体以及背后的控制界面时，都是带着安全、可靠的思维从头设计的，还使用了 8 种不同的机制确保系统能够总是能够按照预期行动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      他们使用的方法里，其中一种较为简单的是估计不确定性。对于总计上亿个可能的动作中的每一种，AI 智能体都需要计算自己认为这是一个好的动作的信心。估计出来信心太低的动作就不去考虑了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      另一个方法是两层验证。AI 计算出的最优行动首先需要根据一个内置的、由数据中心运营人员们制定的安全限制清单做检查。计算的结果通过检查、从云端发送到实际的数据中心之后，当地的控制系统还会再次把指令根据自己的一套安全限制清单再检查一遍。这种冗余设计的检查流程确保了系统的运行总是在当地的限制之内的，操作人员们也总是对操作的边界有完全的控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      最重要的是，谷歌的数据中心总是会受到人类的完全控制的，人类随时可以选择退出 AI 控制模式。这时候，控制系统会自动从 AI 控制无缝地切换到基于现代自动化工业使用的基于现场规则的以及启发式设计的控制系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      他们设计的其它安全机制如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233145141-2081503648.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;          连续监控、自动错误重启、平滑切换、两层验证、不间断通讯、不确定性估计、规则与启发式设计的备用控制系统、人类指令优先越用越节省能源&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;      相比于原来的动作推荐系统需要操作人员自己检查以及实施推荐的动作，新的 AI 控制系统是自己直接实现这些动作的。DeepMind 和谷歌的研究人员在开发它时也有有意识地把系统的优化边界设定到了一个更窄更小的策略中，让它把安全和可靠作为首要目标，也就是说对于节约能源的目标来说，它需要在过于节约导致的不稳定风险和优化不足的低反馈之间找到平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      虽然只上线了几个月时间，这个系统已经可以稳定地节约平均 30% 左右的能源，而且他们还期待系统未来可以改善更多。这是因为随着数据更多，系统的优化判断能力也会变得更强，如下图。随着技术越来越成熟，DeepMind 和谷歌的研究人员未来也会把系统的优化边界设置得宽松一些，来达到更好的能源节约效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233219766-45247200.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      这个 AI 直接控制的系统时不时找到一些新的方法管理冷却系统，有一些方法甚至让数据库操作人员觉得惊讶。与这个系统紧密协作的一位谷歌数据中心运营人员就惊讶道：「这个 AI 会利用冬天外面比较冷的特点，产生比平时更冷的冷却水，然后减少了给数据中心降温所需的能源消耗。规则是不会自己变得越来越好的，但是 AI 可以啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于已经安全运行、独立运行、降低能耗的 AI 直接控制系统，DeepMind 和谷歌都觉得非常激动。不过，在数据中心中使用这样的系统才仅仅是个开始。在长远的未来，他们认为还有很多的潜力把这样的技术运用在其他工业场景中，也就可以在更大的规模上帮助对抗气候变化。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 1.&lt;a id=&quot;post_title_link_4978884&quot; href=&quot;http://www.cnblogs.com/lsjwq/p/4978884.html&quot;&gt;[连载]《C#通讯（串口和网络）框架的设计与实现》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2.[&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5316577.html&quot; target=&quot;_blank&quot;&gt;开源]C#跨平台物联网通讯框架ServerSuperIO（SSIO）介绍&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5359907.html&quot; target=&quot;_blank&quot;&gt;应用SuperIO（SIO）和开源跨平台物联网框架ServerSuperIO（SSIO）构建系统的整体方案&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 3.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5122612.html&quot;&gt;C#工业物联网和集成系统解决方案的技术路线（数据源、数据采集、数据上传与接收、ActiveMQ、Mongodb、WebApi、手机App）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 5.github地址：&lt;a href=&quot;https://github.com/wxzz/ServerSuperIO&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/ServerSuperIO&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/8531046.html&quot; target=&quot;_blank&quot;&gt;6.助力中小企业级连云端，促进工业互联网平台蓬勃发展，全套解决方案。&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 物联网&amp;amp;集成技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 15:34:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>即便深度学习和其它机器学习方法近几年已经取得了不小的发展，但是把它们直接应用在真实工业场景中、让它们直接控制工业系统还未曾见到。深度学习本身缺乏鲁棒性、面对新状况难以预测行为等一些特性固然是重要的掣肘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsjwq/p/9503262.html</dc:identifier>
</item>
<item>
<title>在bugku关于CBC翻转攻击思路 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9503048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9503048.html</guid>
<description>&lt;p&gt;今天在bugku遇到关于CBC翻转攻击的题目，总结了一下关于CBC翻转攻击的原理，以及关于这道题目的解题思路&lt;/p&gt;
&lt;p&gt;CBC翻转攻击的主要目的：通过损坏密文字节来改变明文字节。(注：借助CBC内部的模式) 通过添加单引号等恶意字符来绕过过滤器，或通过将用户ID更改为admin来提升权限，或者更改应用程序所需的明文的任何其他后果。&lt;/p&gt;
&lt;p&gt;加密过程：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213651316-2019008060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图CBC加密原理图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1：Plaintext：待加密的数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2：IV：用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3： Ciphertext：加密后的数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4：Key:分组加密使用的密钥&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里重要的一点是CBC在一个固定长度的位组上工作，称为块。在本文中，我们将使用每个16字节的块。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;整个加密的过程简单说来就是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。&lt;/li&gt;
&lt;li&gt;生成一个随机的初始化向量(IV)和一个密钥。&lt;/li&gt;
&lt;li&gt;将IV和第一组明文异或。&lt;/li&gt;
&lt;li&gt;用密钥对3中xor后产生的密文加密。&lt;/li&gt;
&lt;li&gt;用4中产生的密文对第二组明文进行xor操作。&lt;/li&gt;
&lt;li&gt;用密钥对5中产生的密文加密。&lt;/li&gt;
&lt;li&gt;重复4-7，到最后一组明文。&lt;/li&gt;
&lt;li&gt;将IV和加密后的密文拼接在一起，得到最终的密文。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从第一块开始，首先与一个初始向量IV异或（IV只在第一处作用），然后把异或的结果配合Key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。因此这种模式最重要的特点就是：&lt;em&gt;前一块的密文用来产生后一块的密文。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213754766-343131230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;这是解密过程，解密的过程其实只要理解了加密，反过来看解密过程就也很简单了，同样的，&lt;strong&gt;前一块密文参与下一块密文的还原&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;从密文中提取出IV，然后将密文分组。&lt;/li&gt;
&lt;li&gt;使用密钥对第一组的密文解密，然后和IV进行xor得到明文。&lt;/li&gt;
&lt;li&gt;使用密钥对第二组密文解密，然后和2中的密文xor得到明文。&lt;/li&gt;
&lt;li&gt;重复2-3，直到最后一组密文。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;下图是为解释翻转攻击的原理图：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213811836-1879206320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里可以注意到前一块Ciphertext用来产生下一块明文，如果我们改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就欺骗服务端或者绕过过滤器&lt;/p&gt;
&lt;p&gt;再解释一下：&lt;/p&gt;
&lt;p&gt;根据解密方式我们可以知道，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
A=ciphertext(N-1),B=plaintext(N)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;,C为第N块待异或且经过解密的字符，C'为我们经过翻转要得到的明文。&lt;/p&gt;
&lt;p&gt;所以我们可以打得到关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
A = B ^&lt;span&gt; C

C &lt;/span&gt;= A ^&lt;span&gt; B

A &lt;/span&gt;^ B ^ C =&lt;span&gt; 0

A &lt;/span&gt;^ B ^ C ^ C&lt;span&gt;'&lt;/span&gt;&lt;span&gt; = C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据关系式可以得到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
A&lt;span&gt;'&lt;/span&gt;&lt;span&gt; = A ^ C ^ C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以说我们只需要修改前一组密文所对应的本组明文相同位置的字符，即可得到想要的明文&lt;/p&gt;

&lt;p&gt;下面就是关于Bugku的题目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://118.89.219.210:49168/&quot;&gt;http://118.89.219.210:49168/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一题属于常规思路，可是不容易想到，我记得以前做过类似的题目，毕竟是萌新总会有很多知识点会忘记(QAQ)&lt;/p&gt;
&lt;p&gt;使用备份文件脚本进行扫描就会得到：脚本代码：&lt;/p&gt;
&lt;p&gt;运行之后就会得到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213845006-2103839019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开链接发现是应该可以下载的文件并且文件是以.swp为后缀名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于swp文件：&lt;/strong&gt;&lt;br/&gt;使用vi，经常可以看到swp这个文件。那这个文件是怎么产生的呢，当打开一个文件，vi就会生成这么一个.(filename)swp文件 以备不测（比如非正常退出），如果你正常退出，那么这个这个swp文件将会自动删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么恢复.swp：&lt;/strong&gt;&lt;br/&gt;可以使用&lt;br/&gt;vim -r：命令来查看当前目录下的所有swp文件 &lt;br/&gt;vi -r {your file name} ：命令恢复文件&lt;br/&gt;rm .{your file name}.swp：命令删除swp文件，不然每一次编辑时总是有这个提示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213926106-2106555694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就会得到html文档：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213940199-204193635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看到该题的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html PUBLIC &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-//W3C//DTD XHTML 1.0 Transitional//EN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;;

&lt;/span&gt;&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;

&amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;title&amp;gt;Login Form&amp;lt;/title&amp;gt;

&amp;lt;link href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/css/style.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

$(document).ready(function() {

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).focus(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-48px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).blur(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).focus(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-48px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).blur(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

});

&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;&lt;span&gt;?php

define(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SECRET_KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, file_get_contents(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));

define(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;METHOD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aes-128-cbc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

session_start();

function get_random_iv(){

    $random_iv&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;($i=0;$i&amp;lt;16;$i++&lt;span&gt;){

        $random_iv.&lt;/span&gt;=chr(rand(1,255&lt;span&gt;));

    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $random_iv;

}

function login($info){

    $iv &lt;/span&gt;=&lt;span&gt; get_random_iv();

    $plain &lt;/span&gt;=&lt;span&gt; serialize($info);

    $cipher &lt;/span&gt;=&lt;span&gt; openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);

    $_SESSION[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = $info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    setcookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, base64_encode($iv));

    setcookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, base64_encode($cipher));

}

function check_login(){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;amp;&amp;amp; isset($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])){

        $cipher &lt;/span&gt;= base64_decode($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);

        $iv &lt;/span&gt;= base64_decode($_COOKIE[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($plain =&lt;span&gt; openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){

            $info &lt;/span&gt;= unserialize($plain) &lt;span&gt;or&lt;/span&gt; die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;base64_decode('&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.base64_encode($plain).&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;') can't unserialize&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            $_SESSION[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = $info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

            die(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        }

    }

}

function show_homepage(){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($_SESSION[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]===&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Hello admin&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Flag is $flag&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;hello &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.$_SESSION[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Only admin can see flag&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    }

    echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;&amp;lt;a href=&quot;loginout.php&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;amp;&amp;amp; isset($_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])){

    $username &lt;/span&gt;= (string)$_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    $password &lt;/span&gt;= (string)$_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($username === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){

        exit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;admin are not allowed to login&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        $info &lt;/span&gt;= array(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;=&amp;gt;$username,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;=&amp;gt;&lt;span&gt;$password);

        login($info);

        show_homepage();

    }

}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_SESSION[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])){

        check_login();

        show_homepage();

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;body class=&quot;login-body&quot;&amp;gt;&lt;/span&gt;

                &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;

                    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;

                    &amp;lt;form name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login-form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login-form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; action=&lt;span&gt;&quot;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;h1&amp;gt;Login Form&amp;lt;/h1&amp;gt;

                        &amp;lt;span&amp;gt;Fill out the form below to login to my super awesome imaginary control panel.&amp;lt;/span&amp;gt;

                        &amp;lt;/div&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;input name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onfocus=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this.value=\'\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;input name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onfocus=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this.value=\'\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;/div&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;/div&amp;gt;

                    &amp;lt;/form&amp;gt;

                &amp;lt;/div&amp;gt;

            &amp;lt;/body&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;
    }

}

?&lt;/span&gt;&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214019266-800100518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;GO一下可以看到cookie中返回的iv和cipher&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214031791-38781494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将输入序列化得s:2:{s:8:&quot;username&quot;;s:5:&quot;adcin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;}&lt;/p&gt;&lt;p&gt;然后每16字节分组得&lt;/p&gt;&lt;p&gt;① a : 2 : { s : 8 : &quot; u s e r n a&lt;/p&gt;&lt;p&gt;② m e &quot; ; s : 5 : &quot; a d c i n &quot; ;&lt;/p&gt;&lt;p&gt;③ s : 8 : &quot; p a s s w o r d &quot; ; s&lt;/p&gt;&lt;p&gt;④ : 3 : &quot; 1 2 3 &quot; ; }&lt;/p&gt;&lt;p&gt;可见，如果我们想要将②中的c变成m就需要对①中的s进行改变&lt;/p&gt;&lt;p&gt;于是我们编写脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64,urllib

 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_newCipher():

    cipher &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入所得cipher&lt;/span&gt;
&lt;span&gt;
    cipher &lt;/span&gt;=&lt;span&gt; base64.b64decode(urllib.unquote(cipher))

    newCipher &lt;/span&gt;= cipher[0:x] + chr(ord(cipher[x])^ord(&lt;span&gt;''&lt;/span&gt;)^ord(&lt;span&gt;''&lt;/span&gt;)) + cipher[x+1:]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;x为需要改变值所在的字节数，第二个ord中为输入值，第三个ord中为目标值&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;&lt;span&gt; urllib.quote(base64.b64encode(newCipher))

 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_newIV():

    cipher &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newCipher提交后所得的无法反序列化密文&lt;/span&gt;
&lt;span&gt;
    iv &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所得iv&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;cipher = urllib.unquote(cipher)&lt;/span&gt;
&lt;span&gt;
    cipher &lt;/span&gt;=&lt;span&gt; base64.b64decode(cipher)

    iv &lt;/span&gt;=&lt;span&gt; base64.b64decode(urllib.unquote(iv))

    newIv &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;

    right &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;被损坏前正确的明文&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(16&lt;span&gt;):

        newIv &lt;/span&gt;+= chr(ord(right[i])^ord(iv[i])^&lt;span&gt;ord(cipher[i]))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; urllib.quote(base64.b64encode(newIv))

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newCipher()&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newIV()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214049986-1318280528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;发现新密文无法反序列化，这是因为，我们将c修改成m时破坏了①中的结构&lt;/p&gt;&lt;p&gt;于是我们将新得到的密文复制，通过base64解密过后的iv与新密文解密的明文与原始①中数据对应异或&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214107886-1209046428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;提交新的iv和刚才得到的cipher即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214116327-1609219020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:35:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<og:description>今天在bugku遇到关于CBC翻转攻击的题目，总结了一下关于CBC翻转攻击的原理，以及关于这道题目的解题思路 CBC翻转攻击的主要目的：通过损坏密文字节来改变明文字节。(注：借助CBC内部的模式) 通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9503048.html</dc:identifier>
</item>
<item>
<title>模型训练技巧 - Remixi</title>
<link>http://www.cnblogs.com/MrPan/p/9503008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrPan/p/9503008.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;神经网络模型设计训练流程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220028577-1549476732.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;275&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-1 神经模型设计流程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  当我们设计并训练好一个神经网络之后，需要在训练集上进行验证模型效果是否良好。这一步的目的在于判断模型是否存在欠拟合；在确定已经在训练集上拟合的很好，就需要在测试集上进行验证，如果验证结果差就需要重新设计模型；如果效果一般，可能需要增加正则化，或者增加训练数据；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;欠拟合处理策略&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 当模型在训练集上的表现结果并不好的时候，在排除不是数据集和训过程有问题，你可以采用以下几个方法来进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;更换激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Sigmoid激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; Sigmoid函数的形式如（1）所示，图结构如图1-2所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220100564-80741928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220119443-614365601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-2 sigmoid函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 但是使用Sigmoid函数作为激活函数会存在梯度消失的现象。就是当神经网络的隐藏层数量超过3层的时候，底层的参数更新就几乎为0；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;ReLu（Rectified Linear Unit）激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  ReLu函数的形式如（2）所示，图形结构如图1-3所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220148006-851973452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220157598-845420076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-3 ReLu函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  使用ReLu作为激活函数的原因在于：1）计算更为简单，相比与Sigmoid函数，ReLu计算的更为简单2）ReLu相当于无穷多个不同偏置的Sigmoid函数叠加起来的效果3）ReLu可以解决梯度消失的问题。由于ReLu函数结构，当某个神经元的输出为0时（如图1-4所示），就相当于该神经元在神经网络中不起任何作用，可以将这一些神经元从神经网络中舍去（如图1-5）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220217353-1087723902.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-4 神经网络中输出为0的神经元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220229086-1147170579.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-5 “瘦长线性”神经网络&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Leaky ReLu激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 由于当ReLu的输入&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220304117-2093020863.png&quot; alt=&quot;&quot;/&gt;时，对应的神经元就不起任何作用。因此，Leaky ReLu的改进点是当输入&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220326561-1335249396.png&quot; alt=&quot;&quot;/&gt;时，输出不再是0，而是一个较小值。Leaky ReLu函数结构如（3）所示，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220348703-300624542.png&quot; alt=&quot;&quot;/&gt;的取值通常需要人工赋值，如当&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220404863-2115143455.png&quot; alt=&quot;&quot;/&gt;时，函数结构如1-6所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220424614-1384799947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220432899-1167203425.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-6 Leaky ReLu激活函数&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Parametric ReLu激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 由于在Leaky ReLu中的需要人工赋值，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220452843-1647427588.png&quot; alt=&quot;&quot;/&gt;赋值的好坏需要一定的先验知识。因此，Parametric ReLu中的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220458896-1526494545.png&quot; alt=&quot;&quot;/&gt;是参数，是可以被训练出来，甚至每一个神经元都可以有不同的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220519055-1605786361.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220538448-1449263584.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-7 Parametric ReLu激活函数&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220617013-1043569404.png&quot; alt=&quot;&quot;/&gt;的训练情况更一般参数一样，但跟一般的参数更新有所区别的是&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220636609-1771210759.png&quot; alt=&quot;&quot;/&gt;采用带有动量的更新方法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220652090-1775680114.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220706847-133753959.png&quot; alt=&quot;&quot;/&gt;为动量，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220717337-469155912.png&quot; alt=&quot;&quot;/&gt;为学习率；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Maxout可学习激活函数（Learnable Activation Function）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  Maxout是一种可学习的激活函数，它可以学习出来ReLu函数的形式。因此，ReLu是Maxout的一种特殊情况。 Maxout结构如图1-8所示，当输出值跟权重相乘后，并不是送进激活函数进行转换，而是将若干元素作为一组（元素数量需预先设定），选择最大值作为输出。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220757775-744211274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-8 Maxout结构&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  以图1-9为例，当其中一个输入为1，则最终可以的激活函数实行为图1-10所示。根据你选择多少个元素作为一组，就可以训练出任意的分段函数。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220811285-1568848537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-9 Maxout示例&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220819819-1270030876.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-10 Maxout训练出的激活函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;自适应学习率&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Adagrad&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;     Adagrad是将学习率的取值跟之前所有偏微分值的均方值的根号有关系。以当个参数为例，具体的计算如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220857283-1638200175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220913537-1363937525.png&quot; alt=&quot;&quot;/&gt;表示对&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220925232-515174367.png&quot; alt=&quot;&quot;/&gt;的偏导数；&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221006725-484944069.png&quot; alt=&quot;&quot;/&gt;表示将先前所有对参数的偏导数的平方进行累加，并求均值，最后再取根号；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;RMSProp&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  RMSProp的计算公式如（7）所示，从公式中可以看出，在进行参数更新的时候，不仅考虑了当前的梯度&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221034621-1335391927.png&quot; alt=&quot;&quot;/&gt;，也考虑了先前历史的梯度&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221053709-357184914.png&quot; alt=&quot;&quot;/&gt;。其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221130593-810902320.png&quot; alt=&quot;&quot;/&gt;是可以自己设置的常数，当&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221139505-1054147401.png&quot; alt=&quot;&quot;/&gt;的值较小时，就表示比较相信当前的梯度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221204373-359643941.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Momentum&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; Momentum的思想来自于现实生活中的场景，当我们往一个崎岖的抛一个球时，由于重力势能，会导致球不一定停留在第一个凹点，可能会翻过第一个凸点，到达全局最低点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221224782-1079428788.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-11 Momentum现实场景&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; 因此，不同于以往的移动方向只考虑梯度方向，也会考虑到以往的移动方向。具体的计算公式中为（8）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221305855-766813087.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;过拟合处理策略&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;早停（Early Stopping）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  早停的思想就是，当模型在训练集上的训练误差在降低时，在测试集的测试误差可能会增加，如图1-12所示。因此需要在训练误差和测试误差之间做一个权衡。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221325916-703338767.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-12 训练误差与测试误差&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;正则化（Regularization）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   添加正则化的目的在于增加模型的平滑性，并且通常会在已有的损失函数上添加一些跟参数相关的项。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;L2正则化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;   假定现在已经确定的损失函数为L(θ)，而L2正则化会对添加一项，L(θ)形式如（9）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221500711-1947239097.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当添加上L2之后，对于参数的跟新形式变为（10）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221517675-1430514937.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对于（10）的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221530607-1553521416.png&quot; alt=&quot;&quot;/&gt;跟不添加L2正则项是一样的，而增加L2后，就相当于参数w在更新之前总是会乘上一个小于1的数，因此总是会使w的值减小，这个计算过程称作Weight Decay。L2的效果是使得参数越来越接近0，而我们在初始化参数时通常也会初始化接近于0的值；而我们更新的参数是使得参数越来越远离0,；因此，L2的效果跟早停的效果有些相似。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;L1正则化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;    L1正则化跟L2正则化非常相似，只是L2是取平方和，而L1是取绝对值，形式如（11）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221652097-1969573478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   添加L1项后，参数的更新形式就为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221716977-533968560.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 因此，当w&amp;gt;0时，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221744755-1343737879.png&quot; alt=&quot;&quot;/&gt;为正，从而使得w的值减小；反之，当w&amp;lt;0时，就会加上一个正数，从而使w的值增加。由于L2是每次都乘上一个小于0的系数因此w减小的会比较明显；而L1是每次都减去一个固定值，因此下降的比较缓慢；所以，在最终训练出来的w，添加L2项的参数普遍较小；添加L1的参数可能有大有小。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Dropout&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   Dropout的做法是对于一个确定好的神经网络模型，每一次更新参数前都会对原始模型中的每一个神经元进行采样，决定是否丢弃神经元，每一个神经元都有p%的几率被丢掉。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221806759-885008727.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-13 dropout采样过程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221816803-1057551220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-14 dropout采样后的NN结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在训练的时候需要对模型进行dropout采样，但是当测试的时候就不要进行采样，而且，每一个参数都要乘上（1-p）%。如图1-15所示，假设dropout几率为50%，则训练时有一半的神经元会被丢弃。而在测试时，为了使测试和训练的输出尽可能相同，就需要对每一个权重都乘上（1-p）%，以保持输出值的平衡（如图1-15右图所示）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221840184-1156979169.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;图1-15 dropout测试权重处理&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Dropout原理解释&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  Dropout可以看做是一种集成学习。集成学习的做法大致是，从训练集中采样出多笔数据，分别去训练不同的模型（模型的结构可以不同）。用训练出的多个模型分别对测试集进行预测，将最终的结果进行平均（如图1-16所示）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221912279-633833096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-16 集成学习的处理方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 假定设计的神经网络中的神经元个数为M个，每个神经元可能被dropout或者不被dropout。因此，每个神经元有2种选择，而M个神经元就有2&lt;sup&gt;M&lt;/sup&gt;选择，对应的就可以产生2&lt;sup&gt;M&lt;/sup&gt;种模型结构。因此，在训练模型时，就相当于训练了多个模型。对于模型中的某个权重是，在不同的dropout的神经网络中是共享的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221925312-952072953.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-17 dropout训练过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  但是，在训练好之后，需要进行预测。但是无法将如此多的模型分别进行存储，并单独预测。于是，为了解决这个问题，就在所有的不Dropout的模型的权重都乘上（1-p）%。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221936175-1056544669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-18 dropout权重处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; Dropout在线性激活函数上的表现会更好。原因在于，当激活函数为线性是，所有权重都乘上（1-p）%，dropout后的模型输出跟集成输出的结果更加接近了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Sigmoid梯度消失分析&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 但是使用Sigmoid函数作为激活函数会存在梯度消失的现象。就是当神经网络的隐藏层数量超过3层的时候，底层的参数更新就几乎为0；这是因为Sigmoid求导公式为S(x)'=S(x)(1-S(x))，当时x=0,S(x)=0.5时，maxS(x)'=0.25而当我们要求解底层的参数时，需要累乘上层参数的斜率，也就是要乘上多个小于0.25的数，当乘的个数较多时，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819222243568-150993961.png&quot; alt=&quot;&quot;/&gt;的值就会变得很小，从而导致梯度消失现象。而由于ReLu函数的斜率为1，进行求导在累乘，不会产生上述情况。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361/?spm_id_from=333.788.videocard.0&quot;&gt;&lt;span&gt;[1]机器学习-李宏毅&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 14:27:00 +0000</pubDate>
<dc:creator>Remixi</dc:creator>
<og:description>模型训练技巧 神经网络模型设计训练流程 图1-1 神经模型设计流程 当我们设计并训练好一个神经网络之后，需要在训练集上进行验证模型效果是否良好。这一步的目的在于判断模型是否存在欠拟合；在确定已经在训练</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrPan/p/9503008.html</dc:identifier>
</item>
<item>
<title>区块链的共识算法 及 分叉 的通俗讲解 （一） - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/9502971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/9502971.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;本文不做一般入门的区块链描述讲解。着重简述讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区块链的分叉&lt;/li&gt;
&lt;li&gt;共识算法&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于最近的开发工作是与以太坊公链相关的去中心化交易所，项目两个多月之久，对区块链相关的知识内容了解了一些，故择文以记录之，但求文字通俗易懂，无纰漏。因自身求学过程中所遇坑无数，业内良文亦少之又少，深感朦胧之懂之不爽。此外，亦坚信区块链技术未来必能大放光芒，因现在多应用于虚拟货币，故人谈区块链，内心首想皆炒币相关之内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简单过一下区块链&quot;&gt;简单过一下区块链&lt;/h3&gt;
&lt;p&gt;我们一般意识形态中的 链 是&lt;code&gt;铁链&lt;/code&gt;，由铁铸成，一环扣一环。形象地，区块链的也可以这么理解，只不过它不是由铁铸成，而是由拥有一定&lt;code&gt;数据结构的块&lt;/code&gt;连接而成，这是一个最&lt;code&gt;简单的雏形&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;见下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551d9f9a4d86a1?w=1422&amp;amp;h=427&amp;amp;f=png&amp;amp;s=44594&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通俗讲解共识&quot;&gt;通俗讲解共识&lt;/h3&gt;
&lt;p&gt;所谓&lt;code&gt;共识&lt;/code&gt;，通俗来说，就是我们大家对某种事物的理解达成一致的意思。比如说日常的开会讨论问题，又比如判断一个动物是不是猫，我们肉眼看了后觉得像猫，其满足猫的特征，那么我们认为它是猫。共识，是一种规则。&lt;/p&gt;
&lt;p&gt;继续我们的会议例子。参与&lt;code&gt;会议的人&lt;/code&gt;，通过&lt;code&gt;开会&lt;/code&gt;的方式来达到&lt;code&gt;谈论解决问题&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对比&lt;code&gt;区块链&lt;/code&gt;中，参与&lt;code&gt;挖矿的矿工&lt;/code&gt;通过某种&lt;code&gt;共识方式(算法)&lt;/code&gt;来解决&lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;。让账本保持一致的深入一层意思就是，让链中区块信息保持一致。&lt;/p&gt;
&lt;p&gt;为什么需要&lt;code&gt;共识&lt;/code&gt;，不需要可不可以？当然不可以，生活中没了&lt;code&gt;共识的规则&lt;/code&gt;，一切乱套。区块链没了&lt;code&gt;共识的规则&lt;/code&gt;，各个节点各干各的，失去一致的意义。&lt;/p&gt;
&lt;p&gt;这两个例子的对应的关系如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;会议的人&lt;/code&gt; = &lt;code&gt;挖矿的矿工&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;开会&lt;/code&gt; = &lt;code&gt;共识方式(算法)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;谈论解决问题&lt;/code&gt; = &lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你对&lt;code&gt;节点&lt;/code&gt;的概念意思不懂，请先理解为&lt;code&gt;矿工&lt;/code&gt;，一个节点内部包含很多角色，矿工是其中之一。&lt;/p&gt;
&lt;h3 id=&quot;共识算法&quot;&gt;共识算法&lt;/h3&gt;
&lt;p&gt;目前常见的在区块链中，节点们&lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;的&lt;code&gt;共识方式(算法)&lt;/code&gt;有如下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PoW，代表者是比特币 (BTC)
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。&lt;/li&gt;
&lt;li&gt;存在巨大的算力浪费，看看矿池消耗大量的电力资源，随着难度增加，挖出的不够付电费&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PoS，代表者是以太坊 (ETH)，从PoW过度到PoS
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;破坏者对网络的攻击成本很低，拥有代币就能竞争&lt;/li&gt;
&lt;li&gt;另外拥有代币数量大的节点获得记账权的概率会更大，会使得网络共识受少数富裕账户支配，从而失去公正性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DPoS，代表者是柚子(EOS)
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景&lt;/li&gt;
&lt;li&gt;在网络节点很少的场景，选举的见证人的代表性也不强.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PBFT 拜占庭容错，联盟链中常用
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;不适合公有链，适合联盟链&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通俗讲解下每种&lt;code&gt;共识算法&lt;/code&gt;的概念，注意！是概念，非代码层面的详细实现。&lt;/p&gt;
&lt;h4 id=&quot;pow&quot;&gt;PoW&lt;/h4&gt;
&lt;p&gt;它的全称是：&lt;code&gt;Proof of Work 工作量证明&lt;/code&gt;。字面意思，就是谁做的活越多，谁话事权越大，一定层面上类似现实生活的多劳多得的概念。该例子会穿插生活事例，其他的几个讲解将不再累赘。&lt;/p&gt;
&lt;p&gt;拿&lt;code&gt;比特币&lt;/code&gt;为例子，&lt;code&gt;比特币挖矿&lt;/code&gt;就是通过计算符合某一个比特币&lt;code&gt;区块头&lt;/code&gt;的&lt;code&gt;哈希散列值&lt;/code&gt;争夺&lt;code&gt;记账权&lt;/code&gt;。这个过程需要通过大量的计算实现，简单理解就是你进行的计算量大（工作量大），你就有大概率获得记账权，即矿工的挖出的区块并入主链。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;区块头&lt;/code&gt;，区块链中的区块的头部。你有一个饭盒，饭盒第一层，形象为动物头部，称之为头部。第一层放着米饭，米饭就是头部装载着的东西&lt;/li&gt;
&lt;li&gt;&lt;code&gt;哈希散列值&lt;/code&gt;，一种通过数学公式计算得出的值
&lt;ul&gt;&lt;li&gt;&lt;code&gt;哈希&lt;/code&gt;：数学中的散列函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;散列值&lt;/code&gt;: 通过哈希函数得出的值&lt;/li&gt;
&lt;li&gt;例如加法公式：1 + 2 = 3。那么&lt;code&gt;哈希公式&lt;/code&gt;：hash(1,2) = 结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;区块头&lt;/code&gt;的&lt;code&gt;哈希散列值&lt;/code&gt;，饭盒第一层装着的是饭。那么这里的这个值就是&lt;code&gt;区块头&lt;/code&gt;装着的东西&lt;/li&gt;
&lt;li&gt;&lt;code&gt;记账权&lt;/code&gt;，话事权，谁挖出的&lt;code&gt;区块&lt;/code&gt;是有效的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说。在很多个节点都在挖矿的情况下，大家都有可能挖出一个区块，随之广播到其他节点中去，那么每个节点中会根据谁先挖出为准，确认该区块，并入链中。&lt;/p&gt;
&lt;p&gt;对比现实生活，数学竞赛中，参数者 相当于矿工，一道题目，谁先做出就公布计算过程和答案，不由裁判判断，由参赛者一起验证，没问题后，宣布该题目结束，解题者等相关信息被记录到册子/数据库/网络。之后继续下一道题。&lt;/p&gt;
&lt;p&gt;回到比特币挖矿中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这道难题就是 &lt;code&gt;计算出正确的哈希散列值&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;计算哈希散列值&lt;/code&gt; 随着难度系数增大，会越来越困难&lt;/li&gt;
&lt;li&gt;计算需要耗费大量的电力资源，工作量大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一旦计算出了，就告诉其他节点&lt;/li&gt;
&lt;li&gt;节点收到通知后，停下手上的计算工作&lt;/li&gt;
&lt;li&gt;节点开始验证信息
&lt;ul&gt;&lt;li&gt;信息有效，当前的块被挖出，各节点开始重新挖下一个&lt;/li&gt;
&lt;li&gt;信息无效，各节点继续自己的手上的计算工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;成功挖出有效区块的节点获得奖励，比特币奖励&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时解出问题的情况怎么办？---① 答案见下一章节 &lt;a href=&quot;http://www.cnblogs.com/linguanh/p/区块链分叉&quot; class=&quot;uri&quot;&gt;区块链分叉&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链分叉&quot;&gt;区块链分叉&lt;/h3&gt;
&lt;p&gt;注意私有节点不在讨论范围内，所有节点基于公有节点。分叉的情况有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;硬分叉
&lt;ul&gt;&lt;li&gt;一旦出现，最后的结果是一分为二&lt;/li&gt;
&lt;li&gt;术语的说法：&lt;code&gt;旧节点&lt;/code&gt;无法认可新节点产生的区块，为&lt;code&gt;硬分叉&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;软分叉
&lt;ul&gt;&lt;li&gt;一旦出现，最后的结果是能掰正的&lt;/li&gt;
&lt;li&gt;术语的说法：&lt;code&gt;旧节点&lt;/code&gt;能够认可新节点产生的区块，为&lt;code&gt;软分叉&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在先回答上一章节留下的问题 --- ①，&lt;br/&gt;① 的情况是&lt;code&gt;软分叉&lt;/code&gt;的一种，当有两个或多个节点同时挖出了同区块号码的一个区块，然后它们同时广播信息出去，假设一个是&lt;code&gt;A&lt;/code&gt;，而另一个是&lt;code&gt;B&lt;/code&gt;，那么距离 A 比较近的节点，还没等到收到其他消息就先收到了 A 的信息，并开始确认 A 所挖出的这个区块的信息，随后加入A挖出的这个区块到自己所在的公链中去。同理 距离 B 比较近的节点，也会先处理 B 挖出的区块信息并添加入自己所在的公链中。&lt;/p&gt;
&lt;p&gt;上面文字对应于下图。距离 A 最近的是 &lt;code&gt;节点1&lt;/code&gt;，距离 B 最近的是 &lt;code&gt;节点5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551c11266d98cc?w=1202&amp;amp;h=916&amp;amp;f=png&amp;amp;s=215220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，出现了链的分叉。这是一种使用了同样共识算法，共识规则下导致的分叉，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551ddf6bee353c?w=1387&amp;amp;h=512&amp;amp;f=png&amp;amp;s=67111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现了这种情况，矿工是比较好自我纠正的。由于解题能力和矿工的数量成正比，因此两条链的&lt;code&gt;增长速度&lt;/code&gt;也是不一样的，在一段时间之后，总有一条链的长度要超过另一条。当矿工发现全网有一条更长的链时，他就会抛弃他当前的链，把新的更长的链全部复制回来，在这条链的基础上继续挖矿。所有矿工都这样操作，这条链就成为了主链，分叉出来的链便会被抛弃掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551f433b551ede?w=1336&amp;amp;h=653&amp;amp;f=png&amp;amp;s=102821&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;硬分叉的出现&quot;&gt;硬分叉的出现&lt;/h4&gt;
&lt;p&gt;如果区块链软件的共识规则被改变，并且这种规则改变无法向前兼容，旧节点无法认可新节点产生的区块，且旧节点偏偏就是不升级，那么该分叉将导致链一分为二。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;分叉点后的链&lt;/code&gt;，往后互不影响，节点在站好派别后，也不会再互相广播区块信息。&lt;code&gt;新节点&lt;/code&gt;和&lt;code&gt;旧节点&lt;/code&gt;会开始在不同的区块链上运行（&lt;code&gt;挖矿&lt;/code&gt;、&lt;code&gt;交易&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;等）&lt;/p&gt;
&lt;p&gt;举个简单的例子，如果节点版本1.0 所接收的区块结构字段是10个，1年后发布节点2.0版本，2.0 兼容 1.0，但是 1.0 的不能接受 2.0 版本中多出的字段。&lt;/p&gt;
&lt;p&gt;硬分叉的过程:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发者发布新的&lt;code&gt;节点代码&lt;/code&gt;，新的改变了区块链的共识规则且不被旧的兼容，于是&lt;code&gt;节点程序出现了分叉&lt;/code&gt;（software fork）&lt;/li&gt;
&lt;li&gt;区块链网络中部分节点开始运行新的节点代码，在新规则下产生的交易与区块将被旧节点拒绝，旧节点&lt;code&gt;开始短暂的断开&lt;/code&gt;与这些发送被自己拒绝的交易与区块新节点的连接，于是整个区块链&lt;code&gt;网络出现了分叉&lt;/code&gt;（network fork)&lt;/li&gt;
&lt;li&gt;新节点的矿工开始基于新规则挖矿，旧的依然用旧的规则，不同的的矿工&lt;code&gt;算力出现了分叉&lt;/code&gt;（mining fork）&lt;/li&gt;
&lt;li&gt;最终，整个区块链出现了分叉（chain fork）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个实例：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2017年8月1号，Bitcoin Cash（BCH）区块链成功在区块高度478559与主链分离。这一新的加密货币默认区块大小为8MB，并且可以实现区块容量的动态调整。&lt;br/&gt;由于旧节点只认可小于1MB的区块，所以运行BCH客户端节点产生的区块无法向前兼容，将被旧节点拒绝，最后运行不同客户端的矿工将会长期运行在两条不同的区块链上（BTC和BCH）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;软分叉的出现&quot;&gt;软分叉的出现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;不同的节点短时间差内挖出了同区块号的区块，也就是上面的&lt;code&gt;例子&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因共识规则被改变，旧节点能够识别新节点产生的区块，旧的块不能被新的接受
&lt;ul&gt;&lt;li&gt;新节点全网算力大于50%&lt;/li&gt;
&lt;li&gt;新节点全网算力小于等于50%&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种的软分叉是不一定能由节点自我纠正的。万全的解决方案必须依赖人力升级节点到同版本。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当 &lt;code&gt;新节点全网算力大于50%&lt;/code&gt;，因为新节点算力大于50%，所以不论旧节点升级不升级，最长的链也一定会是全部由新节点生成的区块组成的链。而且，这条最长链最终都会是双方都认为合法的一条，原因参考上面谈到的最长链复制，因满足下面几点所以能被复制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧的能接收新的，在分叉点之后的区块参杂着
&lt;ul&gt;&lt;li&gt;旧节点的区块&lt;/li&gt;
&lt;li&gt;新节点的区块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新的不能接收旧的，但是最终及其之后总比旧的长&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当 &lt;code&gt;新节点全网算力小于等于50%&lt;/code&gt;，最终不能通过短的复制长的达到统一，结果是：&lt;code&gt;分叉&lt;/code&gt;。原因如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧节点最终会比新节点的链要长&lt;/li&gt;
&lt;li&gt;新的总是不能接受旧的，不会去复制一条含有自己不能接受的块的链&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;写到这，发现内容铺开后比我想象中的要多。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/165527bbd831d8da?w=1139&amp;amp;h=377&amp;amp;f=png&amp;amp;s=45148&quot;/&gt;&lt;br/&gt;故目前暂时分成&lt;code&gt;两章节&lt;/code&gt;，剩下的共识算法的介绍留到&lt;code&gt;第二章&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chabuduoxiansheng1/article/details/79740018&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/chabuduoxiansheng1/article/details/79740018&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/s_lisheng/article/details/78022645&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/s_lisheng/article/details/78022645&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:25:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<og:description>作者：林冠宏 / 指尖下的幽灵 掘金：https://juejin.im/user/587f0dfe128fe100570ce2d8 博客：http://www.cnblogs.com/linguan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/9502971.html</dc:identifier>
</item>
<item>
<title>Java Runnable与Callable区别 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/9502968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/9502968.html</guid>
<description>&lt;h3&gt;接口定义&lt;/h3&gt;
&lt;p&gt;#Callable接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#Runnable接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;相同点&lt;/h3&gt;
&lt;p&gt;都是接口&lt;/p&gt;
&lt;p&gt;都可以编写多线程程序&lt;/p&gt;
&lt;p&gt;都采用Thread.start()启动线程&lt;/p&gt;
&lt;h3&gt;不同点&lt;/h3&gt;
&lt;p&gt;Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果&lt;/p&gt;
&lt;p&gt;Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;/span&gt;：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;p&gt;#Callable-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallableAndFuture {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Callable&lt;/span&gt;&amp;lt;Integer&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Thread.sleep(&lt;/span&gt;6000&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random().nextInt();
            }
        };
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(future).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;hello begin&quot;&lt;span&gt;);
            System.out.println(future.isDone());
            System.out.println(future.get());
            System.out.println(future.isDone());
            System.out.println(&lt;/span&gt;&quot;hello end&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;hello begin
&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
1664014921
&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
hello end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#Callable-2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CallableThreadTest &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {
        CallableThreadTest ctt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CallableThreadTest();
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; ft = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(ctt);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(ft, &quot;有返回值的线程&quot;&lt;span&gt;).start();
        System.out.println(&lt;/span&gt;&quot;子线程的返回值&quot; +&lt;span&gt; ft.get());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer call() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i += 2&lt;span&gt;) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; i);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
有返回值的线程 0&lt;span&gt;
有返回值的线程 &lt;/span&gt;2&lt;span&gt;
有返回值的线程 &lt;/span&gt;4&lt;span&gt;
有返回值的线程 &lt;/span&gt;6&lt;span&gt;
有返回值的线程 &lt;/span&gt;8&lt;span&gt;
子线程的返回值10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;优势&lt;/h3&gt;
&lt;p&gt;多线程返回执行结果是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下&lt;strong&gt;取消&lt;/strong&gt;该线程的任务，真的是非常有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallableAndFuture {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Callable&lt;/span&gt;&amp;lt;Integer&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Thread.sleep(&lt;/span&gt;6000&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random().nextInt();
            }
        };
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(future).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;hello begin&quot;&lt;span&gt;);
            System.out.println(future.isDone());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            future.cancel(false);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;future.isCancelled()) {
                System.out.println(future.get());
                System.out.println(future.isDone());
                System.out.println(&lt;/span&gt;&quot;hello end&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;cancel~&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:17:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<og:description>接口定义 #Callable接口 #Runnable接口 相同点 都是接口 都可以编写多线程程序 都采用Thread.start()启动线程 不同点 Runnable没有返回值；Callable可以返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/9502968.html</dc:identifier>
</item>
<item>
<title>《深入理解计算机系统》自学历程（一）模拟高速缓存逻辑（下） - 炎寒</title>
<link>http://www.cnblogs.com/xiayongming/p/9502875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiayongming/p/9502875.html</guid>
<description>&lt;p&gt;经过&lt;strong&gt;三次重写&lt;/strong&gt;，和&lt;strong&gt;合计30多个小时的开发&lt;/strong&gt;，终于把这个简单的逻辑做完了。（自己太笨）&lt;/p&gt;
&lt;p&gt;因为刚刚接触C，写的代码实现方式肯定有不对的地方，逻辑上可能也有疏漏，如果有看官发现问题还望及时给予指正，谢谢。&lt;/p&gt;


&lt;h2&gt;1.1目标：&lt;/h2&gt;
&lt;p&gt;维护一个单独的缓存空间，该空间是低一级存储的缓存。缓存的大小比低级存储的大小要小很多，通过一个逻辑将底层存储的数据抽到缓存中的一个位置。&lt;/p&gt;
&lt;h2&gt;1.2 实现思路：&lt;/h2&gt;
&lt;p&gt;　　通过阅读《深入理解计算机系统》一书，了解低级存储与缓存之间关联规则是基于存储地址的，通过一个地址映射的规则，将低级存储的地址映射到缓存的制定位置。&lt;/p&gt;
&lt;h3&gt;　　1.2.1 存储：&lt;/h3&gt;
&lt;p&gt;　　　　存储是由一个个位构成的，每个位都有一个对应的地址，地址的大小取决于计算机的字长。&lt;/p&gt;
&lt;h3&gt;　　1.2.2 低级存储：&lt;/h3&gt;
&lt;p&gt;　　　　在这次的设计中低级存储只是一个抽象概念，实际上就是内存中的一块空间，只不过我通过映射值将低级存储的地址改为从F000开始的地址。&lt;/p&gt;
&lt;h3&gt;　　1.2.3 缓存：&lt;/h3&gt;
&lt;p&gt;　　　　缓存是比低级存储小得多的集合，因为存储越大寻址的时间越长，所以需要一个小的缓存来存储处理器近期使用到的数据。&lt;/p&gt;
&lt;p&gt;　　　　这次设计中的缓存也只是一个抽象概念，也是内存的一块空间，也是通过映射值将缓存的地址改为A000开始的地址。&lt;/p&gt;
&lt;p&gt;　　如何将低级存储的地址映射到缓存——缓存模型：&lt;/p&gt;
&lt;p&gt;　　　　缓存模型主要分——组、行、缓存单元&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.1 组&lt;/h4&gt;
&lt;p&gt;　　　　　　在逻辑上没有体现，知识对地址进行切割并划分了一个范围，是在映射逻辑上有关，在实际内存中不会存储。&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.2 行&lt;/h4&gt;
&lt;p&gt;　　　　　　也是一个逻辑体现，主要是为了更好的提升缓存的寻址效率而设置的思想。&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.3 缓存单元：&lt;/h4&gt;
&lt;p&gt;　　　　　　实际存储数据的对象，其中包含了标识、是否加载、以及字节块。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;标识：&lt;/strong&gt;标识是地址的一部分根据规则截取出来的，通过地址另一部分找到对应的组以后就会对其中的行进行遍历，根据标识找到对应的行。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;是否加载：&lt;/strong&gt;用来标识该缓存是否已经加载数据。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;字节块：&lt;/strong&gt;用来存储缓存数据。（大小可设置）&lt;/p&gt;
&lt;p&gt;　　   　&lt;strong&gt;1.2.3.4 总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　通过上述的几个对象，我们将缓存组织成了一个三层的结构，第一层是组、第二层是行、第三层是存储单元。一个缓存可以有S个组，可以有E个行，每行只能有一个缓存单元。&lt;/p&gt;
&lt;h3&gt;　　&lt;strong&gt;1.2.4 全相连高速缓存、组相连高速缓存、直接映射高速缓存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　全相连高速缓存就是缓存中只有一个组，有E个行的方式实现。&lt;/p&gt;
&lt;p&gt;　　　　组相连高速缓存就是一个缓存中有S个组，E个行的实现方式。&lt;/p&gt;
&lt;p&gt;　　　　直接映射高速缓存就是一个缓存中有S个组，1个行和1个缓存单元的实现方式。&lt;/p&gt;
&lt;h3&gt;　　 1.2.5 缓存各项指标的设置：&lt;/h3&gt;
&lt;p&gt;　　　　组数、行数、缓存数据块的大小的设置直接影响缓存的效率但也要根据实际情况，大小对不同的情况有不同的策略。&lt;/p&gt;


&lt;h2&gt;　　2.1 公共常量：&lt;/h2&gt;
&lt;p&gt;　　　　计算机字长：MemAddrLength&lt;/p&gt;
&lt;h2&gt;　　2.2 几个核心对象：&lt;/h2&gt;
&lt;h3&gt;　　　　2.2.1 硬件控制器：HWController&lt;/h3&gt;
&lt;p&gt;　　　　　　属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　　存储空间大小&lt;/p&gt;
&lt;p&gt;　　　　　　1）写方法（Write）：传入一个虚拟硬件地址（自己映射的，从F000开始）和一个长度。映射后写入数据到内存。&lt;/p&gt;
&lt;p&gt;　　　　　　2）读方法（Read）：传入一个虚拟硬件地址和一个长度。映射后从内存读出数据，并写到一个新的内存空间并返回该指针。&lt;/p&gt;
&lt;h3&gt;　　　　2.2.2 缓存控制器：CacheController&lt;/h3&gt;
&lt;p&gt;　　　　　　1）缓存单元查询器（CacheFinder）：&lt;/p&gt;
&lt;p&gt;　　　　　　2）读方法（Read）：传入一个硬件虚拟地址和长度，在缓存中查找对应的单元，如果找不到从硬件中读取数据写到缓存，并将数据写到内存新的空间中、返回该指针。&lt;/p&gt;
&lt;p&gt;　　　　　　3）写方法（Write）：传入一个硬件虚拟地址和长度，将数据写入到硬件中再写到缓存里（实际上缓存会有多种策略、直写/不直写等等）。&lt;/p&gt;
&lt;p&gt;　　　　　　4）取下一个（Next）：将传入缓存单元指针移动到相邻的下一个缓存单元，如果超出缓存范围则返回0x00。&lt;/p&gt;
&lt;h2&gt;　　2.3 执行结果概述&lt;/h2&gt;
&lt;p&gt;　　返回四大部分：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1）总体介绍部分，会将地址空间、缓存的S、E、B、t几个主要参数值显示出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214017794-1982648866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2）内存查看部分，会将初始化后虚拟硬件存储和缓存存储的值都写出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214117128-1050858882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214149859-2101098484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）缓存大小显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214205284-869079733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）缓存读值测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的集合是所有缓存单元的参数和右侧缓存单元字节块中的数据。&lt;/p&gt;
&lt;p&gt;上面的集合是根据指令从缓存中读取出来的数据内容。&lt;/p&gt;
&lt;p&gt;通过这两个集合可以验证读取数据是否正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214804303-1557373069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 剩下没解决的问题：&lt;/p&gt;
&lt;p&gt;在写缓存的时候，如果该组所有缓存单元都已经初始化了，就需要通过一个科学的方式选择一个块覆盖或驱逐，目前是用随机数，不太合理。&lt;/p&gt;
&lt;p&gt;抽象不够，没有悟透和语言不熟导致很多复用问题比较多，有问题望指出。后续有时间我会继续完善。&lt;/p&gt;
&lt;p&gt;说不定有BUG，如果有客观指正。&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;185&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;math.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt; * 基本设定初始化
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _memSize = &lt;span&gt;1024&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存大小（字节）&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _memAddrLength = &lt;span&gt;16&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址长度&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _cacheSize = &lt;span&gt;256&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存大小&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt; * 硬件控制器
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HWController{
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _memStartAddr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;start addr 0XF0&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; _memAddr;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _memOffset;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* (*Read)(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; (*Write)(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt; * 缓存控制器：
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt; *      1）缓存单元集合指针 CacheUnitArrayPtr
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt; *      2）缓存查询函数 CacheFinder
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt; *      3）缓存读函数 Read
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt; *      4）缓存写函数 Write
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheController {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _s;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _sMask;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _S;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _E;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _b;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _bMask;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _B;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _t;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _tMask;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _C;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _unitCount;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _unitSize;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheSize;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheStartAddr;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; _cacheMemAddr;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheOffset;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit*&lt;span&gt; CacheUnitArrayPtr;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* (*Next)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;unit);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* (*CacheFinder)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; Addr);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* (*Read)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; (*Write)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt; * 缓存单元
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt; *      1）数据块集合指针 BlockArrayPtr;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt; *      2）t标志位 tCode;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt; *      3）热标识位 hot;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; BlockArrayPtr;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; tCode;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt; Hot;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HWController&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; _hwWrite(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* ptr = (unsigned &lt;span&gt;char&lt;/span&gt;*)(memOffset +&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(length--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         *ptr = *&lt;span&gt;data;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         data++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;* _hwRead(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr = (unsigned &lt;span&gt;char&lt;/span&gt;*)(memOffset +&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *retPtr = &lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(length);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *loopPtr =&lt;span&gt; retPtr;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(length--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         *loopPtr = *&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         loopPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retPtr;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; HWController*&lt;span&gt; GetHWCtroller(){
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; HWController *ctrl = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HWController));
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *rPtr = &lt;span&gt;malloc&lt;/span&gt;(_memSize);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get ptr point to Memory Space.&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;     (*ctrl)._memStartAddr = &lt;span&gt;0xF000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     (*ctrl)._memOffset = (unsigned &lt;span&gt;long&lt;/span&gt;) (rPtr - (*&lt;span&gt;ctrl)._memStartAddr);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     (*ctrl)._memAddr =&lt;span&gt; rPtr;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     (*ctrl).Write =&lt;span&gt; _hwWrite;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     (*ctrl).Read =&lt;span&gt; _hwRead;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr =&lt;span&gt; rPtr;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( i &amp;lt;&lt;span&gt; _memSize ){
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         *ptr = i + &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;==&amp;gt;Memory:\r\n startAddr:%X,offset:%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*ctrl)._memStartAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)((*&lt;span&gt;ctrl)._memOffset ));
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ctrl;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CacheController&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheUnit* _next(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;unit){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;    unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)((unsigned &lt;span&gt;long&lt;/span&gt;)unit + ctrl-&amp;gt;&lt;span&gt;_unitSize);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; unit &amp;gt;= (ctrl-&amp;gt;_cacheSize + ctrl-&amp;gt;_cacheMemAddr) ? &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt; : unit;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheUnit* _cacheFinder(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; addr){
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _tBit = (addr&amp;amp;(*ctrl)._tMask)&amp;gt;&amp;gt;((*ctrl)._b+(*&lt;span&gt;ctrl)._s);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _sBit = (addr&amp;amp;(*ctrl)._sMask)&amp;gt;&amp;gt;((*&lt;span&gt;ctrl)._b);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _bBit = (addr&amp;amp;(*&lt;span&gt;ctrl)._bMask);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;\r\n\r\n====&amp;gt;Find Addr:%X \r\n tMask:%X,tVal:%X \t sMask:%X,sVal:%X \t bMask:%X,bVal:%X&quot;,addr,(*ctrl)._tMask,_tBit,(*ctrl)._sMask,_sBit,(*ctrl)._bMask,_bBit);&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* _unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)((*ctrl)._cacheStartAddr + ctrl-&amp;gt;_cacheOffset + _sBit * ((*ctrl)._E * ctrl-&amp;gt;&lt;span&gt;_unitSize));
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; e = (*&lt;span&gt;ctrl)._E;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; ( e--&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((*_unit).tCode ==&lt;span&gt; _tBit){
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _unit;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;         _unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)(((unsigned &lt;span&gt;long&lt;/span&gt;)_unit)+ ctrl-&amp;gt;&lt;span&gt;_unitSize);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;* _cacheRead(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ctrl-&amp;gt;&lt;span&gt;CacheFinder(ctrl,addr);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo: 找时间把Loader抽象出来或者其他方式优化复用。&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         unsigned &lt;span&gt;char&lt;/span&gt; *read = hwctrl-&amp;gt;Read(hwctrl-&amp;gt;&lt;span&gt;_memOffset,addr,length);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         ctrl-&amp;gt;&lt;span&gt;Write(ctrl,hwctrl,addr,read,length);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         unit = ctrl-&amp;gt;&lt;span&gt;CacheFinder(ctrl,addr);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nERROR::can not load cache by %X !!!! \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)addr);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *memPtr = &lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(length);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *memLoopPtr =&lt;span&gt; memPtr;
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = (*unit).BlockArrayPtr + (ctrl-&amp;gt;_bMask &amp;amp;&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         *memLoopPtr = *&lt;span&gt;blockPtr;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         memLoopPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         blockPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(blockPtr &amp;gt;= (*unit).BlockArrayPtr + (*&lt;span&gt;ctrl)._B){
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             unit = ctrl-&amp;gt;CacheFinder(ctrl,addr + i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nERROR::can not load cache by %X !!!! \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,(unsigned &lt;span&gt;int&lt;/span&gt;)(addr +&lt;span&gt; i));
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                     exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; memPtr;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; _cacheWrite(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入底层内存先。&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;     hwctrl-&amp;gt;Write(hwctrl-&amp;gt;&lt;span&gt;_memOffset,addr,data,length);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入缓存&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr =&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i&amp;lt;&lt;span&gt;length){
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ctrl-&amp;gt;CacheFinder(ctrl,addr +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!unit||!unit-&amp;gt;&lt;span&gt;Hot)
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;             unsigned &lt;span&gt;long&lt;/span&gt; startAddr = (unsigned &lt;span&gt;long&lt;/span&gt;)(ctrl-&amp;gt;_cacheMemAddr + (((ctrl-&amp;gt;_sMask &amp;amp; (addr + i)) &amp;gt;&amp;gt; ((*ctrl)._b)) * ctrl-&amp;gt;_E) * ctrl-&amp;gt;&lt;span&gt;_unitSize) ;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;             unsigned &lt;span&gt;long&lt;/span&gt; endAddr = (unsigned &lt;span&gt;long&lt;/span&gt;)(ctrl-&amp;gt;_cacheMemAddr + (((ctrl-&amp;gt;_sMask &amp;amp; (addr + i)) &amp;gt;&amp;gt; ((*ctrl)._b)) * ctrl-&amp;gt;_E)) + ctrl-&amp;gt;_E * ctrl-&amp;gt;&lt;span&gt;_unitSize;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;             unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;)startAddr;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; hit = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(unit){
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!unit-&amp;gt;&lt;span&gt;Hot)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                     hit=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                 unit = ctrl-&amp;gt;&lt;span&gt;Next(ctrl,unit);
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((unsigned &lt;span&gt;long&lt;/span&gt;)unit &amp;gt;=&lt;span&gt; endAddr){
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;hit)
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                 printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\rnhit!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                &lt;span&gt;int&lt;/span&gt; rm = rand() % ( ctrl-&amp;gt;&lt;span&gt;_E );
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                unit = startAddr + rm * ctrl-&amp;gt;&lt;span&gt;_unitSize;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             unit-&amp;gt;tCode = ((addr + i) &amp;amp; ctrl-&amp;gt;_tMask) &amp;gt;&amp;gt; ((*ctrl)._b+(*&lt;span&gt;ctrl)._s);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             unit-&amp;gt;Hot = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = unit-&amp;gt;BlockArrayPtr + ((addr+i)&amp;amp;ctrl-&amp;gt;&lt;span&gt;_bMask);
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;         *blockPtr = *&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheController* GetCacheController(unsigned &lt;span&gt;int&lt;/span&gt; _memAddrLength, unsigned &lt;span&gt;int&lt;/span&gt; cacheSize, unsigned &lt;span&gt;int&lt;/span&gt; blockSize,unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; E){
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheController *cache = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheController));
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     (*cache)._b = (unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)log2(blockSize);
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;     (*cache)._B =&lt;span&gt; blockSize;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     (*cache)._bMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,(*cache)._b) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     (*cache)._E =&lt;span&gt; E;
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; 
&lt;span&gt;219&lt;/span&gt;     (*cache)._S = cacheSize / (*cache)._B / (*&lt;span&gt;cache)._E;
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     (*cache)._s = (unsigned &lt;span&gt;int&lt;/span&gt;)log2((*&lt;span&gt;cache)._S);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;     (*cache)._sMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,((*cache)._b + (*cache)._s)) - (*cache)._bMask - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; 
&lt;span&gt;223&lt;/span&gt;     (*cache)._C = (*cache)._B * (*cache)._E * (*&lt;span&gt;cache)._S;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     (*cache)._t = _memAddrLength - (*cache)._s - (*&lt;span&gt;cache)._b;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;     (*cache)._tMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,_memAddrLength) - (*cache)._bMask - (*cache)._sMask - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; 
&lt;span&gt;228&lt;/span&gt;     (*cache)._unitCount = (*cache)._E * (*&lt;span&gt;cache)._S;
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;     (*cache)._unitSize = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; CacheUnit) + (*&lt;span&gt;cache)._B;
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; 
&lt;span&gt;231&lt;/span&gt;     (*cache)._cacheSize = (*cache)._unitSize * (*&lt;span&gt;cache)._unitCount;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;apply mem&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt;     (*cache)._cacheMemAddr = &lt;span&gt;malloc&lt;/span&gt;((*&lt;span&gt;cache)._cacheSize);
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     (*cache)._cacheStartAddr = &lt;span&gt;0xA000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     (*cache)._cacheOffset = (unsigned &lt;span&gt;long&lt;/span&gt;)((*cache)._cacheMemAddr - cache-&amp;gt;&lt;span&gt;_cacheStartAddr);
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; counter = (*&lt;span&gt;cache)._unitCount;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)(*&lt;span&gt;cache)._cacheMemAddr;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; 
&lt;span&gt;240&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(counter){
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         (*unit).Hot = &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;         (*unit).tCode =&lt;span&gt; counter;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;         (*unit).BlockArrayPtr = (unsigned &lt;span&gt;char&lt;/span&gt; *)(((unsigned &lt;span&gt;long&lt;/span&gt;)unit) + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit));
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(x = &lt;span&gt;0&lt;/span&gt;;x &amp;lt; cache-&amp;gt;_B ; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;             *(unit-&amp;gt;BlockArrayPtr + x) = (unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;)x;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;         unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)((*unit).BlockArrayPtr + (*&lt;span&gt;cache)._B);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;         counter--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;     (*cache).Next =&lt;span&gt; _next;
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;     (*cache).CacheFinder =&lt;span&gt; _cacheFinder;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;     (*cache).Read =&lt;span&gt; _cacheRead;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;     (*cache).Write =&lt;span&gt; _cacheWrite;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n==&amp;gt;CacheSize:\r\n MemAddrLength = %d. C = %d, \r\nS = %d, E = %d, B = %d; \r\n s = %d, b = %d, t = %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,_memAddrLength,(*cache)._C,(*cache)._S,(*cache)._E,(*cache)._B,(*cache)._s,(*cache)._b,(*&lt;span&gt;cache)._t);
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\ncacheAddr:%X,cacheStartAddr:%X, cacheOffset:%X, cacheSize:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheMemAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheStartAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheOffset,(unsigned &lt;span&gt;int&lt;/span&gt;) (*&lt;span&gt;cache)._cacheSize);
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nbMask:%x,sMask:%x,tMask:%x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._bMask,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._sMask,(unsigned &lt;span&gt;int&lt;/span&gt;)(*&lt;span&gt;cache)._tMask);
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; 
&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; 
&lt;span&gt;263&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;utility&lt;/span&gt;
&lt;span&gt;264&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrintMem(&lt;span&gt;char&lt;/span&gt;* title, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt; length,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; split){
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n\r\n=====&amp;gt; title::%s::  Printing Mem %X,Length:%d  &amp;lt;=======\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,title,(unsigned &lt;span&gt;int&lt;/span&gt;)addr,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)length);
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr = (unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;)addr;
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; 
&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( i % &lt;span&gt;16&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n%d\t%X\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ptr);
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( i &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; i % &lt;span&gt;4&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*&lt;span&gt;ptr);
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrintCache(&lt;span&gt;char&lt;/span&gt;* title, &lt;span&gt;struct&lt;/span&gt; CacheController*&lt;span&gt; ctrl){
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n\r\n=====&amp;gt; title::%s::  Printing Mem %X,Length:%d  &amp;lt;=======\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,title,(unsigned &lt;span&gt;int&lt;/span&gt;)(ctrl-&amp;gt;_cacheStartAddr + ctrl-&amp;gt;_cacheOffset),(unsigned &lt;span&gt;int&lt;/span&gt;)ctrl-&amp;gt;&lt;span&gt;_unitCount);
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt; 
&lt;span&gt;284&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ( &lt;span&gt;struct&lt;/span&gt; CacheUnit *)(ctrl-&amp;gt;_cacheStartAddr + ctrl-&amp;gt;&lt;span&gt;_cacheOffset);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt; ctrl-&amp;gt;&lt;span&gt;_unitCount){
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--Unit%d[[tCode:%d,BlockPtr:%X,Hot:%d]] Blocks:\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;tCode,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;BlockArrayPtr,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;&lt;span&gt;Hot);
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;         j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(j &amp;lt; ctrl-&amp;gt;&lt;span&gt;_B){
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)*&lt;span&gt;blockPtr);
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;             blockPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt;             j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;         unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)(((unsigned &lt;span&gt;long&lt;/span&gt;)unit) + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; CacheUnit) + ctrl-&amp;gt;&lt;span&gt;_B);
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;         blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, World!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; HWController hwCtrl = *&lt;span&gt;GetHWCtroller();
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheController cacheCtrl = *GetCacheController(_memAddrLength,_cacheSize,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; 
&lt;span&gt;306&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HW Unit Test
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot;&quot;,(unsigned long)hwCtrl._memAddr,16,0);
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char temp = 0xAA;
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *data = &amp;amp;temp;
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    hwCtrl.Write(hwCtrl._memOffset,0XF002,data,1);
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot; HWMEM 0~16 &quot;,(unsigned long)hwCtrl._memAddr,16,0);
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *retData = hwCtrl.Read(hwCtrl._memOffset,0XF002,1);
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot; HWMEM 0XF002 &quot;,(unsigned long)retData,1,0);
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *retData = hwCtrl.Read(hwCtrl._memOffset,0XF002,1);&lt;/span&gt;
&lt;span&gt;315&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; HWMEM ALL &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;long&lt;/span&gt;)hwCtrl._memAddr,_memSize,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; 
&lt;span&gt;317&lt;/span&gt; 
&lt;span&gt;318&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cache Unit Test&lt;/span&gt;
&lt;span&gt;319&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; CACHE ALL &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;long&lt;/span&gt;)cacheCtrl._cacheMemAddr,cacheCtrl._cacheSize,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; 
&lt;span&gt;321&lt;/span&gt; 
&lt;span&gt;322&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;struct test&lt;/span&gt;
&lt;span&gt;323&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit cu =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;
&lt;span&gt;327&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitTypeSize %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit));
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu));
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize.Hot %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.Hot));
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize.tCode %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.tCode));
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize ptr %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.BlockArrayPtr));
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; 
&lt;span&gt;334&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReadCacheTest&lt;/span&gt;
&lt;span&gt;335&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&quot;&lt;/span&gt;,cacheCtrl.Read(&amp;amp;cacheCtrl,&amp;amp;hwCtrl,&lt;span&gt;0XF038&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;),&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;     PrintCache(&lt;span&gt;&quot;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;cacheCtrl);
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 19 Aug 2018 13:58:00 +0000</pubDate>
<dc:creator>炎寒</dc:creator>
<og:description>经过三次重写，和合计30多个小时的开发，终于把这个简单的逻辑做完了。（自己太笨） 因为刚刚接触C，写的代码实现方式肯定有不对的地方，逻辑上可能也有疏漏，如果有看官发现问题还望及时给予指正，谢谢。 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiayongming/p/9502875.html</dc:identifier>
</item>
<item>
<title>Java并发编程原理与实战三十一:Future&amp;FutureTask 浅析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9502771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9502771.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、Futrue模式有什么用？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;------&amp;gt;正所谓技术来源与生活，这里举个栗子。在家里，我们都有煮菜的经验。（如果没有的话，你们还怎样来泡女朋友呢？你懂得）。现在女票要你煮四菜一汤，这汤是鸡汤，有常识的人鸡汤要煲好久滴。如果你先炒四个菜，最后再煲汤，估计都已经一天的时间了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;好了。如果我们先煲汤，在煲汤的时候，同时去炒四个菜。这个模式就是Future模式啦。是不是很简单。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------》实现Future模式的，我们直接用JDK提供给我们的FutureTask类就可以了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》直接上代码吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FutureTask 是实现了RunnableFuture&amp;lt;&amp;gt;接口，而RunnablFuture接口继承了Runnable和Future接口.&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;223.5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、Future可以让我们提前处理一些复杂的运行。非常的方便。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里，我们自己去实现一个Future！！！！是不是很兴奋。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;本人编程的思想一般都是来自于生活。从问题出发，再去找到对应的解决方法。而不是先学习大量无关的解决问题的方法，再去解决问题（当然要辩证去看这个问题）。。。不知道有无人看不懂这句话呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------》设计目的：设计一个方法，能在未来某一个时间点，拿出一个结果。如果在未来的那个时刻拿不出来，那就让线程去等待，一直等到拿个结果（无论成功还是出错的结果）才开始执行另外的事情。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
=====================================================
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 场景：一天，我要去订一个蛋糕，去到蛋糕店，下了个订单，我就去上班了，下班之后，拿到蛋糕，回家吃啦。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 面向对象思想，蛋糕店，使用工厂模式的对象。客人，一个对象。产品，里面有订单的对象。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ，去到蛋糕店，拿到蛋糕店给的订单，使用工厂模式来模拟这个工厂，&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
Factory pf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Factory(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个蛋糕店&lt;/span&gt;
Future f = pf.createOrder(&quot;蛋糕&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 蛋糕店生成什么产品，返回一个生成什么的订单&lt;/span&gt;
System.out.println(&quot;我去上班了,下班回来拿蛋糕。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据订单拿到做好的蛋糕，如果没做完就要等待蛋糕店做完。&lt;/span&gt;
System.out.println(&quot;下班去拿蛋糕，拿到蛋糕了&quot;+&lt;span&gt;f.getProduct());
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Factory相当于蛋糕店，接受订单，开始生产蛋糕&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供客人一个订单&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Future createOrder(String name) {
Future f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Future();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个订单&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
System.out.println(&lt;/span&gt;&quot;开始生产蛋糕&quot;&lt;span&gt;);
Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Product(name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成产品&lt;/span&gt;
System.out.println(&quot;生产蛋糕结束&quot;&lt;span&gt;);
f.setProduct(product);
}
}).start();
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订单编号&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的产品名称&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product(String name) {
&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; random.nextInt();
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
e.printStackTrace();
}
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Product [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Future {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Product product;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true:生产完了，false：还没生产完&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProduct(Product product) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.product=&lt;span&gt;product;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果生产完，直接返回就可以，不用再重新设置了。&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
flag&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
notifyAll(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 叫醒所有处于wait状态的线程&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; Product getProduct() {
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!flag) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当还没有生产完的时候，就要等待。&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
wait();
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
e.printStackTrace();
}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Future [product=&quot; + product + &quot;]&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、Future源码解读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Future API以及应用场景&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、Future的核心实现原理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、Future的源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、怎样使用Future API呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》如果一问到这个问题，可以马上向起这三点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.1 new 一个Callable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.2 将刚刚创建的Callable的实例交给FutureTask&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.3 将刚刚创建的FutureTask实例交给Thread&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果有看过源码的朋友，都会问一个问题，就是Callable和Runnable有什么区别？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》Runnable的run方法是被线程调用的，在run方法时异步执行的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Callable的Call方法，不是异步执行的，是由Future的run方法调用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口Callable：有返回结果并且可能抛出异常的任务； &lt;br/&gt;接口Runnable：没有返回结果 &lt;br/&gt;接口Future：表示异步执行的结果； &lt;br/&gt;类FutureTask：实现Future、Runnable等接口，是一个异步执行的任务。可以直接执行，或包装成Callable执行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体详细可以参考：https://blog.csdn.net/lican19911221/article/details/78200344&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、再次理解Future模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;模拟代码1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonCook {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步 网购厨具&lt;/span&gt;
        OnlineShopping thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnlineShopping();
        thread.start();
        thread.join();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证厨具送到
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步 去超市购买食材&lt;/span&gt;
        Thread.sleep(2000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟购买食材时间&lt;/span&gt;
        Shicai shicai = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shicai();
        System.out.println(&lt;/span&gt;&quot;第二步：食材到位&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步 用厨具烹饪食材&lt;/span&gt;
        System.out.println(&quot;第三步：开始展现厨艺&quot;&lt;span&gt;);
        cook(thread.chuju, shicai);
        
        System.out.println(&lt;/span&gt;&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 网购厨具线程&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OnlineShopping &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Chuju chuju;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;第一步：下单&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;第一步：等待送货&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;5000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟送货时间&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&lt;/span&gt;&quot;第一步：快递送到&quot;&lt;span&gt;);
            chuju &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chuju();
        }
        
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  用厨具烹饪食材&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cook(Chuju chuju, Shicai shicai) {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 厨具类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chuju {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 食材类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shicai {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：下单
第一步：等待送货
第一步：快递送到
第二步：食材到位
第三步：开始展现厨艺
总共用时7013ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有人问了，不阻塞主线程行不行？？？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不行！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，怎么做饭。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Where there is a will，there is a way！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟代码2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FutureCook {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步 网购厨具&lt;/span&gt;
        Callable&amp;lt;Chuju&amp;gt; onlineShopping = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Chuju&amp;gt;&lt;span&gt;() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Chuju call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                System.out.println(&lt;/span&gt;&quot;第一步：下单&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;第一步：等待送货&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;5000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟送货时间&lt;/span&gt;
                System.out.println(&quot;第一步：快递送到&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chuju();
            }
            
        };
        FutureTask&lt;/span&gt;&amp;lt;Chuju&amp;gt; task = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Chuju&amp;gt;&lt;span&gt;(onlineShopping);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步 去超市购买食材&lt;/span&gt;
        Thread.sleep(2000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟购买食材时间&lt;/span&gt;
        Shicai shicai = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shicai();
        System.out.println(&lt;/span&gt;&quot;第二步：食材到位&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步 用厨具烹饪食材&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!task.isDone()) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 联系快递员，询问是否到货&lt;/span&gt;
            System.out.println(&quot;第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）&quot;&lt;span&gt;);
        }
        Chuju chuju &lt;/span&gt;=&lt;span&gt; task.get();
        System.out.println(&lt;/span&gt;&quot;第三步：厨具到位，开始展现厨艺&quot;&lt;span&gt;);
        cook(chuju, shicai);
        
        System.out.println(&lt;/span&gt;&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  用厨具烹饪食材&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cook(Chuju chuju, Shicai shicai) {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 厨具类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chuju {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 食材类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shicai {}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：下单
第一步：等待送货
第二步：食材到位
第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）
第一步：快递送到
第三步：厨具到位，开始展现厨艺
总共用时5005ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好神奇，有没有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面具体分析一下第二段代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）&lt;/strong&gt;把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Computes a result, or throws an exception if unable to do so.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; computed result
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception if unable to compute a result
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）&lt;/strong&gt;把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FutureTask&amp;lt;V&amp;gt; &lt;span&gt;implements&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Runnable, Future&amp;lt;V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Future&amp;lt;V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; cancel(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mayInterruptIfRunning);

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCancelled();

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isDone();

    V get() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException;

    V get(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException, TimeoutException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去&lt;em&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/em&gt;方法f的计算过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的&lt;em&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/em&gt;包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;get方法：获取计算结果（如果还没计算完，也是必须等待的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cancel方法：还没计算完，可以取消计算过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isDone方法：判断是否计算完&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isCancelled方法：判断计算是否被取消&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些接口的设计很完美，FutureTask的实现注定不会简单，后面再说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）&lt;/strong&gt;在第三步里面，调用了isDone方法查看状态，然后直接调用task.get方法获取厨具，不过这时还没送到，所以还是会等待3秒。对比第一段代码的执行结果，这里我们节省了2秒。这是因为在快递员送货期间，我们去超市购买食材，这两件事在同一时间段内异步执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过以上3步，我们就完成了对Java原生Future模式最基本的应用。下面具体分析下FutureTask的实现，先看JDK8的，再比较一下JDK6的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然FutureTask也是一个Runnable，那就看看它的run方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state != NEW ||
            !UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, runnerOffset,
                                         &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Thread.currentThread()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Callable&lt;/span&gt;&amp;lt;V&amp;gt; c = callable; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的callable是从构造方法里面传人的&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state ==&lt;span&gt; NEW) {
                V result;
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; ran;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    result &lt;/span&gt;=&lt;span&gt; c.call();
                    ran &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                    result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    ran &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    setException(ex); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存call方法抛出的异常&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ran)
                    set(result); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存call方法的执行结果&lt;/span&gt;
&lt;span&gt;            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runner must be non-null until state is settled to
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prevent concurrent calls to run()&lt;/span&gt;
            runner = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state must be re-read after nulling runner to prevent
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaked interrupts&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;先看try语句块里面的逻辑，发现run方法的主要逻辑就是运行Callable的call方法，然后将保存结果或者异常（用的一个属性result）。这里比较难想到的是，将call方法抛出的异常也保存起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里表示状态的属性state是个什么鬼&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; Possible state transitions:
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; NORMAL
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; EXCEPTIONAL
     &lt;/span&gt;* NEW -&amp;gt;&lt;span&gt; CANCELLED
     &lt;/span&gt;* NEW -&amp;gt; INTERRUPTING -&amp;gt;&lt;span&gt; INTERRUPTED
     &lt;/span&gt;*/
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NEW          = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COMPLETING   = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORMAL       = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCEPTIONAL  = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED    = 4&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTING = 5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTED  = 6;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;把FutureTask看作一个Future，那么它的作用就是控制Callable的call方法的执行过程，在执行的过程中自然会有状态的转换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）一个FutureTask新建出来，state就是NEW状态；COMPETING和INTERRUPTING用的进行时，表示瞬时状态，存在时间极短(&lt;em&gt;为什么要设立这种状态？？？不解&lt;/em&gt;)；NORMAL代表顺利完成；EXCEPTIONAL代表执行过程出现异常；CANCELED代表执行过程被取消；INTERRUPTED被中断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）执行过程顺利完成：NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）执行过程出现异常：NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）执行过程被取消：NEW -&amp;gt; CANCELLED&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）执行过程中，线程中断：NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码中状态判断、CAS操作等细节，请读者自己阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看看get方法的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; V get() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;lt;=&lt;span&gt; COMPLETING)
            s &lt;/span&gt;= awaitDone(&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; report(s);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(&lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : 0L&lt;span&gt;;
        WaitNode q &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; queued = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
                removeWaiter(q);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
            }

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; COMPLETING) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s == COMPLETING) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot time out yet&lt;/span&gt;
&lt;span&gt;                Thread.yield();
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitNode();
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;queued)
                queued &lt;/span&gt;= UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, waitersOffset,
                                                     q.next &lt;/span&gt;=&lt;span&gt; waiters, q);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
                nanos &lt;/span&gt;= deadline -&lt;span&gt; System.nanoTime();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= 0L&lt;span&gt;) {
                    removeWaiter(q);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
                }
                LockSupport.parkNanos(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanos);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;get方法的逻辑很简单，如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。awaitDone方法里面死循环的逻辑，推演几遍就能弄懂；它里面挂起线程的主要创新是定义了WaitNode类，来将多个等待线程组织成队列，这是与JDK6的实现最大的不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;挂起的线程何时被唤醒：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishCompletion() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert state &amp;gt; COMPLETING;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (WaitNode q; (q = waiters) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                    Thread t &lt;/span&gt;=&lt;span&gt; q.thread;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        LockSupport.unpark(t); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒线程&lt;/span&gt;
&lt;span&gt;                    }
                    WaitNode next &lt;/span&gt;=&lt;span&gt; q.next;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    q.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unlink to help gc&lt;/span&gt;
                    q =&lt;span&gt; next;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        done();

        callable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to reduce footprint&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上就是JDK8的大体实现逻辑，像cancel、set等方法，也请读者自己阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再来看看JDK6的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDK6的FutureTask的基本操作都是通过自己的内部类Sync来实现的，而Sync继承自AbstractQueuedSynchronizer这个出镜率极高的并发工具类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task is running &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING   = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task ran &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RAN       = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task was cancelled &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED = 4&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The underlying callable &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; callable;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The result to return from get() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V result;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The exception to throw from get() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Throwable exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;里面的状态只有基本的几个，而且计算结果和异常是分开保存的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 V innerGet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
            acquireSharedInterruptibly(&lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() ==&lt;span&gt; CANCELLED)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException(exception);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个get方法里面处理等待线程队列的方式是调用了acquireSharedInterruptibly方法，看过我之前几篇博客文章的读者应该非常熟悉了。其中的等待线程队列、线程挂起和唤醒等逻辑，这里不再赘述，如果不明白，请出门左转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后来看看，Future模式衍生出来的更高级的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再上一个场景：我们自己写一个简单的数据库连接池，能够复用数据库连接，并且能在高并发情况下正常工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现代码1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionPool {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Connection&amp;gt; pool = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Connection&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection(String key) {
        Connection conn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pool.containsKey(key)) {
            conn &lt;/span&gt;=&lt;span&gt; pool.get(key);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            conn &lt;/span&gt;=&lt;span&gt; createConnection();
            pool.putIfAbsent(key, conn);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection createConnection() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Connection();
    }
    
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Connection {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们用了ConcurrentHashMap，这样就不必把getConnection方法置为synchronized(当然也可以用Lock)，当多个线程同时调用getConnection方法时，性能大幅提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;貌似很完美了，但是有可能导致多余连接的创建，推演一遍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某一时刻，同时有3个线程进入getConnection方法，调用pool.containsKey(key)都返回false，然后3个线程各自都创建了连接。虽然ConcurrentHashMap的put方法只会加入其中一个，但还是生成了2个多余的连接。如果是真正的数据库连接，那会造成极大的资源浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们现在的难点是：如何在多线程访问getConnection方法时，只执行一次createConnection。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合之前Future模式的实现分析：当3个线程都要创建连接的时候，如果只有一个线程执行createConnection方法创建一个连接，其它2个线程只需要用这个连接就行了。再延伸，把createConnection方法放到一个Callable的call方法里面，然后生成FutureTask。我们只需要让一个线程执行FutureTask的run方法，其它的线程只执行get方法就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionPool {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentHashMap&amp;lt;String, FutureTask&amp;lt;Connection&amp;gt;&amp;gt; pool = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, FutureTask&amp;lt;Connection&amp;gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Connection getConnection(String key) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        FutureTask&lt;/span&gt;&amp;lt;Connection&amp;gt; connectionTask =&lt;span&gt; pool.get(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connectionTask != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionTask.get();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Callable&lt;/span&gt;&amp;lt;Connection&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Connection&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Connection call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createConnection();
                }
            };
            FutureTask&lt;/span&gt;&amp;lt;Connection&amp;gt; newTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Connection&amp;gt;&lt;span&gt;(callable);
            connectionTask &lt;/span&gt;=&lt;span&gt; pool.putIfAbsent(key, newTask);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connectionTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                connectionTask &lt;/span&gt;=&lt;span&gt; newTask;
                connectionTask.run();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionTask.get();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection createConnection() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Connection();
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Connection {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;推演一遍：当3个线程同时进入else语句块时，各自都创建了一个FutureTask，但是ConcurrentHashMap只会加入其中一个。第一个线程执行pool.putIfAbsent方法后返回null，然后connectionTask被赋值，接着就执行run方法去创建连接，最后get。后面的线程执行pool.putIfAbsent方法不会返回null，就只会执行get方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在并发的环境下，通过FutureTask作为中间转换，成功实现了让某个方法只被一个线程执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Future是一个接口，FutureTask是Future的一个实现类，并实现了Runnable，因此FutureTask可以传递到线程对象Thread中新建一个线程执行。所以可以通过Excutor(线程池)来执行，也可传递给Thread对象执行。&lt;br/&gt;如果在主线程中需要执行比较耗时的操作，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。&lt;br/&gt;FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果（如果有需要）。&lt;br/&gt;FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，它等价于可以携带结果的Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。&lt;br/&gt;Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时的计算。一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/cz123/p/7693064.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《java并发编程实战》龙果学院&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 19 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Futrue模式有什么用？ &gt;正所谓技术来源与生活，这里举个栗子。在家里，我们都有煮菜的经验。（如果没有的话，你们还怎样来泡女朋友呢？你懂得）。现在女票要你煮四菜一汤，这汤是鸡汤，有常识的人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9502771.html</dc:identifier>
</item>
<item>
<title>Pandas基本操作 - Dominic-Ji</title>
<link>http://www.cnblogs.com/Dominic-Ji/p/9502773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dominic-Ji/p/9502773.html</guid>
<description>&lt;p&gt;pandas是一个强大的Python数据分析的工具包。&lt;/p&gt;
&lt;p&gt;pandas是基于NumPy构建的。&lt;/p&gt;
&lt;h3&gt;pandas的主要功能&lt;/h3&gt;
&lt;p&gt;　　具备对其功能的数据结构DataFrame、Series&lt;/p&gt;
&lt;p&gt;　　集成时间序列功能&lt;/p&gt;
&lt;p&gt;　　提供丰富的数学运算和操作&lt;/p&gt;
&lt;p&gt;　　灵活处理缺失数据&lt;/p&gt;
&lt;p&gt;安装方法：pip install pandas&lt;/p&gt;
&lt;p&gt;引用方法：import pandas as pd(习惯给pandas起别名)&lt;/p&gt;
&lt;h2&gt;Series&lt;/h2&gt;
&lt;p&gt;Series是一种类似于一位数组的对象，由一组数据和一组与之相关的数据标签（索引）组成。&lt;/p&gt;
&lt;h3&gt;创建方式&lt;/h3&gt;
&lt;p&gt;pd.Series([4,7,-5,3])&lt;/p&gt;
&lt;p&gt;pd.Series([4,7,-5,3],index=['a','b','c','d'])&lt;/p&gt;
&lt;p&gt;pd.Series({'a':1, 'b':2})&lt;/p&gt;
&lt;p&gt;pd.Series(0, index=['a','b','c','d’])&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819201013686-1910285403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取值数组和索引数组：values属性和index属性&lt;/p&gt;
&lt;p&gt;Series比较像列表（数组）和字典的结合体。&lt;/p&gt;
&lt;h3&gt;Series特性&lt;/h3&gt;
&lt;p&gt;Series支持数组的特性：&lt;/p&gt;
&lt;p&gt;　　从ndarray创建Series：Series(arr)&lt;/p&gt;
&lt;p&gt;　　与标量运算：sr*2&lt;/p&gt;
&lt;p&gt;　　两个Series运算：sr1+sr2&lt;/p&gt;
&lt;p&gt;　　索引：sr[0], sr[[1,2,4]]&lt;/p&gt;
&lt;p&gt;　　切片：sr[0:2]（切片依然是视图形式）&lt;/p&gt;
&lt;p&gt;　　通用函数：np.abs(sr)&lt;/p&gt;
&lt;p&gt;　　布尔值过滤：sr[sr&amp;gt;0]&lt;/p&gt;
&lt;p&gt;　　统计函数：mean() sum() cumsum()&lt;/p&gt;
&lt;p&gt;Series支持字典的特性（标签）：&lt;/p&gt;
&lt;p&gt;　　从字典创建Series：Series(dic),&lt;/p&gt;
&lt;p&gt;　　in运算：’a’ in sr、for x in sr&lt;/p&gt;
&lt;p&gt;　　键索引：sr['a'], sr[['a', 'b', 'd']]&lt;/p&gt;
&lt;p&gt;　　键切片：sr['a':'c']&lt;/p&gt;
&lt;p&gt;　　其他函数：get('a', default=0)等&lt;/p&gt;
&lt;h3&gt;Series：整数索引&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import pandas &lt;span&gt;as&lt;/span&gt;&lt;span&gt; pd
import numpy &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; np

sr&lt;/span&gt;=pd.Series(np.arange(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.))
sr[&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]

KeyError&lt;/span&gt;!&lt;span&gt;
#pandas的数组对象在查找数据时，会以标签优先查找，也就是第一列表头信息，而不是我们认为的索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果索引是整数类型，则根据整数进行数据操作时总是面向标签的。&lt;/p&gt;
&lt;p&gt;　　loc属性 以标签解释&lt;/p&gt;
&lt;p&gt;　　iloc属性 以下标解释&lt;/p&gt;
&lt;p&gt;Series数据对齐&lt;/p&gt;
&lt;p&gt;pandas在运算时，会按索引进行对齐然后计算。如果存在不同的索引，则结果的索引是两个操作数索引的并集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819202659931-166374504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819202742792-1657749038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意:NaN属于数字类型，表示不是数字类型的数字类型，通常称为缺失值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何在两个Series对象相加时将缺失值设为0？&lt;/p&gt;
&lt;p&gt;sr1.add(sr2, fill_value=0)&lt;/p&gt;
&lt;p&gt;灵活的算术方法：add, sub, div, mul&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819203113213-304476982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Series缺失数据&lt;/h3&gt;
&lt;p&gt;缺失数据：使用NaN（Not a Number）来表示缺失数据。其值等于np.nan。内置的None值也会被当做NaN处理。&lt;/p&gt;
&lt;p&gt;处理缺失数据的相关方法：&lt;/p&gt;
&lt;p&gt;　　dropna() 过滤掉值为NaN的行&lt;/p&gt;
&lt;p&gt;　　fillna() 填充缺失数据&lt;/p&gt;
&lt;p&gt;　　isnull() 返回布尔数组，缺失值对应为True&lt;/p&gt;
&lt;p&gt;　　notnull() 返回布尔数组，缺失值对应为False&lt;/p&gt;
&lt;h2&gt;pandas：DataFrame&lt;/h2&gt;
&lt;p&gt;DataFrame是一个表格型的数据结构，含有一组有序的列。&lt;/p&gt;
&lt;p&gt;DataFrame可以被看做是由Series组成的字典，并且共用一个索引。&lt;/p&gt;
&lt;p&gt;创建方式：&lt;/p&gt;
&lt;p&gt;　　pd.DataFrame({'one':[1,2,3,4],'two':[4,3,2,1]})&lt;/p&gt;
&lt;p&gt;　　pd.DataFrame({'one':pd.Series([1,2,3],index=['a','b','c']),&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819204301860-1523678512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常该类数据类型不需要我们手动去创建出来，而是通过读取表格文件来自动获取。最常用的获取和存储数据&lt;/p&gt;
&lt;p&gt;csv文件读取与写入：&lt;/p&gt;
&lt;p&gt;　　df.read_csv('filename.csv')&lt;/p&gt;
&lt;p&gt;　　df.to_csv()&lt;/p&gt;
&lt;h3&gt;DataFrame查看数据&lt;/h3&gt;
&lt;p&gt;查看数据常用属性及方法：&lt;/p&gt;
&lt;p&gt;index 　　　　　　 获取索引&lt;/p&gt;
&lt;p&gt;T 　　　　　　　　 转置&lt;/p&gt;
&lt;p&gt;columns 　　　　　获取列索引&lt;/p&gt;
&lt;p&gt;values 　　　　　　获取值数组&lt;/p&gt;
&lt;p&gt;describe() 　　　　  获取快速统计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819204911478-559036330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DataFrame各列name属性：列名 rename(columns={})&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819205346226-236858551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;DataFrame索引和切片&lt;/h3&gt;
&lt;p&gt;DataFrame有行索引和列索引。&lt;/p&gt;
&lt;p&gt;DataFrame同样可以通过标签和位置两种方法进行索引和切片。&lt;/p&gt;
&lt;p&gt;DataFrame使用索引切片：&lt;/p&gt;
&lt;p&gt;　　方法1：两个中括号，先取列再取行。 df['A'][0]&lt;/p&gt;
&lt;p&gt;　　方法2（推荐）：使用loc/iloc属性，一个中括号，逗号隔开，先取行再取列。&lt;/p&gt;
&lt;p&gt;　　loc属性：解释为标签&lt;/p&gt;
&lt;p&gt;　　iloc属性：解释为下标&lt;/p&gt;
&lt;p&gt;向DataFrame对象中写入值时只使用方法2&lt;/p&gt;
&lt;p&gt;行/列索引部分可以是常规索引、切片、布尔值索引、花式索引任意搭配。（注意：两部分都是花式索引时结果可能与预料的不同）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819210424888-185035930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;DataFrame数据对齐与缺失数据&lt;/h3&gt;
&lt;p&gt;DataFrame对象在运算时，同样会进行数据对齐，行索引与列索引分别对齐。 结果的行索引与列索引分别为两个操作数的行索引与列索引的并集。&lt;/p&gt;
&lt;p&gt;DataFrame处理缺失数据的相关方法：&lt;/p&gt;
&lt;p&gt;　　dropna(axis=0,how='any',…)&lt;/p&gt;
&lt;p&gt;　　fillna()&lt;/p&gt;
&lt;p&gt;　　isnull()&lt;/p&gt;
&lt;p&gt;　　notnull()&lt;/p&gt;
&lt;h3&gt;其他常用方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819210704351-886057381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;pandas：时间对象处理&lt;/h3&gt;
&lt;p&gt;灵活处理时间对象：dateutil包 dateutil.parser.parse()&lt;/p&gt;
&lt;p&gt;成组处理时间对象：pandas pd.to_datetime(['2001-01-01', '2002-02-02'])&lt;/p&gt;
&lt;p&gt;产生时间对象数组：date_range start 开始时间 end 结束时间 periods 时间长度 freq 时间频率，默认为'D'，可选H(our),W(eek),B(usiness),S(emi-)M(onth),(min)T(es), S(econd), A(year),…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819211854769-33188863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;pandas：时间序列&lt;/h3&gt;
&lt;p&gt;时间序列就是以时间对象为索引的Series或DataFrame。&lt;/p&gt;
&lt;p&gt;datetime对象作为索引时是存储在DatetimeIndex对象中的。&lt;/p&gt;
&lt;p&gt;时间序列特殊功能：&lt;/p&gt;
&lt;p&gt;　　传入“年”或“年月”作为切片方式&lt;/p&gt;
&lt;p&gt;　　传入日期范围作为切片方式&lt;/p&gt;
&lt;p&gt;　　丰富的函数支持：resample(), strftime(), ……&lt;/p&gt;
&lt;p&gt;　　批量转换为datetime对象：to_pydatetime()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819213019356-2118778270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;pandas：写入到文件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819213048849-1570543773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819213124442-1622790305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819213140491-419066849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1342004/201808/1342004-20180819213155146-147455843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 13:32:00 +0000</pubDate>
<dc:creator>Dominic-Ji</dc:creator>
<og:description>pandas：数据分析 pandas是一个强大的Python数据分析的工具包。 pandas是基于NumPy构建的。 pandas的主要功能 具备对其功能的数据结构DataFrame、Series 集</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dominic-Ji/p/9502773.html</dc:identifier>
</item>
<item>
<title>通过游戏外挂.学习逆向技术指超级马里奥. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9502761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9502761.html</guid>
<description>&lt;h2&gt;一丶前言&lt;/h2&gt;
&lt;p&gt;1.什么是逆向.&lt;/p&gt;
&lt;p&gt;　　逆向就是在没有源代码的情况下.通过汇编.反汇编来逆向一个成品的Exe(也可以是别的.举例是EXE)这样叫做逆向.&lt;/p&gt;
&lt;p&gt;2.逆向的用途&lt;/p&gt;
&lt;p&gt;　  逆向技术可以用于 反病毒.反外挂. 破解. ...... 等等.当然反病毒反外挂的前提就是你要对外挂或者病毒写法了解. 才可以进行.所以逆向的高度取决于开发的水平.&lt;/p&gt;
&lt;p&gt;3.这篇博客的作用.&lt;/p&gt;
&lt;p&gt;　　这篇博客不是教授外挂的.而是以外挂为切入点.讲解逆向技术.并了解逆向技术可以做什么.&lt;/p&gt;
&lt;h2&gt;二丶超级马里奥&lt;/h2&gt;
&lt;p&gt;想必超级玛丽大家都玩过.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819211045518-90962077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以对它做点什么.&lt;/p&gt;
&lt;p&gt;1.血值.可以修改为无限血量&lt;/p&gt;
&lt;p&gt;2.子弹个数.可以修改无限子弹.&lt;/p&gt;
&lt;p&gt;3.生命个数.可以修改为无限生命&lt;/p&gt;
&lt;p&gt;4.子弹状态. 使马里奥可以发送普通子弹. 登山镐子弹. 以及忍者飞镖子弹. CTRL+Z键还可以开启大招.&lt;/p&gt;
&lt;h2&gt;三丶逆向工具准备&lt;/h2&gt;
&lt;p&gt;我们要做外挂的前提需要有逆向工具.&lt;/p&gt;
&lt;p&gt;Cheat_Engine 简称CE 一款可以搜索内存的工具. 也可以看反汇编.&lt;/p&gt;
&lt;p&gt;那么我们可以用CE做切入点.&lt;/p&gt;
&lt;p&gt;1.使用CE 附加超级马里奥进程.&lt;/p&gt;
&lt;p&gt;2.搜索子弹个数. 依次减少.然后继续搜索.这样可以搜索到子弹的个数的基址.&lt;/p&gt;
&lt;p&gt;3.基址就是保存信息的一个全局变量地址.就是不会变动的地址.这样超级马里奥重新启动也会是这个地址.&lt;/p&gt;
&lt;p&gt;1.搜索子弹个数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819211648369-1532082851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.子弹个数更改.点击再次扫描.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819211734550-1857683988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们再次扫描之后会发现还有两个地址.根据经验.绿色的是基地址.&lt;/p&gt;
&lt;p&gt;当然我们可以关掉游戏.重新启动.然后看看地址还是不是这个.如果是这个.(0x00428292) 那么这个地址就是个静态地址.我们可以认为这个地址是不变的了.&lt;/p&gt;
&lt;p&gt;3.下拉到下面.CTRL +B 键观察附近内存. 然后CTRL + 2 以字节的10进制显示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819212011494-2028312932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察附近内存. 可以看到92上面的82地址是个6. 而看我们当前的血值也是6 可以猜想这个变量存放的是血值.&lt;/p&gt;
&lt;p&gt;我们可以减血看一下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819212121849-1405510933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以修改一下血值.看看是否是.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819212152638-1334568093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改之后发现是.所以82就是血的基址.  然后通过我们马里奥不断的进行不同的操作.&lt;/p&gt;
&lt;p&gt;可以看出这块内存会更改.&lt;/p&gt;
&lt;p&gt;当然这个操作需要手动去做.步骤我就不做了.&lt;/p&gt;
&lt;p&gt;所以我们可以得出.&lt;/p&gt;
&lt;p&gt;0x00428282  =  血的基址&lt;/p&gt;
&lt;p&gt;0x00428292 =   子弹个数基址.&lt;/p&gt;
&lt;p&gt;0x004282A2 =   生命个数的基址.&lt;/p&gt;


&lt;h2&gt;四丶编程实现外挂编写.&lt;/h2&gt;
&lt;p&gt;C++  : 如果是C++ 我们需要熟悉几个API.  OpenProcess 打开进程句柄.        ReadProcessMemory(); 写内存.  WriteProcessMemory() 读内存.&lt;/p&gt;
&lt;p&gt;易语言: 易语言可以使用模块. 我用的是超级模块.&lt;/p&gt;
&lt;p&gt;要熟悉的易语言命令.&lt;/p&gt;
&lt;p&gt;1.取进程ID(进程名)  返回进程ID  (跟OpenProcess 一样.只不过是封装的一个)&lt;/p&gt;
&lt;p&gt;2.十六到十             在易语言当中.我们操作的地址需要转化成10进制.可以用这个命令.&lt;/p&gt;
&lt;p&gt;3.写内存整数型     跟WriteProcessMemory一样的. 只不过封装了一下. &lt;/p&gt;
&lt;p&gt;具体代码可以在博客中下载. 一个是 VS2015 版本MFC的.  一个是易语言编写的. 附加模块.&lt;/p&gt;
&lt;p&gt;成品图演示&lt;/p&gt;
&lt;p&gt;MFC&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819212850564-1990842919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;易语言:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201808/1197364-20180819212906943-1437712639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;资料下载: 链接：https://pan.baidu.com/s/1AaRAuw7uUcxhxCL_nCrYMQ 密码：i2xt  (超级马里奥 + CE 工具 + 易语言.e代码文件 + 成品 + MFC 代码 + 成品)&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 13:29:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>通过游戏外挂.学习逆向技术指超级马里奥. 一丶前言 1.什么是逆向. 逆向就是在没有源代码的情况下.通过汇编.反汇编来逆向一个成品的Exe(也可以是别的.举例是EXE)这样叫做逆向. 2.逆向的用途</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9502761.html</dc:identifier>
</item>
<item>
<title>家用电器用户行为分析与事件识别学习笔记 - Luove</title>
<link>http://www.cnblogs.com/amoor/p/9502728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amoor/p/9502728.html</guid>
<description>&lt;p&gt;&lt;span&gt;书中介绍太绕，甚至是不清楚的，在此记录一下学习体会！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该例主要讲的是用户洗浴用水事件的识别问题（热水器数据），归结为0-1分类问题——这是全局观&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;按分析问题大的步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据探索性分析——&amp;gt;数据规约——&amp;gt;一次用水事件划分及阈值寻优——&amp;gt;特征工程/属性构造——&amp;gt;筛选洗浴事件（？）——&amp;gt;NN-Model&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;（？）这一部分，没搞懂作者意图，问题一开始就说是要识别出独立用水事件中的洗浴事件，那到此步骤不就完了，~后面就是为了跑跑模型train-test，blabla~？？？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从该章标题看（？）及之前是家用电器用户行为分析，之后才是事件识别，这样才解释得通&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最值得吐槽的是：自己说的数值规约，然而自己实现起来就跟本不存在什么数值规约哦&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人觉得本章最值得学习的点有：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;问题的分析思路（先后该做些什么、如何做），见上面步骤&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;数据分析处理方法（见下方简要介绍）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;特征工程/属性构造（涉及特定问题特定分析，结合问题的关注点，如选取了时长类指标、频率类指标、水量指标、用水变化/波动指标）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;筛选洗浴事件方式方法：一次用水事件划分&lt;span&gt;——&amp;gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;候选&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;洗浴&lt;/span&gt;&lt;span&gt;&lt;span&gt;事件划分（一次用水量&amp;lt;y&lt;span&gt;Litre、&lt;span&gt;用水时长&lt;/span&gt;&amp;lt;100s、&lt;span&gt;总用水时长&lt;/span&gt;&amp;lt;120s&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;关于数据分析处理方法，文中介绍甚是模糊，个人理解记录于此：&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt; 时间的划分均是基于用水量数据来区分的&lt;/h3&gt;
&lt;h4&gt;一次用水事件划分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047928/201808/1047928-20180819185630558-2046798313.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047928/201808/1047928-20180819190005081-244441302.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 阈值寻优&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;阈值寻优区间&lt;/span&gt;&lt;span&gt;1min——9min，step=0.25min=15s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算原理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以阈值及对应划分的用水事件数，作图，当n个相邻点斜率值（取最小的斜率对应的阈值，斜率小说明曲线平稳用户习惯比较趋于平稳）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1047928/201808/1047928-20180819203001241-1598108178.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047928/201808/1047928-20180819203043138-101682218.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;特征工程/ 属性构造&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这类问题解构/组合需要经验和对应问题需要，多多学习&lt;span&gt;~~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;筛选候选洗浴事件&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;文中给出的是判定短暂用水事件，将其余的作为候选洗浴事件，可惜的是描述混乱+无代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 关于判定标准，个人感觉非常的主观呀（这里仅摘记文中标准，满足一个就算是短暂，或关系），希望大神留言讲一讲啊，&lt;/span&gt;thx~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一次用水事件总用水（总水量*热水量（%）=纯热水）&amp;lt;yLitre&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用水时长&amp;lt;100s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;总用水时长&amp;lt;120s&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其中文中y的取值也很有意思，考虑了热水器不同设定温度下热水的使用量阈值y：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047928/201808/1047928-20180819205916233-1784921925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由一系列假设，说明当一次洗浴中热水温度越高热水量使用就越少，反之反是；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V表示热水器的水恒50度时洗浴最低用量，X当前水温，C注入的自来水每月平均温度（室温均值）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多层神经网络&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense,Activation
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; net =&lt;span&gt; Sequential()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;net.add(Dense(input_dim = 11, output_dim = 17))#keras 2.0之前版本&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; net.add(Dense(input_dim=11, units=17))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;keras 2.0 ,推荐;添加输入层、隐藏层的连接&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; net.add(Dense(input_dim=17, units=10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;model.add(Dense(10, 1)) #添加隐藏层、输出层的连接&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; net.add(Dense(1))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出层，同上&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; net.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; net.compile(loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;net.fit(x_train, y_train,epochs=10,batch_size=1)#keras 2.0之前版本&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; net.fit(x_train, y_train,epochs=1000,batch_size=1,verbose=1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;keras 2.0,推荐,verbose=0，不显示过程，默认等于1显示过程&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; r = pd.DataFrame(model.predict_classes(x_test), columns = [u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;预测结果&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; pd.concat([data_test.iloc[:,:5], r], axis = 1&lt;span&gt;).to_excel(testoutputfile)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; net.predict(x_test)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;REF：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《数据分析与挖掘实战》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源代码及数据需要可自取：&lt;a href=&quot;https://github.com/Luove/Data&quot; target=&quot;_blank&quot;&gt;https://github.com/Luove/Data&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 13:20:00 +0000</pubDate>
<dc:creator>Luove</dc:creator>
<og:description>书中介绍太绕，甚至是不清楚的，在此记录一下学习体会！ 该例主要讲的是用户洗浴用水事件的识别问题（热水器数据），归结为0-1分类问题——这是全局观 按分析问题大的步骤： 数据探索性分析——&gt;数据规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amoor/p/9502728.html</dc:identifier>
</item>
</channel>
</rss>