<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解决警告: Setting property 'source' to 'org.eclipse.jst.jee.server_:' did not find a matching property.的方法 - Lesleyhi</title>
<link>http://www.cnblogs.com/Lesleyhi/p/8955826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lesleyhi/p/8955826.html</guid>
<description>&lt;p&gt;今天第一次搭建struts2框架，跟着网上的教程导入对应的jar包之后就开始写登录的jsp页面，但是运行时出现了问题，&lt;/p&gt;
&lt;p&gt;浏览器显示“The requested resource is not available.”的提示。&lt;/p&gt;

&lt;p&gt;于是我查看了Console那里，发现有这么一条警告&lt;/p&gt;
&lt;p&gt;“Setting property 'source' to 'org.eclipse.jst.jee.server struts2（我的项目名）:' did not find a matching property.”&lt;/p&gt;

&lt;p&gt;于是乎百度了一下，找到了解决方案&lt;/p&gt;
&lt;p&gt;1. server 右键——》选择properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372930/201804/1372930-20180426233911252-1604781715.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.单击Switch Location，这时，路径变为如下图显示的，保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372930/201804/1372930-20180426234100299-863065598.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3.双击server，打开Tomcat v7.0 Server at localhost.server 这个文件，选中publis module context to separate xml file 并保存（保存前先要停止服务器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372930/201804/1372930-20180426234439050-1635384140.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;602&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后重启服务器，运行登录页面成功！&lt;/p&gt;

</description>
<pubDate>Thu, 26 Apr 2018 15:47:00 +0000</pubDate>
<dc:creator>Lesleyhi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lesleyhi/p/8955826.html</dc:identifier>
</item>
<item>
<title>AsyncLocal 与 async await - 鱼东东</title>
<link>http://www.cnblogs.com/yudongdong/p/8955811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudongdong/p/8955811.html</guid>
<description>&lt;p&gt;大家来看一张图 先猜猜看为什么会这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201804/472365-20180426231147445-84671808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关于async await的原理 建议查看&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/brook_shi/article/details/50803957 &lt;/p&gt;
&lt;p&gt;这篇文章分析的很透彻&lt;/p&gt;

&lt;p&gt;和AsyncLocal有关的 最最关键的部分是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201804/472365-20180426232141279-1500374864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 对，就是上下文。在 执行异步的方法时。会每次构建异步上下文，&lt;span&gt;&lt;strong&gt;大家记住 AsyncLocal是跟着上下文的&lt;/strong&gt;&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201804/472365-20180426233957178-1682736954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果理解有误还望大佬指正教育&lt;/p&gt;
&lt;p&gt; 谢谢&lt;/p&gt;
</description>
<pubDate>Thu, 26 Apr 2018 15:42:00 +0000</pubDate>
<dc:creator>鱼东东</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudongdong/p/8955811.html</dc:identifier>
</item>
<item>
<title>利用生产者消费者模型和MQ模型写一个自己的日志系统-并发设计里一定会用到的手段 - Silentdoer</title>
<link>http://www.cnblogs.com/silentdoer/p/8955713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/silentdoer/p/8955713.html</guid>
<description>&lt;h2&gt;一：前言&lt;/h2&gt;
&lt;p&gt;　　写这个程序主要是用来理解生产者消费者模型，以及通过这个Demo来理解Redis的单线程取原子任务是怎么实现的和巩固一下并发相关的知识；这个虽然是个Demo，但是只要稍加改下Appender部分也是可以用于项目中的，假设项目里确实不需要log4j/logback之类的日志组件的时候；&lt;/p&gt;
&lt;h2&gt;二：实现方式&lt;/h2&gt;
&lt;p&gt;1.利用LinkedList作为MQ（还可以用jdk自带的LinkedBlockingQueue，不过这个Demo主要是为了更好的理解原理因此写的比较底层）；&lt;/p&gt;
&lt;p&gt;2.利用一个Daemon线程作为消费者从MQ里实时获取日志对象/日志记录，并将它提交给线程池，由线程池再遍历所有的appender并调用它们的通知方法，这个地方还可以根据场景进行效率优化，如将循环遍历appender改为将每个appender都再此提交到线程池实现异步通知观察者；&lt;/p&gt;
&lt;p&gt;3.为生产者提供log方法作为生产日志记录的接口，无论是生产日志对象还是消费日志对象在操作队列时都需要对队列加锁，因为个人用的是非并发包里的；&lt;/p&gt;
&lt;p&gt;4.消费者在获取之前会先判断MQ里是否有数据，有则获取并提交给线程池处理，否则wait；&lt;/p&gt;
&lt;p&gt;5.生产者生产了日志对象后通过notify通知消费者去取，因为只有一个消费者，而生产者是不会wait的因此只需要notify而不用notifyAll&lt;/p&gt;
&lt;p&gt;6.。。剩下的就看代码来说明吧；&lt;/p&gt;
&lt;h2&gt;三：代码&lt;/h2&gt;
&lt;h3&gt;1.MyLogger类的实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger.log;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Writer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicLong;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger.log.MyLogger.LogLevel.DEBUG;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger.log.MyLogger.LogLevel.ERROR;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; silentdoer
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description 这里只是做一个简单的logger实现，不提供Appender之类的功能，主要是用来学习生产者和消费者及MQ的实现原理
 * @date 4/26/18 6:07 PM
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyLogger{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LogLevel loggerLevel =&lt;span&gt; DEBUG;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String charset = &quot;UTF-8&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂且没用，但是当需要序列化时是可能用到的；
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 也可以直接用LinkedQueue，然后手动通过ReentrantLock来实现并发时的数据安全（synchronized也可）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private BlockingQueue&amp;lt;LogRecord&amp;gt; queue = new LinkedBlockingQueue&amp;lt;LogRecord&amp;gt;();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以理解为支持并发的LinkedList
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 想了一下既然是要学习原理干脆就实现的更底层一点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Queue&amp;lt;LogRecord&amp;gt; records = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;LogRecord&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 用于记录生产了多少条日志，可供外部获取&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; AtomicLong produceCount = &lt;span&gt;new&lt;/span&gt; AtomicLong(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 用于记录消费了多少条日志&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; AtomicLong consumeCount = &lt;span&gt;new&lt;/span&gt; AtomicLong(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 日志记录的Consumer&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Thread consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogDaemon();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyLogger(){
        consumer.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        consumer.start();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 对外提供的接口，即log方法就是生产者用于生产日志数据的接口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; msg
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; level
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(String msg, LogLevel level){
        Date curr &lt;/span&gt;=&lt;span&gt; generateCurrDate();
        log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogRecord(level, msg, curr));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 对外提供的接口，即log方法就是生产者用于生产日志数据的接口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; msg
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(String msg){
        Date curr &lt;/span&gt;=&lt;span&gt; generateCurrDate();
        log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LogRecord(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.loggerLevel, msg, curr));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给生产者（即调用log的方法都可以理解为生产者在生产日志对象）提供用于生产日志记录的接口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; record
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(LogRecord record){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReentrantLock可以替代synchronized，不过当前场景下synchronized已经足够&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.records){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 如果用的是LinkedBlockingQueue是不需要这个的&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.records.offer(record);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.produceCount.incrementAndGet();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.records.notify();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 只有一个线程会records.wait()，因此notify()足够&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 类似Redis的那个单线程，用于读取命令对象，而这里则是用于读取LogRecord并通过appender将数据写到相应位置&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LogDaemon &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; valid = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 充当appenders的角色&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;Writer&amp;gt; appenders = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 3&lt;span&gt;
                , &lt;/span&gt;180000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(1024&lt;span&gt;));

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.valid){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 根据最少知道原则，在这里不要去想整体里是否存在打断此线程的地方，你就认为此线程是可能被外界打断的即可，因此需要做一定处理&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (MyLogger.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.records) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (MyLogger.&lt;span&gt;this&lt;/span&gt;.records.size() &amp;lt;= 0&lt;span&gt;) {
                            MyLogger.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.records.wait();
                        }
                        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LogRecord firstRecord = MyLogger.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.records.poll();
                        MyLogger.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.consumeCount.incrementAndGet();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;threadPool.submit()&lt;/span&gt;
                        threadPool.execute(() -&amp;gt; MyLogger.&lt;span&gt;this&lt;/span&gt;.notifyAppender(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.appenders, firstRecord));
                    }
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valid = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    ex.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t){
                    t.printStackTrace();
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; notifyAppender(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Writer&amp;gt; appenders, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; LogRecord record) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(appenders == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            PrintWriter writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PrintWriter(record.level == ERROR ?&lt;span&gt; System.err : System.out);
            writer.append(record.toString());
            writer.flush();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 这种是同步的方式，如果是异步的方式可以将每个appender的执行都由一个Runnable对象包装，然后submit给线程池（或者中间加个中间件）&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Writer writer : appenders){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    writer.append(record.toString());
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex){
                    ex.printStackTrace();
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于产生当前时间的模块，防止因为并发而导致LogRecord的timestamp根实际情况不符
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Lock currDateLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接用synchronized亦可&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date generateCurrDate(){
        currDateLock.lock();
        Date result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        currDateLock.unlock();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生产者生产的数据对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogRecord{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LogLevel level;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String msg;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date timestamp;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleDateFormat DEFAULT_DATE_FORMAT = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SimpleDateFormat dateFormat =&lt;span&gt; DEFAULT_DATE_FORMAT;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public LogRecord(){
            this(INFO, &quot;&quot;);
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogRecord(LogLevel level, String msg){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(level, msg, &lt;span&gt;new&lt;/span&gt; Date());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还是最好由外界设置timestamp，否则高并发下会比较不准&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 最好用这个，不然高并发下timestamp容易出现顺序不准确的情况。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogRecord(LogLevel level, String msg, Date timestamp){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.level =&lt;span&gt; level;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; msg;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timestamp =&lt;span&gt; timestamp;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.format(&quot;[Level:%s, Datetime:%s] : %s\n&quot;&lt;span&gt;, level, dateFormat.format(timestamp), msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogLevel getLevel() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; level;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMsg() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDateFormat(SimpleDateFormat dateFormat) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dateFormat =&lt;span&gt; dateFormat;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTimestamp(Date timestamp) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timestamp =&lt;span&gt; timestamp;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; LogLevel{  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 内部enum默认就是static&lt;/span&gt;
&lt;span&gt;        INFO,
        DEBUG,
        ERROR
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogLevel getLoggerLevel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggerLevel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoggerLevel(LogLevel loggerLevel) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loggerLevel =&lt;span&gt; loggerLevel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCharset() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; charset;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCharset(String charset) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.charset =&lt;span&gt; charset;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicLong getProduceCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; produceCount;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicLong getConsumeCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; consumeCount;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.测试用例1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger.log.MyLogger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; silentdoer
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description the description
 * @date 4/26/18 10:13 PM
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Entrance {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyLogger logger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLogger();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;logger.setLoggerLevel(MyLogger.LogLevel.ERROR);&lt;/span&gt;
        Scanner scanner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String line;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!(line = scanner.nextLine()).equals(&quot;exit&quot;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(line.equals(&quot;&quot;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            logger.log(line);
            System.out.println(String.format(&lt;/span&gt;&quot;共生产了%s条日志。&quot;&lt;span&gt;, logger.getConsumeCount()));
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex){ }
            System.out.println(String.format(&lt;/span&gt;&quot;共消费了%s条日志。&quot;&lt;span&gt;, logger.getProduceCount()));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.测试用例2&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; me.silentdoer.mqlogger.log.MyLogger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; silentdoer
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 * @description the description
 * @date 4/26/18 10:32 PM
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Entrance2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyLogger logger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLogger();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        logger.setLoggerLevel(MyLogger.LogLevel.ERROR);
        ExecutorService threadPool &lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index = i + 1&lt;span&gt;;
            threadPool.execute(() &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                logger.log(String.format(&lt;/span&gt;&quot;生产的第%s条记录。&quot;&lt;span&gt;, index));
                System.out.println(String.format(&lt;/span&gt;&quot;共生产了%s条记录。&quot;&lt;span&gt;, index));
            });
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex){ }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
            System.out.println(String.format(&lt;/span&gt;&quot;共%s条记录被消费。&quot;&lt;span&gt;, logger.getConsumeCount()));
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex){ }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;threadPool.shutdown();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;threadPool.shutdownNow();&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四：补充&lt;/h2&gt;
&lt;p&gt;　　如果想实现像BlockingQueue一样能够控制MQ的元素个数范围，则可以通过ReentrantLock的Confition来实现，即通过lock创建两个Condition对象，一个用来描述是否MQ中元素达到上限的情况，一个用于描述MQ中元素降到下限的情况；&lt;/p&gt;
&lt;p&gt;无论是达到上限或降到下限都会通过相应的condition对象来阻塞对应的生产者或消费者的生产/消费过程从而实现MQ元素个数的可控性；&lt;/p&gt;
</description>
<pubDate>Thu, 26 Apr 2018 15:28:00 +0000</pubDate>
<dc:creator>Silentdoer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/silentdoer/p/8955713.html</dc:identifier>
</item>
<item>
<title>[SDOI2010] 古代猪文 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/8955639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/8955639.html</guid>
<description>&lt;h2&gt;&lt;span&gt;Description&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;猪王国的文明源远流长，博大精深。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iPig在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为N。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iPig打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的k分之一，其中k是N的一个正约数（可以是1和N）。不过具体是哪k分之一，以及k是多少，由于历史过于久远，已经无从考证了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iPig觉得只要符合文献，每一种能整除N的k都是有可能的。他打算考虑到所有可能的k。显然当k等于某个定值时，该朝的猪文文字个数为N / k。然而从N个文字中保留下N / k个的情况也是相当多的。iPig预计，如果所有可能的k的所有情况数加起来为P的话，那么他研究古代文字的代价将会是G的P次方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在他想知道猪王国研究古代文字的代价是多少。由于iPig觉得这个数字可能是天文数字，所以你只需要告诉他答案除以999911659的余数就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Input&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有且仅有一行：两个数N、G，用一个空格分开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Output&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有且仅有一行：一个数，表示答案除以999911659的余数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Range&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;10%的数据中，$1 &amp;lt;= N &amp;lt;= 50$；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;20%的数据中，$1 &amp;lt;= N &amp;lt;= 1000$；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;40%的数据中，$1 &amp;lt;= N &amp;lt;= 100000$；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;100%的数据中，$1 &amp;lt;= G &amp;lt;= 1000000000，1 &amp;lt;= N &amp;lt;= 1000000000$。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Solution&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;先一句话题意：求 $G^{\Sigma _{d \mid n} C_n^d} \; \% 999911659$ 的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若 G =999911659，则上式结果为 0。否则，因为999911659是质数，所以 G，n 互质。由欧拉定理推论得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$G^{\Sigma _{d \mid n} C_n^d} \equiv G^{\Sigma _{d \mid n} C_n^d \; \% \; 999911658} \quad (mod\;999911659)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试分解质因数，可以发现 $999911658 = 2 \times 3 \times 4679 \times 35617$。因为所以质因子的指数都为 1，所以我们枚举 $n$ 的约数 $d$，然后运用 $Lucas$ 求出组合数 $C_n^d$ ，分别计算出 $\Sigma _{d \mid n} C_n^d$ 对 2,3,4679,35617 四个质数取模的结果。然后中国剩余定理合并即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;快速幂非递归版本 1A，递归版本无限 wa。玄学错误=.=&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Code&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; mod 999911659
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; int long long
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,g;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; m[&lt;span&gt;6&lt;/span&gt;],r[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; factorcnt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; inv[&lt;span&gt;100005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fac[&lt;span&gt;100005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; factor[&lt;span&gt;10005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init_factor(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i*i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(n%i) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         factor[++factorcnt]=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i*i!=n) factor[++factorcnt]=n/&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lucas(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; p){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(x&amp;lt;y) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(x&amp;gt;=p) &lt;span&gt;return&lt;/span&gt; (lucas(x%p,y%p,p)*lucas(x/p,y/p,p))%&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (fac[x]*inv[fac[y]]*inv[fac[x-y]])%&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; calc(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     fac[&lt;span&gt;0&lt;/span&gt;]=fac[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     inv[&lt;span&gt;0&lt;/span&gt;]=inv[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=m[x];i++) fac[i]=(fac[i-&lt;span&gt;1&lt;/span&gt;]*i)%&lt;span&gt;m[x];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=m[x];i++) inv[i]=((m[x]-m[x]/i)*inv[m[x]%i])%&lt;span&gt;m[x];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=factorcnt;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         (r[x]+=lucas(n,factor[i],m[x]))%=&lt;span&gt;m[x];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; exgcd(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt; &amp;amp;x,&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;y){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;b){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         x=&lt;span&gt;1&lt;/span&gt;; y=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; c=exgcd(b,a%&lt;span&gt;b,x,y);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; t=&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     x=&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     y=t-a/b*&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; innv(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,y;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    exgcd(a,b,x,y);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (x%b+b)%&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; CRT(){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; M=&lt;span&gt;1&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;4&lt;/span&gt;;i++) M*=&lt;span&gt;m[i];
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         (ans+=(M/m[i])*innv(M/m[i],m[i])*r[i])%=&lt;span&gt;M;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (ans%M+M)%&lt;span&gt;M;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ksm(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;if(y==0) return 1;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    if(y==1) return x%mod;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    int c=ksm(x,y&amp;gt;&amp;gt;1);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    if(y&amp;amp;1) return (x*c*c)%mod;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    return (c*c)%mod;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; r=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;y;y&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(y&amp;amp;&lt;span&gt;1&lt;/span&gt;) (r*=x)%=&lt;span&gt;mod;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         (x*=x)%=&lt;span&gt;mod;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;signed main(){
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;g);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(g==&lt;span&gt;mod){
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         puts(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;     m[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;2&lt;/span&gt;; m[&lt;span&gt;2&lt;/span&gt;]=&lt;span&gt;3&lt;/span&gt;; m[&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;4679&lt;/span&gt;; m[&lt;span&gt;4&lt;/span&gt;]=&lt;span&gt;35617&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;    init_factor();
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;) calc(i);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ksm(g,CRT())%&lt;span&gt;mod);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Thu, 26 Apr 2018 15:18:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/8955639.html</dc:identifier>
</item>
<item>
<title>python读取文本文件数据 - gangandi</title>
<link>http://www.cnblogs.com/gangandimami/p/8955564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gangandimami/p/8955564.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文要点刚要：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（一）读文本文件格式的数据函数：read_csv,read_table&lt;/p&gt;
&lt;p&gt;    1.读不同分隔符的文本文件，用参数sep&lt;/p&gt;
&lt;p&gt;    2.读无字段名（表头）的文本文件 ，用参数names&lt;/p&gt;
&lt;p&gt;    3.为文本文件制定索引，用index_col&lt;/p&gt;
&lt;p&gt;    4.跳行读取文本文件，用skiprows&lt;/p&gt;
&lt;p&gt;    5.数据太大时需要逐块读取文本数据用chunksize进行分块。&lt;/p&gt;
&lt;p&gt;（二）将数据写成文本文件格式函数：to_csv&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;范例如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）读取文本文件格式的数据集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.read_csv和read_table的区别:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;#read_csv默认读取用逗号分隔符的文件，不需要用sep来指定分隔符&lt;/strong&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;import pandas as pd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.csv')
&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224121292-979964237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#read_csv如果读的是用非逗号分隔符的文件，必须要用sep指定分割符，不然读出来的是原文件的样子，数据没被分割开&lt;/strong&gt;
import pandas as pd
pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt')
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224144868-1760190149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#与上面的例子可以对比一下区别&lt;/strong&gt;
import pandas as pd
pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|')
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224410679-520935790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#read_table读取文件时必须要用sep来指定分隔符，否则读出来的数据是原始文件，没有分割开。&lt;/strong&gt;
import pandas as pd
pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.csv')
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224501340-507311282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#read_table读取数据必须指定分隔符&lt;/strong&gt;
import pandas as pd
pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|')
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224605645-1046616757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.读取文本文件时不用header和names指定表头时，默认第一行为表头&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#用header=None表示数据集没有表头，会默认用阿拉伯数字填充表头和索引&lt;/strong&gt;
pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|',header=None)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224759907-1866915755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#用names可以自定义表头&lt;/strong&gt;
pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|',&lt;br/&gt;names=['x1','x2','x3','x4','x5'])
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426224858254-1016291189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.默认用阿拉伯数字指定索引；用index_col指定某一列作为索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;names=['x1','x2','x3','x4','x0']
pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|',
                   names=names,index_col='x0')
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225022347-270755606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.以下示例是用skiprows将hello对应的行跳过后读取其他行数据，不管首行是否作为表头，都是将表头作为第0行开始数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;可以对比一下三个例子的区别进行理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225126273-1981446421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;names=['x1','x2','x3','x4','x0']
pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt',names=names,
            skiprows=[0,3,6])
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225208651-941727855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt',
            skiprows=[0,3,6])
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225257812-1841733706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt',header=None,
            skiprows=[0,3,6])
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225330405-1103613451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.分块读取，data1.txt中总共8行数据，按照每块3行来分，会读3次，第一次3行，第二次3行，第三次1行数据进行读取。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;注意这里在分块的时候跟跳行读取不同的是，表头没作为第一行进行分块读取，可通过一下两个例子对比进行理解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;chunker = pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt',chunksize=3)
for m in chunker:   
    print(len(m)) 
    print m
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225501813-266640696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;chunker = pd.read_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data1.txt',header=None,
                      chunksize=3)
for m in chunker:    
    print(len(m)) 
    print m
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225607037-1448990798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）将数据写入文本格式用to_csv&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;以data.txt为例,注意写出文件时，将索引也写入了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;data=pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|')
print data
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225716866-1303984639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#可以用index=False禁止索引的写入。&lt;/strong&gt;
data=pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|')
data.to_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\outdata.txt',sep='!',index=False)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225814894-925833732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;&lt;strong&gt;#可以用columns指定写入的列&lt;/strong&gt;
data=pd.read_table('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\data.txt',sep='|')
data.to_csv('C:\\Users\\xiaoxiaodexiao\\pythonlianxi\\test0424\\outdata2.txt',sep=',',index=False,
            columns=['a','c','d'])
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201804/1368336-20180426225838900-1320029810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




















</description>
<pubDate>Thu, 26 Apr 2018 15:07:00 +0000</pubDate>
<dc:creator>gangandi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gangandimami/p/8955564.html</dc:identifier>
</item>
<item>
<title>ArrayList源码和多线程安全问题分析 - 不忘初心1223</title>
<link>http://www.cnblogs.com/vitasyuan/p/8955557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vitasyuan/p/8955557.html</guid>
<description>&lt;h2 id=&quot;arraylist源码和多线程安全问题分析&quot;&gt;1.ArrayList源码和多线程安全问题分析&lt;/h2&gt;
&lt;p&gt;在分析ArrayList线程安全问题之前，我们线对此类的源码进行分析，找出可能出现线程安全问题的地方，然后代码进行验证和分析。&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;1.1 数据结构&lt;/h3&gt;
&lt;p&gt;ArrayList内部是使用数组保存元素的，数据定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;transient Object[] elementData; // non-private to simplify nested class access&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ArrayList中此数组即是共享资源，当多线程对此数据进行操作的时候如果不进行同步控制，即有可能会出现线程安全问题。&lt;/p&gt;
&lt;h3 id=&quot;add方法可能出现的问题分析&quot;&gt;1.2 add方法可能出现的问题分析&lt;/h3&gt;
&lt;p&gt;首先我们看一下add的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e;
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法中有两个操作，一个是数组容量检查，另外就是将元素放入数据中。我们先看第二个简单的开始分析，当多个线程执行顺序如下所示的时候，会出现最终数据元素个数小于期望值。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/929184/201804/929184-20180426230449319-1270411977.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照此顺序执行完之后，我们可以看到，elementData[n]的只被设置了两次，第二个线程设置的值将前一个覆盖，最后size=n+1。下面使用代码进行验证此问题。&lt;/p&gt;
&lt;h3 id=&quot;代码验证&quot;&gt;1.3 代码验证&lt;/h3&gt;
&lt;p&gt;首先先看下以下代码，开启1000个线程，同时调用ArrayList的add方法，每个线程向ArrayList中添加100个数字，如果程序正常执行的情况下应该是输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list size is :10000  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();

    private static ExecutorService executorService = Executors.newFixedThreadPool(1000);

    private static class IncreaseTask extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;ThreadId:&quot; + Thread.currentThread().getId() + &quot; start!&quot;);
            for(int i =0; i &amp;lt; 100; i++){
                list.add(i);
            }
            System.out.println(&quot;ThreadId:&quot; + Thread.currentThread().getId() + &quot; finished!&quot;);
        }
    }

    public static void main(String[] args){
        for(int i=0; i &amp;lt; 1000; i++){
            executorService.submit(new IncreaseTask());
        }
        executorService.shutdown();
        while (!executorService.isTerminated()){
            try {
                Thread.sleep(1000*10);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        System.out.println(&quot;All task finished!&quot;);
        System.out.println(&quot;list size is :&quot; + list.size());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行此main方法后，输出如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/929184/201804/929184-20180426230458658-416917695.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从以上执行结果来看，最后输出的结果会小于我们的期望值。即当多线程调用add方法的时候会出现元素覆盖的问题。&lt;/p&gt;
&lt;h3 id=&quot;数组容量检测的并发问题&quot;&gt;1.4 数组容量检测的并发问题&lt;/h3&gt;
&lt;p&gt;在add方法源码中，我们看到在每次添加元素之前都会有一次数组容量的检测，add中调用此方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ensureCapacityInternal(size + 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容量检测的相关源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void ensureCapacityInternal(int minCapacity) {
       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
       }

       ensureExplicitCapacity(minCapacity);
   }

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容量检测的流程图如下所示：&lt;br/&gt;&lt;img src=&quot;http://www.cnblogs.com/img/bVV4Bo&quot; alt=&quot;图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们以两个线程执行add操作来分析扩充容量可能会出现的并发问题：&lt;br/&gt;当我们新建一个ArrayList时候，此时内部数组容器的容量为默认容量10，当我们用两个线程同时添加第10个元素的时候，如果出现以下执行顺序，可能会抛出java.lang.ArrayIndexOutOfBoundsException异常。&lt;br/&gt;&lt;img src=&quot;http://www.cnblogs.com/img/bVV4Bp&quot; alt=&quot;图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二个线程往数组中添加数据的时候由于数组容量为10，而此操作往index为10的位置设置元素值，因此会抛出数组越界异常。&lt;/p&gt;
&lt;h3 id=&quot;代码验证数组容量检测的并发问题&quot;&gt;1.5 代码验证数组容量检测的并发问题&lt;/h3&gt;
&lt;p&gt;使用如下代码：&lt;br/&gt;private static List list = new ArrayList(3);&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static ExecutorService executorService = Executors.newFixedThreadPool(10000);

    private static class IncreaseTask extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;ThreadId:&quot; + Thread.currentThread().getId() + &quot; start!&quot;);
            for(int i =0; i &amp;lt; 1000000; i++){
                list.add(i);
            }
            System.out.println(&quot;ThreadId:&quot; + Thread.currentThread().getId() + &quot; finished!&quot;);
        }
    }

    public static void main(String[] args){

        new IncreaseTask().start();
        new IncreaseTask().start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行main方法后，我们可以看到控制台输出如下：&lt;br/&gt;&lt;img src=&quot;http://www.cnblogs.com/img/bVV4Bq&quot; alt=&quot;图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;arraylist中其他方法说明&quot;&gt;1.6 ArrayList中其他方法说明&lt;/h3&gt;
&lt;p&gt;ArrayList中其他包含对共享变量操作的方法同样会有并发安全问题，只需要按照以上的分析方法分析即可。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Apr 2018 15:05:00 +0000</pubDate>
<dc:creator>不忘初心1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vitasyuan/p/8955557.html</dc:identifier>
</item>
<item>
<title>机器学习中特征的处理及选择 - molearner</title>
<link>http://www.cnblogs.com/wkslearner/p/8933685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkslearner/p/8933685.html</guid>
<description>&lt;h2 id=&quot;基础概念&quot;&gt;基础概念&lt;/h2&gt;
&lt;p&gt;特征工程是通过对原始数据的处理和加工，将原始数据属性通过处理转换为数据特征的过程，属性是数据本身具有的维度，特征是数据中所呈现出来的某一种重要的特性，通常是通过属性的计算，组合或转换得到的。比如主成分分析就是将大量的数据属性转换为少数几个特征的过程。某种程度而言，好的数据以及特征往往是一个性能优秀模型的基础。&lt;/p&gt;
&lt;p&gt;既然叫特征工程，自然涵盖了很多内容，而其中涉及到的比较重要的部分是特征的处理及选择。&lt;/p&gt;
&lt;p&gt;特征处理包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据清洗&lt;/li&gt;
&lt;li&gt;数据规范化&lt;/li&gt;
&lt;li&gt;特征构造与衍生&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特征选择包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征过滤&lt;/li&gt;
&lt;li&gt;wrapper method&lt;/li&gt;
&lt;li&gt;embedded method&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据清洗&quot;&gt;数据清洗&lt;/h2&gt;
&lt;p&gt;数据清洗是指发现并纠正数据文件中可识别的错误以及通过处理得到建模过程需要数据的过程。&lt;/p&gt;
&lt;p&gt;数据清洗包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缺失值处理&lt;/li&gt;
&lt;li&gt;异常值检测与处理&lt;/li&gt;
&lt;li&gt;调配样本比例和权重&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;缺失值处理&quot;&gt;缺失值处理&lt;/h3&gt;
&lt;p&gt;缺失值是指粗糙数据中由于缺少信息而造成的数据的聚类、分组、删失或截断。它指的是现有数据集中某个或某些属性的值是不完全的。&lt;/p&gt;
&lt;p&gt;缺失值的处理目前主要有两种方法：删除缺失值和填充缺失值&lt;/p&gt;
&lt;p&gt;1.删除缺失值&lt;/p&gt;
&lt;p&gt;如果一个样本或变量中所包含的缺失值超过一定的比例，比如超过样本或变量的一半，此时这个样本或变量所含有的信息是有限的，如果我们强行对数据进行填充处理，可能会加入过大的人工信息，导致建模效果打折扣，这种情况下，我们一般选择从数据中剔除整个样本或变量，即删除缺失值。&lt;/p&gt;
&lt;p&gt;2.缺失值填充&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;随机填充法&quot;&gt;随机填充法&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从字面上理解就是找一个随机数，对缺失值进行填充，这种方法没有考虑任何的数据特性，填充后可能还是会出现异常值等情况，一般情况下不建议使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;均值填充法&quot;&gt;均值填充法&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;寻找与缺失值变量相关性最大的那个变量把数据分成几个组，然后分别计算每个组的均值，然后把均值填入缺失的位置作为它的值，如果找不到相关性较好的变量，也可以统计变量已有数据的均值，然后把它填入缺失位置。这种方法会在一定程度上改变数据的分布。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;最相似填充法&quot;&gt;最相似填充法&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在数据集中找到一个与它最相似的样本，然后用这个样本的值对缺失值进行填充。&lt;br/&gt;与均值填充法有点类似，寻找与缺失值变量（比如x）相关性最大的那个变量（比如y），然后按照变量y的值进行排序，然后得到相应的x的排序，最后用缺失值所在位置的前一个值来代替缺失值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;回归填充法&quot;&gt;回归填充法&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把缺失值变量作为一个目标变量y，把缺失值变量已有部分数据作为训练集，寻找与其高度相关的变量x建立回归方程，然后把缺失值变量y所在位置对应的x作为预测集，对缺失进行预测，用预测结果来代替缺失值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;k近邻填充法&quot;&gt;k近邻填充法&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;利用knn算法，选择缺失值的最近k个近邻点，然后根据缺失值所在的点离这几个点距离的远近进行加权平均来估计缺失值。&lt;/p&gt;

&lt;h3 id=&quot;异常值检测与处理&quot;&gt;异常值检测与处理&lt;/h3&gt;
&lt;p&gt;异常值（outlier）是指一组测定值中与平均值的偏差超过两倍标准差的测定值，与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。异常值的产生一般由系统误差、人为误差或数据本身的变异引起的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;单变量异常值检测格拉布斯法&quot;&gt;单变量异常值检测（格拉布斯法）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，将变量按照其值从小到大进行顺序排列x1,x2.....xn&lt;/p&gt;
&lt;p&gt;其次，计算平均值x拔和标准差S，&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180425210249503-753881893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时计算偏离值，即平均值与最大值之差和平均值与最小值之差，然后确定一个可疑值，一般是偏离平均值较大的那个。&lt;/p&gt;
&lt;p&gt;计算统计量gi（残差与标准差的比值），i为可疑值的序列号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180425210917125-1799200171.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再者，将gi与格拉布斯表给出的临界值GP(n)比较，如果计算的Gi值大于表中的临界值GP(n)，则能判断该测量数据是异常值，可以剔除。这里临界值GP(n)与两个参数有关：检出水平α和测量次数n 。&lt;/p&gt;
&lt;p&gt;检出水平α：如果要求严格，检出水平α可以定得小一些，例如定α＝0.01，那么置信概率P＝1－α＝0.99；如果要求不严格，α可以定得大一些，例如定α＝0.10，即P＝0.90；通常定α＝0.05，P＝0.95。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;多变量异常值检测基于距离计算&quot;&gt;多变量异常值检测（基于距离计算）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于距离的多变量异常值检测类似与k近邻算法的思路，一般的思路是计算各样本点到中心点的距离，如果距离太大，则判断为异常值，这里距离的度量一般使用马氏距离(Mahalanobis Distance)。因为马氏距离不受量纲的影响，而且在多元条件下，马氏距离还考虑了变量之间的相关性，这使得它优于欧氏距离。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;异常值处理&quot;&gt;异常值处理&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单变量的情况下异常值可以考虑类似缺失值的删除法、均值填充法或回归填充法，而多变量的情况下，可以尝试用均值向量填充或者删除。&lt;/p&gt;
&lt;p&gt;总的来说，缺失值和异常值的处理要根据实际的情况确定合适的方法，因为某些情况下异常值刚好能够反应一些现实问题。&lt;/p&gt;

&lt;h3 id=&quot;调配样本比例和权重&quot;&gt;调配样本比例和权重&lt;/h3&gt;
&lt;p&gt;当数据集中出现样本不均衡情况时，需要调配样本的比例以及权重，以便能够训练出性能更优的模型，具体方法参考上一篇文章：机器学习中的类别不均衡问题&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wkslearner/p/8870673.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/wkslearner/p/8870673.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;数据规范化&quot;&gt;数据规范化&lt;/h2&gt;
&lt;p&gt;在机器学习中，由于不同模型的需要，我们经常要多数据做不同的规范化处理，以便能够得到性能更优的模型。&lt;/p&gt;
&lt;p&gt;在数据处理中，经常会接触到的数据规范化操作有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据无量纲化&lt;/li&gt;
&lt;li&gt;连续变量离散化&lt;/li&gt;
&lt;li&gt;离散变量量化处理&lt;/li&gt;
&lt;li&gt;数据转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据无量纲化&quot;&gt;数据无量纲化&lt;/h3&gt;
&lt;p&gt;无量纲化使不同规格的数据转换到同一规格，在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。&lt;/p&gt;
&lt;p&gt;数据无量纲化常用方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准化方法&lt;/li&gt;
&lt;li&gt;极值化方法&lt;/li&gt;
&lt;li&gt;均值化方法&lt;/li&gt;
&lt;li&gt;标准差化方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;标准化方法&quot;&gt;1.标准化方法&lt;/h4&gt;
&lt;p&gt;标准化方法是将变量的每个值与其平均值之差除以该变量的标准差，无量纲化后变量的平均值为0，标准差为1。使用该方法无量纲化后不同变量间的均值和标准差都相同，即同时消除了变量间变异程度上的差异。&lt;br/&gt;标准化公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426212308807-654586893.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;极值化方法&quot;&gt;2.极值化方法&lt;/h4&gt;
&lt;p&gt;极值化方法通常是通过变量取值的最大值和最小值将原始数据转换为特定范围内的数据，从而消除量纲和数量级的影响。这种方法十分依赖两个极端值。&lt;/p&gt;
&lt;p&gt;通常情况下极值化方法有3种方式：&lt;/p&gt;
&lt;p&gt;第一种方法，是将变量的值除以该变量的全距，标准化后每个变量的取值范围在[-1,1]。&lt;br/&gt;公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426212725231-1583286352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种方法，是将变量值与最小值之差除以该变量的全距，标准化后取值范围在[0,1]。&lt;br/&gt;公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426212903653-6083496.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三种方法，是将变量值除以该变量的最大值，标准化后变量的最大取值为1。&lt;br/&gt;公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426213038272-1478858671.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;均值化方法&quot;&gt;3.均值化方法&lt;/h4&gt;
&lt;p&gt;均值化方法是将变量值直接除以该变量的平均值，跟标准化方法不同的是，均值化方法能够保留变量间取值差异程度的信息。&lt;br/&gt;均值化方法公式：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426213815181-1674608420.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;标准差化方法&quot;&gt;4.标准差化方法&lt;/h4&gt;
&lt;p&gt;标准差化方法是标准化方法的一种变形，标准差化方法是直接将变量值除以标准差，而不是减去均值后再除以标准差。标准差化方法无量纲化后变量的均值为原始变量均值与标准差的比值，而不是0。&lt;br/&gt;公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426214235873-1945341434.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;连续变量离散化&quot;&gt;连续变量离散化&lt;/h3&gt;
&lt;p&gt;在使用某些算法时，我们需要把连续变量转换为离散变量，在一些情况下离散变量能够简化模型计算同时能够提升模型的稳定性，比如逻辑回归经常使用离散后的变量进行训练，能够体现模型的训练速度以及提升模型的可解释性。&lt;/p&gt;
&lt;p&gt;连续变量离散化大致有两类方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卡方检验方法&lt;/li&gt;
&lt;li&gt;信息增益方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;卡方检验方法&quot;&gt;1.卡方检验方法&lt;/h4&gt;
&lt;p&gt;通常情况下，将变量按照值大小进行排列，将每个值作为一个组，然后对每一对相邻的组计算卡方值，对其中最小的一对组合进行合并，接下来不断重复以上操作，直到满足我们设定的某一个条件，比如最小分组数5,即将连续变量分为5组。&lt;/p&gt;
&lt;p&gt;卡方统计量是指数据的分布与所选择的预期或假设分布之间的差异的度量。它是由各项实际观测次数（fo ）与理论分布次数（fe ）之差的平方除以理论次数，然后再求和而得出的，其计算公式为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426221606808-1343634772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卡方值包含两个信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实际值与理论值偏差的绝对大小。&lt;/li&gt;
&lt;li&gt;差异程度与理论值的相对大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;信息增益方法&quot;&gt;2.信息增益方法&lt;/h4&gt;
&lt;p&gt;信息增益方法是使用信息计算确定分割点的自上而下的分裂技术。&lt;/p&gt;
&lt;p&gt;首先是把每个值看成分割点，将数据分成两个部分，在多种可能的分法中选择产生最小信息熵的分法。然后在分成的两个区间中，寻找最大熵区间，继续进行按前面的方法进行分割，直到满足条件为止，比如满足指定个数时结束过程。&lt;/p&gt;
&lt;p&gt;数据的信息属性是与任务相关的，对于分类任务, 标签值y包含的信息量为:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426225333507-1035353844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中, p(y)为y出现的概率. p(y)越小, y包含的信息量越大. 这是符合直觉的.&lt;/p&gt;
&lt;p&gt;熵定义为信息的期望值.&lt;br/&gt;一个可以分为m类的数据集S, 它的信息熵为随机得到的一个label包含的信息量的期望值:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426225439657-623510036.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据集的信息熵代表这个数据集的混乱程度. 熵越大, 越混乱.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/981211/201804/981211-20180426225557082-653588577.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若按照某种特定的方式, 例如按照某一属性的值对S进行划分, 得到n个子集。新的子集们都有自己的信息熵, 它们的熵的和与原S的熵的差值就是这个划分操作带来的信息熵增益.&lt;/p&gt;
&lt;p&gt;未完待续.....&lt;/p&gt;
</description>
<pubDate>Thu, 26 Apr 2018 14:59:00 +0000</pubDate>
<dc:creator>molearner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkslearner/p/8933685.html</dc:identifier>
</item>
<item>
<title>Linux——makefile编写 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/8955462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/8955462.html</guid>
<description>&lt;p&gt;&lt;span&gt;以前对makefile的编写，限于刚开始接触，我都比较局限一些死板的格式，有时候就会显得有些繁琐。在进一步了解一些系统编译和链接的知识后，对makefile编写流程有了一些新的认识，所以来此梳理梳理，方便更灵活地编写makefile。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;限于makefile认识不足，这里参考了一篇比较好博文:&lt;span&gt;&lt;a dir=&quot;ltr&quot; href=&quot;https://blog.csdn.net/haoel/article/details/2886/&quot; target=&quot;_parent&quot;&gt;&lt;span&gt;&lt;strong&gt;makefile&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;关于makefile&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;span&gt;&lt;span&gt;&lt;strong&gt;makefile&lt;/strong&gt;带来直接好处就是——“自动化编译”。&lt;span&gt;&lt;span&gt;一旦写好，只需要一个make命令，整个工程完全自动编译，所以十分方便。而Makefile文件就是告诉&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;make命令怎么样地去编译和链接程序。但是想要比较灵活的运用它，还是先要熟悉一些关于系统对程序编译和链接的知识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般来说，对C、C++程序、先把源文件编译成中间代码文件。&lt;span&gt;Linux下是 .o 文件&lt;span&gt;即 Object File&lt;/span&gt;,在&lt;/span&gt;Windows下也就是 .obj 文件，这个动作叫做&lt;strong&gt;编译&lt;/strong&gt;（compile）。然后再把大量的.O文件合成执行文件，这个动作叫作&lt;strong&gt;链接&lt;/strong&gt;（link）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;编译时&lt;/strong&gt;，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是让我们告诉编译器头文件的所在位置（头文件中放声明，而定义放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（.O文件或是OBJ文件）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;链接时&lt;/strong&gt;，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（&lt;strong&gt;.O&lt;/strong&gt;文件或.OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，&lt;strong&gt;只管函数的中间目标文件&lt;/strong&gt;。在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在&lt;strong&gt;Linux&lt;/strong&gt;下，是Archive File，也就是 &lt;strong&gt;.a&lt;/strong&gt; 文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;总的来说就是，首先&lt;span&gt;源文件-&amp;gt; &lt;strong&gt;.o&lt;/strong&gt;文件，再由&lt;strong&gt;.o文件-&amp;gt;&lt;/strong&gt;可执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成&lt;strong&gt;Object File&lt;/strong&gt;。而在链接程序时，链接器会在所有的.o文件中找寻函数的实现，如果找不到，那到就会报链接错误码（&lt;strong&gt;Linker Error&lt;/strong&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;直白点说，最后生成的可执行文件就是靠着这种“各各依赖关系”逐步得到的。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;来个例子感受一下，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;hello&lt;/span&gt;: hello.o    
&lt;span&gt;hello.o&lt;/span&gt;: hello.c
    gcc &lt;/span&gt;-c hello.c -o hello.o&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这里make,便会自动编译了。这当中生成可执行文件hello依赖于hello.o,hello.o 依赖于 hello.c; 最后找到了hello.c便可以gcc生成hello.o这样往后‘&lt;span&gt;&lt;span&gt;&lt;span&gt;带&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;’，目标文件的hello便链接上.o文件去执行了。这里值得注意的是写gcc命令时需要添上 &lt;strong&gt;&lt;span&gt;-c&lt;/span&gt;&lt;/strong&gt;选项，用来保证得到的.o文件可重链接，不然基本会make报错（某些情况如直接gcc hello.c -o hello例外）。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;还有注意一点&lt;/span&gt;&lt;/strong&gt;就是在Makefile中的命令（如gcc ..），必&lt;span&gt;须要以[Tab]键开始&lt;/span&gt;，不然你很可能就会make出错哦~。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面例子直接链接一个中间目标文件，显得比较简单，当遇到源文件需要多个链接多个中间目标文件时是怎么个样子呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;比如 分别创建一个加法的add.c 和 add.h ，一个减法 sub.c和 sub.h 最后main.c 来调用add 和 sub实现加减法。此时Makefile 会像这样&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;main: main.o add.o sub.o
main.o: main.c  
    gcc &lt;/span&gt;-c main.c -&lt;span&gt;o main.o
add.o: add.c
    gcc &lt;/span&gt;-c add.c -o add.o  &lt;/strong&gt;&lt;span&gt;#加-&lt;/span&gt;&lt;span&gt;&lt;span&gt;c 指定生成为可重链接.o文件&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
sub.o: sub.c
    gcc &lt;/span&gt;-c sub.c -&lt;span&gt;o sub.o

&lt;span&gt;.PHONY:&lt;/span&gt;clean
clean:
    -rm &lt;/span&gt;-rf *.o&lt;p&gt;使用看看&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180426214857868-718969502.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从上面注意几个地方&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;①&lt;/strong&gt;当最终目标文件依赖多个.o时，将依赖的多个.o  一起写到最前面。然后依次以  目标：依赖文件  gcc...   的格式，罗列所有依赖关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;②&lt;/strong&gt;由于在上面的过程中生成了多个中间.o文件(实际工程中肯定是比较多的），所以每次编译完成，需要进行一定的清理工作，这时候就用上一个 &quot;clean&quot; (后面细说一下）来清理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;③&lt;/strong&gt; .&lt;strong&gt;PHONY意思表示clean是一个“伪目标”。也即是无论clean是否最新，一定执行它。&lt;/strong&gt;rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但并不理睬。当然，clean的规则不要放在文件的开头，否则这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于clean:  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　 &lt;/strong&gt;它只不过是一个动作名字，有点像c语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令（不仅用于clean，其他lable同样适用），就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，&lt;strong&gt;我们可以在一个Makefile中定义不用的编译或是和编译无关的命令&lt;/strong&gt;，比如程序的打包，程序的备份，等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到这，大致可以了解了makefile，以及大致怎么实现makefile.好， 那么make又是怎么用makefile进行执行的呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;make怎么执行&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;　　&lt;span&gt;1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;　　2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“main”这个文件，并把这个文件作为最终的目标文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;　　3、如果main文件不存在，或是main所依赖的后面的 .o 文件的文件修改时间要比main这个文件新，那么，它就会执行后面所定义的命令来生成main这个文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;　　4、如果main所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;　　5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件main了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而&lt;strong&gt;对于所定义的命令的错误&lt;/strong&gt;，&lt;strong&gt;或是编译不成功&lt;/strong&gt;，&lt;span&gt;make根本不理。make只管文件的依赖性，即如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;&lt;span&gt;灵活编写makefile&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从前面的makefile编写来看，  当中我们每写一个依赖关系就需要写一个形如gcc X.c  -o  X.o生成命令，这里还好，若是较大的工程，这样难免就太繁琐了，所以据了解，一般在公司专门编写makefile的人是不会那样写的。还有写着更简洁方式，就是利用下面这几个符号：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　$^    代表所有的依赖文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　$@  代表所有的目标文件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　$&amp;lt;   代表第一个依赖文件 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;于是便可以将&lt;/span&gt;&lt;span&gt;上面的makefile改写成&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;strong&gt;&lt;span&gt;PHONY:&lt;/span&gt;clean

main: main.o add.o sub.o
main.o: main.c  
    gcc &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-c $&amp;lt; -&lt;span&gt;o $@
add.o: add.c
    gcc &lt;/span&gt;-c $^ -&lt;span&gt;o $@  
sub.o: sub.c
    gcc &lt;/span&gt;-c $^ -&lt;span&gt;o $@

clean:
    rm &lt;/span&gt;-rf *.o&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;由于依赖的 都是中间目标文件.o ,如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用常量（这里看了好多人都把它说成变量，个人认为 它在后面并没有被改变，因次叫常量更好）那么还可以定义一个常量来表示所有的.o文件，于是便还可将它们写成这样&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;.PHONY:&lt;/span&gt;clean

&lt;span&gt;OBJS &lt;/span&gt;&lt;/span&gt;=&lt;span&gt; main.o\   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;//\转义字符&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
       add.o\
       sub.o

main: $(&lt;span&gt;OBJS&lt;/span&gt;) 
&lt;/span&gt;%.o : %&lt;span&gt;.c
    gcc &lt;/span&gt;-c $^ -&lt;span&gt;o $@

clean:
    &lt;/span&gt;-rm -rf $(&lt;span&gt;OBJS&lt;/span&gt;)&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里的%.o : %.c 想必都可以猜出来，这代表的意思就是所有的.o文件依赖相应的.C文件，这样便又省去好几步。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;到这，相信聪明的你，可以更灵活编写makefile了。最后，再补充补充关于Makefile的东西&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Makefile还有什么&lt;/span&gt;&lt;/h3&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;显式规则。显式规则说明了，如何生成一个或多个目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜杠进行转义，如：“\#”。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 在工程应用时，我们的规则一般这样：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　②如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　③如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;所以只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Apr 2018 14:50:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/8955462.html</dc:identifier>
</item>
<item>
<title>gdb调试的基本使用 - H&amp;K</title>
<link>http://www.cnblogs.com/HKUI/p/8955443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HKUI/p/8955443.html</guid>
<description>&lt;p&gt;GDB调试&lt;br/&gt;启动程序准备调试&lt;br/&gt;&lt;strong&gt;GDB yourpram&lt;/strong&gt;&lt;br/&gt;或者&lt;br/&gt;先输入GDB&lt;br/&gt;然后输入 &lt;strong&gt;file yourpram&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后使用run或者r命令开始程序的执行,也可以使用 run parameter将参数传递给该程序&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命令缩写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;命令说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;list&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;显示多行源代码&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;break&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;b&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;设置断点&lt;span&gt;,&lt;/span&gt;&lt;span&gt;程序运行到断点的位置会停下来&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;info&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;i&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;描述程序的状态&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;run&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;r&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;开始运行程序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;display&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;disp&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;跟踪查看某个变量&lt;span&gt;,&lt;/span&gt;&lt;span&gt;每次停下来都显示它的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;step&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;s&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;执行下一条语句&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如果该语句为函数调用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则进入函数执行其中的第一条语句&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;next&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;n&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;执行下一条语句&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如果该语句为函数调用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不会进入函数内部执行&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;即不会一步步地调试函数内部语句&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;print&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;p&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;打印内部变量值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;continue&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;c&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;继续程序的运行&lt;span&gt;,&lt;/span&gt;&lt;span&gt;直到遇到下一个断点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;set var name=v&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;设置变量的值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;start&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;st&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;开始执行程序&lt;span&gt;,&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;函数的第一条语句前面停下来&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;file&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;装入需要调试的程序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;kill&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;k&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;终止正在调试的程序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;watch&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;监视变量值的变化&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;backtrace&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;bt&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;产看函数调用信息&lt;span&gt;(&lt;/span&gt;&lt;span&gt;堆栈&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;frame&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;f&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;查看栈帧&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;79&quot;&gt;
&lt;p&gt;&lt;span&gt;quit&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;80&quot;&gt;
&lt;p&gt;&lt;span&gt;q&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;435&quot;&gt;
&lt;p&gt;&lt;span&gt;退出&lt;span&gt;GDB&lt;/span&gt;&lt;span&gt;环境&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e.c&lt;/span&gt;
 #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
}
main(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
    j&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
        j&lt;/span&gt;+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now a=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gcc -g -o e e.c&lt;br/&gt;调试gdb e&lt;br/&gt;或者输入gdb&lt;br/&gt;然后 file e&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;list 命令用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;list命令显示多行源代码,从上次的位置开始显示,默认情况下,一次显示10行,第一次使用时,从代码其实位置显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;list n显示已第n行未中心的10行代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
(gdb) list &lt;span&gt;8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now a=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;        }
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;list functionname显示以functionname的函数为中心的10行代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list main
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;list - 显示刚才打印过的源代码之前的代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(gdb) list &lt;span&gt;10&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now a=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    }(gdb) list -
&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;断点命令break&lt;br/&gt;break location:在location位置设置断点,改位置可以为某一行,某函数名或者其它结构的地址&lt;br/&gt;GDB会在执行该位置的代码之前停下来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_4fef167c-d66b-41c2-9cba-2f66744488a8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4fef167c-d66b-41c2-9cba-2f66744488a8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4fef167c-d66b-41c2-9cba-2f66744488a8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now a=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    }(gdb) &lt;span&gt;break&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x40050a&lt;/span&gt;: file e.c, line &lt;span&gt;10&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe548&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) c
Continuing.
now a&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe548&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) c
Continuing.
now a&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe548&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用delete breakpoints 断点号 删除断点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里的断点号表示的是第几个断点,刚才执行break 10返回 reakpoint 1 at 0x40050a: file e.c, line 10.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;中的1表示该断点的标号，因此使用 delete breakpoints 1表示删除第10行所定义的断点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;clear n表示清除第n行的断点,因此clear 10等同于delete breakpoints 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;disable/enable n表示使得编号为n的断点暂时失效或有效&lt;/span&gt;&lt;br/&gt;可使用info查看断点相关的信息&lt;br/&gt;&lt;span&gt;&lt;strong&gt;info breakpoints&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gdb) info breakpoints
No breakpoints or watchpoints.
(gdb) &lt;/span&gt;&lt;span&gt;break&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; at &lt;span&gt;0x40050a&lt;/span&gt;: file e.c, line &lt;span&gt;10&lt;/span&gt;&lt;span&gt;.
(gdb) &lt;/span&gt;&lt;span&gt;break&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; at &lt;span&gt;0x400501&lt;/span&gt;: file e.c, line &lt;span&gt;9&lt;/span&gt;&lt;span&gt;.
(gdb) info breakpoints
Num     Type           Disp Enb Address            What
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;       breakpoint     keep y   &lt;span&gt;0x000000000040050a&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;       breakpoint     keep y   &lt;span&gt;0x0000000000400501&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main at e.c:&lt;span&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;display命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看参数的值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_bb907703-c6fd-465b-8e30-c2478d9dbe46&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb907703-c6fd-465b-8e30-c2478d9dbe46&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb907703-c6fd-465b-8e30-c2478d9dbe46&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
(gdb) &lt;span&gt;break&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x40050a&lt;/span&gt;: file e.c, line &lt;span&gt;10&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe548&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) display j
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(gdb) c
Continuing.
now a&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe548&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: j = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
(gdb) display
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: j = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
(gdb) display i
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(gdb) display j
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;: j = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
(gdb) display j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;: j*&lt;span&gt;2&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
(gdb) info display
Auto&lt;/span&gt;-display expressions now &lt;span&gt;in&lt;/span&gt;&lt;span&gt; effect:
Num Enb Expression
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;:   y  j*&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:   y  j
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:   y  i
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:   y  j
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;也可以使用disable,enable,delete,info命令修改及查看其状态,用法与对断点的一样&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;step及next命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;step可使得程序逐条执行,即执行完一条语句然后在吓一跳语句前停下来,等待用户的命令&lt;br/&gt;一般使用step命令是，可使用display或者watch命令查看变量的变化,从而判断程序行为是否符合要求&lt;br/&gt;当下一条指令为函数时,s进入函数内部,在其第一条语句前停下来&lt;br/&gt;step n,next n 表示连续但不执行n条指令,如果期间遇到断点,则停下来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_95eebaca-e6ab-4156-bf2e-c7dd69c461fe&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_95eebaca-e6ab-4156-bf2e-c7dd69c461fe&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_95eebaca-e6ab-4156-bf2e-c7dd69c461fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    
&lt;span&gt;7&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;    }(gdb) 
Line number &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; of range; e.c has &lt;span&gt;15&lt;/span&gt;&lt;span&gt; lines.
(gdb) &lt;/span&gt;&lt;span&gt;break&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x40050a&lt;/span&gt;: file e.c, line &lt;span&gt;11&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e1 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;11&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) s
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) s
__printf (format&lt;/span&gt;=&lt;span&gt;0x400648&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at printf.c:&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;&lt;span&gt;    {
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  __printf (format=&lt;span&gt;0x400648&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at printf.c:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x0000000000400525&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
(gdb) n
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;      va_start (arg, format);
(gdb) n
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      done =&lt;span&gt; vfprintf (stdout, format, arg);
(gdb) n
now j&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;&lt;span&gt;    }
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  __printf (format=&amp;lt;value optimized &lt;span&gt;out&lt;/span&gt;&amp;gt;) at printf.c:&lt;span&gt;39&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x0000000000400525&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
(gdb) n
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
(gdb) n
debug info :x&lt;/span&gt;=======&lt;span&gt;x
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) s

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;11&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
(gdb) s
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) n
now j&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
(gdb) n
debug info :x&lt;/span&gt;=======&lt;span&gt;x
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;watch&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;watch可设置观察点(watchpoint)。使用观察点可以使得当某表达式的值发生变化时,程序暂停执行。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;执行该命令前，必须保证程序已经运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_0f7f4a34-0c14-4253-80e7-e25231da5b1e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f7f4a34-0c14-4253-80e7-e25231da5b1e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f7f4a34-0c14-4253-80e7-e25231da5b1e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list 
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    
&lt;span&gt;7&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;    }(gdb) 
Line number &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; of range; e.c has &lt;span&gt;15&lt;/span&gt;&lt;span&gt; lines.
(gdb) b main
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x4004fa&lt;/span&gt;: file e.c, line &lt;span&gt;9&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e1 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;9&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
(gdb) watch j
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: j
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, j);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;print命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_93fc5433-5226-4909-ac49-f48fee04f86c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93fc5433-5226-4909-ac49-f48fee04f86c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93fc5433-5226-4909-ac49-f48fee04f86c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    
&lt;span&gt;7&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;    }(gdb) 
Line number &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; of range; e.c has &lt;span&gt;15&lt;/span&gt;&lt;span&gt; lines.
(gdb) &lt;/span&gt;&lt;span&gt;break&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x40050e&lt;/span&gt;: file e.c, line &lt;span&gt;12&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e1 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) p j
$&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) p i,j
$&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
(gdb) p j
$&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
(gdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;set var name=value&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;在程序运行中动态改变变量的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_4525f81c-6537-4d4a-aac2-4a2e6dd48576&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4525f81c-6537-4d4a-aac2-4a2e6dd48576&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4525f81c-6537-4d4a-aac2-4a2e6dd48576&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    
&lt;span&gt;7&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;    }(gdb) 
Line number &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; of range; e.c has &lt;span&gt;15&lt;/span&gt;&lt;span&gt; lines.
(gdb) &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; main
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x4004fa&lt;/span&gt;: file e.c, line &lt;span&gt;9&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e1 

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;9&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
(gdb) watch i
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i
(gdb) watch j
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;25&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;25&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) c
Continuing.
Hardware watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: j

Old value &lt;/span&gt;= &lt;span&gt;25&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;
main (argc&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
(gdb) c
Continuing.
now j&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
debug info :x&lt;/span&gt;=======&lt;span&gt;x
Hardware watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: i

Old value &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;&lt;span&gt;
New value &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;
&lt;span&gt;0x0000000000400533&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) c
Continuing.

Watchpoint &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; deleted because the program has left the block &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
which its expression &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; valid.

Watchpoint &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; deleted because the program has left the block &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
which its expression &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; valid.
__libc_start_main (main&lt;/span&gt;=&lt;span&gt;0x4004eb&lt;/span&gt; &amp;lt;main&amp;gt;, argc=&lt;span&gt;1&lt;/span&gt;, ubp_av=&lt;span&gt;0x7fffffffe538&lt;/span&gt;, init=&amp;lt;value optimized &lt;span&gt;out&lt;/span&gt;&amp;gt;, fini=&amp;lt;value optimized &lt;span&gt;out&lt;/span&gt;&amp;gt;, rtld_fini=&amp;lt;value optimized &lt;span&gt;out&lt;/span&gt;&amp;gt;&lt;span&gt;, 
    stack_end&lt;/span&gt;=&lt;span&gt;0x7fffffffe528&lt;/span&gt;) at libc-start.c:&lt;span&gt;258&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt;&lt;span&gt;      exit (result);
(gdb) c
Continuing.

Program exited with code &lt;/span&gt;&lt;span&gt;026&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;函数调用相关的&lt;br/&gt;&lt;strong&gt;&lt;span&gt;backtrace&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;可使用frame 查看堆栈中某一帧的信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_20dd077b-7507-4bc9-aea7-4eab9901de2a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20dd077b-7507-4bc9-aea7-4eab9901de2a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20dd077b-7507-4bc9-aea7-4eab9901de2a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(gdb) list
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;void&lt;/span&gt; debug(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    
&lt;span&gt;7&lt;/span&gt;    main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
(gdb) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            j+=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;    }(gdb) 
Line number &lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; of range; e.c has &lt;span&gt;15&lt;/span&gt;&lt;span&gt; lines.
(gdb) b &lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;
Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; at &lt;span&gt;0x400525&lt;/span&gt;: file e.c, line &lt;span&gt;13&lt;/span&gt;&lt;span&gt;.
(gdb) r
Starting program: &lt;/span&gt;/mnt/hgfs/www/c/gcc/&lt;span&gt;e1 
now j&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
(gdb) s
debug (str&lt;/span&gt;=&lt;span&gt;0x400652&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at e.c:&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str );
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  debug (str=&lt;span&gt;0x400652&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at e.c:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x000000000040052f&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;&lt;span&gt;
(gdb) s
__printf (format&lt;/span&gt;=&lt;span&gt;0x400638&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at printf.c:&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;&lt;span&gt;    {
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  __printf (format=&lt;span&gt;0x400638&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at printf.c:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x00000000004004e9&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; debug (str=&lt;span&gt;0x400652&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at e.c:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x000000000040052f&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;&lt;span&gt;
(gdb) s
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;      va_start (arg, format);
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  __printf (format=&lt;span&gt;0x400638&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at printf.c:&lt;span&gt;34&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x00000000004004e9&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; debug (str=&lt;span&gt;0x400652&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at e.c:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x000000000040052f&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;&lt;span&gt;
(gdb) s
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      done =&lt;span&gt; vfprintf (stdout, format, arg);
(gdb) s
_IO_vfprintf_internal (s&lt;/span&gt;=&lt;span&gt;0x333a58f040&lt;/span&gt;, format=&lt;span&gt;0x400638&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ap=&lt;span&gt;0x7fffffffe330&lt;/span&gt;) at vfprintf.c:&lt;span&gt;236&lt;/span&gt;
&lt;span&gt;236&lt;/span&gt;      &lt;span&gt;int&lt;/span&gt; save_errno =&lt;span&gt; errno;
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  _IO_vfprintf_internal (s=&lt;span&gt;0x333a58f040&lt;/span&gt;, format=&lt;span&gt;0x400638&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug info :%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ap=&lt;span&gt;0x7fffffffe330&lt;/span&gt;) at vfprintf.c:&lt;span&gt;236&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0x000000333a24effa&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; __printf (format=&amp;lt;value optimized &lt;span&gt;out&lt;/span&gt;&amp;gt;) at printf.c:&lt;span&gt;35&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;0x00000000004004e9&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; debug (str=&lt;span&gt;0x400652&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) at e.c:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;0x000000000040052f&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;&lt;span&gt;
(gdb) c
Continuing.
debug info :x&lt;/span&gt;=======&lt;span&gt;x
now j&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;

Breakpoint &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;            debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=======x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
(gdb) bt
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  main (argc=&lt;span&gt;1&lt;/span&gt;, argv=&lt;span&gt;0x7fffffffe538&lt;/span&gt;) at e.c:&lt;span&gt;13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 26 Apr 2018 14:43:00 +0000</pubDate>
<dc:creator>H&amp;amp;K</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HKUI/p/8955443.html</dc:identifier>
</item>
<item>
<title>《剑指offer》全部题目-含Java实现 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8955372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8955372.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;陆续刷了好久，算是刷完了《剑指offer》，以下全部AC代码，不一定性能最优，如有错误或更好解答，请留言区指出，大家共同交流，谢谢~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二维数组中的查找&quot;&gt;1.二维数组中的查找&lt;/h3&gt;
&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean Find(int target, int [][] array) {
        if(array == null||array.length==0) return false;
        int rowIdx = 0,colIdx = array[0].length-1;
        while(rowIdx&amp;lt;array.length&amp;amp;&amp;amp;colIdx&amp;gt;=0){
            if(array[rowIdx][colIdx] == target)
                return true;
            else if(target&amp;gt;array[rowIdx][colIdx])
                rowIdx++;
            else if(target&amp;lt;array[rowIdx][colIdx])
                colIdx--;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;替换空格&quot;&gt;2.替换空格&lt;/h3&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public String replaceSpace(StringBuffer str) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i&amp;lt;str.length();i++){
            if(str.charAt(i)==' '){
                sb.append(&quot;%20&quot;);
            }
            else
                sb.append(str.charAt(i));
        }
        return sb.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从尾到头打印链表&quot;&gt;3.从尾到头打印链表&lt;/h3&gt;
&lt;p&gt;输入一个链表，从尾到头打印链表每个节点的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        if(listNode == null) return result;
        while(listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.isEmpty())
            result.add(stack.pop());
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重建二叉树&quot;&gt;==4.重建二叉树==&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre == null || in == null || pre.length != in.length) return null;
        return reConstructBinaryTreeCore(pre, 0, pre.length - 1, in, 0, in.length - 1);
    }

    public TreeNode reConstructBinaryTreeCore(int[] pre, int preStartIdx, int preEndIdx, int[] in, int inStartIdx, int inEndIdx) {
        TreeNode node = new TreeNode(pre[preStartIdx]);
        if (preStartIdx == preEndIdx)
            if (inStartIdx != inEndIdx || pre[preStartIdx] != in[inStartIdx])
                System.out.println(&quot;Invalid input.&quot;);
        int i = 0;
        while (pre[preStartIdx] != in[inStartIdx + i])
            i++;
        if (i == 0)//证明没有左子树
            node.left = null;
        else
            node.left = reConstructBinaryTreeCore(pre, preStartIdx + 1, preStartIdx + i, in, inStartIdx, inStartIdx + i - 1);
        if (inStartIdx + i == inEndIdx)//证明没有右子树
            node.right = null;
        else
            node.right = reConstructBinaryTreeCore(pre, preStartIdx + i + 1, preEndIdx, in, inStartIdx + i + 1, inEndIdx);
        return node;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用两个栈实现队列&quot;&gt;5.用两个栈实现队列&lt;/h3&gt;
&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Stack;

public class Solution {
 Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;Integer&amp;gt;();
    Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;Integer&amp;gt;();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() throws Exception {
        if(stack1.isEmpty()&amp;amp;&amp;amp;stack2.isEmpty())
            throw new Exception(&quot;Queue is empty.&quot;);
        if(!stack2.isEmpty())
            return stack2.pop();
        while(!stack1.isEmpty())
            stack2.push(stack1.pop());
        return stack2.pop();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;旋转数组的最小数字&quot;&gt;==6.旋转数组的最小数字==&lt;/h3&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array == null||array.length == 0)return 0;
        int idx1 = 0,idx2 = array.length-1;
        //如果不能进入while循环，则证明第一个元素小于最后一个元素，而且数组为非递减排序，最小值即为首位。
        while(array[idx1]&amp;gt;=array[idx2]){
            //第一个指针指向前半段递增序列的末尾，第二个指针指向后半段递增序列的首位。
            if(idx2-idx1==1)return array[idx2];
            //二分法查找临界点
            int mid = (idx1+idx2)/2;
            //考虑特例：｛1,0,1,1,1｝
            if(array[idx1] == array[idx2]&amp;amp;&amp;amp; array[mid] == array[idx1]){
                for(int i = idx1;i&amp;lt;=idx2;i++)
                    if(array[i]&amp;lt;array[mid])
                        return array[i];
            //特例：｛1,1,1,1,1,1,1｝
            return array[mid];
            }
            //更新指针，直至idx2-idx1==1;
            if(array[mid]&amp;gt;=array[idx1])
                idx1 = mid;
            else if(array[mid]&amp;lt;=array[idx2])
                idx2 = mid;
        }
        //此时数组为递增排列，第一个元素最小
        return array[0];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;斐波那契数列&quot;&gt;7.斐波那契数列&lt;/h3&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br/&gt;n&amp;lt;=39&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int Fibonacci(int n) {
         if(n&amp;lt;1) return 0;
        int[] fibonacci = new int[2];
        fibonacci[0] = 1;
        fibonacci[1] = 1;
        n-=2;
        while(n&amp;gt;0){
            int temp = fibonacci[0]+fibonacci[1];
            fibonacci[0] = fibonacci[1];
            fibonacci[1] = temp;
            n--;
        }
        return fibonacci[1];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;跳台阶动态规划&quot;&gt;8.跳台阶（动态规划）&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int JumpFloor(int target) {
        if(target &amp;lt; 1) return 0;
        int[] DP = new int[3];
        DP[0] = 1;
        DP[1] = 2;
        DP[2] = DP[0]+DP[1];
        if(target&amp;lt;=3)
            return DP[target-1];
        for(int i =4;i&amp;lt;=target;i++){
            DP[0] = DP[1];
            DP[1] = DP[2];
            DP[2] = DP[0]+DP[1];
        }
        return DP[2];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;矩形覆盖&quot;&gt;9.矩形覆盖&lt;/h3&gt;
&lt;p&gt;我们可以用2&lt;em&gt;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;/em&gt;1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int RectCover(int target) {
        if(target&amp;lt;1) return 0;
        int[] DP = new int[3];
        DP[0] = 1;
        DP[1] = 2;
        DP[2] = DP[1]+DP[0];
        if(target&amp;lt;4)
            return DP[target-1];
        for(int i = 4;i&amp;lt;=target;i++){
            int temp = DP[1]+DP[2];
            DP[0] = DP[1];
            DP[1] = DP[2];
            DP[2] = temp;
        }
        return DP[2];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二进制中1的个数&quot;&gt;10.二进制中1的个数&lt;/h3&gt;
&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while(n!=0){
            count+=n&amp;amp;1;
            n=n&amp;gt;&amp;gt;&amp;gt;1;
        }
        return count;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数值的整数次方&quot;&gt;11.数值的整数次方&lt;/h3&gt;
&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public double Power(double base, int exponent) {
        if(base == 0 &amp;amp;&amp;amp; exponent &amp;lt; 0)//输入不合法
            return 0.0;
        if(exponent &amp;lt; 0)
            return 1/PowerWithPositive(base,-1*exponent);
        else
            return PowerWithPositive(base,exponent);
  }
    public double PowerWithPositive(double base,int exponent){
        if(exponent == 0)
            return 1;
        if(exponent == 1)
            return base;
        double result = PowerWithPositive(base,exponent &amp;gt;&amp;gt; 1);
        result *= result;
        if((exponent &amp;amp; 1) == 1)
            result *= base;
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调整数组顺序使奇数位于偶数前面&quot;&gt;12.调整数组顺序使奇数位于偶数前面&lt;/h3&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Stack;
public class Solution {
    public void reOrderArray(int [] array) {
        if(array == null||array.length == 0) return;
        Stack&amp;lt;Integer&amp;gt; odd = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; even = new Stack&amp;lt;&amp;gt;();
        for(int i = 0;i&amp;lt;array.length;i++){
            if((array[i]&amp;amp;1) == 1)
                odd.push(array[i]);
            else
                even.push(array[i]);
        }
        int index = array.length-1;
        while(!even.isEmpty())
            array[index--] = even.pop();
        while(!odd.isEmpty())
            array[index--] = odd.pop();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;链表中倒数第k个结点&quot;&gt;13.链表中倒数第K个结点&lt;/h3&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;strong&gt;（能用指针尽量不要使用辅助栈）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;方法一使用指针&quot;&gt;方法一：使用指针&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class ListNode {
    int val;
    ListNode next = null;
 
    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.Stack;
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head == null || k&amp;lt;=0)
            return null;
        ListNode node1 = head,node2 = head;
        for(int i=1;i&amp;lt;k;i++){
            if(node1==null)
                return null;
            node1 = node1.next;
        }
        if(node1 == null)
            return null;
        while(node1.next!=null){
            node1 = node1.next;
            node2 = node2.next;
        }
        return node2;
    }
         
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法二使用辅助栈&quot;&gt;方法二：使用辅助栈&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class ListNode {
    int val;
    ListNode next = null;
 
    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.Stack;
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        Stack&amp;lt;ListNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        ListNode node = head;
        while(node!=null){
            stack.push(node);
            node = node.next;
        }
        for(int i =0;i&amp;lt;k;i++){
            if(stack.empty())
                return null;
            node = stack.pop();
        }
        return node;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反转链表&quot;&gt;14.反转链表&lt;/h3&gt;
&lt;p&gt;输入一个链表，反转链表后，输出链表的所有元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head == null) return null;
        ListNode node1 = null,node2 = head,node3 = head.next;
        while(node3!=null){
            node2.next = node1;
            node1 = node2;
            node2 = node3;
            node3 = node3.next;
        }
        node2.next = node1;
        return node2;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反转链表-1&quot;&gt;15.反转链表&lt;/h3&gt;
&lt;p&gt;输入一个链表，反转链表后，输出链表的所有元素。&lt;/p&gt;
&lt;h5 id=&quot;解法一使用栈&quot;&gt;解法一：（使用栈）&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.Stack;
public class Solution {
    public ListNode ReverseList(ListNode head) {
        Stack&amp;lt;ListNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        if(head == null) return null;
        while(head != null){
            stack.push(head);
            head = head.next;
        }
        
        head = stack.pop();
        ListNode temp = head;
        while(!stack.empty()){
            temp.next = stack.pop();
            temp = temp.next;
        }
        temp.next = null;//一定要注意这里的这行代码
        //一定要将链表末位next置为null
        return head;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;解法二&quot;&gt;解法二：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution{
    public ListNode ReverseList(ListNode head){
        ListNode reversedListHead;
        ListNode pre = null;
        ListNode node = null;
        ListNode next = null;
        if(head == null) return null;
        node = head;
        while(true){
            next = node.next;
            node.next = pre;
            pre = node;
            if(next == null){
                reversedListHead = node;
                break;
            }   
            node = next;
        }
        return reversedListHead;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;合并两个排序的链表&quot;&gt;16.合并两个排序的链表&lt;/h3&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;h5 id=&quot;解法一&quot;&gt;解法一：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //if(list1 == null &amp;amp;&amp;amp; list2 == null) return null;
        //这行代码可以不要，因为当list1 == null  return list2也等于null
        if(list1 == null) return list2;
        if(list2 == null) return list1;
        ListNode head,node;
        if(list1.val &amp;lt;= list2.val){
            node = list1;
            head = node;
            list1 = list1.next;
        }else{
            node = list2;
            head = node;
            list2 = list2.next;
        }
        while(list1 != null&amp;amp;&amp;amp;list2 != null){
            if(list1.val&amp;lt;=list2.val){
                node.next = list1;
                list1 = list1.next;
                node = node.next;
            }else{
                node.next = list2;
                list2 = list2.next;
                node = node.next;
            }
        }
        while(list1 != null){
            node.next = list1;
            list1 = list1.next;
            node = node.next;
        }
        while(list2 != null){
            node.next = list2;
            list2 = list2.next;
            node = node.next;
        }
        return head;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;解法二使用递归&quot;&gt;解法二：（使用递归）&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null) return list2;
        if(list2 == null) return list1;
        ListNode MergedHead = null;
        if(list1.val &amp;lt;= list2.val){
            MergedHead = list1;
            MergedHead.next = Merge(list1.next,list2);
        }else{
            MergedHead = list2;
            MergedHead.next = Merge(list1,list2.next);
        }
        return MergedHead;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;树的子结构&quot;&gt;17.树的子结构&lt;/h3&gt;
&lt;p&gt;输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1==null||root2==null) return false;
        boolean result = false;
        if(root1.val == root2.val){
            result = isEqualTree(root1,root2);
        }
        if(!result)
            result = HasSubtree(root1.left,root2);
        if(!result)
            result = HasSubtree(root1.right,root2);
        return result;
    }
    public boolean isEqualTree(TreeNode tree1,TreeNode tree2){
        //注意此处，只需判断tree2 == null即可返回true；
        //因为tree2为子树，此时tree1可以不为null，即tree1不为叶节点
        if(tree2 == null) return true; 
        if(tree1 == null) return false;
        if(tree1.val == tree2.val){
            return isEqualTree(tree1.left,tree2.left) &amp;amp;&amp;amp; isEqualTree(tree1.right,tree2.right);
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的镜像&quot;&gt;18.二叉树的镜像&lt;/h3&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1192699/201801/1192699-20180117193236584-783843940.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public void Mirror(TreeNode root) {
        if(root != null){
            TreeNode temp = root.left;
            root.left = root.right;
            root.right = temp;
            if(root.left!=null) Mirror(root.left);
            if(root.right!=null) Mirror(root.right);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;顺时针打印矩阵这道题有难度&quot;&gt;==19.顺时针打印矩阵（这道题有难度）==&lt;/h3&gt;
&lt;p&gt;==见书P161==&lt;/p&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/p&gt;
&lt;h4 id=&quot;知识点&quot;&gt;知识点：&lt;/h4&gt;
&lt;p&gt;关于值传递和引用传递可以得出这样的结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本数据类型传值，对形参的修改不会影响实参；&lt;/li&gt;
&lt;li&gt;引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；&lt;/li&gt;
&lt;li&gt;String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;解法一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; printMatrix(int [][] matrix) {
        if(matrix == null) return null;
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        int start = 0;
        while(start*2&amp;lt;matrix.length&amp;amp;&amp;amp;start*2&amp;lt;matrix[0].length){
            printMatrixCircle(matrix,start,result);
            start++;
        }
       return result;
    }
    public void printMatrixCircle(int [][] matrix,int start,ArrayList&amp;lt;Integer&amp;gt; result){
        int endX = matrix[0].length - 1 - start;
        int endY = matrix.length - 1 - start;
        for(int i = start;i &amp;lt;= endX;i++){
            result.add(matrix[start][i]);
        }
        if(start &amp;lt; endY){
            for(int i = start +1;i &amp;lt;= endY;i++)
                result.add(matrix[i][endX]);
        }
        if(start&amp;lt;endX&amp;amp;&amp;amp;start&amp;lt;endY)
            for(int i = endX -1;i&amp;gt;=start;i--)
                result.add(matrix[endY][i]);
        if(start&amp;lt;endX&amp;amp;&amp;amp;start&amp;lt;endY-1)
            for(int i = endY -1;i&amp;gt;start;i--)
                result.add(matrix[i][start]);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; printMatrix(int [][] matrix) {
       if(matrix == null) return null;
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        int h = matrix.length,w = matrix[0].length,round = 0;
        while(result.size()&amp;lt;h*w){
            int c=round,r=round;
            while(c&amp;lt;w-round)
                result.add(matrix[r][c++]);
            c--;
            r++;
            if(r == h-round) continue;
            while(r&amp;lt;h-round)
                result.add(matrix[r++][c]);
            r--;
            c--;
            if(c == round-1) continue;
            while(c&amp;gt;=round)
                result.add(matrix[r][c--]);
            c++;
            r--;
            while(r&amp;gt;round)
                result.add(matrix[r--][c]);
            round++;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;包含min函数的栈&quot;&gt;20 包含min函数的栈&lt;/h3&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Stack;

public class Solution {

    Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;();
    Stack&amp;lt;Integer&amp;gt; minStack = new Stack&amp;lt;Integer&amp;gt;();
    int min;
    public void push(int node) {
        stack.push(node);
        if(minStack.empty())
            min = node;
        else
            min = Math.min(minStack.peek(),node);
        minStack.push(min);
    }
    
    public int pop() {
        minStack.pop();
        return stack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;栈的压入弹出序列&quot;&gt;21.栈的压入、弹出序列&lt;/h3&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【解题思路】：设计一个辅助栈，如果下一个弹出的数字是辅助栈的栈顶，则弹出，如果不是栈顶，则继续将压入序列压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入辅助站，栈顶仍然不是欲弹出的数字，则该序列不可能是一个弹出序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;==注意：当stack为空的时候，调用peek()方法会抛出异常==&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA == null||popA == null||pushA.length!=popA.length) return false;
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int j = 0;
        for(int i = 0 ;i&amp;lt;popA.length;i++){
            //一定注意这里需要先判断一下栈是否为空，
            //如果为空，则调用peek()时会出现异常;
            if(stack.empty())
                stack.push(pushA[j++]);
            while(stack.peek()!=popA[i]&amp;amp;&amp;amp;j&amp;lt;pushA.length)
                stack.push(pushA[j++]);
            if(stack.peek()==popA[i])
                stack.pop();
            else
                return false;
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从上往下打印二叉树&quot;&gt;22.从上往下打印二叉树&lt;/h3&gt;
&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/p&gt;
&lt;h4 id=&quot;java知识点&quot;&gt;Java知识点：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;返回长度：
&lt;ol&gt;&lt;li&gt;String.length();String字符串用length()方法会返回其长度。&lt;/li&gt;
&lt;li&gt;Array.length;数组有length属性，直接数组名点length就可以取到。&lt;/li&gt;
&lt;li&gt;ArrayList.size()方法的会返回其长度。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ArrayList 操作：&lt;br/&gt;&lt;strong&gt;get(),add(),remove()&lt;/strong&gt;&lt;br/&gt;You need to use the get() method to get the element at a particular index from an ArrayList. You can't use [] to get the element at a particular index, in an arraylist. Its possible only for arrays and your files is not an array, but an ArrayList.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;==一定要注意，Java中Queue为接口，如果使用队列需要使用LinkedList（双向队列）、PriorityQueue（优先队列）==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.LinkedList;

/**
 * public class TreeNode {
 *  int val = 0;
 *  TreeNode left = null;
 *  TreeNode right = null;
 *
 *  public TreeNode(int val) {
 *      this.val = val;
 *  }
 * }
 */
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; PrintFromTopToBottom( TreeNode root )
    {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if ( root == null )
            return(result);
        LinkedList&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        result.add( root.val );
        if ( root.left != null )
            queue.offer( root.left );
        if ( root.right != null )
            queue.offer( root.right );
        while ( !queue.isEmpty() )
        {
            TreeNode node = queue.poll();
            result.add( node.val );
            if ( node.left != null )
                queue.offer( node.left );
            if ( node.right != null )
                queue.offer( node.right );
        }
        return(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
import java.util.ArrayList;
/**
用arraylist模拟一个队列来存储相应的TreeNode
*/
public class Solution {
    ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    ArrayList&amp;lt;TreeNode&amp;gt; temp = new ArrayList&amp;lt;&amp;gt;();
    public ArrayList&amp;lt;Integer&amp;gt; PrintFromTopToBottom(TreeNode root) {
        if(root == null) return result;
        temp.add(root);
        while(temp.size() != 0){
            TreeNode node = temp.remove(0);
            result.add(node.val);
            if(node.left!=null)
                temp.add(node.left);
            if(node.right!=null)
                temp.add(node.right);
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉搜索树的后序遍历序列&quot;&gt;23.二叉搜索树的后序遍历序列&lt;/h3&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出True,否则输出False。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence == null || sequence.length == 0) return false;
        int start = 0,end = sequence.length-1;
        return isSearchTree(sequence,start,end);
    }
    public boolean isSearchTree(int [] sequence,int start,int end){
        if(end==start) return true;
        int root = sequence[end];
        int index = end;
        for(int i = start;i&amp;lt;end;i++){
            if(sequence[i] &amp;gt; root){
                index = i;
                break;
            }
        }
        for(int i = index;i&amp;lt;end;i++)
            if(sequence[i]&amp;lt; root)
                return false;
        if(index == end||index == start)// index = end 时没有右子树；index = start时没有左子树； 
            return isSearchTree(sequence,start,end-1);
        else
            return isSearchTree(sequence,start,index-1)&amp;amp;&amp;amp;isSearchTree(sequence,index,end-1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树中和为某一值的路径&quot;&gt;24.二叉树中和为某一值的路径&lt;/h3&gt;
&lt;p&gt;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;br/&gt;&lt;strong&gt;【解题思路】：因为根结点和叶子结点一定在路径中，而且路径开始一定是跟结点，使用前序遍历遍历二叉树，每经过一个结点减小target的值，直至找到使target=0的叶子结点，即为路径，每次回退，需要删除路径中最后一个结点。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    private ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; allPath = new ArrayList&amp;lt;&amp;gt;();
    private ArrayList&amp;lt;Integer&amp;gt; path = new ArrayList&amp;lt;&amp;gt;();
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root,int target) {
        if(root == null) return allPath;
        target -= root.val;
        path.add(root.val);
        if(target == 0&amp;amp;&amp;amp; root.left == null&amp;amp;&amp;amp;root.right == null)
            allPath.add(new ArrayList&amp;lt;Integer&amp;gt;(path));
        else{
            FindPath(root.left,target);
            FindPath(root.right,target);
        }
        path.remove(path.size()-1);
        return allPath;
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;复杂链表的复制&quot;&gt;25.复杂链表的复制&lt;/h3&gt;
&lt;p&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        //一定注意考虑输入为空链表的情况
        if(pHead == null) return null;
        //第一步：克隆每个结点的值和next，并且将新节点放置在对应旧结点之后
        RandomListNode node = pHead;
        while(node != null){
            RandomListNode cloneNode = new RandomListNode(node.label);
            //cloneNode.label = node.label;
            cloneNode.next = node.next;
            node.next = cloneNode;
            node = cloneNode.next;
        }
        //第二步：克隆每个随机指针
        node = pHead;
        while(node != null){
            RandomListNode cloneNode = node.next;
            if(node.random != null)
                cloneNode.random = node.random.next;
            node = cloneNode.next;
        }
        //第三步：拆分拼接的链表
        node = pHead;
        RandomListNode cloneHead = pHead.next;
        while(node != null){
            RandomListNode cloneNode = node.next;
            node.next = cloneNode.next;
            node = node.next;
            if(node != null)
                cloneNode.next = node.next;
            else
                cloneNode.next = null;
        }
        return cloneHead;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉搜索树与双向链表&quot;&gt;26.二叉搜索树与双向链表&lt;/h3&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null) return null;
        if(pRootOfTree.left == null &amp;amp;&amp;amp; pRootOfTree.right == null) return pRootOfTree;
        TreeNode left = Convert(pRootOfTree.left);
        TreeNode node = left;
        
        if(node == null)
            pRootOfTree.left = null;
        else{
            while(node.right != null)
                node = node.right;
            pRootOfTree.left = node;
            node.right = pRootOfTree;
        }
        TreeNode right = Convert(pRootOfTree.right);
        pRootOfTree.right = right;
        if(right != null)
            right.left = pRootOfTree;
        return left != null ? left : pRootOfTree; 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串的排列&quot;&gt;27.==字符串的排列==&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br/&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;:&lt;br/&gt;输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.HashSet;
import java.util.Collections;
public class Solution {
    ArrayList&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;String&amp;gt;();
    public ArrayList&amp;lt;String&amp;gt; Permutation(String str) {
        if(str == null) return null;
        char[] charArray = str.toCharArray();
        permutation(charArray,0);
        Collections.sort(result);
        return result;
    }
    public void permutation(char[] charArray,int beginIdx){
        if(beginIdx &amp;gt;= charArray.length) return;
        if(beginIdx == charArray.length-1){
            result.add(String.valueOf(charArray));
        }
        HashSet&amp;lt;Character&amp;gt; charSet = new HashSet&amp;lt;&amp;gt;();
        for(int i = beginIdx;i&amp;lt;charArray.length;i++){
            if(i == beginIdx){
                charSet.add(charArray[i]);
                permutation(charArray,beginIdx+1);
            }else if(i != beginIdx &amp;amp;&amp;amp; !charSet.contains(charArray[i])){
                char temp = charArray[beginIdx];
                charArray[beginIdx] = charArray[i];
                charArray[i] = temp;
                permutation(charArray,beginIdx+1);
                temp = charArray[beginIdx];
                charArray[beginIdx] = charArray[i];
                charArray[i] = temp;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组中出现次数超过一半的数字&quot;&gt;28.数组中出现次数超过一半的数字&lt;/h3&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;/p&gt;
&lt;h4 id=&quot;解法一利用hashmap&quot;&gt;解法一：利用HashMap&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.HashMap;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        HashMap&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        int length = array.length;
        if(length == 1) return array[0]; //此处用于当数组只有一个元素的时候，下面的代码对该情况无效
        for(int i : array){
           if(map.containsKey(i)){
               if(map.get(i) == length/2)
                   return i;
               map.put(i,map.get(i) + 1);
               
           }else{
               map.put(i,1);
           }
        }
        return 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;解法二利用数组特点重复次数超过一半的数字一定大于其它数字出现次数之和&quot;&gt;解法二：利用数组特点，重复次数超过一半的数字一定大于其它数字出现次数之和&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array == null || array.length == 0) return 0;
        int length = array.length;
        int result = array[0];
        int times = 1;
        for(int i =1;i&amp;lt;length;i++){
            if(result == array[i])
                times++;
            else if(times == 0){
                result = array[i];
                times =1;
            }else
                times--; 
        }
        if(times == 0) return 0;
        times = 0;
        for(int i =0;i&amp;lt;length;i++){
            if(array[i] == result)
                times++;
        }
        if(times &amp;lt;= length/2)
            result = 0;
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最小的k个数&quot;&gt;29.最小的K个数&lt;/h3&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
&lt;h4 id=&quot;解法一-1&quot;&gt;解法一&lt;/h4&gt;
&lt;p&gt;Partition思想&lt;/p&gt;
&lt;p&gt;允许改变原始数组的情况，时间复杂度O(n)，不适合海量数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    /*解法一：允许改变原始数组的情况，时间复杂度O(n)，不适合海量数据*/
    public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        //注意如果输入不合法，这里返回的是一个空集合，不是Null，与return null不同
        if(input == null || k&amp;lt;0 || k&amp;gt;input.length) return result;
        
        int start = 0;
        int end = input.length-1;
        int smallNums = partition(input,start,end);
        while(smallNums != k-1){
            if(smallNums &amp;gt; k-1)
                smallNums = partition(input,start,smallNums-1);
            else if(smallNums &amp;lt; k-1)
                smallNums = partition(input,smallNums+1,end);
        }
        for(int i =0;i&amp;lt;k;i++){
            result.add(input[i]);
        }
        return result;
    }
    //快排方法功能函数，在指定范围内随机选取一个数字，将数组中大与等于的放置其又，小于的放置其左；
    //返回值是在变换位置后，该元素的索引值
    public static int partition(int[] array,int start,int end){
        //边界检测
        if(array == null || array.length == 0 || start &amp;lt; 0 || end &amp;gt;= array.length || start &amp;gt; end) return -1;
        //在[start,end]范围内，随机选取一个数作为index
        int randomIdx = (int)(start + Math.random()*(end-start));
        //int length = array.length;
        int smallNums = start-1;
        swap(array,randomIdx,end);
        for(int i=start;i&amp;lt;end;i++){
            if(array[i] &amp;lt; array[end]){
                smallNums++;
                if(smallNums &amp;lt; i){
                    swap(array,smallNums,i);
                }
            }
        }
        
        smallNums++;
        swap(array,smallNums,end);
        return smallNums;
    }
    //交换元素
    public static void swap(int[] array,int i,int j){
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;解法二-1&quot;&gt;解法二：&lt;/h4&gt;
&lt;p&gt;使用最大堆思想，通过优先队列的Conparator定制排序，实现指定大小的最大堆。这样做的目的是使空间复杂度最低O(k),时间复杂度最低O(nlogk)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;
public class Solution {
    //解法二：不改变原始数组，使用优先队列，时间复杂度O(nlogk)，适合海量数据
    public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if(input == null || k &amp;gt; input.length || k&amp;lt;=0) return result;
        PriorityQueue&amp;lt;Integer&amp;gt; maxQueue = new PriorityQueue(k,new Comparator&amp;lt;Integer&amp;gt;(){
            @Override
            public int compare(Integer o1,Integer o2){
                return o2.compareTo(o1);//将先前Integer中的自然排序（从小到大）反过来，实现从大到小；
            }
        });
        for(int i =0;i&amp;lt;input.length;i++){
            if(maxQueue.size() != k ){
                maxQueue.offer(input[i]);
            }else if(maxQueue.peek() &amp;gt; input[i]){
                Integer temp = maxQueue.poll();//必须先去除队列头部的数据,以保证队列长度
                temp = null;
                maxQueue.offer(input[i]);
            }
        }
        for(Integer i : maxQueue){
            result.add(i);
        }
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连续子数组的最大和&quot;&gt;30.连续子数组的最大和&lt;/h3&gt;
&lt;p&gt;HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;
        int[] DP = new int[2];
        DP[0] = array[0];
        int max = DP[0];
        for (int i = 1; i &amp;lt; array.length; i++) {
            DP[i &amp;amp; 1] = Math.max(array[i], array[i] + DP[(i - 1) &amp;amp; 1]);
            max = Math.max(max, DP[i &amp;amp; 1]);
        }
        return max;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;n整数中1出现的次数&quot;&gt;==31.1~n整数中1出现的次数==&lt;/h3&gt;
&lt;p&gt;输入一个整数n，求1~ n个整数的十进制表示中1出现的次数，例如：输入13，1~13中包含1的数字有1、10、11、12、13因此共出现6次。&lt;/p&gt;
&lt;h4 id=&quot;解题思路&quot;&gt;解题思路：&lt;/h4&gt;
&lt;p&gt;思路：&lt;br/&gt;n中每一位数字对整体“1”数量的影响包括一下两个方面：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;若第i位大于1，则该位1的个数位，高于i的位组成的数字+1倍的10^i；&lt;/li&gt;
&lt;li&gt;若第i位等于1，则该位1的个数位，高于i的位组成的数字倍的10^i加上后面各位组成的数字加1；&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;若第i位小于1，则该位1的个数位，高于i的位组成的数字倍的10^i；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
public int NumberOf1Between1AndN_Solution(int n) {
    if(n&amp;lt;=0) return 0;
    //用于将int的每一位数字保存在int[]数组中
    ArrayList&amp;lt;Integer&amp;gt; number = new ArrayList&amp;lt;&amp;gt;();
    int totalNums = 0;
    //已分析过的高位数字组成的乘子
    int mult = 0;
    int temp = n;
    while(temp!=0){
        number.add(temp%10);
        temp = temp/10;
    }
    for(int i = number.size()-1;i&amp;gt;=0;i--){
        int nums = (int)(Math.pow(10,i));
        if(number.get(i) == 1){
            totalNums += (int)(n % Math.pow(10,i) + 1);
        }else if(number.get(i) &amp;gt; 1){
            totalNums += (int)(Math.pow(10,i));
        }else if(number.get(i) == 0){
        }
        totalNums += mult * nums;
        mult = mult * 10 + number.get(i);
    }
    return totalNums;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法二：找数字规律&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;

public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        if (n &amp;lt;= 0) return 0;
        int num = 0, k = 0, count = 0, i = 1;
        while (n != 0) {
            int x = n % 10;
            if (x == 1) {
                count += num + 1;
                count += x * k;
            } else if (x &amp;gt; 1) {
                count += x * k;
                count += (int) Math.pow(10, i - 1);
            }
            num += x * Math.pow(10, i - 1);
            k = 10 * k + (int) Math.pow(10, i - 1);
            n /= 10;
            i++;
        }

        return count;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;把数组排成最小的数&quot;&gt;32.把数组排成最小的数&lt;/h3&gt;
&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。&lt;/p&gt;
&lt;h4 id=&quot;解题思路-1&quot;&gt;解题思路：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;实际是将数组元素进行排序的操作&lt;/li&gt;
&lt;li&gt;排序规则为，若MN组成的数字大于NM，则N在前M在后&lt;/li&gt;
&lt;li&gt;使用Comparatpr定制排序规则&lt;/li&gt;
&lt;li&gt;考虑到数字连接起来可能使int溢出，所以转换为使用String来操作。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
public class Solution {
    public String PrintMinNumber(int[] numbers) {
        String result = &quot;&quot;;
        if (numbers == null || numbers.length == 0) return result;
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; numbers.length; i++) {
            list.add(numbers[i] + &quot;&quot;);
        }
        Collections.sort(list, new Comparator&amp;lt;String&amp;gt;() {
            @Override
            public int compare(String sNum1, String sNum2) {
                String num1 = sNum1 + sNum2;
                String num2 = sNum2 + sNum1;
                return num1.compareTo(num2);
            }
        });
        for (String str : list) {
            result += str;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;丑数&quot;&gt;33.丑数&lt;/h3&gt;
&lt;p&gt;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index &amp;lt;= 0 ) return 0;
        int mult2_Idx = 0,mult3_Idx = 0,mult5_Idx = 0;
        int[] uglyNumber = new int[index];
        uglyNumber[0] = 1;
        for(int i = 1;i&amp;lt;index;i++){
            int min = Math.min(Math.min(uglyNumber[mult2_Idx]*2,
                                        uglyNumber[mult3_Idx]*3),
                                        uglyNumber[mult5_Idx]*5);
            uglyNumber[i] = min;    
            while(uglyNumber[mult2_Idx]*2 &amp;lt;= uglyNumber[i])
                mult2_Idx++;
            while(uglyNumber[mult3_Idx]*3 &amp;lt;= uglyNumber[i])
                mult3_Idx++;
            while(uglyNumber[mult5_Idx]*5 &amp;lt;= uglyNumber[i])
                mult5_Idx++;
        }
        return uglyNumber[index-1];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第一个只出现一次的字符&quot;&gt;34.第一个只出现一次的字符&lt;/h3&gt;
&lt;p&gt;在一个字符串(1&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.HashMap;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        int result = Integer.MAX_VALUE;
        if(str.length() == 0) return -1;
        HashMap&amp;lt;Character,Integer&amp;gt; charIdx = new HashMap&amp;lt;&amp;gt;();
        for(int i = 0 ;i &amp;lt; str.length(); i++){
            Character c = str.charAt(i);
            if(charIdx.containsKey(c)){
                charIdx.put(c,-1);
            }else{
                charIdx.put(c,i);
            }
        }
        for(int index : charIdx.values()){
            if(index != -1){
                result = Math.min(result,index);
            }
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组中的逆序对&quot;&gt;35.==数组中的逆序对==&lt;/h3&gt;
&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007&lt;/p&gt;
&lt;p&gt;输入描述:&lt;/p&gt;
&lt;p&gt;题目保证输入的数组中没有的相同的数字&lt;/p&gt;
&lt;p&gt;数据范围：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;对于%50的数据,size&amp;lt;=10^4
对于%75的数据,size&amp;lt;=10^5
对于%100的数据,size&amp;lt;=2*10^5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;p&gt;输入1,2,3,4,5,6,7,0 输出7&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int InversePairs(int [] array) {
        if(array == null||array.length == 0) return 0;
        int length = array.length;
        int[] copy = new int[length];
        for(int i = 0;i &amp;lt; length ;i++){
            copy[i] = array[i];
        }
        int count = InversePairsCore(array,copy,0,array.length-1);
        return count;
    }
    
    public int InversePairsCore(int[] array,int[] copy,int start,int end){
        if(start == end){
            return 0;
        }
        int count = 0;
        int length = (end-start)/2;
        //注意：这里是故意将copy和array调换位置的，因为每次执行InversePairCore之后copy在[start,end]部分都是排好序的
        //随意使用data作为array输入，省去了来回复制的资源消耗。
        int left = InversePairsCore(copy,array,start,start+length);
        int right = InversePairsCore(copy,array,start+length+1,end);
        int p1 = start+length;
        int p2 = end;
        int copyIdx = end;
        while(p1 &amp;gt;= start &amp;amp;&amp;amp; p2 &amp;gt;= start+length+1){
            if(array[p1]&amp;gt;array[p2]){
                count += p2-start-length;
                //此处先判断一下，以免超出运算范围。
                if(count &amp;gt; 1000000007)
                    count = count%1000000007;
                copy[copyIdx--] = array[p1--];
            }else{
                copy[copyIdx--] = array[p2--];
            }
        }
        while(p1 &amp;gt;= start){
            copy[copyIdx--] = array[p1--];
        }
        while(p2 &amp;gt;= start+length+1){
            copy[copyIdx--] = array[p2--];
        }
        return (count+left+right)%1000000007;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;两个链表的第一个公共结点&quot;&gt;36.两个链表的第一个公共结点&lt;/h3&gt;
&lt;p&gt;输入两个链表，找出它们的第一个公共结点。&lt;strong&gt;技巧：不使用辅助Stack&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if(pHead1 == null || pHead2 == null) return null;
        int L1 = getListLength(pHead1);
        int L2 = getListLength(pHead2);
        if(L1&amp;gt;L2)
            for(int i = 0 ;i&amp;lt;(L1-L2);i++)
                pHead1 = pHead1.next;
        else if(L2&amp;gt;L1)
            for(int i = 0 ;i&amp;lt;(L2-L1);i++)
                pHead2 = pHead2.next;
        
        while(pHead1!=null){
            if(pHead1 == pHead2)
                return pHead1;
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
        return null;
    }
    public int getListLength(ListNode head){
        ListNode temp = head;
        int count = 1;
        while(temp.next != null){
            temp = temp.next;
            count++;
        }
        return count;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数字在排序数组中出现的次数&quot;&gt;37.数字在排序数组中出现的次数&lt;/h3&gt;
&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;br/&gt;&lt;strong&gt;采用二分查找法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
方法一：时间复杂度O（n），不可选
*/

public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        if(array.length == 0) return 0;
        int count = 0;
        for(int i = 0 ; i &amp;lt; array.length ; i++){
            if(array[i] == k){
                count++;
            }else{
                if(count != 0)
                    break;
            }
        }
        return count;
    }
}

/*
方法二：首选！先采用二分查找法，在数组中查找到第一个K和第二个K，总时间复杂度O（logn）
*/
public class Solution {
    public int GetNumberOfK(int[] array,int k){
        if(array.length == 0) return 0;
        int first = getFirstK(array,k,0,array.length-1);
        int last = getLastK(array,k,0,array.length-1);
        if(first &amp;gt; -1 &amp;amp;&amp;amp; last &amp;gt; -1)
            return last - first + 1;
        return 0;
    }
    public int getFirstK(int[] array,int k,int start,int end){
        if(start &amp;gt; end) return -1;
        int midIdx = (end + start)/2;
        if(array[midIdx] == k){
            if((midIdx &amp;gt; 0 &amp;amp;&amp;amp; array[midIdx-1] != k) || midIdx == 0)
                return midIdx;
            else{
                end = midIdx - 1;
                return getFirstK(array,k,start,end);
            }
        }else if(array[midIdx] &amp;gt; k){
            end = midIdx - 1;
        }else if(array[midIdx] &amp;lt; k){
            start = midIdx +1;
        }
        return getFirstK(array,k,start,end);
    }
    public int getLastK(int[] array,int k ,int start,int end){
        if(start &amp;gt; end) return -1;
        int midIdx = (start + end)/2;
        if(array[midIdx] == k){
            if((midIdx &amp;lt; array.length-1 &amp;amp;&amp;amp; array[midIdx+1] != k) || midIdx == array.length-1)
                return midIdx;
            else
                start = midIdx + 1;
        }else if(array[midIdx] &amp;gt; k){
            end = midIdx - 1;
        }else if(array[midIdx] &amp;lt; k){
            start = midIdx + 1;
        }
        return getLastK(array,k,start,end);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的深度&quot;&gt;38.二叉树的深度&lt;/h3&gt;
&lt;p&gt;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root == null) return 0;
        int left = TreeDepth(root.left);
        int right = TreeDepth(root.right);
        if(left&amp;gt;right) return left+1;
        else return right+1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;平衡二叉树&quot;&gt;39.平衡二叉树&lt;/h3&gt;
&lt;p&gt;输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么他就是一棵平衡二叉树。&lt;br/&gt;&lt;strong&gt;解法一：不够简便&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null) return true;
        int left = TreeDepth(root.left);
        int right = TreeDepth(root.right);
        if((left-right)&amp;gt;1||(left-right)&amp;lt;-1)
            return false;
        else
            return IsBalanced_Solution(root.left) &amp;amp;&amp;amp; IsBalanced_Solution(root.right);
    }
    public int TreeDepth(TreeNode root){
        if(root == null) return 0;
        int left = TreeDepth(root.left);
        int right = TreeDepth(root.right);
        return left &amp;gt; right ? left+1 : right+1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法二：推荐！后序遍历二叉树，只需遍历一遍即可。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return getDepth(root) != -1;
    }
    public int getDepth(TreeNode root){
        if(root == null) return 0;
        int left = getDepth(root.left);
        if(left == -1)
            return -1;
        int right = getDepth(root.right);
        if(right == -1)
            return -1;
        return Math.abs(left-right) &amp;gt; 1 ? -1 : Math.max(left,right) + 1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组中只出现一次的数字&quot;&gt;40.数组中只出现一次的数字&lt;/h3&gt;
&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;br/&gt;&lt;strong&gt;第一种：利用Set，空间复杂度为O(N)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.HashSet;
import java.util.Iterator;
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();
        for(int i = 0;i&amp;lt;array.length;i++){
            if(set.contains(array[i])){
                set.remove(array[i]);
            }else{
                set.add(array[i]);
            }
        }
        boolean isFirst = true;
        Iterator iter = set.iterator();
        while(iter.hasNext()){
            if(isFirst){
                num1[0] = (int)iter.next();
                isFirst = false;
            }else
                num2[0] = (int)iter.next();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二种：按位运算：异或、位移&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        int OR = 0;
        for(int i = 0;i&amp;lt;array.length;i++)
            OR ^= array[i];
        int idx = 0;//OR从后数第几位是1，从1开始
        while(OR != 0){
            OR = OR &amp;gt;&amp;gt; 1;
            idx++;
        }
        num1[0] = 0;
        num2[0] = 0;
        for(int i = 0;i&amp;lt;array.length;i++){
            if((array[i]&amp;amp;(1&amp;lt;&amp;lt;(idx-1))) == 0)
                num1[0] ^= array[i];
            else
                num2[0] ^= array[i];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;和为s的连续正数序列&quot;&gt;41.和为S的连续正数序列&lt;/h3&gt;
&lt;p&gt;小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!&lt;br/&gt;输出描述:&lt;br/&gt;输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;

public class Solution {
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindContinuousSequence(int sum) {
        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        int small = 1, big = 2, s = 3, mid = sum / 2;
        while (small &amp;lt;= mid) {
            if (s == sum) {
                ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                for (int i = small; i &amp;lt;= big; i++)
                    list.add(i);
                result.add(list);
                s -= small;
                small++;
            } else if (s &amp;lt; sum) {
                big++;
                s += big;
            } else if (s &amp;gt; sum) {
                s -= small;
                small++;
            }
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;和为s的两个数&quot;&gt;42.和为S的两个数&lt;/h3&gt;
&lt;p&gt;输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。&lt;br/&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;br/&gt;其实找的就是数组最两侧满足和为S的数字，因为：&lt;/p&gt;
&lt;p&gt;z=xy&lt;/p&gt;
&lt;p&gt;x+y=s&lt;/p&gt;
&lt;p&gt;z=x(s-x)=sx-x^2 函数图像为向下开口的抛物线，两段数值小中间大。所以取两边的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; FindNumbersWithSum(int [] array,int sum) {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        int p1 = 0,p2 = array.length-1;
        while(p1&amp;lt;p2){
            if(array[p1]+array[p2] == sum){
                result.add(array[p1]);
                result.add(array[p2]);
                return result;
            }else if(array[p1]+array[p2]&amp;gt;sum)
                p2--;
            else
                p1++;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;坐旋转字符串&quot;&gt;43.坐旋转字符串&lt;/h3&gt;
&lt;p&gt;汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！&lt;br/&gt;==该题有好多种做法==&lt;br/&gt;&lt;strong&gt;方法一：虽然AC，但是不是最优解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n&amp;lt;0 || str==null || str.length() == 0) return &quot;&quot;;
        n %= str.length();
        StringBuilder sb = new StringBuilder();
        for(int i = n;i&amp;lt;str.length();i++){
            sb.append(str.charAt(i));
        }
        for(int i = 0;i&amp;lt;n;i++){
            sb.append(str.charAt(i));
        }
        return sb.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public String LeftRotateString(String str, int n) {
        if (str.length() == 0 || n &amp;lt; 0) return &quot;&quot;;
        int length = str.length();
        n %= length;
        str += str;
        return str.substring(n, n + length);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;翻转字符串&quot;&gt;44.翻转字符串&lt;/h3&gt;
&lt;p&gt;牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public String ReverseSentence(String str) {
        if (str.length() == 0) return &quot;&quot;;
        char[] charArray = str.toCharArray();
        Reverse(charArray, 0, str.length() - 1);
        int start = 0, end = 0;
        for (int i = 0; i &amp;lt; charArray.length; i++) {
            if (charArray[i] == ' ') {
                end = i - 1;
                Reverse(charArray, start, end);
                start = i + 1;
            }
        }
        //这句话是用于旋转最后一个单词的。
        Reverse(charArray, start, charArray.length - 1);
        return String.valueOf(charArray);
    }

    public char[] Reverse(char[] charArray, int start, int end) {
        while (start &amp;lt; end) {
            char temp = charArray[start];
            charArray[start] = charArray[end];
            charArray[end] = temp;
            start++;
            end--;
        }
        return charArray;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;扑克牌顺子&quot;&gt;45.扑克牌顺子&lt;/h3&gt;
&lt;p&gt;LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Arrays;
public class Solution {
    public boolean isContinuous(int [] numbers) {
        if(numbers.length &amp;lt; 5) return false;
        Arrays.sort(numbers);
        int zerosNum = 0;
        int needZeros = 0;
        for(int i = 0 ;i &amp;lt; 5;i++){
            if(numbers[i] == 0){
                zerosNum++;
            }else if(i+1&amp;lt;5){
                //如存在两数字相同，则一定不是顺子
                if(numbers[i+1] == numbers[i]) return false; 
                needZeros += numbers[i+1] - numbers[i] -1;
            }
        }
        //此时大王个数超过四个，不符合题目要求
        if(zerosNum &amp;gt; 4) return false; 
        if(zerosNum &amp;gt;= needZeros) return true;
        else return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;孩子们的游戏&quot;&gt;46.孩子们的游戏&lt;/h3&gt;
&lt;p&gt;n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。（约瑟夫环问题）&lt;br/&gt;&lt;strong&gt;解法一：使用数组模拟环&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n&amp;lt;0||m&amp;lt;1) return -1;
        int[] array = new int[n];
        int count=n,step=0,idx=-1;
        while(count&amp;gt;0){
            idx++;
            if(idx == n) idx=0;
            if(array[idx] == -1) continue;//如果是被标记过的则跳过
            step++;
            if(step == m){
                array[idx] = -1;
                count--; 
                step=0;
            } 
        }
        return idx;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法二：使用ArrayList模拟环&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180314105704058-283774158.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public int LastRemaining_Solution(int n, int m){
        if(n&amp;lt;0||m&amp;lt;1) return -1;
        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for(int i = 0;i&amp;lt;n;i++)
            list.add(i);
        int idx = (m-1)%n;
        while(list.size()&amp;gt;1){
            list.remove(idx);
            idx = (idx+m-1)%list.size();
        }
        return list.get(0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;求123...n&quot;&gt;47.求1+2+3+...+n&lt;/h3&gt;
&lt;p&gt;求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
&lt;p&gt;解题思路：&lt;strong&gt;(短路求值)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需利用&lt;strong&gt;逻辑与&lt;/strong&gt;的&lt;strong&gt;短路特性&lt;/strong&gt;实现递归终止。&lt;/li&gt;
&lt;li&gt;当n==0时，(n&amp;gt;0)&amp;amp;&amp;amp;((sum+=Sum_Solution(n-1))&amp;gt;0)只执行前面的判断，为false，然后直接返回0；&lt;/li&gt;
&lt;li&gt;当n&amp;gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int Sum_Solution(int n) {
        int sum = n;
        boolean isEnd = (sum != 0)&amp;amp;&amp;amp;((sum += Sum_Solution(n-1))&amp;gt;0);
        return sum;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不用加减乘除做加法&quot;&gt;48.不用加减乘除做加法&lt;/h3&gt;
&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析：按位运算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;step1:按位与是查看两个数哪些二进制位都为1，这些都是进位位，结果需左移一位，表示进位后的结果&lt;/li&gt;
&lt;li&gt;step2:异或是查看两个数哪些二进制位只有一个为1，这些是非进位位，可以直接加、减，结果表示非进位位进行加操作后的结果&lt;/li&gt;
&lt;li&gt;step3:n1&amp;amp;n2是查看有没有进位位了，如果有，需要重复step1、step2；如果没有，保留n1、n2上二进制为1的部分，用或将之合为一个数，即为最后结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int Add(int num1,int num2) {
        int n1,n2;
        n1 = num1 &amp;amp; num2;
        n1 = n1&amp;lt;&amp;lt;1;
        n2 = num1 ^ num2;
        if((n1 &amp;amp; n2) != 0) return Add(n1,n2);
        return n1 | n2;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;把字符串转换成整数&quot;&gt;49.把字符串转换成整数&lt;/h3&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180314114711013-454626611.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int StrToInt(String str) {
        if(str.length() &amp;lt; 1) return 0;
        char[] nums = str.toCharArray();
        int result = 0;
        int flag = 1;
        for(int i = 0 ; i&amp;lt;nums.length ; i++){
            if(nums[i]-'0'&amp;gt;9 || nums[i]-'0'&amp;lt;0){
                if( i==0 &amp;amp;&amp;amp; (nums[i] == '+' || nums[i] == '-'))
                    flag = nums[i] == '+' ? 1 : -1;
                else
                    return 0;
            }else{
                result*=10;
                result+=(nums[i]-'0');
            }  
        }
        return result*flag;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不适用str.toCharArray()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int StrToInt(String str) {
        if(str.length() &amp;lt; 1) return 0;
        int result = 0;
        int flag = 1;
        for(int i = 0 ; i&amp;lt;str.length(); i++){
            if(str.charAt(i)-'0'&amp;gt;9 || str.charAt(i)-'0'&amp;lt;0){
                if( i==0 &amp;amp;&amp;amp; (str.charAt(i) == '+' || str.charAt(i) == '-'))
                    flag = str.charAt(i) == '+' ? 1 : -1;
                else
                    return 0;
            }else{
                result*=10;
                result+=(str.charAt(i)-'0');
            }  
        }
        return result*flag;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组中重复的数字&quot;&gt;50.数组中重复的数字&lt;/h3&gt;
&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(length&amp;lt;0) return false;
        boolean[] result = new boolean[length];
        for(int i = 0;i&amp;lt;length;i++){
            if(numbers[i]&amp;gt;length-1||numbers[i]&amp;lt;0) return false;
            if(result[numbers[i]]){
                duplication[0] = numbers[i];
                return true;
            }
            result[numbers[i]] = true;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建乘积数组&quot;&gt;51.构建乘积数组&lt;/h3&gt;
&lt;p&gt;给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1]&lt;/em&gt;...&lt;em&gt;A[i-1]&lt;/em&gt;A[i+1]&lt;em&gt;...&lt;/em&gt;A[n-1]。不能使用除法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180314161925060-1134955272.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        int[] B = new int[A.length];
        if(A.length == 0) return B;
        B[0] = 1;
        for(int i = 1;i&amp;lt;A.length;i++){
            B[i] = B[i-1] * A[i-1];
        }
        int temp = 1;
        for(int i = A.length-1;i&amp;gt;=0;i--){
            B[i] *= temp;
            temp *= A[i];
        }
        return B;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则表达式匹配&quot;&gt;==52.正则表达式匹配==&lt;/h3&gt;
&lt;p&gt;请实现一个函数用来匹配包括'.'和'&lt;em&gt;'的正则表达式。模式中的字符'.'表示任意一个字符，而'&lt;/em&gt;'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab&lt;em&gt;ac&lt;/em&gt;a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.当patternIndex后一位为‘&lt;em&gt;’时：&lt;br/&gt;此时若strIndex == str.length时，直接将patternIndex+2，跳过两个；&lt;br/&gt;如果strIndex!=str.length时，分为以下三种情况：&lt;br/&gt;1.strIndex，patternIndex+2；（str != pattern时）&lt;br/&gt;2.strIndex+1，patternIndex+2；（str = pattern 时 或者 此时pattern == ‘.’）&lt;br/&gt;3.strIndex+1，patternIndex；(str == pattern 而且 str+1 也 == pattern)&lt;br/&gt;2.当patternIndex后一位不为‘&lt;/em&gt;’&lt;br/&gt;此时如果strIndex = str.length return false；&lt;br/&gt;如果 str = pattern 则 str+1，pattern+1&lt;br/&gt;反之 return false；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean match(char[] str, char[] pattern)
    {
        //1.边缘检测
        if(str==null||pattern==null) return false;
        int strIndex=0,patternIndex=0;
        return matchCore(str,pattern,strIndex,patternIndex);
    } 
    public boolean matchCore(char[] str,char[] pattern,int strIndex,int patternIndex){
        if(strIndex == str.length &amp;amp;&amp;amp; patternIndex == pattern.length) return true;
        if(strIndex != str.length &amp;amp;&amp;amp; patternIndex == pattern.length) return false;
        //当模式中第二个字符是‘*’
        if(patternIndex+1 &amp;lt; pattern.length &amp;amp;&amp;amp; pattern[patternIndex +1] == '*'){
            //一定注意这里strIndex有可能是str.length 需要把str[strIndex]放在后面，以免溢出
            if(strIndex != str.length &amp;amp;&amp;amp; (pattern[patternIndex] == '.' || str[strIndex] == pattern[patternIndex])){
                return matchCore(str,pattern,strIndex+1,patternIndex) || matchCore(str,pattern,strIndex+1,patternIndex+2) || matchCore(str,pattern,strIndex,patternIndex+2);
            }else{
                return matchCore(str,pattern,strIndex,patternIndex+2);
            }     
        }else{//模式中第二个字符不是’*‘
            if(strIndex != str.length &amp;amp;&amp;amp; (str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == '.'))
                return matchCore(str,pattern,strIndex+1,patternIndex+1);
            else
                return false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表示数值的字符串&quot;&gt;==53.表示数值的字符串==&lt;/h3&gt;
&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析：数值可以表示为&quot;A+'.'+B+'E/e'+C&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中A为带符号整数，可以为空&lt;/li&gt;
&lt;li&gt;B为不带符号整数，可以为空&lt;/li&gt;
&lt;li&gt;A和B不能同时为空&lt;/li&gt;
&lt;li&gt;C为带符号整数，不能为空&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Solution {
    //声明一个全局变量，记录小数点前是否有数字
    boolean hasInt = false;
    public boolean isNumeric(char[] str) {
        if(str == null || str.length == 0) return false;
        return scanA(str,0);
    }
    //第一部分：为带符号整数，后续字符串可包括'./e/E'
    public boolean scanA(char[] str,int index){
        //1.如果有符号则跳过。
        if(str[index] == '-' || str[index] == '+') index++;
        while(index &amp;lt; str.length &amp;amp;&amp;amp; str[index]-'0' &amp;lt;= 9 &amp;amp;&amp;amp; str[index]-'0' &amp;gt;= 0){
            hasInt = true;
            index++;
        }
        if(index == str.length) return hasInt;
        if(str[index] == '.')
            return scanB(str,index+1);
        else if(str[index] == 'e'||str[index]=='E')
            return scanC(str,index+1);
        else
            return false;
    }
    //第二部分:为不带符号整数,后续字符可带'e/E'
    public boolean scanB(char[] str,int index){
        boolean hasNum = false;
        //用于判断是否是“12.”这种数字
        if(index == str.length) return hasInt || hasNum;
        while(index &amp;lt; str.length &amp;amp;&amp;amp; str[index]-'0' &amp;lt;= 9 &amp;amp;&amp;amp; str[index]-'0' &amp;gt;= 0){
            index++;
            hasNum = true;
        }
        if(index == str.length) return hasInt || hasNum;
        if(str[index] == 'e' || str[index] == 'E')
            return (hasInt || hasNum) &amp;amp;&amp;amp; scanC(str,index+1);
        else
            return false;
    }
    //第三部分：为带符号整数
    public boolean scanC(char[] str,int index){
        //用于判断是否为“12e”这样的数字，这种是不正确的，第三部分不能为空
        if(index == str.length) return false;
        boolean hasNum = false;
        //如果有符号，则跳过
        if(str[index]=='+'||str[index]=='-') index++;
        while(index &amp;lt; str.length &amp;amp;&amp;amp; str[index]-'0' &amp;lt;= 9 &amp;amp;&amp;amp; str[index]-'0' &amp;gt;= 0){
            hasNum=true;
            index++;
        }  
        if(index == str.length) return hasNum;
        else return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符流中第一个不重复的字符&quot;&gt;54.字符流中第一个不重复的字符&lt;/h3&gt;
&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。&lt;/p&gt;
&lt;p&gt;输出描述:&lt;/p&gt;
&lt;p&gt;如果当前字符流没有存在出现一次的字符，返回#字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.HashSet;
public class Solution {
    ArrayList&amp;lt;Character&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    HashSet&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    //Insert one char from stringstream
    public void Insert(char ch)
    {
        if(!set.contains(ch))
            if(list.contains(ch)){
                //注意这里之所以将char转换为Character对象，是因为，如果直接带入char
                //函数会将char转变成ASCII码int值作为索引，会导致溢出。
                list.remove((Character)ch);
                set.add(ch);
            }else{
                list.add(ch);
            }
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        if(list.size() &amp;gt; 0)
            return list.get(0);
        else
            return '#';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;链表中的入口结点&quot;&gt;55.链表中的入口结点&lt;/h3&gt;
&lt;p&gt;一个链表中包含环，请找出该链表的环的入口结点。&lt;br/&gt;&lt;strong&gt;方法一：使用辅助Set集合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
import java.util.HashSet;
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        if(pHead == null) return null;
        HashSet&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        while(!set.contains(pHead)){
            if(pHead.next == null) return null;
            set.add(pHead);
            pHead = pHead.next;
        }
        return pHead;
            
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法二：单纯指针操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        if(pHead == null) return null;
        ListNode p1=pHead,p2=pHead.next;
        //第一步：如果有环，则算出环的长度；
        while(p1 != p2 &amp;amp;&amp;amp; p2 != null){
            p1 = p1.next;
            p2 = p2.next;
            if(p2 == null) return null;
            p2 = p2.next;
        }
        if(p2 == null) return null;
        int count = 1;
        while(p1.next != p2){
            p1 = p1.next;
            count++;
        }
        //第二步：找到环的入口
        p1 = pHead;
        p2 = pHead;
        while(count-- &amp;gt; 0)
            p2 = p2.next;
        while(p1!=p2){
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;     
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除链表中重复的结点这道题纠结了很久很简单的递归就能实现有点类似于动态规划&quot;&gt;56.删除链表中重复的结点&lt;strong&gt;这道题纠结了很久！！！很简单的递归就能实现，有点类似于动态规划&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if(pHead == null || pHead.next == null)
            return pHead;
        if(pHead.val == pHead.next.val){
          while(pHead.next != null &amp;amp;&amp;amp; pHead.val == pHead.next.val)
              pHead = pHead.next;
          return deleteDuplication(pHead.next);
        }
        pHead.next = deleteDuplication(pHead.next);
        return pHead;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉树的下一个结点&quot;&gt;57.二叉树的下一个结点&lt;/h3&gt;
&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode == null) return null;
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null)
                node = node.left;
            return node;
        }
        while(pNode.next != null){
            if(pNode.next.right != pNode)
                return pNode.next;
            pNode = pNode.next;
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对称的二叉树&quot;&gt;58.对称的二叉树&lt;/h3&gt;
&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        return isSymmetrical(pRoot,pRoot);
    }
    public boolean isSymmetrical(TreeNode n1,TreeNode n2){
        if(n1 == null &amp;amp;&amp;amp; n2 == null) return true;
        if(n1 == null || n2 == null) return false;
        if(n1.val != n2.val) return false;
        return isSymmetrical(n1.left,n2.right) &amp;amp;&amp;amp; isSymmetrical(n1.right,n2.left);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;之字形打印二叉树&quot;&gt;59.==之字形打印二叉树==&lt;/h3&gt;
&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;br/&gt;&lt;strong&gt;解题思路：参见《剑指offer》p176，使用两个辅助栈进行操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; Print(TreeNode pRoot) {
        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if(pRoot == null) return result;
        int layer = 1;
        Stack&amp;lt;TreeNode&amp;gt; odd = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;TreeNode&amp;gt; even = new Stack&amp;lt;&amp;gt;();
        odd.push(pRoot);
        while(!odd.empty()||!even.empty()){
            ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            if((layer &amp;amp; 1) == 1){//位运算，判断是否为奇数;等价于layer%2
                while(!odd.empty()){
                    TreeNode node = odd.pop();
                    list.add(node.val);
                    if(node.left != null) even.push(node.left);
                    if(node.right != null) even.push(node.right);
                }
            }else{
                while(!even.empty()){
                    TreeNode node = even.pop();
                    list.add(node.val);
                    if(node.right != null) odd.push(node.right);
                    if(node.left != null) odd.push(node.left);
                }
            }
            result.add(list);
            layer++;   
        }
        return result;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;把二叉树打印成多行&quot;&gt;60.把二叉树打印成多行&lt;/h3&gt;
&lt;p&gt;从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。&lt;br/&gt;&lt;strong&gt;注意要使用isEmpty()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
import java.util.LinkedList;
public class Solution {
    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; Print(TreeNode pRoot) {
        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if(pRoot == null) return result;
        LinkedList&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        queue.offer(pRoot);//将根节点加入队列
        int elementsCount = 1;//用于记录每一层的元素个数
        while(!queue.isEmpty()){//注意LinkedList 是没有 enpty()方法的。
            TreeNode node = queue.poll();
            elementsCount--;
            list.add(node.val);
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
            if(elementsCount == 0){
                result.add(list);
                list = new ArrayList&amp;lt;&amp;gt;();
                elementsCount = queue.size();
            }
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;序列化二叉树&quot;&gt;61.序列化二叉树&lt;/h3&gt;
&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    String Serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        if(root == null)
            sb.append(&quot;$,&quot;);
        else{
            sb.append(root.val+&quot;,&quot;);
            sb.append(Serialize(root.left));
            sb.append(Serialize(root.right));
        }
        return sb.toString();
  }
    int index = -1;
    TreeNode Deserialize(String str) {
        if(str == null || str == &quot;&quot;) return null;
        String[] strArray = str.split(&quot;,&quot;);
        if(strArray.length == 0) return null;
        return DeserializeCore(strArray);
   }
    TreeNode DeserializeCore(String[] strArray){     
        TreeNode node = null;
        index++;
        if(!strArray[index].equals(&quot;$&quot;)){
            node = new TreeNode(Integer.parseInt(strArray[index]));
            node.left = DeserializeCore(strArray);
            node.right = DeserializeCore(strArray);
        }
        return node;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二叉搜索树的第k个结点&quot;&gt;62.二叉搜索树的第K个结点&lt;/h3&gt;
&lt;p&gt;给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。(换句话说，从小到大排列，第k个数字)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.ArrayList;
public class Solution {
    ArrayList&amp;lt;TreeNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(k &amp;lt; 1 || pRoot == null) return null;
        LDR(pRoot);
        if(list.size() &amp;lt; k) return null;
        return list.get(k-1);
    }
    
    void LDR(TreeNode pRoot){
        if(pRoot.left != null)
            LDR(pRoot.left);
        list.add(pRoot);
        if(pRoot.right!=null)
            LDR(pRoot.right);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据流中的中位数&quot;&gt;63.数据流中的中位数&lt;/h3&gt;
&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目解析：如果直接使用ArrayList每次进行排序再选取中位数的话，时间复杂度为O(n^2logn),每一次排序O(nlogn)，共进行N次排序；而使用最大堆、最小堆操作，每次插入数据，取出数据均占用O（logn）的时间，所以总共占用时间复杂度为O(NlogN)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
    PriorityQueue&amp;lt;Integer&amp;gt; minHeap = new PriorityQueue&amp;lt;&amp;gt;();
    PriorityQueue&amp;lt;Integer&amp;gt; maxHeap = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;(){
        @Override
        public int compare(Integer i1,Integer i2){
            return i2-i1;
        }
    });
    public void Insert(Integer num) {
        minHeap.offer(num);
        if(minHeap.size()&amp;gt;maxHeap.size()){
            maxHeap.offer(minHeap.poll());
        }else{
            maxHeap.offer(minHeap.poll());
            minHeap.offer(maxHeap.poll());
        }
    }
    public Double GetMedian() {
        if(minHeap.size()==0&amp;amp;&amp;amp;maxHeap.size()==0)
            return null;
        if(minHeap.size() == maxHeap.size())
            return (double)(minHeap.peek()+maxHeap.peek())/2.0;
        return (double)maxHeap.peek();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;滑动窗口的最大值&quot;&gt;64.滑动窗口的最大值&lt;/h3&gt;
&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.LinkedList; 
import java.util.ArrayList;
public class Solution {
    public ArrayList&amp;lt;Integer&amp;gt; maxInWindows(int [] num, int size)
    {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if(num.length&amp;lt;1||size&amp;lt;1||size&amp;gt;num.length)
            return result;
        LinkedList&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;();
        for(int i = 0;i&amp;lt;num.length;i++){
            while(!deque.isEmpty() &amp;amp;&amp;amp; num[deque.peekLast()] &amp;lt;= num[i])
                deque.pollLast();
            deque.offerLast(i);
            if(i&amp;gt;=size-1){
                while(i-deque.peekFirst()&amp;gt;size-1)
                    deque.pollFirst();
                result.add(num[deque.peekFirst()]);
            }
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;矩阵中的路径&quot;&gt;65.矩阵中的路径&lt;/h3&gt;
&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {    
        if(matrix == null || rows&amp;lt;1 || cols&amp;lt;1 || str == null) return false;
        boolean[][] visited = new boolean[rows][cols];
        int pathLength = 0;
        for(int row = 0;row&amp;lt;rows;row++)
            for(int col = 0 ;col&amp;lt;cols;col++){
                if(hasPathCore(matrix,rows,cols,row,col,str,visited,pathLength))
                    return true;
            }
        return false;
    }
    public boolean hasPathCore(char[] matrix,int rows,int cols,int row,int col,char[] str,boolean[][] visited,int pathLength){
        if(pathLength == str.length) return true;
        boolean hasPath = false;
        if(row&amp;gt;=0 &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;lt;cols &amp;amp;&amp;amp; visited[row][col]==false &amp;amp;&amp;amp; matrix[row*cols+col] == str[pathLength]){
            pathLength++;
            visited[row][col] = true;
            hasPath = hasPathCore(matrix,rows,cols,row+1,col,str,visited,pathLength)
                ||hasPathCore(matrix,rows,cols,row-1,col,str,visited,pathLength)
                ||hasPathCore(matrix,rows,cols,row,col+1,str,visited,pathLength)
                ||hasPathCore(matrix,rows,cols,row,col-1,str,visited,pathLength);
            if(!hasPath){
                pathLength--;
                visited[row][col] = false;
            }     
        }
        return hasPath;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;机器人的运动范围&quot;&gt;66.机器人的运动范围&lt;/h3&gt;
&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
    public int movingCount(int threshold, int rows, int cols) {
        if (threshold &amp;lt; 1 || rows &amp;lt; 1 || cols &amp;lt; 1) return 0;
        boolean[][] visited = new boolean[rows][cols];
        return movingCountCore(threshold, 0, 0, rows, cols, visited);

    }

    public int movingCountCore(int threshold, int row, int col, int rows, int cols, boolean[][] visited) {
        int count = 0;
        if (check(threshold, row, col, rows, cols, visited)) {
            visited[row][col] = true;
            count = 1 + movingCountCore(threshold, row + 1, col, rows, cols, visited)
                    + movingCountCore(threshold, row - 1, col, rows, cols, visited)
                    + movingCountCore(threshold, row, col + 1, rows, cols, visited)
                    + movingCountCore(threshold, row, col - 1, rows, cols, visited);
        }
        return count;

    }

    public boolean check(int threshold, int row, int col, int rows, int cols, boolean[][] visited) {
        if (row &amp;lt; 0 || col &amp;lt; 0 || row &amp;gt;= rows || col &amp;gt;= cols || visited[row][col])
            return false;
        int num = 0;
        while (col != 0 || row != 0) {
            num += col % 10;
            num += row % 10;
            col /= 10;
            row /= 10;
        }
        if (num &amp;gt; threshold)
            return false;
        return true;
    }

}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 26 Apr 2018 14:24:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8955372.html</dc:identifier>
</item>
</channel>
</rss>