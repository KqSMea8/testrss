<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>相似图像搜图全过程 - 张居斜</title>
<link>http://www.cnblogs.com/yaolin1228/p/9557588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaolin1228/p/9557588.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近完成了一个以图搜图的项目，项目总共用时三个多月。记录一下项目中用到机器学习的地方，以及各种踩过的坑。总的来说，项目分为一下几个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347106&quot;&gt;一、训练目标函数 &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347107&quot;&gt;&lt;span&gt;1、    设定基础模型&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347108&quot;&gt;&lt;span&gt;2、    添加新层&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347109&quot;&gt;&lt;span&gt;3、    冻结 base 层&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347110&quot;&gt;&lt;span&gt;4、    编译模型&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347111&quot;&gt;&lt;span&gt;5、    训练&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347112&quot;&gt;&lt;span&gt;6、    保存模型&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347113&quot;&gt;&lt;span&gt;二、特征提取&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347114&quot;&gt;&lt;span&gt;三、创建索引&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347115&quot;&gt;&lt;span&gt;四、构建服务&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347116&quot;&gt;&lt;span&gt;1、flask 开发 &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347117&quot;&gt;&lt;span&gt;2、Gunicorn 异步，增加服务稳健性&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347118&quot;&gt;&lt;span&gt;3、Supervisor 部署监控服务&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yaolin1228/p/9557588.html#_Toc523347119&quot;&gt;&lt;span&gt;五、总结  &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;项目是在预训练模型&lt;/span&gt; &lt;span&gt;vgg16&lt;/span&gt; &lt;span&gt;的基础上进行微调（&lt;/span&gt;&lt;span&gt;fine_tune)&lt;/span&gt;&lt;span&gt;，并将特征的维度从原先的&lt;/span&gt; &lt;span&gt;2048&lt;/span&gt; &lt;span&gt;维降为&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt; &lt;span&gt;维度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;模型的微调又分为以下几个步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、设定基础模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本次采用预训练的 VGG16基础模型，利用其 bottleneck 特征&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;#&lt;/span&gt; &lt;span&gt;设定基础模型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;base_model &lt;span&gt;&lt;strong&gt;=&lt;/strong&gt; &lt;span&gt;VGG16&lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;span&gt;weights&lt;span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;'./model/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'&lt;span&gt;&lt;strong&gt;,&lt;/strong&gt; &lt;span&gt;include_top&lt;span&gt;&lt;strong&gt;=&lt;span&gt;False&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; #指定权重路径&lt;/p&gt;
&lt;p&gt;# include_top= False 不加载三层全连接层&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、添加新层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将自己要目标图片，简单分类，统计类别（在训练模型时需要指定类别）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt; &lt;span&gt;添加新层&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_new_last_layer(base_model, nb_classes):

    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    添加最后的层
    :param base_model: 预训练模型
    :param nb_classes: 分类数量
    :return: 新的 model
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;=&lt;span&gt; base_model.output
    x &lt;/span&gt;=&lt;span&gt; GlobalAveragePooling2D()(x)
    x &lt;/span&gt;= Dense(128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)(x) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出的特征维度 88&lt;/span&gt;
    predictions = Dense(nb_classes, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)
    model &lt;/span&gt;= Model(input=base_model.input, output=&lt;span&gt;predictions)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; model
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3、冻结 base 层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前的参数可以使用预训练好的参数，不需要重新训练，所以需要冻结，不让其改变。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; freeze_base_layer(model, base_model):

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; base_model.layers:

        layer.trainable &lt;/span&gt;= False
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt; 4、编译模型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
model.compile(optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rmsprop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, metrics= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; optimizer: 优化器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; loss: 损失函数，多类的对数损失需要将分类标签转换为（将标签转化为形如(nb_samples, nb_classes)的二值序列）&lt;/span&gt;
&lt;span&gt;
# metrics: 列表，包含评估模型在训练和测试时的网络性能的指标准备训练数据。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、训练&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据准备&lt;/span&gt;&lt;span&gt;
IM_WIDTH, IM_HEIGHT &lt;/span&gt;= 224,224&lt;span&gt;
train_dir &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./refine_img_data/train&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
val_dir &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./refine_img_data/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
nb_classes &lt;/span&gt;= 5&lt;span&gt;
np_epoch &lt;/span&gt;= 3&lt;span&gt;
batch_size &lt;/span&gt;= 16&lt;span&gt;
nb_train_samples &lt;/span&gt;=&lt;span&gt; get_nb_files(train_dir)
nb_classes &lt;/span&gt;= len(glob.glob(train_dir + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
nb_val_samples &lt;/span&gt;=&lt;span&gt; get_nb_files(val_dir)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据现有数据，设置新数据生成参数&lt;/span&gt;&lt;span&gt;
train_datagen &lt;/span&gt;=&lt;span&gt; ImageDataGenerator(
preprocessing_function&lt;/span&gt;=&lt;span&gt;preprocess_input,
rotation_range&lt;/span&gt;=30&lt;span&gt;,
width_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
height_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
shear_range&lt;/span&gt;=0.2&lt;span&gt;,
zoom_range&lt;/span&gt;=0.2&lt;span&gt;,
horizontal_flip&lt;/span&gt;=&lt;span&gt;True
)

test_datagen &lt;/span&gt;=&lt;span&gt; ImageDataGenerator(
preprocessing_function&lt;/span&gt;=&lt;span&gt;preprocess_input,
rotation_range&lt;/span&gt;=30&lt;span&gt;,
width_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
height_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
shear_range&lt;/span&gt;=0.2&lt;span&gt;,
zoom_range&lt;/span&gt;=0.2&lt;span&gt;,
horizontal_flip&lt;/span&gt;=&lt;span&gt;True
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文件夹获取数据&lt;/span&gt;&lt;span&gt;
train_generator &lt;/span&gt;=&lt;span&gt; train_datagen.flow_from_directory(
train_dir,
target_size&lt;/span&gt;=&lt;span&gt;(IM_WIDTH, IM_HEIGHT),
batch_size&lt;/span&gt;=&lt;span&gt;batch_size,
class_mode&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

validation_generator &lt;/span&gt;=&lt;span&gt; test_datagen.flow_from_directory(
val_dir,
target_size&lt;/span&gt;=&lt;span&gt;(IM_WIDTH, IM_HEIGHT),
batch_size&lt;/span&gt;=&lt;span&gt;batch_size,
class_mode&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练&lt;/span&gt;&lt;span&gt;
history_t1 &lt;/span&gt;=&lt;span&gt; model.fit_generator(
train_generator,
epochs&lt;/span&gt;=1&lt;span&gt;,
steps_per_epoch&lt;/span&gt;=10&lt;span&gt;,
validation_data&lt;/span&gt;=&lt;span&gt;validation_generator,
validation_steps&lt;/span&gt;=10&lt;span&gt;,
class_weight&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;6、保存模型&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将模型保存到指定路径一般保存为&lt;/span&gt; &lt;span&gt;.h5&lt;/span&gt; &lt;span&gt;格式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 model.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/model/test_model.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;加载我们训练好的模型，根据需要，取指定层的特征。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可用 model.summary() 查看模型结构&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据模型提取图片特征&lt;/span&gt;
&lt;span&gt;
target_size &lt;/span&gt;= (224,224&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_feature(mod, path):
    img &lt;/span&gt;= image.load_img(path,target_size=&lt;span&gt;target_size)
    img &lt;/span&gt;=&lt;span&gt; image.img_to_array(img)
    img &lt;/span&gt;= np.expand_dims(img, axis=&lt;span&gt;0)
    img &lt;/span&gt;=&lt;span&gt; preprocess_input(img)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mod.predict(img)

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建模型，获取指定层特征&lt;/span&gt;&lt;span&gt;
model_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./model/my_model.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
base_model &lt;/span&gt;=&lt;span&gt; load_model(model_path)
model &lt;/span&gt;= Model(inputs=base_model.input, outputs=base_model.get_layer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dense_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).output)

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取特征&lt;/span&gt;&lt;span&gt;
img_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./my_img/bus.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
feat &lt;/span&gt;= my_feature(model,img_path) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; shape 为 (1,128)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(feat)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(feat.shape)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意， 当需要提取的图片特征数量较大，比如千万以上，需要的时间是比较长的，这时我们可以采用多核与批处理来进行 (python 由于 GIL 的问题对多线程不友好)。&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pre_processs_image(path):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; path &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; os.path.exists(path) &lt;span&gt;and&lt;/span&gt; len(path) &amp;gt; 10&lt;span&gt;:
    　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        　　img &lt;/span&gt;=&lt;span&gt; cv2.imread(path, cv2.IMREAD_COLOR)
        　　img &lt;/span&gt;= cv2.resize(img, (224, 224&lt;span&gt;))
       　　 img &lt;/span&gt;=&lt;span&gt; cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
       　　 img &lt;/span&gt;= img.transpose(2, 0, 1&lt;span&gt;)
       　　 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [material_id,img, flag]
   　　 &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as err:
        　　traceback.print_exc()
       　　 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
   　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
　　　　logging.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;could not find path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; path)
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;cpu 部分，调用多核处理函数，指定核数为 20&lt;/span&gt;&lt;span&gt;
with ProcessPoolExecutor(max_workers&lt;/span&gt;=20&lt;span&gt;) as executor:
feat_paras &lt;/span&gt;=&lt;span&gt; list(executor.map(pre_processs_image，, material_batch))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; GPU 部分采用批处理&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;此处我们使用 Facebook 开源的近邻索引框架 faiss 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; create index&lt;/span&gt;&lt;span&gt;
d &lt;/span&gt;= 128&lt;span&gt;
nlist &lt;/span&gt;= 100 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切分数量&lt;/span&gt;&lt;span&gt;
nprobe &lt;/span&gt;= 8 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次查找分片数量&lt;/span&gt;&lt;span&gt;
quantizer_img &lt;/span&gt;= faiss.IndexFlatL2(d) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据欧式距离创建索引&lt;/span&gt;
&lt;span&gt;
 
image_index &lt;/span&gt;=&lt;span&gt; None
model_index &lt;/span&gt;=&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; image_feat_array &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; len(img_feat_list) &amp;gt; 100&lt;span&gt;:
　　image_index &lt;/span&gt;=&lt;span&gt; faiss.IndexIVFFlat(quantizer_img, d, nlist, faiss.METRIC_L2)
　　image_index.train(image_feat_array)
　　image_index.add_with_ids(image_feat_array,image_id_array)
　　image_index.nprobe &lt;/span&gt;=&lt;span&gt; nprobe
　　image_index.dont_dealloc_me &lt;/span&gt;=&lt;span&gt; quantizer_img

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存当前索引到指定路径&lt;/span&gt;&lt;span&gt;
faiss.write_index(img_index,path)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试当前索引&lt;/span&gt;&lt;span&gt;
temp_feat &lt;/span&gt;= img_feat_list[1&lt;span&gt;]
res_2 &lt;/span&gt;= image_index.search(temp_feat, k=5&lt;span&gt;)
logging.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image search result is:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(res_2))
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;参考文档 http://docs.jinkan.org/docs/flask/quickstart.html#a-minimal-application&lt;/p&gt;
&lt;h2&gt;2、Gunicorn 异步，增加服务稳健性&lt;/h2&gt;
&lt;p&gt;基础语法：&lt;/p&gt;
&lt;p&gt;Gunicorn –w process_num –b ip:port –k 'gevent' fileName：app&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt; &lt;span&gt;注意：此处不选择&lt;/span&gt; &lt;span&gt;–k 'gevent'&lt;/span&gt; &lt;span&gt;则为同步运行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;同步部署：&lt;/p&gt;
&lt;p&gt;gunicorn -b 0.0.0.0:9090 my_service:app&lt;/p&gt;

&lt;p&gt;&lt;span&gt;异步部署：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gunicorn -b 0.0.0.0:9090 -k gevent my_service:app&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用了 Gunicorn 来部署应用后， 对比 flask , qps 提升了一倍。原 flask 框架中由于我的接口中 request 了其他的接口，线程在此处会阻塞，导致程序非常容易假死。改用后，稳定又了极大的提升。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3、Supervisor 部署监控服务&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可参考以下文档 https://www.cnblogs.com/gjack/p/8076419.html&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;项目到这个地方，基本的服务框架已经有了。许多地方只说了大体思路，但是结构是完整。文中的许多用了许多方法工具，如 gunicorn 的异步等， 但是原理却不甚了解，还需要花功夫去学习。由于上线压力大，时间紧，许多地方来不及仔细琢磨，肯定有不少纰漏，后面再查漏补缺吧。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 15:14:00 +0000</pubDate>
<dc:creator>张居斜</dc:creator>
<og:description>最近完成了一个以图搜图的项目，项目总共用时三个多月。记录一下项目中用到机器学习的地方，以及各种踩过的坑。总的来说，项目分为一下几个部分： 一、训练目标函数 1、 设定基础模型 2、 添加新层 3、 冻</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaolin1228/p/9557588.html</dc:identifier>
</item>
<item>
<title>Java 多线程（四）之守护线程（Daemon） - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9557507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9557507.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;Java 中有两种线程： 一种是用户线程（User Thread），一种是守护线程（Daemon Thread）。&lt;/p&gt;
&lt;p&gt;守护线程是一种特殊的线程， 它的特殊有“陪伴”的含义， 当线程中不存在非守护线程时， 则守护线程自动销毁。&lt;/p&gt;
&lt;p&gt;垃圾回收线程就是一种守护线程， 当线程中没有非守护线程了， 则垃圾回收线程就会自动销毁。&lt;/p&gt;
&lt;p&gt;因此， 守护线程的作用就是为其他非守护线程的线程服务， 当非守护线程不存在时， 其自然就没有存在的必要了。&lt;/p&gt;
&lt;h2 id=&quot;如何创建&quot;&gt;如何创建&lt;/h2&gt;
&lt;p&gt;创建过程与一般的线程一样， 只需要在创建完之后调用如下函数即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setDaemon(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;判断&quot;&gt;判断&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean isDaemon() {
    return daemon;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过该函数判定一个线程是否为守护线程。&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;函数setdaemontrue必须在-start-函数之前使用&quot;&gt;函数setDaemon(true)必须在 start() 函数之前使用。&lt;/h3&gt;
&lt;p&gt;如 setDaemon(true) 在 start() 之后， 就会抛异常。如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180829225331435?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;报错信息&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说， 在线程运行之后， 其类型（守护与否）就已经确定了， 无法更改。&lt;/p&gt;
&lt;h3 id=&quot;守护线程中产生的线程也是守护线程&quot;&gt;守护线程中产生的线程也是守护线程；&lt;/h3&gt;
&lt;p&gt;在 Thread 的 init() 函数中， 可以看到这么一句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.daemon = parent.isDaemon();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;创建一个线程类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class PrimeThread extends Thread {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
        try {
            int i = 0;
            while(true) {
                Thread.sleep(500);
                System.out.println(&quot;Current i = &quot; + (i++));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    PrimeThread primeThread = new PrimeThread();
    primeThread.setDaemon(true);
    primeThread.start();

    try {
        Thread.sleep(3000L);
        System.out.println(&quot;Main 函数准备结束了， 守护线程也机会停止， 不打印&quot;);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018082922540166?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果中， Main 函数的线程结束后， primeThread 线程也随之结束了。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 14:58:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>定义 Java 中有两种线程： 一种是用户线程（User Thread），一种是守护线程（Daemon Thread）。 守护线程是一种特殊的线程， 它的特殊有“陪伴”的含义， 当线程中不存在非守护线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9557507.html</dc:identifier>
</item>
<item>
<title>补习系列-springboot 单元测试之道 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9557405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9557405.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;了解 单元测试的背景&lt;/li&gt;
&lt;li&gt;了解如何 利用 springboot 实现接口的测试&lt;/li&gt;
&lt;li&gt;了解如何 利用 mokito 做代码的 mock&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一about-单元测试&quot;&gt;一、About 单元测试&lt;/h2&gt;
&lt;p&gt;单元测试其实是一种廉价的技术，是由开发者创建运行测试代码，用于对程序模块(软件设计的最小单位)进行正确性检验的一种做法。&lt;br/&gt;而所谓的最小单元，就是指应用的最小可测试部件。 在面向对象领域，最小单元对应于类的某个成员方法。&lt;/p&gt;
&lt;p&gt;通常意义的单元测试会用于验证某场景、某条件下某方法的行为结果，举个例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我想验证&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Equals 方法，在两个对象类型不一致时应该返回 false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试的初衷，是对各个相互独立，互不影响的基本单元基线测试，以此来保证核心代码的质量。&lt;/p&gt;
&lt;p&gt;每一段单元测试代码，都一定会&lt;strong&gt;包含几个部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Arrange&lt;br/&gt;用于初始化一些被测试方法需要的参数或依赖的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Act方法&lt;br/&gt;用于调用被测方法进行测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Assert&lt;br/&gt;用于验证测试方法是否按期望执行或者结果是否符合期望值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;See ！并不是很复杂，可是大多数开发者并不喜欢做单元测试。&lt;br/&gt;而且，有一个现象很有意思，水平越高的程序员，越不喜欢写测试代码，why?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“ 因为单元测试，主要是用来防低级程序员挖坑的啊 ”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话不是我说的，但却代表了相当一部分程序员的心声..&lt;/p&gt;
&lt;p&gt;那么，单元测试到底要不要做，并不是本文要讨论的问题。&lt;br/&gt;建议大家阅读下 《单元测试之道-Java版本》 (程序员修炼三部曲系列)这边书，看完后再做出自己的理解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为了测试一座桥梁，不应该只在晴朗的天气，开一辆汽车从桥中间穿过，就认为已经完成了对桥梁的测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二about-junit&quot;&gt;二、About Junit&lt;/h2&gt;
&lt;p&gt;接下来，要说一说 Junit框架，这个是最流行的Java 单元测试框架。&lt;br/&gt;Junit 创建者是 Kent Beck和Erich Gamma，自其出现以来，Junit 生态圈已经非常庞大。&lt;br/&gt;大量的应用程序、开发框架都以 Junit 作为标准的的基础测试组件，这当然也包括 Spring系列的框架。&lt;/p&gt;
&lt;p&gt;一个典型的Junit单元测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class StandardTests {

    @BeforeClass
    static void initAll() {
    }

    @Before
    void init() {
    }

    @Test
    void justTest() {
    ...
    assertTrue(...)
    }

    
    @After
    void tearDown() {
    }

    @AfterClass
    static void tearDownAll() {
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@BeforeClass&lt;/td&gt;
&lt;td&gt;在当前类测试之前执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@Before&lt;/td&gt;
&lt;td&gt;在每个测试方法之前执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Test&lt;/td&gt;
&lt;td&gt;声明测试方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@After&lt;/td&gt;
&lt;td&gt;在每个测试方法之后执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@AfterClass&lt;/td&gt;
&lt;td&gt;在当前类测试之后执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面的注解还是比较容易理解的，需要注意的只是 @BeforeClass 和 @Before，前者是一个静态方法，&lt;br/&gt;会在整个测试用例类开始前执行，仅一次； 而后者则是在方法测试之前触发，可能会执行多次。&lt;/p&gt;
&lt;p&gt;当前最新的版本是Junit 5 ，有兴趣的可以看看 &lt;strong&gt;&lt;em&gt;https://junit.org/junit5&lt;/em&gt;&lt;/strong&gt; 官网的介绍&lt;/p&gt;
&lt;p&gt;为了更清晰的理解Junit 是怎么运作，下面展示一个源码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    public void runBare() throws Throwable {
        Throwable exception = null;
        setUp();
        try {
            runTest();
        } catch (Throwable running) {
            exception = running;
        } finally {
            try {
                tearDown();
            } catch (Throwable tearingDown) {
                if (exception == null) exception = tearingDown;
            }
        }
        if (exception != null) throw exception;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是早期版本的&lt;strong&gt;TestCase&lt;/strong&gt;类其中的一段实现，与我们所说的思路是基本一致的。&lt;br/&gt;然而，基于注解的实现是由 Junit4提供的，在有兴趣的话可以深入看看源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;br/&gt;TestCase、JUnit4TestAdapter、BlockJUnit4ClassRunner&lt;/p&gt;
&lt;h2 id=&quot;三springboot-单元测试&quot;&gt;三、SpringBoot-单元测试&lt;/h2&gt;
&lt;p&gt;SpringBoot 提供了 &lt;strong&gt;spring-boot-starter-test&lt;/strong&gt; 用于实现单元测试。&lt;/p&gt;
&lt;h3 id=&quot;项目依赖&quot;&gt;项目依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试样例&quot;&gt;测试样例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(classes = DemoBoot.class)
public class RestApiTest {

    private MockMvc mockMvc;

    private ObjectMapper mapper = new ObjectMapper();

    @Autowired
    private WebApplicationContext context;

    @Autowired
    private RestDataManager dataManager;

    private static final String CUSTOMER = &quot;LiLei&quot;;
    private Pet polly;
    private Pet badboy;

    @Before
    public void setupMockMvc() throws Exception {
        mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
        initData();
    }

    private void initData() {
        // 清除原有宠物信息
        dataManager.clearPets(CUSTOMER);

        // 添加新的宠物信息
        polly = new Pet();
        polly.setType(&quot;Bird&quot;);
        polly.setName(&quot;Polly&quot;);
        polly.setDescription(&quot;the rapid speaker&quot;);

        dataManager.addPet(CUSTOMER, polly);

        badboy = new Pet();
        badboy.setType(&quot;Dog&quot;);
        badboy.setName(&quot;BadBoy&quot;);
        polly.setDescription(&quot;the monster&quot;);

        dataManager.addPet(CUSTOMER, badboy);
    }

    @Test
    public void testGet() throws Exception {

        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/rest/pets/{customer}/{petId}&quot;, 
                CUSTOMER, polly.getPetId()))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content()
                       .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(MockMvcResultMatchers.content()
                       .json(mapper.writeValueAsString(polly)))
                .andDo(MockMvcResultHandlers.print());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringRunner&lt;/strong&gt;继承于SpringJUnit4ClassRunner，这是Spring框架基于Junit实现的基础类。&lt;br/&gt;如果还记得前面提到的 &lt;strong&gt;BlockJUnit4ClassRunner&lt;/strong&gt;，应该不难猜到，Spring 的实现类集成了该类。&lt;/p&gt;
&lt;p&gt;那么，SpringRunner 做了什么？ 什么也没有，只是一个名称的修正而已(论命名的重要性)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootTest的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其代码注释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Annotation that can be specified on a test class that runs Spring Boot based tests. 
Provides the following features over and above the regular Spring TestContext Framework: 

1. Uses SpringBootContextLoader as the default ContextLoader when no specific @ContextConfiguration(loader=...) is defined. 
2. Automatically searches for a @SpringBootConfiguration when nested @Configuration is not used, and no explicit classes are specified. 
3. Allows custom Environment properties to be defined using the properties attribute. 
4. Provides support for different webEnvironment modes, including the ability to start a fully running container listening on a defined or random port. 
5. Registers a TestRestTemplate bean for use in web tests that are using a fully running container. 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;默认会使用&lt;strong&gt;SpringBootContextLoader&lt;/strong&gt;类用于上下文加载，&lt;br/&gt;这个类将会使用所配置的SpringBootApplication实体类作为入口，加载配置并初始化Spring上下文环境；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;可以支持自定义的配置，通过 Environment 属性设置；&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持不同的 web 环境模式，可以是固定端口、随机端口、无端口几种模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;br/&gt;SpringRunner、SpringBootTest、SpringBootContextLoader&lt;/p&gt;
&lt;h2 id=&quot;四mock测试&quot;&gt;四、Mock测试&lt;/h2&gt;
&lt;p&gt;Mock 测试的使用场景在于，被测试模块(方法)依赖于外部系统(web服务、中间件或是数据库)时。&lt;br/&gt;我们需要提供一种快速验证本地实现逻辑的策略，那就是 Mock，也称为打桩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201808/242916-20180829223241987-1353696103.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，&lt;strong&gt;A&lt;/strong&gt; 模块依赖于 &lt;strong&gt;B&lt;/strong&gt; 模块，在 &lt;strong&gt;B&lt;/strong&gt; 模块不可达的时候，我们对 依赖接口进行了 Mock。&lt;br/&gt;这样在执行测试时，不需要真实的 B 模块便可完成测试。&lt;/p&gt;
&lt;p&gt;下面我们要用到的 &lt;strong&gt;Mock&lt;/strong&gt; 组件叫 &lt;strong&gt;Mockito&lt;/strong&gt;&lt;br/&gt;springboot-starter-test 自带了对于 mockito 的依赖，下面看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Before
    public void setupMockMvc() throws Exception {

        // 启用mock
       
    @Before
    public void setupMockMvc() throws Exception {

        // 启用mock
        MockitoAnnotations.initMocks(this);

        polly = new Pet();
        polly.setType(&quot;Bird&quot;);
        polly.setName(&quot;Polly&quot;);
        polly.setDescription(&quot;the rapid speaker&quot;);

        lilei = new Customer();
        lilei.setName(CUSTOMER);

        // 设置mock接口
        Mockito.when(dataManager.getPets(Mockito.isA(String.class))).thenReturn(Arrays.asList(polly));
        Mockito.when(dataManager.getCustomer(Mockito.isA(String.class))).thenReturn(lilei);

        // 使用standaloneSetup，指定controller
        // 由于不通过webappliationContext初始化，许多配置不会自动完成，此外bean的初始化方法也不会执行
        mockMvc = MockMvcBuilders.standaloneSetup(controller)
                .setMessageConverters(new MappingJackson2HttpMessageConverter()).build();
    }

        polly = new Pet();
        polly.setType(&quot;Bird&quot;);
        polly.setName(&quot;Polly&quot;);
        polly.setDescription(&quot;the rapid speaker&quot;);

        lilei = new Customer();
        lilei.setName(CUSTOMER);

        // 设置mock接口
        Mockito.when(dataManager.getPets(Mockito.isA(String.class))).thenReturn(Arrays.asList(polly));
        Mockito.when(dataManager.getCustomer(Mockito.isA(String.class))).thenReturn(lilei);

        // 使用standaloneSetup，指定controller
        // 由于不通过webappliationContext初始化，许多配置不会自动完成，此外bean的初始化方法也不会执行
        mockMvc = MockMvcBuilders.standaloneSetup(controller)
                .setMessageConverters(new MappingJackson2HttpMessageConverter()).build();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗，利用 Mockito 可以实现你想要的 Mock效果，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Mockito.when( somemethod ).thenReturn( some thing to return);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，在进行 mock 方法时，需要使用 standaloneSetup 的模式，&lt;br/&gt;否则 mockito 无法工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mockMvc = MockMvcBuilders.standaloneSetup(controller)..&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;br/&gt;Mockito、MockMvcBuilders&lt;/p&gt;
&lt;h2 id=&quot;五最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;细心的读者会发现，前面讲了单元测试的对象，是指软件设计的最小单位(方法)，可是为什么到了 SpringBoot 的部分时&lt;br/&gt;却都是对于API(Controller层)的测试呢？ 到底我们的单元测试应该针对内部实现的某个单元，比如 DAO/Service方法，还是针对接口(API Interface)？&lt;/p&gt;
&lt;p&gt;笔者认为，这点并没有绝对的好坏之分，关键在于取舍。&lt;br/&gt;单元测试是软件工程领域的概念，而软件项目是分很多种类型的，比如在早期的软件工程中，&lt;br/&gt;就有不少的基于C/S架构的程序，这类程序的体积相对庞大，往往需要对大量模块级的方法进行单元测试；&lt;/p&gt;
&lt;p&gt;现如今的微服务体系架构中，对于各个子系统来说，API(作为契约)是必须进行测试的。&lt;br/&gt;对于某服务的单元测试，选择 Controller 还是 Service层，取决于你的成本效益考虑，&lt;/p&gt;
&lt;p&gt;而目前来看，结合&lt;strong&gt;敏捷化的 TDD实践&lt;/strong&gt;、 通过单元测试进行 API测试 已经是一种主流做法。&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 14:32:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 目标 1. 了解 单元测试的背景 2. 了解如何 利用 springboot 实现接口的测试 3. 了解如何 利用 mokito 做代码的 mock 一、About 单元测试 单元测试其实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9557405.html</dc:identifier>
</item>
<item>
<title>Ocelot简易教程之Ocelot是什么 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9557375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9557375.html</guid>
<description>&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9557375.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9557375.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的说Ocelot是一个用.NET Core实现并且开源的API网关技术。&lt;br/&gt;可能你又要问了，什么是API网关技术呢？Ocelot又有什么特别呢？我们又该如何集成到我们的asp.net core程序中呢？&lt;br/&gt;下面我会通过一些列通俗易懂的教程来为大家讲解。今天的这篇文档先给大家简述下什么是API网关技术，以及Ocelot是什么，一个Ocelot的整体架构。&lt;/p&gt;
&lt;h3 id=&quot;api网关是什么&quot;&gt;API网关是什么？&lt;/h3&gt;
&lt;p&gt;API网关是系统暴露在外部的一个访问入口。就像一个公司的门卫承担着寻址、限制进入、安全检查、位置引导、等等功能。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理等等。&lt;br/&gt;API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。&lt;/p&gt;
&lt;h3 id=&quot;ocelot在api网关实现上有什么优点呢&quot;&gt;Ocelot在API网关实现上有什么优点呢？&lt;/h3&gt;
&lt;p&gt;首先，上面已经讲述了Ocelot是一个用.NET Core技术实现并且开源的API网关技术。除此之外还有什么优点呢？那就是它强大的功能以及使用上的简单了。它的功能包括了：路由、请求聚合、服务发现、认证、鉴权、限流熔断、并内置了负载均衡器、Service Fabric、Butterfly Tracing等的集成。而且这些功能都只需要简单的配置即可完成。&lt;br/&gt;目前，腾讯和微软是Ocelot在官网贴出来的客户。&lt;br/&gt;另外，附上Ocelot的开源地址：&lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot; class=&quot;uri&quot;&gt;https://github.com/ThreeMammals/Ocelot&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ocelot工作流程是怎样的呢&quot;&gt;Ocelot工作流程是怎样的呢？&lt;/h3&gt;
&lt;p&gt;实际上Ocelot就是一系列按特定顺序排列的中间件。&lt;br/&gt;Ocelot首先通过配置将HttpRequest对象保存到一个指定的状态直到它到达用来创建HttpRequestMessage对象并将创建的HttpRequestMessage对象发送到下游服务中的请求构造中间件。通过中间件来发出请求是Ocelot管道中做的最后一件事。它不会再调用下一个中间件。下游服务的响应会存储在每个请求 scoped repository中，并作为一个请求返回到Ocelot管道中。有一个中间件将HttpResponseMessage映射到HttpResponse对象并返回给客户端。&lt;br/&gt;接下来是你使用Ocelot是可能会使用的配置。&lt;/p&gt;
&lt;h3 id=&quot;基本集成&quot;&gt;基本集成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180829222057748-1275660609.jpg&quot; alt=&quot;OcelotBasic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用一台web service来host Ocelot，在这里有一个json配置文件，里面设置了所有对当前这个网关的配置。它会接收所有的客户端请求，并路由到对应的下游服务器进行处理，再将请求结果返回。而这个上下游请求的对应关系也被称之为路由。&lt;/p&gt;
&lt;h3 id=&quot;集成-identityserver&quot;&gt;集成 IdentityServer&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180829222057348-1166204389.jpg&quot; alt=&quot;OcelotIndentityServer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们涉及到认证和鉴权的时候，我们可以跟Identity Server进行结合。当网关需要请求认证信息的时候会与Identity Server服务器进行交互来完成。&lt;/p&gt;
&lt;h3 id=&quot;网关集群配置&quot;&gt;网关集群配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180829222056735-726222539.jpg&quot; alt=&quot;OcelotMultipleInstances&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有一个网关是很危险的，也就是我们通常所讲的单点，只要它挂了，所有的服务全挂。这显然无法达到高可用，所以我们也可以部署多台Ocelot网关。当然这个时候在多台网关前，你还需要一台负载均衡器。&lt;/p&gt;
&lt;h3 id=&quot;结合consul服务发现&quot;&gt;结合Consul服务发现&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180829222056241-1572688193.jpg&quot; alt=&quot;OcelotMultipleInstancesConsul (1)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Ocelot已经支持简单的负载功能，也就是当下游服务存在多个结点的时候，Ocelot能够承担起负载均衡的作用。但是它不提供健康检查，服务的注册也只能通过手动在配置文件里面添加完成。这不够灵活并且在一定程度下会有风险。这个时候我们就可以用Consul来做服务发现，它能与Ocelot完美结合。&lt;/p&gt;
&lt;h3 id=&quot;结合service-fabric&quot;&gt;结合Service Fabric&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180829222055631-362589366.jpg&quot; alt=&quot;OcelotServiceFabric&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文首先介绍了API网关的概念，进而引出asp.net core中的一个开源的API网关技术Ocelot。并介绍了Ocelot的优点以及工作原理及架构图。接下来会详细介绍Ocelot如何通过简单地配置实现路由、请求聚合、服务发现、认证、鉴权、限流熔断、并内置了负载均衡器、Service Fabric、Butterfly Tracing等等功能。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 14:25:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文地址：https://www.cnblogs.com/yilezhu/p/9557375.html 简单的说Ocelot是一个用.NET Core实现并且开源的API网关技术。 可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9557375.html</dc:identifier>
</item>
<item>
<title>webpack4.0各个击破（4）—— Javascript &amp; splitChunk - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9545482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9545482.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;作为前端最火的构建工具，是前端自动化工具链&lt;strong&gt;最重要的部分&lt;/strong&gt;，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过&lt;strong&gt;问题 + 解决方式&lt;/strong&gt;的模式，以前端构建中遇到的具体需求为出发点，学习&lt;code&gt;webpack&lt;/code&gt;工具中相应的处理办法。（本篇中的参数配置及使用方式均基于&lt;code&gt;webpack4.0版本&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇摘要：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇主要介绍基于&lt;code&gt;webpack4.0&lt;/code&gt;的&lt;code&gt;splitChunks&lt;/code&gt;分包技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/3f33d17bd04306ab251aa94d7dd05f3e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/802b1e3d9a504a84663aac64ca9a98cc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-js模块化开发&quot;&gt;一. Js模块化开发&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;javascript&lt;/code&gt;之所以需要打包合并，是因为模块化开发的存在。开发阶段我们需要将&lt;code&gt;js&lt;/code&gt;文件分开写在很多零碎的文件中，方便调试和修改，但如果就这样上线，那首页的&lt;code&gt;http&lt;/code&gt;请求数量将直接爆炸。同一个项目，别人2-3个请求就拿到了需要的文件，而你的可能需要20-30个，结果就不用多说了。&lt;/p&gt;
&lt;p&gt;但是合并脚本可不是&lt;em&gt;“把所有的碎片文件都拷贝到一个&lt;code&gt;js&lt;/code&gt;文件里”&lt;/em&gt;这样就能解决的，不仅要解决命名空间冲突的问题，还需要兼容不同的模块化方案，更别提根据模块之间复杂的依赖关系来手动确定模块的加载顺序了，所以利用自动化工具来将开发阶段的&lt;code&gt;js&lt;/code&gt;脚本碎片进行合并和优化是非常有必要的。&lt;/p&gt;
&lt;h2 id=&quot;二.-js文件的一般打包需求&quot;&gt;二. Js文件的一般打包需求&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;代码编译（&lt;code&gt;TS&lt;/code&gt;或&lt;code&gt;ES6&lt;/code&gt;代码的编译）&lt;/li&gt;
&lt;li&gt;脚本合并&lt;/li&gt;
&lt;li&gt;公共模块识别&lt;/li&gt;
&lt;li&gt;代码分割&lt;/li&gt;
&lt;li&gt;代码压缩混淆&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.-使用webpack处理js文件&quot;&gt;三. 使用webpack处理js文件&lt;/h2&gt;
&lt;h3 id=&quot;使用babel转换es6语法&quot;&gt;3.1 使用babel转换ES6+语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;是&lt;code&gt;ES6&lt;/code&gt;语法的转换工具，对&lt;code&gt;babel&lt;/code&gt;不了解的读者可以先阅读&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/000b11aba6ac11e89fc57ca23e93a89f&quot;&gt;《大前端的自动化工厂（3）——Babel》&lt;/a&gt;一文进行了解，&lt;code&gt;babel&lt;/code&gt;与&lt;code&gt;webpack&lt;/code&gt;结合使用的方法也在其中做了介绍，此处仅提供基本配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;...  
module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: [
          {
             loader: 'babel-loader'
          }
        ]
      }
    ]
  },
 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;presets&quot;:[
        [&quot;env&quot;,{
            &quot;targets&quot;:{
                &quot;browsers&quot;:&quot;last 2 versions&quot;
            }
        }
        ]],
    &quot;plugins&quot;: [
         &quot;babel-plugin-transform-runtime&quot; 
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;脚本合并&quot;&gt;3.2 脚本合并&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;webpack&lt;/code&gt;对脚本进行合并是非常方便的，毕竟&lt;strong&gt;模块管理&lt;/strong&gt;和&lt;strong&gt;文件合并&lt;/strong&gt;这两个功能是&lt;code&gt;webpack&lt;/code&gt;最初设计的主要用途，直到涉及到分包和懒加载的话题时才会变得复杂。&lt;code&gt;webpack&lt;/code&gt;使用起来很方便，是因为实现了对各种不同模块规范的兼容处理，对前端开发者来说，理解这种兼容性实现的方式比学习如何配置&lt;code&gt;webpack&lt;/code&gt;更为重要。&lt;code&gt;webpack&lt;/code&gt;默认支持的是&lt;code&gt;CommonJs&lt;/code&gt;规范，但同时为了扩展其使用场景，&lt;code&gt;webpack&lt;/code&gt;在后续的版本迭代中也加入了对&lt;code&gt;ES harmony&lt;/code&gt;等其他规范定义模块的兼容处理，具体的处理方式将在下一章&lt;strong&gt;《webpack4.0各个击破（5）—— Module篇》&lt;/strong&gt;详细分析。&lt;/p&gt;
&lt;h3 id=&quot;公共模块识别&quot;&gt;3.3 公共模块识别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;的输出的文件中可以看到如下的部分：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/******/    function __webpack_require__(moduleId) {
/******/
/******/        // Check if module is in cache
/******/        if(installedModules[moduleId]) {
/******/            return installedModules[moduleId].exports;
/******/        }
/******/        // Create a new module (and put it into the cache)
/******/        var module = installedModules[moduleId] = {
/******/            i: moduleId,
/******/            l: false,
/******/            exports: {}
/******/        };
/******/
/******/        // Execute the module function
/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/        // Flag the module as loaded
/******/        module.l = true;
/******/
/******/        // Return the exports of the module
/******/        return module.exports;
/******/    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;__webpack_require__( )&lt;/code&gt;方法就是&lt;code&gt;webpack&lt;/code&gt;的模块加载器，很容易看出其中对于已加载的模块是有统一的&lt;code&gt;installedModules&lt;/code&gt;对象来管理的，这样就避免了模块重复加载的问题。而公共模块一般也需要从&lt;code&gt;bundle.js&lt;/code&gt;文件中提取出来，这涉及到下一节的“代码分割”的内容。&lt;/p&gt;
&lt;h3 id=&quot;代码分割&quot;&gt;3.4 代码分割&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/73ed4f49dbc761f9794897ba1df8ceac.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为什么要进行代码分割？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码分割最基本的任务是分离出第三方依赖库，因为第三方库的内容可能很久都不会变动，所以用来标记变化的摘要哈希&lt;code&gt;contentHash&lt;/code&gt;也很久不变，这也就意味着我们可以利用本地缓存来避免没有必要的重复打包，并利用浏览器缓存避免冗余的客户端加载。另外当项目发布新版本时，如果第三方依赖的&lt;code&gt;contentHash&lt;/code&gt;没有变化，就可以使用客户端原来的缓存文件（通用的做法一般是给静态资源请求设置一个很大的&lt;code&gt;max-age&lt;/code&gt;），提升访问速度。另外一些场景中，代码分割也可以提供对脚本在整个加载周期内的加载时机的控制能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 代码分割的使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个很常见的例子，比如你在做一个数据可视化类型的网站，引用到了百度的&lt;code&gt;Echarts&lt;/code&gt;作为第三方库来渲染图表，如果你将自己的代码和&lt;code&gt;Echarts&lt;/code&gt;打包在一起生成一个&lt;code&gt;main.bundle.js&lt;/code&gt;文件，这样的结果就是在一个网速欠佳的环境下打开你的网站时，用户可能需要面对很长时间的白屏，你很快就会想到将&lt;code&gt;Echarts&lt;/code&gt;从主文件中剥离出来，让体积较小的主文件先在界面上渲染出一些动画或是提示信息，然后再去加载&lt;code&gt;Echarts&lt;/code&gt;，而分离出的&lt;code&gt;Echarts&lt;/code&gt;也可以从速度更快的&lt;code&gt;CDN&lt;/code&gt;节点获取，如果加载某个体积庞大的库，你也可以选择使用懒加载的方案，将脚本的下载时机延迟到用户真正使用对应的功能之前。这就是一种人工的代码分割。&lt;/p&gt;
&lt;p&gt;从上面的例子整个的生命周期来看，我们将原本一次就可以加载完的脚本拆分为了两次，这无疑会加重服务端的性能开销，毕竟建立TCP连接是一种开销很大的操作，但这样做却可以换来&lt;strong&gt;对渲染节奏的控制和用户体验的提升&lt;/strong&gt;，&lt;strong&gt;异步模块&lt;/strong&gt;和&lt;strong&gt;懒加载模块&lt;/strong&gt;从宏观上来讲实际上都属于&lt;strong&gt;代码分割&lt;/strong&gt;的范畴。&lt;code&gt;code splitting&lt;/code&gt;最极端的状况其实就是拆分成打包前的原貌，也就是&lt;strong&gt;源码直接上线&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 代码分割的本质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/15cd086498b4caba72d85f23522cf8eb.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代码分割的本质，就是在&lt;strong&gt;“源码直接上线”&lt;/strong&gt;和&lt;strong&gt;“打包为唯一的脚本main.bundle.js”&lt;/strong&gt;这两种极端方案之间寻找一种更符合实际场景的中间状态，用可接受的服务器性能压力增加来换取更好的用户体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. 配置代码分割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;code-splitting&lt;/code&gt;技术的配置和使用方法将在下一小节详细描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 更细致的代码分割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的读者可以参考来自google开发者社区的文章&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/&quot;&gt;《Reduce JavaScript Payloads with Code Splitting》&lt;/a&gt;自行研究。&lt;/p&gt;
&lt;h3 id=&quot;代码混淆压缩&quot;&gt;3.5 代码混淆压缩&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack4&lt;/code&gt;中已经内置了&lt;code&gt;UglifyJs&lt;/code&gt;插件，当打包模式参数&lt;code&gt;mode&lt;/code&gt;设置为&lt;code&gt;production&lt;/code&gt;时就会自动开启，当然这不是唯一的选择，&lt;code&gt;babel&lt;/code&gt;的插件中也能提供代码压缩的处理，具体的效果和原理笔者尚未深究，感兴趣的读者可以自行研究。&lt;/p&gt;
&lt;h2 id=&quot;四.-细说splitchunks技术&quot;&gt;四. 细说splitChunks技术&lt;/h2&gt;
&lt;h3 id=&quot;参数说明&quot;&gt;4.1 参数说明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack4&lt;/code&gt;废弃了&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;插件，使用&lt;code&gt;optimization.splitChunks&lt;/code&gt;和&lt;code&gt;optimization.runtimeChunk&lt;/code&gt;来代替，原因可以参考&lt;a href=&quot;https://www.cnblogs.com/wmhuang/p/8967639.html&quot;&gt;《webpack4：连奏中的进化》&lt;/a&gt;一文。关于&lt;code&gt;runtimeChunk&lt;/code&gt;参数，有的文章说是提取出入口chunk中的runtime部分，形成一个单独的文件，由于这部分不常变化，可以利用缓存。google开发者社区的博文是这样描述的：&lt;/p&gt;
&lt;blockquote readability=&quot;4.2377622377622&quot;&gt;
&lt;p&gt; &lt;a href=&quot;https://webpack.js.org/configuration/optimization/#optimization-runtimechunk&quot;&gt;The &lt;code&gt;runtimeChunk&lt;/code&gt; option&lt;/a&gt; is also specified to move &lt;a href=&quot;https://webpack.js.org/concepts/manifest/#runtime&quot;&gt;webpack's runtime&lt;/a&gt; into the &lt;code&gt;vendors&lt;/code&gt; chunk to avoid duplication of it in our app code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;splitChunks&lt;/code&gt;中默认的代码自动分割要求是下面这样的：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;node_modules中的模块或其他被重复引用的模块&lt;/p&gt;
&lt;p&gt;就是说如果引用的模块来自&lt;code&gt;node_modules&lt;/code&gt;,那么只要它被引用，那么满足其他条件时就可以进行自动分割。否则该模块需要被重复引用才继续判断其他条件。（对应的就是下文配置选项中的&lt;code&gt;minChunks&lt;/code&gt;为1或2的场景）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;分离前模块最小体积下限（默认30k，可修改）&lt;/p&gt;
&lt;p&gt;30k是官方给出的默认数值，它是可以修改的，上一节中已经讲过，每一次分包对应的都是服务端的性能开销的增加，所以必须要考虑分包的性价比。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;对于异步模块，生成的公共模块文件不能超出5个（可修改）&lt;/p&gt;
&lt;p&gt;触发了懒加载模块的下载时，并发请求不能超过5个，对于稍微了解过服务端技术的开发者来说，&lt;strong&gt;【高并发】&lt;/strong&gt;和&lt;strong&gt;【压力测试】&lt;/strong&gt;这样的关键词应该不会陌生。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于入口模块，抽离出的公共模块文件不能超出3个（可修改）&lt;/p&gt;
&lt;p&gt;也就是说一个入口文件的最大并行请求默认不得超过3个，原因同上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参数配置&quot;&gt;4.2 参数配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;splitChunks&lt;/code&gt;的在&lt;code&gt;webpack&lt;/code&gt;4.0以上版本中的用法是下面这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async',//默认只作用于异步模块，为`all`时对所有模块生效,`initial`对同步模块有效
      minSize: 30000,//合并前模块文件的体积
      minChunks: 1,//最少被引用次数
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '~',//自动命名连接符
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          minChunks:1,//敲黑板
          priority: -10//优先级更高
        },
        default: {
          test: /[\\/]src[\\/]js[\\/]/
          minChunks: 2,//一般为非第三方公共模块
          priority: -20,
          reuseExistingChunk: true
        }
      },
      runtimeChunk:{
          name:'manifest'
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码分割实例&quot;&gt;4.3 代码分割实例&lt;/h3&gt;
&lt;p&gt;注：实例中使用的demo及配置文件已放在附件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/719486908506c4edd597d96e90d59040.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.89164086687306&quot;&gt;&lt;li readability=&quot;4.4582043343653&quot;&gt;
&lt;p&gt;多页面应用&lt;/p&gt;
&lt;p&gt;多页面应用的情形稍显复杂，以&lt;a href=&quot;https://www.cnblogs.com/wmhuang/p/8967639.html&quot;&gt;《webpack4：连奏中的进化》&lt;/a&gt;一文中的例子进行代码分割处理，源码的依赖关系为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;entryA.js: vue vuex component10k
entryB.js: vue axios component10k
entryC.js: vue vuex axios component10k&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过代码分割后得到的包如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/0aedcb0347e7989f4eadd2acb9e6c24a.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;splitChunks&lt;/code&gt;提供了更精确的分割策略，但是似乎无法直接通过&lt;code&gt;html-webpack-plugin&lt;/code&gt;配置参数来动态解决分割后代码的注入问题，因为分包名称是不确定的。这个场景在使用&lt;code&gt;chunks:'async'&lt;/code&gt;默认配置时是不存在的，因为异步模块的引用代码是不需要以&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的形式注入&lt;code&gt;html&lt;/code&gt;文件的。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;chunks&lt;/code&gt;配置项设置为&lt;code&gt;all&lt;/code&gt;或&lt;code&gt;initial&lt;/code&gt;时，就会有问题，例如上面示例中，通过在&lt;code&gt;html-webpack-plugin&lt;/code&gt;中配置&lt;code&gt;excludeChunks&lt;/code&gt;可以去除&lt;em&gt;page&lt;/em&gt;和&lt;em&gt;about&lt;/em&gt;这两个chunk，但是却无法提前排除&lt;em&gt;vendors-about-page&lt;/em&gt;这个chunk，因为打包前无法知道是否会生成这样一个chunk。这个场景笔者并没有找到现成的解决方案，对此场景有需求的读者也许可以通过使用&lt;code&gt;html-webpack-plugin&lt;/code&gt;的&lt;strong&gt;事件扩展&lt;/strong&gt;来处理此类场景，也可以使用折中方案，就是第一次打包后记录下新生成的chunk名称，按需填写至&lt;code&gt;html-webpack-plugin&lt;/code&gt;的&lt;code&gt;chunks&lt;/code&gt;配置项里。&lt;/p&gt;
&lt;p&gt;### 4.4 结果分析&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Bundle Buddy&lt;/code&gt;分析工具或&lt;code&gt;webpack-bundle-analyser&lt;/code&gt;插件就可以看到分包前后对于公共代码的抽取带来的影响（图片来自参考文献的博文）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/27/11c20b43d6a8c9bcb7bb713c5dc0d099.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.-参考及附件说明&quot;&gt;五. 参考及附件说明&lt;/h2&gt;
&lt;p&gt;【1】附加中文件说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;webpack.spa.config.js&lt;/code&gt;——单页面应用代码分割配置实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main.js&lt;/code&gt;——单页面应用入口文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack.multi.config.js&lt;/code&gt;——多页面应用代码分割配置实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;entryA.js&lt;/code&gt;,&lt;code&gt;entryB.js&lt;/code&gt;,&lt;code&gt;entryC.js&lt;/code&gt;——多页面应用的3个入口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【2】参考文献： &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/&quot;&gt;《Reduce JavaScript Payloads with Code Splitting》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 14:19:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>作为前端最火的构建工具，是前端自动化工具链 最重要的部分 ，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过 问题 + 解决方式 的模式，以前端构建中遇到的具体需求为出发点，学习 工具中相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9545482.html</dc:identifier>
</item>
<item>
<title>ThreadLocal 从源码角度简单分析 - 苍枫露雨</title>
<link>http://www.cnblogs.com/chrischennx/p/9557285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chrischennx/p/9557285.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;threadlcoal源码浅析&quot;&gt;ThreadLcoal源码浅析&lt;/h2&gt;
&lt;p&gt;我们知道ThreadLocal用于维护多个线程&lt;strong&gt;线程独立&lt;/strong&gt;的变量副本，这些变量只在&lt;strong&gt;线程内共享&lt;/strong&gt;，可跨方法、类等，如下是一个维护多个线程Integer变量的ThreadLocal：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocal&amp;lt;Integer&amp;gt; threadLocalNum = new ThreadLocal&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个使用&lt;code&gt;threadLocalNum&lt;/code&gt;的线程，可以通过形如&lt;code&gt;threadLocalNum.set(1)&lt;/code&gt;的方式创建了一个独立使用的&lt;code&gt;Integer&lt;/code&gt;变量副本，那么它是怎么实现的呢？我们今天就来简单的分析一下。&lt;/p&gt;
&lt;p&gt;先看下ThreadLocal的set方法是如何实现的，源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void set(T value) {
        Thread t = Thread.currentThread();  //获取当前线程
        ThreadLocalMap map = getMap(t);     //获取当前线程的ThreadLocalMap
        if (map != null)
            map.set(this, value);           //当前线程的ThreadLocalMap不为空则直接设值
        else
            createMap(t, value);            //当前线程的ThreadLocalMap为空则创建一个来设置值
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，你没有看错，是获取当前线程中的&lt;code&gt;ThreadLocalMap&lt;/code&gt;来设置的值，我们来看一下&lt;code&gt;getMap(t)&lt;/code&gt;是如何实现的:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们看到Thread中包含了一个ThreadLocalMap类型的属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里我们可以得出一个结论：&lt;strong&gt;&lt;em&gt;各个线程持有了一个ThreadLocalMap的属性，通过ThreadLocal设置变量时，直接设置到了对应线程的的ThreadLocalMap属性中&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么不同的线程中通过ThreadLocal设置的值是如何关联定义的ThreadLocal变量和Thread中的ThreadLocalMap的呢？我们接着分析。&lt;/p&gt;
&lt;p&gt;前面写到&lt;em&gt;当前线程的ThreadLocalMap为空则创建一个ThreadLocalMap来设值&lt;/em&gt;，我们来看下&lt;code&gt;createMap(t, value)&lt;/code&gt;的具体实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

///////////////////
//ThreadLocalMap构造器定义如下
ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1);  //
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
private static final int INITIAL_CAPACITY = 16;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程中&lt;em&gt;threadLocals&lt;/em&gt;是一个ThreadLocalMap变量，其默认值是null，该线程在首次使用threadLocal对象调用set的时候通过&lt;code&gt;createMap(Thread t, T firstValue)&lt;/code&gt;实例化。&lt;/p&gt;
&lt;p&gt;先来看一下ThreadLocalMap，它是在ThreadLocal中定义的一个静态内部类，其内属性如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
         * The initial capacity -- MUST be a power of two.
         */
        private static final int INITIAL_CAPACITY = 16;

        /**
         * The table, resized as necessary.
         * table.length MUST always be a power of two.
         */
        private Entry[] table;

        /**
         * The number of entries in the table.
         */
        private int size = 0;

        /**
         * The next size value at which to resize.
         */
        private int threshold; // Default to 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中属性&lt;code&gt;private Entry[] table&lt;/code&gt;，用于存储通过threadLocal set 进来的变量，Entry定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
                super(k);
                value = v;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Entry&lt;/code&gt;继承了&lt;code&gt;WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt;，ThreadLocal在构造器中被指定为弱引用&lt;code&gt;super(k)&lt;/code&gt;(后面会单独讨论为何这里使用弱引用)。&lt;/p&gt;
&lt;p&gt;至此，我们可以知道ThreadLocal和Thead的内存结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/572732/201808/572732-20180829194625099-636107726.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocal的垃圾回收&quot;&gt;ThreadLocal的垃圾回收&lt;/h2&gt;
&lt;p&gt;网上看到很多文章都在讲ThreadLocal的内存泄露问题，所以也在这里简单说一下自己的理解。&lt;/p&gt;
&lt;p&gt;从上面的结构可以看出ThreadLocal涉及到的要回收的对象包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ThreadLocal实例本身&lt;/li&gt;
&lt;li&gt;各线程中的threadLocalMap，其中包括各个Entry的 key, value&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面先简述java的引用，然后分别讨论ThreadLocal本身的回收和threadLcoalMap的回收&lt;/p&gt;
&lt;h3 id=&quot;java引用&quot;&gt;Java引用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;强引用（StrongReference）：对象可达就不会被gc回收，空间不足时报error&lt;/li&gt;
&lt;li&gt;软引用（SoftReference）：对象无其他强引用，当空间不足时才会被gc回收。&lt;/li&gt;
&lt;li&gt;弱引用（WeakReference）：对象无其他强引用，gc过程扫描到就会被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;threadlocal的回收&quot;&gt;ThreadLocal的回收&lt;/h3&gt;
&lt;p&gt;ThreadLocal实例的引用主要包括两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ThreadLocal定义处的强引用&lt;/li&gt;
&lt;li&gt;各线程中ThreadLocalMap里的key=weak(threadLocal)， 是弱引用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;强引用还在的情况下ThreadLocal一定不会被回收；无强引用后，由于各个Thread中Entry的key是弱引用，会在下次GC后变为null。ThreadLocal实例什么时候被回收完全取决于强引用何时被干掉，那么什么时候强引用会被销毁呢？最简单的就是 &lt;code&gt;threadLocal=null&lt;/code&gt;强引用被赋值为null；其它也可是threadLocal是一个局部变量，在方法退出后引用被销毁，等等。&lt;/p&gt;
&lt;p&gt;这里来回答一下前面提到的&lt;strong&gt;为什么ThreadLocalMap中将key设计为弱引用&lt;/strong&gt;，我们假设如果ThreadLocalMap中是强引用会出现什么情况？定义ThreadLocal时定义的强引用被置为null的时候，如果还有其它使用了该ThreadLocal的线程没有完成，还需要很久会执行完成，那么这个线程将一直持有该ThreadLocal实例的引用，直到线程完成，期间ThreadLocal实例都不能被回收，最重要的是如果不了解ThreadLocal内部实现，你可能都不知道还有其他线程引用了threadLocal实例。&lt;/p&gt;
&lt;p&gt;线程结束时清除ThreadLocalMap的代码&lt;code&gt;Thread.exit()&lt;/code&gt;如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * This method is called by the system to give a Thread
     * a chance to clean up before it actually exits.
     */
    private void exit() {
        if (group != null) {
            group.threadTerminated(this);
            group = null;
        }
        /* Aggressively null out all reference fields: see bug 4006245 */
        target = null;
        /* Speed the release of some of these resources */
        threadLocals = null;
        inheritableThreadLocals = null;
        inheritedAccessControlContext = null;
        blocker = null;
        uncaughtExceptionHandler = null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;各线程中threadlocalmap的回收&quot;&gt;各线程中threadLocalMap的回收&lt;/h3&gt;
&lt;p&gt;单从引用的角度来看，各线程中的threadLocalMap，其中包括各个Entry的key 和 value，线程（也就是Thread实例）本身一直持有threadLocalMap的强引用，只有在线程结束的时候才会被回收，但是ThreadLocal在实现的时候提供了一些方法：&lt;strong&gt;set/get/remove&lt;/strong&gt;，可以在执行它们的时候回收其它已经失效（key=null）的entry实例。&lt;/p&gt;
&lt;p&gt;这里就以set为例看看ThreadLocal是如何回收entry的，ThreadLocal set方法实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ThreadLocal
public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);  // 本次要分析的方法
        else
            createMap(t, value);   //这里前面已经分析了
    }

//ThreadLocalMap
private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {
            // We don't use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.
            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp;amp; (len-1);  //获取当前threadLocal实例的hashcode，同时也是table的下标

            //这里for循环找key，是因为hash冲突会使hashcode指向的下标不是真实的存储位置
            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) { 
                ThreadLocal&amp;lt;?&amp;gt; k = e.get();
                //找到了设置为新值
                if (k == key) {
                    e.value = value;
                    return;
                }
                //entry不为null，key为null
                //说明原来被赋值过,但是原threadLocal已经被回收
                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }
            //如果下标对应的entry为null, 则新建一个entry
            tab[i] = new Entry(key, value);
            int sz = ++size;
            //清理threadlocal中其它被回收了的entry(也就是key=null的entry)
            if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
                //rehash
                rehash();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下cleanSomeSlots的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ThreadLocalMap
private boolean cleanSomeSlots(int i, int n) {
            boolean removed = false;
            Entry[] tab = table;
            int len = tab.length;
            do {
                //获取下一个entry的下标
                i = nextIndex(i, len);
                Entry e = tab[i];
                //entry不为null，key为null
                //说明原来被赋值过,但是原threadLocal已经被回收
                if (e != null &amp;amp;&amp;amp; e.get() == null) {
                    n = len;
                    removed = true;
                    // 删除已经无效的entry
                    i = expungeStaleEntry(i);
                }
            } while ( (n &amp;gt;&amp;gt;&amp;gt;= 1) != 0);
            return removed;
        }



private int expungeStaleEntry(int staleSlot) {
            Entry[] tab = table;
            int len = tab.length;

            // 回收无效entry
            tab[staleSlot].value = null;
            tab[staleSlot] = null;
            size--;

            // Rehash until we encounter null
            Entry e;
            int i;
            for (i = nextIndex(staleSlot, len);
                 (e = tab[i]) != null;
                 i = nextIndex(i, len)) {
                ThreadLocal&amp;lt;?&amp;gt; k = e.get();
                //entry不为null，key为null，应该回收
                if (k == null) {
                    e.value = null;
                    tab[i] = null;
                    size--;
                } else {
                    //rehash的实现
                    //计算当前entry的k的hashcode，看是下标是否应该为i
                    //如果不为i说明，是之前hash冲突放到这儿的，现在需要reash
                    int h = k.threadLocalHashCode &amp;amp; (len - 1);
                    //h!=i 说明hash冲突了, entry不应该放在下标为i的位置
                    if (h != i) {
                        tab[i] = null;
                        // Unlike Knuth 6.4 Algorithm R, we must scan until
                        // null because multiple entries could have been stale.
                        //找正确的位置h，但是还是有可能冲突所以要循环
                        while (tab[h] != null)
                            h = nextIndex(h, len);
                        tab[h] = e;
                    }
                }
            }
            return i;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的分析我们可以看到&lt;strong&gt;把ThreadLocalMap中的key设计为weakReference，也使set方法可以通过&lt;code&gt;key==null &amp;amp;&amp;amp; entry != null&lt;/code&gt;判断entry是否失效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总结一下ThreadLocal set方法的实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据threadLocal计算hashcode找到entry[]数组对应位置设置值&lt;/li&gt;
&lt;li&gt;遍历数组找到其它失效的(entry不为null，key为null)的entry删除&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;内存泄露问题&quot;&gt;内存泄露问题&lt;/h3&gt;
&lt;p&gt;ThreadLocal通过巧妙的设计最大程度上减少了内存泄露的可能，但是并没有完全消除。&lt;/p&gt;
&lt;p&gt;当我们使用完ThreadLocal后没有调用&lt;strong&gt;set/get/remove&lt;/strong&gt;方法，那么可能会导致失效内存不能及时被回收，导致内存泄露，尤其是在value占用内存较大的情况。&lt;/p&gt;
&lt;p&gt;所以最佳实践是，在明确ThreadLocal不再使用时，手动调用remove方法及时清空。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ThreadLocal 并不解决线程间共享数据的问题&lt;/li&gt;
&lt;li&gt;ThreadLocal是通过让线程内的ThreadLocalMap.Entry的key指向自身，来实现了对线程内对象的引用，从而可以在线程内方便的使用变量。同时因为操作的都是线程内的变量，也避免了实例线程安全的问题&lt;/li&gt;
&lt;li&gt;ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景&lt;/li&gt;
&lt;li&gt;ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题&lt;/li&gt;
&lt;li&gt;ThreadLocalMap 的 set 方法通过调用 &lt;code&gt;cleanSomeSlots&lt;/code&gt; 方法回收键为 null 的 Entry 对象的值（即失效实例）从而防止内存泄漏（其它的remove，get类似）&lt;/li&gt;
&lt;li&gt;在明确ThreadLocal不再使用时，手动调用remove方法及时清空&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/java/threadlocal/&quot;&gt;正确理解Thread Local的原理与适用场景&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 14:11:00 +0000</pubDate>
<dc:creator>苍枫露雨</dc:creator>
<og:description>[TOC] ThreadLcoal源码浅析 我们知道ThreadLocal用于维护多个线程 线程独立 的变量副本，这些变量只在 线程内共享 ，可跨方法、类等，如下是一个维护多个线程Integer变量的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chrischennx/p/9557285.html</dc:identifier>
</item>
<item>
<title>深入浅出CSS：关于雪碧图、background-position与steps函数的三角恋情 - 低头苦读、抬头高歌</title>
<link>http://www.cnblogs.com/keepStudying/p/9557203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keepStudying/p/9557203.html</guid>
<description>&lt;p&gt;&lt;span&gt;【测试代码】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;id=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;雪碧图练习&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;footer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic pic1 move&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic pic2 move &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic pic3 move&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic pic4 move&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;{&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;}
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;html,body &lt;/span&gt;{
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; }
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; .footer &lt;/span&gt;{
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     background&lt;/span&gt;:&lt;span&gt; url(&quot;https://xyq.res.netease.com/pc/gw/20170118103441/img/ft_e43a6db.webp&quot;) 0 0 no-repeat&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        overflow&lt;/span&gt;:&lt;span&gt; hidden: &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;形成BFC盒模型，保证.wrap的margin在.footer内移动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;  }
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; .wrap &lt;/span&gt;{
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 780px&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     margin&lt;/span&gt;:&lt;span&gt; 320px auto 0&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;未设置overflow: hidden;，保证在图片调整位置时的溢出仍能显示&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;  }
&lt;span&gt;17&lt;/span&gt; &lt;span&gt; .pic &lt;/span&gt;{
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt;  }
&lt;span&gt;20&lt;/span&gt; &lt;span&gt; .pic1 &lt;/span&gt;{
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     height&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     background&lt;/span&gt;:&lt;span&gt; url(&quot;https://xyq.res.netease.com/pc/gw/20170118103441/img/west_01_3ca39fe.png&quot;) 0 0 no-repeat&lt;/span&gt;;
&lt;span&gt;24&lt;/span&gt;  }
&lt;span&gt;25&lt;/span&gt; &lt;span&gt; .pic2 &lt;/span&gt;{
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     height&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     background&lt;/span&gt;:&lt;span&gt; url(&quot;https://xyq.res.netease.com/pc/gw/20170118103441/img/west_02_47bad19.png&quot;) 0 0 no-repeat&lt;/span&gt;;
&lt;span&gt;29&lt;/span&gt;  }
&lt;span&gt;30&lt;/span&gt; &lt;span&gt; .pic3 &lt;/span&gt;{
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 170px&lt;/span&gt;;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     height&lt;/span&gt;:&lt;span&gt; 240px&lt;/span&gt;;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     background&lt;/span&gt;:&lt;span&gt; url(&quot;https://xyq.res.netease.com/pc/gw/20170118103441/img/west_03_f962447.png&quot;) 0 0 no-repeat&lt;/span&gt;;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     margin-top&lt;/span&gt;:&lt;span&gt; -30px&lt;/span&gt;;
&lt;span&gt;35&lt;/span&gt;  }
&lt;span&gt;36&lt;/span&gt; &lt;span&gt; .pic4 &lt;/span&gt;{
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     width&lt;/span&gt;:&lt;span&gt; 210px&lt;/span&gt;;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     background&lt;/span&gt;:&lt;span&gt; url(&quot;https://xyq.res.netease.com/pc/gw/20170118103441/img/west_04_6516d80.png&quot;) 0 0 no-repeat&lt;/span&gt;;
&lt;span&gt;40&lt;/span&gt;  }
&lt;span&gt;41&lt;/span&gt;  
&lt;span&gt;42&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;动画&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;@keyframes move &lt;/span&gt;{
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    0% {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        background-position&lt;/span&gt;:&lt;span&gt; 0 0&lt;/span&gt;;
&lt;span&gt;46&lt;/span&gt;     }
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    100% &lt;/span&gt;{
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        background-position&lt;/span&gt;:&lt;span&gt; 114.2857% 0&lt;/span&gt;;
&lt;span&gt;49&lt;/span&gt;     }
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;.move &lt;/span&gt;{
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    -webkit-animation&lt;/span&gt;:&lt;span&gt; move 1.4s steps(8) infinite&lt;/span&gt;;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    -o-animation&lt;/span&gt;:&lt;span&gt; move 1.4s steps(8) infinite&lt;/span&gt;;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    animation&lt;/span&gt;:&lt;span&gt; move 1.4s steps(8) infinite&lt;/span&gt;;
&lt;span&gt;56&lt;/span&gt; }
&lt;span&gt;57&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;一、概念理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;1.什么是雪碧图？？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CSS雪碧的基本原理，是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS的background和background-position属性渲染，达到加在一次图片，可以实现复杂图片的效果，提高页面在使用时的效果响应速度。但相应的，缺点也十分明显，就是提高了页面的加载时间。&lt;/p&gt;
&lt;p&gt;　　CSS雪碧图的基本应用大多在鼠标滑过以及一些动图效果。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2.什么是background和background-position？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据W3C的标准定义，background就是声明元素背景的属性，共有如下属性值：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-position&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-size&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-repeat&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-origin&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-clip&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-attachment&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;background-image&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　具体每个属性的含义及用法，这里不再阐述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上我们可以看到，background-position是background众多属性中的一种。其含义就是声明背景在元素中的位置。其计算方式如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829194428693-1754233623.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　这里边的计算，由易到难，我一一进行一个简单的梳理。首先要明确的一点，所有位置的计算，都是基于元素的background-clip设定区域（如果未设置background-clip的话，就是元素的border-box）。明确了计算区域后，下面再来说计算规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　计算规则总共分为两大类，一类是根据设定好规则的方向值来声明位置。另一类是根据确定的数值或百分比来计算位置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　1.首先是五个方向top lright bottom left center的计算。这个的位置是相对固定的。设定值总共有两个，默认为center。理解起来也很简单——就是把两个单词倒过来读。举个例子，top left就是左上角、bottom right就是右下角。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829201634792-977154182.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;2.然后是设定固定值或百分比，这两类都是根据确定的数值，在X、Y轴上进行调整。区别就是固定值是直接根据声明值进行调整，而百分比是由（背景区域的宽度/高度 - 图片的宽度/高度）*(X)%的计算式计算后的数值在X、Y轴上进行调整。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　1）&lt;span&gt;固定值声明的位移&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829203515461-907800698.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　&lt;span&gt;　2）百分比声明的计算&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829203634624-532587075.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;结合上图，理解结论：1）固定值声明，正值即沿X、Y轴方向进行位移。负值即沿反方向位移；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　2）百分比声明，当图片宽度大于实际背景尺寸时（雪碧图原理），百分比正值时，计算值即为负；百分比负值时，计算值即为正。方向调整逻辑与固定值声明相同；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　    &lt;span&gt;好了，概念介绍完毕，下面进入正题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、雪碧图与background-position的爱恨纠缠&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;1.直接上例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　以网易梦幻西游的底部的雪碧图为例  http://xyq.163.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829204706360-688657261.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829204846002-582485168.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;span&gt;从上面两张梦幻西游官网的图中可以看到，雪碧图由师徒四人共四张图片形成，并且每个图片都单独设置了动画样式。由此不难猜出，这个雪碧图是根据每个图片的实际宽度，通过steps属性，设定了固定的background值来完成的。大致代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;假定图片宽度1600px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@keyframes play &lt;/span&gt;{&lt;span&gt;
    from {background-position&lt;/span&gt;:&lt;span&gt; 0 0&lt;/span&gt;;}&lt;span&gt;     
    to &lt;/span&gt;{&lt;span&gt;background-position&lt;/span&gt;:&lt;span&gt; -1600px 0&lt;/span&gt;}&lt;span readability=&quot;3&quot;&gt;
}&lt;p&gt;/*应用动画*/&lt;br/&gt;.west-x {&lt;br/&gt;animation: play 1.4s steps(8,end) infinite;&lt;br/&gt;}&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;当我看到这段代码时，我就思考一个问题。既然是将图片移动了100%的宽度，为什么不直接给所有的雪碧图，设定一个统一的动画，backgroun-position直接结束值为background-position: 100% 0;，这样就直接一步到位，还不用去计算每个图片的宽度。当我想出这个好方法，敲出简洁的代码，为自己的聪明才智美滋滋的时候。运行结果直接呼了我一个大嘴巴子，总结起来总共有如下几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）steps步数不对，按照官网的代码copy下来，steps(8)根本实现不了效果；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）将steps(8)改写成steps(7)时，人物确实是动起来了，但是在动画结束时会卡帧；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）将steps(7)改写为steps(7,start)后，人物卡帧现象消失，但仔细观察动画，与实际效果并不一致；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出现问题后，我逐步解决了问题1和问题2，但是问题3，着实费了好大力气才研究明白。接下来对问题3解决的讲解，将是本文的重点，重点，重点！！！敲黑板！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;重点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　针对问题3的解决思路，必须明确两点——background-position的计算方式；steps()函数的属性值；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;background-position的计算方式，上边已经说明。现在重点说一下steps()函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;steps()是针对帧数动画，专有的函数，可以说是没有steps就没有雪碧图了。它主要有两个函数值steps(number,start/end)，第一个值number就是步数，理解起来也简单，一般雪碧图分为几张小图，number就设定为多少，几张图就走几步。第二个值是固定的两个值——start和end，这两个值理解起来就稍微有点难度了。还是举例说明，简单明了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;animation动画练习&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; black&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            -webkit-animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; move 1s steps(1,start) infinite&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            -o-animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; move 1s steps(1,start) infinite&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; move 1s steps(1,start) infinite&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        @keyframes move &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            0% {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            50% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; yellow&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            100% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;以上代码，如果粘贴到编辑器中并运行，会发生一个有趣的现象。元素的背景颜色，将在yellow和blue间来回切换，至于元素本身的背景色black以及0%时的背景色red，都不会显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在让我们把代码中的steps的属性值start改为end，再来看一下结果。此时，背景色在red和yellow间切换，black和blue将不再显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先不考虑元素本身背景色的显示问题，这个相信不用说，大家也都明白。通过上面的例子，相信大家已经发现了其中的端倪——那就是start/end设置相应的属性值时，动画设定中的开始帧和结束帧就会跳过不显示，这就是它们的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　明白了step()函数的作用之后，让我们返回去再看一下刚才出现的3个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）steps步数不对，按照官网的代码copy下来，steps(8)根本实现不了效果；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这个主要是background-position按%百分比设置属性值时，计算方式产生的影响。&lt;strong&gt;当我设置background-position: 100% 0;时，按照图片总共分为8张小图片，每张小图片宽度为200px，背景宽度为200px计算。实际上计算出来的位移值为(200-1400)*100%=1400px，所以我实际的设置值为background-position: -1400px 0;&lt;/strong&gt;，结果一目了然，少走了一步，实际上只走了7张图片的步数。所以steps值应改为steps(7)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）将steps(8)改写成steps(7)时，人物确实是动起来了，但是在动画结束时会卡帧；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　与问题1实际上是同一类型，因为&lt;strong&gt;background-position: -1400px 0;&lt;/strong&gt;，所以上最后一张图片并没有显示。而steps第二属性值start/end的默认属性值是end。在少走一步图片的基础上，又少显示了动画的最后一页图片，不卡帧才怪嘞！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3）将steps(7)改写为steps(7,start)后，人物卡帧现象消失，但仔细观察动画，与实际效果并不一致；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　通过前两步的解读，到了这一步，其实很清晰了，&lt;strong&gt;虽然少显示了两张图，却正好是头和尾&lt;/strong&gt;，所以整个动画看起来还是连贯的。但实际上少了两帧图，跟官网的效果肯定存在偏差，只是不长时间盯着，看不出来而已（眼睛都要看花了……）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么现在理解下来的话，问题3的重点就是2个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1）把少走的一步补回来；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）把steps函数没有播放的那一帧补回来；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一个问题还是回到background-position的计算问题上，既然设定100%时，是&lt;strong&gt;background-position: -1400px 0;走7步&lt;/strong&gt;，那我设定多少才能是&lt;strong&gt;background-position: -1600px 0;走8步呢&lt;/strong&gt;？？这里我倒推了一个公式——&lt;strong&gt;[100% / (图片个数-1) + 100%]&lt;/strong&gt;，这样算出来的百分比数，就是应该设定的数值，以此例计算的话就是——&lt;strong&gt;100% / (8-1) + 100% = 114.2857%&lt;/strong&gt;。这样计算下来的最终结果就是&lt;strong&gt;background-position: -1600px 0;&lt;/strong&gt;，同时将steps(7,start)改为steps(8,start)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解决完第一个问题，再来解决第二个问题。设定了background-position: 114.2857% 0;之后，再看效果，发现不卡帧了。直接卡空白画面了？？Excuse me？？这不是刚改完steps第一个属性，还没改第二个属性值嘛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1080150/201808/1080150-20180829214854043-1825228202.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　相信看完上面这张图，大家心里肯定是明明白白的了。修改完第一步之后，最后动画停留的位置。实际上是一片空白，因为图片已经完全溢出背景了。再来看steps的属性值steps(8,start)，设置了动画第一帧不显示，显然是有问题了。那么只需要将start删除，让steps匹配默认属性end，按百分比设置的完美雪碧图就完成了~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到这里，关于雪碧图、background-position与steps函数三角恋情就八卦完毕了，如果还想看更多的CSS花边新闻，敬请期待下一期CSS&lt;span&gt;娱乐大搜查&lt;/span&gt;深入浅出！欢迎批评指正！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 13:56:00 +0000</pubDate>
<dc:creator>低头苦读、抬头高歌</dc:creator>
<og:description>【测试代码】 HTML CSS 一、概念理解 1.什么是雪碧图？？ CSS雪碧的基本原理，是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS的ba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keepStudying/p/9557203.html</dc:identifier>
</item>
<item>
<title>Java面试题之HashMap阿里面试必问知识点，你会吗？ - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/9557152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/9557152.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试官Q1：你用过HashMap，你能跟我说说它的数据结构吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap作为一种容器类型，无论你是否了解过其内部的实现原理，它的大名已经频频出现在各种互联网Java面试题中了。从基本的使用角度来说，它很简单，但从其内部的实现来看，它又并非想象中那么容易。如果你一定要问了解其内部实现与否对于写程序究竟有多大影响，我不能给出一个确切的答案。但是作为一名合格程序员，对于这种遍地都在谈论的技术不应该不为所动。下面我们将自己实现一个简易版HashMap，然后通过阅读HashMap的源码&lt;span&gt;逐步&lt;/span&gt;来认识HashMap的底层数据结构。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;简易HashMap V1.0版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0版本我们需要实现Map的几个重要的功能：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomHashMap&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    CustomEntry[] arr = &lt;span&gt;new&lt;/span&gt; CustomEntry[&lt;span&gt;990&lt;/span&gt;];&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; size;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        CustomEntry e = &lt;span&gt;new&lt;/span&gt; CustomEntry(key, &lt;span&gt;value&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++) {&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (arr[i].key.&lt;span&gt;equals&lt;/span&gt;(key)) {&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;                &lt;span&gt;//如果有key值相等，直接覆盖value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;                arr[i].&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        arr[size++] = e;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++) {&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (arr[i].key.&lt;span&gt;equals&lt;/span&gt;(key)) {&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; arr[i].&lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; boolean &lt;span&gt;containsKey&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++) {&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; (arr[i].key.&lt;span&gt;equals&lt;/span&gt;(key)) {&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;        CustomHashMap map = &lt;span&gt;new&lt;/span&gt; CustomHashMap();&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;        map.put(&lt;span&gt;&quot;k1&quot;&lt;/span&gt;, &lt;span&gt;&quot;v1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;        map.put(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;, &lt;span&gt;&quot;v2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;        map.put(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;, &lt;span&gt;&quot;v4&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(map.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;    Object key;&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;    Object &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;        super();&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getKey&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;56&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;&lt;span&gt;57&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;58&lt;/span&gt;&lt;br/&gt;&lt;span&gt;59&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setKey&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;60&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;61&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;62&lt;/span&gt;&lt;br/&gt;&lt;span&gt;63&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getValue&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;64&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;65&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;66&lt;/span&gt;&lt;br/&gt;&lt;span&gt;67&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setValue&lt;/span&gt;(&lt;span&gt;Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;68&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;69&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;70&lt;/span&gt;&lt;br/&gt;&lt;span&gt;71&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;上面就是我们自定义的简单Map实现，可以完成V1.0提出的几个功能点，但是大家有木有发现，这个Map是基于数组实现的，不管是put还是get方法，每次都要循环去做数据的对比，可想而知效率会很低，现在数组长度只有990，那如果数组的长度很长了，岂不是要循环很多次。既然问题出现了，我们有没有更好的办法做改进，使得效率提升，答案是肯定，下面就是V2.0版本升级。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;简易HashMap V2.0版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V2.0版本需要处理问题如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在做改进之前，我们先思考一下，有没有什么方式可以在我们放数据的时候，通过一次定位，就能将这个数放到某个位置，而再我们获取数据的时候，&lt;span&gt;直接通过一次定位就能找到我们想要的数据，那样我们就减少了很多迭代遍历次数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;接下来，我们需要介绍一下哈希表的相关知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数组：&lt;/strong&gt;采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线性链表：&lt;/strong&gt;对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二叉树：&lt;/strong&gt;对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哈希表：&lt;/strong&gt;相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;存储位置 = f(关键字)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223046/201808/1223046-20180829210020880-1817808128.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;542&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。&lt;/span&gt;&lt;span&gt;既然思路有了，那我们继续改进呗！&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomHashMap&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    CustomEntry[] arr = &lt;span&gt;new&lt;/span&gt; CustomEntry[&lt;span&gt;999&lt;/span&gt;];&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        CustomEntry entry = &lt;span&gt;new&lt;/span&gt; CustomEntry(key, &lt;span&gt;value&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;//使用Hash码对999取余数，那么余数的范围肯定在0到998之间&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;//你可能也发现了，不管怎么取余数，余数也会有冲突的时候(暂时先不考虑，后面慢慢道来)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;//至少现在我们存数据的效率明显提升了，key.hashCode() % 999 相同的key算出来的结果肯定是一样的&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; a = key.hashCode() % &lt;span&gt;999&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        arr[a] = entry;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;//取数的时候也通过一次定位就找到了数据，效率明显得到提升&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; arr[key.hashCode() % &lt;span&gt;999&lt;/span&gt;].&lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;        CustomHashMap map = &lt;span&gt;new&lt;/span&gt; CustomHashMap();&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;        map.put(&lt;span&gt;&quot;k1&quot;&lt;/span&gt;, &lt;span&gt;&quot;v1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;        map.put(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;, &lt;span&gt;&quot;v2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(map.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;    Object key;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;    Object &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;        super();&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getKey&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setKey&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getValue&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setValue&lt;/span&gt;(&lt;span&gt;Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;通过上面的代码，我们知道余数也有冲突的时候，不一样的key计算出相同的地址，那么这个时候我们又要怎么处理呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，&lt;strong&gt;而HashMap即是采用了链地址法，也就是数组+链表的方式&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过上面的说明知道，HashMap的底层是基于数组+链表的方式，此时，我们需要再对V2.0的Map再次升级&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;简易HashMap V3.0版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V3.0版本需要处理问题如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomHashMap&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    LinkedList[] arr = &lt;span&gt;new&lt;/span&gt; LinkedList[&lt;span&gt;999&lt;/span&gt;];&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        CustomEntry entry = &lt;span&gt;new&lt;/span&gt; CustomEntry(key, &lt;span&gt;value&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; a = key.hashCode() % arr.length;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (arr[a] == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;            LinkedList list = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;            list.&lt;span&gt;add&lt;/span&gt;(entry);&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            arr[a] = list;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;            LinkedList list = arr[a];&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;                CustomEntry e = (CustomEntry) list.&lt;span&gt;get&lt;/span&gt;(i);&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (entry.key.&lt;span&gt;equals&lt;/span&gt;(key)) {&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;                    e.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;span&gt;// 键值重复需要覆盖&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;                }&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;            arr[a].&lt;span&gt;add&lt;/span&gt;(entry);&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; a = key.hashCode() % arr.length;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (arr[a] != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;            LinkedList list = arr[a];&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;                CustomEntry entry = (CustomEntry) list.&lt;span&gt;get&lt;/span&gt;(i);&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt; (entry.key.&lt;span&gt;equals&lt;/span&gt;(key)) {&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;                    &lt;span&gt;return&lt;/span&gt; entry.&lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;                }&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;            }&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;        }&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;        CustomHashMap map = &lt;span&gt;new&lt;/span&gt; CustomHashMap();&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;        map.put(&lt;span&gt;&quot;k1&quot;&lt;/span&gt;, &lt;span&gt;&quot;v1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;        map.put(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;, &lt;span&gt;&quot;v2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;        map.put(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;, &lt;span&gt;&quot;v3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(map.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;k2&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;&lt;br/&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;    Object key;&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;    Object &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomEntry&lt;/span&gt;(&lt;span&gt;Object key, Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;        super();&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;56&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;57&lt;/span&gt;&lt;br/&gt;&lt;span&gt;58&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getKey&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;59&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;&lt;span&gt;60&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;61&lt;/span&gt;&lt;br/&gt;&lt;span&gt;62&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setKey&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;63&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;&lt;span&gt;64&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;65&lt;/span&gt;&lt;br/&gt;&lt;span&gt;66&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getValue&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;67&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;68&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;69&lt;/span&gt;&lt;br/&gt;&lt;span&gt;70&lt;/span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setValue&lt;/span&gt;(&lt;span&gt;Object &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;71&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;72&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;73&lt;/span&gt;&lt;br/&gt;&lt;span&gt;74&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;最终的数据结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223046/201808/1223046-20180829210250777-1095049731.png&quot; alt=&quot;&quot; width=&quot;890&quot; height=&quot;695&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;简单来说，&lt;/span&gt;&lt;strong&gt;HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HashMap源码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面的推导过程，我们逐渐清晰的认识了HashMap的实现原理，下面我们通过阅读部分源码，来看看HashMap(基于JDK1.7版本)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; Entry[] table;  &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;,&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;.&lt;span&gt;Entry&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;,&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{  &lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;final&lt;/span&gt; K key;  &lt;br/&gt;&lt;span&gt;5&lt;/span&gt;    V value;  &lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    Entry&amp;lt;K,V&amp;gt; next;  &lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash;  &lt;br/&gt;&lt;span&gt;8&lt;/span&gt;    ...&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;}  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;可以看出，HashMap中维护了一个Entry为元素的table，transient修饰表示不参与序列化。每个Entry元素存储了指向下一个元素的引用，构成了链表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;put方法实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;put&lt;/span&gt;(&lt;span&gt;K key, V &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{  &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;// HashMap允许存放null键和null值。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; putForNullKey(&lt;span&gt;value&lt;/span&gt;);  &lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;// 根据key的keyCode重新计算hash值。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; hash = hash(key.hashCode());  &lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;// 搜索指定hash值在对应table中的索引。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; i = indexFor(hash, table.length);  &lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e = e.next) {  &lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        Object k;  &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.&lt;span&gt;equals&lt;/span&gt;(k))) {  &lt;br/&gt;&lt;span&gt;14&lt;/span&gt;            V oldValue = e.&lt;span&gt;value&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt;15&lt;/span&gt;            e.&lt;span&gt;value&lt;/span&gt; = &lt;span&gt;value&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt;16&lt;/span&gt;            e.recordAccess(&lt;span&gt;this&lt;/span&gt;);  &lt;br/&gt;&lt;span&gt;17&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; oldValue;  &lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        }  &lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    }  &lt;br/&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;// 如果i索引处的Entry为null，表明此处还没有Entry。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;    modCount++;  &lt;br/&gt;&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;// 将key、value添加到i索引处。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;    addEntry(hash, key, &lt;span&gt;value&lt;/span&gt;, i);  &lt;br/&gt;&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt;25&lt;/span&gt;}  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;从源码可以看出，大致过程是，当我们向HashMap中put一个元素时，首先判断key是否为null，不为null则根据key的hashCode，重新获得hash值，根据hash值通过indexFor方法获取元素对应哈希桶的索引，遍历哈希桶中的元素，如果存在元素与key的hash值相同以及key相同，则更新原entry的value值；如果不存在相同的key，则将新元素从头部插入。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看一下重hash的方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; int hash(int h) {  &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;h&lt;/span&gt;&lt;span&gt; ^=&lt;/span&gt; (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;20&lt;/span&gt;)&lt;span&gt; ^&lt;/span&gt; (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;12&lt;/span&gt;);  &lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; h&lt;span&gt; ^&lt;/span&gt; (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;7&lt;/span&gt;)&lt;span&gt; ^&lt;/span&gt; (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;);  &lt;br/&gt;&lt;span&gt;4&lt;/span&gt;}  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;此算法加入了&lt;strong&gt;高位计算，防止低位不变，高位变化时，造成的hash冲突&lt;/strong&gt;。在HashMap中，我们希望元素尽可能的离散均匀的分布到每一个hash桶中，因此，这边给出了一个indexFor方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;indexFor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length&lt;span&gt;-1&lt;/span&gt;);  &lt;br/&gt;&lt;span&gt;3&lt;/span&gt;}  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这段代码&lt;/span&gt;&lt;span&gt;&lt;strong&gt;使用 &amp;amp; 运算代替取模(上面我们自己实现的方式就是取模)&lt;/strong&gt;&lt;strong&gt;，效率更高&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再来看一眼addEntry方法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addEntry&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V &lt;span&gt;value&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; bucketIndex&lt;/span&gt;) &lt;/span&gt;{  &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;// 获取指定 bucketIndex 索引处的 Entry   &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];  &lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;(hash, key, &lt;span&gt;value&lt;/span&gt;, e);  &lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;// 如果 Map 中的 key-value 对的数量超过了极限  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (size++ &amp;gt;= threshold)  &lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;// 把 table 对象的长度扩充到原来的2倍。  &lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        resize(&lt;span&gt;2&lt;/span&gt; * table.length);  &lt;br/&gt;&lt;span&gt;10&lt;/span&gt;}   &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;很明显，这边代码做的事情就是从头插入新元素；如果size超过了阈值threshold，就调用resize方法扩容两倍，至于，为什么要扩容成原来的2倍，请参考，此节不是我们要说的重点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;get方法实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;Object key&lt;/span&gt;) &lt;/span&gt;{  &lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; getForNullKey();  &lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; hash = hash(key.hashCode());  &lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];  &lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        e != &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        e = e.next) {  &lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;        Object k;  &lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.&lt;span&gt;equals&lt;/span&gt;(k)))  &lt;br/&gt;&lt;span&gt;10&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; e.&lt;span&gt;value&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    }  &lt;br/&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;&lt;span&gt;13&lt;/span&gt;}   &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这段代码很容易理解，首先根据key的hashCode计算hash值，根据hash值确定桶的位置，然后遍历。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在，大家都应该对HashMap的底层结构有了更深刻的认识吧，下面笔者对于面试时可能出现的关于HashMap相关的面试题，做了一下梳理，大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;你了解HashMap的底层数据结构吗？(本文已做梳理)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;为何HashMap的数组长度一定是2的次幂？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HashMap何时扩容以及它的扩容机制？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HashMap的键一般使用的String类型，还可以用别的对象吗？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HashMap是线程安全的吗，如何实现线程安全？&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 13:56:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官Q1：你用过HashMap，你能跟我说说它的数据结构吗？ HashMap作为一种容器类型，无论你是否了解过其内部的实现原理，它的大名已经频频出现在各种互联网Java面试题中了。从基本的使用角度来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/marsitman/p/9557152.html</dc:identifier>
</item>
<item>
<title>[三] java虚拟机 JVM字节码 指令集 bytecode 操作码 指令分类用法 助记符 - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9556928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9556928.html</guid>
<description>&lt;div id=&quot;&quot;&gt;&lt;td readability=&quot;106.5&quot;&gt;
&lt;p&gt;&lt;span&gt;dup比较复杂一点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根本含义为复制栈顶的元素然后压入栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过涉及到复制几个元素,以及操作数栈的数据类型,所以比较复杂&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面提到过虚拟机处理的数据类型,有分类,分为1 和2两种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虚拟机能处理的类型long和double为类型2 其余为类型1 也就是int returnAddress  reference等&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;39.5&quot;&gt;
&lt;p&gt;&lt;span&gt;dup      复制操作数栈栈顶一个元素  并且将这个值压入到栈顶   value必须分类1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式如下,右侧为栈顶&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;... , value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;... , value , value&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;dup_x1 复制操作数栈栈顶的一个元素.并插入到栈顶以下  两个值之后   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式如下,右侧为栈顶,value1 插入到了第二个元素value2 下面  value1 和value2  必须分类1&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;... , value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;... , value1, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;dup_x2 复制操作数栈栈顶的一个元素. 并插入栈顶以下 2 个 或 3个值之后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式一 如果 value3, value2, value1  全都是分类1  使用此形式  插入栈顶三个值 以下 也就是value3之下&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value3, value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value1, value3, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式二如果value1 是分类1   value2 是分类2  那么使用此形式 插入栈顶两个值 以下,也就是value2 之下&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value1, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;dup2  复制操作数栈栈顶一个或者两个元素,并且按照原有顺序,入栈到操作数栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式一 如果  value2, value1 全都是分类1  使用此形式 复制栈顶两个元素,按照原顺序,插入到栈顶&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式二 如果value 属于分类2 使用此形式 复制栈顶一个元素,插入到栈顶&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;..., value →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value, value&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;dup2_x1复制操作数栈栈顶一个或者两个元素,并且按照原有顺序   插入栈顶以下  两个或者三个 值  之后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式一   如果  value3, value2, value1 都是分类1 使用此形式 复制两个元素,插入栈顶下 三个值之后,也就是value3 之后&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value3, value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1, value3, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式二 如果value1 是分类2 value2 是分类1 使用此形式   复制一个元素,插入到栈顶以下 两个元素之后 &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value1, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;dup_x2  复制操作数栈栈顶一个或者两个元素,并且按照原有顺序   插入栈顶以下  两个或者三个 或者四个   值  之后&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;形式一   全都是分类1  使用此形式  复制两个元素,插入到栈顶 第四个值后面&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value4, value3, value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1, value4, value3, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式二 如果 value1 是分类2   value2 和 value3 是分类1 中的数据类型  使用此形式 复制一个元素 插入到栈顶 第三个值后面&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value3, value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value1, value3, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式三 如果value 1  value2 是分类1   value3 是分类2 使用此形式 复制两个元素 插入到栈顶 第三个值后面&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value3, value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1, value3, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;形式四 当value1 和value2 都是分类2 使用此形式  复制一个元素 插入到栈顶 第二个值后面&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;..., value2, value1 →&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;..., value1, value2, value1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;td readability=&quot;71.5&quot;&gt;&lt;span&gt;上面关于dup的描述摘自 虚拟机规范,很难理解&lt;/span&gt;&lt;br/&gt;&lt;span&gt;看起来是非常难以理解的,不妨换一个角度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们知道局部变量的空间分配分为两种long 和 double 占用2个slot  其他占用一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;操作数栈,每个单位可以表示虚拟机支持的任何的一个数据类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不过操作数栈其实同局部变量一样,他也是被组织一个数组, 每个元素的数据宽度和局部变量的宽度是一致的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以对于long 和double占用2个单位长度  对于其他类型占用一个单位长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;虽然外部呈现上任何一个操作数栈可以表示任何一种数据类型,但是内部是有所区分的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如同局部变量表使用两个单位存储时,访问元素使用两个中索引小的那个类似的道理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以可以把栈理解成线性的数组,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;来一个long或者double 就分配两个单位空间作为一个元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其余类型就分配一个单位空间作为元素&lt;/span&gt;&lt;p&gt;&lt;span&gt;既然栈本身的结构中,线性空间的最小单位的数据宽度同局部变量,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;long和double占用两个  也就是下面涉及说到的数据类型的分类1  和  分类2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设栈的示意结构如下图所示,(只是给出来一种可能每个元素的类型都可能是随机的)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左边表示呈现出来的栈元素 右边是内部的线性形式  我们当做数组好了&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211942888-1237297386.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3c9b&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211943149-1235406783.png&quot; alt=&quot;image_5b869c5d_3c9b&quot; width=&quot;397&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对栈元素的处理,显然指的是对于栈元素内部数组的处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以自然要分为    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到底是直接复制一个单位的数据        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是直接复制两个单位的数据 &lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一次复制占用一个单位空间   的指令 使用dup  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一次复制占用两个单位空间   的指令 使用dup2&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一次复制占用一个单位空间 时 假设复制的栈顶是array[0] &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dup 可以理解为dup_x0    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入到他栈顶的内部线性结构的第(1+0)个元素下面 所以array[0] 对应的必然是一个完整的栈元素 ,必然是分类1 不可能是分类2的一半!&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211943402-1981415796.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_24b7&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211943632-1601051365.png&quot; alt=&quot;image_5b869c5d_24b7&quot; width=&quot;706&quot; height=&quot;207&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;p&gt;&lt;span&gt;dup_x1                           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入到他栈顶的内部线性结构的第(1+1)个元素下面 也就是插到第二个下面  因为array[0] 对应value1为分类1  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果接下来的是分类2的数据,必然接下来的两个单元array[1] 和array[2]是不可分割的,也就是不可能插入到array[1] 后面,所以array[1] 对应value2 也必须是分类1 也就是两个都是分类1&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211943839-1022001567.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_5c27&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211944055-1729354563.png&quot; alt=&quot;image_5b869c5d_5c27&quot; width=&quot;680&quot; height=&quot;214&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;dup_x2                          &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入到他栈顶的内部线性结构的第(1+2)个元素下面 也就是插到第三个后面,array[0] 对应value1为分类1 为分类1  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么接下来的两个单位array[1] 和array[2],可以是一个分类2  也可以是两个分类1,都是可以的&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211944376-74738569.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3651&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211944603-601341154.png&quot; alt=&quot;image_5b869c5d_3651&quot; width=&quot;704&quot; height=&quot;229&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211944858-1946933618.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_7212&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211945119-1732214990.png&quot; alt=&quot;image_5b869c5d_7212&quot; width=&quot;692&quot; height=&quot;298&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;span&gt;一次复制占用两个单位的数据类型 时&lt;/span&gt;&lt;p&gt;&lt;span&gt;dup2 可以理解为dup2_x0   &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;插入到他栈顶的内部线性结构的第(2+0)个元素下面 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一次复制的两个单位array[0] 和 array[1],  到 array[1]下面  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能是对应value1 和value2 表示两个分类1  也可能是对应一个value1 表示类型为分类2 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211945360-1907355269.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3101&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211945603-1559108988.png&quot; alt=&quot;image_5b869c5d_3101&quot; width=&quot;713&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211945846-1560481165.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_6ad0&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211946098-131767083.png&quot; alt=&quot;image_5b869c5d_6ad0&quot; width=&quot;723&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;dup2_x1   插入到他栈顶的内部线性结构的第(2+1)个元素下面 也就是复制array[0] 和 array[1] 到第三个元素 array[2]的下面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;array[0] 和 array[1] 可能分别对应value1 和value2 表示两个分类1 数据  也可能是对应着一个value1表示一个分类2数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是array[2] 作为第三个单位,既然能被分割,自然他必须是分类1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以要么三个都是分类1,要么value1 分类2  value2 分类1&lt;/span&gt;&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211946399-2041558767.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3201&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211946631-146819796.png&quot; alt=&quot;image_5b869c5d_3201&quot; width=&quot;704&quot; height=&quot;296&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211946892-373598599.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3543&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211947201-1357209470.png&quot; alt=&quot;image_5b869c5d_3543&quot; width=&quot;674&quot; height=&quot;295&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;p&gt;&lt;span&gt;dup2_x2  插入到他栈顶的内部线性结构的第(2+2)个元素下面 也就是复制array[0] 和 array[1] 到第四个内部元素 array[3]的下面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一次复制两个,放到第四个下面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这种情形下的组合就非常多了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;全都是分类1的数据&lt;/span&gt;&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211947449-225431035.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_3cea&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211947693-947355492.png&quot; alt=&quot;image_5b869c5d_3cea&quot; width=&quot;683&quot; height=&quot;293&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全部都是分类2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;array[0]  和 array[1]  对应value1 表示一个分类2数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;array[2]  和 array[3]     对应value2 表示一个分类2数据&lt;/span&gt;&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211947941-1608308157.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_5ddd&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211948212-905939192.png&quot; alt=&quot;image_5b869c5d_5ddd&quot; width=&quot;717&quot; height=&quot;262&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;array[0]  和 array[1]  对应value1 表示一个分类2数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;array[2]  和 array[3]     对应value2 和 value3表示两个分类1数据&lt;/span&gt;&lt;/p&gt;
&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211948454-1600452043.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_4ebd&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211948702-633327856.png&quot; alt=&quot;image_5b869c5d_4ebd&quot; width=&quot;666&quot; height=&quot;277&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;p&gt;&lt;span&gt;array[0]  和 array[1]  对应value1 和value2 表示两个分类1 数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;array[2]  和 array[3]    对应value3表示一个分类2数据&lt;/span&gt;&lt;/p&gt;
&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211948972-1002664968.png&quot;&gt;&lt;img title=&quot;image_5b869c5d_4ea4&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180829211949249-557378569.png&quot; alt=&quot;image_5b869c5d_4ea4&quot; width=&quot;672&quot; height=&quot;277&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;p&gt;&lt;span&gt;所以说只需要明确以下几点,就不难理解dup指令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;操作数栈指令操作的是栈内部的存储单元,而不是以一个栈元素为单位的&lt;br/&gt;long和double在栈元素内部需要两个存储单元,其余一个存储单元&lt;br/&gt;两个相邻的内部单位组合起来表示一个栈元素时,是不能拆分的&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;再回过头看,所有的dup指令,不过是根据栈元素的实际存放的类型的排列组合,梳理出来的一些复制一个或者两个栈顶元素的实际操作方式而已&lt;br/&gt;就是因为他是逆向推导的,所以看起来不好理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 29 Aug 2018 13:20:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>字节码指令集是了解学习虚拟机运行的必须步骤,本文详细的介绍了绝大多数的字节码指令,从多个维度对字节码指令进行了解析说明,并且对字节码指令集助记符进行了更加详细的释义. 本文主要涉及jvm的字节码指令</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9556928.html</dc:identifier>
</item>
<item>
<title>nginx反向代理跨域基本配置与常见误区 - 木子墨</title>
<link>http://www.cnblogs.com/heioray/p/9529566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heioray/p/9529566.html</guid>
<description>&lt;p&gt;最近公司前后端分离，前端独立提供页面和静态服务很自然的就想到了用nginx去做静态服务器。同时由于跨域了，就想利用nginx的反向代理去处理一下跨域，但是在解决问题的同时，发现网上有些方案的确是存在一些问题，在这里总结一下基本配置，也聊一下常见的配置问题。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;nginx接口服务反向代理基本配置&quot;&gt;Nginx接口服务反向代理基本配置&lt;/h3&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
    listen 8443; # 监听的端口号
    server_name a.test.com; # 服务器名称
    client_max_body_size 100m;   # 定义读取客户端请求头的超时时间
    ssl on;
    ssl_certificate test.pem;
    ssl_certificate_key test.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1.2;
    ssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;
    ssl_prefer_server_ciphers on;
    location / {
        root /test-static-app; # 静态资源目录
        index index.html index.htm;
        try_files $uri $uri/ /index.html; # 动态解析目录，配合vue的history模式
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本配置实现了页面及静态服务器的基本功能，并可以实现使用vue的history模式时的路由解析。进一步的，为了实现向接口服务器的统一转发，我们需要和后端开发人员规定接口名的前缀，比如所有接口的相对路径都以api开头，此时我们可以添加如下配置(和上一个location平级)，&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;...
location /api {
   proxy_pass https://b.test.com; # 设置代理服务器的协议和地址
   proxy_cookie_domain b.test.com  a.test.com; # 修改cookie，针对request和response互相写入cookie
}       
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中主要依赖proxy_pass，实现将a.test.com下的/api/x接口转发到了b.test.com下面，这个过程大致如下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/461976/201808/461976-20180829202604273-241278886.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cookie的交互主要就是proxy_cookie_domain，加上下面这段&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;proxy_cookie_domain b.test.com  a.test.com; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个实现了，a.test.com和b.test.com域名之间cookie的传递与回写。&lt;/p&gt;
&lt;p&gt;如果用node来模拟一下的话，大致如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports =  (router) =&amp;gt; {
  router.get('/api/index/getCmsInfo', async function (ctx, next) {
    // 接口转发
    let result = await superagent.post('https://b.test.com/api/card/home').set(browserMsg)
    // 获取返回的set-cookie，并设置header
    let setCookie = result.headers['set-cookie']
    if (setCookie) {
        ctx.response.header['set-cookie'] = setCookie
    }
    // 返回
    ctx.response.body={
        success: true,
        result: result.body 
    }
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;综上nginx反向代理的本质其实就是接口服务的转发与header的处理，仔细想想也就容易理解了。&lt;/p&gt;
&lt;h3 id=&quot;常见误区&quot;&gt;常见误区&lt;/h3&gt;
&lt;p&gt;1、无用的ACA-Header ？&lt;br/&gt;网上很多的nginx跨域设置里面都加了跨域header设置相关的内容，比如&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;add_header 'Access-Control-Allow-Origin' '*';
add_header 'Access-Control-Allow-Credentials' &quot;true&quot;; 
add_header Access-Control-Allow-Headers X-Requested-With;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想想上面的原理，各位看官觉得这个还有用么？ACA(Access-Control-Allow-)系列的header本身是为了cors中做协商跨域而配置的，在这里配这个纯属脱裤子放屁多此一举。&lt;br/&gt;2、proxy_pass 域名带不带‘斜杠/’ ？&lt;br/&gt;同样的，在网上看到了有的网友在配置proxy_pass的时候，会在后面加一个斜杠，如下，然后说报错啦，找不到接口啦～咋整啊～&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;...
location /api {
   #proxy_pass https://b.test.com;
   proxy_pass https://b.test.com/;
}       
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这个我们来想一想哈，proxy_pass的作用是抓发，加了斜杠意味着所有的&lt;strong&gt;/api&lt;/strong&gt;请求都会转发到根目录下，也就是说 &lt;strong&gt;/api&lt;/strong&gt; 会被 &lt;strong&gt;/&lt;/strong&gt; 替代，这个时候接口路径就变了，少了一层&lt;strong&gt;/api&lt;/strong&gt;。而不加斜杠的时候呢？这代表着转发到&lt;strong&gt;b.test.com&lt;/strong&gt; 的域名下，&lt;strong&gt;/api&lt;/strong&gt;的路径不会丢失。&lt;br/&gt;针对这种情况，如果后端接口统一有了规定前缀，比如&lt;strong&gt;/api&lt;/strong&gt;，那你这里就不要配置斜杠了。另一种情况，后端接口shit一样，没有统一前缀，这边又要区分，那就在前端所有接口都加一个统一前缀，比如&lt;strong&gt;/api&lt;/strong&gt;，然后通过加&lt;strong&gt;斜杠&lt;/strong&gt;来替换掉好了～&lt;/p&gt;
&lt;p&gt;以上就是本次的全部内容了～今天的《新闻联播》播送完了，谢谢收看，再见～再见～&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 13:02:00 +0000</pubDate>
<dc:creator>木子墨</dc:creator>
<og:description>最近公司前后端分离，前端独立提供页面和静态服务很自然的就想到了用nginx去做静态服务器。同时由于跨域了，就想利用nginx的反向代理去处理一下跨域，但是在解决问题的同时，发现网上有些方案的确是存在一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heioray/p/9529566.html</dc:identifier>
</item>
</channel>
</rss>