<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python的进程、线程、协程 - 快乐水</title>
<link>http://www.cnblogs.com/kangyuqi/p/9323789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangyuqi/p/9323789.html</guid>
<description>&lt;h3 id=&quot;从操作系统角度&quot;&gt;从操作系统角度&lt;/h3&gt;
&lt;p&gt;操作系统处理任务，调度单位是&lt;strong&gt;进程&lt;/strong&gt;和&lt;strong&gt;线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：表示一个程序的执行活动（打开程序、读写程序数据、关闭程序）&lt;br/&gt;&lt;strong&gt;线程&lt;/strong&gt;：执行某个程序时，该进程调度的最小执行单位（执行功能1，执行功能2）&lt;/p&gt;
&lt;p&gt;一个程序至少有一个进程，一个进程至少有一个线程。&lt;/p&gt;
&lt;p&gt;并行：&lt;br/&gt;需要处理的任务数 == CPU核心数量&lt;/p&gt;
&lt;p&gt;两个任务，两个核心&lt;/p&gt;
&lt;p&gt;任务1：-------------&lt;br/&gt;任务2：-------------&lt;/p&gt;
&lt;p&gt;并发：&lt;br/&gt;需要处理的任务数 &amp;gt; CPU核心数量&lt;/p&gt;
&lt;p&gt;三个任务，一个核心&lt;br/&gt;任务1: ----- ------&lt;br/&gt;任务2: ------&lt;br/&gt;任务3: ------&lt;/p&gt;
&lt;h3 id=&quot;从程序角度&quot;&gt;从程序角度&lt;/h3&gt;
&lt;p&gt;多进程、多线程&lt;br/&gt;表示当前程序可以同时执行多个任务&lt;/p&gt;
&lt;p&gt;进程和线程都是由操作系统调度完成。&lt;/p&gt;
&lt;h4 id=&quot;进程&quot;&gt;进程：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每个进程都有自己独立的内存空间，不同进程之间的内存空间不能共享。&lt;/li&gt;
&lt;li&gt;不同进程之间的通信由 操作系统 完成。&lt;/li&gt;
&lt;li&gt;不同进程之间的通信效率低下，切换开销大。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;线程&quot;&gt;线程：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;一个进程下可以有多个线程，同一个进程内的线程可以共享内存空间.&lt;/li&gt;
&lt;li&gt;不同线程之间的通信 有进程 管理。&lt;/li&gt;
&lt;li&gt;不同线程之间的通信效率高，切换开销小。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;互斥锁&quot;&gt;互斥锁：&lt;/h4&gt;
&lt;p&gt;共享意味着多个线程的竞争，会导致不安全问题。&lt;br/&gt;为了保护内存空间的数据不被多个线程同时读写，导致数据隐患，于是诞生了&quot;互斥锁&quot;。&lt;/p&gt;
&lt;p&gt;&quot;互斥锁&quot;：一种安全有序的让多个线程访问进程内存空间的机制。&lt;br/&gt;当一个线程在访问进程内存空间时，互斥锁可以防止其他线程访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;解释型语言：执行程序时，解释器按行执行程序内容，执行时检查问题。
编译型语言：通过编译器将程序编译为一个可执行文件，执行前检查问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;python中的多线程&quot;&gt;Python中的多线程：&lt;/h4&gt;
&lt;p&gt;GIL(全局解释器锁)：同一时刻只能有一个线程在运行。&lt;/p&gt;
&lt;p&gt;坏处：多线程不能充分利用多核CPU资源。&lt;br/&gt;好处：从根本上杜绝了多线程访问内存空间的安全问题。&lt;/p&gt;
&lt;p&gt;Python的多线程不适合并行，但非常适合并发。&lt;/p&gt;
&lt;p&gt;Python的多线程在遇到 IO阻塞函数执行，会自动释放GIL，让后面的线程执行任务。&lt;br/&gt;如果没有 IO 操作，那么解释器会每隔100次操作后，强制释放GIL，让后面的线程执行。&lt;br/&gt;import sys&lt;br/&gt;sys.getcheckinterval()&lt;/p&gt;
&lt;h4 id=&quot;多进程&quot;&gt;多进程：&lt;/h4&gt;
&lt;p&gt;适用于密集CPU任务，可以充分调度CPU资源（大量的并行运算）。&lt;br/&gt;multiprocessing&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;缺点：不适用于需要大量数据通信和多次切换的场景，因为进程之间通信和切换成本高。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多线程&quot;&gt;多线程：&lt;/h4&gt;
&lt;p&gt;适用于密集IO任务（网络IO，磁盘IO，数据库IO），在IO阻塞时可以切换线程执行。&lt;br/&gt;threading.Thread、multiprocessing.dummy&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;缺点：同一个CPU时间片只能执行一个任务，不能做到并行，只能做到并发。
优点：线程之间切换和通信非常方便，开销小。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;协程&quot;&gt;协程：&lt;/h4&gt;
&lt;p&gt;由程序员自行编写调度功能，切换协程就好比切换一个函数，几乎没有切换开销。&lt;br/&gt;特点是在单线程上执行多个任务，调度由程序员控制，不经过操作系统，所以没有进程线程的切换开销，也不需要处理锁。&lt;br/&gt;gevent&lt;br/&gt;monkey.patch_all()&lt;/p&gt;
&lt;p&gt;monkey的作用是将Python底层的网络库socket、select自动打个补丁，程序在遇到网络IO阻塞时，可以自动切换协程工作。（该补丁不适用于本地IO）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;优点：协程任务是基于用户的，不经过操作系统，执行效率极高。
缺点：单线程执行，不能处理 CPU密集任务，和密集本地IO任务。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 17 Jul 2018 07:55:00 +0000</pubDate>
<dc:creator>快乐水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangyuqi/p/9323789.html</dc:identifier>
</item>
<item>
<title>Java并发编程笔记之基础总结(一) - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9323717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9323717.html</guid>
<description>&lt;h3&gt;一.线程概念&lt;/h3&gt;
&lt;p&gt;说到线程就必须要提一下进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程是共享进程的资源的。操作系统在分配资源时候是把资源分配给进程的，但是 CPU 资源就比较特殊，它是分派到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。&lt;/p&gt;
&lt;p&gt;Java 中当我们启动 main 函数时候其实就启动了一个 JVM 的进程，而 main 函数所在线程就是这个进程中的一个线程，也叫做主线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717144405282-644371607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器，栈区域。、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其中程序计数器是一块内存区域，用来记录线程当前要执行的指令地址，那么程序计数器为何要设计为线程私有的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面说了线程是占用 CPU 执行的基本单位，而 CPU 一般是使用时间片轮转方式让线程轮询占用的，所以当前线程 CPU 时间片用完后，要让出 CPU，等下次轮到自己时候在执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么如何知道之前程序执行到哪里了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实程序计数器就是为了记录该线程让出 CPU 时候的执行地址，待再次分配到时间片时候就可以从自己私有的计数器指定地址继续执行了。&lt;/p&gt;

&lt;p&gt;另外每个线程有自己的栈资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其它线程是访问不了的，另外栈还用来存放线程的调用栈帧。&lt;/p&gt;
&lt;p&gt;堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时候分配的，堆里面主要存放使用 new 操作创建的对象实例。&lt;/p&gt;
&lt;p&gt;方法区则是用来存放进程中的代码片段的，是线程共享的。&lt;/p&gt;

&lt;h3&gt;二.线程创建方式与运行&lt;/h3&gt;
&lt;p&gt;Java 中有三种线程创建方法，分别为实现 Runnable 接口的run方法、继承 Thread 类并重写 run 方法、使用 FutureTask 方式。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.继承 Thread 方法的实现，如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadTest {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承Thread类并重写run方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread extends Thread {

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----子线程-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程&lt;/span&gt;
        MyThread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;        thread.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717145115016-1424696923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码 MyThread 类继承了 Thread 类，并重写了 run 方法，然后调用了线程的 start 方法启动了线程，当创建完 thread 对象后该线程并没有被启动执行.当调用了 start 方法后才是真正启动了线程。其实当调用了 start 方法后线程并没有马上执行而是处于就绪状态，这个就绪状态是指该线程已经获取了除 CPU 资源外的其它资源，等获取 CPU 资源后才会真正处于运行状态。&lt;/p&gt;
&lt;p&gt;当 run 方法执行完毕，该线程就处于终止状态了。使用继承方式好处是 run 方法内获取当前线程直接使用 this 就可以，无须使用 Thread.currentThread() 方法，不好的地方是 Java 不支持多继承，如果继承了 Thread 类那么就不能再继承其它类，另外任务与代码没有分离，当多个线程执行一样的任务时候需要多份任务代码，而 Runable 则没有这个限制。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.实现 Runnable 接口的 run 方法方式，例子如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunableTest implements Runnable {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----子线程----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException{

        RunableTest runableTest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunableTest();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runableTest).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runableTest).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717145851048-241843848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上面代码，两个线程公用一个 task 代码逻辑，需要的话 RunableTask 可以添加参数进行任务区分，另外 RunableTask 可以继承其他类，但是上面两种方法都有一个缺点就是任务没有返回值，&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.使用 FutureTask方式，例子如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FutureTaskTest implements Callable&amp;lt;String&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String call() throws Exception {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建异步任务&lt;/span&gt;
        FutureTask&amp;lt;String&amp;gt; futureTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FutureTaskTest());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(futureTask).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待任务执行完毕，并返回结果&lt;/span&gt;
            String result = futureTask.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717150327328-847746753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：每种方式都有自己的优缺点，应该根据实际场景进行选择&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;三.线程通知与等待&lt;/h3&gt;
&lt;p&gt;Java 中 Object 类是所有类的父类，鉴于继承机制，Java 把所有类都需要的方法放到了 Object 类里面，其中就包含本节要讲的通知等待系列函数,这些通知等待函数是组成并发包中线程同步组件的基础。&lt;/p&gt;
&lt;p&gt;下面讲解下 Object 中关于线程同步的通知等待函数。如下所示：&lt;/p&gt;
&lt;p&gt;　　1.void wait() 方法：首先谈下什么是共享资源，所谓共享资源是说该资源被多个线程共享，多个线程都可以去访问或者修改的资源。当一个线程调用一个共享对象的 wait() 方法时候，调用线程会被阻塞挂起，直到下面几个事情之一发生才返回：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;其它线程调用了该共享对象的 notify() 或者 notifyAll() 方法；&lt;/li&gt;
&lt;li&gt;其它线程调用了该线程的 interrupt() 方法设置了该线程的中断标志，该线程会抛出 InterruptedException 异常返回&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外需要注意的是如果调用 wait() 方法的线程没有事先获取到该对象的监视器锁，则调用 wait() 方法时候调用线程会抛出 IllegalMonitorStateException 异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么一个线程如何获取到一个共享变量的监视器呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.执行使用 synchronized 同步代码块时候，使用该共享变量作为参数，例子如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronized（共享变量）{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doSomething&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2.调用该共享变量的方法，并且该方法使用了 synchronized 修饰，代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
synchronized &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doSomething&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外需要注意的是一个线程可以从挂起状态变为可以运行状态（也就是被唤醒）即使该线程没有被其它线程调用 notify()，notifyAll() 进行通知，或者被中断，或者等待超时，这就是所谓的&lt;strong&gt;虚假唤醒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然虚假唤醒在应用实践中很少发生，但是还是需要防范于未然的，做法就是不停的去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中去调用 wait() 方法进行防范，退出循环的条件是条件满足了唤醒该线程。代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; synchronized (obj) {
     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (条件不满足){
         obj.wait();  
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码是经典的调用共享变量 wait() 方法的实例，首先通过同步块获取 obj 上面的监视器锁，然后通过 while 循环内调用 obj 的 wait() 方法。&lt;/p&gt;
&lt;p&gt;下面从生产者消费者例子来加深理解，例子如下：&lt;/p&gt;
&lt;p&gt;　　生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产线程&lt;/span&gt;
&lt;span&gt;synchronized (queue) { 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费队列满，则等待队列空闲&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (queue.size() ==&lt;span&gt; MAX_SIZE) { 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; { 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起当前线程，并释放通过同步块获取的queue上面的锁，让消费线程可以获取该锁，然后获取队列里面元素&lt;/span&gt;
&lt;span&gt;            queue.wait(); 
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) { 
            ex.printStackTrace(); 
        } 
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空闲则生成元素，并通知消费线程&lt;/span&gt;
&lt;span&gt;    queue.add(ele); 
    queue.notifyAll(); 

    } 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费线程&lt;/span&gt;
&lt;span&gt;synchronized (queue) { 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费队列为空&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (queue.size() == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;try {&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起当前线程，并释放通过同步块获取的queue上面的锁，让生产线程可以获取该锁，生产元素放入队列&lt;/span&gt;
&lt;span&gt;            queue.wait(); 
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) { 
            ex.printStackTrace(); 
        } 
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费元素，并通知唤醒生产线程&lt;/span&gt;
&lt;span&gt;    queue.take(); 
    queue.notifyAll();  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面代码所示是一个生产者的例子，其中 queue 为共享变量，生产者线程在调用 queue 的 wait 方法前，通过使用 synchronized 关键字拿到了该共享变量 queue 的监视器，所以调用 wait() 方法才不会抛出 IllegalMonitorStateException 异常，如果当前队列没有空闲容量则会调用 queued 的 wait() 挂起当前线程，这里使用循环就是为了避免上面说的虚假唤醒问题，这里假如当前线程虚假唤醒了，但是队列还是没有空余容量的话，当前线程还是会调用 wait() 把自己挂起。&lt;/p&gt;
&lt;p&gt;另外当一个线程调用了共享变量的 wait() 方法后该线程会被挂起，同时该线程会暂时释放对该共享变量监视器的持有，直到另外一个线程调用了共享变量的 notify() 或者 notifyAll() 方法才有可能会重新获取到该共享变量的监视器的持有权（这里说有可能，是因为考虑到多个线程第一次都调用了 wait() 方法，所以多个线程会竞争持有该共享变量的监视器）。、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来讲解下调用共享变量 wait() 方法后当前线程会释放持有的共享变量的锁的理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上代码假如生产线程 A 首先通过 synchronized 获取到了 queue 上的锁，那么其它生产线程和所有消费线程都会被阻塞，线程 A 获取锁后发现当前队列已满会调用 queue.wait() 方法阻塞自己，然后会释放获取的 queue 上面的锁，这里考虑下为何要释放该锁？如果不释放，由于其它生产线程和所有消费线程已经被阻塞挂起，而线程 A 也被挂起，这就处于了死锁状态。这里线程 A 挂起自己后释放共享变量上面的锁就是为了打破死锁必要条件之一的持有并等待原则。关于死锁下面章节会有讲到，线程 A 释放锁后其它生产线程和所有消费线程中会有一个线程获取 queue 上的锁进而进入同步块，这就打破了死锁。&lt;/p&gt;
&lt;p&gt;最后再举一个例子说明当一个线程调用共享对象的 wait() 方法被阻塞挂起后，如果其它线程中断了该线程，则该线程会抛出 InterruptedException 异常后返回,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitNotifyInteruptTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程&lt;/span&gt;
        Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---开始---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞当前线程&lt;/span&gt;
&lt;span&gt;                    obj.wait();
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---结束---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        threadA.start();

        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---开始打断线程A---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        threadA.interrupt();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---线程A已经被打断---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717151858833-1820658209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码 threadA 调用了共享对 obj 的 wait（） 方法后阻塞挂起了自己，然后主线程在休眠1s后中断了 threadA 线程，可知中断后 threadA 在 obj.wait() 处抛出了 java.lang.IllegalMonitorStateException 异常后返回后终止。&lt;/p&gt;

&lt;p&gt;　　2.void wait(long timeout) 方法：该方法相比 wait() 方法多一个超时参数，不同在于如果一个线程调用了共享对象的该方法挂起后，如果没有在指定的 timeout ms 时间内被其它线程调用该共享变量的 notify() 或者 notifyAll() 方法唤醒，那么该函数还是会因为超时而返回。需要注意的是如果在调用该函数时候 timeout 传递了负数会抛出 IllegalArgumentException 异常。&lt;/p&gt;

&lt;p&gt;　　3.void wait(long timeout, int nanos) 方法：内部是调用 wait(long timeout)，如下代码：只是当 nanos&amp;gt;0 时候让参数一递增1。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt; wait(&lt;span&gt;long&lt;/span&gt; timeout, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nanos) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeout &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timeout value is negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt; &lt;span&gt;0&lt;/span&gt; || nanos &amp;gt; &lt;span&gt;999999&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nanosecond timeout value out of range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            timeout&lt;/span&gt;++&lt;span&gt;;
        }

        wait(timeout);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4.void notify() 方法：一个线程调用共享对象的 notify() 方法后，会唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程，一个共享变量上可能会有多个线程在等待，具体唤醒哪一个等待的线程是随机的。另外被唤醒的线程不能马上从 wait 返回继续执行，它必须获取了共享对象的监视器后才可以返回,也就是唤醒它的线程释放了共享变量上面的监视器锁后，被唤醒它的线程也不一定会获取到共享对象的监视器，这是因为该线程还需要和其它线程一块竞争该锁，只有该线程竞争到了该共享变量的监视器后才可以继续执行。&lt;/p&gt;
&lt;p&gt;类似 wait 系列方法，只有当前线程已经获取到了该共享变量的监视器锁后，才可以调用该共享变量的 notify() 方法，否者会抛出 IllegalMonitorStateException 异常。&lt;/p&gt;

&lt;p&gt;　　5.void notifyAll() 方法：不同于 nofity() 方法在共享变量上调用一次就会唤醒在该共享变量上调用 wait 系列方法被挂起的一个线程，notifyAll() 则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。&lt;/p&gt;
&lt;p&gt;最后讲一个例子来说明 notify() 和 notifyAll() 的具体含义和一些需要注意的地方，代码实例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test1 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Object resourceA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程&lt;/span&gt;
        Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取resourceA共享资源的监视器锁&lt;/span&gt;
&lt;span&gt;                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadA get resourceA lock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadA begin wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        resourceA.wait();
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadA end wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                        e.printStackTrace();
                    }
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadB get resourceA lock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadB begin wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        resourceA.wait();
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadB end wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                        e.printStackTrace();
                    }
                }
            }

        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程&lt;/span&gt;
        Thread threadC = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadC begin notify&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    resourceA.notifyAll();
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;        threadA.start();
        threadB.start();

        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        threadC.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待线程结束&lt;/span&gt;
&lt;span&gt;        threadA.join();
        threadB.join();
        threadC.join();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717152843250-408942995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上代码开启了三个线程，其中线程 A 和 B 分别调用了共享资源 resourceA 的 wait() 方法，线程 C 则调用了 nofity() 方法。&lt;/p&gt;
&lt;p&gt;这里启动线程 C 前首先调用 sleep 方法让主线程休眠 1s，目的是让线程 A 和 B 全部执行到调用 wait 方法后在调用线程 C 的 notify 方法。&lt;/p&gt;
&lt;p&gt;这个例子企图希望在线程 A 和线程 B 都因调用共享资源 resourceA 的 wait() 方法而被阻塞后，线程 C 在调用 resourceA 的 notify() 方法，希望可以唤醒线程 A 和线程 B，但是从执行结果看只有一个线程 A 被唤醒了，线程 B 没有被唤醒，&lt;/p&gt;
&lt;p&gt;从结果看线程调度器这次先调度了线程 A 占用 CPU 来运行，线程 A 首先获取 resourceA 上面的锁，然后调用 resourceA 的 wait() 方法挂起当前线程并释放获取到的锁，然后线程 B 获取到 resourceA 上面的锁并调用了 resourceA 的 wait()，此时线程 B 也被阻塞挂起并释放了 resourceA 上的锁。&lt;/p&gt;
&lt;p&gt;线程 C 休眠结束后在共享资源 resourceA 上调用了 notify() 方法，则会激活 resourceA 的阻塞集合里面的一个线程，这里激活了线程 A，所以线程 A 调用的 wait() 方法返回了，线程 A 执行完毕。而线程 B 还处于阻塞状态。&lt;/p&gt;
&lt;p&gt;如果把线程 C 里面调用的 notify() 改为调用 notifyAll() 而执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717152906848-1546781558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知线程 A 和线程 B 被挂起后，线程 C 调用 notifyAll() 函数会唤醒在 resourceA 等待的所有线程，这里线程 A 和线程 B 都会被唤醒，只是线程 B 先获取到 resourceA 上面的锁然后从 wait() 方法返回，等线程 B 执行完毕后，线程 A 又获取了 resourceA 上面的锁，然后从 wait() 方返回，当线程 A 执行完毕，主线程就返回后，然后打印输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：在调用具体共享对象的 wait 或者 notify 系列函数前要先获取共享对象的锁；另外通知和等待是实现线程同步的原生方法，理解它们的协作功能很有必要；最后由于线程虚假唤醒的存在，一定要使用循环检查的方式。&lt;/p&gt;

&lt;p&gt;　　6.等待线程执行终止的 join 方法：在项目实践时候经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程去加载资源，当多个线程全部加载完毕后在汇总处理，Thread 类中有个静态的 join 方法就可以做这个事情，前面介绍的等待通知方法是属于 Object 类的，而 join 方法则是直接在 Thread 类里面提供的，join 是无参，返回值为 void 的方法。下面看一个简单的例子来介绍 join 的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test3 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        Thread threadOne &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadOne over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        });

        Thread threadTwo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadTwo over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线程&lt;/span&gt;
&lt;span&gt;        threadOne.start();
        threadTwo.start();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wait all child thread over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子线程执行完毕，返回&lt;/span&gt;
&lt;span&gt;        threadOne.join();
        threadTwo.join();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;all child thread over!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717153244842-1043675682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如代码主线程里面启动了两个子线程，然后在分别调用了它们的 join() 方法，那么主线程首先会阻塞到 threadOne.join() 方法，等 threadOne 执行完毕后返回，threadOne 执行完毕后 threadOne.join() 就会返回，然后主线程调用 threadTwo.join() 后再次被阻塞，等 threadTwo 执行完毕后主线程也就返回了。这里只是为了演示 join 的作用，对应这类需求后面会讲的 CountDownLatch 是不错选择。&lt;/p&gt;
&lt;p&gt;另外线程 A 调用线程 B 的 join 方法后会被阻塞，当其它线程调用了线程 B 的 interrupt() 方法中断了线程 B 时候，线程 B 会抛出 InterruptedException 异常而返回，下面通过一个例子来加深理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test4 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程one&lt;/span&gt;
        Thread threadOne = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;threadOne begin run!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取主线程&lt;/span&gt;
        final Thread mainThread =&lt;span&gt; Thread.currentThread();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程two&lt;/span&gt;
        Thread threadTwo = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;休眠1s&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断主线程&lt;/span&gt;
&lt;span&gt;                mainThread.interrupt();
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动子线程&lt;/span&gt;
&lt;span&gt;        threadOne.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟1s启动线程&lt;/span&gt;
&lt;span&gt;        threadTwo.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待线程one执行结束&lt;/span&gt;
&lt;span&gt;            threadOne.join();

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717153431647-2080111072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码 threadOne 线程里面执行死循环，主线程调用 threadOne 的 join 方法阻塞自己等待线程 threadOne 执行完毕，待 threadTwo 休眠 1s 后会调用主线程的 interrupt() 方法设置主线程的中断标志。&lt;/p&gt;
&lt;p&gt;从结果看主线程中 threadOne.join() 处会抛出 InterruptedException 异常而返回。这里需要注意的是 threadTwo 里面调用的是主线程的 interrupt()，而不是线程 threadOne 的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：由于 CountDownLatch 功能比 join 更丰富，所以项目实践中一般使用 CountDownLatch。&lt;/p&gt;

&lt;p&gt;　　7.让线程睡眠的 sleep 方法：Thread 类中有一个静态的 sleep 方法，当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。当指定的睡眠时间到了该函数会正常返回，线程就处于就绪状态，然后参与 CPU 的调度，当获取到了 CPU 资源就可以继续运行了。如果在睡眠期间其它线程调用了该线程的 interrupt() 方法中断了该线程,该线程会在调用 sleep 的地方抛出 InterruptedException 异常返回。&lt;/p&gt;
&lt;p&gt;用一个例子来说明线程在睡眠时候拥有的监视器资源不会被释放是什么意思，例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepTest2 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个独占锁&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final Lock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程A&lt;/span&gt;
        Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取独占锁&lt;/span&gt;
                &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadA is in sleep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    Thread.sleep(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadA is in awaked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
                    &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程B&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取独占锁&lt;/span&gt;
                &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadB is in sleep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Thread.sleep(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child threadB is in awaked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
                    &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;        threadA.start();
        threadB.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717153906856-1369379599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码首先创建了一个独占锁，然后创建了两个线程，每个线程内部先获取锁，然后睡眠，睡眠结束后会释放锁。&lt;/p&gt;
&lt;p&gt;首先无论你执行多少遍上面的代码都是先输出线程 A 的打印或者先输出线程 B 的打印，不会存在线程 A 和线程 B 交叉打印的情况。&lt;/p&gt;
&lt;p&gt;从执行结果看线程 B 先获取了锁，那么线程 B 会先打印一行，然后调用 sleep 让自己沉睡 10s，在线程 B 沉睡的这 10s 内那个独占锁 lock 还是线程 B 自己持有的，线程 A 会一直阻塞直到线程 B 醒过来后执行 unlock 释放锁。&lt;/p&gt;
&lt;p&gt;下面在来看下当一个线程处于睡眠时候如果另外一个线程中断了它，会不会在调用 sleep 处抛出异常。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepInterruptTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程&lt;/span&gt;
        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child thread is in sleep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Thread.sleep(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child thread is in awaked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;        thread.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠2s&lt;/span&gt;
        Thread.sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程中断子线程&lt;/span&gt;
&lt;span&gt;        thread.interrupt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717154204145-1146363481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码在子线程睡眠期间主线程中断了它，所以子线程在调用 sleep 处抛出了 InterruptedException 异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：sleep 方法只是会让调用线程暂时让出指定时间的 CPU 执行权，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 07:44:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9323717.html</dc:identifier>
</item>
<item>
<title>【RL-TCPnet网络教程】第6章    RL-TCPnet底层驱动说明 - 席萌0209</title>
<link>http://www.cnblogs.com/armfly/p/9323540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/9323540.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章节为大家讲解RL-TCPnet的底层驱动，主要是STM32自带MAC的驱动实现和PHY的驱动实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.1  初学者重要提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.2  KEIL提供的底层驱动文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.3  DM9161和DM9162的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.4  底层驱动实现说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.5  总结&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;6.1  初学者重要提示&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、学习本章节前，务必学习STM32参考手册中MAC章节的基础知识讲解，非常重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、DM9161和DM9162的手册可以在官网地址下载，本章节需要用到部分寄存器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.davicom.com.tw/page1.aspx?no=143762&quot;&gt;http://www.davicom.com.tw/page1.aspx?no=143762&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、早期STM32F407开发板使用的PHY芯片是DM9161，不过现在基本已经停产了，当前F407和F429开发板统一使用DM9162。底层代码对这两个芯片都可以正确驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果大家要驱动其它的PHY芯片，需要修改底层驱动函数中以下三个地方：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）根据使用的MII或者RMII接口方式，配置实际使用的引脚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）所有PHY芯片的基本寄存器地址都是一样的，只有扩展寄存器不同，用户需要根据实际情况做修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）如果要使用PHY芯片的中断触发功能，也要根据实际使用的引脚重新配置。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;6.2   KEIL提供的底层驱动文件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在MDK4.74的安装路径C:\Keil_v474\ARM\RL\TCPnet\Drivers已经包含了大量制作好的驱动文件，下面是部分驱动文件的截图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180717151634442-843066715.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些驱动文件主要分为三类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、以太网驱动（Ethernet Driver）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种类型的驱动文件也分为三类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）用芯片自带的MAC驱动外置PHY芯片，比如STM32F407，STM32F429就是这种的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）芯片自带MAC+PHY，这样就不需要外置PHY了，比如LM3S。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）驱动外置的以太网控制器，这种控制器自带MAC+PHY，比如LAN91C111。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、调制解调器驱动（Modem Driver）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种主要是通过PPP或者SLIP方式的网络接口驱动调制解调器。驱动里面提供了Null_Modem.c和Std_Modem.c两种驱动文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、串行驱动（Serial Driver）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种也是采用的PPP或者SLIP方式的驱动，只是驱动接口采用的串口。驱动里面也提供了很多相关的驱动文件，比如Serial_LPC23xx.c，Serial_S3C44B0X.c和Serial_STM32x.c等。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;6.3   DM9161和DM9162的区别&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;早期我们发布的STM32F407开发板的PHY芯片使用的是DM9161，现在这个芯片基本已经停产，所以已经统一改成使用DM9162，这两个型号主要在以下两个地方有区别，其它基本都一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、两个PHY芯片的的ID不一样，DM9161的ID是0x0181B8B1，DM9162的ID是0x0181B8A0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、系统刚上电时，DM9161的ID寄存器支持立即读取，但是DM9162不支持，这一点用户在使用的时候要特别注意。但是DM9161和DM9162都支持立即写寄存器BMCR，所以当前的操作就是直接对寄存器BMCR发复位命令，然后再进行相关设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这两个芯片，了解这两点区别就可以了。另外，这两个芯片的手册和其它的相关知识在这个帖子里面进行了简单的汇总：&lt;a href=&quot;http://bbs.armfly.com/read.php?tid=19577&quot;&gt;http://bbs.armfly.com/read.php?tid=19577&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;6.4  底层驱动实现说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当前教程配套的开发板STM32F407和STM32F429都是采用的RMII接口，即下面这种硬件接口方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180717151646563-188714039.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMII接口降低了 10/100Mbps下微控制器以太网外设与外部PHY间的引脚数。根据IEEE 802.3u标准， MII包括16个数据和控制信号的引脚。RMII规范将引脚数减少为7个（引脚数减少62.5%）。RMII具有以下特性：&lt;br/&gt;（1）支持10Mbps和100Mbps的运行速率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）参考时钟必须是 50 MHz。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）相同的参考时钟必须从外部提供给 MAC 和外部以太网 PHY。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）它提供了独立的2位宽（双位）的发送和接收数据路径，即发生和接收都是占用了两个引脚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据上面的硬件设计，我们需要实现RMII接口用到的引脚配置，STM32的MAC配置以及用到的PHY芯片DM9161/9162的配置。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;6.4.1     STM32F407和STM32F429开发板底层驱动区别&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;STM32F407和STM32F429开发板的底层驱动仅有一个引脚配置不同，其它所有的驱动代码都一样。STM32F407开发板使用的引脚如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

     PA1/ETH_RMII_RX_CLK

     PA2/ETH_MDIO

     PA7/RMII_CRS_DV

     PC1/ETH_MDC

     PC4/ETH_RMII_RX_D0

     PC5/ETH_RMII_RX_D1

     PG11/ETH_RMII_TX_EN

     PG13/FSMC_A24/ETH_RMII_TXD0

     PG14/ETH_RMII_TXD1

     PH6/MII_INT ----- 中断引脚,这里将其用于网线断开或者连接的状态触发

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;STM32F429开发板使用的引脚如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

     PA1/ETH_RMII_RX_CLK

     PA2/ETH_MDIO

     PA7/RMII_CRS_DV

     PC1/ETH_MDC

     PC4/ETH_RMII_RX_D0

     PC5/ETH_RMII_RX_D1

     PG11/ETH_RMII_TX_EN

     PG13/FSMC_A24/ETH_RMII_TXD0

     PB13/ETH_RMII_TXD1

     PH6/MII_INT ----- 中断引脚,这里将其用于网线断开或者连接的状态触发

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从两者的引脚可以看出F407开发板的TXD1引脚用的是PG14，F429开发板的TXD1引脚用的是PB13。除了这点不同，底层驱动的其它地方都是相同的。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;6.4.2     中断方式和查询方式接口函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的底层提供了中断和查询两种方式的接口函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、 查询方式需要提供如下几个函数的实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）void init_ethernet ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        初始化以太网控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）void send_frame (OS_FRAME *frame)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        发送数据包给以太网控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）void poll_ethernet (void)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        从以太网控制器缓冲中读取数据包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、 中断方式需要提供以下几个函数的实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）void init_ethernet ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        初始化以太网控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）void send_frame (OS_FRAME *frame)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        发送数据包给以太网控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）void int_enable_eth ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        使能以太网控制器中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）void int_disable_eth ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        关闭以太网控制器中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）interrupt function&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        中断函数，主要用于数据包的接收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;教程配套例子是采用的中断方式，需要用户提供中断接口函数的实现，当前的实现是在KEIL官方ETH_STM32F4xx.c文件的基础上修改而来的。官方提供的驱动是基于DP83848C实现的，现在将其修改为DM9161和DM9162的驱动，并增加PHY芯片的中断触发功能，这样可以实时监测到网线的插拔状态。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;6.4.3  用于调试和配置的宏定义&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;底层驱动文件ETH_STM32F4xx.c文件里面提供了三个宏定义，分别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  用于驱动调试的宏定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在底层驱动比较关键的地方都加上了函数printf_eth，用于驱动代码的调试，如果不想使用这个功能，将条件编译#if 1改成#if 0就可以了。如果PHY芯片正确驱动了，串口打印出来的效果就是如下这个样子的：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180717151711704-1939396315.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 用于选择10Mbps，100Mbps或者Auto-Negotiation功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

  默认情况下，我们选择是自动识别，即使用PHY芯片支持的Auto-Negotiation实现自适应10Mbps网络或者100Mbps网络

  但是这种时间稍长，如果用户确定了使用的网络是10Mbps还是100Mbps，直接通过下面的宏定义选择即可，如果使用的

  自适应，两个都不需要选择。

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define  _10MBIT_

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define  _100MBIT_&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 用于网线插拔消息实时打印&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了检查网线插拔是否正确识别，这里专门做了一个宏定义，方便串口打印，具体使用和说明看本章节6.4.8小节的讲解，下面是宏定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; ETH_CONSTATUS

&lt;span&gt;#define&lt;/span&gt; ETH_CONNECT    &quot;ETH_LINK Connect\r\n&quot;

&lt;span&gt;#define&lt;/span&gt; ETH_DISCONNECT &quot;ETH_LINK Disconnect\r\n&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.4.4  初始化函数init_ethernet&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;初始化函数主要是实现以太网RMII方式的引脚配置，PHY芯片DM9161/9162的配置，MAC配置及其DMA方式配置。具体实现的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: init_ethernet

*    功能说明: 初始化以太网RMII方式引脚，驱动PHY，配置MAC及其DMA方式。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; init_ethernet (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     U32 regv,tout,conn;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 关闭PHY中断触发引脚 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_DisableIRQ(EXTI9_5_IRQn);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（1）&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使能系统配置控制器时钟 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     RCC&lt;/span&gt;-&amp;gt;APB2ENR |= (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 复位以太网MAC &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     RCC&lt;/span&gt;-&amp;gt;AHB1RSTR |=  &lt;span&gt;0x02000000&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 选择RMII接口，必须在 MAC 处于复位状态且在使能 MAC 时钟之前完成此配置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     SYSCFG&lt;/span&gt;-&amp;gt;PMC |=  (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 停止复位以太网MAC &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     RCC&lt;/span&gt;-&amp;gt;AHB1RSTR &amp;amp;= ~&lt;span&gt;0x02000000&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使能以太网时钟，GPIOA，GPIOB，GPIOC，GPIOG时钟 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     RCC&lt;/span&gt;-&amp;gt;AHB1ENR |= &lt;span&gt;0x1E000047&lt;/span&gt;&lt;span&gt;;

                                                                                

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 原始驱动还配置了PA8，用于给PHY芯片提供时钟，V6开发板外置有源晶振，无需配置PA8 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------（2）&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置PA1，PA2和PA7，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     GPIOA&lt;/span&gt;-&amp;gt;MODER   &amp;amp;= ~&lt;span&gt;0x0000C03C&lt;/span&gt;&lt;span&gt;;

     GPIOA&lt;/span&gt;-&amp;gt;MODER   |=  &lt;span&gt;0x00008028&lt;/span&gt;&lt;span&gt;;             

     GPIOA&lt;/span&gt;-&amp;gt;OTYPER  &amp;amp;= ~&lt;span&gt;0x00000086&lt;/span&gt;&lt;span&gt;;             

     GPIOA&lt;/span&gt;-&amp;gt;OSPEEDR |=  &lt;span&gt;0x0003C03C&lt;/span&gt;&lt;span&gt;;             

     GPIOA&lt;/span&gt;-&amp;gt;PUPDR   &amp;amp;= ~&lt;span&gt;0x0003C03C&lt;/span&gt;&lt;span&gt;;            

     GPIOA&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;0&lt;/span&gt;]  &amp;amp;= ~&lt;span&gt;0xF0000FF0&lt;/span&gt;&lt;span&gt;;

     GPIOA&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;0&lt;/span&gt;]  |=  &lt;span&gt;0xB0000BB0&lt;/span&gt;&lt;span&gt;;             

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置PC1，PC4和PC5，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     GPIOC&lt;/span&gt;-&amp;gt;MODER   &amp;amp;= ~&lt;span&gt;0x00000F0C&lt;/span&gt;&lt;span&gt;;

     GPIOC&lt;/span&gt;-&amp;gt;MODER   |=  &lt;span&gt;0x00000A08&lt;/span&gt;&lt;span&gt;;            

     GPIOC&lt;/span&gt;-&amp;gt;OTYPER  &amp;amp;= ~&lt;span&gt;0x00000032&lt;/span&gt;&lt;span&gt;;             

     GPIOC&lt;/span&gt;-&amp;gt;OSPEEDR |=  &lt;span&gt;0x00000F0C&lt;/span&gt;&lt;span&gt;;             

     GPIOC&lt;/span&gt;-&amp;gt;PUPDR   &amp;amp;= ~&lt;span&gt;0x00000F0C&lt;/span&gt;&lt;span&gt;;           

     GPIOC&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;0&lt;/span&gt;]  &amp;amp;= ~&lt;span&gt;0x00FF00F0&lt;/span&gt;&lt;span&gt;;

     GPIOC&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;0&lt;/span&gt;]  |=  &lt;span&gt;0x00BB00B0&lt;/span&gt;&lt;span&gt;;             

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置PG11，PG13，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     GPIOG&lt;/span&gt;-&amp;gt;MODER   &amp;amp;= ~&lt;span&gt;0x0CC00000&lt;/span&gt;&lt;span&gt;;

     GPIOG&lt;/span&gt;-&amp;gt;MODER   |=  &lt;span&gt;0x08800000&lt;/span&gt;&lt;span&gt;;            

     GPIOG&lt;/span&gt;-&amp;gt;OTYPER  &amp;amp;= ~&lt;span&gt;0x00002800&lt;/span&gt;&lt;span&gt;;             

     GPIOG&lt;/span&gt;-&amp;gt;OSPEEDR |=  &lt;span&gt;0x0CC00000&lt;/span&gt;&lt;span&gt;;            

     GPIOG&lt;/span&gt;-&amp;gt;PUPDR   &amp;amp;= ~&lt;span&gt;0x0CC00000&lt;/span&gt;&lt;span&gt;;             

     GPIOG&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;1&lt;/span&gt;]  &amp;amp;= ~&lt;span&gt;0x00F0F000&lt;/span&gt;&lt;span&gt;;

     GPIOG&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;1&lt;/span&gt;]  |=  &lt;span&gt;0x00B0B000&lt;/span&gt;&lt;span&gt;;            

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置PB13，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     GPIOB&lt;/span&gt;-&amp;gt;MODER   &amp;amp;= ~&lt;span&gt;0x0C000000&lt;/span&gt;&lt;span&gt;;

     GPIOB&lt;/span&gt;-&amp;gt;MODER   |=  &lt;span&gt;0x08000000&lt;/span&gt;&lt;span&gt;;            

     GPIOB&lt;/span&gt;-&amp;gt;OTYPER  &amp;amp;= ~&lt;span&gt;0x00002000&lt;/span&gt;&lt;span&gt;;             

     GPIOB&lt;/span&gt;-&amp;gt;OSPEEDR |=  &lt;span&gt;0x0C000000&lt;/span&gt;&lt;span&gt;;             

     GPIOB&lt;/span&gt;-&amp;gt;PUPDR   &amp;amp;= ~&lt;span&gt;0x0C000000&lt;/span&gt;&lt;span&gt;;             

     GPIOB&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;1&lt;/span&gt;]  &amp;amp;= ~&lt;span&gt;0x00F00000&lt;/span&gt;&lt;span&gt;;

     GPIOB&lt;/span&gt;-&amp;gt;AFR[&lt;span&gt;1&lt;/span&gt;]  |=  &lt;span&gt;0x00B00000&lt;/span&gt;&lt;span&gt;;           

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       寄存器ETH-&amp;gt;DMABMR的SR位置1后，MAC DMA控制器会复位所有MAC子系统的内部寄存器和逻辑。在所有内

       核时钟域完成复位操作后，该位自动清零。重新编程任何内核寄存器之前，在该位中读取0 值。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMABMR  |=&lt;span&gt; DBMR_SR;

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (ETH-&amp;gt;DMABMR &amp;amp;&lt;span&gt; DBMR_SR);

     conn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        HCLK的时钟是168MHz，这里选项CR位为100，CR占用寄存器ETH-&amp;gt;MACMIIAR的bit4，bit3和bit2。

        CR 时钟范围选项可确定 HCLK 频率并用于决定 MDC 时钟频率：

         选项     HCLK        MDC 时钟

         000    60-100MHz     HCLK/42

         001    100-150MHz    HCLK/62

         010    20-35MHz      HCLK/16

         011    35-60MHz      HCLK/26

         100    150-168MHz    HCLK/102

         101、110、111 保留

    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACMIIAR = &lt;span&gt;0x00000010&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       注意事项：DM9161可以上电后就读取其ID寄存器，但是DM9162不行，需要延迟一段时间这里为了方便起见，

       直接将其复位，发送复位指令可以立即执行。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 第1步：复位DM9161/9162 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下面是DM9161/9162的硬件初始化：\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

     printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1. Start PHY_ID_DM9161/9162 Init\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送复位命令 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     write_PHY (PHY_REG_BMCR, &lt;/span&gt;&lt;span&gt;0x8000&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（3）&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待复位完成 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;for&lt;/span&gt; (tout = &lt;span&gt;0&lt;/span&gt;; tout &amp;lt; &lt;span&gt;0x10000&lt;/span&gt;; tout++&lt;span&gt;)

     {

         regv &lt;/span&gt;=&lt;span&gt; read_PHY (PHY_REG_BMCR);

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(regv &amp;amp; &lt;span&gt;0x8800&lt;/span&gt;&lt;span&gt;))

         {

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 复位完成 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

              printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2. Reset Complete\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

         }

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 第2步：配置DM9161/9162 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; defined (_10MBIT_)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（4）&lt;/span&gt;&lt;span&gt;

     write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接到10Mbps的网络 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#elif&lt;/span&gt; defined (_100MBIT_)&lt;span&gt;

     write_PHY (PHY_REG_BMCR, PHY_FULLD_100M); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接到100Mbps的网络 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 通过Auto-Negotiation实现自适应10Mbps网络或者100Mbps网络 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（5）&lt;/span&gt;

    

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待完成Auto-Negotiation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;for&lt;/span&gt; (tout = &lt;span&gt;0&lt;/span&gt;; tout &amp;lt; &lt;span&gt;0x100000&lt;/span&gt;; tout++&lt;span&gt;)

     {

         regv &lt;/span&gt;=&lt;span&gt; read_PHY (PHY_REG_BMSR);

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (regv &amp;amp; &lt;span&gt;0x0020&lt;/span&gt;&lt;span&gt;)

         {

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 完成Auto-Negotiation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

              printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3. Auto-Negotiation Complete\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

         }

     }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 第3步：检测连接状态 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;for&lt;/span&gt; (tout = &lt;span&gt;0&lt;/span&gt;; tout &amp;lt; &lt;span&gt;0x10000&lt;/span&gt;; tout++&lt;span&gt;)

     {

         regv &lt;/span&gt;=&lt;span&gt; read_PHY (PHY_REG_BMSR);   

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（6）&lt;/span&gt;
&lt;span&gt;
         {

              printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4. Connection Succeeded\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

             

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; PHY已经连接上网络 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

              g_ucEthLinkStatus &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

             

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 获取连接信息 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

              regv &lt;/span&gt;=&lt;span&gt; read_PHY (PHY_REG_DSCSR);

             

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;15&lt;/span&gt;))|(regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;13&lt;/span&gt;)))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（7）&lt;/span&gt;
&lt;span&gt;
              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 全双工 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                   printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5. Full-duplex connection\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                   conn &lt;/span&gt;|=&lt;span&gt; PHY_CON_SET_FULLD;

              }

             

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;15&lt;/span&gt;))|(regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;14&lt;/span&gt;)))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（8）&lt;/span&gt;
&lt;span&gt;
              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 速度100Mbps的网络 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                   printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6. 100Mbps Mode\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                   conn &lt;/span&gt;|=&lt;span&gt; PHY_CON_SET_100M;

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

         }

         &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

         {

              printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4. Connection failed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

             

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 未连接上 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

              g_ucEthLinkStatus &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

         }

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 第4步：使能DM9161/9162中断 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使能DM9161/9162的连接中断 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     write_PHY (PHY_REG_INTERRUPT, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置引脚PH6来接收中断信号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     Eth_Link_EXTIConfig();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 第5步：使能DM9161/9162中断 **********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        初始化MAC配置寄存器

        （1）当该位MCR_ROD置1时，MAC禁止在半双工模式下接收帧。

        （2）当该位MCR_ROD清0时，MAC接收PHY发送的所有数据包。

        （3）如果MAC在全双工模式下工作，该位不适用。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACCR  =&lt;span&gt; MCR_ROD;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置MAC工作在全双工模式 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (conn &amp;amp;&lt;span&gt; PHY_CON_SET_FULLD)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使能全双工 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ETH&lt;/span&gt;-&amp;gt;MACCR |=&lt;span&gt; MCR_DM;

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         通过位MCR_FES配置MAC通信速度

         （1）0表示10Mbps

         （2）1表示100Mbps

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (conn &amp;amp;&lt;span&gt; PHY_CON_SET_100M)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置为100Mbps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ETH&lt;/span&gt;-&amp;gt;MACCR |=&lt;span&gt; MCR_FES;

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; MACFFR 以太网帧过滤寄存器，配置可接收所有MAC组播包，即MAC地址第一个字节的bit0 = 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACFFR = MFFR_HPF |&lt;span&gt; MFFR_PAM;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; MACFCR 以太网流控制寄存器，ZQPD零时间片暂停禁止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACFCR =&lt;span&gt; MFCR_ZQPD;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置以太网MAC地址寄存器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACA0HR = ((U32)own_hw_adr[&lt;span&gt;5&lt;/span&gt;] &amp;lt;&amp;lt;  &lt;span&gt;8&lt;/span&gt;) | (U32)own_hw_adr[&lt;span&gt;4&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（9）&lt;/span&gt;
&lt;span&gt;
     ETH&lt;/span&gt;-&amp;gt;MACA0LR = ((U32)own_hw_adr[&lt;span&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) | (U32)own_hw_adr[&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt; |&lt;span&gt;

                      ((U32)own_hw_adr[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt;  &lt;span&gt;8&lt;/span&gt;) | (U32)own_hw_adr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化DMA发送和接收描述符 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     rx_descr_init ();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（10）&lt;/span&gt;
&lt;span&gt;
     tx_descr_init ();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（11）&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         刷新FIFO，启动DMA发送和接收功能

         DMAOMR 工作模式寄存器

         位20 DOMR_FTF：刷新发送 FIFO (Flush transmit FIFO)：

                        该位置1时，发送FIFO控制器逻辑会复位为默认值，因此，TX FIFO中的所有数据均会

                         丢失/刷新。刷新操作结束时该位在内部清零。此位清零之前不得对工作模式寄存器执

                         行写操作。

         位13 DOMR_ST：启动/停止发送 (Start/stop transmission)

                       该位置1时，启动发送，DMA会检查当前位置的发送列表来查找待发送的帧。

         位1  DOMR_SR：启动/停止接收 (Start/stop receive)

                       该位置1时，启动接收，DMA尝试从接收列表中获取描述符并处理传入帧。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMAOMR = DOMR_FTF | DOMR_ST | DOMR_SR;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（12）&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 使能发送和接收 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;MACCR |= MCR_TE |&lt;span&gt; MCR_RE;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 复位所有MAC中断 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMASR  = &lt;span&gt;0xFFFFFFFF&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 

         使能发送和接收中断

         DMAIER 中断使能寄存器

         位16 NISE：使能所有正常中断(Normal interrupt summary enable)

         位15 AISE：使能所有异常中断(Abnormal interrupt summary enable)

         位7 RBUIE：接收缓冲区不可用中断使能(Receive buffer unavailable interrupt enable)

                    当该位和AISE位都置1后，可使能接收缓冲区不可用中断。该位清零时，会禁止接

                      收缓冲区不可用中断。

         位6   RIE：接收中断使能 (Receive interrupt enable)

                    当该位和AISE都置1后，可使能接收中断。该位清零时，会禁止接收中断。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMAIER = ETH_DMAIER_NISE | ETH_DMAIER_AISE | ETH_DMAIER_RBUIE |&lt;span&gt; ETH_DMAIER_RIE;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置为最高优先级，仅调用NVIC-&amp;gt;ISER设置的默认优先级也是最高优先级0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_SetPriority(ETH_IRQn, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    

     printf_eth(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1.  这里通过函数NVIC_DisableIRQ(EXTI9_5_IRQn)关闭PHY芯片触发STM32的PH6引脚中断，防止PHY芯片初始化的过程中造成误触发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  初始化RMII接口用到的引脚：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

     PA1/ETH_RMII_RX_CLK

     PA2/ETH_MDIO

     PA7/RMII_CRS_DV

     PC1/ETH_MDC

     PC4/ETH_RMII_RX_D0

     PC5/ETH_RMII_RX_D1

     PG11/ETH_RMII_TX_EN

     PG13/FSMC_A24/ETH_RMII_TXD0

     PB13/ETH_RMII_TXD1

     PH6/MII_INT ----- 中断引脚,这里将其用于网线断开或者连接的状态触发

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.  对PHY芯片的BMCR寄存器bit15置1可以实现对PHY芯片的软件复位操作。PHY芯片能否正确复位是建立在前面RMII接口引脚正确配置，而且PHY芯片的硬件电路设计没问题的基础上。间接的，我们也就可以通过判断芯片是否能够正常复位来判断RMII接口引脚配置是否正确，PHY芯片的引脚电路设计是否正确。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;      给PHY芯片发送了复位命令后，要等待复位完成，也就是继续查询此寄存器的bit15或者bit11，任何一个被清零了，都表示系统正常复位了。也就是下面调用函数：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;regv = read_PHY (PHY_REG_BMCR);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;进行不断的查询，直到bit15或者bit11任何一个bit被清零，表示PHY芯片正常复位了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;4.  配置PHY工作在10Mbps或者100Mbps状态， 也可以通过使用PHY芯片支持的Auto-Negotiation实现自适应10Mbps网络或者100Mbps网络，但是这种时间稍长，如果用户确定了使用的网络是10Mbps还是100Mbps，直接通过下面的宏定义选择即可，如果使用的自适应，两个都不需要选择。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;#define  _10MBIT_&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;#define  _100MBIT_&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.  通过配置PHY芯片的BMCR寄存器的bit12使能Auto-Negotiation功能，从而可以根据实际的网络环境是10Mbps还是100Mbps实现自适应（&lt;span&gt;这里自适应的意思是PHY芯片根据所处的网络环境来自行配置10Mbps或者100Mbps&lt;/span&gt;）。配置完毕后，不断查询BMSR寄存器的bit5来判断自适应是否完成，这个判别过程时间稍长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.  通过读取PHY芯片的BMSR寄存器bit2来获取连接状态，即PHY芯片是否和外部网络建立了10Mbps或者100Mbps的网络连接，如果返回1表示有效的连接已经建立，否则反之。同时设置全局变量g_ucEthLinkStatus来表示连接状态，方便查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.  通过读取PHY芯片DSCSR寄存器bit15和bit13来获取&lt;span&gt;PHY芯片是否工作在全双工模式&lt;/span&gt;。可以读取这个寄存器是建立在用户使能了Auto-Negotiation功能的基础上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        BIT15 : 100Mbps全双工模式判别。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        Auto-Negotiation功能完成后，如果此位是1表示PHY芯片工作在100Mpbs全双工模式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        BIT13：10Mbps全双工模式判别。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        Auto-Negotiation功能完成后，如果此位是1表示PHY芯片工作在10Mpbs全双工模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.  通过读取PHY芯片DSCSR寄存器bit15和bit14来获取&lt;span&gt;PHY芯片是否工作在100Mbps&lt;/span&gt;。可以读取这个寄存器是建立在用户使能了Auto-Negotiation功能的基础上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        BIT15 : 100Mbps全双工模式判别。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        Auto-Negotiation功能完成后，如果此位是1表示PHY芯片工作在100Mpbs全双工模式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        BIT14：10Mbps半双工模式判别。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;        Auto-Negotiation功能完成后，如果此位是1表示PHY芯片工作在10Mpbs半双工模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9. 配置MAC地址，地址的设置是在配置向导文件Net_Config.c文件里面：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180717151806182-694195949.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10. 配置MAC的DMA接收描述符，具体实现代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: rx_descr_init

*    功能说明: MAC DMA接收描述符初始化。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rx_descr_init (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     U32 i,next;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        1. RDES0：接收描述符字0，对应Rx_Desc[i].Stat

           位31 OWN：所有关系位 (Own bit)

                       该位置1时，指示描述符由MAC子系统的DMA所拥有。

                     该位清零时，指示描述符由主机所拥有，即CPU。

                     DMA在帧接收完成或此描述符的关联缓冲区已满时将该位清零。

    

        2. RDES1：接收描述符字1，对应Rx_Desc[i].Ctrl

           位14   RCH： 链接的第二个地址 (Second address chained)

                          该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。该

                       位置1时，RBS2(RDES1[28:16])为无关值。RDES1[15]比RDES1[14]优先处理。

           位12:0 RBS1：接收缓冲区1大小 (Receive buffer 1 size)

                       第一个数据缓冲区的大小以字节为单位。即使RDES2（缓冲区1地址指针）的值未对齐，缓

                        冲区大小也必须为4、8或16的倍数，具体取决于总线宽度32、64或128。如果缓冲区大小不

                        是4、8或16的倍数，这种情况的结果是未定义。如果该字段为0，则DMA会忽略该缓冲区并

                        使用缓冲区2或下一个描述符，具体取决于RCH（位14）的值。

    

        3. RDES2：接收描述符字2，对应Rx_Desc[i].Addr

           位31:0 RBAP1/RTSL：接收缓冲区1地址指针/接收帧时间戳低位

                              Receive buffer 1 address pointer

                             Receive frame time stamp low

    

        4. RDES3：接收描述符字3，对应Rx_Desc[i].Next

           位31:0 RBAP2/RTSH：接收缓冲区2地址指针（下一个描述符地址）/ 接收帧时间戳高位

                              Receive buffer 2 address pointer (next descriptor address)

                              Receive frame time stamp high

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     RxBufIndex &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    

     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;, next = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_RX_BUF; i++&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++next == NUM_RX_BUF) next = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

         Rx_Desc[i].Stat &lt;/span&gt;=&lt;span&gt; DMA_RX_OWN;

         Rx_Desc[i].Ctrl &lt;/span&gt;= DMA_RX_RCH |&lt;span&gt; ETH_BUF_SIZE;

         Rx_Desc[i].Addr &lt;/span&gt;= (U32)&amp;amp;&lt;span&gt;rx_buf[i];

         Rx_Desc[i].Next &lt;/span&gt;= (U32)&amp;amp;&lt;span&gt;Rx_Desc[next];

     }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收描述符列表地址寄存器指向接收描述符列表的起始处 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMARDLAR = (U32)&amp;amp;Rx_Desc[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;这里是将接收描述符做成了环形队列进行初始化，通过DMA接收描述符结构体成员Next指向下一个描述符的地址，从而组成一个环形队列。这样DMA方式数据接收的时候就可以做成FIFO的形式，提升DMA接收效率。DMA接收描述符定义和DMA缓冲定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; NUM_RX_BUF          4         /* 接收缓冲个数 (4*1536=6K) */

&lt;span&gt;#define&lt;/span&gt; NUM_TX_BUF          2         /* 发送缓冲个数 (2*1536=3K) */

&lt;span&gt;#define&lt;/span&gt; ETH_BUF_SIZE        1536      /* 发送/接收缓冲大小定义    */

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA 接收描述符定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {

  U32 &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Stat;

  U32 Ctrl;

  U32 Addr;

  U32 Next;

} RX_Desc;

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; RX_Desc Rx_Desc[NUM_RX_BUF];             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA接收描述符 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; U32 rx_buf[NUM_RX_BUF][ETH_BUF_SIZE&amp;gt;&amp;gt;&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA接收描述符缓冲 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;11. 配置MAC的DMA发送描述符，具体实现代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tx_descr_init

*    功能说明: MAC DMA发送描述符初始化

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tx_descr_init (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     U32 i,next;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        1. TDES0：发送描述符字0，对应Tx_Desc[i].CtrlStat

           位29 LS ：末段 (Last segment)

                    该位置1时，指示缓冲区中包含帧的末段。

           位28 FS ：首段 (First segment)

                    该位置1时，指示缓冲区中包含帧的首段

          位20 TCH：链接的第二个地址 (Second address chained)

                    该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。

                    TDES0[20]置1时，TBS2(TDES1[28:16])为无关值。TDES0[21]比TDES0[20]优先处理。

    

        2. TDES1：发送描述符字1，对应Tx_Desc[i].Size

    

        3. TDES2：发送描述符字2，对应Tx_Desc[i].Addr

           位31:0 TBAP1：发送缓冲区1地址指针/发送帧时间戳低位

                         Transmit buffer 1 address pointer / Transmitframe time stamp low

    

        4. TDES3：发送描述符字3，对应Tx_Desc[i].Next

           位 1:0 TBAP2：发送缓冲区2地址指针（下一个描述符地址）/ 发送帧时间戳高位

                          Transmit buffer 2 address pointer (Next descriptor address)

                            Transmit frame time stamp high

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     TxBufIndex &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;, next = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_TX_BUF; i++&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++next == NUM_TX_BUF) next = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

         Tx_Desc[i].CtrlStat &lt;/span&gt;= DMA_TX_TCH | DMA_TX_LS |&lt;span&gt; DMA_TX_FS;

         Tx_Desc[i].Addr     &lt;/span&gt;= (U32)&amp;amp;&lt;span&gt;tx_buf[i];

         Tx_Desc[i].Next     &lt;/span&gt;= (U32)&amp;amp;&lt;span&gt;Tx_Desc[next];

     }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送描述符列表地址寄存器指向发送描述符列表的起始处 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMATDLAR = (U32)&amp;amp;Tx_Desc[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;1&quot;&gt;&lt;span&gt;这里是将发送描述符做成了环形队列进行初始化，通过DMA发送描述符结构体成员Next指向下一个描述符的地址，从而组成一个环形队列。这样DMA方式数据发送的时候就可以做成FIFO的形式，提升DMA发送效率。DMA发送描述符定义和DMA缓冲定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; NUM_RX_BUF          4         /* 接收缓冲个数 (4*1536=6K) */

&lt;span&gt;#define&lt;/span&gt; NUM_TX_BUF          2         /* 发送缓冲个数 (2*1536=3K) */

&lt;span&gt;#define&lt;/span&gt; ETH_BUF_SIZE        1536      /* 发送/接收缓冲大小定义    */

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA 接收描述符定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {

  U32 &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; CtrlStat;

  U32 Size;

  U32 Addr;

  U32 Next;

} TX_Desc;

 

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TX_Desc Tx_Desc[NUM_TX_BUF];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA发送描述符 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; U32 tx_buf[NUM_TX_BUF][ETH_BUF_SIZE&amp;gt;&amp;gt;&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DMA发送描述符缓冲 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;12. 剩下的函数主要是使能MAC的DMA方式发送和接收功能，并使能以太网中断。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;6.4.5  数据包发送函数send_frame&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下面是数据包的发送函数，主要是通过初始化函数中建立的MAC DMA发送描述符实现FIFO方式的数据帧发送。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: send_frame

*    功能说明: 传递数据帧给MAC DMA发送描述符，并使能发送。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; send_frame (OS_FRAME *&lt;span&gt;frame)

{

     U32 &lt;/span&gt;*sp,*&lt;span&gt;dp;

     U32 i,j;

 

     j &lt;/span&gt;=&lt;span&gt; TxBufIndex;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待上一帧数据发送完成 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt; (Tx_Desc[j].CtrlStat &amp;amp;&lt;span&gt; DMA_TX_OWN);

 

     sp &lt;/span&gt;= (U32 *)&amp;amp;frame-&amp;gt;data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

     dp &lt;/span&gt;= (U32 *)(Tx_Desc[j].Addr &amp;amp; ~&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 复制要发送的数据到DMA发送描述符中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;for&lt;/span&gt; (i = (frame-&amp;gt;length + &lt;span&gt;3&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;; i; i--&lt;span&gt;)

     {

         &lt;/span&gt;*dp++ = *sp++&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置数据帧大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     Tx_Desc[j].Size      &lt;/span&gt;= frame-&amp;gt;&lt;span&gt;length;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送描述符由DMA控制发送 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     Tx_Desc[j].CtrlStat &lt;/span&gt;|=&lt;span&gt; DMA_TX_OWN;

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++j == NUM_TX_BUF) j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

     TxBufIndex &lt;/span&gt;=&lt;span&gt; j;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 开始帧传输 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        DMASR 以太网 DMA 状态寄存器

        向ETH_DMASR寄存器[16:0]中的（未保留）位写入1会将其清零，写入 0 则不起作用。

        位1 TPSS：发送过程停止状态 (Transmit process stopped status)

                 当发送停止时，此位置 1。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMASR   =&lt;span&gt; DSR_TPSS;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        DMATPDR 以太网DMA发送轮询请求寄存器

       应用程序使用此寄存器来指示DMA轮询发送描述符列表。

       位 31:0 TPD：发送轮询请求(Transmit poll demand)

                    向这些位写入任何值时，DMA都会读取ETH_DMACHTDR寄存器指向的当前描述符。如果

                    该描述符不可用（由CPU所有），则发送会返回到挂起状态，并将ETH_DMASR寄存器位2

                    进行置位。如果该描述符可用，则发送会继续进行。      

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMATPDR = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.4.6  以太网中断函数ETH_IRQHandler&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以太网中断函数主要用于实现数据包的接收，主要是通过初始化函数中建立的MAC DMA接收描述符实现FIFO方式的数据帧接收。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: ETH_IRQHandler

*    功能说明: 以太网中断，主要处理从MAC DMA接收描述符接收到的数据帧以及错误标志的处理。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; ETH_IRQHandler (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     OS_FRAME &lt;/span&gt;*&lt;span&gt;frame;

     U32 i, RxLen;

     U32 &lt;/span&gt;*sp,*&lt;span&gt;dp;

 

     i &lt;/span&gt;=&lt;span&gt; RxBufIndex;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 循环所有接受描述符列表，遇到未接收到数据的退出循环 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;do&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（1）&lt;/span&gt;
&lt;span&gt;
     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              #define DMA_RX_ERROR_MASK   (DMA_RX_ES | DMA_RX_LE | DMA_RX_RWT | \

                                              DMA_RX_RE | DMA_RX_CE)

             

              有错误，放弃此帧数据，错误类型包含如下：

              位15 DMA_RX_ES：错误汇总(Error summary)，即CRC错误，接收错误，看门狗超时，延迟冲突等。

             位12 DMA_RX_LE：长度错误(Length error)

                             该位置1时，指示接收帧的实际长度与长度/类型字段的值不符。该字段仅在帧类

                             型位(RDES0[5])复位后有效。

              位4 DMA_RX_RWT：接收看门狗超时 (Receive watchdog timeout)

                             该位置1时，表示接收看门狗计时器在接收当前帧时超时，且当前帧在看门狗超

                             时后被截断了

              位3 DMA_RX_RE： 接收错误 (Receive error)

                            该位置1时，表示在帧接收期间，当发出RX_DV信号时，会发出RX_ERR信号。

              位1 DMA_RX_CE： CRC 错误(CRC error)

                            该位置1时，表示接收的帧发生循环冗余校验(CRC)错误。只有最后一个描述符

                             (RDES0[8])置1时，该字段才有效

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt; (Rx_Desc[i].Stat &amp;amp;&lt;span&gt; DMA_RX_ERROR_MASK)

         {

              &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rel;

         }

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              #define DMA_RX_SEG_MASK   (DMA_RX_FS | DMA_RX_LS)

             位9 FS：第一个描述符 (First descriptor)

                    该位置1时，指示此描述符包含帧的第一个缓冲区。如果第一个缓冲区的大小为0，则第二

                    个缓冲区将包含帧的帧头。如果第二个缓冲区的大小为0，则下一个描述符将包含帧的帧头。

        

             位8 LS：最后一个描述符 (Last descriptor)

                    该位置1时，指示此描述符指向的缓冲区为帧的最后一个缓冲区。

        

           下面的函数用于判断此帧数据是否只有一个缓冲，初始化接收描述符列表的时候，每个描述符仅设置了

            一个缓冲。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt; ((Rx_Desc[i].Stat &amp;amp; DMA_RX_SEG_MASK) != DMA_RX_SEG_MASK) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（2）&lt;/span&gt;
&lt;span&gt;
         {

              &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rel;

         }

        

         RxLen &lt;/span&gt;= ((Rx_Desc[i].Stat &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;) &amp;amp; &lt;span&gt;0x3FFF&lt;/span&gt;) - &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (RxLen &amp;gt;&lt;span&gt; ETH_MTU)

         {

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 数据包太大，直接放弃 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

              &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rel;

         }

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 申请动态内存，RxLen或上0x80000000表示动态内存不足了不会调用函数sys_error() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         frame &lt;/span&gt;= alloc_mem (RxLen | &lt;span&gt;0x80000000&lt;/span&gt;&lt;span&gt;);

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果动态内存申请失败了，放弃此帧数据；成功了，通过函数put_in_queue存入队列中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt; (frame !=&lt;span&gt; NULL)

         {

              sp &lt;/span&gt;= (U32 *)(Rx_Desc[i].Addr &amp;amp; ~&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

              dp &lt;/span&gt;= (U32 *)&amp;amp;frame-&amp;gt;data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (RxLen = (RxLen + &lt;span&gt;3&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;; RxLen; RxLen--&lt;span&gt;)

              {

                  &lt;/span&gt;*dp++ = *sp++&lt;span&gt;;

              }

              put_in_queue (frame);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（3）&lt;/span&gt;
&lt;span&gt;
         }

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置此接收描述符继续接收新的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         rel: Rx_Desc[i].Stat &lt;/span&gt;=&lt;span&gt; DMA_RX_OWN;

 

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++i == NUM_RX_BUF) i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

     }

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!(Rx_Desc[i].Stat &amp;amp;&lt;span&gt; DMA_RX_OWN));

    

     RxBufIndex &lt;/span&gt;=&lt;span&gt; i;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        DMASR DMA的状态寄存器（DMA status register）

        位7 RBUS：接收缓冲区不可用状态 (Receive buffer unavailable status)

                 此位指示接收列表中的下一个描述符由CPU所拥有，DMA无法获取。接收过程进入挂起状态。

                  要恢复处理接收描述符，CPU应更改描述符的拥有关系，然后发出接收轮询请求命令。如果

                  未发出接收轮询请求命令，则当接收到下一个识别的传入帧时，接收过程会恢复。仅当上一

                  接收描述符由DMA所拥有时，才能将ETH_DMASR[7]置1。

    

        DMAIER的接收缓冲区不可用中断RBUIE是bit7，对于的接收缓冲区不可用状态在DMA状态寄存器中也是bit7。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (ETH-&amp;gt;DMASR &amp;amp;&lt;span&gt; INT_RBUIE)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收缓冲区不可用，重新恢复DMA传输 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ETH&lt;/span&gt;-&amp;gt;DMASR =&lt;span&gt; ETH_DMASR_RBUS;

         ETH&lt;/span&gt;-&amp;gt;DMARPDR = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        DMASR DMA的状态寄存器（DMA status register）

        这里实现清除中断挂起标志

        位16 ETH_DMASR_NIS：所有正常中断 (Normal interrupt summary)

        位15 ETH_DMASR_AIS：所有异常中断 (Abnormal interrupt summary)

        位6  ETH_DMASR_RS ：接收状态 (Receive status)

                            此位指示帧接收已完成，具体的帧状态信息已经包含在描述符中，接收仍保持运行状态。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     ETH&lt;/span&gt;-&amp;gt;DMASR = ETH_DMASR_NIS | ETH_DMASR_AIS |&lt;span&gt; ETH_DMASR_RS;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;由于初始化的时候创建了一个MAC DMA描述符的FIFO，这里是通过do while语句读取FIFO中所有已经接收到的数据包。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;要理解这个函数的作用，首先需要明白初始化DMA接收描述符的时候已经设置每个描述符仅有一个缓冲，这里就是判断此描述符是否只有这一个缓冲地址。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过函数put_in_queue就将接收到的数据帧存储到RL-TCPnet协议栈中了，供上层API使用。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;6.4.7  中断开关函数int_enable_eth和int_disable_eth&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这两个函数比较简单，实现了以太网中断的开关设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: int_enable_eth

*    功能说明: 使能以太网中断

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; int_enable_eth (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     NVIC&lt;/span&gt;-&amp;gt;ISER[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;29&lt;/span&gt;&lt;span&gt;;

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: int_disable_eth

*    功能说明: 使能以太网中断

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; int_disable_eth (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     NVIC&lt;/span&gt;-&amp;gt;ICER[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;29&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.4.8  网线插拔检测中断EXTI9_5_IRQHandler&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;特别注意，如果开发板上电前，网线已经插到板子上面了，这种情况是不会触发中断的，其余情况都会触发中断&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中断函数EXTI9_5_IRQHandler的作用只有一个，就是实时检测网线的插拔状态。具体实现代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: EXTI9_5_IRQHandler

*    功能说明: PH6引脚的中断处理

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; ETH_CONSTATUS   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（1）&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; ETH_CONNECT    &quot;ETH_LINK Connect\r\n&quot;

&lt;span&gt;#define&lt;/span&gt; ETH_DISCONNECT &quot;ETH_LINK Disconnect\r\n&quot;

&lt;span&gt;void&lt;/span&gt; EXTI9_5_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     U32 regv, tout;

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (EXTI_GetITStatus(EXTI_Line6) !=&lt;span&gt; RESET)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 可以考虑在此处加入延迟，有时连接状态变了，但是寄存器没有及时更新&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         regv &lt;/span&gt;= read_PHY(PHY_REG_INTERRUPT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（2）&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt;(regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;))

         {

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 重新插入后要多读几次，保证寄存器BMSR被更新 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

              &lt;span&gt;for&lt;/span&gt;(tout = &lt;span&gt;0&lt;/span&gt;; tout &amp;lt; &lt;span&gt;10&lt;/span&gt;; tout++)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（3）&lt;/span&gt;
&lt;span&gt;
              {

                   regv &lt;/span&gt;=&lt;span&gt; read_PHY (PHY_REG_BMSR);

                   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;))

                   {

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                   }

              }

 

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接上网线 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

              &lt;span&gt;if&lt;/span&gt;(regv &amp;amp; (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（4）&lt;/span&gt;
&lt;span&gt;
              {

                   #ifdef ETH_CONSTATUS &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（4）&lt;/span&gt;

                       &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *pError =&lt;span&gt; ETH_CONNECT;

                       uint8_t i;

                   &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

                  

                   g_ucEthLinkStatus &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                  

                   #ifdef ETH_CONSTATUS 

                       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(ETH_CONNECT); i++&lt;span&gt;)

                       {

                            USART1&lt;/span&gt;-&amp;gt;DR =&lt;span&gt; pError[i];

                            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待发送结束 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                            &lt;span&gt;while&lt;/span&gt; ((USART1-&amp;gt;SR &amp;amp; USART_FLAG_TC) ==&lt;span&gt; (uint16_t)RESET);

                       }

                   &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

              }

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 网线断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

              &lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（5）&lt;/span&gt;
&lt;span&gt;
              {

                   #ifdef ETH_CONSTATUS  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------（6）&lt;/span&gt;

                       &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *pError =&lt;span&gt; ETH_DISCONNECT;

                       uint8_t i;

                   &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

                  

                   g_ucEthLinkStatus &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                  

                   #ifdef ETH_CONSTATUS

                       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(ETH_DISCONNECT); i++&lt;span&gt;)

                       {

                            USART1&lt;/span&gt;-&amp;gt;DR =&lt;span&gt; pError[i];

                            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待发送结束 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                            &lt;span&gt;while&lt;/span&gt; ((USART1-&amp;gt;SR &amp;amp; USART_FLAG_TC) ==&lt;span&gt; (uint16_t)RESET);

                       }

                   &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

                  

              }

             

         }

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 清中断挂起位 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         EXTI_ClearITPendingBit(EXTI_Line6);

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;如果用户需要网线插拔时，串口可以打印相应的信息出来，使能这个宏定义即可。默认情况下，此宏定义是注销掉的。另外，特别注意一点，如果首次下载程序到板子里面，此功能不好用的话，将板子重新上电就好了，以后开关电源也都没有影响，出现这种情况的原因估计是PHY芯片没有正常复位并初始化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;读取PHY芯片的中断寄存器，通过此寄存器的bit2可以检测网线的插拔状态变化。如果发生了变化，此位会被置1，读取完毕此寄存器后，此位会被自动清零。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过PHY芯片的中断寄存器仅仅能够判断网线的插拔状态发生了变化，但是不知道网线是插上了还是拔下来了，这个时候就需要通过BMSR寄存器进行判断。这里需要多读几次，防止BMSR寄存器还没有更新。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果寄存器BMSR的bit2是1，表示网线插入。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果用户使能了宏定义#define ETH_CONSTATUS，插拔网线时会打印插拔状态信息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果寄存器BMSR的bit2是0，表示网线拔出。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果用户使能了宏定义#define ETH_CONSTATUS，插拔网线时会打印插拔状态信息。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;6.5  总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本章节就为大家讲解这么多，主要是为学习下个章节RL-TCPnet的移植做准备。学完本章后，务必将STM32参考手册中MAC章节读一遍。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 17 Jul 2018 07:19:00 +0000</pubDate>
<dc:creator>席萌0209</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/9323540.html</dc:identifier>
</item>
<item>
<title>Java1.8的HashMap源码解析 - 丰极</title>
<link>http://www.cnblogs.com/zhangbin1989/p/9323144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangbin1989/p/9323144.html</guid>
<description>&lt;p&gt;java1.8是现在用的最多的版本，hashmap是现在用的最多的map，今天我们试图分析一下源码。&lt;/p&gt;

&lt;p&gt;首先我们注意到数据是存放在一个Node数组里面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;transient Node&amp;lt;K,V&amp;gt;[] table;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们看一下Node&amp;lt;K,V&amp;gt;的结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们注意到这是一个单链表，next指向下一个节点。&lt;/p&gt;

&lt;p&gt;接着我们看一下get(Object key)方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k;
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (first = tab[(n - 1) &amp;amp; hash]) != null) {
            if (first.hash == hash &amp;amp;&amp;amp; // always check first node
                ((k = first.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定位到数据在数组的下标： (n - 1) &amp;amp; hash&lt;br/&gt;找到数组的第一个node：first，如果first为null直接返回&lt;br/&gt;如果first的key和get里面的key相等，则返回first的value&lt;br/&gt;如果first的key和get里面的key不相等，判断first是不是TreeNode,如果不是，则一直找next,直到key和所传的key相等&lt;br/&gt;如果first的key和get里面的key不相等，判断first是不是TreeNode,如果是，则调用getTreeNode方法查找&lt;br/&gt;我们看一下TreeNode的数据结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, val, next);
        }

    ......
    ......
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看下LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
        Entry&amp;lt;K,V&amp;gt; before, after;
        Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, value, next);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们注意到LinkedHashMap.Entry把单链表扩展成了双向链表&lt;br/&gt;TreeNode把双向链表扩张成了红黑树&lt;br/&gt;我们在来看一下getTreeNode方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        final TreeNode&amp;lt;K,V&amp;gt; getTreeNode(int h, Object k) {
            return ((parent != null) ? root() : this).find(h, k, null);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;root()是查询根节点,接着看一下find方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final TreeNode&amp;lt;K,V&amp;gt; find(int h, Object k, Class&amp;lt;?&amp;gt; kc) {
            TreeNode&amp;lt;K,V&amp;gt; p = this;
            do {
                int ph, dir; K pk;
                TreeNode&amp;lt;K,V&amp;gt; pl = p.left, pr = p.right, q;
                if ((ph = p.hash) &amp;gt; h)
                    p = pl;
                else if (ph &amp;lt; h)
                    p = pr;
                else if ((pk = p.key) == k || (k != null &amp;amp;&amp;amp; k.equals(pk)))
                    return p;
                else if (pl == null)
                    p = pr;
                else if (pr == null)
                    p = pl;
                else if ((kc != null ||
                          (kc = comparableClassFor(k)) != null) &amp;amp;&amp;amp;
                         (dir = compareComparables(kc, k, pk)) != 0)
                    p = (dir &amp;lt; 0) ? pl : pr;
                else if ((q = pr.find(h, k, kc)) != null)
                    return q;
                else
                    p = pl;
            } while (p != null);
            return null;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，要查询的key的hash为h，依次遍历节点，如果节点的hash&amp;gt;h，则把节点的左节点赋值给节点，如果节点的hash&amp;lt;h，则把节点的右节点赋值给节点，知道节点的hash和h相等。&lt;/p&gt;

&lt;p&gt;接着我们看一下put方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们一行行分析&lt;br/&gt;先是拿到数组的长度：n = (tab = resize()).length;&lt;br/&gt;取到数据在数组的下标：i = (n - 1) &amp;amp; hash&lt;br/&gt;取到下标i对应的节点p = tab[i]&lt;br/&gt;如果p为null,则新建一个node: tab[i] = newNode(hash, key, value, null);&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Node&amp;lt;K,V&amp;gt; newNode(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
        return new Node&amp;lt;&amp;gt;(hash, key, value, next);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果p不为null，判断p的key和传的key是否相等，相等则返回p&lt;br/&gt;如果p不为null，判断p的key和传的key是否相等，不相等，如果是TreeNode则放入红黑树里面&lt;br/&gt;如果p不为null，判断p的key和传的key是否相等，不相等，如果不是TreeNode，则一直遍历next节点，知道节点的key和传的key相等&lt;br/&gt;如果一直遍历到最后也没找到，则新建一个节点，并把它放在链表的末尾&lt;/p&gt;
&lt;p&gt;最后新建节点的时候有一个树化 的判断&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TREEIFY_THRESHOLD的值为8，超过8个则由链表转换成红黑树&lt;br/&gt;我们来看一个这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
        int n, index; Node&amp;lt;K,V&amp;gt; e;
        if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
            TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
            do {
                TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取到链表的首节点：e = tab[index = (n - 1) &amp;amp; hash]&lt;br/&gt;replacementTreeNode方法实际是new一个TreeNode&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    TreeNode&amp;lt;K,V&amp;gt; replacementTreeNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt; next) {
        return new TreeNode&amp;lt;&amp;gt;(p.hash, p.key, p.value, next);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;do while操作是做了一个转换，转换成双向链表&lt;br/&gt;最后一句hd.treeify(tab);是调用树化的方法，我们看一下这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        final void treeify(Node&amp;lt;K,V&amp;gt;[] tab) {
            TreeNode&amp;lt;K,V&amp;gt; root = null;
            for (TreeNode&amp;lt;K,V&amp;gt; x = this, next; x != null; x = next) {
                next = (TreeNode&amp;lt;K,V&amp;gt;)x.next;
                x.left = x.right = null;
                if (root == null) {
                    x.parent = null;
                    x.red = false;
                    root = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&amp;lt;?&amp;gt; kc = null;
                    for (TreeNode&amp;lt;K,V&amp;gt; p = root;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &amp;gt; h)
                            dir = -1;
                        else if (ph &amp;lt; h)
                            dir = 1;
                        else if ((kc == null &amp;amp;&amp;amp;
                                  (kc = comparableClassFor(k)) == null) ||
                                 (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);

                        TreeNode&amp;lt;K,V&amp;gt; xp = p;
                        if ((p = (dir &amp;lt;= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir &amp;lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            root = balanceInsertion(root, x);
                            break;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个方法的this是下标为i的数组的首节点&lt;br/&gt;如果root为空，初始化root，根节点是黑色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    if (root == null) {
        x.parent = null;
        x.red = false;
        root = x;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外面的for循环，遍历next节点，把所有的节点插入进树里面&lt;br/&gt;里面的For循环，通过hash对比判断左节点还是右节点，从根节点找左右节点，并把左右节点当成根节点往下找，直到左节点或者右节点为空，把它安装在这里&lt;/p&gt;
&lt;p&gt;我们先看一下红黑树的特性，在看下面的balanceInsertion(root, x)方法&lt;br/&gt;红黑树的特性:&lt;br/&gt;（1）每个节点或者是黑色，或者是红色。&lt;br/&gt;（2）根节点是黑色。&lt;br/&gt;（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]&lt;br/&gt;（4）如果一个节点是红色的，则它的子节点必须是黑色的。&lt;br/&gt;（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        static &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceInsertion(TreeNode&amp;lt;K,V&amp;gt; root,
                                                    TreeNode&amp;lt;K,V&amp;gt; x) {
            x.red = true;
            for (TreeNode&amp;lt;K,V&amp;gt; xp, xpp, xppl, xppr;;) {
                if ((xp = x.parent) == null) {
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null)
                    return root;
                if (xp == (xppl = xpp.left)) {
                    if ((xppr = xpp.right) != null &amp;amp;&amp;amp; xppr.red) {
                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else { ！！
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null &amp;amp;&amp;amp; xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过判断决定是左旋转还是右旋转，如上标两个感叹号的地方，是右节点没有，树不平衡了，此时x等于xp.right，这时候就左旋，否则就右旋&lt;br/&gt;左旋转&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        static &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateLeft(TreeNode&amp;lt;K,V&amp;gt; root,
                                              TreeNode&amp;lt;K,V&amp;gt; p) {
            TreeNode&amp;lt;K,V&amp;gt; r, pp, rl;
            if (p != null &amp;amp;&amp;amp; (r = p.right) != null) {
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                if ((pp = r.parent = p.parent) == null)
                    (root = r).red = false;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
            return root;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1429576/201807/1429576-20180717145505277-1490383791.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右旋转&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        static &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateRight(TreeNode&amp;lt;K,V&amp;gt; root,
                                               TreeNode&amp;lt;K,V&amp;gt; p) {
            TreeNode&amp;lt;K,V&amp;gt; l, pp, lr;
            if (p != null &amp;amp;&amp;amp; (l = p.left) != null) {
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent) == null)
                    (root = l).red = false;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1429576/201807/1429576-20180717145517456-169460231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，把根节点设置在第一位&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /**
         * Ensures that the given root is the first node of its bin.
         */
        static &amp;lt;K,V&amp;gt; void moveRootToFront(Node&amp;lt;K,V&amp;gt;[] tab, TreeNode&amp;lt;K,V&amp;gt; root) {
            int n;
            if (root != null &amp;amp;&amp;amp; tab != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0) {
                int index = (n - 1) &amp;amp; root.hash;
                TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;)tab[index];
                if (root != first) {
                    Node&amp;lt;K,V&amp;gt; rn;
                    tab[index] = root;
                    TreeNode&amp;lt;K,V&amp;gt; rp = root.prev;
                    if ((rn = root.next) != null)
                        ((TreeNode&amp;lt;K,V&amp;gt;)rn).prev = rp;
                    if (rp != null)
                        rp.next = rn;
                    if (first != null)
                        first.prev = root;
                    root.next = first;
                    root.prev = null;
                }
                assert checkInvariants(root);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果已经是红黑树了，插入进节点的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /**
         * Tree version of putVal.
         */
        final TreeNode&amp;lt;K,V&amp;gt; putTreeVal(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab,
                                       int h, K k, V v) {
            Class&amp;lt;?&amp;gt; kc = null;
            boolean searched = false;
            TreeNode&amp;lt;K,V&amp;gt; root = (parent != null) ? root() : this;
            for (TreeNode&amp;lt;K,V&amp;gt; p = root;;) {
                int dir, ph; K pk;
                if ((ph = p.hash) &amp;gt; h)
                    dir = -1;
                else if (ph &amp;lt; h)
                    dir = 1;
                else if ((pk = p.key) == k || (k != null &amp;amp;&amp;amp; k.equals(pk)))
                    return p;
                else if ((kc == null &amp;amp;&amp;amp;
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (!searched) {
                        TreeNode&amp;lt;K,V&amp;gt; q, ch;
                        searched = true;
                        if (((ch = p.left) != null &amp;amp;&amp;amp;
                             (q = ch.find(h, k, kc)) != null) ||
                            ((ch = p.right) != null &amp;amp;&amp;amp;
                             (q = ch.find(h, k, kc)) != null))
                            return q;
                    }
                    dir = tieBreakOrder(k, pk);
                }

                TreeNode&amp;lt;K,V&amp;gt; xp = p;
                if ((p = (dir &amp;lt;= 0) ? p.left : p.right) == null) {
                    Node&amp;lt;K,V&amp;gt; xpn = xp.next;
                    TreeNode&amp;lt;K,V&amp;gt; x = map.newTreeNode(h, k, v, xpn);
                    if (dir &amp;lt;= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    xp.next = x;
                    x.parent = x.prev = xp;
                    if (xpn != null)
                        ((TreeNode&amp;lt;K,V&amp;gt;)xpn).prev = x;
                    moveRootToFront(tab, balanceInsertion(root, x));
                    return null;
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和上面基本差不多，也是平衡，旋转，把root置为first。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 06:56:00 +0000</pubDate>
<dc:creator>丰极</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangbin1989/p/9323144.html</dc:identifier>
</item>
<item>
<title>Python 3 进阶 —— 使用 PyMySQL 操作 MySQL - Shocker</title>
<link>http://www.cnblogs.com/shockerli/p/python3-pymysql.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shockerli/p/python3-pymysql.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/PyMySQL/PyMySQL&quot;&gt;PyMySQL&lt;/a&gt; 是一个纯 Python 实现的 MySQL 客户端操作库，支持事务、存储过程、批量执行等。&lt;/p&gt;
&lt;p&gt;PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;pip install PyMySQL&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建数据库连接&quot;&gt;创建数据库连接&lt;/h2&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import pymysql

connection = pymysql.connect(host='localhost',
                             port=3306,
                             user='root',
                             password='root',
                             db='demo',
                             charset='utf8')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数列表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;30&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;数据库服务器地址，默认 localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;用户名，默认为当前程序运行用户&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;登录密码，默认为空字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;默认操作的数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;数据库端口，默认为 3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;bind_address&lt;/td&gt;
&lt;td&gt;当客户端有多个网络接口时，指定连接到主机的接口。参数可以是主机名或IP地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;unix_socket&lt;/td&gt;
&lt;td&gt;unix 套接字地址，区别于 host 连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;read_timeout&lt;/td&gt;
&lt;td&gt;读取数据超时时间，单位秒，默认无限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;write_timeout&lt;/td&gt;
&lt;td&gt;写入数据超时时间，单位秒，默认无限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;charset&lt;/td&gt;
&lt;td&gt;数据库编码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;sql_mode&lt;/td&gt;
&lt;td&gt;指定默认的 SQL_MODE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;read_default_file&lt;/td&gt;
&lt;td&gt;Specifies my.cnf file to read these parameters from under the [client] section.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;conv&lt;/td&gt;
&lt;td&gt;Conversion dictionary to use instead of the default one. This is used to provide custom marshalling and unmarshaling of types.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;use_unicode&lt;/td&gt;
&lt;td&gt;Whether or not to default to unicode strings. This option defaults to true for Py3k.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;client_flag&lt;/td&gt;
&lt;td&gt;Custom flags to send to MySQL. Find potential values in constants.CLIENT.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cursorclass&lt;/td&gt;
&lt;td&gt;设置默认的游标类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;init_command&lt;/td&gt;
&lt;td&gt;当连接建立完成之后执行的初始化 SQL 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;connect_timeout&lt;/td&gt;
&lt;td&gt;连接超时时间，默认 10，最小 1，最大 31536000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ssl&lt;/td&gt;
&lt;td&gt;A dict of arguments similar to mysql_ssl_set()'s parameters. For now the capath and cipher arguments are not supported.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;read_default_group&lt;/td&gt;
&lt;td&gt;Group to read from in the configuration file.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;compress&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;named_pipe&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;autocommit&lt;/td&gt;
&lt;td&gt;是否自动提交，默认不自动提交，参数值为 None 表示以服务器为准&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;local_infile&lt;/td&gt;
&lt;td&gt;Boolean to enable the use of LOAD DATA LOCAL command. (default: False)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;max_allowed_packet&lt;/td&gt;
&lt;td&gt;发送给服务器的最大数据量，默认为 16MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;defer_connect&lt;/td&gt;
&lt;td&gt;是否惰性连接，默认为立即连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;auth_plugin_map&lt;/td&gt;
&lt;td&gt;A dict of plugin names to a class that processes that plugin. The class will take the Connection object as the argument to the constructor. The class needs an authenticate method taking an authentication packet as an argument. For the dialog plugin, a prompt(echo, prompt) method can be used (if no authenticate method) for returning a string from the user. (experimental)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;server_public_key&lt;/td&gt;
&lt;td&gt;SHA256 authenticaiton plugin public key value. (default: None)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;db&lt;/td&gt;
&lt;td&gt;参数 database 的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;passwd&lt;/td&gt;
&lt;td&gt;参数 password 的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;binary_prefix&lt;/td&gt;
&lt;td&gt;Add _binary prefix on bytes and bytearray. (default: False)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;执行-sql&quot;&gt;执行 SQL&lt;/h2&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;cursor.execute(sql, args) 执行单条 SQL&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 获取游标
cursor = connection.cursor()

# 创建数据表
effect_row = cursor.execute('''
CREATE TABLE `users` (
  `name` varchar(32) NOT NULL,
  `age` int(10) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
''')

# 插入数据(元组或列表)
effect_row = cursor.execute('INSERT INTO `users` (`name`, `age`) VALUES (%s, %s)', ('mary', 18))

# 插入数据(字典)
info = {'name': 'fake', 'age': 15}
effect_row = cursor.execute('INSERT INTO `users` (`name`, `age`) VALUES (%(name)s, %(age)s)', info)

connection.commit()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;executemany(sql, args) 批量执行 SQL&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 获取游标
cursor = connection.cursor()

# 批量插入
effect_row = cursor.executemany(
    'INSERT INTO `users` (`name`, `age`) VALUES (%s, %s) ON DUPLICATE KEY UPDATE age=VALUES(age)', [
        ('hello', 13),
        ('fake', 28),
    ])

connection.commit()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：INSERT、UPDATE、DELETE 等修改数据的语句需手动执行&lt;code&gt;connection.commit()&lt;/code&gt;完成对数据修改的提交。&lt;/p&gt;
&lt;h2 id=&quot;获取自增-id&quot;&gt;获取自增 ID&lt;/h2&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;cursor.lastrowid&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询数据&quot;&gt;查询数据&lt;/h2&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 执行查询 SQL
cursor.execute('SELECT * FROM `users`')

# 获取单条数据
cursor.fetchone()

# 获取前N条数据
cursor.fetchmany(3)

# 获取所有数据
cursor.fetchall()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;游标控制&quot;&gt;游标控制&lt;/h2&gt;
&lt;p&gt;所有的数据查询操作均基于游标，我们可以通过&lt;code&gt;cursor.scroll(num, mode)&lt;/code&gt;控制游标的位置。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;cursor.scroll(1, mode='relative') # 相对当前位置移动
cursor.scroll(2, mode='absolute') # 相对绝对位置移动&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置游标类型&quot;&gt;设置游标类型&lt;/h2&gt;
&lt;p&gt;查询时，默认返回的数据类型为元组，可以自定义设置返回类型。支持5种游标类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Cursor: 默认，元组类型&lt;/li&gt;
&lt;li&gt;DictCursor: 字典类型&lt;/li&gt;
&lt;li&gt;DictCursorMixin: 支持自定义的游标类型，需先自定义才可使用&lt;/li&gt;
&lt;li&gt;SSCursor: 无缓冲元组类型&lt;/li&gt;
&lt;li&gt;SSDictCursor: 无缓冲字典类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无缓冲游标类型，适用于数据量很大，一次性返回太慢，或者服务端带宽较小时。源码注释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Unbuffered Cursor, mainly useful for queries that return a lot of data, or for connections to remote servers over a slow network.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Instead of copying every row of data into a buffer, this will fetch rows as needed. The upside of this is the client uses much less memory, and rows are returned much faster when traveling over a slow network&lt;br/&gt;or if the result set is very big.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;There are limitations, though. The MySQL protocol doesn't support returning the total number of rows, so the only way to tell how many rows there are is to iterate over every row returned. Also, it currently isn't possible to scroll backwards, as only the current row is held in memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建连接时，通过 cursorclass 参数指定类型：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;connection = pymysql.connect(host='localhost',
                             user='root',
                             password='root',
                             db='demo',
                             charset='utf8',
                             cursorclass=pymysql.cursors.DictCursor)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在创建游标时指定类型：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;cursor = connection.cursor(cursor=pymysql.cursors.DictCursor)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;事务处理&quot;&gt;事务处理&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;&lt;code&gt;connection.begin()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提交修改&lt;br/&gt;&lt;code&gt;connection.commit()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回滚事务&lt;br/&gt;&lt;code&gt;connection.rollback()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;防-sql-注入&quot;&gt;防 SQL 注入&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;转义特殊字符&lt;br/&gt;&lt;code&gt;connection.escape_string(str)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;参数化语句&lt;br/&gt;支持传入参数进行自动转义、格式化 SQL 语句，以避免 SQL 注入等安全问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 插入数据(元组或列表)
effect_row = cursor.execute('INSERT INTO `users` (`name`, `age`) VALUES (%s, %s)', ('mary', 18))

# 插入数据(字典)
info = {'name': 'fake', 'age': 15}
effect_row = cursor.execute('INSERT INTO `users` (`name`, `age`) VALUES (%(name)s, %(age)s)', info)

# 批量插入
effect_row = cursor.executemany(
    'INSERT INTO `users` (`name`, `age`) VALUES (%s, %s) ON DUPLICATE KEY UPDATE age=VALUES(age)', [
        ('hello', 13),
        ('fake', 28),
    ])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;个人博客同步地址：&lt;br/&gt;&lt;a href=&quot;https://shockerli.net/post/python3-pymysql/&quot; class=&quot;uri&quot;&gt;https://shockerli.net/post/python3-pymysql/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 06:50:00 +0000</pubDate>
<dc:creator>Shocker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shockerli/p/python3-pymysql.html</dc:identifier>
</item>
<item>
<title>[C#]实现任何数据库类型的DbHelper帮助类 - cnc</title>
<link>http://www.cnblogs.com/cncc/p/9323324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cncc/p/9323324.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文章为原创内容，如需转载，请注明作者及出处，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;一、在System.Data.Common命名空间下，存在这样的一个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     表示一组方法，这些方法用于创建提供程序对数据源类的实现的实例。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbProviderFactory
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     初始化 System.Data.Common.DbProviderFactory 类的新实例。&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; DbProviderFactory();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指定特定的 System.Data.Common.DbProviderFactory 是否支持 System.Data.Common.DbDataSourceEnumerator
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     类。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     如果 System.Data.Common.DbProviderFactory 的实例支持 System.Data.Common.DbDataSourceEnumerator
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     类，则为 true；否则为 false。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanCreateDataSourceEnumerator { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbCommand 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbCommand 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbCommand CreateCommand();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbCommandBuilder 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbCommandBuilder 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbCommandBuilder CreateCommandBuilder();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbConnection 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbConnection 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbConnection CreateConnection();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbConnectionStringBuilder 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbConnectionStringBuilder 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbConnectionStringBuilder CreateConnectionStringBuilder();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbDataAdapter 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbDataAdapter 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbDataAdapter CreateDataAdapter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbDataSourceEnumerator 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbDataSourceEnumerator 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbDataSourceEnumerator CreateDataSourceEnumerator();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回实现 System.Data.Common.DbParameter 类的提供程序的类的一个新实例。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Data.Common.DbParameter 的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; DbParameter CreateParameter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     返回提供程序的类的新实例，该实例可实现提供程序的 System.Security.CodeAccessPermission 类的版本。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   state:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Security.Permissions.PermissionState 值之一。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指定 System.Security.Permissions.PermissionState 的 System.Security.CodeAccessPermission
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     对象。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; CodeAccessPermission CreatePermission(PermissionState state);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，在此类中，有很多用于创建数据库相关对象的类型，如DbConnection，DbCommand，DbDataAdapter等。&lt;/p&gt;
&lt;p&gt;而且，实现诸如SqlConnection、SqlCommand、SqlDataAdapter（这里用的是SQL Server）的类型，都分别继承自DbConnection，DbCommand，DbDataAdapter，&lt;/p&gt;
&lt;p&gt;因此，我们可以使用DbProviderFactory来创建我们想要的、可实现任何数据库的DbHelper。&lt;/p&gt;
&lt;p&gt;二、实现基本的DbHelper帮助类&lt;/p&gt;
&lt;p&gt;1、我们将DbHelper定义为抽象类，并在类中提供一个抽象可读属性，名称叫DbProviderFactory，返回类型为DbProviderFactory（注：名称与返回类型可以为一样，也可以不一样），&lt;/p&gt;
&lt;p&gt;2、我们利用在该抽象类实现的子类中重写DbProviderFactory方法，并在子类的构造函数中为该属性赋值，该值就是已经实现了具体数据库类型的DbProviderFactory。&lt;/p&gt;
&lt;p&gt;定义的代码参考如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; DbProviderFactory DbProviderFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、我们为该抽象类编写一个构造函数，传进去的参数为连接字符串，并将其存储在可读的ConnectionString字段里，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbHelper(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            ConnectionString &lt;/span&gt;=&lt;span&gt; connectionString;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConnectionString { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; DbProviderFactory DbProviderFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、在DbHelper编写一些用于实现数据库相关操作的方法，这里就用到了DbProviderFactory类中的方法，以下方法仅供参考，具体请参照其他完整的DbHelp帮助类，&lt;/p&gt;
&lt;p&gt;DbHelper完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;帮助类的基类(抽象类)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbHelper(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            ConnectionString &lt;/span&gt;=&lt;span&gt; connectionString;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; DbProviderFactory DbProviderFactory {  &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; } 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConnectionString { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下实现的帮助类方法，仅供该例子使用，具体请参照其他完整的DbHelp帮助类&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThrowExceptionIfLengthNotEqual(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; sqls.Length != parameters.GetLength(&lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一维数组{nameof(sqls)}的长度与二维数组{nameof(parameters)}长度的第一维长度不一致&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; T[] Execute&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, CommandType commandType = CommandType.Text, ExecuteMode executeMode = ExecuteMode.NonQuery, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            ThrowExceptionIfLengthNotEqual(sqls, parameters);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(executeMode == ExecuteMode.NonQuery &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt;(T) != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidCastException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用NonQuery模式时，必须将类型T指定为int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbConnection connection =&lt;span&gt; DbProviderFactory.CreateConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbCommand command =&lt;span&gt; DbProviderFactory.CreateCommand())
            {
                connection.ConnectionString &lt;/span&gt;=&lt;span&gt; ConnectionString;
                connection.Open();
                command.Connection &lt;/span&gt;=&lt;span&gt; connection;
                command.CommandType &lt;/span&gt;=&lt;span&gt; commandType;
                DbTransaction transaction &lt;/span&gt;=&lt;span&gt; connection.BeginTransaction();
                command.Transaction &lt;/span&gt;=&lt;span&gt; transaction;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    List&lt;/span&gt;&amp;lt;T&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sqls.Length; i++&lt;span&gt;)
                    {
                        command.CommandText &lt;/span&gt;=&lt;span&gt; sqls[i];
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            command.Parameters.Clear();
                            command.Parameters.AddRange(parameters[i]);
                        }
                        &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (executeMode)
                        {
                            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExecuteMode.NonQuery:
                                result &lt;/span&gt;= command.ExecuteNonQuery(); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExecuteMode.Scalar:
                                result &lt;/span&gt;= command.ExecuteScalar(); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
                        }
                        resultList.Add((T)Convert.ChangeType(result, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T)));
                    }
                    transaction.Commit();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList.ToArray();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                    transaction.Rollback();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters)=&amp;gt; Execute&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sqls, CommandType.Text, ExecuteMode.NonQuery,parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQueryWithProc(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQueryWithProc(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql },  &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] ExecuteNonQueryWithProc(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sqls, CommandType.StoredProcedure, ExecuteMode.NonQuery, parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T ExecuteScalar&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T[] ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;T&amp;gt;&lt;span&gt;(sqls, CommandType.Text,ExecuteMode.Scalar, parameters);
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T ExecuteScalarWithProc&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T[] ExecuteNonQueryWithProc&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;T&amp;gt;&lt;span&gt;(sqls, CommandType.StoredProcedure, ExecuteMode.Scalar, parameters);
        
        &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ExecuteMode
        {
            NonQuery,Scalar
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DataTable[] Fill(&lt;span&gt;string&lt;/span&gt;[] selectSqls, CommandType commandType = CommandType.Text, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            ThrowExceptionIfLengthNotEqual(selectSqls, parameters);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbConnection connection =&lt;span&gt; DbProviderFactory.CreateConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbDataAdapter adapter =&lt;span&gt; DbProviderFactory.CreateDataAdapter())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbCommand command =&lt;span&gt; DbProviderFactory.CreateCommand())
            {
                connection.ConnectionString &lt;/span&gt;=&lt;span&gt; ConnectionString;
                connection.Open();
                command.Connection &lt;/span&gt;=&lt;span&gt; connection;
                command.CommandType &lt;/span&gt;=&lt;span&gt; commandType;
                adapter.SelectCommand &lt;/span&gt;=&lt;span&gt; command;
                List&lt;/span&gt;&amp;lt;DataTable&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DataTable&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; selectSqls.Length; i++&lt;span&gt;)
                {
                    command.CommandText &lt;/span&gt;=&lt;span&gt; selectSqls[i];
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        command.Parameters.Clear();
                        command.Parameters.AddRange(parameters[i]);
                    }
                    DataTable table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
                    adapter.Fill(table);
                    resultList.Add(table);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList.ToArray();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable Fill(&lt;span&gt;string&lt;/span&gt; selectSql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; Fill(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { selectSql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable[] Fill(&lt;span&gt;string&lt;/span&gt;[] selectSqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt;&lt;span&gt; Fill(selectSqls, CommandType.Text, parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable FillWithProc(&lt;span&gt;string&lt;/span&gt; selectSql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; FillWithProc(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { selectSql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable[] FillWithProc(&lt;span&gt;string&lt;/span&gt;[] selectSqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt;&lt;span&gt; Fill(selectSqls, CommandType.StoredProcedure, parameters);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、实现具体的数据库帮助类&lt;/p&gt;
&lt;p&gt;1、实现Sql Server的帮助类，具体方法：只要重写DbHelper类的DbProviderFactory属性并在构造函数为其赋值即可，其他的数据库帮助类亦是如此，&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于Sql Server的帮助类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlClientHelper : DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlClientHelper(&lt;span&gt;string&lt;/span&gt; connectionString) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(connectionString)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DbProviderFactory =&lt;span&gt; SqlClientFactory.Instance;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; DbProviderFactory DbProviderFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、参照以上，实现SQLite帮助类如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于SQLite的帮助类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SQLiteHelper : DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SQLiteHelper(&lt;span&gt;string&lt;/span&gt; connectionString) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(connectionString)
        {
            DbProviderFactory &lt;/span&gt;=&lt;span&gt; SQLiteFactory.Instance;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; DbProviderFactory DbProviderFactory  { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、其他数据库的帮助类，正如以上所说的，只要重写DbHelper类的DbProviderFactory属性并在构造函数为其赋值即可。&lt;/p&gt;
&lt;p&gt;四、示例演示&lt;/p&gt;
&lt;p&gt;使用前，必须引用了System.Data.SQLite，具体请参考一下文章：&lt;/p&gt;

&lt;p&gt;编写的客户端代码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端调用&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(fileName)) File.Delete(fileName);
            SQLiteConnection.CreateFile(fileName);
            SQLiteHelper helper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SQLiteHelper($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source = {fileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            helper.ExecuteNonQuery(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CREATE TABLE IF NOT EXISTS Info(ID integer PRIMARY KEY AUTOINCREMENT, Guid text)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; sqlList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
            {
                sqlList.Add($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO Info VALUES(null,'{Guid.NewGuid()}')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            helper.ExecuteNonQuery(sqlList.ToArray());
            DataTable table &lt;/span&gt;= helper.Fill(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM Info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            table.Rows.Cast&lt;/span&gt;&amp;lt;DataRow&amp;gt;().ToList().ForEach(x =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{x[0]}\t{x[1]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/580518/201807/580518-20180717144315281-564221231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五、完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0fd22ea6-f550-4af0-96e7-bbb72fcbc34f')&quot; readability=&quot;55.5&quot;&gt;&lt;img id=&quot;code_img_closed_0fd22ea6-f550-4af0-96e7-bbb72fcbc34f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0fd22ea6-f550-4af0-96e7-bbb72fcbc34f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0fd22ea6-f550-4af0-96e7-bbb72fcbc34f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0fd22ea6-f550-4af0-96e7-bbb72fcbc34f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;106&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.Common;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.SqlClient;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.SQLite;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApp
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端调用&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(fileName)) File.Delete(fileName);
            SQLiteConnection.CreateFile(fileName);
            SQLiteHelper helper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SQLiteHelper($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source = {fileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            helper.ExecuteNonQuery(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CREATE TABLE IF NOT EXISTS Info(ID integer PRIMARY KEY AUTOINCREMENT, Guid text)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; sqlList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
            {
                sqlList.Add($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO Info VALUES(null,'{Guid.NewGuid()}')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            helper.ExecuteNonQuery(sqlList.ToArray());
            DataTable table &lt;/span&gt;= helper.Fill(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM Info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            table.Rows.Cast&lt;/span&gt;&amp;lt;DataRow&amp;gt;().ToList().ForEach(x =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{x[0]}\t{x[1]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            Console.ReadKey();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于Sql Server的帮助类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlClientHelper : DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlClientHelper(&lt;span&gt;string&lt;/span&gt; connectionString) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(connectionString)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DbProviderFactory =&lt;span&gt; SqlClientFactory.Instance;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; DbProviderFactory DbProviderFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于SQLite的帮助类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SQLiteHelper : DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SQLiteHelper(&lt;span&gt;string&lt;/span&gt; connectionString) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(connectionString)
        {
            DbProviderFactory &lt;/span&gt;=&lt;span&gt; SQLiteFactory.Instance;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; DbProviderFactory DbProviderFactory  { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------------------------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他数据库的帮助类，只要重写DbHelper类的DbProviderFactory属性并在构造函数为其赋值即可
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;帮助类的基类(抽象类)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbHelper(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            ConnectionString &lt;/span&gt;=&lt;span&gt; connectionString;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; DbProviderFactory DbProviderFactory {  &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; } 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConnectionString { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下实现的帮助类方法，仅供该例子使用，具体请参照其他完整的DbHelp帮助类&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThrowExceptionIfLengthNotEqual(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; sqls.Length != parameters.GetLength(&lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一维数组{nameof(sqls)}的长度与二维数组{nameof(parameters)}长度的第一维长度不一致&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; T[] Execute&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, CommandType commandType = CommandType.Text, ExecuteMode executeMode = ExecuteMode.NonQuery, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            ThrowExceptionIfLengthNotEqual(sqls, parameters);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(executeMode == ExecuteMode.NonQuery &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt;(T) != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidCastException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用NonQuery模式时，必须将类型T指定为int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbConnection connection =&lt;span&gt; DbProviderFactory.CreateConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbCommand command =&lt;span&gt; DbProviderFactory.CreateCommand())
            {
                connection.ConnectionString &lt;/span&gt;=&lt;span&gt; ConnectionString;
                connection.Open();
                command.Connection &lt;/span&gt;=&lt;span&gt; connection;
                command.CommandType &lt;/span&gt;=&lt;span&gt; commandType;
                DbTransaction transaction &lt;/span&gt;=&lt;span&gt; connection.BeginTransaction();
                command.Transaction &lt;/span&gt;=&lt;span&gt; transaction;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    List&lt;/span&gt;&amp;lt;T&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sqls.Length; i++&lt;span&gt;)
                    {
                        command.CommandText &lt;/span&gt;=&lt;span&gt; sqls[i];
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            command.Parameters.Clear();
                            command.Parameters.AddRange(parameters[i]);
                        }
                        &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (executeMode)
                        {
                            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExecuteMode.NonQuery:
                                result &lt;/span&gt;= command.ExecuteNonQuery(); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExecuteMode.Scalar:
                                result &lt;/span&gt;= command.ExecuteScalar(); &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
                        }
                        resultList.Add((T)Convert.ChangeType(result, &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T)));
                    }
                    transaction.Commit();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList.ToArray();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                    transaction.Rollback();
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters)=&amp;gt; Execute&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sqls, CommandType.Text, ExecuteMode.NonQuery,parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQueryWithProc(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQueryWithProc(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql },  &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] ExecuteNonQueryWithProc(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sqls, CommandType.StoredProcedure, ExecuteMode.NonQuery, parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T ExecuteScalar&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T[] ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;T&amp;gt;&lt;span&gt;(sqls, CommandType.Text,ExecuteMode.Scalar, parameters);
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T ExecuteScalarWithProc&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; ExecuteNonQuery&amp;lt;T&amp;gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { sql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T[] ExecuteNonQueryWithProc&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;[] sqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt; Execute&amp;lt;T&amp;gt;&lt;span&gt;(sqls, CommandType.StoredProcedure, ExecuteMode.Scalar, parameters);
        
        &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ExecuteMode
        {
            NonQuery,Scalar
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DataTable[] Fill(&lt;span&gt;string&lt;/span&gt;[] selectSqls, CommandType commandType = CommandType.Text, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; DbParameter[][] parameters)
        {
            ThrowExceptionIfLengthNotEqual(selectSqls, parameters);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbConnection connection =&lt;span&gt; DbProviderFactory.CreateConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbDataAdapter adapter =&lt;span&gt; DbProviderFactory.CreateDataAdapter())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DbCommand command =&lt;span&gt; DbProviderFactory.CreateCommand())
            {
                connection.ConnectionString &lt;/span&gt;=&lt;span&gt; ConnectionString;
                connection.Open();
                command.Connection &lt;/span&gt;=&lt;span&gt; connection;
                command.CommandType &lt;/span&gt;=&lt;span&gt; commandType;
                adapter.SelectCommand &lt;/span&gt;=&lt;span&gt; command;
                List&lt;/span&gt;&amp;lt;DataTable&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DataTable&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; selectSqls.Length; i++&lt;span&gt;)
                {
                    command.CommandText &lt;/span&gt;=&lt;span&gt; selectSqls[i];
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameters.GetLength(&lt;span&gt;0&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        command.Parameters.Clear();
                        command.Parameters.AddRange(parameters[i]);
                    }
                    DataTable table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
                    adapter.Fill(table);
                    resultList.Add(table);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList.ToArray();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable Fill(&lt;span&gt;string&lt;/span&gt; selectSql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; Fill(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { selectSql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable[] Fill(&lt;span&gt;string&lt;/span&gt;[] selectSqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt;&lt;span&gt; Fill(selectSqls, CommandType.Text, parameters);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable FillWithProc(&lt;span&gt;string&lt;/span&gt; selectSql, &lt;span&gt;params&lt;/span&gt; DbParameter[] parameter) =&amp;gt; FillWithProc(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { selectSql }, &lt;span&gt;new&lt;/span&gt; DbParameter[][] { parameter })[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DataTable[] FillWithProc(&lt;span&gt;string&lt;/span&gt;[] selectSqls, &lt;span&gt;params&lt;/span&gt; DbParameter[][] parameters) =&amp;gt;&lt;span&gt; Fill(selectSqls, CommandType.StoredProcedure, parameters);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Jul 2018 06:49:00 +0000</pubDate>
<dc:creator>cnc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cncc/p/9323324.html</dc:identifier>
</item>
<item>
<title>【精解】EOS TPS 多维实测 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/eostps.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/eostps.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要研究EOS的tps表现，会从插件、cleos、EOSBenchTool以及eosjs四种方式进行分析研究。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;关键字：eos, tps, cleos, txn_test_gen_plugin, EOSBenchTool, qt, eosjs, C++源码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;tps: Transaction per Second. 每秒事务处理量&lt;/li&gt;
&lt;li&gt;链环境部署使用Python3脚本 bios-boot-tutorial，使用方法请参考&lt;a href=&quot;https://www.cnblogs.com/Evsward/p/eos-boot.html#%E5%90%AF%E5%8A%A8%E5%BA%8F%E5%88%97&quot;&gt;boot-sequence脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;测试机器的硬件配置：双核cpu + 8G内存&lt;/li&gt;
&lt;li&gt;eos中一个transaction的结构，展示如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;{
    &quot;transaction_id&quot;: &quot;7943f613f8cde71bc37d76daf3581ceb62ae6d481fa9b3a11ba73d19d909c666&quot;,
    &quot;broadcast&quot;: false,
    &quot;transaction&quot;: {
        &quot;compression&quot;: &quot;none&quot;,
        &quot;transaction&quot;: {
            &quot;expiration&quot;: &quot;2018-07-12T09:51:14&quot;,
            &quot;ref_block_num&quot;: 526,
            &quot;ref_block_prefix&quot;: 52869816,
            &quot;net_usage_words&quot;: 0,
            &quot;max_cpu_usage_ms&quot;: 0,
            &quot;delay_sec&quot;: 0,
            &quot;context_free_actions&quot;: [],
            &quot;actions&quot;: [
                {
                    &quot;account&quot;: &quot;eosio.token&quot;,
                    &quot;name&quot;: &quot;transfer&quot;,
                    &quot;authorization&quot;: [
                        {
                            &quot;actor&quot;: &quot;eosiotestay&quot;,
                            &quot;permission&quot;: &quot;active&quot;
                        }
                    ],
                    &quot;data&quot;: &quot;00bcc95865ea305500fcc95865ea3055010000000000000004535953000000000c7061636b696e672074657374&quot;
                }
            ],
            &quot;transaction_extensions&quot;: []
        },
        &quot;signatures&quot;: [
            &quot;SIG_K1_KB6ENT2Ns3QmaPSfvxqCkgZTjK5RUDRFwkZ7p9Jv6p1GpnD67jhMUsw1Spfp7yw4hChsubPeiTc2HSt5hc6YdMH5rk5Kfz&quot;
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于我们在研究eos阶段，大量使用到cleos，因此使用cleos来测试tps是我们第一个能想到的手段。这一节我们将加深理解tps的意义，tps的计算方法，讨论单节点与多节点环境对tps的影响。&lt;/p&gt;
&lt;h2 id=&quot;单节点环境&quot;&gt;单节点环境&lt;/h2&gt;
&lt;p&gt;单节点的搭建这里不再赘述，直接使用脚本执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bios-boot-tutorial.py -k -w -b -s -c -t -S -T --user-limit 1000 -X&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意参数的顺序不能变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行成功以后，我们将得到一个拥有1000个stake账户（简单理解为已抵押完可直接投票的账户）的单节点eos环境，最后一个参数-X会让当前环境不断执行随机转账操作（注意：每一笔转账都是一个action，一个action对应一个transaction）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看日志&lt;/strong&gt;&lt;br/&gt;修改脚本的stepLog函数，改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def stepLog():
    run('tail -f ' + args.nodes_dir + '00-eosio/stderr')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在终端执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bios-boot-tutorial.py -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可进入同步日志输出的界面。&lt;/p&gt;
&lt;h3 id=&quot;一shell方式&quot;&gt;一、shell方式&lt;/h3&gt;
&lt;p&gt;环境准备完毕，我们来测试一下当前正在不断进行转账的eos链上的tps表现。这里采用的tps计算方式为：&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;tps = BlockTxs*2&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为eos是半秒出块，所以两个块的打包交易量之和就是tps，为确保数值可靠性，每个块的打包交易量我们要通过大量区块取平均值的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于以上思想，可以总结出一个shell命令直接在终端执行即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (( i = 12638; i &amp;lt;= 13638; i++ )); do cleos --wallet-url http://localhost:6666 --url http://localhost:8000 get block $i | grep &quot;executed&quot; | wc -l; done  | awk '{sum+=$1} END {print NR,&quot;blocks average tps =&quot;, sum/NR*2}'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;取出区块号从200到1200的区块，分别计算每个区块的打包交易量（通过统计其包含的“executed”即可，因为每个交易对应一个“executed”），然后将这些区块交易量进行累加除以数量得到平均值，再乘以2，辅以可视化备注输出即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最终结果不是很理想，至少距离官方声称的几千tps有很大差距。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1001 blocks average tps = 39.2727&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以1000个块统计tps为 39.2727&lt;/p&gt;
&lt;h3 id=&quot;二python脚本&quot;&gt;二、python脚本&lt;/h3&gt;
&lt;p&gt;由于tps的结果不理想，我也有过很多思考，下面我们换一种计算方式来看：&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;tps = trxs/time&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里通过一种简单的方式来计算tps：即统计共发出了trxs笔交易所耗费的时间，以秒为单位，然后相除即可得到tps。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于以上思想，由于这部分代码是无法通过一行shell解决的，所以我通过修改bios脚本来解决，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加内容：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def stepTPS():
    start = time.time()
    numtps = args.num_tps
    i = 0
    while i &amp;lt; numtps :
        print (&quot;on: &quot;,i)
        randomTransfer(0, args.num_senders,1)
        i=i+1
    elapsed = (time.time() - start)
    print (&quot;Time used:&quot;,elapsed,&quot;s tps=&quot;,numtps/elapsed)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改randomTransfer函数，增加参数t，用来决定循环次数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def randomTransfer(b, e, t):
    for j in range(t):
        src = accounts[random.randint(b, e - 1)]['name']
        dest = src
        while dest == src:
            dest = accounts[random.randint(b, e - 1)]['name']
        run(args.cleos + 'transfer -f ' + src + ' ' + dest + ' &quot;0.0001 ' + args.symbol + '&quot;' + ' || true')&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;增加命令：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;('A', 'tps',            stepTPS,                    False,   &quot;calculate the tps&quot;),&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;增加参数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;parser.add_argument('--num-tps', metavar='', help=&quot;Number of tps test trx&quot;, type=int, default=1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;执行A：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，在执行前，我们要先停掉单节点环境，将-X去掉，而采用我们的-A来执行随机转账。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;./bios-boot-tutorial.py -k -w -b -s -c -t -S -T --user-limit 1000 -X&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;执行B：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;./bios-boot-tutorial.py -A --num-tps 2000&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;发起2000笔交易，然后使用脚本函数stepTPS进行测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Time used: 26.172592401504517 s tps= 38.20790790072884&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果与shell方式差不多，都是不到40的tps表现。&lt;/p&gt;
&lt;h2 id=&quot;多节点环境&quot;&gt;多节点环境&lt;/h2&gt;
&lt;p&gt;tps的结果不尽人意，我又转念想到了是否因为单节点出块的原因。因此我搭建了多节点出块加全节点的环境，搭建环境的方法可以参考&lt;a href=&quot;https://www.cnblogs.com/Evsward/p/eos-boot.html&quot;&gt;《【精解】EOS多节点组网：商业场景分析以及节点启动时序》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我仍旧通过以上两种方式，分别是shell方式和Python脚本的方式去测试，最后结果是并无改变，这也证实了eos不具备多线程处理事务的能力。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;插曲：我将python脚本的修改提交了EOSIO/eos的官方pr，结果被拒绝合并，原因是“unrelated change”，转念一想，如果合并至源码，用户可以通过这种方式直白地得到eos的tps就是几十个的结论，那绝对是很不好的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我对eos的高tps有了深深地怀疑，于是找来了官方的tps测试插件，要亲自感受一下tps的“洗礼”。插件的使用方式很简单，按照&lt;a href=&quot;https://github.com/EOSIO/eos/tree/master/plugins/txn_test_gen_plugin&quot;&gt;官方文档&lt;/a&gt;的步骤执行即可，最后我调整参数：&lt;/p&gt;
&lt;blockquote readability=&quot;5.5909090909091&quot;&gt;
&lt;p&gt;curl --data-binary '[&quot;&quot;30, 50]' &lt;a class=&quot;uri&quot;&gt;http:/&lt;/a&gt; /localhost:8888/v1/txn_test_gen/start_generationn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链上日志结果：&lt;br/&gt;&lt;img src=&quot;https://github.com/evsward/banner/blob/master/resouce/20180712151825.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过trxs一列可以看出，每个区块打包的交易量大大提升了，平均tps在2000左右。&lt;/p&gt;
&lt;blockquote readability=&quot;6.4524590163934&quot;&gt;
&lt;p&gt;插件的测试方法也是bm所推崇的，他说通过cleos无法发挥出真正的eos的性能。那么具体是为什么，我们通过插件的源码txn_test_gen_plugin.cpp进行分析，我将这一部分内容单独成文，请阅读《&lt;a href=&quot;https://www.cnblogs.com/Evsward/p/txn_test_gen_plugin.html&quot;&gt;【源码解读】EOS测试插件：txn_test_gen_plugin.cpp&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/OracleChain/EOSBenchTool&quot;&gt;EOSBenchTool&lt;/a&gt;来自于OracleChain的贡献，虽然他们的节点&lt;a href=&quot;https://eostracker.io/producers/oraclegogogo&quot;&gt;oraclegogogo&lt;/a&gt;没竞选上bp，但我认为bp的竞选更多是市场行为，不是技术实力的“成绩单”，在所有bp中，目前我也仅看到了OracleChain做出的技术方面的贡献，包括对EOSIO/eos的pr，都是OracleChain自身技术气质的体现。多余夸奖的话不多讲了，下面来研究这套工具内容。&lt;/p&gt;
&lt;p&gt;EOSBenchTool的思想与以上的cleos有很大不同，与插件的方式（打包交易）比较相似，但它的实现方式却是独具一格的，他并不是像插件那样直接在“服务器端”自我模拟交易来测试tps。他们敢于直接使用C++ 来编写客户端请求主网来打包、发起请求，最终测试得到一个非常不错的结果，大约可以到200到300，这个结果也是我在众多压测手段中得到的比较理想的结果，包括下面要介绍到的eosjs的方式，都不及EOSBenchTool的测试结果。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;EOSBenchTool既能不牺牲在真实场景中的模拟，又能通过技术手段优化交易通讯，可以说他的tps结果是比较具备真实性、业务可行性，以及他的技术实现手段也是非常值得业务方来学习并尝试使用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方文档的介绍比较技术范儿，就是不太亲民。这里我给他填点肉，希望层级尝试使用EOSBenchTool却失败的朋友能够在这里找到答案。&lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;
&lt;h4 id=&quot;一eos主网环境&quot;&gt;一、EOS主网环境&lt;/h4&gt;
&lt;p&gt;首先，要准备EOS主网环境，可以通过脚本快速获得：python3 ./bios-boot-tutorial.py -k -w -b -s -c -t (不部署system合约，因为部署后无法使用create account创建账户。)&lt;/p&gt;
&lt;h4 id=&quot;二获取代码qt工具编译代码&quot;&gt;二、获取代码，QT工具，编译代码&lt;/h4&gt;
&lt;ul readability=&quot;0.98593200468933&quot;&gt;&lt;li&gt;源码位置：&lt;a href=&quot;https://github.com/OracleChain/EOSBenchTool&quot;&gt;EOSBenchTool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;QT去官网下载community版本即可，注意：QT在安装时要同时勾选安装 &lt;strong&gt;QCreator&lt;/strong&gt; 和 &lt;strong&gt;QT source&lt;/strong&gt; 以及 &lt;strong&gt;QT prebuild tool&lt;/strong&gt;（这里我选择的是&lt;strong&gt;mingw&lt;/strong&gt;）&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;打开QCreator，一般情况下，上面的步骤准备妥当以后，QCreator会自动检测一套&lt;strong&gt;构建套件(Kit)&lt;/strong&gt;，构建套件依赖于Qt Version、编译器、Debuggers，Cmakes，这些工具也都是可以自动检测到的，如果无法检测到，一定是某个工具未安装，请检查相应的工具，并重新下载安装（一般来讲，所有这些工具在QT安装包都会包含，只需再次打开QT安装包，选择更新，重新勾选缺乏的工具安装即可。）最终我的&lt;strong&gt;构建套件(Kit)&lt;/strong&gt; 截图如下：&lt;br/&gt;&lt;img src=&quot;https://github.com/evsward/banner/blob/master/resouce/QT20180716112225.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;QCreator中，Open Project 导入项目源码中的文件 src/EOSBenchTool.pro，点击左下角小锄头构建项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;启动eosbenchtool&quot;&gt;启动EOSBenchTool&lt;/h3&gt;
&lt;p&gt;以上工作都顺利完成以后，在QCreator中，点击左下角三角按钮运行启动EOSBenchTool工具。建议将UI最大化，可以更方便地查看日志。填写好setting内容，如下：&lt;br/&gt;&lt;img src=&quot;https://github.com/evsward/banner/blob/master/resouce/EOSBenchTool20180716113120.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于几个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Thread number：会创建对应的账户数量。&lt;/li&gt;
&lt;li&gt;Transaction pool size：总共发送的测试交易笔数&lt;/li&gt;
&lt;li&gt;Transaction batch size：打包时每个包内包含的交易笔数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他参数不多介绍。设置好参数以后，点击OK保存，然后切换到 Benchmark Testing 点击Prepare：创建测试账户、给测试账户转账、每个测试账户发起测试交易并打包。&lt;/p&gt;
&lt;p&gt;等待Prepare结束，1万笔测试交易大约两到三分钟，视客户端机器本地性能。然后点击Start，得到tps结果，这里由于界面都是可视化的，我不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;这部分我们将一起通过源码学习EOSBenchTool打包交易的原理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整个EOSBenchTool工具，我们从main.cpp入口，然后转到主要文件mainwindow.cpp，这里面包含了UI界面配置，传参，以及按钮事件，这里面我们主要关注按钮事件，总共有三个：
&lt;ul&gt;&lt;li&gt;on_pushButtonOK_clicked，这是对应界面 setting 中的ok按钮，这是负责传参的，这里不做介绍。&lt;/li&gt;
&lt;li&gt;on_pushButtonInitialize_clicked，这是对应界面 Benchmark Testing 中的Prepare按钮，稍后主要分析。&lt;/li&gt;
&lt;li&gt;on_pushButtonRun_clicked，这是对应界面 Benchmark Testing 中的Start按钮，稍后主要分析。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;on_pushbuttoninitialize_clicked&quot;&gt;on_pushButtonInitialize_clicked&lt;/h3&gt;
&lt;p&gt;Prepare阶段，正如上面在EOSBenchTool使用中介绍到的那样，包括创建账户，转账，打包。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过CreateAccount对象创建测试账户&lt;/li&gt;
&lt;li&gt;通过PushManager来转账&lt;/li&gt;
&lt;li&gt;通过Packer来打包交易&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建账户&quot;&gt;创建账户&lt;/h4&gt;
&lt;p&gt;下面先来看创建账户的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CreateAccount createAccount;
int count = createAccount.create(thread_num, [=](const QString&amp;amp; name, bool res) { // lambda格式的回调函数：打印日志
    commonOutput(QString(&quot;Create %1 %2.&quot;).arg(name).arg(res ? &quot;succeed&quot; : &quot;failed&quot;));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入createaccount.cpp文件，查看create函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int CreateAccount::create(int threadNum, const create_account_callback&amp;amp; func)
{
    if (threadNum &amp;lt;= 0) { // 根据threadNum个数创建对应数量的账户。
        return 0;
    }
    // 清空其他账户
    AccountManager::instance().removeAll();
    
    for (int i = 0; i &amp;lt; threadNum; ++i) {
        eos_key owner, active;
        keys.clear(); // 头文件中的 QVector&amp;lt;eos_key&amp;gt; keys;
        keys.push_back(owner); // 添加owner和active权限到keys对象
        keys.push_back(active);
    
        newAccountName = createNewName();
    
        bool res = false;
    
        QEventLoop loop;
        // WINSOCK_API_LINKAGE int PASCAL connect (SOCKET, const struct sockaddr *, int);
        // 通过connect开启一个socket通道
        connect(this, &amp;amp;CreateAccount::oneRoundFinished, &amp;amp;loop, &amp;amp;QEventLoop::quit);
    
        if (httpc) { // httpc(new HttpClient)
            httpc-&amp;gt;request(FunctionID::get_info); // 通过http请求get info
            // 以上的get_info回调函数，实际功能函数：get_info_returned，由connect开启socket访问进去。
            connect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;CreateAccount::get_info_returned);
        }
    
        loop.exec();
    
        // 返回执行结果res，成功为true，失败为false
        res = !(AccountManager::instance().listKeys(newAccountName).first.empty());
    
        // 执行回调函数：打印日志
        func(newAccountName, res);
    }
    
    return AccountManager::instance().count() - 1;  // 除了super account以外的集合中的账户个数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看一下AccountManager的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class AccountManager
{
    public:
        AccountManager();
        static AccountManager&amp;amp; instance();
    
        void addAccounts(const QString&amp;amp; name, const QPair&amp;lt;std::string, std::string&amp;gt;&amp;amp; keypairs);
        void removeAll();
        QPair&amp;lt;std::string, std::string&amp;gt; listKeys(const QString&amp;amp; account);
        QVector&amp;lt;std::string&amp;gt; listAccounts();
        int count() const;
    
    private: // 私有属性，QMap集合对象 accounts
        QMap&amp;lt;QString, QPair&amp;lt;std::string, std::string&amp;gt;&amp;gt; accounts;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;removeAll的实现方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void AccountManager::removeAll()
{
    QPair&amp;lt;std::string, std::string&amp;gt; superKey = accounts[super_account];
    accounts.clear();
    accounts.insert(super_account, superKey);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;super_account和superKey是全局变量，在mainwindow.cpp前面标明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QString super_account = &quot;eosio&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，是对QMap集合对象 accounts的操作。接着，账户名的生成方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QString CreateAccount::createNewName()
{
    // eos的命名规则
    static const char *char_map = &quot;12345abcdefghijklmnopqrstuvwxyz&quot;;
    int map_size = strlen(char_map);
    QString newName;
    
    for (int i = 0; i &amp;lt; 5; ++i) {
        int r = rand() % map_size; // 随机选出char_map的下标位置
        newName += char_map[r];
    } // 返回的是一个五位的名字
    
    return newName;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AccountManager的实例也是个static的单例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AccountManager &amp;amp;AccountManager::instance()
{
    static AccountManager manager;
    return manager;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;get_info_returned函数，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void CreateAccount::get_info_returned(const QByteArray &amp;amp;data)
{
    //先关闭进来的socket通道
    disconnect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;CreateAccount::get_info_returned);
    
    getInfoData.clear();
    getInfoData = data;
    
    QByteArray param = packGetRequiredKeysParam();
    if (param.isNull()) {
        emit oneRoundFinished();
        return;
    }
    
    if (httpc) {
        // 通过http请求链的get_required_keys接口，传入对应事务的json格式作为入参。
        httpc-&amp;gt;request(FunctionID::get_required_keys, param);
        // get_required_keys的回调函数，通过socket建立通道去访问get_required_keys_returned函数。
        connect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;CreateAccount::get_required_keys_returned);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转到函数packGetRequiredKeysParam()，该函数是创建账户的实际生效函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QByteArray CreateAccount::packGetRequiredKeysParam()
{
    if (getInfoData.isEmpty()) {
        return QByteArray();
    }
    
    // 组装了newAccount的请求数据
    EOSNewAccount newAccount(EOS_SYSTEM_ACCOUNT, newAccountName.toStdString(),
                             keys.at(0).get_eos_public_key(), keys.at(1).get_eos_public_key(),
                             EOS_SYSTEM_ACCOUNT);
    
    std::vector&amp;lt;unsigned char&amp;gt; hexData = newAccount.dataAsHex(); // 将data对象转为十六进制
    // 通过ChainManager创建事务，是创建账户的事务。
    signedTxn = ChainManager::createTransaction(EOS_SYSTEM_ACCOUNT, newAccount.getActionName(), std::string(hexData.begin(), hexData.end()),
                                                ChainManager::getActivePermission(EOS_SYSTEM_ACCOUNT), getInfoData);
    QJsonObject txnObj = signedTxn.toJson().toObject();
    
    QJsonArray avaibleKeys;
    std::string pub = eos_key::get_eos_public_key_by_wif(super_private_key.toStdString());// 通过私钥获得公钥
    avaibleKeys.append(QJsonValue(QString::fromStdString(pub)));
    
    QJsonObject obj;
    obj.insert(&quot;available_keys&quot;, avaibleKeys);
    obj.insert(&quot;transaction&quot;, txnObj);
    return QJsonDocument(obj).toJson();// 最终获得json格式的创建账户的事务对象
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入get_required_keys_returned函数，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void CreateAccount::get_required_keys_returned(const QByteArray &amp;amp;data)
{
    disconnect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;CreateAccount::get_required_keys_returned);

    getRequiredKeysData.clear();
    getRequiredKeysData = data;

    QByteArray param = packPushTransactionParam();
    if (param.isNull()) {
        emit oneRoundFinished();
        return;
    }

    if (httpc) {
        // 相同的套路，通过packPushTransactionParam()函数组装好的推送交易接口的入参param，然后通过http发起请求。
        httpc-&amp;gt;request(FunctionID::push_transaction, param);
        // 通过connect建立socket连接访问push_transaction的回调函数push_transaction_returned，继续处理。
        connect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;CreateAccount::push_transaction_returned);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;packPushTransactionParam()，开始组装push transaction的参数，由于代码中对于数据的处理较多，这里只展示结果的部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 给上面由函数packGetRequiredKeysParam()组装的交易signedTxn签名。
signedTxn.sign(pri, TypeChainId::fromHex(info.value(&quot;chain_id&quot;).toString().toStdString()));
PackedTransaction packedTxn(signedTxn, &quot;none&quot;);

QJsonObject obj = packedTxn.toJson().toObject();

return QJsonDocument(obj).toJson(); // 获得签名后的交易数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;push_transaction_returned，我们经过大量的组合校验，与链上的信息进行同步组装获得了合法的签名交易对象，然后通过http接口请求了push_transaction接口将签名交易对象推送到链上执行，执行结果通过回调函数处理，回调函数的主要作用是将处理结果 -&amp;gt; 成功创建了的这个账户，存入集合accounts中，由于accounts是私有属性，所以通过方法AccountManager::instance().addAccounts执行。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;客户端本地保存了一个对象accounts用来同步自己创建过的账户。大部分代码是对accounts的处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;账户转账&quot;&gt;账户转账&lt;/h4&gt;
&lt;p&gt;在上一个创建账户的部分，我们详细解读了通讯的过程，仍旧是通过http去发起请求，通过每个请求的回调函数进行处理，组装，维护了本地的集合accounts。由于篇幅过大，在之后的介绍中，不会再过多介绍，而专注于实现方式的核心代码。转账的核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QVector&amp;lt;std::string&amp;gt; accounts = AccountManager::instance().listAccounts(); // 通过accounts获得测试账户们
int accountSize = accounts.size();
int balance = total_tokens / accountSize; // 平均分配测试用币
for (int i = 0; i &amp;lt; accountSize; ++i) {
    PushManager push;
    QString quantity = QString(&quot;%1.0000 %2&quot;).arg(balance).arg(token_name); // 拼串，转账额度
    QString to = QString::fromStdString(accounts.at(i)); // 遍历接收转账的账户
    commonOutput(QString(&quot;Transfering %1 to %2 ...&quot;).arg(quantity).arg(to)); // 日志
    bool ret = push.transferToken(super_account, to, quantity); // 核心生效代码，是PushManager的transferToken函数。
    commonOutput(ret ? &quot;Succeed.&quot; : &quot;Failed.&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PushManager的transferToken函数是本地组装了标准的转账请求参数，json字符串格式的from, to, quality以及memo信息。然后跳转到make_push函数。make_push函数需要通过http请求接口&lt;strong&gt;abi_json_to_bin&lt;/strong&gt;，而针对该接口的入参，都需要在这个函数处理获取到，入参包括action，code以及args。code就是对应的合约的code，例如我们使用账户eosio部署了合约eosio.system，那么eosio.system的code就可以通过get code eosio获得。action就是转账：transfer。args就是上面PushManager的transferToken函数组装的参数对象。http请求成功以后，通过回调函数abi_json_to_bin_returned处理响应结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (httpc) {
    httpc-&amp;gt;request(FunctionID::abi_json_to_bin, QJsonDocument(obj).toJson());
    connect(httpc, &amp;amp;HttpClient::responseData, this, &amp;amp;PushManager::abi_json_to_bin_returned);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接口abi_json_to_bin：序列化json数据为二进制数据。这个结果的数据通常用在push_transaction的data字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;action.setData(hexData); // action的hexData字段就是以上接口**abi\_json\_to\_bin**获得的结果。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩余部分与上面介绍“创建账户”相同，get_info -&amp;gt; get_required_keys -&amp;gt; push_transaction 的流程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总结一下，转账由于涉及到合约，所以多了一步abi_json_to_bin，而创建账户不需要这一步，但创建账户需要本地的集合对象同步存储。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;打包交易&quot;&gt;打包交易&lt;/h4&gt;
&lt;p&gt;首先说明，打包的交易是测试交易，不是以上的创建账户和账户转账。先看源码部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trxpool = new TransactionPool; // 创建交易池
trxpool-&amp;gt;setTargetSize(trx_size); // 设置交易池的大小
// packedTrxTransferFinished，打包测试交易发送链全部结束
connect(trxpool, &amp;amp;TransactionPool::finished, this, &amp;amp;MainWindow::packedTrxTransferFinished); 
// packedTrxReady，prepare阶段完成，可以点击start
connect(trxpool, &amp;amp;TransactionPool::packedTrxPoolFulfilled, this, &amp;amp;MainWindow::packedTrxReady);

enablePacker(true);// 核心打包内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enablePacker()，触发打包流程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QVector&amp;lt;std::string&amp;gt; accounts = AccountManager::instance().listAccounts();
for (int i = 0; i &amp;lt; accounts.size(); ++i) {
    Packer *p = new Packer;
    connect(p, &amp;amp;Packer::finished, p, &amp;amp;QObject::deleteLater);    // auto delete
    // A:稍后重点讲
    connect(p, &amp;amp;Packer::newPackedTrx, trxpool, &amp;amp;TransactionPool::incomingPackedTrxs);

    // 为Packer的对象设置属性的值
    p-&amp;gt;setAccountName(QString::fromStdString(accounts.at(i)));
    p-&amp;gt;setCallback([=] (const QString&amp;amp; msg) {
        commonOutput(msg);
    });
    p-&amp;gt;start(); // 执行Packer

    packers.push_back(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入incomingPackedTrxs函数，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TransactionPool::incomingPackedTrxs(const QByteArray &amp;amp;data)
{
    // 上锁，data推入packedTransactions，QVector&amp;lt;QByteArray&amp;gt; packedTransactions;
    QMutexLocker locker(&amp;amp;mutex);
    packedTransactions.push_back(data);

    if (packedTransactions.size() &amp;gt;= targetSize) { // 通过我们设置的交易池的大小来控制总测试交易量
        emit packedTrxPoolFulfilled();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Packer开始执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void Packer::run()
{
    while(!needStop) {
        PushManager push(false);
        // 这是一个包含lambda为回调函数的connect语句
        connect(&amp;amp;push, &amp;amp;PushManager::trxPacked, this, [&amp;amp;](const QByteArray&amp;amp; data){
            emit newPackedTrx(data); // emit 发送signal给newPackedTrx B:稍后重点讲
            func(QString(&quot;PACKED: %1 to %2.&quot;).arg(accountName).arg(super_account));// 打印日志
        });
        // 以下部分与账户转账接口一致，后续内容均同上。
        push.transferToken(accountName, super_account, QString(&quot;0.0001 %1&quot;).arg(token_name));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当Packer开始run的时候，它是一个无线循环，直到灌满trxPool为止，而其中，我们注意观察，这一connect翻译过来就是：我先注册一个signals trxPacked在这，等待某处代码将该信号发射，会被这里捕捉到，将它传入回调函数，就是这个lambda回调函数的参数data中，这个lambda回调函数我们先放一放，来讲这个signals trxPacked：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;signals 对应的触发是 emit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;trxPacked 作为一个signals 是在PushManager::get_required_keys_returned中被发射emit的(注意这个是与上面讲到的CreateAccount::get_required_keys_returned是不同的。)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QByteArray param = packPushTransactionParam();
emit trxPacked(param);
...
httpc-&amp;gt;request(FunctionID::push_transaction, param);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个emit发送的param是仅在push_transaction发送之前的transaction，会将这个对象传入回调函数。下面来看一下lambda回调函数的内部，获取到transaction数据对象以后，会将该对象再次emit到一个signals newPackedTrx，我们去找一下这个signals的注册位置：MainWindow::enablePacker，就是上面展示过的代码，我注释为“A:稍后重点讲”，因此相同的原理，这个data又被传入了incomingPackedTrxs函数，最终被打包进packedTransactions集合中。&lt;/p&gt;
&lt;blockquote readability=&quot;6.6&quot;&gt;
&lt;p&gt;关于QT的signals emit slot connect 的具体语法介绍的内容可以查看&lt;a href=&quot;https://blog.csdn.net/zong596568821xp/article/details/78917689&quot;&gt;这篇文章&lt;/a&gt;我们没有QT开发的需求，所以没必要在此过多介绍语法内容，只需要捋清楚业务逻辑即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;packedTransactions的内容是属于TransactionPool的，它会在TransactionPool被启动时（也就是start按钮被按下时）使用，而这个对象是在prepare阶段被储存。（据说这个时间只有5分钟，机器性能不太好的不要将trxPool设置地太高，否则执行不完，打包好的packedTransactions并未做持久化，就会消失掉，最终导致测试结果失真）&lt;/p&gt;
&lt;h3 id=&quot;on_pushbuttonrun_clicked&quot;&gt;on_pushButtonRun_clicked&lt;/h3&gt;
&lt;p&gt;这个按钮点击事件的内容看上去比较简单，只有一个enableTrxpool(true)是生效代码，其他都是一些日志。下面直接进入enableTrxpool函数，不张贴了，直接转到核心代码trxpool-&amp;gt;start(); 那么我们进入到transactionpool.cpp，start对应run函数，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TransactionPool::run()
{
    DataManager::instance().setBeginBlockNum(get_block_info());// get_block_info()是通过http请求链获取的
    HttpClient httpc;
    int sz = packedTransactions.size();
    for (int i = 0; i &amp;lt; sz &amp;amp;&amp;amp; !needStop; i += batch_size) {
        QEventLoop loop;
        connect(&amp;amp;httpc, &amp;amp;HttpClient::responseData, &amp;amp;loop, &amp;amp;QEventLoop::quit);
        
        QJsonArray array;
        int range = sz - i &amp;gt; batch_size ? batch_size : sz - i;
        for (int j = 0; j &amp;lt; range; ++j) {
            QJsonObject val = QJsonDocument::fromJson(packedTransactions.at(i+j)).object();
            array.append(val);
        }
        // http请求push_transactions接口，推送打包交易到链
        httpc.request(FunctionID::push_transactions, QJsonDocument(array).toJson());
        loop.exec();
    }
    DataManager::instance().setEndBlockNum(get_block_info());
    packedTransactions.clear();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码就是上面提到的对 packedTransactions 的“消费”，核心代码是按照设置的打包（后称小包）大小来逐渐“消费”packedTransactions，然后通过http的push_transactions接口，将这些“小包”推送到链执行。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;没想到EOSBenchTool的源码解读一下子搞了这么长的篇幅，我没控制住，读者又要吃力了。其实到这里我们来总结一下，EOSBenchTool主要是使用了QT的界面系统，同时也用到了QT的signals，emit，connect等专有语法，不懂qt的同学看起来有些吃力。然而，抛开这些语言或者类库的语法来讲，我们专注于代码逻辑，EOSBenchTool的实现是容易被人理解的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，可以确定他是一个客户端，都是通过我们前面文章介绍过很多遍的最熟悉的那些http接口的请求来与链交互的。&lt;/li&gt;
&lt;li&gt;++接着，它采用了本地内存对象的方式来存储我们设定好的所有的交易量的集合对象。这个部分是可以改善的，毕竟如果测试量过大就会丢失。++&lt;/li&gt;
&lt;li&gt;它设计了一个“小包”的概念，相对应的，我们前面打包好的“大包”，我们设置了一个小包的大小，可以按照小包为单位对链发起批量交易的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面我们介绍了：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cleos&lt;/td&gt;
&lt;td&gt;可直接使用&lt;/td&gt;
&lt;td&gt;70-80&lt;/td&gt;
&lt;td&gt;（单节点、多节点）shell方式，python脚本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;txn_test_gen_plugin&lt;/td&gt;
&lt;td&gt;不可使用&lt;/td&gt;
&lt;td&gt;1500-2000&lt;/td&gt;
&lt;td&gt;官方用来测试的一种方式，这个插件纯粹是为了测tps而设的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;EOSBenchTool&lt;/td&gt;
&lt;td&gt;可修改使用&lt;/td&gt;
&lt;td&gt;200-300&lt;/td&gt;
&lt;td&gt;C++门槛较高且无对外封装接口&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过以上总结，我们可以推论出，如果有一种方式，支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有对外接口可易于调用&lt;/li&gt;
&lt;li&gt;开发语言门槛较低&lt;/li&gt;
&lt;li&gt;客户端行为&lt;/li&gt;
&lt;li&gt;支持打包请求&lt;/li&gt;
&lt;li&gt;tps能达到200-300&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么它对于业务方来讲，是完全可以接受并享受基于eos的区块链带来的红利的。&lt;/p&gt;
&lt;p&gt;下面就到了引出eosjs的时刻了，eosjs是官方EOSIO组织承认的客户端调用技术，它不仅仅是对rpc协议的封装，更多的还有大量的eos本身的特性，这些特性都可以做到在客户端本地实现，例如本地签名，本地生成交易id等等，这些技术可以让我们在业务方的客户端角度充分挖掘需求，自定义接口，上乘业务方，下启公有链eos环境，这种目前为止最为合适的承上启下的技术就是eosjs。&lt;/p&gt;

&lt;h2 id=&quot;准备环境&quot;&gt;准备环境&lt;/h2&gt;
&lt;p&gt;eos环境，可通过脚本快速搭建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 ./bios-boot-tutorial.py -k -w -b -s -c -t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 ./bios-boot-tutorial.py -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将终端界面的输出内容保持链日志的同步输出。&lt;/p&gt;
&lt;h2 id=&quot;源码架构&quot;&gt;源码架构&lt;/h2&gt;
&lt;p&gt;eosjs是使用JavaScript语言，nodejs框架构成。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;nodejs框架天生可以让我们便携地封装导出以及依赖导入某个“组件”，监于这种特性，我们也可以为业务方开发自己的sdk。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用组件&quot;&gt;常用组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;src/index.js 中的 module.exports = EOS，这是主要组件，通过该组件可创建相应对象&lt;/li&gt;
&lt;li&gt;eosjs-ecc，可获得加密工具对象，该对象能够调用所有加密相关的动作，例如签名，私钥公钥等。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const Eos = require('../src')
const ecc = require('eosjs-ecc')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;eos对象&quot;&gt;EOS对象&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;const keyProvider = [
    &quot;5K463ynhZoCDDa4RDcr63cUwWLTnKqmdcoTKTHBjqoKfv4u5V7p&quot;,
    ecc.seedPrivate('test-tps')
]
const eos = Eos({
    httpEndpoint: 'http://39.107.152.239:8000',
    chainId: '1c6ae7719a2a3b4ecb19584a30ff510ba1b6ded86e1fd8b8fc22f1179c622a32',
    keyProvider: keyProvider,
    expireInSeconds: 60,
    broadcast: false,
    verbose: true
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;expireInSeconds：过期时间，该行为如在此过期时间内仍未执行成功，则会被判定过期而抛弃。&lt;/li&gt;
&lt;li&gt;broadcast：这是一个本地行为（false）还是要广播到远端链上（ture）。&lt;/li&gt;
&lt;li&gt;verbose：是否要打印所有发生http请求的请求返回结构体。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;eos对象的能力：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ getCurrencyBalance: [Function],
  getCurrencyStats: [Function],
  getProducers: [Function],
  getInfo: [Function],
  getBlock: [Function],
  getAccount: [Function],
  getCode: [Function],
  getTableRows: [Function],
  getAbi: [Function],
  abiJsonToBin: [Function],
  abiBinToJson: [Function],
  getRequiredKeys: [Function],
  pushBlock: [Function],
  pushTransaction: [Function],
  pushTransactions: [Function],
  getActions: [Function],
  getControlledAccounts: [Function],
  getKeyAccounts: [Function],
  getTransaction: [Function],
  createTransaction: [Function],
  api: { createTransaction: [Function: createTransaction] },
  transaction: [AsyncFunction],
  nonce: [Function],
  bidname: [Function],
  buyram: [Function],
  buyrambytes: [Function],
  canceldelay: [Function],
  claimrewards: [Function],
  delegatebw: [Function],
  deleteauth: [Function],
  linkauth: [Function],
  newaccount: [Function],
  onerror: [Function],
  refund: [Function],
  regproducer: [Function],
  regproxy: [Function],
  reqauth: [Function],
  rmvproducer: [Function],
  sellram: [Function],
  setalimits: [Function],
  setglimits: [Function],
  setprods: [Function],
  setabi: [Function],
  setcode: [Function],
  setparams: [Function],
  setpriv: [Function],
  setram: [Function],
  undelegatebw: [Function],
  unlinkauth: [Function],
  unregprod: [Function],
  updateauth: [Function],
  voteproducer: [Function],
  create: [Function],
  issue: [Function],
  transfer: [Function],
  contract: [Function],
  fc: 
   { structs: 
      { extensions_type: [Object],
        transaction_header: [Object],
        transaction: [Object],
        signed_transaction: [Object],
        field_def: [Object],
        producer_key: [Object],
        producer_schedule: [Object],
        chain_config: [Object],
        type_def: [Object],
        struct_def: [Object],
        clause_pair: [Object],
        error_message: [Object],
        abi_def: [Object],
        table_def: [Object],
        action: [Object],
        action_def: [Object],
        block_header: [Object],
        packed_transaction: [Object],
        nonce: [Object],
        authority: [Object],
        bidname: [Object],
        blockchain_parameters: [Object],
        buyram: [Object],
        buyrambytes: [Object],
        canceldelay: [Object],
        claimrewards: [Object],
        connector: [Object],
        delegatebw: [Object],
        delegated_bandwidth: [Object],
        deleteauth: [Object],
        eosio_global_state: [Object],
        exchange_state: [Object],
        key_weight: [Object],
        linkauth: [Object],
        namebid_info: [Object],
        newaccount: [Object],
        onerror: [Object],
        permission_level: [Object],
        permission_level_weight: [Object],
        producer_info: [Object],
        refund: [Object],
        refund_request: [Object],
        regproducer: [Object],
        regproxy: [Object],
        require_auth: [Object],
        rmvproducer: [Object],
        sellram: [Object],
        set_account_limits: [Object],
        set_global_limits: [Object],
        set_producers: [Object],
        setabi: [Object],
        setcode: [Object],
        setparams: [Object],
        setpriv: [Object],
        setram: [Object],
        total_resources: [Object],
        undelegatebw: [Object],
        unlinkauth: [Object],
        unregprod: [Object],
        updateauth: [Object],
        user_resources: [Object],
        voteproducer: [Object],
        voter_info: [Object],
        wait_weight: [Object],
        account: [Object],
        create: [Object],
        currency_stats: [Object],
        issue: [Object],
        transfer: [Object],
        fields: [Object] },
     types: 
      { bytes: [Function],
        string: [Function],
        vector: [Function],
        optional: [Function],
        time: [Function],
        map: [Function],
        static_variant: [Function],
        fixed_string16: [Function],
        fixed_string32: [Function],
        fixed_bytes16: [Function],
        fixed_bytes20: [Function],
        fixed_bytes28: [Function],
        fixed_bytes32: [Function],
        fixed_bytes33: [Function],
        fixed_bytes64: [Function],
        fixed_bytes65: [Function],
        uint8: [Function],
        uint16: [Function],
        uint32: [Function],
        uint64: [Function],
        uint128: [Function],
        uint224: [Function],
        uint256: [Function],
        uint512: [Function],
        varuint32: [Function],
        int8: [Function],
        int16: [Function],
        int32: [Function],
        int64: [Function],
        int128: [Function],
        int224: [Function],
        int256: [Function],
        int512: [Function],
        varint32: [Function],
        float64: [Function],
        name: [Function],
        public_key: [Function],
        symbol: [Function],
        extended_symbol: [Function],
        asset: [Function],
        extended_asset: [Function],
        signature: [Function],
        config: [Object],
        checksum160: [Function],
        checksum256: [Function],
        checksum512: [Function],
        message_type: [Function],
        symbol_code: [Function],
        field_name: [Function],
        account_name: [Function],
        permission_name: [Function],
        type_name: [Function],
        token_name: [Function],
        table_name: [Function],
        scope_name: [Function],
        action_name: [Function],
        time_point: [Function],
        time_point_sec: [Function],
        timestamp: [Function],
        block_timestamp_type: [Function],
        block_id: [Function],
        checksum_type: [Function],
        checksum256_type: [Function],
        checksum512_type: [Function],
        checksum160_type: [Function],
        sha256: [Function],
        sha512: [Function],
        sha160: [Function],
        weight_type: [Function],
        block_num_type: [Function],
        share_type: [Function],
        digest_type: [Function],
        context_free_type: [Function],
        unsigned_int: [Function],
        bool: [Function],
        transaction_id_type: [Function] },
     fromBuffer: [Function],
     toBuffer: [Function],
     abiCache: { abiAsync: [Function: abiAsync], abi: [Function: abi] } },
  modules: 
   { format: 
      { ULong: [Function: ULong],
        isName: [Function: isName],
        encodeName: [Function: encodeName],
        decodeName: [Function: decodeName],
        encodeNameHex: [Function: encodeNameHex],
        decodeNameHex: [Function: decodeNameHex],
        DecimalString: [Function: DecimalString],
        DecimalPad: [Function: DecimalPad],
        DecimalImply: [Function: DecimalImply],
        DecimalUnimply: [Function: DecimalUnimply],
        printAsset: [Function: printAsset],
        parseAsset: [Function: parseAsset] } } }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实例创建用户&quot;&gt;实例：创建用户&lt;/h3&gt;
&lt;p&gt;通过以上列出的eos对象的提供的这些功能，我们可以满足大部分业务方的需求，这里展示一个创建用户的代码实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const nameRule = &quot;12345abcdefghijklmnopqrstuvwxyz&quot;
const config = {
    trx_pool_size: 10,
    optBCST: {expireInSeconds: 120, broadcast: true},
    opts: {expireInSeconds: 60, broadcast: false},
    ok: true,
    no: false
}
function createAccount(account, publicKey, callback) {
    eos.transaction(tr =&amp;gt; {
        tr.newaccount({
            creator: 'eosio',
            name: account,
            owner: publicKey,
            active: publicKey
        })

        tr.buyrambytes({
            payer: 'eosio',
            receiver: account,
            bytes: 4096
        })

        tr.delegatebw({
            from: 'eosio',
            receiver: account,
            stake_net_quantity: '0.0002 SYS',
            stake_cpu_quantity: '0.0002 SYS',
            transfer: 0
        })
    }).then(callback)
}

function generateAccounts(nameroot) {
    for (i = 0; i &amp;lt; 31; i++) {
        let accountname = nameroot + nameRule.charAt(i)
        console.log(&quot;create account: &quot;, accountname)
        createAccount(accountname, ecc.privateToPublic(keyProvider[1]), asset =&amp;gt; {
            eos.transfer(&quot;eosio&quot;, accountname, &quot;40.0000 SYS&quot;, &quot;initial distribution&quot;, config.optBCST)
        })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实例获取账户余额&quot;&gt;实例：获取账户余额&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function getAccountsBalance(nameroot) {
    for (i = 0; i &amp;lt; 31; i++) {
        let accountname = nameroot + nameRule.charAt(i)
        eos.getCurrencyBalance(&quot;eosio.token&quot;, accountname, &quot;SYS&quot;).then(tx =&amp;gt; {
            console.log(accountname + &quot; balance: &quot; + tx[0])
        })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;打包交易-1&quot;&gt;打包交易&lt;/h2&gt;
&lt;p&gt;打包交易接口目前我还未封装完毕，这篇文章更适合作为学习研究而不是代码段粘贴，因此对于打包交易的功能，研究好以上内容的朋友可以有自己的想法，这里我简单说一下我的实现思路：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每笔transaction是可以包含多个action的，在上面介绍过的插件的实现中，也是它的实现思路。另外push_transactions接口是链提供的http接口，我们打包多笔transaction成一个transactions对象请求这个接口，正如插件和EOSBenchTool的实现方式。然后中间要经过大量的优化，这其中较为重要的是我们的本地交易池，这个概念在EOSBenchTool中也研究过，那里的内存对象最多存活5分钟，而我们这里要如何设计呢？是否采用内存变量？还是引入队列？这都是架构师的工作，也是根据不同的业务场景大有所为的地方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本篇文章全面而详细地分析了EOS中关于tps的一切手段，包括了cleos，插件，EOSBenchTool，eosjs的方式，这其中，我们仔细研究了EOSBenchTool的源码，过程中也涉及到了qt的部分语法，对比了这几种方式的利弊，讨论了tps的计算方式，tps的现实意义，插件的“作弊”行为，EOSBenchTool的良好思路和贡献，eosjs的最终确型，以及针对transaction，action等内部元素的深入理解与研究。最后也思考了未来eos商业实现的架构设想：通过eosjs作为承上启下的sdk。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;EOS官方文档&lt;/li&gt;
&lt;li&gt;EOSBenchTool源码&lt;/li&gt;
&lt;li&gt;eosjs源码&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 17 Jul 2018 06:49:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/eostps.html</dc:identifier>
</item>
<item>
<title>针对 ElasticSearch .Net  客户端的一些封装 - 飘渺丶散人</title>
<link>http://www.cnblogs.com/wulaiwei/p/9319821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wulaiwei/p/9319821.html</guid>
<description>&lt;p&gt;        ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353&quot; target=&quot;_blank&quot; data-lemmaid=&quot;9969353&quot;&gt;云计算&lt;/a&gt;中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
&lt;p&gt;　　ElasticSearch 为.net提供了两个客户端，分别是 Elasticsearch.Net  和  NEST　&lt;/p&gt;
&lt;h2&gt;　 Elasticsearch.net为什么会有两个客户端？&lt;/h2&gt;
&lt;p&gt;　　Elasticsearch.Net是一个非常底层且灵活的客户端，它不在意你如何的构建自己的请求和响应。它非常抽象，因此所有的Elasticsearch API被表示为方法，没有太多关于你想如何构建json/request/response对象的东东，并且它还内置了可配置、可重写的集群故障转移机制。&lt;/p&gt;
&lt;p&gt;　　Elasticsearch.Net有非常大的弹性，如果你想更好的提升你的搜索服务，你完全可以使用它来做为你的客户端。&lt;/p&gt;
&lt;p&gt;　　NEST是一个高层的客户端，可以映射所有请求和响应对象，拥有一个强类型查询DSL（领域特定语言），并且可以使用.net的特性比如协变、Auto Mapping Of POCOs，NEST内部使用的依然是Elasticsearch.Net客户端。&lt;/p&gt;
&lt;p&gt;　　具体客户端的用法可参考官方的文档说明，本文主要针对 NEST 的查询做扩展。&lt;/p&gt;
&lt;p&gt;　　起因：之前在学习Dapper的时候看过一个 &lt;strong&gt;DapperExtensions&lt;/strong&gt; 的封装 其实Es的查询基本就是类似Sql的查询 。因此参考DapperExtensions 进行了Es版本的迁移&lt;/p&gt;
&lt;p&gt;　　通过官网说明可以看到  NEST  的对象初始化的方式进行查询  都是已下面的方式开头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; searchRequest = &lt;span&gt;new&lt;/span&gt; SearchRequest&amp;lt;XXT&amp;gt;(XXIndex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以通过查看源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/674034/201807/674034-20180717092048999-2073976907.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;570&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 我们可以看到所有的查询基本都是在SearchRequest上面做的扩展  这样我们也可以开始我们的第一步操作：&lt;/p&gt;
&lt;p&gt;　　1.关于分页，我们定义如下分页对象：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9e1720ef-c30c-42f8-9b37-9e233c5d0a78')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9e1720ef-c30c-42f8-9b37-9e233c5d0a78&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9e1720ef-c30c-42f8-9b37-9e233c5d0a78&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9e1720ef-c30c-42f8-9b37-9e233c5d0a78',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9e1720ef-c30c-42f8-9b37-9e233c5d0a78&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 分页类型
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PageEntity
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     每页行数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PageSize { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     当前页
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PageIndex { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     总记录数
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Records { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     总页数
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Total
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (Records &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; Records % PageSize == &lt;span&gt;0&lt;/span&gt; ? Records / PageSize : Records / PageSize + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     排序列
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sidx { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     排序类型
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sord { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
  2.定义ElasticsearchPage 分页对象
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cb65223e-f4a6-424c-92ab-1eeb6713f66d')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_cb65223e-f4a6-424c-92ab-1eeb6713f66d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cb65223e-f4a6-424c-92ab-1eeb6713f66d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cb65223e-f4a6-424c-92ab-1eeb6713f66d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cb65223e-f4a6-424c-92ab-1eeb6713f66d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     ElasticsearchPage
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ElasticsearchPage&amp;lt;T&amp;gt;&lt;span&gt; : PageEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Index { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ElasticsearchPage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; index)
        {
            Index &lt;/span&gt;=&lt;span&gt; index;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; InitSearchRequest
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; SearchRequest&amp;lt;T&amp;gt;&lt;span&gt; InitSearchRequest()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SearchRequest&amp;lt;T&amp;gt;&lt;span&gt;(Index)
            {
                From &lt;/span&gt;= (PageIndex - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; PageSize,
                Size &lt;/span&gt;=&lt;span&gt; PageSize
            };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;pre class=&quot;programlisting prettyprint lang-csharp&quot;&gt;
  至此我们的SearchRequest的初始化操作已经完成了我们可以通过如下方式进行调用
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('751940b0-e1ab-4b43-b46b-1968c12485d6')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_751940b0-e1ab-4b43-b46b-1968c12485d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_751940b0-e1ab-4b43-b46b-1968c12485d6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('751940b0-e1ab-4b43-b46b-1968c12485d6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_751940b0-e1ab-4b43-b46b-1968c12485d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; elasticsearchPage = &lt;span&gt;new&lt;/span&gt; ElasticsearchPage&amp;lt;Content&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 PageIndex =&lt;span&gt; pageIndex,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 PageSize =&lt;span&gt; pageSize
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; searchRequest = elasticsearchPage.InitSearchRequest();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      通过SearchRequest的源码我们可以得知，所有的查询都是基于内部属性进行(扩展的思路来自DapperExtensions)：&lt;/p&gt;
&lt;p&gt;　  3.QueryContainer的扩展 ，类似Where 语句：&lt;/p&gt;
&lt;p&gt;　　我们定义一个 比较操作符 类似 Sql中的  like  !=  in  等等  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0040b807-6aed-4bf9-8e75-054427b4b892')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_0040b807-6aed-4bf9-8e75-054427b4b892&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0040b807-6aed-4bf9-8e75-054427b4b892&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0040b807-6aed-4bf9-8e75-054427b4b892',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0040b807-6aed-4bf9-8e75-054427b4b892&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     比较操作符
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ExpressOperator
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     精准匹配 term（主要用于精确匹配哪些值，比如数字，日期，布尔值或 not_analyzed 的字符串(未经分析的文本数据类型)： ）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        Eq,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     大于
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        Gt,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     大于等于
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        Ge,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     小于
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        Lt,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     小于等于
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        Le,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     模糊查询 (You can use % in the value to do wilcard searching)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        Like,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; in 查询
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        In
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　接着我们定义一个 如下接口，主要包括：&lt;/p&gt;
&lt;p&gt;　　1. 提供返回一个 QueryContainer GetQuery方法 &lt;/p&gt;
&lt;p&gt;　　2. 属性名称 PropertyName&lt;/p&gt;
&lt;p&gt;　　3. 操作符 ExpressOperator&lt;/p&gt;
&lt;p&gt;　　4. 谓词值 Value&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e68fa1c5-6ed5-41a4-a4b0-e52cb56b1184')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e68fa1c5-6ed5-41a4-a4b0-e52cb56b1184&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e68fa1c5-6ed5-41a4-a4b0-e52cb56b1184&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e68fa1c5-6ed5-41a4-a4b0-e52cb56b1184',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e68fa1c5-6ed5-41a4-a4b0-e52cb56b1184&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     谓词接口
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPredicate
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        QueryContainer GetQuery(QueryContainer query);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     基础谓词接口
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBasePredicate : IPredicate
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     属性名称
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; PropertyName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePredicate : IBasePredicate
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PropertyName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; QueryContainer GetQuery(QueryContainer query);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     比较谓词
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IComparePredicate : IBasePredicate
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     操作符
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         ExpressOperator ExpressOperator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComparePredicate : BasePredicate
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ExpressOperator ExpressOperator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     字段谓词
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFieldPredicate : IComparePredicate
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     谓词的值
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;object&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　具体实现定义 FieldPredicate  并且继承如上接口，通过操作符映射为 Nest具体查询对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8c63393f-bbc5-4ed0-bf5b-366ed06cd005')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_8c63393f-bbc5-4ed0-bf5b-366ed06cd005&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c63393f-bbc5-4ed0-bf5b-366ed06cd005&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8c63393f-bbc5-4ed0-bf5b-366ed06cd005',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c63393f-bbc5-4ed0-bf5b-366ed06cd005&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FieldPredicate&amp;lt;T&amp;gt;&lt;span&gt; : ComparePredicate, IFieldPredicate
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; QueryContainer GetQuery(QueryContainer query)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ExpressOperator)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Eq:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermQuery
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         Value =&lt;span&gt; Value
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Gt:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermRangeQuery
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         GreaterThan =&lt;span&gt; Value.ToString()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Ge:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermRangeQuery
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         GreaterThanOrEqualTo =&lt;span&gt; Value.ToString()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Lt:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermRangeQuery
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         LessThan =&lt;span&gt; Value.ToString()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Le:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermRangeQuery
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         LessThanOrEqualTo =&lt;span&gt; Value.ToString()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.Like:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MatchPhraseQuery
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         Query =&lt;span&gt; Value.ToString()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ExpressOperator.In:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TermsQuery
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                         Field =&lt;span&gt; PropertyName,
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                         Terms=(List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;)Value
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ElasticsearchException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;构建Elasticsearch查询谓词异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; query;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　4.定义好这些后我们就可以拼接我们的条件了，我们定义了 PropertyName  但是我们更倾向于一种类似EF的查询方式  可以通过 &lt;strong&gt;Expression&amp;lt;Func&amp;lt;T, object&amp;gt;&amp;gt;&lt;/strong&gt; 的方式所以我们这边提供一个泛型方式&lt;/p&gt;
&lt;p&gt;  ，因为在创建 Elasticsearch  文档的时候我们已经建立了Map 文件 我们通过反射读取 &lt;strong&gt;PropertySearchName&lt;/strong&gt;属性  就可以读取到我们的 &lt;strong&gt;PropertyName &lt;/strong&gt; 这边 PropertySearchName 是自己定义的属性&lt;/p&gt;
&lt;p&gt; 为什么不反解Nest 的属性   针对不同类型需要反解的属性也是不相同的  所以避免麻烦 直接重新定义了新的属性 。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('223bec3c-0cac-47fb-981a-2b1a7de83ff0')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_223bec3c-0cac-47fb-981a-2b1a7de83ff0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_223bec3c-0cac-47fb-981a-2b1a7de83ff0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('223bec3c-0cac-47fb-981a-2b1a7de83ff0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_223bec3c-0cac-47fb-981a-2b1a7de83ff0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertySearchNameAttribute: Attribute
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; PropertySearchNameAttribute(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             Name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    然后我们就可以来定义的们初始化&lt;strong&gt;IFieldPredicate&lt;/strong&gt; 的方法了&lt;/p&gt;
&lt;p&gt;　首先我们解析我们的需求：&lt;/p&gt;
&lt;p&gt;　　1.我们需要一个Expression&amp;lt;Func&amp;lt;T, object&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;　　2.我们需要一个操作符&lt;/p&gt;
&lt;p&gt;　　3.我们需要比较什么值&lt;/p&gt;
&lt;p&gt;  针对需求我们可以得到这样一个方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：所依赖的反射方法详解文末&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('131eaf8a-e782-4d22-919c-6c9ae7b4d6c1')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_131eaf8a-e782-4d22-919c-6c9ae7b4d6c1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_131eaf8a-e782-4d22-919c-6c9ae7b4d6c1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('131eaf8a-e782-4d22-919c-6c9ae7b4d6c1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_131eaf8a-e782-4d22-919c-6c9ae7b4d6c1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     工厂方法创建一个新的  IFieldPredicate 谓语: [FieldName] [Operator] [Value].
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;实例类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expression&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;返回左操作数的表达式  [FieldName].&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;op&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;比较运算符&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;谓语的值.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;An instance of IFieldPredicate.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IFieldPredicate Field&amp;lt;T&amp;gt;(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt; expression, ExpressOperator op, &lt;span&gt;object&lt;/span&gt; value) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; propertySearchName =&lt;span&gt; (PropertySearchNameAttribute)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 LoadAttributeHelper.LoadAttributeByType&amp;lt;T, PropertySearchNameAttribute&amp;gt;&lt;span&gt;(expression);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FieldPredicate&amp;lt;T&amp;gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 PropertyName =&lt;span&gt; propertySearchName.Name,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 ExpressOperator =&lt;span&gt; op,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 Value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后 我们就可以像之前拼接sql的方式来进行拼接条件了&lt;/p&gt;
&lt;p&gt;就以我们项目中的业务需求做个演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('717b8db6-ae78-408c-ab4b-f0aa8514a68c')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_717b8db6-ae78-408c-ab4b-f0aa8514a68c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_717b8db6-ae78-408c-ab4b-f0aa8514a68c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('717b8db6-ae78-408c-ab4b-f0aa8514a68c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_717b8db6-ae78-408c-ab4b-f0aa8514a68c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; predicateList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大价格&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (requestContentDto.MaxPrice != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.UnitPrice, ExpressOperator.Le,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                    requestContentDto.MaxPrice));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小价格&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (requestContentDto.MinPrice != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.UnitPrice, ExpressOperator.Ge,
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;                     requestContentDto.MinPrice));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后针对实际业务我们在写sql的时候就回有  (xx1  and  xx2) or  xx3 这样的业务需求了  &lt;/p&gt;
&lt;p&gt;针对这种业务需求  我们需要在提供一个 IPredicateGroup 进行分组查询谓词&lt;/p&gt;
&lt;p&gt;首先我们定义一个PredicateGroup 加入谓词时使用的操作符 GroupOperator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5b27bd3b-2ad9-401c-81fe-b8a11eb9d808')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_5b27bd3b-2ad9-401c-81fe-b8a11eb9d808&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5b27bd3b-2ad9-401c-81fe-b8a11eb9d808&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5b27bd3b-2ad9-401c-81fe-b8a11eb9d808',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5b27bd3b-2ad9-401c-81fe-b8a11eb9d808&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     PredicateGroup 加入谓词时使用的操作符
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; GroupOperator
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        And,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        Or
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后我们定义 IPredicateGroup 及实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f4a91372-8333-4265-9a54-0483805c07f2')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_f4a91372-8333-4265-9a54-0483805c07f2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f4a91372-8333-4265-9a54-0483805c07f2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f4a91372-8333-4265-9a54-0483805c07f2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f4a91372-8333-4265-9a54-0483805c07f2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     分组查询谓词
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPredicateGroup : IPredicate
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         GroupOperator Operator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         IList&amp;lt;IPredicate&amp;gt; Predicates { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     分组查询谓词
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PredicateGroup : IPredicateGroup
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; GroupOperator Operator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IList&amp;lt;IPredicate&amp;gt; Predicates { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     GetQuery
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;query&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QueryContainer GetQuery(QueryContainer query)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (Operator)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GroupOperator.And:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; Predicates.Aggregate(query, (q, p) =&amp;gt; q &amp;amp;&amp;amp;&lt;span&gt; p.GetQuery(query));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GroupOperator.Or:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; Predicates.Aggregate(query, (q, p) =&amp;gt; q ||&lt;span&gt; p.GetQuery(query));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ElasticsearchException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;构建Elasticsearch查询谓词异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以用 PredicateGroup来组装我们的 谓词&lt;/p&gt;
&lt;p&gt;　同样解析我们的需求：&lt;/p&gt;
&lt;p&gt;　　1.我们需要一个GroupOperator&lt;/p&gt;
&lt;p&gt;　　2.我们需要谓词列表 IPredicate[]&lt;/p&gt;
&lt;p&gt;针对需求我们可以得到这样一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bc923b36-473e-4f76-9576-40830d11b0ff')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bc923b36-473e-4f76-9576-40830d11b0ff&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bc923b36-473e-4f76-9576-40830d11b0ff&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bc923b36-473e-4f76-9576-40830d11b0ff',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bc923b36-473e-4f76-9576-40830d11b0ff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     工厂方法创建一个新的 IPredicateGroup 谓语.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     谓词组与其他谓词可以连接在一起.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;op&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;分组操作时使用的连接谓词 (AND / OR).&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;predicate&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;一组谓词列表.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;An instance of IPredicateGroup.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IPredicateGroup Group(GroupOperator op, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; IPredicate[] predicate)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PredicateGroup
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Operator =&lt;span&gt; op,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Predicates =&lt;span&gt; predicate
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以进行组装了&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f6a25d0e-5c7a-4f7c-a565-538ad358e216')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_f6a25d0e-5c7a-4f7c-a565-538ad358e216&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f6a25d0e-5c7a-4f7c-a565-538ad358e216&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f6a25d0e-5c7a-4f7c-a565-538ad358e216',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6a25d0e-5c7a-4f7c-a565-538ad358e216&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建或查询&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; predicateList= &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键词&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.SearchKey))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.Title, ExpressOperator.Like,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;requestContentDto.SearchKey));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; predicate =&lt;span&gt; Predicates.Group(GroupOperator.And, predicateList.ToArray());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建或查询&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; predicateListOr = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.Brand))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; array = requestContentDto.Brand.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).ToList();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;predicateListOr
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;.AddRange(array.Select
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; (item =&amp;gt; Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.Brand, ExpressOperator.Like, item)));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; predicateOr =&lt;span&gt; Predicates.Group(GroupOperator.Or, predicateListOr.ToArray());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; predicatecCombination = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt; {predicate, predicateOr};
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; pgCombination = Predicates.Group(GroupOperator.And, predicatecCombination.ToArray());
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后我们的  IPredicateGroup  优雅的和  ISearchRequest 使用呢  我们提供一个链式的操作方法 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('08e5ae68-4051-4665-ba37-c7c4ca64e3f0')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_08e5ae68-4051-4665-ba37-c7c4ca64e3f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_08e5ae68-4051-4665-ba37-c7c4ca64e3f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('08e5ae68-4051-4665-ba37-c7c4ca64e3f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_08e5ae68-4051-4665-ba37-c7c4ca64e3f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化query
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;searchRequest&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;predicate&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ISearchRequest InitQueryContainer(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; ISearchRequest searchRequest, IPredicate predicate)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (predicate != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 searchRequest.Query =&lt;span&gt; predicate.GetQuery(searchRequest.Query);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchRequest;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;至此我们的基础查询方法已经封装完成&lt;/p&gt;
&lt;p&gt;然后通过 Nest 的进行查询即可&lt;/p&gt;
&lt;p&gt;var response = ElasticClient.Search&amp;lt;T&amp;gt;(searchRequest);&lt;/p&gt;
&lt;p&gt;具体演示代码（以项目的业务）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b1bbc29d-c9e4-4e00-99ac-76d2948d90fa')&quot; readability=&quot;56.5&quot;&gt;&lt;img id=&quot;code_img_closed_b1bbc29d-c9e4-4e00-99ac-76d2948d90fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b1bbc29d-c9e4-4e00-99ac-76d2948d90fa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b1bbc29d-c9e4-4e00-99ac-76d2948d90fa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b1bbc29d-c9e4-4e00-99ac-76d2948d90fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;108&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; elasticsearchPage = &lt;span&gt;new&lt;/span&gt; ElasticsearchPage&amp;lt;Content&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;                 PageIndex =&lt;span&gt; pageIndex,
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;                 PageSize =&lt;span&gt; pageSize
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; terms 分组
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; terms = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IFieldTerms&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; classificationGroupBy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;searchKey_classification&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; brandGroupBy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;searchKey_brand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; searchRequest =&lt;span&gt; elasticsearchPage.InitSearchRequest();
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; predicateList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分类ID&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (requestContentDto.CategoryId != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.ClassificationCode, ExpressOperator.Like,
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;                    requestContentDto.CategoryId));
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;                 terms.Add(Predicates.FieldTerms&amp;lt;Content&amp;gt;(x =&amp;gt; x.ClassificationGroupBy, classificationGroupBy, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;品牌&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.Brand))
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 terms.Add(Predicates.FieldTerms&amp;lt;Content&amp;gt;(x =&amp;gt; x.BrandGroupBy, brandGroupBy, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;供应商名称&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.BaseType))
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.BaseType, ExpressOperator.Like,
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;                    requestContentDto.BaseType));
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否自营&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (requestContentDto.IsSelfSupport == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.IsSelfSupport, ExpressOperator.Eq,
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                    requestContentDto.IsSelfSupport));
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大价格&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (requestContentDto.MaxPrice != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.UnitPrice, ExpressOperator.Le,
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;                    requestContentDto.MaxPrice));
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小价格&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (requestContentDto.MinPrice != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.UnitPrice, ExpressOperator.Ge,
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                    requestContentDto.MinPrice));
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键词&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.SearchKey))
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 predicateList.Add(Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.Title, ExpressOperator.Like,
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                    requestContentDto.SearchKey));
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;规整排序&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sortConfig =&lt;span&gt; SortOrderRule(requestContentDto.SortKey);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sorts = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ISort&amp;gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 Predicates.Sort&amp;lt;Content&amp;gt;&lt;span&gt;(sortConfig.Key, sortConfig.SortOrder)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; predicate =&lt;span&gt; Predicates.Group(GroupOperator.And, predicateList.ToArray());
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建或查询&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; predicateListOr = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.Brand))
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; array = requestContentDto.Brand.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).ToList();
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                predicateListOr
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                    .AddRange(array.Select
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                         (item =&amp;gt; Predicates.Field&amp;lt;Content&amp;gt;(x =&amp;gt;&lt;span&gt; x.Brand, ExpressOperator.Like, item)));
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; predicateOr =&lt;span&gt; Predicates.Group(GroupOperator.Or, predicateListOr.ToArray());
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; predicatecCombination = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPredicate&amp;gt;&lt;span&gt; {predicate, predicateOr};
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pgCombination =&lt;span&gt; Predicates.Group(GroupOperator.And, predicatecCombination.ToArray());
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            searchRequest.InitQueryContainer(pgCombination)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                .InitSort(sorts)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                .InitHighlight(requestContentDto.HighlightConfigEntity)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                .InitGroupBy(terms);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; _searchProvider.SearchPage(searchRequest);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; terms 分组赋值
&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; classificationResponses = requestContentDto.CategoryId != &lt;span&gt;null&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;                 ? &lt;span&gt;null&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                : data.Aggregations.Terms(classificationGroupBy).Buckets
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     .Select(x =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassificationResponse
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                         Key =&lt;span&gt; x.Key.ToString(),
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                         DocCount =&lt;span&gt; x.DocCount
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                    }).ToList();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; brandResponses = !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(requestContentDto.Brand)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 ? &lt;span&gt;null&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                : data.Aggregations.Terms(brandGroupBy).Buckets
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     .Select(x =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrandResponse
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                         Key =&lt;span&gt; x.Key.ToString(),
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                         DocCount =&lt;span&gt; x.DocCount
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                    }).ToList();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; 高亮
&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; titlePropertySearchName =&lt;span&gt; (PropertySearchNameAttribute)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 LoadAttributeHelper.LoadAttributeByType&amp;lt;Content, PropertySearchNameAttribute&amp;gt;(x =&amp;gt;&lt;span&gt; x.Title);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; list = data.Hits.Select(c =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Content
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 Key =&lt;span&gt; c.Source.Key,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 Title = (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) c.Highlights.Highlight(c.Source.Title, titlePropertySearchName.Name),
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 ImgUrl =&lt;span&gt; c.Source.ImgUrl,
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 BaseType =&lt;span&gt; c.Source.BaseType,
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 BelongMemberName =&lt;span&gt; c.Source.BelongMemberName,
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 Brand =&lt;span&gt; c.Source.Brand,
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 Code =&lt;span&gt; c.Source.Code,
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                 BrandFirstLetters =&lt;span&gt; c.Source.BrandFirstLetters,
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 ClassificationName =&lt;span&gt; c.Source.ClassificationName,
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                 ResourceStatus =&lt;span&gt; c.Source.ResourceStatus,
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                 BrandGroupBy =&lt;span&gt; c.Source.BrandGroupBy,
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 ClassificationGroupBy =&lt;span&gt; c.Source.ClassificationGroupBy,
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 ClassificationCode =&lt;span&gt; c.Source.ClassificationCode,
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 IsSelfSupport =&lt;span&gt; c.Source.IsSelfSupport,
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 UnitPrice =&lt;span&gt; c.Source.UnitPrice
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;            }).ToList();
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; contentResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentResponse
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 Records = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) data.Total,
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 PageIndex =&lt;span&gt; elasticsearchPage.PageIndex,
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 PageSize =&lt;span&gt; elasticsearchPage.PageSize,
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 Contents =&lt;span&gt; list,
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 BrandResponses =&lt;span&gt; brandResponses,
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 ClassificationResponses =&lt;span&gt; classificationResponses
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; contentResponse;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关于排序、group by 、 高亮 的具体实现不做说明  思路基本一致  可以参考git上面的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码详见 Git &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://github.com/wulaiwei/WorkData.Core/tree/master/WorkData/WorkData.ElasticSearch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要对 Nest 进行封装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.项目组不可能每个人都来熟悉一道 Nest的 api ，缩小上手难度&lt;/p&gt;
&lt;p&gt;2.规范查询方式  &lt;/p&gt;


</description>
<pubDate>Tue, 17 Jul 2018 05:55:00 +0000</pubDate>
<dc:creator>飘渺丶散人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wulaiwei/p/9319821.html</dc:identifier>
</item>
<item>
<title>还原堆栈信息，分析地形系统使用ASTC格式的纹理导致Crash的问题 - 陈嘉栋</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/9322975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/9322975.html</guid>
<description>&lt;h2 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们选择了过去一周Unity官方社区交流群中比较有代表性的几个问题，总结在这里和大家进行分享。主要涵盖了&lt;strong&gt;IL2CPP、Scripting、Virtual Reality、Graphics、Editor、Terrain、Plugins 、Education&lt;/strong&gt;等领域，其中会着重介绍一下在原生的地形系统中使用ASTC格式纹理导致Crash的问题。&lt;/p&gt;
&lt;p&gt;在文章结尾处我们还总结了社区小伙伴们过去一周在群里分享的一些干货连接。&lt;/p&gt;
&lt;p&gt;同时，也欢迎大家加入我们这个讨论干货的官方技术群，交流看法分享经验。&lt;br/&gt;Unity官方社区交流群：629212643&lt;/p&gt;
&lt;h2 id=&quot;x01-il2cpp&quot;&gt;0x01 IL2CPP&lt;/h2&gt;
&lt;p&gt;Q: 有人遇到过GZipStream在安卓上没办法正常工作的问题么？在Editor中工作是正常的。但是在安卓手机上会无法执行，查看logcat发现在执行时抛出了下面的异常：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Unable to find MonoPosixHelper&lt;br/&gt;DllNotFoundException: MonoPosixHelper&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-a66b18b5fa687001.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-13 上午11.47.11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A: 如果项目的scripting backend使用的是Mono，则在使用System.IO.Compression命名空间时的确会抛出类似上面的异常。但是如果使用IL2CPP的话，System.IO.Compression命名空间是可以正常使用的，包括GZipStream同样也是可以正常使用的。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-58ee3c233fa457fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-13 上午11.50.58.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x02-scripting&quot;&gt;0x02 Scripting&lt;/h2&gt;
&lt;p&gt;Q: 如何求一个数最大能是2的多少次幂啊? 比如513最大是2的9次幂,就多了一位数. math里有没有这样的方法，想要模拟cullingmask那样的筛选层出来。&lt;/p&gt;
&lt;p&gt;A: 用查找表，尽量限制在512之内。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-1be61c4a4348f954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;10F001F907D2BA03480C0AA0C0DE624B.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(郑州(๑•̀.̫•́๑)大FC)&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int Exp(int i)
{
    int counter = 0;
    while(i &amp;gt; 1)
    {
        i = i &amp;gt;&amp;gt; 1;
        counter++;
    }
    return counter;
}

void outpuLayers(int layerValue)
{
    
    while(layerValue &amp;gt; 0)
    {
        int i = layerValue;
        int counter = 0;
        while (i &amp;gt; 0)
        {
            i = i &amp;gt;&amp;gt; 1;
            counter++;
        }
        Debug.Log(counter);
        i = 1;
        while (counter &amp;gt; 1)
        {
            counter--;
            i = i &amp;lt;&amp;lt; 1;
        }
        layerValue = layerValue ^ I;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(南京-科穆宁)&lt;/p&gt;
&lt;p&gt;A: 查表法如果要支持20+的layer数，内存占用爆炸。位运算log2正解，这里下面也有个例子。&lt;br/&gt;https://stackoverflow.com/questions/13654499/calculating-log-base-2&lt;br/&gt;（上海-Weiqi “Xylt” Gu）&lt;/p&gt;
&lt;p&gt;A: 范围小用查表~ 范围大用位移 ~ 不要用浮点运算~。（成都-xxp）&lt;/p&gt;
&lt;h2 id=&quot;x03-virtual-reality&quot;&gt;0x03 Virtual Reality&lt;/h2&gt;
&lt;p&gt;Q: 在开发Windows Mixed Reality时，编辑器会报错“RenderTexture.GenerateMips failed: render texture does not have mip maps (set useMipMap to true).”这个是一个bug吗？Unity版本为Unity2017.1.1f1, Unity2017.1.2f1, Unity2017.21f1。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-86c83396df252c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;A13A5C9EB89FDAD98828621D7CB75673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A: 这的确是一个bug。细节可以查看：https://forum.unity.com/threads/beta-7-case-943170-windows-mixed-reality-far-clip-and-rendertexture-generatemips-error.488714/&lt;/p&gt;
&lt;p&gt;这个bug已经修复了。但是当时还没有backport到2017.1和2017.2，也就是你用来测试的版本。&lt;br/&gt;推荐你使用2017.4来测试和进行开发。2017.4版本作为一个长期维护版本，会持续修复已经知道的bug。&lt;/p&gt;
&lt;h2 id=&quot;x04-graphics&quot;&gt;0x04 Graphics&lt;/h2&gt;
&lt;p&gt;Q: tonemapping和打包设置里colorspace是冲突的吗?是不是用tonemapping，colorspace需要改成线性?&lt;/p&gt;
&lt;p&gt;A: 用tonemapping的话要用hdr，hdr最好和线性空间一起用，才能保证准确度。如果你的项目设置为gamma的话，postprocessing中的color grading会有一个警告的。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-eb2e4c03679606aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-13 下午2.32.53.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q: 难道我理解错了。摄像机可以开HDR，但是打包到手机渲染设置里默认是不开的啊 我可不可以 用HDR算出来的结果 通过mapping 转换成ldr给手机显示&lt;br/&gt;A: tonemapping的作用也是为了将一个高动态范围的颜色数据映射回可用颜色空间，为的是不被显示屏幕截断色彩。(北京-哎呀)&lt;br/&gt;A: 因为显示器很少支持hdr，安卓手机更是565颜色居多。tonemap就是一个简单s曲线remapping。（深圳-topameng）&lt;/p&gt;
&lt;p&gt;Q: 摄像机开启HDR并不表示移动端开启HDR吧。&lt;br/&gt;A: 手机上不是固定fp16的，可以自己调，如果设置没有hdr backbuffer, 你摄像机上的标记一点用也没有。（深圳-topameng）&lt;/p&gt;
&lt;h3 id=&quot;小贴士&quot;&gt;小贴士&lt;/h3&gt;
&lt;p&gt;这里可以和大家科普一下Graphic Setting中的各个tier和设备的对应关系：Graphics Settings内的Tier设置，在运行时会根据GPU来选择对应的Tier。应用相关的设置。具体各个Tier和设备的对应关系如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Tier 1:&lt;br/&gt;Android - all devices that have support for OpenGL ES 2 only&lt;br/&gt;iOS - all devices before iPhone 5S (not including 5S, but including 5C), iPods up to and including 5th generation, iPads up to 4th generation, iPad mini first generation&lt;br/&gt;Desktops: DirectX 9, HoloLens&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tier 2:&lt;br/&gt;Android - all devices with OpenGL ES 3 support，Vulkan&lt;br/&gt;iOS - all devices starting from iPhone 5S, iPad Air, iPad mini 2nd generation, iPod 6th generation&lt;br/&gt;AppleTV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tier 3:&lt;br/&gt;Desktops: OpenGL, Metal, DirectX 11+，Vulkan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体也可以查阅相关文档。&lt;/p&gt;
&lt;p&gt;Q: unity自带的屏幕射线反射效果一般，然后我找了好久，找到一个livenda lab开发的，居然离屏追踪，就是现在还没出成品。有好的推荐吗？&lt;br/&gt;A: 可以参考群里@上海-CGBull在他的文章中的实现。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-9f284a44d9b4350b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;Unity_StochasticScreenSpaceReflection-实现篇：&lt;br/&gt;https://zhuanlan.zhihu.com/p/38303394&lt;br/&gt;（北京-小小光）&lt;/p&gt;
&lt;p&gt;Q: 我这里想要扰动的方向是随机的怎么弄啊 在脚本里setfloat感觉是硬切的。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-2d2d07e570a077bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;32A41337C2F9B902D9B43EC5D821C34D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A: 从一张噪声贴图里读。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-6c87a75b8b17247e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;15FBFCCBF78868125F605311A25090A9.png&quot;/&gt;&lt;br/&gt;可以看看和失真效果相关的这篇博客：&lt;br/&gt;https://zhuanlan.zhihu.com/p/37696836。（北京-破晓）&lt;/p&gt;
&lt;p&gt;Q: 我想要的就是一团纹理在球上面随机方向位移，并且随时间变化。&lt;br/&gt;A: 可以参考这篇文章：https://blog.csdn.net/panda1234lee/article/details/52085375&lt;br/&gt;总之采样的时候以_Time作为种子取个噪声就行。（北京-破晓）&lt;/p&gt;
&lt;p&gt;Q: 有人实现过手机上面能用的雪地踩踏效果吗?主美还想着要那种曲面细分的效果。。。战神 古墓丽影。。。&lt;br/&gt;A: 思路并不复杂。简单的说, 就是Mesh变形。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-41ed5eb220c9028e.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;1372105-c552ebae7261538b.gif&quot;/&gt;&lt;br/&gt;至于古墓丽影的那个案例，之前@逍遥剑客 也在知乎上分享过。http://tombraider.tumblr.com/post/131825841425/dev-blog-snow-tech-and-houdini-simulations-mike&lt;/p&gt;
&lt;p&gt;A: https://www.cnblogs.com/murongxiaopifu/p/7887614.html (北京-suzakul)&lt;/p&gt;
&lt;h2 id=&quot;x05-editor&quot;&gt;0x05 Editor&lt;/h2&gt;
&lt;p&gt;Q: 求教animationclip的inspector上显示的该资源的内存占用大小数据是如何获得的？&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-ac2b9f7e2d7bbc83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午8.50.47.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A: 你可以调用AnimationUtility.GetAnimationClipStats(clip)来获取某个clip的status，即AnimationClipStats类的实例，其中的size字段即inspector上显示的内存占用大小。可以参考下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        Assembly asm = Assembly.GetAssembly(typeof(Editor));
        getAnimationClipStats = typeof(AnimationUtility).GetMethod(&quot;GetAnimationClipStats&quot;, BindingFlags.Static | BindingFlags.NonPublic);
        Type aniclipstats = asm.GetType(&quot;UnityEditor.AnimationClipStats&quot;);
        sizeInfo = aniclipstats.GetField(&quot;size&quot;, BindingFlags.Public | BindingFlags.Instance);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，c#部分的代码其实有开源的。你也可以参考github上的代码：https://github.com/Unity-Technologies/UnityCsReference/blob/3cfc6c4729d5cacedf67a38df5de1bfffb5994a3/Editor/Mono/Inspector/AnimationClipEditor.cs&lt;/p&gt;
&lt;h2 id=&quot;x06-terrain&quot;&gt;0x06 Terrain&lt;/h2&gt;
&lt;p&gt;Q: 有人遇到过地形上用的纹理的纹理格式设置为astc，在手机上会崩溃的问题吗？我的unity版本是2018.1。&lt;/p&gt;
&lt;p&gt;A: 遇到过这个问题。我下午也做了一些测试，这其实并非Unity2018上出现的新bug。我测试了一些2018之前的版本，比如2017.3.0p1，发现同样会由于在原生地形系统中使用astc格式纹理而出现crash。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-fe2b3531ee7be71b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-15 下午12.20.33.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-9679bf869b173376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-15 下午12.20.43.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过这个问题我已经提交了Bug报告给开发，开发那边已经知道了。以后的版本会修掉。并且目前在原生地形中使用ETC2格式的纹理是没有问题的。&lt;br/&gt;不过，我们其实可以通过crash日志信息，来看看程序是在哪一步crash掉的。同时，也可以在这里和大家分享一下如何通过crash日志来还原堆栈信息。&lt;br/&gt;首先说明的是，我这里使用的Unity版本是2018.1.0f1，并且使用的Script Backend是Mono。&lt;br/&gt;打开手机上的测试程序，查看程序crash时的日志：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-62d3c750a6ccd80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午9.47.46.png&quot;/&gt;&lt;br/&gt;在这份堆栈信息里，我们可以看到例如&lt;strong&gt;0049b647&lt;/strong&gt;这样的数字，它们是在crash时，程序正在执行的方法的内存地址。每行的结尾则是所使用的库，这里是&lt;strong&gt;libunity.so&lt;/strong&gt;。&lt;br/&gt;但是，内存地址对我们来说显然没有什么意义，所以接下来我们需要将内存地址转换成我们可以看懂的内容。&lt;br/&gt;在Unity 5.3.6之后的版本，我们都提供了libunity的符号表。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-805f0dd40222591e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午10.31.58.png&quot;/&gt;&lt;br/&gt;在Mac上，符号表的路径是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Symbols&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在windows上，符号表的路径是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;C:\Program Files\Unity\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Release\Symbols\armeabi-v7a\libunity.sym.so&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，接下来我们使用的符号表版本一定要和你打包所使用的Editor版本一致。&lt;br/&gt;有了符号表，接下来我们还需要NDK的&lt;strong&gt;addr2line&lt;/strong&gt;工具。你可以在你的NDK目录下找到它：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，万事俱备，我们接下来就来解析一下第一条内存地址所对应的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;./arm-linux-androideabi-addr2line -f -C -e libunity.sym.so 0049b647&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到crash的方法是：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-f07dc2633ab34a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午10.48.44.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;construct_block_size_descriptor_2d似乎还不太明显。我们再往回追。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-5504705e4872b2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午10.50.40.png&quot;/&gt;&lt;br/&gt;原来是在做DecompressASTC相关的操作时crash了。&lt;/p&gt;
&lt;p&gt;当然，&lt;strong&gt;这个bug已经提交了，并且会在以后的版本中修复的。现在大家可以在地形中使用ETC2格式的贴图&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;x07-plugins&quot;&gt;0x07 Plugins&lt;/h2&gt;
&lt;p&gt;Q: 有没有大佬 知不知道 unity支不支持 64位动态库的调用?使用安卓平台。&lt;br/&gt;A: 在Unity2018.1.0 Beta 2版本中提供了对 Android 64-bit ARM（experimental）的支持。&lt;br/&gt;首先要将scripting backend设置为IL2CPP，之后就可以在Player Setting中选择ARM 64了。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-38479a1c4fd7c6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-14 下午11.11.39.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，在刚推出的2018.2正式版中，对ARM64的支持应该已经很完善了。&lt;/p&gt;
&lt;h2 id=&quot;x08-education&quot;&gt;0x08 Education&lt;/h2&gt;
&lt;p&gt;Q: 请问目前Unity提供的资质认证中，是只有“专家程序员认证”有培训课程吗？&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-3b5fd2d1f3779f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;B22A35F67942884B811DFAEF30D03EF1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A: 除了初级开发者考试有相应的课程外，其他证书的课程还在制作中，暂时还没有。初级的8月份才会搬到coursera，中文的现在网易云 51cto 已经有了。http://study.163.com/course/introduction/1005268010.htm&lt;/p&gt;
&lt;h2 id=&quot;x09-后记&quot;&gt;0x09 后记&lt;/h2&gt;
&lt;p&gt;这一周恰好也迎来了Unity2018.2的正式版本的发布，大家可以通过Unity Hub来直接下载：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-c099be511c5ff787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-07-15 下午12.42.00.png&quot;/&gt;&lt;br/&gt;也可以点击这个链接来下载：https://unity3d.com/cn/get-unity/update&lt;/p&gt;
&lt;p&gt;好了，以上就是想和大家分享的几个在群里讨论的小问题。&lt;br/&gt;再次，欢迎大家加入我们这个讨论干货的官方技术群，交流分享呀。&lt;br/&gt;Unity官方社区交流群：629212643&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;
&lt;p&gt;这里是社区小伙伴们过去一周在群里分享的一些干货连接：&lt;br/&gt;[1]Don’t Re-invent Finite State Machines: How to Repurpose Unity’s Animator:&lt;br/&gt;https://medium.com/the-unity-developers-handbook/dont-re-invent-finite-state-machines-how-to-repurpose-unity-s-animator-7c6c421e5785&lt;br/&gt;[2]Calculating Log base 2:&lt;br/&gt;https://stackoverflow.com/questions/13654499/calculating-log-base-2&lt;br/&gt;[3]【翻译】Shader · 冰:&lt;br/&gt;https://zhuanlan.zhihu.com/p/37696836&lt;br/&gt;[4]Shader特效——实现“噪声”【基于ShaderToy】【GLSL】:&lt;br/&gt;https://blog.csdn.net/panda1234lee/article/details/52085375&lt;br/&gt;[5]小随笔：利用Shader给斯坦福兔子长毛和实现雪地效果:&lt;br/&gt;https://www.cnblogs.com/murongxiaopifu/p/7887614.html&lt;br/&gt;[6]Dev Blog: Snow Tech and Houdini Simulations:&lt;br/&gt;http://tombraider.tumblr.com/post/131825841425/dev-blog-snow-tech-and-houdini-simulations-mike&lt;/p&gt;
&lt;p&gt;Unity官方社区交流群：629212643&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 05:52:00 +0000</pubDate>
<dc:creator>陈嘉栋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/murongxiaopifu/p/9322975.html</dc:identifier>
</item>
<item>
<title>[开源]开放域实体抽取泛用工具 NetCore2.1 - codesnippet.info</title>
<link>http://www.cnblogs.com/TextEditor/p/9322845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TextEditor/p/9322845.html</guid>
<description>&lt;p&gt;https://github.com/magicdict/FDDC&lt;/p&gt;
&lt;p&gt;更新时间 2018年7月16日 By 带着兔子去旅行&lt;/p&gt;
&lt;p&gt;开发这个工具的起源是天池大数据竞赛，FDDC2018金融算法挑战赛02－A股上市公司公告信息抽取。这个比赛是针对金融公告开展的信息抽取比赛。在参赛过程中，萌生出一个念头，是否能够开发出一个泛用的信息抽取工具呢？&lt;/p&gt;
&lt;p&gt;信息抽取是NLP里的一个实用内容。该工具的目标是打造一个泛用的自动信息抽取工具。使得没有任何基础的用户，可以通过简单的步骤提取文档（PDF，HTML，TXT）中的信息。该工具使用C#(.Net Core)开发，所以可以跨平台运行。（Python在做大的工程的时候有诸多不便，所以没有使用python语言）&lt;/p&gt;
&lt;p&gt;工具原理采用的是开放域实体抽取的方法:&lt;br/&gt;使用各种方法尽可能抽取实体，然后对于候选内容进行置信度分析打分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/magicdict/FDDC/raw/master/img/%E5%BC%80%E6%94%BE%E5%9F%9F%E5%AE%9E%E4%BD%93%E6%8A%BD%E5%8F%96%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95.png&quot; title=&quot;开放域实体抽取的方法&quot; alt=&quot;开放域实体抽取的方法&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本环境&quot;&gt;基本环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;.NetCore2.1&lt;/li&gt;
&lt;li&gt;LTP组件：哈工大LTP3.3.2版&lt;/li&gt;
&lt;li&gt;PDF转TXT工具 pdfminer&lt;/li&gt;
&lt;li&gt;分词系统：结巴分词&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ltp工具：哈工大LTP工具（ltp.ai）提供的ltp工具，最新版为3.3.4.该工具在windows，max，centos上，srl的训练可能无法正常完成。（dp，ner阶段没有问题）所以这里使用了3.3.2版本。ltp工具的SRL结果中包含了DP和NER的内容，但是暂时保留DP和NER中间XML文件。&lt;/p&gt;
&lt;p&gt;pdfminer：请注意处理中文的时候需要额外的步骤，具体方法不再赘述。部分PDF可能无法正确转换，原因CaseByCase。&lt;/p&gt;
&lt;p&gt;结巴分词：某些地名，例如&quot;大连&quot;，会被误判。这里使用地名辅助字典的方式做纠正。ltp工具没有这个问题。ltp工具和结巴分词功能虽然重复，但是暂时还不能移除结巴分词。&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;前期准备&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用pdfminer将PDF文件转化为Txt文件&lt;/li&gt;
&lt;li&gt;使用哈工大LTP工具，将Txt文件转换为NER，DP，SRL的XML文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;期待文件夹结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;html（存放HTML文件目录）&lt;/li&gt;
&lt;li&gt;pdf（存放PDF文件目录）&lt;/li&gt;
&lt;li&gt;txt（存放TXT文件目录）&lt;/li&gt;
&lt;li&gt;dp（存放LTP的DP结果XML目录）&lt;/li&gt;
&lt;li&gt;ner（存放LTP的NER结果XML目录）&lt;/li&gt;
&lt;li&gt;srl（存放LTP的SRL结果XML目录）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;训练词语统计&quot;&gt;训练（词语统计）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分析待提取信息自身的特征&lt;/li&gt;
&lt;li&gt;分析待提取信息周围语境的特征（LTP工具）&lt;/li&gt;
&lt;li&gt;构建置信度体系&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;词语自身属性&quot;&gt;词语自身属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;长度&lt;/li&gt;
&lt;li&gt;包含词数&lt;/li&gt;
&lt;li&gt;首词词性（POS）&lt;/li&gt;
&lt;li&gt;词尾&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;语境&quot;&gt;语境&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;该关键字在 ：（中文冒号）之后的场景下，：（中文冒号）前面的内容&lt;/li&gt;
&lt;li&gt;包含该关键字的句子中，该关键字的前置动词&lt;/li&gt;
&lt;li&gt;包含该关键字的句子中，该关键字是否在角色标识中存在&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;训练结果例：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;协议书(5.180388%)[56]
协议(11.84089%)[128]
合同(58.55689%)[633]
合同书(2.960222%)[32]
买卖合同(3.792784%)[41]
承包合同(12.0259%)[130]
意向书(0.2775208%)[3]
补充协议(1.110083%)[12]
项目(0.2775208%)[3]
书(0.9250694%)[10]
议案(0.2775208%)[3]
)(0.8325624%)[9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(更多规则持续加入中,同时对于相关度低的规则也会剔除)&lt;/p&gt;
&lt;p&gt;这里暂时使用频率最高的前5位作为抽取依据。同时为了保证正确率，部分特征的占比必须超过某个阈值。&lt;br/&gt;以下是中文冒号的一个例子，要求前导词占比在40%以上。&lt;br/&gt;（例如前导词A可以正确抽取10个关键字，前导词B可以抽取5个关键字，前导词C可以抽取15个关键字。则前导词A的占比为33%）&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        e.LeadingColonKeyWordList = ContractTraning.ContractNameLeadingDict
        .Where((x) =&amp;gt; { return x.Value &amp;gt;= 40; })    //阈值40%以上
        .Select((x) =&amp;gt; { return x.Key + &quot;：&quot;; }).ToArray();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表格&quot;&gt;表格&lt;/h3&gt;
&lt;p&gt;对于大量表格中的关键字，工具也提供了表格统计的功能。主要是统计一下该关键字的表头标题信息。&lt;br/&gt;同时由于表格中的原始数据可能需要通过参照表格标题才能进行比对的情况，这里支持变换器。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 增发对象训练
    /// &amp;lt;/summary&amp;gt;
    public static void TrainingIncreaseTarget()
    {
        var TargetTool = new TableAnlayzeTool();
        var IncreaseNumberTool = new TableAnlayzeTool();
        IncreaseNumberTool.Transform = NumberUtility.NormalizerStockNumber;
        var IncreaseMoneyTool = new TableAnlayzeTool();
        IncreaseMoneyTool.Transform =  MoneyUtility.Format;
        TraningDataset.InitIncreaseStock();
        var PreviewId = String.Empty;
        var PreviewRoot = new HTMLEngine.MyRootHtmlNode();
        foreach (var increase in TraningDataset.IncreaseStockList)
        {
            if (!PreviewId.Equals(increase.id))
            {
                var htmlfile = Program.DocBase + @&quot;\FDDC_announcements_round1_train_20180518\定增\html\&quot; + increase.id + &quot;.html&quot;;
                PreviewRoot = new HTMLEngine().Anlayze(htmlfile, &quot;&quot;);
                PreviewId = increase.id;
            }
            TargetTool.PutTrainingItem(PreviewRoot, increase.PublishTarget);
            IncreaseNumberTool.PutTrainingItem(PreviewRoot, increase.IncreaseNumber);
            IncreaseMoneyTool.PutTrainingItem(PreviewRoot, increase.IncreaseMoney);
        }
        TargetTool.WriteTop(10);
    }

增发对象
17% 00237   发行对象
16% 00223   发行对象名称
11% 00156   股东名称
09% 00132   认购对象
07% 00096   投资者名称
06% 00085   名称
04% 00061   认购对象名称
04% 00055   获配投资者名称
02% 00035   询价对象名称
02% 00029   配售对象名称
增发数量
30% 00370   获配股数（股）
19% 00234   配售股数（股）
13% 00158   认购股数（股）
10% 00126   持股数量（股）
03% 00045   认购数量（股）
02% 00028   持股总数（股）
02% 00024   配售数量（股）
01% 00019   持股数（股）
01% 00015   获配数量（股）
00% 00011   总股本比例
00% 00011   获配股数(万股)
00% 00011   认购股数（万股）
增发金额
35% 00257   获配金额（元）
21% 00155   认购金额（元）
17% 00125   配售金额（元）
08% 00062   配售金额(元）
02% 00018   认购金额（万元）
02% 00017   认购金额（人民币元）
01% 00014   发行前
01% 00014   申购金额（万元）
01% 00011   获配金额(元）
01% 00008   追加认购金额（元）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了统计标题之外，还可以通过某个标题下面出现的内容。&lt;br/&gt;下面的例子是看一下增减持方式有哪些：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 增减持训练
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;TraningCnt&quot;&amp;gt;训练条数&amp;lt;/param&amp;gt;
    public static void Traning(int TraningCnt = int.MaxValue)
    {
        var ChangeMethodTool = new TableAnlayzeTool();
        var PreviewId = String.Empty;
        var PreviewRoot = new HTMLEngine.MyRootHtmlNode();
        int Cnt = 0;
        foreach (var stockchange in TraningDataset.StockChangeList)
        {
            if (!PreviewId.Equals(stockchange.id))
            {
                var htmlfile = Program.DocBase + @&quot;\FDDC_announcements_round1_train_20180518\增减持\html\&quot; + stockchange.id + &quot;.html&quot;;
                PreviewRoot = new HTMLEngine().Anlayze(htmlfile, &quot;&quot;);
                PreviewId = stockchange.id;
                Cnt++; if (Cnt == TraningCnt) break;
            }
            ChangeMethodTool.PutValueTrainingItem(PreviewRoot, new string[]{&quot;减持方式&quot;,&quot;增持方式&quot;}.ToList());
        }
        Program.Training.WriteLine(&quot;增减持方式&quot;);
        ChangeMethodTool.WriteTop(10);
    }

增减持方式
33% 09277   集中竞价交易
24% 06771   集中竞价
21% 05940   大宗交易
08% 02468   竞价交易
01% 00464   集中竞价减持
01% 00365   减持方式
01% 00303   &amp;lt;null&amp;gt;
01% 00289   二级市场竞价
00% 00258   合计
00% 00196   竞价减持&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;抽取&quot;&gt;抽取&lt;/h2&gt;
&lt;p&gt;采用各种方法抽取数据，务必使得所有数据都抽取出来。根据训练结果从候选值里面获得置信度最大的数据。抽取手段如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有明确先导词&lt;/li&gt;
&lt;li&gt;NER实体标识&lt;/li&gt;
&lt;li&gt;具体语境&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;表格抽取工具内容系&quot;&gt;表格抽取工具（内容系）&lt;/h3&gt;
&lt;p&gt;代码内置表头规则系的表抽取工具，对于表格可以设定如下抽取规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Content:匹配内容&lt;/li&gt;
&lt;li&gt;IsContentEq:内容匹配规则（包含或者相等）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 表抽取规则（内容系）
    /// &amp;lt;/summary&amp;gt;
    public struct TableSearchContentRule
    {
        /// &amp;lt;summary&amp;gt;
        /// 匹配内容
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;String&amp;gt; Content;
        /// &amp;lt;summary&amp;gt;
        /// 是否相等模式
        /// &amp;lt;/summary&amp;gt;
        public bool IsContentEq;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个表格抽取的例子：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        var rule = new TableSearchContentRule();
        rule.Content = new string[] { &quot;集中竞价交易&quot;, &quot;竞价交易&quot;, &quot;大宗交易&quot;, &quot;约定式购回&quot; }.ToList();
        rule.IsContentEq = true;
        var result = HTMLTable.GetMultiRowsByContentRule(root,rule);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表格抽取工具表头规则系&quot;&gt;表格抽取工具（表头规则系）&lt;/h3&gt;
&lt;p&gt;代码内置表头规则系的表抽取工具，对于表格可以设定如下抽取规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SuperTitle：层叠表头的情况下，父表头文字&lt;/li&gt;
&lt;li&gt;IsSuperTitleEq：父表头文字匹配规则（包含或者相等）&lt;/li&gt;
&lt;li&gt;Title：表头文字&lt;/li&gt;
&lt;li&gt;IsTitleEq：表头文字匹配规则（包含或者相等）&lt;/li&gt;
&lt;li&gt;IsRequire：在行单位抽取时，该项目是否为必须项目&lt;/li&gt;
&lt;li&gt;ExcludeTitle：表标题不能包含的文字&lt;/li&gt;
&lt;li&gt;Normalize：抽取内容预处理器&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  /// &amp;lt;summary&amp;gt;
    /// 表抽取规则
    /// &amp;lt;/summary&amp;gt;
    public struct TableSearchTitleRule
    {
        public string Name;
        /// &amp;lt;summary&amp;gt;
        /// 父标题
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;String&amp;gt; SuperTitle;
        /// &amp;lt;summary&amp;gt;
        /// 是否必须一致
        /// &amp;lt;/summary&amp;gt;
        public bool IsSuperTitleEq;
        /// &amp;lt;summary&amp;gt;
        /// 标题
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;String&amp;gt; Title;
        /// &amp;lt;summary&amp;gt;
        /// 是否必须一致
        /// &amp;lt;/summary&amp;gt;
        public bool IsTitleEq;
        /// &amp;lt;summary&amp;gt;
        /// 是否必须
        /// &amp;lt;/summary&amp;gt;
        public bool IsRequire;
        /// &amp;lt;summary&amp;gt;
        /// 表标题不能包含的文字
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;String&amp;gt; ExcludeTitle;
        /// &amp;lt;summary&amp;gt;
        /// 抽取内容预处理器
        /// &amp;lt;/summary&amp;gt;
        public Func&amp;lt;String, String, String&amp;gt; Normalize;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个表格抽取的例子：&lt;/p&gt;
&lt;p&gt;这里我们想抽取持股比例和持股数，但是希望抽取的是增持后的部分，所以需要使用SuperTitle的规则了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        var HoldList = new List&amp;lt;struHoldAfter&amp;gt;();
        var StockHolderRule = new TableSearchRule();
        StockHolderRule.Name = &quot;股东全称&quot;;
        StockHolderRule.Title = new string[] { &quot;股东名称&quot;, &quot;名称&quot;, &quot;增持主体&quot;, &quot;增持人&quot;, &quot;减持主体&quot;, &quot;减持人&quot; }.ToList();
        StockHolderRule.IsTitleEq = true;
        StockHolderRule.IsRequire = true;

        var HoldNumberAfterChangeRule = new TableSearchRule();
        HoldNumberAfterChangeRule.Name = &quot;变动后持股数&quot;;
        HoldNumberAfterChangeRule.IsRequire = true;
        HoldNumberAfterChangeRule.SuperTitle = new string[] { &quot;减持后&quot;, &quot;增持后&quot; }.ToList();
        HoldNumberAfterChangeRule.IsSuperTitleEq = false;
        HoldNumberAfterChangeRule.Title = new string[] {
             &quot;持股股数&quot;,&quot;持股股数&quot;,
             &quot;持股数量&quot;,&quot;持股数量&quot;,
             &quot;持股总数&quot;,&quot;持股总数&quot;,&quot;股数&quot;
        }.ToList();
        HoldNumberAfterChangeRule.IsTitleEq = false;

        var HoldPercentAfterChangeRule = new TableSearchRule();
        HoldPercentAfterChangeRule.Name = &quot;变动后持股数比例&quot;;
        HoldPercentAfterChangeRule.IsRequire = true;
        HoldPercentAfterChangeRule.SuperTitle = HoldNumberAfterChangeRule.SuperTitle;
        HoldPercentAfterChangeRule.IsSuperTitleEq = false;
        HoldPercentAfterChangeRule.Title = new string[] { &quot;比例&quot; }.ToList();
        HoldPercentAfterChangeRule.IsTitleEq = false;

        var Rules = new List&amp;lt;TableSearchRule&amp;gt;();
        Rules.Add(StockHolderRule);
        Rules.Add(HoldNumberAfterChangeRule);
        Rules.Add(HoldPercentAfterChangeRule);
        var result = HTMLTable.GetMultiInfoByTitleRules(root, Rules, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;entityproperty对象&quot;&gt;EntityProperty对象&lt;/h3&gt;
&lt;p&gt;EntityProperty对象属性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PropertyName：属性名称&lt;/li&gt;
&lt;li&gt;PropertyType：属性类型（数字，金额，字符，日期）&lt;/li&gt;
&lt;li&gt;MaxLength：最大长度&lt;/li&gt;
&lt;li&gt;MinLength：最小长度&lt;/li&gt;
&lt;li&gt;MaxLengthCheckPreprocess：最大长度判定前预处理器（不改变抽取内容）&lt;/li&gt;
&lt;li&gt;LeadingColonKeyWordList：先导词（包含&quot;：&quot;）&lt;/li&gt;
&lt;li&gt;LeadingColonKeyWordCandidatePreprocess：先导词预处理器（&lt;strong&gt;改变抽取内容&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;QuotationTrailingWordList:引号和书名号中的词语&lt;/li&gt;
&lt;li&gt;DpKeyWordList：句法依存环境&lt;/li&gt;
&lt;li&gt;ExternalStartEndStringFeature：普通的开始结尾词判定&lt;/li&gt;
&lt;li&gt;CandidatePreprocess:一般候选词预处理器（&lt;strong&gt;改变抽取内容&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;struRegularExpressFeature：正则表达式特征检索条件&lt;/li&gt;
&lt;li&gt;ExcludeContainsWordList：不能包含词语列表&lt;/li&gt;
&lt;li&gt;ExcludeEqualsWordList：不能等于词语列表&lt;/li&gt;
&lt;li&gt;Confidence：置信度对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 获得合同名
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    string GetContractName()
    {
        var e = new EntityProperty();
        e.PropertyName = &quot;合同名称&quot;;
        e.PropertyType = EntityProperty.enmType.Normal;
        e.MaxLength = ContractTraning.MaxContractNameLength;
        e.MinLength = 5;
        e.LeadingColonKeyWordList =  new string[] { &quot;合同名称：&quot; };
        e.QuotationTrailingWordList = new string[] { &quot;协议书&quot;, &quot;合同书&quot;, &quot;确认书&quot;, &quot;合同&quot;, &quot;协议&quot; };
        e.QuotationTrailingWordList_IsSkipBracket = true;   //暂时只能选True
        var KeyList = new List&amp;lt;ExtractPropertyByDP.DPKeyWord&amp;gt;();
        KeyList.Add(new ExtractPropertyByDP.DPKeyWord()
        {
            StartWord = new string[] { &quot;签署&quot;, &quot;签订&quot; },    //通过SRL训练获得
            StartDPValue = new string[] { LTPTrainingDP.核心关系, LTPTrainingDP.定中关系, LTPTrainingDP.并列关系 },
            EndWord = new string[] { &quot;补充协议&quot;, &quot;合同书&quot;, &quot;合同&quot;, &quot;协议书&quot;, &quot;协议&quot;, },
            EndDPValue = new string[] { LTPTrainingDP.核心关系, LTPTrainingDP.定中关系, LTPTrainingDP.并列关系, LTPTrainingDP.动宾关系, LTPTrainingDP.主谓关系 }
        });
        e.DpKeyWordList = KeyList;

        var StartArray = new string[] { &quot;签署了&quot;, &quot;签订了&quot; };   //通过语境训练获得
        var EndArray = new string[] { &quot;合同&quot; };
        e.ExternalStartEndStringFeature = Utility.GetStartEndStringArray(StartArray, EndArray);
        e.ExternalStartEndStringFeatureCandidatePreprocess = (x) =&amp;gt; { return x + &quot;合同&quot;; };
        e.MaxLengthCheckPreprocess = str =&amp;gt;
        {
            return EntityWordAnlayzeTool.TrimEnglish(str);
        };
        //最高级别的置信度，特殊处理器
        e.LeadingColonKeyWordCandidatePreprocess = str =&amp;gt;
        {
            var c = Normalizer.ClearTrailing(TrimJianCheng(str));
            return c;
        };

        e.CandidatePreprocess = str =&amp;gt;
        {
            var c = Normalizer.ClearTrailing(TrimJianCheng(str));
            var RightQMarkIdx = c.IndexOf(&quot;”&quot;);
            if (!(RightQMarkIdx != -1 &amp;amp;&amp;amp; RightQMarkIdx != c.Length - 1))
            {
                //对于&quot;XXX&quot;合同，有右边引号，但不是最后的时候，不用做
                c = c.TrimStart(&quot;“&quot;.ToCharArray());
            }
            c = c.TrimStart(&quot;《&quot;.ToCharArray());
            c = c.TrimEnd(&quot;》&quot;.ToCharArray()).TrimEnd(&quot;”&quot;.ToCharArray());
            return c;
        };
        e.ExcludeContainsWordList = new string[] { &quot;日常经营重大合同&quot; };
        //下面这个列表的根据不足
        e.ExcludeEqualsWordList = new string[] { &quot;合同&quot;, &quot;重大合同&quot;, &quot;项目合同&quot;, &quot;终止协议&quot;, &quot;经营合同&quot;, &quot;特别重大合同&quot;, &quot;相关项目合同&quot; };
        e.Extract(this);

        //是否所有的候选词里面包括（测试集无法使用）
        var contractlist = TraningDataset.ContractList.Where((x) =&amp;gt; { return x.id == this.Id; });
        if (contractlist.Count() &amp;gt; 0)
        {
            var contract = contractlist.First();
            var contractname = contract.ContractName;
            if (!String.IsNullOrEmpty(contractname))
            {
                e.CheckIsCandidateContainsTarget(contractname);
            }
        }
        //置信度
        e.Confidence = ContractTraning.ContractES.GetStardardCI();
        return e.EvaluateCI();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简单关键字抽取&quot;&gt;简单关键字抽取&lt;/h3&gt;
&lt;p&gt;对于一些及其简单的关键字抽取，例如，出现&quot;现金认购&quot;，则将认购方法标记为&quot;现金&quot;，则可以使用KeyWordMap属性即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 评估方式
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;root&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    string getEvaluateMethod()
    {
        var p = new EntityProperty();
        foreach (var method in ReOrganizationTraning.EvaluateMethodList)
        {
            p.KeyWordMap.Add(method, method);
        }
        p.Extract(this);
        if (!Program.IsMultiThreadMode) Program.Logger.WriteLine(&quot;评估方式:&quot; + string.Join(&quot;、&quot;, p.WordMapResult));
        return string.Join(&quot;、&quot;, p.WordMapResult);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实体位置体系&quot;&gt;实体位置体系&lt;/h2&gt;
&lt;p&gt;在寻在实体的时候，尽可能的将找到的实体及其位置进行记录，下面的结构体则是一个实体的记录。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 位置和值
    /// &amp;lt;/summary&amp;gt;
    public struct LocAndValue&amp;lt;T&amp;gt;
    {
        /// &amp;lt;summary&amp;gt;
        /// HTML整体位置
        /// &amp;lt;/summary&amp;gt;
        public int Loc;
        /// &amp;lt;summary&amp;gt;
        /// 开始位置
        /// &amp;lt;/summary&amp;gt;
        public int StartIdx;
        /// &amp;lt;summary&amp;gt;
        /// 值
        /// &amp;lt;/summary&amp;gt;
        public T Value;
        /// &amp;lt;summary&amp;gt;
        /// 类型
        /// &amp;lt;/summary&amp;gt;
        public string Type;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面则是一个实体位置的应用。公司里面放着所有公司实体的位置，标的则放着百分比 + “股权”字样的实体。通过位置信息，则可以将“公司”和“标的”成对发现。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 获得标的
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    List&amp;lt;(string Target, string Comany)&amp;gt; getTargetList()
    {
        var rtn = new List&amp;lt;(string Target, string Comany)&amp;gt;();

        var targetRegular = new ExtractProperyBase.struRegularExpressFeature()
        {
            RegularExpress = RegularTool.PercentExpress,
            TrailingWordList = new string[] { &quot;股权&quot; }.ToList()
        };
        var targetLoc = ExtractPropertyByHTML.FindRegularExpressLoc(targetRegular, root);

        //所有公司名称
        var CompanyList = new List&amp;lt;string&amp;gt;();
        foreach (var companyname in companynamelist)
        {
            //注意，这里的companyname.WordIdx是分词之后的开始位置，不是位置信息！
            if (!CompanyList.Contains(companyname.secFullName))
            {
                if (!string.IsNullOrEmpty(companyname.secFullName)) CompanyList.Add(companyname.secFullName);
            }
            if (!CompanyList.Contains(companyname.secShortName))
            {
                if (!string.IsNullOrEmpty(companyname.secShortName)) CompanyList.Add(companyname.secShortName);
            }
        }

        var targetlist = new List&amp;lt;string&amp;gt;();

        foreach (var companyname in CompanyList)
        {
            var companyLoc = ExtractPropertyByHTML.FindWordLoc(companyname, root);
            foreach (var company in companyLoc)
            {
                foreach (var target in targetLoc)
                {
                    var EndIdx = company.StartIdx + company.Value.Length;
                    if (company.Loc == target.Loc &amp;amp;&amp;amp; Math.Abs(target.StartIdx - EndIdx) &amp;lt; 2)
                    {
                        if (!targetlist.Contains(target.Value + &quot;:&quot; + company.Value))
                        {
                            rtn.Add((target.Value, company.Value));
                            targetlist.Add(target.Value + &quot;:&quot; + company.Value);
                        }
                    }
                }
            }
        }

        return rtn;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;h2 id=&quot;鸣谢&quot;&gt;鸣谢&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;感谢阿里巴巴组委会提供标注好的金融数据。&lt;/li&gt;
&lt;li&gt;感谢组委会@通联数据_梅洁,@梅童的及时答疑。&lt;/li&gt;
&lt;li&gt;感谢微信好友 邓少冬 潘昭鸣 NLP宋老师 的帮助和指导&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 17 Jul 2018 05:11:00 +0000</pubDate>
<dc:creator>codesnippet.info</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TextEditor/p/9322845.html</dc:identifier>
</item>
</channel>
</rss>