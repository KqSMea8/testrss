<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Rootkit 核心技术——利用 nt!_MDL（内存描述符链表）突破 SSDT（系统服务描述符表）的只读访问限制 Part I - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8361964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8361964.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在 rootkit 与恶意软件开发中有一项基本需求，那就是 hook Windows 内核的系统服务描述符表（下称 SSDT），把该表中的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;特定系统服务函数替换成我们自己实现的恶意例程；当然，&lt;span&gt;为了确保系统能够正常运作，我们需要事先用一个函数指针保存原始&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的系统服务，并且在我们恶意例程的逻辑中调用这个函数指针，此后才能进行 hook，否则损坏的内核代码与数据结构将导致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个 BugCheck（俗称的蓝屏）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;尽管 64 位 Windows 引入了像是 PatchGuard 的技术，实时监控关键的内核数据，包括但不限于 SSDT，IDT，GDT。。。等等，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;保证其完整性，但在 32 系统上修改 SSDT 是经常会遇到的场景，所以本文还是对此做出了介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OS 一般在系统初始化阶段把 SSDT 设定成&lt;span&gt;只读&lt;/span&gt;访问，这也是为了避免驱动与其它内核组件无意间改动到它；所以我们的首要任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是设法绕过这个只读属性。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;在此之前，先复习一下与 SSDT 相关的几个数据结构，并解释定位 SSDT 的过程。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们知道，每个线程的 _KTHREAD 结构中，偏移 0xbc 字节处是一枚叫做 ServiceTable 的泛型指针（亦即 PVOID 或 void*），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该字段指向一个全局的数据结构，叫做 KeServiceDescriptorTable，它就是 SSDT，SSDT 中首个字段又是一枚指针，指向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局的数据结构 KiServiceTable，&lt;span&gt;而后者是一个数组，其内的每个成员都是一枚函数指针，持有相应的系统服务例程入口地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的时候，用言语来描述内核的一些概念过于抽象和词穷，还是来看看下图吧，它很形象地展示了上述关系：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126222926522-1739045614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;根据上图我们有了思路：首先设法获取当前运行线程的 _KTHREAD 结构，然后即可逐步定位到 KiServiceTable，它就是我们最终&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hook 的对象！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;鉴于 ServiceTable 是一枚指针，持有另一枚指针 KeServiceDescriptorTable 的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（亦即“指向指针的指针”，往后我会不加以区分“持有”与“指向”术语），而 KiServiceTable 则是一个函数指针数组；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Rootkit 源码中，它们可以分别用三个全局变量（在驱动的入口点 DriverEntry() &lt;span&gt;之外&lt;/span&gt;声明 ）表示，如下图，我使用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“自注释”的变量名，很易于理解；而且我把星号紧接类型保留字后面，避免与“解引”操作混淆（所以星号是一个重载的运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;符）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224251303-1789262683.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于内核模式驱动程序开发人员来讲，自己实现一个例程来获取当前运行线程的 _KTHREAD 结构显然并不轻松，幸运的是，文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;化的 &lt;/span&gt;&lt;span&gt;PsGetCurrentThread() 例程能够完成这一任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（事实上，PsGetCurrentThread()的反汇编代码恰恰说明了这很简单，如下代码，&lt;span&gt;仅仅&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只是把 fs:[00000124h] 地址处的内容移动到 eax 寄存器作为返回值，而且 KeGetCurrentThread() 的逻辑与它如出一撤！&lt;/span&gt; ）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;kd&amp;gt; u PsGetCurrentThread
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; nt!&lt;span&gt;PsGetCurrentThread:&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 83c6cd19 64a124010000    &lt;span&gt;mov&lt;/span&gt;     eax,dword ptr &lt;span&gt;fs:&lt;/span&gt;&lt;span&gt;[00000124h]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 83c6cd1f c3              &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 83c6cd20 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 83c6cd21 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 83c6cd22 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 83c6cd23 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 83c6cd24 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; nt!&lt;span&gt;KeReadStateMutant:&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 83c6cd25 8bff            &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     edi,edi
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;kd&amp;gt; u KeGetCurrentThread
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; nt!&lt;span&gt;PsGetCurrentThread:&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 83c6cd19 64a124010000    &lt;span&gt;mov&lt;/span&gt;     eax,dword ptr &lt;span&gt;fs:&lt;/span&gt;&lt;span&gt;[00000124h]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 83c6cd1f c3              &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 83c6cd20 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 83c6cd21 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 83c6cd22 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 83c6cd23 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 83c6cd24 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;老生常谈，fs 寄存器通常用来存放“段选择符”，“段选择符”用来索引 GDT 中的一个“段描述符”，后者有一个“段基址”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;属性，也就是 KPCR（Kernel Processor Control Region，内核处理器控制区域）结构（nt!_KPCR）的起始地址；nt!_KPCR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏移 0x120 字节处是一个 nt!_KPRCB 结构，后者偏移 0x4 字节处的“CurrentThread”字段就是一个 _KTHREAD 结构，每次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程切换都会更新该字段，这就是 fs:[00000124h] 简洁的背后隐藏的强大设计思想！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;注意，PsGetCurrentThread() 返回一枚指向 _ETHREAD 结构的指针（亦即“PETHREAD”，如你所见，微软喜欢在指针这一概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上大玩&lt;/span&gt;&lt;span&gt;“&lt;span&gt;头文字 P&lt;/span&gt;”游戏），而 _ETHREAD 结构的首个字段 Tcb 就是一个 _KTHREAD 实例——这意味着，我们无需计算额外的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏移量，只要&lt;/span&gt;&lt;span&gt;考虑那个 ServiceTable 的偏移量 0xbc 即可，如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126223940850-2057569699.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;而我们需要在这枚指针上执行加法运算，移动它到 ServiceTable 字段处，所以不能声明一个 PETHREAD 变量来存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PsGetCurrentThread() &lt;/span&gt;&lt;span&gt;的返回值，因为“指针加上数值 n ”会把指针当前持有的地址加上（ n * 该指针所指的数据类型大小 ）个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节—— 表达式 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; PETHREAD ethread_ptr += &lt;span&gt;0xbc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;实际上把起始地址加上了 &lt;strong&gt;0xbc * sizeof(ETHREAD)&lt;/strong&gt; 个字节&lt;/span&gt;，远远超出了我们的预期。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么办呢？好办，声明一个&lt;strong&gt;字节型&lt;/strong&gt;指针来保存 PsGetCurrentThread() 的返回值，同时把返回值强制转型为一致的即可！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此一来，表达式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BYTE* byte_ptr += &lt;span&gt;0xbc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;就是把起始地址加上 &lt;strong&gt;0xbc * sizeof(BYTE)&lt;/strong&gt; 个字节&lt;/span&gt;，符合我们的预期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，这要求我们添加相关的类型定义，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224210365-1376951978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这表明 BYTE 与 无符号字符型等价（还等于微软自家的 UCHAR），大小都是单字节；DWORD 则与无符号长整型等价，大小都是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四字节——&lt;/span&gt;&lt;span&gt;我们用一个 DWORD 变量存储数组 KiServiceTable 的地址。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来就是通过一系列的&lt;span&gt;指针转型和解引操作&lt;/span&gt;，定位到 KiServiceTable 的过程，再次凸显了指针在 C 编程中的地位，无论是应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;还是内核。。。。。经过如下图的赋值运算，最终，全局变量 os_ki_service_table 持有了 KiServiceTable 的地址。注意，除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;了那&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;偏移量的宏定义外，所有的运算都在我们的驱动入口例程 DriverEntry() 中完成，而且为了支持动态卸载，我注册了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unload() 回&lt;/span&gt;&lt;span&gt;调，&lt;/span&gt;&lt;span&gt;稍后你会看到 Unload() 的内部实现——大致就是卸载时取消对 KiServiceTable 的写权限映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224520147-441321543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了验证定位 KiServiceTable 过程的准确性，我添加了下列打印输出语句，注意，DbgPrint() 的输出需要在被调试机器上以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DbgView.exe 查看；抑或直接输出到调试机器上的 windbg.exe/kd.exe 屏幕上：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224652569-885873950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合上图，在调试器中进行验证——“dd”命令可以按双字（四字节）显示给定虚拟内存地址处的内容；“dps”命令可以按照函&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数符号&lt;/span&gt;&lt;span&gt;显示从给定内存地址开始的例程地址——它就是专为函数指针数组（例如 KiServiceTable）设计的，如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224746647-153827286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，KiServiceTable 可以经由全局变量 os_ki_service_table 以只读形式访问，在我们 hook 它之前，需要设法更改为可写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看尝试向只读的 KiServiceTable 写入时会发生什么事情，如下图所示，我通过 RtlFillMemory() 试图向 KiServiceTable&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持有的第一个四字节（亦即系统服务 &lt;span&gt;nt!NtAcceptConnectPort&lt;/span&gt; ）填充 4 个 ASCII 字符“A”：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224907584-2118495130.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意，RtlFillMemory() 的第一个参数是一个指针，指向要被填充的内存块，后面二个参数分别是填充的长度与数据；由于我们的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量 os_ki_service_table 是 &lt;span&gt;DWORD 型&lt;/span&gt;，所以我把它强制转型为匹配的指针，再作为实参传入。。。。重新构建驱动，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放入以调试模式运行的虚拟机中加载，宿主机中发生的情况如下图所示，假设我们编译好的 rootkit 名称为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UseMdlMappingSSDT.sys ，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图中表明出现一个致命系统错误，代码为 0x000000BE，圆括号里边是携带错误信息的四个参数，在故障排查时会用到它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，这就是一个 BugCheck，当错误检查发生时，如果目标系统连接着宿主机上的调试器，就断入调试器，&lt;span&gt;否则目标系统&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上将执行 KeBugCheckEx() 例程，后者会屏蔽掉所有处理器核上的中断事件，然后将显示器切换到低分辩率的 VGA 图形模式下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绘制一个蓝色背景，然后向用户显示 “检查结果” 对应的停机代码。这就是“蓝屏”的由来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225214381-729772399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在此场景中，我们得到一个 0x000000BE 的停机代码，将其作为关键字串搜索 MSDN 文档，给出的描述如下图：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225240865-494102246.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;官方讲解的很清楚：0x000000BE（ATTEMPTED_WRITE_TO_READONLY_MEMORY）停机代码是由于驱动程序尝试向一个只读&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;的内存段写入导致的；第一个参数是试图写入的虚拟地址，第二个参数是描述该虚拟地址所在虚拟页-物理页的 PTE（页表项）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内容；后面两个参数为保留未来扩展使用，所以被我截断了。结合前面一张图我们知道，尝试写入的虚拟地址为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0x83CAFF7C，描述映射它的物理页的 PTE 内容是 0x03CAF121，后面两个参数就目前而言可以忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示，0x83CAFF7C 就是 KiServiceTable 的起始地址；&lt;span&gt;描述它的 PTE 经解码后的标志部分有一个“R”属性，表示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只读&lt;/span&gt;；BugCheck 时刻的栈回溯信息显示，内核中通用的异常处理程序 MmAccessFault() 负责处理与内存访问相关的错误，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是一个前端解析例程，如果异常或错误能够处理，它就分发至实际的处理函数，否则，它调用 KeBugCheck*() 系列函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该家族函数会根据调试器的存在与否作出决定——要么调用 KiBugCheckDebugBreak() 断入调试器；要么执行如前文所述的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程来绘制蓝屏：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225407303-1474115984.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此确定了 BugCheck 是由于在驱动中调用 RtlFillMemory() 写入只读的内核内存引发的。另一个更强大的调试器扩展命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“!analyze -v”可以输出详细的信息，包括 BugCheck “现场”的指令地址和寄存器状态，如下图所示，导致 BugCheck 的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指令地址为 0x9ff990b4，&lt;span&gt;该指令把 eax 寄存器的当前值（0x41414141，亦即我们调用 RtlFillMemory() 传入的 4 个 ASCII 字&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;符“A”）&lt;/span&gt;&lt;span&gt;&lt;span&gt;写入 ecx 寄存器持有的内存地址处，试图把 nt!NtAcceptConnectPort() 的入口点地址替换成 0x41414141&lt;/span&gt; ；另外它会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出&lt;/span&gt;&lt;span&gt;驱动源码中对应的行号——也就是第 137 行的 RtlFillMemory() 调用：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225539022-1351949022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如你所见，微软 C/C++ 编译器（cl.exe）把 RtlFillMemory() 内联在它的调用者内部，换言之，尽管有公开的文档描述它的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值，参数。。。。具体的实现还是由编译器说了算——&lt;strong&gt;为了性能优化，RtlFillMemory() 直接实现为一条简洁的数据移动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;指令，相关的参数由寄存器传递，没有因函数调用创建与销毁栈帧带来的额外开销！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到目前为止，尽管我们通过一系列步骤从 _KTHREAD 定位到了系统服务指针表，但以常规手段却无法 hook 其中的系统服务函&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数，因为&lt;/span&gt;&lt;span&gt;它是只读的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下一篇文章我将讨论如何使用 MDL（Memory Descriptor List，内存描述符链表）来绕过这种限制，随心所欲地读写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KiServiceTable！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 15:11:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8361964.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（十三）——哈希表 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8032656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8032656.html</guid>
<description>&lt;p&gt;　　Hash表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。&lt;/p&gt;
&lt;p&gt;　　注意，这里有个重要的问题就是如何把关键字转换为数组的下标，这个转换的函数称为哈希函数（也称散列函数），转换的过程称为哈希化。&lt;/p&gt;
&lt;h3&gt;1、哈希函数的引入&lt;/h3&gt;
&lt;p&gt;　　大家都用过字典，字典的优点是我们可以通过前面的目录快速定位到所要查找的单词。如果我们想把一本英文字典的每个单词，从 a 到 zyzzyva(这是牛津字典的最后一个单词)，都写入计算机内存，以便快速读写，那么哈希表是个不错的选择。&lt;/p&gt;
&lt;p&gt;　　这里我们将范围缩小点，比如想在内存中存储5000个英文单词。我们可能想到每个单词会占用一个数组单元，那么数组的大小是5000，同时可以用数组下标存取单词，这样设想很完美，但是数组下标和单词怎么建立联系呢？&lt;/p&gt;
&lt;p&gt;　　首先我们要建立单词和数字（数组下标）的关系：&lt;/p&gt;
&lt;p&gt;　　我们知道 ASCII 是一种编码，其中 a 表示97，b表示98，以此类推，一直到122表示z，而每个单词都是由这26个字母组成，我们可以不用 ASCII 编码那么大的数字，自己设计一套类似 ASCII的编码，比如a表示1，b表示2，依次类推，z表示26，那么表示方法我们就知道了。&lt;/p&gt;
&lt;p&gt;　　接下来如何把单个字母的数字组合成代表整个单词的数字呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、把数字相加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先第一种简单的方法就是把单词的每个字母表示的数字相加，得到的和便是数组的下标。&lt;/p&gt;
&lt;p&gt;　　比如单词 cats 转换成数字：&lt;/p&gt;
&lt;p&gt;　　cats = 3 + 1 + 20 + 19 = 43&lt;/p&gt;
&lt;p&gt;　　那么单词 cats 存储在数组中的下标为43，所有的英文单词都可以用这个办法转换成数组下标。但是这个办法真的可行吗？&lt;/p&gt;
&lt;p&gt;　　假设我们约定一个单词最多有 10 个字母，那么字典的最后一个单词为 zzzzzzzzzz ，其转换为数字：&lt;/p&gt;
&lt;p&gt;　　zzzzzzzzzz = 26*10 = 260&lt;/p&gt;
&lt;p&gt;　　那么我们可以得到单词编码的范围是从1-260。很显然，这个范围是不够存储5000个单词的，那么肯定有一个位置存储了多个单词，每个数组的数据项平均要存储192个单词（5000除以260）。&lt;/p&gt;
&lt;p&gt;　　对于上面的问题，我们如何解决呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一种方法：&lt;/strong&gt;考虑每个数组项包含一个子数组或者一个子链表，这个办法存数据项确实很快，但是如果我们想要从192个单词中查找到其中一个，那么还是很慢。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第二种方法：&lt;/strong&gt;为啥要让那么多单词占据同一个数据项呢？也就是说我们没有把单词分的足够开，数组能表示的元素太少，我们需要扩展数组的下标，使其每个位置都只存放一个单词。&lt;/p&gt;
&lt;p&gt;　　对于上面的第二种方法，问题产生了，我们如何扩展数组的下标呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、幂的连乘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们将单词表示的数拆成数列，用适当的 27 的幂乘以这些位数（因为有26个可能的字符，以及空格，一共27个），然后把乘积相加，这样就得出了每个单词独一无二的数字。&lt;/p&gt;
&lt;p&gt;　　比如把单词cats 转换为数字：&lt;/p&gt;
&lt;p&gt;　　cats = 3*27&lt;sup&gt;3&lt;/sup&gt; + 1*27&lt;sup&gt;2&lt;/sup&gt; + 20*27&lt;sup&gt;1&lt;/sup&gt; + 19*27&lt;sup&gt;0&lt;/sup&gt; = 59049 + 729 + 540 + 19 = 60337&lt;/p&gt;
&lt;p&gt;　　这个过程会为每个单词创建一个独一无二的数，但是注意的是我们这里只是计算了 4 个字母组成的单词，如果单词很长，比如最长的10个字母的单词 zzzzzzzzzz，仅仅是27&lt;sup&gt;9&lt;/sup&gt; 结果就超出了7000000000000，这个结果是很巨大的，在实际内存中，根本不可能为一个数组分配这么大的空间。&lt;/p&gt;
&lt;p&gt;　　所以这个方案的问题就是虽然为每个单词都分配了独一无二的下标，但是只有一小部分存放了单词，很大一部分都是空着的。那么现在就需要一种方法，把数位幂的连乘系统中得到的巨大的整数范围压缩到可接受的数组范围中。&lt;/p&gt;
&lt;p&gt;　　对于英语字典，假设只有5000个单词，这里我们选定容量为10000 的数组空间来存放（后面会介绍为啥需要多出一倍的空间）。那么我们就需要将从 0 到超过 7000000000000 的范围，压缩到从0到10000的范围。&lt;/p&gt;
&lt;p&gt;　　第一种方法：取余，得到一个数被另一个整数除后的余数。首先我们假设要把从0-199的数字（用largeNumber表示），压缩为从0-9的数字（用smallNumber表示），后者有10个数，所以变量smallRange 的值为10，这个转换的表达式为：&lt;/p&gt;
&lt;p&gt;　　smallNumber = largeNumber % smallRange&lt;/p&gt;
&lt;p&gt;　　当一个数被 10 整除时，余数一定在0-9之间，这样，我们就把从0-199的数压缩为从0-9的数，压缩率为 20 :1。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180106221144471-1865375569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们也可以用类似的方法把表示单词唯一的数压缩成数组的下标：&lt;/p&gt;
&lt;p&gt;　　arrayIndex = largerNumber % smallRange&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这也就是哈希函数。它把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2、冲突&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;把巨大的数字范围压缩到较小的数字范围，那么肯定会有几个不同的单词哈希化到同一个数组下标，即产生了&lt;strong&gt;冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　冲突可能会导致哈希化方案无法实施，前面我们说指定的数组范围大小是实际存储数据的两倍，因此可能有一半的空间是空着的，所以，当冲突产生时，一个方法是通过系统的方法找到数组的一个空位，并把这个单词填入，而不再用哈希函数得到数组的下标，这种方法称为开放地址法。比如加入单词 cats 哈希化的结果为5421，但是它的位置已经被单词parsnip占用了，那么我们会考虑将单词 cats 存放在parsnip后面的一个位置 5422 上。&lt;/p&gt;
&lt;p&gt;　　另一种方法，前面我们也提到过，就是数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中，这种方法称为链地址法。&lt;/p&gt;
&lt;h3&gt;3、开放地址法&lt;/h3&gt;
&lt;p&gt;　　开发地址法中，若数据项不能直接存放在由哈希函数所计算出来的数组下标时，就要寻找其他的位置。分别有三种方法：线性探测、二次探测以及再哈希法。&lt;/p&gt;
&lt;h4&gt;　　①、线性探测&lt;/h4&gt;
&lt;p&gt;　　在线性探测中，它会线性的查找空白单元。比如如果 5421 是要插入数据的位置，但是它已经被占用了，那么就使用5422，如果5422也被占用了，那么使用5423，以此类推，数组下标依次递增，直到找到空白的位置。这就叫做线性探测，因为它沿着数组下标一步一步顺序的查找空白单元。&lt;/p&gt;
&lt;p&gt;　　完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class MyHashTable {
        private DataItem[] hashArray;   //DataItem类，表示每个数据项信息
        private int arraySize;//数组的初始大小
        private int itemNum;//数组实际存储了多少项数据
        private DataItem nonItem;//用于删除数据项
        
        public MyHashTable(int arraySize){
                this.arraySize = arraySize;
                hashArray = new DataItem[arraySize];
                nonItem = new DataItem(-1);//删除的数据项下标为-1
        }
        //判断数组是否存储满了
        public boolean isFull(){
                return (itemNum == arraySize);
        }
        
        //判断数组是否为空
        public boolean isEmpty(){
                return (itemNum == 0);
        }
        
        //打印数组内容
        public void display(){
                System.out.println(&quot;Table:&quot;);
                for(int j = 0 ; j &amp;lt; arraySize ; j++){
                        if(hashArray[j] != null){
                                System.out.print(hashArray[j].getKey() + &quot; &quot;);
                        }else{
                                System.out.print(&quot;** &quot;);
                        }
                }
        }
        //通过哈希函数转换得到数组下标
        public int hashFunction(int key){
                return key%arraySize;
        }
        
        //插入数据项
        public void insert(DataItem item){
                if(isFull()){
                        //扩展哈希表
                        System.out.println(&quot;哈希表已满，重新哈希化...&quot;);
                        extendHashTable();
                }
                int key = item.getKey();
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null &amp;amp;&amp;amp; hashArray[hashVal].getKey() != -1){
                        ++hashVal;
                        hashVal %= arraySize;
                }
                hashArray[hashVal] = item;
                itemNum++;
        }
        /**
         * 数组有固定的大小，而且不能扩展，所以扩展哈希表只能另外创建一个更大的数组，然后把旧数组中的数据插到新的数组中。
         * 但是哈希表是根据数组大小计算给定数据的位置的，所以这些数据项不能再放在新数组中和老数组相同的位置上。
         * 因此不能直接拷贝，需要按顺序遍历老数组，并使用insert方法向新数组中插入每个数据项。
         * 这个过程叫做重新哈希化。这是一个耗时的过程，但如果数组要进行扩展，这个过程是必须的。
         */
        public void extendHashTable(){
                int num = arraySize;
                itemNum = 0;//重新计数，因为下面要把原来的数据转移到新的扩张的数组中
                arraySize *= 2;//数组大小翻倍
                DataItem[] oldHashArray = hashArray;
                hashArray = new DataItem[arraySize];
                for(int i = 0 ; i &amp;lt; num ; i++){
                        insert(oldHashArray[i]);
                }
        }
        
        //删除数据项
        public DataItem delete(int key){
                if(isEmpty()){
                        System.out.println(&quot;Hash Table is Empty!&quot;);
                        return null;
                }
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                DataItem temp = hashArray[hashVal];
                                hashArray[hashVal] = nonItem;//nonItem表示空Item,其key为-1
                                itemNum--;
                                return temp;
                        }
                        ++hashVal;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        //查找数据项
        public DataItem find(int key){
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                return hashArray[hashVal];
                        }
                        ++hashVal;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        public static class DataItem{
                private int iData;
                public DataItem(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的是，当哈希表变得太满时，我们需要扩展数组，但是需要注意的是，数据项不能放到新数组中和老数组相同的位置，而是要根据数组大小重新计算插入位置。这是一个比较耗时的过程，所以一般我们要确定数据的范围，给定好数组的大小，而不再扩容。&lt;/p&gt;
&lt;p&gt;　　另外，当哈希表变得比较满时，我们每插入一个新的数据，都要频繁的探测插入位置，因为可能很多位置都被前面插入的数据所占用了，这称为聚集。数组填的越满，聚集越可能发生。&lt;/p&gt;
&lt;p&gt;　　这就像人群，当某个人在商场晕倒时，人群就会慢慢聚集。最初的人群聚过来是因为看到了那个倒下的人，而后面聚过来的人是因为它们想知道这些人聚在一起看什么。人群聚集的越大，吸引的人就会越多。&lt;/p&gt;
&lt;h4&gt;　　②、装填因子&lt;/h4&gt;
&lt;p&gt;　　已填入哈希表的数据项和表长的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 2/3。当装填因子不太大时，聚集分布的比较连贯，而装填因子比较大时，则聚集发生的很大了。&lt;/p&gt;
&lt;p&gt;　　我们知道线性探测是一步一步的往后面探测，当装填因子比较大时，会频繁的产生聚集，那么如果我们探测比较大的单元，而不是一步一步的探测呢，这就是下面要讲的二次探测。&lt;/p&gt;
&lt;h4&gt;　　③、二次探测&lt;/h4&gt;
&lt;p&gt; 　　二测探测是防止聚集产生的一种方式，思想是探测相距较远的单元，而不是和原始位置相邻的单元。&lt;/p&gt;
&lt;p&gt;　　线性探测中，如果哈希函数计算的原始下标是x, 线性探测就是x+1, x+2, x+3, 以此类推；而在二次探测中，探测的过程是x+1, x+4, x+9, x+16，以此类推，到原始位置的距离是步数的平方。二次探测虽然消除了原始的聚集问题，但是产生了另一种更细的聚集问题，叫二次聚集：比如讲184，302，420和544依次插入表中，它们的映射都是7，那么302需要以1为步长探测，420需要以4为步长探测， 544需要以9为步长探测。只要有一项其关键字映射到7，就需要更长步长的探测，这个现象叫做二次聚集。二次聚集不是一个严重的问题，但是二次探测不会经常使用，因为还有好的解决方法，比如再哈希法。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180107104018674-1008018949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　④、再哈希法&lt;/h4&gt;
&lt;p&gt;　　为了消除原始聚集和二次聚集，我们使用另外一种方法：再哈希法。&lt;/p&gt;
&lt;p&gt;　　我们知道二次聚集的原因是，二测探测的算法产生的探测序列步长总是固定的：1,4，9,16以此类推。那么我们想到的是需要产生一种依赖关键字的探测序列，而不是每个关键字都一样，那么，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。&lt;/p&gt;
&lt;p&gt;　　方法是把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长。对于指定的关键字，步长在整个探测中是不变的，不过不同的关键字使用不同的步长。&lt;/p&gt;
&lt;p&gt;　　第二个哈希函数必须具备如下特点：&lt;/p&gt;
&lt;p&gt;　　一、和第一个哈希函数不同&lt;/p&gt;
&lt;p&gt;　　二、不能输出0（否则，将没有步长，每次探测都是原地踏步，算法将陷入死循环）。&lt;/p&gt;
&lt;p&gt;　　专家们已经发现下面形式的哈希函数工作的非常好：stepSize = constant - key % constant; 其中constant是质数，且小于数组容量。&lt;br/&gt;　　再哈希法要求表的容量是一个质数，假如表长度为15(0-14)，非质数，有一个特定关键字映射到0，步长为5，则探测序列是0,5,10,0,5,10,以此类推一直循环下去。算法只尝试这三个单元，所以不可能找到某些空白单元，最终算法导致崩溃。如果数组容量为13, 质数，探测序列最终会访问所有单元。即0,5,10,2,7,12,4,9,1,6,11,3,一直下去，只要表中有一个空位，就可以探测到它。&lt;/p&gt;
&lt;p&gt;　　完整再哈希法代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class HashDouble {
        private DataItem[] hashArray;   //DataItem类，表示每个数据项信息
        private int arraySize;//数组的初始大小
        private int itemNum;//数组实际存储了多少项数据
        private DataItem nonItem;//用于删除数据项
        
        public HashDouble(){
                this.arraySize = 13;
                hashArray = new DataItem[arraySize];
                nonItem = new DataItem(-1);//删除的数据项下标为-1
        }
        //判断数组是否存储满了
        public boolean isFull(){
                return (itemNum == arraySize);
        }
        
        //判断数组是否为空
        public boolean isEmpty(){
                return (itemNum == 0);
        }
        
        //打印数组内容
        public void display(){
                System.out.println(&quot;Table:&quot;);
                for(int j = 0 ; j &amp;lt; arraySize ; j++){
                        if(hashArray[j] != null){
                                System.out.print(hashArray[j].getKey() + &quot; &quot;);
                        }else{
                                System.out.print(&quot;** &quot;);
                        }
                }
        }
        //通过哈希函数转换得到数组下标
        public int hashFunction1(int key){
                return key%arraySize;
        }
        
        public int hashFunction2(int key){
                return 5 - key%5;
        }
        
        //插入数据项
        public void insert(DataItem item){
                if(isFull()){
                        //扩展哈希表
                        System.out.println(&quot;哈希表已满，重新哈希化...&quot;);
                        extendHashTable();
                }
                int key = item.getKey();
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);//用第二个哈希函数计算探测步数
                while(hashArray[hashVal] != null &amp;amp;&amp;amp; hashArray[hashVal].getKey() != -1){
                        hashVal += stepSize;
                        hashVal %= arraySize;//以指定的步数向后探测
                }
                hashArray[hashVal] = item;
                itemNum++;
        }

        /**
         * 数组有固定的大小，而且不能扩展，所以扩展哈希表只能另外创建一个更大的数组，然后把旧数组中的数据插到新的数组中。
         * 但是哈希表是根据数组大小计算给定数据的位置的，所以这些数据项不能再放在新数组中和老数组相同的位置上。
         * 因此不能直接拷贝，需要按顺序遍历老数组，并使用insert方法向新数组中插入每个数据项。
         * 这个过程叫做重新哈希化。这是一个耗时的过程，但如果数组要进行扩展，这个过程是必须的。
         */
        public void extendHashTable(){
                int num = arraySize;
                itemNum = 0;//重新计数，因为下面要把原来的数据转移到新的扩张的数组中
                arraySize *= 2;//数组大小翻倍
                DataItem[] oldHashArray = hashArray;
                hashArray = new DataItem[arraySize];
                for(int i = 0 ; i &amp;lt; num ; i++){
                        insert(oldHashArray[i]);
                }
        }
        
        //删除数据项
        public DataItem delete(int key){
                if(isEmpty()){
                        System.out.println(&quot;Hash Table is Empty!&quot;);
                        return null;
                }
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                DataItem temp = hashArray[hashVal];
                                hashArray[hashVal] = nonItem;//nonItem表示空Item,其key为-1
                                itemNum--;
                                return temp;
                        }
                        hashVal += stepSize;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        //查找数据项
        public DataItem find(int key){
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                return hashArray[hashVal];
                        }
                        hashVal += stepSize;
                        hashVal %= arraySize;
                }
                return null;
        }
        public static class DataItem{
                private int iData;
                public DataItem(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、链地址法&lt;/h3&gt;
&lt;p&gt;　　在开放地址法中，通过再哈希法寻找一个空位解决冲突问题，另一个方法是在哈希表每个单元中设置链表（即链地址法），某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这个位置的数据项只需要加到链表中，不需要在原始的数组中寻找空位。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180107112426424-1731209796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有序链表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class SortLink {
        private LinkNode first;
        public SortLink(){
                first = null;
        }
        public boolean isEmpty(){
                return (first == null);
        }
        public void insert(LinkNode node){
                int key = node.getKey();
                LinkNode previous = null;
                LinkNode current = first;
                while(current != null &amp;amp;&amp;amp; current.getKey() &amp;lt; key){
                        previous = current;
                        current = current.next;
                }
                if(previous == null){
                        first = node;
                }else{
                        node.next = current;
                        previous.next = node;
                }
        }
        public void delete(int key){
                LinkNode previous = null;
                LinkNode current = first;
                if(isEmpty()){
                        System.out.println(&quot;Linked is Empty!!!&quot;);
                        return;
                }
                while(current != null &amp;amp;&amp;amp; current.getKey() != key){
                        previous = current;
                        current = current.next;
                }
                if(previous == null){
                        first = first.next;
                }else{
                        previous.next = current.next;
                }
        }
        
        public LinkNode find(int key){
                LinkNode current = first;
                while(current != null &amp;amp;&amp;amp; current.getKey() &amp;lt;= key){
                        if(current.getKey() == key){
                                return current;
                        }
                }
                return null;
        }
        
        public void displayLink(){
                System.out.println(&quot;Link(First-&amp;gt;Last)&quot;);
                LinkNode current = first;
                while(current != null){
                        current.displayLink();
                        current = current.next;
                }
                System.out.println(&quot;&quot;);
        }
        class LinkNode{
                private int iData;
                public LinkNode next;
                public LinkNode(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
                public void displayLink(){
                        System.out.println(iData + &quot; &quot;);
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　链地址法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

import com.ys.hash.SortLink.LinkNode;

public class HashChain {
        private SortLink[] hashArray;//数组中存放链表
        private int arraySize;
        public HashChain(int size){
                arraySize = size;
                hashArray = new SortLink[arraySize];
                //new 出每个空链表初始化数组
                for(int i = 0 ; i &amp;lt; arraySize ; i++){
                        hashArray[i] = new SortLink();
                }
        }
        
        public void displayTable(){
                for(int i = 0 ; i &amp;lt; arraySize ; i++){
                        System.out.print(i + &quot;：&quot;);
                        hashArray[i].displayLink();
                }
        }
        
        public int hashFunction(int key){
                return key%arraySize;
        }
        
        public void insert(LinkNode node){
                int key = node.getKey();
                int hashVal = hashFunction(key);
                hashArray[hashVal].insert(node);//直接往链表中添加即可
        }
        
        public LinkNode delete(int key){
                int hashVal = hashFunction(key);
                LinkNode temp = find(key);
                hashArray[hashVal].delete(key);//从链表中找到要删除的数据项，直接删除
                return temp;
        }
        
        public LinkNode find(int key){
                int hashVal = hashFunction(key);
                LinkNode node = hashArray[hashVal].find(key);
                return node;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　链地址法中，装填因子（数据项数和哈希表容量的比值）与开放地址法不同，在链地址法中，需要有N个单元的数组中转入N个或更多的数据项，因此装填因子一般为1，或比1大（有可能某些位置包含的链表中包含两个或两个以上的数据项）。&lt;/p&gt;
&lt;p&gt;　　找到初始单元需要O(1)的时间级别，而搜索链表的时间与M成正比，M为链表包含的平均项数，即O(M)的时间级别。&lt;/p&gt;
&lt;h3&gt;5、桶&lt;/h3&gt;
&lt;p&gt;　　另外一种方法类似于链地址法，它是在每个数据项中使用子数组，而不是链表。这样的数组称为桶。&lt;/p&gt;
&lt;p&gt;　　这个方法显然不如链表有效，因为桶的容量不好选择，如果容量太小，可能回溢出，如果太大，又造成性能浪费，而链表是动态分配的，不存在此问题。所以一般不使用桶。&lt;/p&gt;
&lt;h3&gt;6、总结 &lt;/h3&gt;
&lt;p&gt;　　哈希表基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。用来解决冲突的有两种方法：开放地址法和链地址法。在开发地址法中，把冲突的数据项放在数组的其它位置；在链地址法中，每个单元都包含一个链表，把所有映射到同一数组下标的数据项都插入到这个链表中。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 14:56:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8032656.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——26. 不要使用原始类型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8361867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8361867.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自Java 5以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。&lt;/p&gt;

&lt;p&gt;首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（ type parameters ），被称之为泛型类或泛型接口[JLS，8.1.2,9.1.2]。 例如，List接口具有单个类型参数E，表示其元素类型。 接口的全名是&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;（读作“E”的列表），但是人们经常称它为List。 泛型类和接口统称为泛型类型（generic types）。&lt;/p&gt;
&lt;p&gt;每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5]相对应的实际类型参数的尖括号“&amp;lt;&amp;gt;”列表。 例如，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;（读作“字符串列表”）是一个参数化类型，表示其元素类型为String的列表。 （String是与形式类型参数E相对应的实际类型参数）。&lt;/p&gt;
&lt;p&gt;最后，每个泛型定义了一个原始类型（ raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;的原始类型是List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。&lt;/p&gt;
&lt;p&gt;在泛型被添加到Java之前，这是一个典型的集合声明。 从Java 9开始，它仍然是合法的，但并不是典型的声明方式了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Raw collection type - don't do this!

// My stamp collection. Contains only Stamp instances.
private final Collection stamps = ... ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你今天使用这个声明，然后不小心把coin实例放入你的stamp集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Erroneous insertion of coin into stamp collection
stamps.add(new Coin( ... )); // Emits &quot;unchecked call&quot; warning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直到您尝试从stamp集合中检索coin实例时才会发生错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Raw iterator type - don't do this!
for (Iterator i = stamps.iterator(); i.hasNext(); )
    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException
        stamp.cancel();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到ClassCastException，就必须搜索代码类库，查找将coin实例放入stamp集合的方法调用。 编译器不能帮助你，因为它不能理解那个说“仅包含stamp实例”的注释。&lt;/p&gt;
&lt;p&gt;对于泛型，类型声明包含的信息，而不是注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Parameterized collection type - typesafe
private final Collection&amp;lt;Stamp&amp;gt; stamps = ... ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个声明中，编译器知道stamps集合应该只包含Stamp实例，并保证它是true，假设你的整个代码类库编译时不发出（或者抑制;参见条目27）任何警告。 当使用参数化类型声明声明stamps时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:9: error: incompatible types: Coin cannot be converted
to Stamp
    c.add(new Coin());
              ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将coin实例插入stamp集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将&lt;code&gt;BigInteger&lt;/code&gt;放入一个只包含&lt;code&gt;BigDecimal&lt;/code&gt;实例的集合中。&lt;/p&gt;
&lt;p&gt;如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 &lt;strong&gt;如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势&lt;/strong&gt;。 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（条目 28）。&lt;/p&gt;
&lt;p&gt;虽然不应使用诸如List之类的原始类型，但可以使用参数化类型来允许插入任意对象（如&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;）。 原始类型List和参数化类型&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;传递给List类型的参数，但不能将其传递给&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;类型的参数。 泛型有子类型的规则，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;是原始类型List的子类型，但不是参数化类型&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的子类型（条目 28）。 因此，如果使用诸如List之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;）则不会。&lt;/p&gt;
&lt;p&gt;为了具体说明，请考虑以下程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Fails at runtime - unsafeAdd method uses a raw type (List)!
public static void main(String[] args) {
    List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;();
    unsafeAdd(strings, Integer.valueOf(42));
    String s = strings.get(0); // Has compiler-generated cast
}

private static void unsafeAdd(List list, Object o) {
    list.add(o);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此程序可以编译，它使用原始类型列表，但会收到警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:10: warning: [unchecked] unchecked call to add(E) as a
member of the raw type List
    list.add(o);
            ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，如果运行该程序，则当程序尝试调用&lt;code&gt;strings.get(0)&lt;/code&gt;的结果（一个Integer）转换为一个String时，会得到ClassCastException异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。&lt;/p&gt;
&lt;p&gt;如果用unsafeAdd声明中的参数化类型&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;替换原始类型List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:5: error: incompatible types: List&amp;lt;String&amp;gt; cannot be
converted to List&amp;lt;Object&amp;gt;
    unsafeAdd(strings, Integer.valueOf(42));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Use of raw type for unknown element type - don't do this!
static int numElementsInCommon(Set s1, Set s2) {
    int result = 0;
    for (Object o1 : s1)
        if (s2.contains(o1))
            result++;
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型&lt;code&gt;Set&amp;lt;E&amp;gt;&lt;/code&gt;的无限制通配符类型是&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;（读取“某种类型的集合”）。 它是最通用的参数化的Set类型，能够保持任何集合。 下面是&lt;code&gt;numElementsInCommon&lt;/code&gt;方法使用无限制通配符类型声明的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Uses unbounded wildcard type - typesafe and flexible
static int numElementsInCommon(Set&amp;lt;?&amp;gt; s1, Set&amp;lt;?&amp;gt; s2) { ... }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无限制通配符&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;与原始类型Set之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第119页上的unsafeAdd方法所示）; 你不能把任何元素（除null之外）放入一个&lt;code&gt;Collection &amp;lt;?&amp;gt;&lt;/code&gt;中。 试图这样做会产生一个像这样的编译时错误消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WildCard.java:13: error: incompatible types: String cannot be
converted to CAP#1
    c.add(&quot;verboten&quot;);
          ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅可以将任何元素（除null以外）放入一个&lt;code&gt;Collection &amp;lt;?&amp;gt;&lt;/code&gt;中，但是不能保证你所得到的对象的类型。 如果这些限制是不可接受的，可以使用泛型方法（条目 30）或有限制配符类型（条目 31）。&lt;/p&gt;
&lt;p&gt;对于不应该使用原始类型的规则，有一些小例外。 &lt;strong&gt;你必须在类字面值（class literals）中使用原始类型&lt;/strong&gt;。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，&lt;code&gt;List.class&lt;/code&gt;，&lt;code&gt;String [] .class&lt;/code&gt;和&lt;code&gt;int.class&lt;/code&gt;都是合法的，但&lt;code&gt;List &amp;lt;String&amp;gt; .class&lt;/code&gt;和&lt;code&gt;List &amp;lt;?&amp;gt;.class&lt;/code&gt;不是合法的。&lt;/p&gt;
&lt;p&gt;规则的第二个例外涉及&lt;code&gt;instanceof&lt;/code&gt;操作符。 因为泛型类型信息在运行时被删除，所以在无限制通配符类型以外的参数化类型上使用instanceof运算符是非法的。 使用无限制通配符类型代替原始类型不会以任何方式影响instanceof运算符的行为。 在这种情况下，尖括号和问号就显得多余。 以下是使用泛型类型的instanceof运算符的首选方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Legitimate use of raw type - instanceof operator
if (o instanceof Set) {       // Raw type
    Set&amp;lt;?&amp;gt; s = (Set&amp;lt;?&amp;gt;) o;    // Wildcard type
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，一旦确定&lt;code&gt;o&lt;/code&gt;对象是一个Set，则必须将其转换为通配符&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;，而不是原始类型Set。 这是一个强制转换，所以不会导致编译器警告。&lt;/p&gt;
&lt;p&gt;总之，使用原始类型可能导致运行时异常，所以不要使用它们。 它们仅用于与泛型引入之前的传统代码的兼容性和互操作性。 作为一个快速回顾，&lt;code&gt;Set&amp;lt;Object&amp;gt;&lt;/code&gt;是一个参数化类型，表示一个可以包含任何类型对象的集合，&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。&lt;/p&gt;
&lt;p&gt;为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Parameterized type&lt;/td&gt;
&lt;td&gt;参数化类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Actual type parameter&lt;/td&gt;
&lt;td&gt;实际类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Generic type&lt;/td&gt;
&lt;td&gt;泛型类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Formal type parameter&lt;/td&gt;
&lt;td&gt;形式类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Unbounded wildcard type&lt;/td&gt;
&lt;td&gt;无限制通配符类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Raw type&lt;/td&gt;
&lt;td&gt;原始类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Bounded type parameter&lt;/td&gt;
&lt;td&gt;限制类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 29&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Recursive type bound&lt;/td&gt;
&lt;td&gt;递归类型限制&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Bounded wildcard type&lt;/td&gt;
&lt;td&gt;限制通配符类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;? extends Number&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 31&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Generic method&lt;/td&gt;
&lt;td&gt;泛型方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; asList(E[] a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Type token&lt;/td&gt;
&lt;td&gt;类型令牌&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String.class&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 33&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Fri, 26 Jan 2018 14:28:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8361867.html</dc:identifier>
</item>
<item>
<title>豹哥嵌入式讲堂：ARM Cortex-M开发之文件详解（8）- 镜像文件(.bin/.hex/.s19) - Jay豹哥</title>
<link>http://www.cnblogs.com/henjay724/p/8361693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/8361693.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是豹哥，猎豹的豹，犀利哥的哥。今天豹哥给大家讲的是&lt;strong&gt;嵌入式开发里的image文件(.bin, .hex, .s19)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　今天这节课是豹哥《ARM Cortex-M开发之文件详解》主题系列的最后一节课（突然有点不舍，要告别的感觉，咳咳，让豹哥整理下情绪先）。今天豹哥主要讲的是工程开发最终的output文件，即image文件。image文件也叫镜像文件，这个文件主要包含的是只有芯片能够解释执行的二进制机器码数据，这些数据其实在前面介绍的relocatable、list、executable文件中出现过，在那些文件里我们还可以根据其他辅助信息来分析机器码数据的实际意义，但在image文件里，我们已经完全无法看懂这些机器码了。所以image文件主要是用来做大规模量产的。既要做大规模量产，由于各芯片厂家制定的标准不一，所以实际上image文件有很多种格式，今天我们主要讲的是其中最具有代表性也应用最广泛的3种image文件格式。&lt;/p&gt;
&lt;h3 id=&quot;一通用镜像文件bin&quot;&gt;一、通用镜像文件bin&lt;/h3&gt;
&lt;p&gt;　　第一种格式叫binary，以.bin为文件后缀，这种格式是一种通用image格式，其完全是机器码裸数据的集合，没有其他任何多余信息，这个数据可以直接被编程器/下载器下载到芯片内部非易失性存储器里，不需要任何额外的数据转换，所见即所得。由于是纯二进制编码的文件，所以普通text编辑器无法正确查看这个文件，需要用专用的十六进制编辑器（比如Hex Editor HxD）才能正常打开。以本系列创建的demo工程的demo.bin文件为例，用HxD打开可见如下数据（仅截取前后部分显示，demo.bin共6780 bytes）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;offset(h)
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; DB &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; CB &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000010&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000020&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;07&lt;/span&gt; 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000030&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1D 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1F 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000040&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt; B6 0E &lt;span class=&quot;dv&quot;&gt;48&lt;/span&gt; 0E &lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
...
00001A30: &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt; E0 0A &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;09&lt;/span&gt; 1D 1A &lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt; D0 4D &lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;
00001A40: 6D 1E &lt;span class=&quot;dv&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; 1D &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1F &lt;span class=&quot;dv&quot;&gt;04&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; FA D2 &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
00001A50: &lt;span class=&quot;dv&quot;&gt;86&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;07&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt; D5 &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt; AD 1C &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; D0 2C &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt;
00001A60: &lt;span class=&quot;dv&quot;&gt;09&lt;/span&gt; 1D &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; E7 D1 &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; BC &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;47&lt;/span&gt; C1 FF FF FF
00001A70: &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; -- -- -- --&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有细心的朋友可能会疑问，打开bin文件看数据都是按连续地址排列的，如果在应用设计中，我们在linker文件里给各个段分配的地址不是连续的，这在bin文件里是怎么处理的？为了解决这个问题，bin文件会在非有效地址区域插入无效字节以保证有效地址处都是正确的数据，这在IDE里或相关转换工具里都会有相应option，可以让用户设置填充字节pattern（比如0x00，0xFF等）。&lt;br/&gt;　　好，现在让我们尝试分析一下这个bin文件，我们都知道ARM Cortex-M架构里，image bin文件前8个字节应该是初始SP和PC的值，从前面map文件里我们知道SP=0x10002000，PC=0x00000041，来检查一下bin文件里是不是这样，前4个字节分别是 00 20 00 10、看起来好像跟0x10002000数据是吻合的，但是这个数据排列方式看起来好像有点别扭，怎么回事？嵌入式老司机这时应该要莞尔一笑，是的，ARM Coretx-M默认采用的Little-Endian（小端）模式，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。数据查看地址显示都是从低到高的（从左到右），所以SP的最低字节应该显示在最左边（最低地址），而不是像查看0x10002000那样最低字节在最右边，这跟人的阅读习惯是有点不吻合。&lt;br/&gt;　　PS: 既有小端模式，那么与其对应的也有大端模式（Big-Endian）-高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。注意大端小端仅是针对以32bit为单元的数据排列方式差异，对于n个32bit数据，其都是统一的排列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;offset(h)
&lt;span class=&quot;co&quot;&gt;// 小端&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;// 大端&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上面对bin文件的分析，我们知道bin文件是不含地址信息的，也就是说bin文件数据应该被放在什么地址处，我们仅从bin文件本身是无法得知的。所以在使用编程器/下载器下载bin文件时，用户必须指定起始下载地址。由于bin文件的这种局限性，下面两种带地址信息的image格式应运而生。&lt;/p&gt;
&lt;h3 id=&quot;二intel镜像文件标准hex&quot;&gt;二、Intel镜像文件标准hex&lt;/h3&gt;
&lt;p&gt;　　第二种格式叫Intel hex，以.hex为文件后缀，这种格式是Intel公司推行的一种image格式标准，其不仅含有机器码裸数据还含有地址信息等额外信息，与bin文件不同的是，hex文件可以直接通用普通text编辑器打开查看，hex文件采用的ASCII编码，hex文件内的机器码数据不可以直接被下载进芯片内部，需要在帧数据解析的过程中进行转换。&lt;br/&gt;　　由于hex文件并不是纯机器码文件，还含有其他额外信息，那么hex文件就需要按某种约定格式进行数据组织，数据组织方式叫帧格式，hex文件是由n帧数据组成的。&lt;/p&gt;
&lt;h4 id=&quot;hex帧格式&quot;&gt;2.1 hex帧格式&lt;/h4&gt;
&lt;p&gt;　　要想解析hex文件，必须要先了解其帧格式，hex每帧都由下表列出的6部分组成：&lt;/p&gt;
&lt;table readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;帧段名&lt;/th&gt;
&lt;td&gt;Start code&lt;/td&gt;
&lt;td&gt;Byte count&lt;/td&gt;
&lt;td&gt;Address&lt;/td&gt;
&lt;td&gt;Record type&lt;/td&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;th&gt;帧段内容&lt;/th&gt;
&lt;td&gt;固定前导码':'，十六进制0x3A&lt;/td&gt;
&lt;td&gt;机器码数据长度&lt;/td&gt;
&lt;td&gt;机器码数据存储地址&lt;/td&gt;
&lt;td&gt;帧类型&quot;00&quot;-&quot;05&quot;，有6种帧&lt;/td&gt;
&lt;td&gt;机器码数据&lt;/td&gt;
&lt;td&gt;校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;帧段长度(bytes)&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;2*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;(0-255)*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;　　编程器/下载器在解析hex文件时，先找到帧前导码，然后找到帧类型，如果该帧为数据帧，再根据帧机器码长度，将该帧机器码数据全部读出放到缓存里，在做完帧和校验后，如果没有错误，最后根据帧机器码存储地址将帧机器码数据下载到芯片指定存储器地址处，至此一帧处理结束，进入下一帧，直到所有帧全部处理完。需要注意的是由于hex文件是ASCII编码，所以相比bin文件长度至少大2倍以上，demo.hex文件大小有19,106 bytes，后面我们会截取部分hex文件进行分析。&lt;br/&gt;　　关于checksum的计算方法，其是将Byte count、Address、Record type、Data四个段内所有byte全部相加得到sum，截取sum的LSB（最低字节），再对该LSB取其补码（默认该LSB为负数的低8bit数据位(注意8bit中没有符号位)，其反码为原码各bit取反，其补码为反码+1）得到checksum。比如LSB是0xA5，其反码为0x5A，补码为0x5B，则checksum为0x5B。&lt;/p&gt;
&lt;h4 id=&quot;hex帧类型&quot;&gt;2.2 hex帧类型&lt;/h4&gt;
&lt;p&gt;　　前面说到一共有6种类型的帧，其中最重要也是数量最多的帧是数据帧，除了数据帧之外还有其他5种帧，下面来统一介绍：&lt;/p&gt;
&lt;table readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;th&gt;帧类型码&lt;/th&gt;
&lt;th&gt;帧类型&lt;/th&gt;
&lt;th&gt;帧描述&lt;/th&gt;
&lt;th&gt;帧举例&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&quot;00&quot;&lt;/td&gt;
&lt;td&gt;数据帧&lt;/td&gt;
&lt;td&gt;以16bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含11bytes机器码从0x0010地址处开始的数据帧:0B0010006164647265737320676170A7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&quot;01&quot;&lt;/td&gt;
&lt;td&gt;文件结尾帧&lt;/td&gt;
&lt;td&gt;用于表明hex文件的结尾&lt;/td&gt;
&lt;td&gt;统一的文件结尾帧:00000001FF&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&quot;02&quot;&lt;/td&gt;
&lt;td&gt;拓展段地址帧&lt;/td&gt;
&lt;td&gt;多用于80x86架构芯片，ARM Cortex-M架构不用&lt;/td&gt;
&lt;td&gt;:020000021200EA&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&quot;03&quot;&lt;/td&gt;
&lt;td&gt;起始段地址帧&lt;/td&gt;
&lt;td&gt;多用于80x86架构芯片，ARM Cortex-M架构不用&lt;/td&gt;
&lt;td&gt;:0400000300003800C1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&quot;04&quot;&lt;/td&gt;
&lt;td&gt;拓展线性地址帧&lt;/td&gt;
&lt;td&gt;用于32bit地址存储空间芯片，与数据帧配合使用，指引编程器将数据下载到正确地址&lt;/td&gt;
&lt;td&gt;标明拓展地址为0xFFFF的帧:02000004FFFFFC&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&quot;05&quot;&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧&lt;/td&gt;
&lt;td&gt;指示调试器，程序初始PC地址，方便在线调试&lt;/td&gt;
&lt;td&gt;标明起始PC为0x000000CD的帧:04000005000000CD2A&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h4 id=&quot;解析hex文件&quot;&gt;2.3 解析hex文件&lt;/h4&gt;
&lt;p&gt;　　在了解hex文件帧数据格式之后，让我们开始尝试解析demo.hex文件(仅截取前后部分，与前面截取的bin文件内容对应着一起分析)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;:100000000020001041000000DB180000CB190000A8
:&lt;span class=&quot;fl&quot;&gt;1000100000000000000000000000000000000000E0&lt;/span&gt;
:10002000000000000000000000000000071A0000AF
:1000300000000000000000001D1A00001F1A000050
:1000400072B60E480E498860002200230024002565
....
:101A30000123002413E00A68091D1A4202D04D4612
:101A40006D1E52191460121D001F0428FAD21500D1
:101A5000860701D51480AD1C184000D02C70086892
:101A6000091D0028E7D1080070BC7047C1FFFFFFC7
:0C1A70000802000014200010000000001C
:0400000500000041B6
:00000001FF&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　hex文件前5帧均为数据帧，每帧包含16bytes机器码数据，帧数据地址分别为0x0000, 0x0010, 0x0020, 0x0030, 0x0040，可见帧数据是连续的，并且5帧机器码数据共80bytes与bin文件前80bytes是一致的。&lt;br/&gt;　　再来看最后7帧数据里的前5个数据帧，除最后一帧数据只包含12bytes数据外，其余数据帧均含有16bytes数据，5帧数据一共76bytes，帧数据地址从0x1A30 - 0x1A70。显然这与bin文件最后76bytes也是吻合的。&lt;br/&gt;　　倒数第二帧是起始程序地址帧，其标明的程序起始PC是0x00000041，这与bin文件里第二个32bit数据（起始PC）是一致的。&lt;br/&gt;　　倒数第一帧显然是标准文件结尾帧。&lt;/p&gt;
&lt;h3 id=&quot;三motorola镜像文件标准s-record&quot;&gt;三、Motorola镜像文件标准S-Record&lt;/h3&gt;
&lt;p&gt;　　第三种格式叫Motorola S-Record，以.s19或.srec为文件后缀，这种格式是Motorola公司推行的一种image格式标准，其与Intel hex文件比较类似，都是ASCII编码的文件，可以通过普通text编辑器打开查看，其也由帧数据组成，只是帧格式与Intel hex有差别，还是按照介绍Intel hex文件那样先来看S-Record文件的帧格式。&lt;/p&gt;
&lt;h4 id=&quot;s-record帧格式&quot;&gt;3.1 S-Record帧格式&lt;/h4&gt;
&lt;p&gt;　　S-Record每帧由下表列出的6部分组成：&lt;/p&gt;
&lt;table readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;th&gt;帧段名&lt;/th&gt;
&lt;td&gt;Start code&lt;/td&gt;
&lt;td&gt;Record type&lt;/td&gt;
&lt;td&gt;Byte count&lt;/td&gt;
&lt;td&gt;Address&lt;/td&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;th&gt;帧段内容&lt;/th&gt;
&lt;td&gt;固定前导码'S'，十六进制0x53&lt;/td&gt;
&lt;td&gt;帧类型'0'-'9'，有10种帧&lt;/td&gt;
&lt;td&gt;帧数据长度（包含后续段地址、数据、校验和）&lt;/td&gt;
&lt;td&gt;机器码数据存储地址&lt;/td&gt;
&lt;td&gt;机器码数据&lt;/td&gt;
&lt;td&gt;校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;帧段长度(bytes)&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;(2-4)*2&lt;/td&gt;
&lt;td&gt;(0-255)*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;　　编程器/下载器在解析S-Record文件时，先找到帧前导码，然后找到帧类型，如果该帧为数据帧，再根据帧长度，将该帧机器码数据全部读出放到缓存里，在做完帧和校验后，如果没有错误，最后根据帧机器码存储地址将帧机器码数据下载到芯片指定存储器地址处，至此一帧处理结束，进入下一帧，直到所有帧全部处理完。&lt;br/&gt;　　关于checksum的计算方法，其是将Byte count、Address、Data三个段内所有byte全部相加得到sum，截取sum的LSB（最低字节），再对该LSB取其反码（默认该LSB为负数的低8bit数据位(注意8bit中没有符号位)，其反码为原码各bit取反）得到checksum。比如LSB是0xA5，其反码为0x5A，则checksum为0x5A。&lt;/p&gt;
&lt;h4 id=&quot;s-record帧类型&quot;&gt;3.2 S-Record帧类型&lt;/h4&gt;
&lt;p&gt;　　前面说到一共有10种类型的帧，其中最重要也是数量最多的帧是数据帧，数据帧按地址长度可分为16bit、24bit、32bit地址长度数据帧，除了数据帧，还有其他种类帧，下面来统一介绍：&lt;/p&gt;
&lt;table readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;th&gt;帧类型码&lt;/th&gt;
&lt;th&gt;帧类型&lt;/th&gt;
&lt;th&gt;帧描述&lt;/th&gt;
&lt;th&gt;帧举例&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'0'&lt;/td&gt;
&lt;td&gt;文件起始帧&lt;/td&gt;
&lt;td&gt;用于表明S-Record文件的开始&lt;/td&gt;
&lt;td&gt;标明文件名为HDR的文件起始帧S00600004844521B&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'1'&lt;/td&gt;
&lt;td&gt;数据帧x16地址&lt;/td&gt;
&lt;td&gt;以16bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含14bytes机器码从0x0038地址处开始的数据帧S111003848656C6C6F20776F726C642E0A0042&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'2'&lt;/td&gt;
&lt;td&gt;数据帧x24地址&lt;/td&gt;
&lt;td&gt;以24bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含4bytes机器码从0x100000地址处开始的数据帧S2081000000400FA05E5&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'3'&lt;/td&gt;
&lt;td&gt;数据帧x32地址&lt;/td&gt;
&lt;td&gt;以32bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含4bytes机器码从0x13000160地址处开始的数据帧S309130001600400FA057F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'4'&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'5'&lt;/td&gt;
&lt;td&gt;数据帧总数帧x16&lt;/td&gt;
&lt;td&gt;用16bit count记录数据帧总帧数的总数帧&lt;/td&gt;
&lt;td&gt;标明总数据帧为4帧的总数帧S5030004F8&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'6'&lt;/td&gt;
&lt;td&gt;数据帧总数帧x16&lt;/td&gt;
&lt;td&gt;用24bit count记录数据帧总帧数的总数帧&lt;/td&gt;
&lt;td&gt;标明总数据帧为80000帧的总数帧S604080000F3&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'7'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x32&lt;/td&gt;
&lt;td&gt;含32bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x10000000的帧S70510000000EA&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'8'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x24&lt;/td&gt;
&lt;td&gt;含24bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x100000的帧S804100000EB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'9'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x16&lt;/td&gt;
&lt;td&gt;含16bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x0000的帧S9030000FC&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h4 id=&quot;解析s-record文件&quot;&gt;3.3 解析S-Record文件&lt;/h4&gt;
&lt;p&gt;　　在了解S-Record文件帧数据格式之后，让我们开始尝试解析demo.s19文件(仅截取前后部分，与前面截取的bin文件内容对应着一起分析)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;S00B000064656D6F2E73313944
S11300000020001041000000DB180000CB190000A4
S113001000000000000000000000000000000000DC
S1130020000000000000000000000000071A0000AB
S113003000000000000000001D1A00001F1A00004C
S113004072B60E480E498860002200230024002561
....
S1131A300123002413E00A68091D1A4202D04D460E
S1131A406D1E52191460121D001F0428FAD21500CD
S1131A50860701D51480AD1C184000D02C7008688E
S1131A60091D0028E7D1080070BC7047C1FFFFFFC3
S10F1A7008020000142000100000000018
S9030041BB&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　S-Record文件第一帧是文件起始帧，帧数据64656D6F2E733139对应ASCII为demo.s19，即该文件名。&lt;br/&gt;　　第2-6帧均为16bit地址的数据帧，每帧包含16bytes机器码数据，帧数据地址分别为0x0000, 0x0010, 0x0020, 0x0030, 0x0040，可见帧数据是连续的，并且5帧机器码数据共80bytes与bin文件前80bytes是一致的。&lt;br/&gt;　　再来看最后6帧数据里的前5个数据帧，除最后一帧数据只包含12bytes数据外，其余数据帧均含有16bytes数据，5帧数据一共76bytes，帧数据地址从0x1A30 - 0x1A70。显然这与bin文件最后76bytes也是吻合的。&lt;br/&gt;　　倒数第一帧是起始程序地址帧，其标明的程序起始PC是0x0041，这与bin文件里第二个32bit数据（起始PC）是一致的。&lt;/p&gt;
&lt;h3 id=&quot;番外一一些image文件辅助小工具&quot;&gt;番外一、一些image文件辅助小工具&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;SRecordizer：专用S19文件编辑器，可根据修改自动更新checksum，详见网页https:&lt;span class=&quot;co&quot;&gt;//srecordizer.codeplex.com/&lt;/span&gt;
SRecord项目：各种image文件格式互转的小工具合集，详见网页http:&lt;span class=&quot;co&quot;&gt;//srecord.sourceforge.net/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，嵌入式开发里的image文件(.bin, .hex, .s19)文件豹哥便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 13:34:00 +0000</pubDate>
<dc:creator>Jay豹哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/8361693.html</dc:identifier>
</item>
<item>
<title>kafka和storm集群的环境安装 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8361629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8361629.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;storm和kafka集群安装是没有必然联系的，我将这两个写在一起，是因为他们都是由zookeeper进行管理的，也都依赖于JDK的环境，为了不重复再写一遍配置，所以我将这两个写在一起。若只需一个，只需挑选自己选择的阅读即可。&lt;/p&gt;
&lt;p&gt;这两者的依赖如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Storm集群&lt;/strong&gt;：JDK1.8 , Zookeeper3.4，Storm1.1.1；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafa集群&lt;/strong&gt; : JDK1.8 ，Zookeeper3.4 ，Kafka2.12；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;: Storm1.0 和Kafka2.0对JDK要求是1.7以上，Zookeeper3.0以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载地址:&lt;/strong&gt;&lt;br/&gt;Zookeeper：&lt;a href=&quot;https://zookeeper.apache.org/releases.html#download&quot; class=&quot;uri&quot;&gt;https://zookeeper.apache.org/releases.html#download&lt;/a&gt;&lt;br/&gt;Storm: &lt;a href=&quot;http://storm.apache.org/downloads.html&quot; class=&quot;uri&quot;&gt;http://storm.apache.org/downloads.html&lt;/a&gt;&lt;br/&gt;Kafka: &lt;a href=&quot;http://kafka.apache.org/downloads&quot; class=&quot;uri&quot;&gt;http://kafka.apache.org/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;jdk安装&quot;&gt;JDK安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每台机器都要安装JDK！！！&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;: 一般CentOS自带了openjdk，但是我们这里使用的是oracle的JDK。所以要写卸载openjdk，然后再安装在oracle下载好的JDK。如果已经卸载，可以跳过此步骤。&lt;br/&gt;首先输入 java -version&lt;br/&gt;查看是否安装了JDK，如果安装了，但版本不适合的话，就卸载&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230151037761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;br/&gt;rpm -qa | grep java&lt;br/&gt;查看信息&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230151047319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;然后输入:&lt;br/&gt;rpm -e --nodeps “你要卸载JDK的信息”&lt;br/&gt;如: rpm -e --nodeps java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230151054538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认没有了之后，解压下载下来的JDK&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar  -xvf   jdk-8u144-linux-x64.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移动到opt/java文件夹中，没有就新建，然后将文件夹重命名为jdk1.8。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv  jdk1.8.0_144 /opt/java
mv  jdk1.8.0_144  jdk1.8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编辑 profile 文件，添加如下配置&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/opt/java/jdk1.8
export JRE_HOME=/opt/java/jdk1.8/jre
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export PATH=.:${JAVA_HOME}/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加成功之后，输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source /etc/profile
java  -version &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看是否配置成功&lt;/p&gt;
&lt;h2 id=&quot;zookeeper-环境安装&quot;&gt;Zookeeper 环境安装&lt;/h2&gt;
&lt;h3 id=&quot;文件准备&quot;&gt;1，文件准备&lt;/h3&gt;
&lt;p&gt;将下载下来的Zookeeper 的配置文件进行解压&lt;br/&gt;在linux上输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; tar  -xvf   zookeeper-3.4.10.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/zookeeper里面，没有就新建，然后将文件夹重命名为zookeeper3.4&lt;br/&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv  zookeeper-3.4.10  /opt/zookeeper
mv  zookeeper-3.4.10  zookeeper3.4&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境配置&quot;&gt;2，环境配置&lt;/h3&gt;
&lt;p&gt;编辑 /etc/profile 文件&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export  ZK_HOME=/opt/zookeeper/zookeeper3.4 
export PATH=.:${JAVA_HOME}/bin:${ZK_HOME}/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source  /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使配置生效&lt;/p&gt;
&lt;h3 id=&quot;修改配置文件&quot;&gt;3，修改配置文件&lt;/h3&gt;
&lt;h4 id=&quot;创建文件和目录&quot;&gt;3.3.1 创建文件和目录&lt;/h4&gt;
&lt;p&gt;在集群的服务器上都创建这些目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir   /opt/zookeeper/data  
mkdir   /opt/zookeeper/dataLog&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且在/opt/zookeeper/data目录下创建myid文件&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;touch  myid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功之后，更改myid文件。&lt;br/&gt;我这边为了方便，将master、slave1、slave2的myid文件内容改为1,2,3&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230152536678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;新建zoo.cfg&quot;&gt;3.3.2 新建zoo.cfg&lt;/h4&gt;
&lt;p&gt;切换到/opt/zookeeper/zookeeper3.4/conf 目录下&lt;br/&gt;如果没有 zoo.cfg 该文件，就复制zoo_sample.cfg文件并重命名为zoo.cfg。&lt;br/&gt;修改这个新建的zoo.cfg文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataDir=/opt/zookeeper/data
dataLogDir=/opt/zookeeper/dataLog
server.1=master:2888:3888
server.2=slave1:2888:3888
server.3=slave2:2888:3888&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230152800716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：client port，顾名思义，就是客户端连接zookeeper服务的端口。这是一个TCP port。dataLogDir里是放到的顺序日志(WAL)。而dataDir里放的是内存数据结构的snapshot，便于快速恢复。为了达到性能最大化，一般建议把dataDir和dataLogDir分到不同的磁盘上，这样就可以充分利用磁盘顺序写的特性。dataDir和dataLogDir需要自己创建，目录可以自己制定，对应即可。server.1中的这个1需要和master这个机器上的dataDir目录中的myid文件中的数值对应。server.2中的这个2需要和slave1这个机器上的dataDir目录中的myid文件中的数值对应。server.3中的这个3需要和slave2这个机器上的dataDir目录中的myid文件中的数值对应。当然，数值你可以随便用，只要对应即可。2888和3888的端口号也可以随便用，因为在不同机器上，用成一样也无所谓。&lt;br/&gt;1.tickTime：CS通信心跳数&lt;br/&gt;Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。&lt;br/&gt;tickTime=2000&lt;br/&gt;2.initLimit：LF初始通信时限&lt;br/&gt;集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。&lt;br/&gt;initLimit=10&lt;br/&gt;3.syncLimit：LF同步通信时限&lt;br/&gt;集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。&lt;br/&gt;syncLimit=5&lt;/p&gt;
&lt;p&gt;依旧将zookeeper传输到其他的机器上，记得更改 /opt/zookeeper/data 下的myid，这个不能一致。&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scp -r /opt/zookeeper root@slave1:/opt
scp -r /opt/zookeeper root@slave2:/opt&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动zookeeper&quot;&gt;4，启动zookeeper&lt;/h3&gt;
&lt;p&gt;因为zookeeper是选举制，它的主从关系并不是像hadoop那样指定的，具体可以看官方的文档说明。&lt;br/&gt;成功配置zookeeper之后，在每台机器上启动zookeeper。&lt;br/&gt;切换到zookeeper目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/zookeeper/zookeeper3.4/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功启动之后&lt;br/&gt;查看状态输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; zkServer.sh status&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查看各个机器上zookeeper的leader和follower&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230152823369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;storm-环境安装&quot;&gt;Storm 环境安装&lt;/h2&gt;
&lt;h3 id=&quot;文件准备-1&quot;&gt;1，文件准备&lt;/h3&gt;
&lt;p&gt;将下载下来的storm的配置文件进行解压&lt;br/&gt;在linux上输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; tar  -xvf   apache-storm-1.1.1.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/storm里面，没有就新建，然后将文件夹重命名为storm1.1&lt;br/&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv  apache-storm-1.1.1  /opt/storm
 mv  apache-storm-1.1.1  storm1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境配置-1&quot;&gt;2，环境配置&lt;/h3&gt;
&lt;p&gt;编辑 /etc/profile 文件&lt;br/&gt;添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export STORM_HOME=/opt/storm/storm1.1
export PATH=.:${JAVA_HOME}/bin:${ZK_HOME}/bin:${STORM_HOME}/bin:$PATH   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入 storm version 查看版本信息&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126203955725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改配置文件-1&quot;&gt;3，修改配置文件&lt;/h3&gt;
&lt;p&gt;编辑 storm/conf 的 storm.yarm。&lt;/p&gt;
&lt;p&gt;进行如下编辑:&lt;br/&gt;输入:&lt;br/&gt;vim storm.yarm&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storm.zookeeper.servers:
     - &quot;master&quot;
     - &quot;slave1&quot;
     - &quot;slave2&quot;

storm.local.dir: &quot;/root/storm&quot;

nimbus.seeds: [&quot;master&quot;]

supervisor.slots.ports:
    - 6700
    - 6701
    - 6702
    - 6703&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126204334259?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;storm.zookeeper.servers是指定zookeeper的服务地址。&lt;br/&gt;因为storm的存储信息在zookeeper上，所以要配置zookeeper的服务地址。如果zookeeper是单机就只用指定一个！&lt;/li&gt;
&lt;li&gt;storm.local.dir 表示存储目录。&lt;br/&gt;Nimbus和Supervisor守护进程需要在本地磁盘上存储一个目录来存储少量的状态（比如jar，confs等等）。可以在每台机器创建，并给于权限。&lt;br/&gt;3.nimbus.seeds 表示候选的主机。&lt;br/&gt;worker需要知道那一台机器是主机候选(zookeeper集群是选举制)，从而可以下载 topology jars 和confs。&lt;br/&gt;4.supervisor.slots.ports 表示worker 端口。&lt;br/&gt;对于每一个supervisor机器，我们可以通过这项来配置运行多少worker在这台机器上。每一个worker使用一个单独的port来接受消息，这个端口同样定义了那些端口是开放使用的。如果你在这里定义了5个端口，就意味着这个supervisor节点上最多可以运行5个worker。如果定义3个端口，则意味着最多可以运行3个worker。在默认情况下(即配置在defaults.yaml中)，会有有四个workers运行在 6700, 6701, 6702, and 6703端口。&lt;br/&gt;supervisor并不会在启动时就立即启动这四个worker。而是接受到分配的任务时，才会启动，具体启动几个worker也要根据我们Topology在这个supervisor需要几个worker来确定。如果指定Topology只会由一个worker执行，那么supervisor就启动一个worker，并不会启动所有。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 这些配置前面不要有空格！！！，不然会报错。 这里使用的是主机名(做了映射)，也可以使用IP。实际的以自己的为准。&lt;/p&gt;
&lt;p&gt;可以使用scp命令或者ftp软件将storm复制到其他机器上&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126204325034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功配置之后，然后就可以启动Storm了，不过要确保JDK、Zookeeper已经正确安装，并且Zookeeper已经成功启动。&lt;/p&gt;
&lt;h3 id=&quot;启动storm&quot;&gt;4，启动Storm&lt;/h3&gt;
&lt;p&gt;切换到 storm/bin 目录下&lt;br/&gt;在主节点(master)启动输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storm nimbus &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问web界面(master)输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storm ui &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从节点(slave1，slave2)输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storm supervisor &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在浏览器界面输入: 8080端口&lt;br/&gt;成功打开该界面，表示环境配置成功:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126204703636?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;kafka的环境安装&quot;&gt;kafka的环境安装&lt;/h2&gt;
&lt;h3 id=&quot;文件准备-2&quot;&gt;1，文件准备&lt;/h3&gt;
&lt;p&gt;将下载下来的Kafka的配置文件进行解压&lt;br/&gt;在linux上输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; tar  -xvf   kafka_2.12-1.0.0.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/kafka里面，没有就新建，然后将文件夹重命名为kafka2.12&lt;br/&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv  kafka_2.12-1.0.0  /opt/kafka
 mv  kafka_2.12-1.0.0  kafka2.12&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境配置-2&quot;&gt;2，环境配置&lt;/h3&gt;
&lt;p&gt;编辑 /etc/profile 文件&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export  KAFKA_HOME=/opt/kafka/kafka2.12 
export PATH=.:${JAVA_HOME}/bin:${KAFKA_HOME}/bin:${ZK_HOME}/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source  /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使配置生效&lt;/p&gt;
&lt;h3 id=&quot;修改配置文件-2&quot;&gt;3，修改配置文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:其实要说的话，如果是单机的话，kafka的配置文件可以不用修改，直接到bin目录下启动就可以了。但是我们这里是集群，所以稍微改下就可以了。&lt;/p&gt;
&lt;p&gt;切换到kafka/config 目录下&lt;br/&gt;编辑&lt;strong&gt;server.properties&lt;/strong&gt; 文件&lt;br/&gt;需要更改的是Zookeeper的地址:&lt;br/&gt;找到Zookeeper的配置，指定Zookeeper集群的地址，设置如下修改就可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zookeeper.connect=master:2181,slave1:2181,slave2:2181
zookeeper.connection.timeout.ms=6000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它可以选择更改的有&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 ，num.partitions 表示指定的分区，默认为1&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2，log.dirs kafka的日志路径，这个按照个人需求更改就行&lt;/strong&gt;&lt;br/&gt;...&lt;br/&gt;&lt;strong&gt;注&lt;/strong&gt;:还有其它的配置，可以查看官方文档，如果没有特别要求，使用默认的就可以了。&lt;/p&gt;
&lt;p&gt;配置好之后，记得使用scp 命令传输到其它的集群上！&lt;/p&gt;
&lt;h3 id=&quot;启动kafka&quot;&gt;4，启动kafka&lt;/h3&gt;
&lt;p&gt;集群每台集群都需要操作！&lt;/p&gt;
&lt;p&gt;切换到kafka/bin 目录下&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-server-start.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后输入jps名称查看是否成功启动:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126205434422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功启动之后，可以进行简单的测试下&lt;br/&gt;首先创建个topic&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-topics.sh --zookeeper master:2181 --create --topic t_test --partitions 5  --replication-factor 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 这里是创建了一个名为 t_test 的topic，并且指定了5个分区，每个分区指定了2个副本数。如果不指定分区，默认的分区就是配置文件配置的。&lt;/p&gt;
&lt;p&gt;然后进行生产数据&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-console-producer.sh --broker-list master:9092 --topic t_test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126210106287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用进行Ctrl+D 退出&lt;/p&gt;
&lt;p&gt;然后我们再打开一个xshell窗口&lt;br/&gt;进行消费&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-console-consumer.sh  --zookeeper master:2181  --topic t_test --from-beginning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180126210233242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;可以使用进行Ctrl+C 退出&lt;/p&gt;
&lt;p&gt;可以看到数据已经正常消费了。&lt;/p&gt;
&lt;h3 id=&quot;kafka的一些常用命令&quot;&gt;5，kafka的一些常用命令&lt;/h3&gt;
&lt;p&gt;1.启动和关闭kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-server-start.sh config/server.properties &amp;gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
bin/kafka-server-stop.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看kafka集群中的消息队列和具体队列&lt;br/&gt;查看集群所有的topic&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; kafka-topics.sh --zookeeper master:2181,slave1:2181,slave2:2181 --list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看一个topic的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; kafka-topics.sh --zookeeper master:2181 --describe --topic t_test  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.创建Topic&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-topics.sh --zookeeper master:2181 --create --topic t_test --partitions 5  --replication-factor 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.生产数据和消费数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-console-producer.sh --broker-list master:9092 --topic t_test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ctrl+D 退出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-console-consumer.sh  --zookeeper master:2181  --topic t_test --from-beginning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ctrl+C 退出&lt;/p&gt;
&lt;p&gt;5.kafka的删除命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-topics.sh --delete --zookeeper master:2181 --topic t_test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6,添加分区&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka-topics.sh --alter --topict_test --zookeeper master:2181 --partitions 10&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;Storm环境搭建参考官方文档:&lt;br/&gt;&lt;a href=&quot;http://storm.apache.org/releases/1.1.1/Setting-up-a-Storm-cluster.html&quot; class=&quot;uri&quot;&gt;http://storm.apache.org/releases/1.1.1/Setting-up-a-Storm-cluster.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kafka环境搭建参考官方文档:&lt;br/&gt;&lt;a href=&quot;http://kafka.apache.org/quickstart&quot; class=&quot;uri&quot;&gt;http://kafka.apache.org/quickstart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到此，本文结束，谢谢阅读！&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 13:09:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8361629.html</dc:identifier>
</item>
<item>
<title>ASP.NET网络爬虫小研究 HtmlAgilityPack基础，爬取数据保存在数据库中再显示再自己的网页中 - 魏杨杨</title>
<link>http://www.cnblogs.com/w5942066/p/8361585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w5942066/p/8361585.html</guid>
<description>&lt;h2&gt;1、什么是网络爬虫&lt;/h2&gt;
&lt;p&gt;  关于爬虫百度百科这样定义的：网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。从搜索引擎开始，爬虫应该就出现了，爬虫所做的事情就是分析URL、下载WebServer返回的HTML、分析HTML内容、构建HTTP请求的模拟、在爬虫过程中存储有用的信息等等。简单点说，就是把别人网站上的东西爬下来，至于爬做什么用就看你自己了。&lt;/p&gt;
&lt;p&gt;  写网络爬虫很多语言都可以写，比如众所周知的Python以及、PHP、C、Java等等。今天我就基于.Net中的HtmlAgilityPack类写一个简单的爬虫。&lt;/p&gt;

&lt;h2&gt;2、HtmlAgilityPack类&lt;/h2&gt;
&lt;p&gt;  HtmlAgilityPack 是 .NET 下的一个 HTML 解析类库。支持用 XPath 来解析 HTML 。命名空间： HtmlAgilityPack，下载地址：http://htmlagilitypack.codeplex.com/releases/view/90925&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126201036084-1278012833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.1基本属性&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Attributes 　　　　　　　　　　　　获取节点的属性集合&lt;br/&gt;ChildNodes　　　　　　　　　　　　获取子节点集合(包括文本节点)&lt;br/&gt;Closed　　　　　　　　　　　　　　该节点是否已关闭(&amp;lt;/xxx&amp;gt;)&lt;br/&gt;ClosingAttributes　　　　　　　　 在关闭标签的属性集合&lt;br/&gt;FirstChild　　　　　　　　　　　　 获取第一个子节点&lt;br/&gt;HasAttributes　　　　　　　　　　 判断该节点是否含有属性&lt;br/&gt;HasChildNodes　　　　　　　　　　判断该节点是否含有子节点&lt;br/&gt;HasClosingAttributes　　　　　　 判断该节点的关闭标签是否含有属性(&amp;lt;/xxx class=&quot;xxx&quot;&amp;gt;)&lt;br/&gt;Id　　　　　　　　　　　　　　　　 获取该节点的Id属性&lt;br/&gt;InnerHtml　　　　　　　　　　　　 获取该节点的Html代码&lt;br/&gt;InnerText　　　　　　　　　　　　 获取该节点的内容，与InnerHtml不同的地方在于它会过滤掉Html代码，而InnerHtml是连Html代码一起输出&lt;br/&gt;LastChild　　　　　　　　　　　　 获取最后一个子节点&lt;br/&gt;Line　　　　　　　　　　　　　　　 获取该节点的开始标签或开始代码位于整个HTML源代码的第几行(行号)&lt;br/&gt;LinePosition　　　　　　　　　　　 获取该节点位于第几列&lt;br/&gt;Name　　　　　　　　　　　　　　 Html元素名&lt;br/&gt;NextSibling　　　　　　　　　　　　获取下一个兄弟节点&lt;br/&gt;NodeType　　　　　　　　　　　　 获取该节点的节点类型&lt;br/&gt;OriginalName　　　　　　　　　　　获取原始的未经更改的元素名&lt;br/&gt;OuterHtml　　　　　　　　　　　　 整个节点的代码&lt;br/&gt;OwnerDocument　　　　　　　　　节点所在的HtmlDocument文档&lt;br/&gt;ParentNode　　　　　　　　　　　　获取该节点的父节点&lt;br/&gt;PreviousSibling　　　　　　　　　　获取前一个兄弟节点&lt;br/&gt;StreamPosition　　　　　　　　　　该节点位于整个Html文档的字符位置&lt;br/&gt;XPath　　　　　　　　　　　　　　 根据节点返回该节点的XPath&lt;/p&gt;
&lt;h3&gt;2.2方法&lt;/h3&gt;

&lt;p&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; Ancestors(); 　　　　　　　　　　　　　　返回此元素的所有上级节点的集合。&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; Ancestors(string name); 　　　　 　　　  返回此元素参数名字匹配的所有上级节点的集合。&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; AncestorsAndSelf(); 　　　　　　 　　　　返回此元素的所有上级节点和自身的集合。&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; AncestorsAndSelf(string name); 　　　　 返回此元素的名字匹配的所有上级节点和自身的集合。&lt;br/&gt;HtmlNode AppendChild(HtmlNode newChild); 　　　　　　 　　　　  将参数元素追加到为调用元素的子元素(追加在最后)&lt;br/&gt;void AppendChildren(HtmlNodeCollection newChildren);　　　　　　 将参数集合中的元素追加为调用元素的子元素(追加在最后)&lt;br/&gt;HtmlNode PrependChild(HtmlNode newChild); 　　　　　　　　　　   将参数中的元素作为子元素，放在调用元素的最前面&lt;br/&gt;void PrependChildren(HtmlNodeCollection newChildren); 　　　　　　将参数集合中的所有元素作为子元素，放在调用元素前面&lt;br/&gt;static bool CanOverlapElement(string name); 　　　　　　　　　　　 确定是否可以保存重复的元素&lt;br/&gt;IEnumerable&amp;lt;HtmlAttribute&amp;gt; ChildAttributes(string name); 　　　　获取所有子元素的属性(参数名要与元素名匹配)&lt;br/&gt;HtmlNode Clone(); 　　　　　　　　　　　　　　　　　　　　　　　　 本节点克隆到一个新的节点&lt;br/&gt;HtmlNode CloneNode(bool deep); 　　　　　　　　　　　　　　　　　节点克隆到一个新的几点，参数确定是否连子元素一起克隆&lt;br/&gt;HtmlNode CloneNode(string newName); 　　　　　　　　　　　　　　克隆的同时更改元素名&lt;br/&gt;HtmlNode CloneNode(string newName, bool deep);　　　　　　　　  克隆的同时更改元素名。参数确定是否连子元素一起克隆&lt;br/&gt;void CopyFrom(HtmlNode node); 　　　　　　　　　　　　　　　　　 创建重复的节点和其下的子树。&lt;br/&gt;void CopyFrom(HtmlNode node, bool deep); 　　　　　　　　　　　 创建节点的副本。&lt;br/&gt;XPathNavigator CreateNavigator(); 　　　　　　　　　　　　　　　　 返回的一个对于此文档的XPathNavigator &lt;br/&gt;static HtmlNode CreateNode(string html); 　　　　　　　　　　　　  静态方法，允许用字符串创建一个新节点&lt;br/&gt;XPathNavigator CreateRootNavigator(); 　　　　　　　　　　　　　　创建一个根路径的XPathNavigator &lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; DescendantNodes(); 　　　　　　　　　　 获取所有子代节点&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; DescendantNodesAndSelf(); 　　　　　　 获取所有的子代节点以及自身&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; Descendants(); 　　　　　　　　　　　　　获取枚举列表中的所有子代节点&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; Descendants(string name); 　　　　　　　获取枚举列表中的所有子代节点，注意元素名要与参数匹配&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; DescendantsAndSelf(); 　　　　　　　　　获取枚举列表中的所有子代节点以及自身&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; DescendantsAndSelf(string name);　　　 获取枚举列表中的所有子代节点以及自身，注意元素名要与参数匹配&lt;br/&gt;HtmlNode Element(string name); 　　　　　　　　　　　　　　　　　 根据参数名获取一个元素&lt;br/&gt;IEnumerable&amp;lt;HtmlNode&amp;gt; Elements(string name); 　　　　　　　　　根据参数名获取匹配的元素集合&lt;br/&gt;bool GetAttributeValue(string name, bool def); 　　　　　　　　　　 帮助方法，用来获取此节点的属性的值(布尔类型)。如果未找到该属性，则将返回默认值。&lt;br/&gt;int GetAttributeValue(string name, int def); 　　　　　　　　　　　　 帮助方法，用来获取此节点的属性的值(整型)。如果未找到该属性，则将返回默认值。&lt;br/&gt;string GetAttributeValue(string name, string def); 　　　　　　　　　帮助方法，用来获取此节点的属性的值(字符串类型)。如果未找到该属性，则将返回默认值。&lt;br/&gt;HtmlNode InsertAfter(HtmlNode newChild, HtmlNode refChild); 　　  将一个节点插入到第二个参数节点的后面，与第二个参数是兄弟关系&lt;br/&gt;HtmlNode InsertBefore(HtmlNode newChild, HtmlNode refChild); 　　讲一个节点插入到第二个参数节点的后面，与第二个参数是兄弟关系&lt;br/&gt;static bool IsCDataElement(string name); 　　　　　　　　　　　　　 确定是否一个元素节点是一个 CDATA 元素节点。&lt;br/&gt;static bool IsClosedElement(string name); 　　　　　　　　　　　　　确定是否封闭的元素节点&lt;br/&gt;static bool IsEmptyElement(string name); 　　　　　　　　　　　　   确定是否一个空的元素节点。&lt;br/&gt;static bool IsOverlappedClosingElement(string text); 　　　　　　　  确定是否文本对应于一个节点可以保留重叠的结束标记。&lt;br/&gt;void Remove(); 　　　　　　　　　　　　　　　　　　　　　　　　　　 从父集合中移除调用节点&lt;br/&gt;void RemoveAll(); 　　　　　　　　　　　　　　　　　　　　　　　　　 移除调用节点的所有子节点以及属性&lt;br/&gt;void RemoveAllChildren(); 　　　　　　　　　　　　　　　　　　　　　 移除调用节点的所有子节点&lt;br/&gt;HtmlNode RemoveChild(HtmlNode oldChild); 　　　　　　　　　　　　 移除调用节点的指定名字的子节点&lt;br/&gt;HtmlNode RemoveChild(HtmlNode oldChild, bool keepGrandChildren);移除调用节点调用名字的子节点，第二个参数确定是否连孙子节点一起移除&lt;br/&gt;HtmlNode ReplaceChild(HtmlNode newChild, HtmlNode oldChild);　　 将调用节点原有的一个子节点替换为一个新的节点，第二个参数是旧节点&lt;br/&gt;HtmlNodeCollection SelectNodes(string xpath);　　　　　　　　　　　根据XPath获取一个节点集合&lt;br/&gt;HtmlNode SelectSingleNode(string xpath); 　　　　　　　　　　　　　根据XPath获取唯一的一个节点&lt;br/&gt;HtmlAttribute SetAttributeValue(string name, string value); 　　　　 设置调用节点的属性&lt;br/&gt;string WriteContentTo(); 　　　　　　　　　　　　　　　　　　　　　  将该节点的所有子级都保存到一个字符串中。&lt;br/&gt;void WriteContentTo(TextWriter outText); 　　　　　　　　　　　　　将该节点的所有子级都保存到指定的 TextWriter。&lt;br/&gt;string WriteTo(); 　　　　　　　　　　　　　　　　　　　　　　　　　　将当前节点保存到一个字符串中。&lt;br/&gt;void WriteTo(TextWriter outText); 　　　　　　　　　　　　　　　　　将当前节点保存到指定的 TextWriter。&lt;br/&gt;void WriteTo(XmlWriter writer);&lt;/p&gt;

&lt;h2&gt;3、第一个爬虫程序&lt;/h2&gt;
&lt;h3&gt;3.1在VS2017中建立一个web项目拖个服务器控件按钮上去（我VS是用2017的）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126201157537-545966555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;3.2后台代码及解释&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客园精华单机按钮
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btntwo_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
            {
               

                SqlDB sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlDB();
                HtmlWeb wb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWeb();
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; webaddress= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    webaddress&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/pick/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为啥http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/pick/#p10进去还是第一页&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; webbbb =&lt;span&gt; GetHTML(webaddress);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    webaddress &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/pick/{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;i.ToString()).ToString());
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; webbbb =&lt;span&gt; GetHTML(webaddress);
                }
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    HtmlDocument doc &lt;/span&gt;=&lt;span&gt; wb.Load(webaddress);
               
                HtmlNode node &lt;/span&gt;= doc.GetElementbyId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (HtmlNode hnode &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node.ChildNodes)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hnode.Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;null&lt;/span&gt; || hnode.Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post_item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        HtmlNode hn &lt;/span&gt;=&lt;span&gt; HtmlNode.CreateNode(hnode.OuterHtml);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;推荐&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; recommend = Convert.ToInt32((hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;diggnum\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText).Trim());
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; title = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网址&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; webhref = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Value.ToString();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;介绍&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; introduce = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_summary\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; articletimetest = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_foot\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发表时间（陈树义  发布于 2017 - 11 - 15 10:13  评论(41)阅读(7372)&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; articletime = ((hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_foot\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText).Trim()).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割字符串&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt;[] st = articletime.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出（发布于 2017 - 11 - 15 10:13）&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; pp = (st[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].ToString()).Trim();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割字符串&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt;[] qq = pp.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出（2017/11/15 10 :13）&lt;/span&gt;
                        DateTime gg = Convert.ToDateTime(qq[&lt;span&gt;1&lt;/span&gt;].ToString() + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + qq[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].ToString());
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;insert into CnblogsList( Recommend, Title,Contents, Introduce, WebHref, ArticleTime) values({0},'{1}','{2}','{3}','{4}','{5}')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, recommend, title, GetContentsString(webhref), introduce, webhref, gg);
                            sb.ExecuteNonQuery(sql);
                            sum&lt;/span&gt;++&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                        {
                            Response.Write(ex.Message);
                        }

                            Response.Write(GetContentsString(webhref)&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;hr /&amp;gt; &amp;lt;hr /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 陈树义  发布于 2017 - 11 - 15 10:13  评论(41)阅读(7372)&lt;/span&gt;
                        Response.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;推荐：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;diggnum\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                         Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;标题：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;标题对应的网址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value.ToString()) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                         Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;介绍：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_summary\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                         Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_foot\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&amp;lt;hr /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;节点为空  +++++  出错节点Iiiii是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;  网址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + webaddress.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;  插入数据：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ sum +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception esz)
                {
                    Response.Write(esz.Message);
                }
&lt;/span&gt;&lt;span&gt;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是获取网页源码的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取网页源码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetHTML(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
        {
            WebClient web &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();
            web.Encoding &lt;/span&gt;=&lt;span&gt; Encoding.UTF8;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;  buffer =&lt;span&gt; web.DownloadString(url);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的for循环目的是获取精华区后面页数的内容，但是效果并不是这样的&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126202152209-668472455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我早谷歌上F12调试发现并不是这样的额  请求地址不对。为以为在后面加?PageIndex= XX就可以实现  还是不可以 因为这是经过处理的，在Header上面有地址https://www.cnblogs.com/mvc/AggSite/PostList.aspx你们仔细就可以看到。这样做了如果页数写多了就会重复出现第一页的内容 数据库中是保存的  数据库的表结构我上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126202642272-851544313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;我一弄才发现原来这个地址是博客园里面的内容时刻更新的。经过处理取出精华区的。一次去可以取出2天的内容  不管是发布在博客园首页的还是没有发布在首页的都有。我就爬虫爬了一次 试试看 这是第二个按钮的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客园数据最近大约2天
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BtnNowTowDay_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;200&lt;/span&gt;; i++&lt;span&gt;)
            {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是SqlDB类&lt;/span&gt;
                SqlDB sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlDB();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例HtmlWdb&lt;/span&gt;
                HtmlWeb wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWeb();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网址&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; webaddress = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                    webaddress &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/mvc/AggSite/PostList.aspx?PageIndex={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, +&lt;span&gt; i);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网页源码 有html的&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; webbbb =&lt;span&gt; GetHTML(webaddress);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    HtmlDocument doc &lt;/span&gt;=&lt;span&gt; wb.Load(webaddress);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取div[@class='post_item的上级目录
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个可以根据节点 ID选择 建议多看一下Xpath 就好理解了&lt;/span&gt;
                    HtmlNode node = doc.DocumentNode.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div[@class='post_item']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HtmlNode node = doc.GetElementbyId(&quot;#id&quot;);&lt;/span&gt;
                    
                    &lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (HtmlNode hnode &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node.ChildNodes)
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hnode.Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;null&lt;/span&gt; || hnode.Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Value != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post_item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                            HtmlNode hn &lt;/span&gt;=&lt;span&gt; HtmlNode.CreateNode(hnode.OuterHtml);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;推荐&lt;/span&gt;
                            &lt;span&gt;int&lt;/span&gt; recommend = Convert.ToInt32((hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;diggnum\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText).Trim());
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; title = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网址&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; webhref = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;titlelnk\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Attributes[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Value.ToString();
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;介绍&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; introduce = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_summary\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; articletimetest = hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_foot\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).InnerText;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发表时间（陈树义  发布于 2017 - 11 - 15 10:13  评论(41)阅读(7372)&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; articletime = ((hn.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@class=\&quot;post_item_foot\&quot;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).InnerText).Trim()).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割字符串&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt;[] st = articletime.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出（发布于 2017 - 11 - 15 10:13）&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt; pp = (st[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].ToString()).Trim();
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割字符串&lt;/span&gt;
                            &lt;span&gt;string&lt;/span&gt;[] qq = pp.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出（2017/11/15 10 :13）&lt;/span&gt;
                            DateTime gg = Convert.ToDateTime(qq[&lt;span&gt;1&lt;/span&gt;].ToString() + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + qq[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].ToString());
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                            {
                                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;insert into CnblogsList( Recommend, Title,Contents, Introduce, WebHref, ArticleTime) values({0},'{1}','{2}','{3}','{4}','{5}')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, recommend, title, GetContentsString(webhref), introduce, webhref, gg);
                                sb.ExecuteNonQuery(sql);
                                sum&lt;/span&gt;++&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                            {
                                Response.Write(ex.Message);
                            }
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Response.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;节点为空  +++++  出错节点Iiiii是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;  网址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + webaddress.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;  插入数据：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sum + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception esz)
                {
                    Response.Write(esz.Message);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是住区自己博客园的后台&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/// &amp;lt;summary&amp;gt;
        /// 抓取自己博客园的
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;
        protected void btnWY_Click(object sender, EventArgs e)
        {
            SqlDB sb = new SqlDB();
            HtmlWeb wh = new HtmlWeb();
            HtmlDocument doc = wh.Load(&quot;http://www.cnblogs.com/w5942066/&quot;);
            HtmlNode node = doc.DocumentNode.SelectSingleNode(&quot;//div[@class='day']&quot;).SelectSingleNode(&quot;..&quot;);
            if(node !=null)
            {
                foreach(HtmlNode hn in node.ChildNodes)
                {
                    if(hn.Attributes[&quot;class&quot;] == null || hn.Attributes[&quot;class&quot;].Value!=&quot;day&quot;)
                    {
                        continue;
                    }
                    HtmlNode hnn = HtmlNode.CreateNode(hn.OuterHtml);
                    //shijian
                    string  recommend = hnn.SelectSingleNode(&quot;//*[@class=\&quot;dayTitle\&quot;]&quot;).InnerText;
                    //标题
                    string title = hnn.SelectSingleNode(&quot;//*[@class=\&quot;postTitle\&quot;]&quot;).InnerText;
                    //网址
                    string webhref = hnn.SelectSingleNode(&quot;//*[@class=\&quot;postTitle2\&quot;]&quot;).Attributes[&quot;href&quot;].Value.ToString();
                    //介绍
                    string introduce = hnn.SelectSingleNode(&quot;//*[@class=\&quot;c_b_p_desc\&quot;]&quot;).InnerText;
                    //时间
                    //  string articletimetest = hn.SelectSingleNode(&quot;//*[@class=\&quot;postDesc\&quot;]&quot;).InnerText;
                    //发表时间（陈树义  发布于 2017 - 11 - 15 10:13  评论(41)阅读(7372)
                    // string articletime = ((hn.SelectSingleNode(&quot;//*[@class=\&quot;postDesc\&quot;]&quot;).InnerText).Trim()).Replace(&quot;\r\n&quot;, &quot;+&quot;);
                    //分割字符串
                    //string[] st = articletime.Split('+');
                    //取出（发布于 2017 - 11 - 15 10:13）
                    //string pp = (st[1].ToString()).Trim();
                    //分割字符串
                    //string[] qq = pp.Split(' ');
                    //取出（2017/11/15 10 :13）
                    DateTimeFormatInfo dtFormat = new DateTimeFormatInfo();
                    dtFormat.ShortDatePattern = &quot;yyyy年MM月dd日&quot;;
                    DateTime dt = Convert.ToDateTime(recommend, dtFormat);
                    try
                    {
                        string sql = string.Format(@&quot;insert into CnblogsList( Recommend, Title,Contents, Introduce, WebHref, ArticleTime) values({0},'{1}','{2}','{3}','{4}','{5}')&quot;, 520, title, GetContentsString(webhref), introduce, webhref, dt);
                        sb.ExecuteNonQuery(sql);
                    }
                    catch (Exception ex)
                    {
                        Response.Write(ex.Message);
                    }

                }
            }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.3列表显示出来&lt;/h3&gt;
&lt;p&gt;这里我用的是一个原始的GridView前台页面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;form1&quot;&lt;/span&gt;&lt;span&gt; runat&lt;/span&gt;&lt;span&gt;=&quot;server&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height:35px;line-height:30px;text-align:center;padding-top:50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;博客园文章列表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:GridView &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;=&quot;gdMain&quot;&lt;/span&gt;&lt;span&gt;  runat&lt;/span&gt;&lt;span&gt;=&quot;server&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;100%&quot;&lt;/span&gt;&lt;span&gt; AllowPaging&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; AutoGenerateColumns&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; DataKeyNames&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; DataSourceID&lt;/span&gt;&lt;span&gt;=&quot;SqlDataSource1&quot;&lt;/span&gt;&lt;span&gt; CellPadding&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; ForeColor&lt;/span&gt;&lt;span&gt;=&quot;#333333&quot;&lt;/span&gt;&lt;span&gt; GridLines&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt; PageSize&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AlternatingRowStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:BoundField &lt;/span&gt;&lt;span&gt;HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;3%&quot;&lt;/span&gt;&lt;span&gt; ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;  DataField&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; HeaderText&lt;/span&gt;&lt;span&gt;=&quot;编号&quot;&lt;/span&gt;&lt;span&gt; InsertVisible&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; ReadOnly&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; SortExpression&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                    
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;10%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HeaderStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemStyle &lt;/span&gt;&lt;span&gt;HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:BoundField&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:BoundField &lt;/span&gt;&lt;span&gt;ItemStyle-Wrap&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;10%&quot;&lt;/span&gt;&lt;span&gt; ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; DataField&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt;&lt;span&gt; HeaderText&lt;/span&gt;&lt;span&gt;=&quot;标题&quot;&lt;/span&gt;&lt;span&gt; SortExpression&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;10%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HeaderStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemStyle &lt;/span&gt;&lt;span&gt;HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:BoundField&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:BoundField &lt;/span&gt;&lt;span&gt;ItemStyle-Wrap&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;  HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;30%&quot;&lt;/span&gt;&lt;span&gt;  ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt; DataField&lt;/span&gt;&lt;span&gt;=&quot;Contents&quot;&lt;/span&gt;&lt;span&gt; HeaderText&lt;/span&gt;&lt;span&gt;=&quot;内容&quot;&lt;/span&gt;&lt;span&gt; SortExpression&lt;/span&gt;&lt;span&gt;=&quot;Contents&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;30%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HeaderStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemStyle &lt;/span&gt;&lt;span&gt;HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:BoundField&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:BoundField &lt;/span&gt;&lt;span&gt;ItemStyle-Wrap&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;  HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;20%&quot;&lt;/span&gt;&lt;span&gt; ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;  DataField&lt;/span&gt;&lt;span&gt;=&quot;WebHref&quot;&lt;/span&gt;&lt;span&gt; HeaderText&lt;/span&gt;&lt;span&gt;=&quot;原文网址&quot;&lt;/span&gt;&lt;span&gt; SortExpression&lt;/span&gt;&lt;span&gt;=&quot;WebHref&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;20%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HeaderStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemStyle &lt;/span&gt;&lt;span&gt;HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:BoundField&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:BoundField  &lt;/span&gt;&lt;span&gt;ItemStyle-Wrap&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;  HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;10%&quot;&lt;/span&gt;&lt;span&gt;  ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; DataField&lt;/span&gt;&lt;span&gt;=&quot;ArticleTime&quot;&lt;/span&gt;&lt;span&gt; HeaderText&lt;/span&gt;&lt;span&gt;=&quot;时间&quot;&lt;/span&gt;&lt;span&gt; SortExpression&lt;/span&gt;&lt;span&gt;=&quot;ArticleTime&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;10%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HeaderStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemStyle &lt;/span&gt;&lt;span&gt;HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:BoundField&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:HyperLinkField &lt;/span&gt;&lt;span&gt;DataNavigateUrlFields&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; 
     DataNavigateUrlFormatString&lt;/span&gt;&lt;span&gt;=&quot;PageInfo.aspx?ID={0}&quot;&lt;/span&gt;&lt;span&gt; HeaderStyle-Width&lt;/span&gt;&lt;span&gt;=&quot;5%&quot;&lt;/span&gt;&lt;span&gt;  ItemStyle-HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;
     Text&lt;/span&gt;&lt;span&gt;=&quot;详细&quot;&lt;/span&gt;&lt;span&gt; DataTextFormatString&lt;/span&gt;&lt;span&gt;=&quot;详细&quot;&lt;/span&gt;&lt;span&gt;  Target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EditRowStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#2461BF&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FooterStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#507CD1&quot;&lt;/span&gt;&lt;span&gt; Font-Bold&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; ForeColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HeaderStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#507CD1&quot;&lt;/span&gt;&lt;span&gt; Font-Bold&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; ForeColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PagerSettings &lt;/span&gt;&lt;span&gt;PageButtonCount&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PagerStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#2461BF&quot;&lt;/span&gt;&lt;span&gt; ForeColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlign&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#EFF3FB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SelectedRowStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#D1DDF1&quot;&lt;/span&gt;&lt;span&gt; Font-Bold&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; ForeColor&lt;/span&gt;&lt;span&gt;=&quot;#333333&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SortedAscendingCellStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#F5F7FB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SortedAscendingHeaderStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#6D95E1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SortedDescendingCellStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#E9EBEF&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SortedDescendingHeaderStyle &lt;/span&gt;&lt;span&gt;BackColor&lt;/span&gt;&lt;span&gt;=&quot;#4870BE&quot;&lt;/span&gt;&lt;span&gt; Wrap&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:GridView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asp:SqlDataSource &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;=&quot;SqlDataSource1&quot;&lt;/span&gt;&lt;span&gt; runat&lt;/span&gt;&lt;span&gt;=&quot;server&quot;&lt;/span&gt;&lt;span&gt; ConnectionString&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;%$ ConnectionStrings:TestBaseConnectionString %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; SelectCommand&lt;/span&gt;&lt;span&gt;=&quot;select ID,SUBSTRING(Title,0,30)AS Title,SUBSTRING(Contents,0,30)AS Contents ,SUBSTRING(Webhref,0,20)AS WebHref , ArticleTime from CnblogsList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asp:SqlDataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后台部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NetCrawlerTest.Winfrom
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CnblogListData : System.Web.UI.Page
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Page_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if(!IsPostBack)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    GetData();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetData()
        {
            SqlDB sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlDB();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _Sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select ID,SUBSTRING(Title,0,50)AS Title,SUBSTRING(Contents,0,60)AS Contents ,SUBSTRING(Webhref,0,50)AS WebHref , ArticleTime from CnblogsList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                gdMain.DataSource &lt;/span&gt;= sb.ExecuteDataSet(_Sql).Tables[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                gdMain.DataBind();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126203842647-495075748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.4具体的博客显示&lt;/h3&gt;
&lt;p&gt;前台代码就是上面图片中的PageInfo页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;form1&quot;&lt;/span&gt;&lt;span&gt; runat&lt;/span&gt;&lt;span&gt;=&quot;server&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height:35px;line-height:30px;text-align:center; padding-top:50px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;GetTitle() &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;CnblogListData.aspx&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;返回列表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; 
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;PageInfo.aspx?ID=&amp;lt;%=UpIDS() %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:100px; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上一条&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; | &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;PageInfo.aspx?ID=&amp;lt;%=UpIDX() %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:100px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下一条&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:center;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;发表时间：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;GetTime() &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin:10px 10px 30px 10px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;GetContens() &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;%= GetWebhref() %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;原文链接：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; GetWebhref() &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align:right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;CnblogListData.aspx&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;返回列表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; 
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;PageInfo.aspx?ID=&amp;lt;%=UpIDS() %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:100px; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上一条&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; | &lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;PageInfo.aspx?ID=&amp;lt;%=UpIDX() %&amp;gt;&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:100px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;下一条&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div  &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height:50px;text-align:center;color:#fbe8e8;background-color:#000000;width:100%;line-height:50px;font-weight:600; position:fixed; border-bottom:2px #ffffff solid; bottom:0px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;行到水穷处，坐看云起时！转载声明：技术需要共享，欢迎转载！但请注明版权及出处！
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后台代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PageInfo : System.Web.UI.Page
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Page_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {

        }
        SqlDB sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlDB();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public int Sum = 0;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取标题
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetTitle()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT TITLE FROM CNBLOGSLIST WHERE ID={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString();
             
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 接收ID
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetID()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToInt32(Request.QueryString[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString());
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;时间&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetTime()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT ARTICLETIME FROM CNBLOGSLIST WHERE ID={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetContens()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT CONTENTS FROM CNBLOGSLIST WHERE ID={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;].ToString()).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;prime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取原网址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;网址&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetWebhref()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT WEBHREF FROM CNBLOGSLIST WHERE ID={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 上一条
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;上一条信息的ID&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; UpIDS()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT top 1 ID FROM CNBLOGSLIST AS n WHERE n.ID &amp;lt; {0} ORDER BY n.ID DESC &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;].ToString() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToInt32(sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString());
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetID();
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetID();
            }
            
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下一条
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;下一条信息的ID&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; UpIDX()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; _sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT top 1 ID FROM CNBLOGSLIST AS n WHERE n.ID &amp;gt; {0} ORDER BY n.ID ASC &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetID());

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;].ToString() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToInt32(sb.ExecuteDataTable(_sql).Rows[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString());
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetID();
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetID();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些代码都很基础就不一一解释了 实现的效果还是可以的，文字都在 ，大部分的图片都显示不出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/787521/201801/787521-20180126204419428-2029331516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;希望看到的朋友能有所收获，别拿去干坏事  也干不了啥坏事，其他的网站维护你就弄不到了还要研究的。对此感谢博客园提供平台让我学有所获。初学者，大神勿喷谢谢！有兴趣的朋友不懂的可以留言。&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 12:48:00 +0000</pubDate>
<dc:creator>魏杨杨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w5942066/p/8361585.html</dc:identifier>
</item>
<item>
<title>基于FPGA的HDMI高清显示接口驱动 - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8353827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8353827.html</guid>
<description>&lt;p&gt;　　HDMI是（High Definition Multimedia Interface）的缩写，意思是高清晰度多媒体接口，是一种数字化视频/音频接口技术，适合影像传输的专用型数字化接口，可同时传送音频和影像信号，最高数据传输速度为48Gbps（2.1版），HDMI相较于VGA接口，它传输的信息量大，色彩度高，传输速度快等显著优点。&lt;/p&gt;
&lt;p&gt;　　一般来说驱动HDMI有两种方法，有些开发板是用一颗专用的HDMI芯片ADV7511做HDMI的输出使用，ADV7511 是一款高速高清晰度多媒体接口(High Definition Multimedia Interface HDMI)发送器。 能够处理的数据速率高达165MHz(1080p @60H, UXGA @60Hz)， 输出数据速率高达 225MHz。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001215537-1273395872.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Digilent官方出品的ZYBO开发板，上面一个双向的HDMI端口，直接连接在PL的引脚上，所以这次博主分享的工程是用ZYBO PL端的IO口模拟HDMI接口，首先先来讲一下HDMI的显示原理主要是TMDS，该部分摘自博客：http://blog.sina.com.cn/s/blog_679686370100vgg1.html&lt;/p&gt;
&lt;p&gt;　　HDMI 采用和 DVI 相同癿传输原理——TMDS（Transition Minimized Differential &lt;em id=&quot;__mceDel&quot;&gt;signal），最小化传输差分信号。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　TMDS 传输系统分为两个部分：发送端和接收端。 TMDS 发送端收到HDMI 接口传来的表示 RGB 信号的24 位并行数据（TMDS 对每个像素的 RGB 三原色分别按 8bit 编码，即 R信号有 8 位，G 信号有 8 位，B 信号有 8 位），然后对这些数据进行编码和并/串转换，再将表示 3 个 RGB 信号的数据分别分配到独立的传输通道发送出去。接收端接收来自发送端的串行信号，对其进行解码和串/并转换，然后发送到显示器的控制端。与此同时也接收时钟信号，以实现同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TMDS&lt;/strong&gt;&lt;strong&gt;的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       每一个 TMDS 链路都包括 3 个传输 RGB 信号的数据通道和 1 个传输时钟信号的通道。每一个数据通道都通过编码算法，将 8 位的视、音频数据转换成最小化传输、直流平衡的 10 位数据。这使得数据的传输和恢复更加可靠。最小化传输差分信号是通过异或及异或非等逡、逻辑算法将原始 8 位信号数据转换成 10 位，前 8 为数据由原始信号经运算后获得，第 9 位指示运算的方式，第 10 位用来对应直流平衡。&lt;/p&gt;
&lt;p&gt;　　一般来说，HDMI 传输癿编码格式中要包含视频数据、控制数据和数据包（数据包中包吨音频数据和附加信息数据，例如纠错码等）。 TMDS 每个通道在传输时要包含一个 2bit 的控制数据、 8bit 的视频数据或者 4bit 的数据包即可。在 HDMI 信息传输过程中，可以分为三个阶段：视频数据传输周期、控制数据传输周期和数据岛传输周期，分别对应上述的三种数据类型。&lt;/p&gt;
&lt;p&gt;下面介绍 TMDS 中采用的技术：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传输最小化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;       8 位数据经过编码和直流平衡得到 10 位最小化数据，这仿佛增加了冗余位，对传输链路的带宽要求更高，但事实上，通过这种算法得到的 10 位数据在更长的同轴电缆中传输的可靠性增强了。下图是一个例子，说明对一个 8 位的并行 RED 数据编码、并/串转换。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001240131-1640587131.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　第一步：将 8 位并行 RED 数据发送到 TMDS 収送端。&lt;br/&gt;　　第二步：并/串转换.&lt;br/&gt;　　第三步：进行最小化传输处理，加上第 9 位，即编码过程。第 9 位数据称为编码位。&lt;/p&gt;
&lt;p&gt;　　2. 直流平衡&lt;/p&gt;
&lt;p&gt;　　直流平衡（DC-balanced）就是指在编码过程中保证信道中直流偏移为零。方法是在原来的 9 位数据癿后面加上第 10 位数据，返样，传输的数据趋于直流平衡，使信号对传输线的电磁干扰减少，提高信号传输的可靠性。&lt;/p&gt;
&lt;p&gt;　　3. 差分信号&lt;/p&gt;
&lt;p&gt;　　TMDS差分传动技术是一种利用2个引脚间电压差来传送信号的技术。传输数据的数值（“0”或者“1”）由两脚间电压正负极性和大小决定。即，采用 2 根线来传输信号，一根线上传输原来的信号，另一根线上传输与原来信号相反的信号。这样接收端就可以通过让一根线上的信号减去另一根线上的信号的方式来屏蔽电磁干扰，从而得到正确的信号。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001358444-50059982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外，还有一个显示数据通道（DDC），是用于读取表示接收端显示器的清晰度等显示能力的扩展显示标识数据(EDID)的信号线。搭载 HDCP（High-bandwidth Digital Content Protection，高带宽数字内容保护技术）的发送、接收设备之间也利用 DDC 线进行密码键的认证。&lt;/p&gt;
&lt;p&gt;       接下来是电路设计部分，HDMI驱动部分追寻原始出处应该是迪芝伦官方，该部分代码用VHDL语言描述，为了方便移植，我将该部分代码封装成自定义IP Core，由上文可知，我们需要产生RGB888三路数据，输入给该模块，然后经过解码、串/并转换，差分输出。还需要两个时钟输入，一个是当前显示分辨率的像素时钟，一个是当前显示分辨率的像素时钟的五倍。还有一个行同步信号和场同步信号，这两个信号的产生方法和VGA是一样的，简单来说就是先产生VGA的信号，行同步信号、场同步信号RGB888的数据输入给HDMI驱动模块就可以显示了，我们要修改显示的数据，还是只需要修改VGA时序即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001405569-540101957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　该工程经过测试，可以实现720p（1280x720）的分辨率显示，1080p（1920×1080）的分辨率没有测试出来，原因我觉得可能是官方的zybo的晶振是125Mhz的，这个时钟很尴尬，直接用Clocking wizard锁不出来HDMI所需要的精确时钟，如下图。我试过先分频出100Mhz，然后在调用一个IP Core分频和倍频，但是综合总会报错。所以直接这样进行PLL虽然有误差但是还是可以显示出720p的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001411397-292914677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       而且根据迪芝伦的官方手册上描述，有这样一段，Resolution up to 720p(1280x720) have been teste。我的英文不是很好，那既然这样说了，没准它还真达不到1080p，好吧不管了，就暂且认为它最高只能达到720p吧。逃~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001434772-2084459047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       打开工程后，需要重新添加HDMI自定义IP的路径，就在工程中，rgb2dvi_v1_2文件夹中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001442615-1651853290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在IP Catalog中搜索hdmi_disp就可以得到对应的IP Core了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001452178-1696426735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　双击打开这四个需要定义的参数，已经定义好在IP中了，直接点击OK——Generate生成&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001503678-1329415684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　直接可以在如下图所示中找到例化文件，直接实例化即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001509740-1728482237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于引脚约束，需要说的是，引脚约束必须为TMDS_33电平标准&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001515272-576676410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后附上一张720p彩条测试图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180126001525162-1380740337.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       最后欢迎关注一亿人都想要关注的微信订阅号【开源FPGA】，总结记录自己的学习过程，一个FPGA工程师的养成之路。欢迎加入开源FPGA-交流群-I进行讨论，群号码：677163633。如果您需要本工程的源码，欢迎关注博主微信订阅号【开源FPGA】，在后台回复，开源FPGA，即可获得工程源码哦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 基于FPGA的HDMI高清显示接口驱动&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8353827.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8353827.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 11:02:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8353827.html</dc:identifier>
</item>
<item>
<title>一步步部署基于Windows系统的Jenkins持续集成环境 - pandaphinex</title>
<link>http://www.cnblogs.com/babygirl/p/jenkins_ci_windows.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babygirl/p/jenkins_ci_windows.html</guid>
<description>&lt;p&gt;&lt;strong&gt;如题&lt;/strong&gt;：本文将介绍如何在Windows环境下运用Jenkins部署持续集成环境。之所以写本文，是因为在最近工作当中，学习使用Jenkins时，确实遇到了一些问题，而大多数教程文档都是基于Mac或是Linux平台。为此很是头疼，经过一番摸索，终于走通了Windows平台下的一条路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本CI系统流程&lt;/strong&gt;：Dev提交代码，并merge到master分支--&amp;gt;Jenkns获取最新代码，开始构建（解析git触发响应，build solution，run automation，get result都在此步内完成）--&amp;gt;构建完成发送邮件。&lt;/p&gt;
&lt;p&gt;首先，下载安装Jenkins：https://jenkins.io/&lt;/p&gt;
&lt;p&gt;安装完成之后可以通过访问 http://hostname:8080 进入管理页面。选择:Manage Jenkins&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126164639584-904682778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在右侧列表中选中&quot;Configure Global Secuity&quot;，选中&quot;Allow user to sign up&quot;，然后就可以提前注册好要赋权限的账户。若以后不允许新管理账户的注册，在取消此选中项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126165403397-711664759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，在代理项下，展开代理协议，并全部选中。此处选中之后，会启用&quot;Java Web Start Agent&quot;，否则其在创建slave时处于不可见状态。（使用此代理，还需提前安装Java，到Java官网下载一个安装即可）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126165659600-1434060757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再回到&quot;Manage Jenkins&quot;界面，选择&quot;Manage Node&quot;，点击&quot;New Node&quot;创建一个新的slave，这里我们选择&quot;Permanent Agent&quot;，也可以选择从已有的slave复制出新的节点。填写名称，远程根目录和标签，启动方法选择如图。这里的远程目录用于存储Jenkins客户端运行文件。其他设置默认值就可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126170805209-1656460060.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到这里一个node就创建好了。我们可以回到Node管理界面，此时新建的node是未连接状态，可以在你的另外一台server，或本机上访问你的Jenkins页面，并点击&quot;Launch&quot;连接node，并将之安装为本地service。如果你是Win10系统，会出现安装错误，这时别急，先将你的IE或这Edge以管理员的方式重新启动，再次访问Jenkins尝试连接和安装。当你觉得要启用这个安装的service时，先停止服务，然后再cmd命令窗口输入“sc delete servicename&quot;就可以删除此服务了。servicename可以再service的右键属性中查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126171550740-393991871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建好了node，我们就和某一台server连接上了，接下来我们需要去创建job，去完成我们需要做的工作。&lt;/p&gt;
&lt;p&gt;回到Jenkins主页面，点击&quot;New Item&quot;，这里我选择使用&quot;Freestyle Project&quot;。编辑好项目名称，描述之后，我们可以定义清楚过时的build。这里我定义为保留7天以内的build，并规定最多只保留10个build。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126172022490-404189314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面介绍过，本CI系统响应git返回的触发条件，因此需要设置一个参数接收返回的响应，并在此设置在哪个node上执行此次构建任务，即填写创建node时设置的Label：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126172934569-493105607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了在创建node时的默认设置，我们也可以在此处设置自定义的workspace，获取的代码将存储在此处：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126173310865-1361572785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在源代码管理项中，我们选用Git，设置好相应的git项目url和访问的用户名和密码，分支选默认的master：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126173801037-1317529911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取了代码之后，选择触发方式，如果时定时轮询的方式，选择&quot;Poll SCM&quot;，设置间隔时间即可。需要每次提交都响应，这里我选择远程触发&quot;Trigger builds remotely&quot;，设置一个token值待用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126174105350-881263216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时，我们需要到Git网站代码管理设置页面，添加一个&quot;Hooks &amp;amp; services&quot;，并启用&quot;Pull request&quot;。Payload URL的格式按照上面设置的token下提示的格式设置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126174436444-24391427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成以上步骤之后，Job的运行环境基本上就已经设置成功了，接下来就是构建自动化运行脚本了。&lt;/p&gt;
&lt;p&gt;回到刚才的Job编辑页面，继续往下走，点击&quot;Add build step&quot;，在下拉框中可以看到，Jenkins支持的脚本语言十分丰富。这里我们会用到Window batch和Widows PowerShell。在这里写入你的业务处理脚本，保存一下。比如输出&quot;Jenkins CI&quot;，在Windows batch框中输入&quot;echo Jenkins CI&quot;，保存，就可以了。&lt;/p&gt;
&lt;p&gt;最后，需要在脚本完成之后自动发送邮件。来看看是如何配置的：&lt;/p&gt;
&lt;p&gt;配置邮件通知之前，我们需要到&quot;Configure System&quot;中设置一下邮件系统的基本配置。&lt;/p&gt;
&lt;p&gt;首先，填写好Jenkins访问地址和发件人邮箱地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126181142100-1522756323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，设置SMTP邮件服务器和一些默认值，包括接收对象，主题，内容等等。如此，最简单的邮件发送配置就完成了。后面来设置具体的邮件通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126181453522-2065814487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是回到Job编辑页面，找到&quot;Post-build Actions&quot;并选择&quot;Editable Email Notification&quot;。设置实际的接收人，内容格式和默认主题。并设置默认内容，可以配合环境变量（此处不做详解）参数化、格式化内容文体。&lt;/p&gt;
&lt;p&gt;需要发送附件的，还可以对附件的路径、名称进行设置。最后设置好邮件发送触发条件就OK了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137111/201801/1137111-20180126182424194-1465747908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，一个完整的Windows平台下的CI系统就建立起来了。&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 10:29:00 +0000</pubDate>
<dc:creator>pandaphinex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/babygirl/p/jenkins_ci_windows.html</dc:identifier>
</item>
<item>
<title>UWP: 通过命令行启动 UWP 应用 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/uwp_commandline_launch.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/uwp_commandline_launch.html</guid>
<description>&lt;p&gt;最近在开发应用的过程中，我遇到了如标题所述的需求，其实主要是为了能够快捷启动应用，正像我们可以在“运行”对话框中可以输入一些可执行程序的名称后，就能够直接启动它；这样做，可以增加 App 的易用性。在查了一些文档后，得知在 Windows Build 16266 之后，就加入相关的 API，因此要实现以及使用这一功能，Window 系统和 SDK 的版本都要大于 16266，Fall Creators Update (Build 16299) 则完全满足这一条件。&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;要使用命令行启动 UWP 应用，其实非常简单，只需要两步：首先，在 Package.appxmanifest 中添加 appExecutionAlias 扩展；然后，在 App.OnActived 事件中做相应的处理。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1. 修改Package.appxmanifest&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;右击项目中的 Package.appxmanifest 文件，在快捷菜单中选择“打开方式“-&amp;gt;”XML 文本编辑器“。打开后，对它的内容按以下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Package
  &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:mp&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/2014/phone/manifest&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:uap&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
  xmlns:uap5&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10/5&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
  IgnorableNamespaces&lt;/span&gt;&lt;span&gt;=&quot;uap mp &lt;strong&gt;uap5&lt;/strong&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application
        &lt;/span&gt;&lt;span&gt;...
&lt;strong&gt;      &amp;lt;Extensions&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
        &lt;strong&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uap5:Extension
            &lt;/span&gt;&lt;span&gt;Category&lt;/span&gt;&lt;span&gt;=&quot;windows.appExecutionAlias&quot;&lt;/span&gt;&lt;span&gt;
            Executable&lt;/span&gt;&lt;span&gt;=&quot;TestCmdLineApp.exe&quot;&lt;/span&gt;&lt;span&gt;
            EntryPoint&lt;/span&gt;&lt;span&gt;=&quot;TestCmdLineApp.App&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uap5:AppExecutionAlias&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uap5:ExecutionAlias &lt;/span&gt;&lt;span&gt;Alias&lt;/span&gt;&lt;span&gt;=&quot;App.exe&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;uap5:AppExecutionAlias&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;uap5:Extension&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;/strong&gt;   
   &lt;strong&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Extensions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/strong&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pakage&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中加粗部分是我们需要补充的内容。可以看到，我们添加了一个名为 appExecutionAlias  的扩展 (Extension)。在 Extension 节点中包括了几个属性，它们的意义分别如下：&lt;/p&gt;
&lt;p&gt;1) Category 属性指明 Extension 的类别，对于我们当前的需求，它的值固定为 windows.appExecutionAlias，即为应用的运行提供别名；&lt;br/&gt;2) Executable 属性指明当前应用的 exe 名称，也即：程序集名称 ＋ &quot;.exe&quot;；&lt;br/&gt;3) EntryPoint 属性指明当前应用的入口点，也即 App 类的完整名称（包含其所在的命名空间）；&lt;br/&gt;4) 在 AppExecutionAlias\ExecutionAlias  节点中的 Alias 属性，就是我们为要为当前应用定义的命令行启动名称；这里需要说明三点：&lt;/p&gt;
&lt;p&gt;a) 它可以与前面 Executable 属性值相同，也可以不同，比如更简短一些，便于用户记住与输入；&lt;br/&gt;b) 如果定义的别名，已经被当前机器上安装的其它应用占用了，那么它就不会生效，也即，谁先占用就对谁有效（当然，如果先前占用的应用被卸载了，那么这个别名就可以被你的应用使用）；&lt;br/&gt;c) 可以添加多个 ExecutionAlias  节点，为应用指定多个别名。通过为应用提供更多的别名，可以解决别名被占用的问题（如果确实存在这个问题）。&lt;/p&gt;
&lt;h3&gt;2. 处理 OnActivated 事件&lt;/h3&gt;
&lt;p&gt;在 App.OnActived 事件中，我们对 IActivatedEventArgs 参数类型判断，如果其 Kind 属性为 CommandLineLaunch，则认为是命令行启动，接下来所做的就像在 OnLaunched 事件中一样，对 Frame 初始化并导航到应用的主页，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActivated(IActivatedEventArgs args)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Kind ==&lt;span&gt; ActivationKind.CommandLineLaunch)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;            }

            Frame rootFrame &lt;/span&gt;= Window.Current.Content &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Frame;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rootFrame == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                rootFrame &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Frame();
                rootFrame.NavigationFailed &lt;/span&gt;+=&lt;span&gt; OnNavigationFailed;
                Window.Current.Content &lt;/span&gt;=&lt;span&gt; rootFrame;
            }

            rootFrame.Navigate(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MainPage));

            Window.Current.Activate();
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActivated(args);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 参数处理&lt;/h3&gt;
&lt;p&gt;使用命令行启动应用有一个很大的好处，用户在启动时可以携带参数，如： app.exe a, app.exe a b, app.exe /type:a 等，而应用则根据用户提供的参数作相应的处理。要得到用户传递的参数，只要将 IActivatedEventArgs 类型的参数转换为  CommandLineActivatedEventArgs，通过它的  Operation.Arguments 属性即可得到，剩下的就是对参数进行分析并根据参数进行相应的处理。除了参数，我们也能够得到用户是从哪个目录启动 App 的，这是通过 Operation.CurrentDirectoryPath 属性得到的。完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActivated(IActivatedEventArgs args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; arugment = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Kind ==&lt;span&gt; ActivationKind.CommandLineLaunch)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cmdArgs = args &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CommandLineActivatedEventArgs;
                StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                sb.AppendLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Argument: {cmdArgs.Operation.Arguments}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                sb.AppendLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentDirectoryPath: {cmdArgs.Operation.CurrentDirectoryPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageDialog(sb.ToString()).ShowAsync();
            }

            Frame rootFrame &lt;/span&gt;= Window.Current.Content &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Frame;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rootFrame == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                rootFrame &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Frame();
                rootFrame.NavigationFailed &lt;/span&gt;+=&lt;span&gt; OnNavigationFailed;
                Window.Current.Content &lt;/span&gt;=&lt;span&gt; rootFrame;
            }

            rootFrame.Navigate(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MainPage), arugment);

            Window.Current.Activate();
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActivated(args);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，要测试效果，需要部署(Deploy)应用。&lt;/p&gt;
&lt;p&gt;部署完成后，在“运行”(Win + R)对话框中输入上面定义的别名（和参数），即可。当然，在“命令提示符”窗口甚至在“资源管理器”窗口的地址栏中，你都可以输入别名来启动应用。&lt;/p&gt;
&lt;h2&gt;背后原理&lt;/h2&gt;
&lt;p&gt;为什么在上述这些位置我们输入别名后，就可以运行应用呢？为了解决这个问题，首先我们使用 where 命令得看看对应的命令究竟在哪里。在“命令提示符”窗口中，输入： where 别名，得到这样的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
C:\Users\Admin&amp;gt;&lt;span&gt;where app
&lt;span&gt;C:\Users\Admin\AppData\Local\Microsoft\WindowsApps\App.exe&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在“资源管理器”中打开对应的路径，会看到在这个目录下存放了当前机器中所有那些使用别名的应用，其实这里的文件可以认为是一个快捷方式。&lt;/p&gt;
&lt;p&gt;不仅如此，这个目录也在 PATH 环境变量中（可在“命令提示符”中使用 path 命令查看或在“系统属性”的“环境变量”对话框中查看），因此，我们才可以在任何位置都能启动应用。&lt;/p&gt;
&lt;p&gt;除此以外，作为用户，我们还可以在桌面（或其它任何目录）为应用创建快捷方式，右击桌面-&amp;gt;创建快捷方式，然后输入别名 和参数（可选）。通过双击快捷方式图标，也可以启动应用。这一点类似于创建磁贴，不过，它要比磁贴更灵活。我们甚至还可以为不同的参数创建多个快捷方式，也可以为每个快捷方式指定不同的图标。这样，是不是感觉更像 Win32 应用了呢？&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要提到了如何使用命令行来启动 UWP 应用，为应用提供这一特性可以为其增加易用性以及灵活性。作为 App 的使用者，可以更便利、更灵活地打开、使用应用。这样，使得 UWP 应用和 Win32 程序的行为更加一致。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blogs.windows.com/buildingapps/2017/07/05/command-line-activation-universal-windows-apps/&quot; target=&quot;_blank&quot;&gt;Command-Line Activation of Universal Windows Apps&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 09:43:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/uwp_commandline_launch.html</dc:identifier>
</item>
<item>
<title>解决spring定时任务执行两次和tomcat部署缓慢的问题 - Sinte-Beuve</title>
<link>http://www.cnblogs.com/Sinte-Beuve/p/8360321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sinte-Beuve/p/8360321.html</guid>
<description>&lt;h2 id=&quot;spring定时任务执行两次&quot;&gt;spring定时任务执行两次&lt;/h2&gt;
&lt;h3 id=&quot;问题重现和解析&quot;&gt;问题重现和解析&lt;/h3&gt;
&lt;p&gt;最近使用quartz定时任务框架，结果发现开发环境执行无任何问题，部署到服务器上后，发现同一时间任务执行了多次。经过搜索发现是服务器上tomcat的配置文件出现了问题。&lt;br/&gt;原来的配置文件——&lt;strong&gt;server.xml&lt;/strong&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
    &amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
           pattern=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot; /&amp;gt;
&amp;lt;/Host&amp;gt;
&amp;lt;Host name=&quot;www.xxx.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&amp;gt;
    &amp;lt;Context path=&quot;&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.9/webapps/xxxindex&quot;  reloadable=&quot;true&quot;&amp;gt;&amp;lt;/Context&amp;gt;  
&amp;lt;/Host&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个Host表示一个容器，里面可以包含若干个Context（应用）。上面这段配置文件意思就是：在tomcat中配置了两个容器，一个&lt;strong&gt;name=localhost&lt;/strong&gt;，应用的根目录为&lt;strong&gt;webapps&lt;/strong&gt;，并且会自动解压war包和自动部署。没有指定context，会把根目录下的所有web应用都部署，部署成功后，外网可以通过服务器IP+项目名来访问；另一个&lt;strong&gt;name=www.xxx.com&lt;/strong&gt;，和第一个host不同在于，配置了主页web应用，且不需要跟项目名就可以访问。部署成功后可以通过域名+项目名访问，主页所在项目可以直接通过根域名访问。&lt;/p&gt;
&lt;p&gt;这个时候问题就来了，包含定时任务的项目部署在webapps目录下，tomcat中两个独立的容器都部署了一遍，相当于项目在服务器上的tomcat上部署了两次，两边同时会运行定时任务，指定的是同一个数据库。&lt;/p&gt;
&lt;h3 id=&quot;问题解决&quot;&gt;问题解决&lt;/h3&gt;
&lt;p&gt;因此，为了尽可能不影响其他项目的正常访问，我做了折中，讲需要执行定时任务的项目单独部署在另一个文件夹中，例如&lt;strong&gt;webroot&lt;/strong&gt; ，然后只使用域名那个host，配置文件修改后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
    &amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
           prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
           pattern=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot; /&amp;gt;
&amp;lt;/Host&amp;gt;

&amp;lt;Host name=&quot;www.xxx.com&quot; appBase=&quot;&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&amp;gt;
    &amp;lt;Context path=&quot;&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.9/webapps/xxxindex&quot;  reloadable=&quot;true&quot;&amp;gt;&amp;lt;/Context&amp;gt;  
    &amp;lt;Context path=&quot;/projectA&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.9/webapps/projectA&quot;  reloadable=&quot;true&quot;&amp;gt;&amp;lt;/Context&amp;gt;  
    &amp;lt;Context path=&quot;/projectB&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.9/webapps/projectB&quot;  reloadable=&quot;true&quot;&amp;gt;&amp;lt;/Context&amp;gt;  
    &amp;lt;Context path=&quot;/projectC&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.9/webroot/projectC&quot;  reloadable=&quot;true&quot;&amp;gt;&amp;lt;/Context&amp;gt;  
&amp;lt;/Host&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到projectC是包含定时任务的项目。这样部署成功后，除了该项目只能通过域名访问之外，其余项目的访问方式和之前保持不变。同时问题解决，定时任务只执行一次。&lt;/p&gt;
&lt;h3 id=&quot;网上的另一种说法&quot;&gt;网上的另一种说法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;  
    &amp;lt;Context docBase=&quot;projectA&quot; path=&quot;&quot; reloadable=&quot;true&quot; /&amp;gt;  
&amp;lt;/Host&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有一个host，tomcat在启动时，会部署一次根目录下的所有项目，然后Context又会单独部署一次，所以也会导致定时任务执行2次。&lt;br/&gt;对于这种问题，解决的方案也有多种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将huost的appBase设为空，将Context的Context 指向项目部署位置的绝对路径。&lt;/li&gt;
&lt;li&gt;删除Context节点。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;tomcat部署缓慢的问题&quot;&gt;tomcat部署缓慢的问题&lt;/h2&gt;
&lt;p&gt;用的阿里云服务器，部署tomcat时速度非常慢，但是后来买的新阿里云又没有这个问题。部署项目后一直会在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /opt/apache-tomcat-8.0.15-server/webapps/ROOT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里卡好几分钟才会继续下去。之前一直以为是服务器配置原因，后来无意中发现是jre的配置原因。参考了几篇博客，发现oracle在WebLogic的文档下&lt;a href=&quot;https://docs.oracle.com/cd/E13209_01/wlcp/wlss30/configwlss/jvmrand.html&quot;&gt;Avoiding JVM Delays Caused by Random Number Generation&lt;/a&gt;给了原因和解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;The library used for random number generation in Sun's JVM relies on /dev/random by default for UNIX platforms. This can potentially block the WebLogic SIP Server process because on some operating systems /dev/random waits for a certain amount of &quot;noise&quot; to be generated on the host machine before returning a result. Although /dev/random is more secure, BEA recommends using /dev/urandom if the default JVM configuration delays WebLogic SIP Server startup.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;意思就是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JVM上产生随机数的策略有两种：/dev/random 和/dev/urandom。&lt;/li&gt;
&lt;li&gt;tomcat或者WebLogic等web服务器在部署时需要等待若一段随机数产生的时间。unix平台下JVM默认采用的是安全性更好的/dev/random，但是潜在的会阻塞服务进程。&lt;/li&gt;
&lt;li&gt;推荐使用/dev/urandom，产生随机数速度快，/dev/random需要时间间隔生成随机数，部署时间长。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;修改方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;code&gt;$JAVA_HOME/jre/lib/security/java.security&lt;/code&gt;文件。&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;securerandom.source=file:/dev/random&lt;/code&gt; 修改为&lt;code&gt;securerandom.source=file:/dev/urandom&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重启tomcat，三十秒部署成功，solve it&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
</description>
<pubDate>Fri, 26 Jan 2018 08:50:00 +0000</pubDate>
<dc:creator>Sinte-Beuve</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sinte-Beuve/p/8360321.html</dc:identifier>
</item>
</channel>
</rss>