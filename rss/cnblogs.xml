<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>区块链开发_以太坊多重签名 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/8948537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/8948537.html</guid>
<description>&lt;p&gt;假想这么一个场景：&lt;/p&gt;
&lt;p&gt;有一天，你的朋友A来找你开公司，但是钱不够，希望你能在找一个人入伙。&lt;/p&gt;
&lt;p&gt;然后，你就找了你另一个朋友C。&lt;/p&gt;
&lt;p&gt;你们三个人分别出了500W开公司。但是由于公司资金流动性大，每次拿钱都要三个人分别拿钱，很不方便。&lt;/p&gt;
&lt;p&gt;经过你们协商，就让你的朋友A管理公司财政。&lt;/p&gt;
&lt;p&gt;结果，不久你的朋友A就带着公司的钱跑路了。&lt;/p&gt;
&lt;p&gt;估计，你的朋友C会把你点天灯。&lt;/p&gt;

&lt;p&gt;所以，以太坊上有一个很重要的功能，就是多重签名。&lt;/p&gt;
&lt;p&gt;就是，建立一个合约钱包，这个钱包可以有多个账户（假定为三位）。每次通过这个钱包转出超过额定限度（这里假定为2以太币）时，就需要一定数量的账户同意（这里假定为2个）。&lt;/p&gt;
&lt;p&gt;这样就避免了上述中，某人将全部money卷走的问题。&lt;/p&gt;

&lt;p&gt;一，选择测试网络，注册多个账号：&lt;/p&gt;
&lt;p&gt;首先，通过DEVELOP下NETWORK选择Rinkiby测试网络。&lt;/p&gt;
&lt;p&gt;PS：这里假定你的钱包已经有测试以太币了。如果没有，请看我之前的文章。&lt;/p&gt;

&lt;p&gt;然后，通过FILE下的NEW ACCOUNT创建四个账号。&lt;/p&gt;
&lt;p&gt;PS：一定要记住密码的。&lt;/p&gt;

&lt;p&gt;最后，通过SEND，将部分的测试以太币发到其他账号。&lt;/p&gt;
&lt;p&gt;PS：确保有四个账号，并且其中有三个有money。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201804/987666-20180426000457778-1479608330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;二，建立一个联合钱包：&lt;/p&gt;
&lt;p&gt;首先，通过下图位置，点击进入创建联合钱包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201804/987666-20180426000542999-1234078608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，你就会看到联合钱包的创建界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201804/987666-20180426000837015-2067405998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，1号红线处，是这个钱包的名字。&lt;/p&gt;
&lt;p&gt;毕竟这种钱包也许不止一个呢。&lt;/p&gt;
&lt;p&gt;另外，2号红框框是要勾选的，表示多重签名钱包合约。&lt;/p&gt;
&lt;p&gt;另外两个，一个是单用户，另一个是导入钱包。&lt;/p&gt;

&lt;p&gt;然后，设置完成后，应该是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201804/987666-20180426001339697-919408846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，1号红线是名字。&lt;/p&gt;
&lt;p&gt;2号红线后面，有三个短红线处，分别表示该联合钱包总参与人数，每人每日最高独立额度（即一个账号可以决定的额度。毕竟，总不能一毛钱也要所有人都签名吧），多重签名所需要的最低签名人数。&lt;/p&gt;
&lt;p&gt;这里，我们设置为3，1，2。表示这个钱包由三个账号参与，没人每日最多单独提出1个以太币，当超出这个额度时，至少需要2个账号同意。&lt;/p&gt;
&lt;p&gt;再往下的两处红线，表示参与该联合钱包的其他两个账号。&lt;/p&gt;

&lt;p&gt;到了这里就算完成设置，点击CREATE创建该钱包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201804/987666-20180426002026805-772572129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：此时，表示正在创建，部署。请稍稍等候一下。&lt;/p&gt;
&lt;p&gt;PS：中途会出现一个确认的界面，输入密码即可。有时候会没法提交，稍等一下，再提交即可。&lt;/p&gt;


&lt;p&gt;至此，就完成了一个以太坊多重签名的联合钱包。&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 23:26:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tiancheng-Duan/p/8948537.html</dc:identifier>
</item>
<item>
<title>[译文]Domain Driven Design Reference（三）—— 模型驱动设计的构建模块 - Zachary_Fan</title>
<link>http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;其它本系列其它文章地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference1.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（一）—— 前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8117860&quot; href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference2.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（二）—— 让模型起作用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8341318&quot; href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（三）—— 模型驱动设计的构建模块&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;　　这些模式根据领域驱动设计，广泛地推行了面向对象设计的最佳实践。他们指导决策来提炼模型，并使模型和实现保持一致，每一个都增强了其他的有效性。仔细制定模型元素的细节为开发人员提供了一个稳定的平台，从中可以探索模型并使其与实现保持紧密联系。&lt;/p&gt;

&lt;h2&gt;分层架构&lt;/h2&gt;
&lt;p&gt;　　在面向对象的程序中，用户界面，数据库和其他支持代码通常会直接写入业务对象。额外的业务逻辑被嵌入在UI部件和数据库脚本的行为中。发生这种情况是因为在短期内，这样做是最简单的方法。&lt;/p&gt;
&lt;p&gt;　　当与领域相关的代码通过如此大量的其他代码被扩散时，变得非常难以理解和推理。UI的表面变化实际上可以改变业务逻辑。要更改业务规则，可能需要仔细跟踪UI代码，数据库代码或其他程序元素。实现一致的、模型驱动的对象变得不切实际。自动化测试变得难以进行。由于每个活动都涉及到所有的技术和逻辑，程序必须保持非常简单，否则就无法理解。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;隔离领域模型和业务逻辑的表达形式，并消除对基础架构，用户界面甚至非业务逻辑的应用程序逻辑的依赖。将一个复杂的程序分成多个层。在每个层次内开发一个内聚的设计，并且仅依赖于下面的层。遵循标准的建筑模式，为上面的分层提供松散的耦合。将所有与领域模型相关的代码集中在一个层中，并将其与用户界面，应用程序和基础设施的代码隔离。领域对象没有显示自己，存储自己，管理应用程序任务等等的职责，可以集中在表达领域模型上。这使得一个模型能够发展到足够丰富，足够清晰，能够捕获必要的业务知识并将其付诸实践。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里的关键目标是隔离。 诸如“六边形架构”之类的相关模式可以起到允许我们的领域模型表现避免依赖和引用其他系统问题，甚至更好的效果。&lt;/p&gt;

&lt;h2&gt;实体&lt;/h2&gt;
&lt;p&gt;　　许多对象代表了一个连续的具有身份标识的主线，贯穿整个生命周期，尽管其属性可能会改变。一些对象不是主要由它们的属性定义的。它们代表了贯穿时间并经常跨越不同展现形式的主线的身份标识。有时这样的对象必须与另一个对象匹配，即使属性不同。错误的身份可能导致数据损坏。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当一个对象被它的身份而不是它的属性所区分时，把它作为它在模型中定义的要点。保持简单的类定义，并关注生命周期的连续性和身份标识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　定义一个区分每个对象的方法，而不管它的形式或历史。 对通过属性调用匹配对象的需求保持警惕。定义一个保证为每个对象产生唯一结果的操作，可能通过附加一个保证唯一的符号。这种标识手段可能来自外部，也可能是由系统创建的任意标识符，但必须符合模型中的身份标识区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　模型必须定义什么是同样的事情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（又称参考对象）&lt;/p&gt;

&lt;h2&gt;值对象&lt;/h2&gt;
&lt;p&gt;　　有些对象描述或计算事物的一些特征。&lt;/p&gt;
&lt;p&gt;　　许多对象没有概念上的身份标识。&lt;/p&gt;
&lt;p&gt;　　跟踪实体的身份标识至关重要。但将身份标识附加到其他对象可能会伤害系统性能，增加分析工作，并使所有对象看起来都一模一样。软件设计是一个复杂的持续战斗。我们必须作出区分，以便只有在必要时才进行特殊处理。&lt;/p&gt;
&lt;p&gt;　　然而，如果我们把这种类型的对象看作是缺少身份的话，那么我们并没有在我们的工具箱或词汇中添加太多东西。实际上，这些对象具有自己的特点，对模型本身也有意义。 这些是描述事物的对象。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当您只关心模型元素的属性和逻辑时，将其归类为值对象。使其表达它传达的属性的含义并赋予它相关的功能。将值对象视为不可变的。使所有操作是不依赖任何可变状态的无副作用函数。不要给值对象任何身份标识，并避免保留实体所必需的设计复杂性。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;领域事件&lt;/h2&gt;
&lt;p&gt;　　领域专家关心的事情发生了。一个实体负责跟踪其状态和规定其生命周期的规则。但是，如果你需要知道状态变化的实际原因，这通常是不明确的，并且可能很难解释系统如何实现它。审计线索可以允许跟踪，但通常不适合用于程序本身的逻辑。实体的变化历史可以允许访问先前的状态，但忽略这些变化的含义，以便对信息的任何操作都是程序性的，并且经常被抛出领域层。&lt;/p&gt;
&lt;p&gt;　　分布式系统中出现了一系列独特但又相关的问题。分布式系统的状态在任何时候都不能保持完全一致。我们始终保持聚合内部一致，而异步的进行其他更改。当更改在网络的节点间传播时，可能很难解决无序或来自不同来源的多个更新。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;将关于领域中活动的模型信息视为一系列离散事件。将每个事件表示为一个领域对象。这些不同于系统事件，它们反映了软件本身的活动，虽然通常系统事件与领域事件相关联或者作为领域事件的响应的一部分，或者作为将领域事件的信息携带到系统中的一种方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　领域事件是领域模型的一个完整的部分，是领域中发生的事情的表示形式。忽略不相关的领域活动，同时明确领域专家想要跟踪或者被通知的事件，或者与其他模型对象中的状态改变相关联的事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在分布式系统中，实体的状态可以从特定节点的当前已知的领域事件中推断出来，从而在没有关于整个系统的完整信息的情况下得到相关的模型。&lt;/p&gt;
&lt;p&gt;　　领域事件通常是不可变的，因为它们是过去的某种事物的记录。除了对事件的描述之外，领域事件通常包含事件发生时间的时间戳以及事件涉及的实体的身份标识。此外，领域事件通常具有单独的时间戳，指示事件何时进入系统以及使其进入系统的人的身份标识。如果有用，领域事件的身份标识可以基于这些属性的一些集合。所以，例如，如果同一个事件的两个实例到达一个节点，则它们可以被识别为相同的。&lt;/p&gt;

&lt;h2&gt;服务&lt;/h2&gt;
&lt;p&gt;　　有时候，这不是一回事。领域的一些概念由模型作为对象是不自然的。强制所需的领域功能成为实体或者值对象的职责，要么篡改基于模型的对象的定义，要么添加无意义的虚拟对象。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当领域中的重要流程或转换不是实体或值对象的自然职责时，添加一个操作到模型中作为一个单独的接口同时声明为一个服务。定义一个服务契约，一组关于与服务交互的声明。用一个特定限界上下文的通用语言来陈述这些声明。给服务一个名字，这也成为通用语言的一部分。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;模块&lt;/h2&gt;
&lt;p&gt;　　每个人都使用模块，但很少将它们视为模型的完整部分。代码被分解成各种类别，从技术架构的各个方面到开发人员的工作任务。即使是做了很多重构的开发人员也倾向于使用项目早期构思的模块。&lt;/p&gt;
&lt;p&gt;　　耦合和凝聚力的解释倾向于使它们听起来像是技术指标，根据关联和相互作用的分布进行机械的判断。然而，这不仅仅是将代码划分为模块，还包括概念。一个人一次可以思考多少事情是有限的（因此耦合度低），不连贯的想法片段很难被理解为一个无差别的想法（因此具有很高的内聚性）。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;选择能够讲述系统故事的模块，并包含一系列内聚的概念。让模块名称成为通用语言的一部分。模块是模型的一部分，它们的名称应反映对领域的洞察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这通常会导致模块之间的低耦合，但是如果它不寻找一种方法来改变模型来分解概念，或者是一个被忽视的概念，它可能是一个能够以有意义的方式将元素组合在一起的模块的基础。在可以被独立地理解和推理的概念上寻求低耦合。根据高层领域概念对模型进行细化直到它被划分，&lt;/strong&gt;&lt;strong&gt;并将相应的代码解耦。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;聚合&lt;/h2&gt;
&lt;p&gt;　　要保证复杂关联模型中对象变化的一致性是很困难的。他们能够被是概念上的构成部分的其它对象的变化所掩盖。在多个服务器之间分发对象或设计异步事务时会出现类似的问题。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;将实体和值对象集中到聚合中并在周围定义边界。选择一个实体作为每个聚合的根，并允许外部对象仅保留对根的引用（对内部成员的引用仅在一个操作中返回出去才能使用）。定义聚合的属性和不变量作为一个整体，并将这个约束的责任赋予根【这里指的是聚合根】或某种指定的框架机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用相同的聚合边界来管理事务和分配。&lt;/p&gt;
&lt;p&gt;　　在一个聚合边界内，同步地应用一致性规则。 跨越边界，异步地处理更新。&lt;/p&gt;
&lt;p&gt;　　在一台服务器上共同维护一个聚合。允许不同的聚合在节点间分配。&lt;/p&gt;
&lt;p&gt;　　如果这些设计决策没有受到聚合边界的良好指导，请重新考虑模型。是领域的场景正在暗示着一个重要的新见解吗？这种改变通常会提高模型的表现力和灵活性，并解决事务和分配问题。&lt;/p&gt;

&lt;h2&gt;仓储&lt;/h2&gt;
&lt;p&gt;　　查询通用语言表达的聚合。&lt;/p&gt;
&lt;p&gt;　　可遍历的关联的扩散只用于找到弄乱模型的东西。在成熟模型中，查询经常表达领域概念。然而查询可能会导致问题。&lt;/p&gt;
&lt;p&gt;　　应用大多数数据库访问基础架构的纯粹技术复杂性迅速吞噬了客户端代码，导致开发人员陷入了领域层，使得模型无关紧要。&lt;/p&gt;
&lt;p&gt;　　查询框架可能会封装大部分的技术复杂性，使开发人员能够以更自动化或声明的方式从数据库中提取所需的确切数据，但这只能解决一部分问题。&lt;/p&gt;
&lt;p&gt;　　不受约束的查询可能会从对象中拉出特定的字段，违反封装，或从聚合内部实例化几个特定的对象，让聚合根变得充满变数并使这些对象无法执行领域模型的规则。领域逻辑移入查询和应用程序层代码，实体和值对象变成仅仅为数据容器。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;对于需要全局访问的每种聚合类型，创建一个服务，它可以提供所有聚合根类型的对象的在一个内存集合中的错觉。通过一个大家都知道的全局接口设置访问。提供添加和删除对象的方法，这将封装实际数据往数据存储中的插入或删除。提供基于对领域专家有意义的标准来选择对象的方法。返回完全实例化的对象或属性值符合条件的对象集合，从而封装实际的存储和查询技术，或者返回给予以惰性的方式完全实例化的聚合的幻觉的代理。仅为实际需要直接访问的聚合根提供仓储。保持应用程序逻辑专注于模型，委托所有的对象存储和访问给仓储。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;工厂&lt;/h2&gt;
&lt;p&gt;　　当创建一个完整的，内部一致的聚合或者一个大值对象变得复杂或者显示太多的内部结构时，工厂提供封装。一个对象的创建本身可以是一个主要的操作，但是复杂的组装操作不适合由创建的对象来承担。将这些职责结合起来可能会产生难以理解并且难看的设计。让客户端直接组装会混乱客户端的设计，破坏组装对象或集合的封装，并且过度地将客户端耦合到所创建对象的实现中【举个例子，这里的客户端可以理解成应用层或者UI层】。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;将创建复杂对象和聚合实例的责任转移到单独的对象上，这个对象本身可能在域模型中没有职责，但仍然是领域设计的一部分。提供一个封装所有复杂程序集的接口，并且不要求客户端引用实例化对象的具体类。将创建一个完整的聚合作为一部分，强制实施它的不变性。&lt;/strong&gt;&lt;strong&gt;创建一个复杂的值对象，可能是在将元素与构建器组合后。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;作者：Zachary_Fan&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;如果你想及时得到个人自写文章的消息推送，欢迎扫描下面的二维码~。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/397048/201805/397048-20180508110423470-695014188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 22:47:00 +0000</pubDate>
<dc:creator>Zachary_Fan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html</dc:identifier>
</item>
<item>
<title>TensorFlow-谷歌深度学习库 图片处理模块 - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/9049114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/9049114.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/adjust_brightness&quot;&gt;&lt;code&gt;adjust_brightness(...)&lt;/code&gt;&lt;/a&gt;: Adjust the brightness of RGB or Grayscale images.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/adjust_contrast&quot;&gt;&lt;code&gt;adjust_contrast(...)&lt;/code&gt;&lt;/a&gt;: Adjust contrast of RGB or grayscale images.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/adjust_gamma&quot;&gt;&lt;code&gt;adjust_gamma(...)&lt;/code&gt;&lt;/a&gt;: Performs Gamma Correction on the input image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/adjust_hue&quot;&gt;&lt;code&gt;adjust_hue(...)&lt;/code&gt;&lt;/a&gt;: Adjust hue of an RGB image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/adjust_saturation&quot;&gt;&lt;code&gt;adjust_saturation(...)&lt;/code&gt;&lt;/a&gt;: Adjust saturation of an RGB image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/central_crop&quot;&gt;&lt;code&gt;central_crop(...)&lt;/code&gt;&lt;/a&gt;: Crop the central region of the image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/convert_image_dtype&quot;&gt;&lt;code&gt;convert_image_dtype(...)&lt;/code&gt;&lt;/a&gt;: Convert &lt;code&gt;image&lt;/code&gt; to &lt;code&gt;dtype&lt;/code&gt;, scaling its values if needed.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/crop_and_resize&quot;&gt;&lt;code&gt;crop_and_resize(...)&lt;/code&gt;&lt;/a&gt;: Extracts crops from the input image tensor and bilinearly resizes them (possibly&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/crop_to_bounding_box&quot;&gt;&lt;code&gt;crop_to_bounding_box(...)&lt;/code&gt;&lt;/a&gt;: Crops an image to a specified bounding box.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_and_crop_jpeg&quot;&gt;&lt;code&gt;decode_and_crop_jpeg(...)&lt;/code&gt;&lt;/a&gt;: Decode and Crop a JPEG-encoded image to a uint8 tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_bmp&quot;&gt;&lt;code&gt;decode_bmp(...)&lt;/code&gt;&lt;/a&gt;: Decode the first frame of a BMP-encoded image to a uint8 tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_gif&quot;&gt;&lt;code&gt;decode_gif(...)&lt;/code&gt;&lt;/a&gt;: Decode the first frame of a GIF-encoded image to a uint8 tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_image&quot;&gt;&lt;code&gt;decode_image(...)&lt;/code&gt;&lt;/a&gt;: Convenience function for &lt;code&gt;decode_bmp&lt;/code&gt;, &lt;code&gt;decode_gif&lt;/code&gt;, &lt;code&gt;decode_jpeg&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_jpeg&quot;&gt;&lt;code&gt;decode_jpeg(...)&lt;/code&gt;&lt;/a&gt;: Decode a JPEG-encoded image to a uint8 tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/decode_png&quot;&gt;&lt;code&gt;decode_png(...)&lt;/code&gt;&lt;/a&gt;: Decode a PNG-encoded image to a uint8 or uint16 tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/draw_bounding_boxes&quot;&gt;&lt;code&gt;draw_bounding_boxes(...)&lt;/code&gt;&lt;/a&gt;: Draw bounding boxes on a batch of images.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/encode_jpeg&quot;&gt;&lt;code&gt;encode_jpeg(...)&lt;/code&gt;&lt;/a&gt;: JPEG-encode an image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/encode_png&quot;&gt;&lt;code&gt;encode_png(...)&lt;/code&gt;&lt;/a&gt;: PNG-encode an image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/extract_glimpse&quot;&gt;&lt;code&gt;extract_glimpse(...)&lt;/code&gt;&lt;/a&gt;: Extracts a glimpse from the input tensor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/extract_jpeg_shape&quot;&gt;&lt;code&gt;extract_jpeg_shape(...)&lt;/code&gt;&lt;/a&gt;: Extract the shape information of a JPEG-encoded image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/flip_left_right&quot;&gt;&lt;code&gt;flip_left_right(...)&lt;/code&gt;&lt;/a&gt;: Flip an image horizontally (left to right).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/flip_up_down&quot;&gt;&lt;code&gt;flip_up_down(...)&lt;/code&gt;&lt;/a&gt;: Flip an image vertically (upside down).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/grayscale_to_rgb&quot;&gt;&lt;code&gt;grayscale_to_rgb(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from Grayscale to RGB.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/hsv_to_rgb&quot;&gt;&lt;code&gt;hsv_to_rgb(...)&lt;/code&gt;&lt;/a&gt;: Convert one or more images from HSV to RGB.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/image_gradients&quot;&gt;&lt;code&gt;image_gradients(...)&lt;/code&gt;&lt;/a&gt;: Returns image gradients (dy, dx) for each color channel.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/is_jpeg&quot;&gt;&lt;code&gt;is_jpeg(...)&lt;/code&gt;&lt;/a&gt;: Convenience function to check if the 'contents' encodes a JPEG image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/non_max_suppression&quot;&gt;&lt;code&gt;non_max_suppression(...)&lt;/code&gt;&lt;/a&gt;: Greedily selects a subset of bounding boxes in descending order of score.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/pad_to_bounding_box&quot;&gt;&lt;code&gt;pad_to_bounding_box(...)&lt;/code&gt;&lt;/a&gt;: Pad &lt;code&gt;image&lt;/code&gt; with zeros to the specified &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/per_image_standardization&quot;&gt;&lt;code&gt;per_image_standardization(...)&lt;/code&gt;&lt;/a&gt;: Linearly scales &lt;code&gt;image&lt;/code&gt; to have zero mean and unit norm.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/psnr&quot;&gt;&lt;code&gt;psnr(...)&lt;/code&gt;&lt;/a&gt;: Returns the Peak Signal-to-Noise Ratio between a and b.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_brightness&quot;&gt;&lt;code&gt;random_brightness(...)&lt;/code&gt;&lt;/a&gt;: Adjust the brightness of images by a random factor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_contrast&quot;&gt;&lt;code&gt;random_contrast(...)&lt;/code&gt;&lt;/a&gt;: Adjust the contrast of an image by a random factor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_flip_left_right&quot;&gt;&lt;code&gt;random_flip_left_right(...)&lt;/code&gt;&lt;/a&gt;: Randomly flip an image horizontally (left to right).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_flip_up_down&quot;&gt;&lt;code&gt;random_flip_up_down(...)&lt;/code&gt;&lt;/a&gt;: Randomly flips an image vertically (upside down).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_hue&quot;&gt;&lt;code&gt;random_hue(...)&lt;/code&gt;&lt;/a&gt;: Adjust the hue of an RGB image by a random factor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/random_saturation&quot;&gt;&lt;code&gt;random_saturation(...)&lt;/code&gt;&lt;/a&gt;: Adjust the saturation of an RGB image by a random factor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_area&quot;&gt;&lt;code&gt;resize_area(...)&lt;/code&gt;&lt;/a&gt;: Resize &lt;code&gt;images&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; using area interpolation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_bicubic&quot;&gt;&lt;code&gt;resize_bicubic(...)&lt;/code&gt;&lt;/a&gt;: Resize &lt;code&gt;images&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; using bicubic interpolation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_bilinear&quot;&gt;&lt;code&gt;resize_bilinear(...)&lt;/code&gt;&lt;/a&gt;: Resize &lt;code&gt;images&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; using bilinear interpolation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_image_with_crop_or_pad&quot;&gt;&lt;code&gt;resize_image_with_crop_or_pad(...)&lt;/code&gt;&lt;/a&gt;: Crops and/or pads an image to a target width and height.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_images&quot;&gt;&lt;code&gt;resize_images(...)&lt;/code&gt;&lt;/a&gt;: Resize &lt;code&gt;images&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; using the specified &lt;code&gt;method&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/resize_nearest_neighbor&quot;&gt;&lt;code&gt;resize_nearest_neighbor(...)&lt;/code&gt;&lt;/a&gt;: Resize &lt;code&gt;images&lt;/code&gt; to &lt;code&gt;size&lt;/code&gt; using nearest neighbor interpolation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/rgb_to_grayscale&quot;&gt;&lt;code&gt;rgb_to_grayscale(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from RGB to Grayscale.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/rgb_to_hsv&quot;&gt;&lt;code&gt;rgb_to_hsv(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from RGB to HSV.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/rgb_to_yiq&quot;&gt;&lt;code&gt;rgb_to_yiq(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from RGB to YIQ.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/rgb_to_yuv&quot;&gt;&lt;code&gt;rgb_to_yuv(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from RGB to YUV.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/rot90&quot;&gt;&lt;code&gt;rot90(...)&lt;/code&gt;&lt;/a&gt;: Rotate image(s) counter-clockwise by 90 degrees.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/sample_distorted_bounding_box&quot;&gt;&lt;code&gt;sample_distorted_bounding_box(...)&lt;/code&gt;&lt;/a&gt;: Generate a single randomly distorted bounding box for an image.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/sobel_edges&quot;&gt;&lt;code&gt;sobel_edges(...)&lt;/code&gt;&lt;/a&gt;: Returns a tensor holding Sobel edge maps.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/ssim&quot;&gt;&lt;code&gt;ssim(...)&lt;/code&gt;&lt;/a&gt;: Computes SSIM index between img1 and img2.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/ssim_multiscale&quot;&gt;&lt;code&gt;ssim_multiscale(...)&lt;/code&gt;&lt;/a&gt;: Computes the MS-SSIM between img1 and img2.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/total_variation&quot;&gt;&lt;code&gt;total_variation(...)&lt;/code&gt;&lt;/a&gt;: Calculate and return the total variation for one or more images.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/transpose_image&quot;&gt;&lt;code&gt;transpose_image(...)&lt;/code&gt;&lt;/a&gt;: Transpose image(s) by swapping the height and width dimension.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/yiq_to_rgb&quot;&gt;&lt;code&gt;yiq_to_rgb(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from YIQ to RGB.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/image/yuv_to_rgb&quot;&gt;&lt;code&gt;yuv_to_rgb(...)&lt;/code&gt;&lt;/a&gt;: Converts one or more images from YUV to RGB.&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 22:19:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/9049114.html</dc:identifier>
</item>
<item>
<title>PHP后端之验证码 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/9049019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/9049019.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;PHP后端之验证码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打算写一些实际开发中遇到的东西。我这个人记性不好，觉得记下来，以后就算想找，也能找得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PHP，可能很长一段时间都不会使用了。所以还是留一些记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还有一些服务器架设的总结，之后整理了，会发布出来。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一，问题：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相信大家都有以下的经历：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，上学的时候，猜解家里电脑的登陆密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，忘了行李箱密码，让后凄惨地一个个试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，大学，一个个试学校内网的密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;也许，你会觉得这样一个个试，很麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那就编写一个程序，来暴力猜解多好啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际情况，就是有人做这样的事情，为此，黑客们还做出了各种包含常用密码字段的破解字典来提高破解速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，为了防止这种破解。人们想出了一些方法，来杜绝这种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，密码设置得没有规律性（就是不用姓名，生日什么的）(具体密码相关，以后有机会我会写一篇专门的文章）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，限制登陆尝试次数（在一段时间内只允许登陆有限次数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，验证码。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中，验证码经过这么些年的变化，有了许多的分支。从简单输入4位数字，再到顺序点击图片中文字（如12306，简直折磨人），还有现在的邮件，短信，语音等验证码（如steam，阿里云等）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中这些验证码方式又可以按照发送方大致分为两类：一类是通过本地服务器来提供服务（如4位数字等），另一类是通过其他服务提供商来提供服务（如短信，电话等）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，由于验证码的流行，还有专门的服务提供商。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实，验证码最初完全是为了杜绝机器暴力破解。而现在的验证码，如短信，完全可以确认人的身份（所以现在有的登陆完全不需要密码，只需要账号和验证码）。其价值已经大大提高了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天，只做一个本地服务器制作的验证码。其他的本地验证码完全可以照此类变形。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二，实现原理：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PHP支持许多的函数，其中一些函数完全可以将字符串，制作为图片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完全可以将画布背景放上一些乱码，再挑选四个数字（你也可以添加字母，但是那样会比较花）。按照不同的角度放在画布上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意返回的文件格式即可。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;三，实际代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Created by PhpStorm.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * User: curek
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Date: 2/5/2018
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Time: 3:57
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字符集&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;header&lt;/span&gt;(&quot;Content-Type:text/html;charset=utf-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图宽&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;$width&lt;/span&gt; = 150&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图高&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;$height&lt;/span&gt; = 40&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码的长度&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;$length&lt;/span&gt; = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体样式&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;$fontstyle&lt;/span&gt; = './font/MSYHBD.TTF'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;$fontsize&lt;/span&gt; = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建画布&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;$img&lt;/span&gt; = imagecreatetruecolor(&lt;span&gt;$width&lt;/span&gt;, &lt;span&gt;$height&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.分配颜色&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;$bgcolor&lt;/span&gt; = imagecolorallocate(&lt;span&gt;$img&lt;/span&gt;, &lt;span&gt;mt_rand&lt;/span&gt;(180, 240), &lt;span&gt;mt_rand&lt;/span&gt;(180, 240), &lt;span&gt;mt_rand&lt;/span&gt;(180, 240&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.填充&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; imagefill(&lt;span&gt;$img&lt;/span&gt;, 0, 0, &lt;span&gt;$bgcolor&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.画干扰&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;$str&lt;/span&gt; = '~~~~~~~~~~~~~~~~~~~~!@#$%%^^&amp;amp;*()_+.,[]:&amp;lt;&amp;gt;';   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手写一些奇葩符号&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;$str_len&lt;/span&gt; = &lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;$i&lt;/span&gt; = 0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; &lt;span&gt;$str_len&lt;/span&gt;; &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配字体颜色&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;$fontcolor&lt;/span&gt; = imagecolorallocate(&lt;span&gt;$img&lt;/span&gt;, &lt;span&gt;mt_rand&lt;/span&gt;(0, 150), &lt;span&gt;mt_rand&lt;/span&gt;(0, 150), &lt;span&gt;mt_rand&lt;/span&gt;(0, 150&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     imagettftext(&lt;span&gt;$img&lt;/span&gt;, 8, &lt;span&gt;mt_rand&lt;/span&gt;(0, 360), &lt;span&gt;mt_rand&lt;/span&gt;(0, &lt;span&gt;$width&lt;/span&gt;), &lt;span&gt;mt_rand&lt;/span&gt;(0, &lt;span&gt;$height&lt;/span&gt;), &lt;span&gt;$fontcolor&lt;/span&gt;, &lt;span&gt;$fontstyle&lt;/span&gt;, &lt;span&gt;$str&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.生成随机验证码&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;$code_small&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt;('a', 'z'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;$code_big&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt;('A', 'Z'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;$code_num&lt;/span&gt; = &lt;span&gt;range&lt;/span&gt;('0', '9'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.合并成一个数组&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;$list&lt;/span&gt; = &lt;span&gt;array_merge&lt;/span&gt;(&lt;span&gt;$code_small&lt;/span&gt;, &lt;span&gt;$code_big&lt;/span&gt;, &lt;span&gt;$code_num&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.随机打乱顺序&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;shuffle&lt;/span&gt;(&lt;span&gt;$list&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.用于储存验证码&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;$code&lt;/span&gt; = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;$i&lt;/span&gt; = 0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; &lt;span&gt;$length&lt;/span&gt;; &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配字体颜色
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    //分配字体颜色&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;$fontcolor&lt;/span&gt; = imagecolorallocate(&lt;span&gt;$img&lt;/span&gt;, &lt;span&gt;mt_rand&lt;/span&gt;(0, 150), &lt;span&gt;mt_rand&lt;/span&gt;(0, 150), &lt;span&gt;mt_rand&lt;/span&gt;(0, 150&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    imagettftext(
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;$img&lt;/span&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作目标&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;$fontsize&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;mt_rand&lt;/span&gt;(-40, 40), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;角度&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;         ((&lt;span&gt;$i&lt;/span&gt; * &lt;span&gt;$fontsize&lt;/span&gt;) + (&lt;span&gt;$width&lt;/span&gt; - (&lt;span&gt;$length&lt;/span&gt; + &lt;span&gt;$fontsize&lt;/span&gt;) &amp;gt;&amp;gt; 1)),   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体横坐标X&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         ((&lt;span&gt;$height&lt;/span&gt; - &lt;span&gt;$fontsize&lt;/span&gt; &amp;gt;&amp;gt; 1) + &lt;span&gt;$fontsize&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体纵坐标Y&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;$fontcolor&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体颜色&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;$fontstyle&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体样式&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;$list&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;]   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体内容&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;$code&lt;/span&gt; .= &lt;span&gt;$list&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.开启会话&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.将正确验证码放入session&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;['code'] = &lt;span&gt;$code&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;header&lt;/span&gt;('Content-Type:image/png'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; imagepng(&lt;span&gt;$img&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; imagedestroy(&lt;span&gt;$img&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; ?&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;PS：需要的说明都写在了注释内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS2：部分代码参考网络资源，不过地址记不得了。这是很久之前的项目了。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;四，完成效果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987666/201805/987666-20180517013031590-733891450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;五，总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的诸如短信验证等，代码都比较简单，而且服务提供商都有教程。所以不在此赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证码用到的地方还是很多的。我们应该学会并理解原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;起码看到别人家网站上的验证码，能够知道它的运行原理。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 17:24:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tiancheng-Duan/p/9049019.html</dc:identifier>
</item>
<item>
<title>C# Ioc、DI、Unity、TDD的一点想法和实践 - 毛毛虫</title>
<link>http://www.cnblogs.com/catzhou/p/9048966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catzhou/p/9048966.html</guid>
<description>&lt;p&gt;&lt;strong&gt;面向对象设计（OOD）有助于我们开发出高性能、易扩展以及易复用的程序。其中，OOD有一个重要的思想那就是依赖倒置原则（DIP）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖倒置原则（DIP）：&lt;/strong&gt;一种软件架构设计的原则（抽象概念）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制反转（IoC）：&lt;/strong&gt;一种反转流、依赖和接口的方式（DIP的具体实现方式）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖注入（DI）：&lt;/strong&gt;IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IoC容器：&lt;/strong&gt;依赖注入的&lt;strong&gt;框架&lt;/strong&gt;，用来映射依赖，管理对象创建和生存周期（DI框架）、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unity：&lt;/strong&gt;是微软推出的IOC框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TDD：&lt;/strong&gt;测试驱动开发，是敏捷开发中的一项核心实践和技术，也是一种设计方法论&lt;/p&gt;

&lt;p&gt;上面的内容都是抄的（英文不好，放在这里备查），相关的内容看了一些，不明觉厉。&lt;/p&gt;

&lt;p&gt;曾经写了一个酒店读写房卡的程序，不同的酒店门锁是不一样的，同一个酒店也有可能更换门锁，程序流程：&lt;/p&gt;
&lt;p&gt;1.通过Api获取当前酒店的门锁类型&lt;/p&gt;
&lt;p&gt;2.如果需要则下载对应门锁的dll&lt;/p&gt;
&lt;p&gt;3.实现读写功能&lt;/p&gt;
&lt;p&gt;一、定义接口&lt;/p&gt;
&lt;p&gt;新建一个类库（Lock.Interface），代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace Lock
{
    public interface ILock
    {
        /// &amp;lt;summary&amp;gt;
        /// 门锁初始化
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;password&quot;&amp;gt;初始化密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        bool Init(int password);

    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;是不是算是IoC了？（我不确定）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二、单元测试&lt;/p&gt;
&lt;p&gt;新建一个单元测试项目（Lock.Tests）,代码如下：&lt;/p&gt;
&lt;p&gt;1.门锁A单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 门锁A测试
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [TestClass()]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockATests
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化，password为正奇数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [TestMethod()]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitTest()
        {
            ILock l &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LockA();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = l.Init(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            Assert.AreEqual(ret, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            ret &lt;/span&gt;= l.Init(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            Assert.AreEqual(ret, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            ret &lt;/span&gt;= l.Init(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            Assert.AreEqual(ret, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.门锁B单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 门锁B测试
    /// &amp;lt;/summary&amp;gt;
    [TestClass()]
    public class LockBTests
    {
        /// &amp;lt;summary&amp;gt;
        /// 初始化测试，password为正偶数
        /// &amp;lt;/summary&amp;gt;
        [TestMethod()]
        public void InitTest()
        {
            ILock l = new LockB();
            var ret = l.Init(1);
            Assert.AreEqual(ret, false);
            ret = l.Init(2);
            Assert.AreEqual(ret, true);
            ret = l.Init(-1);
            Assert.AreEqual(ret, false);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然编译都不能通过（不能通过编译也是一种测试）&lt;/p&gt;
&lt;p&gt;三、定义类&lt;/p&gt;
&lt;p&gt; 1.创建门锁A类库（Lock.LockA），代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 门锁A
    /// &amp;lt;/summary&amp;gt;
    public class LockA : ILock
    {
        
        /// &amp;lt;summary&amp;gt;
        /// 初始化
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;password&quot;&amp;gt;正确密码是正奇数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public bool Init(int password)
        {
            return password &amp;gt; 0 &amp;amp;&amp;amp; (password % 2) == 1;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.创建门锁B类库（Lock.LockB），代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 门锁B
    /// &amp;lt;/summary&amp;gt;
    public class LockB : ILock
    {
        /// &amp;lt;summary&amp;gt;
        /// 初始化
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;password&quot;&amp;gt;正确密码是正偶数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public bool Init(int password)
        {
            return password &amp;gt; 0 &amp;amp;&amp;amp; (password % 2) == 0;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别编译成功后，回到测试项目，添加引用，编译通过，运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/10915/201805/10915-20180516235838361-63697486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算不算TDD？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;四、主程序&lt;/p&gt;
&lt;p&gt;1.添加控制台项目&lt;/p&gt;
&lt;p&gt;2.添加Unity（5.8.6）包&lt;/p&gt;
&lt;p&gt;3.修改App.Config为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;unity&quot; type=&quot;Microsoft.Practices.Unity.Configuration.UnityConfigurationSection,Unity.Configuration, Version=5.2.1.0, Culture=neutral, PublicKeyToken=6d32ff45e0ccc69f&quot; /&amp;gt;
&lt;span&gt;    &amp;lt;!--上一些的内容网上复制过来有错误，后来查看UnityConfigurationSection的定义，复制了对应的程序集
    type=&quot;命名空间.类名,程序集&quot;
    --&amp;gt;&lt;/span&gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;unity&amp;gt;
    &amp;lt;containers&amp;gt;
      &amp;lt;container name=&quot;LockA&quot;&amp;gt;
        &amp;lt;register type=&quot;Lock.ILock,Lock.Interface&quot;  mapTo=&quot;Lock.LockA,Lock.LockA&quot; &amp;gt;&amp;lt;/register&amp;gt;
      &amp;lt;/container&amp;gt;
      &amp;lt;container name=&quot;LockB&quot;&amp;gt;
        &amp;lt;register type=&quot;Lock.ILock,Lock.Interface&quot;  mapTo=&quot;Lock.LockB,Lock.LockB&quot;&amp;gt;&amp;lt;/register&amp;gt;
      &amp;lt;/container&amp;gt;
    &amp;lt;/containers&amp;gt;
  &amp;lt;/unity&amp;gt;
  &amp;lt;startup&amp;gt;
    &amp;lt;supportedRuntime version=&quot;v4.0&quot; sku=&quot;.NETFramework,Version=v4.5.2&quot; /&amp;gt;
  &amp;lt;/startup&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.引用接口&lt;/p&gt;
&lt;p&gt;5.Main方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        static void Main(string[] args)
        {
            var container = new UnityContainer();
            UnityConfigurationSection config = (UnityConfigurationSection)ConfigurationManager.GetSection(UnityConfigurationSection.SectionName);
            config.Configure(container, &lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;ILock l = container.Resolve&amp;lt;ILock&amp;gt;();
            Console.WriteLine(l.Init(2));
            Console.WriteLine(l.Init(1));
            Console.WriteLine(l.Init(-1));
&lt;br/&gt;Console.ReadKey();
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.复制门锁A的dll复制到运行目录&lt;/p&gt;
&lt;p&gt;7.运行结果如为：False、True、False，是门锁A的结果&lt;/p&gt;
&lt;p&gt;8.将“LockA”改成“LockB”，并将门锁B的dll复制到运行目录，运行结果为True、False、False是门锁B的结果&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算DI吧？咱都用了Unity了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;至此，基本实现了想要的功能，未来新酒店要增加门锁C、门锁D都没问题，只有老酒店改成门锁E的问题没解决（估计可以通过动态修改config文件实现，也不知道有没有更好地办法）。&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 16:36:00 +0000</pubDate>
<dc:creator>毛毛虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catzhou/p/9048966.html</dc:identifier>
</item>
<item>
<title>Spring中的循环依赖 - BeginnerH</title>
<link>http://www.cnblogs.com/xz816111/p/9048908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xz816111/p/9048908.html</guid>
<description>&lt;p&gt;在使用Spring时，如果主要采用&lt;code&gt;基于构造器&lt;/code&gt;的依赖注入方式，则可能会遇到循环依赖的情况，简而言之就是&lt;code&gt;Bean A&lt;/code&gt;的构造器依赖于&lt;code&gt;Bean B&lt;/code&gt;，&lt;code&gt;Bean B&lt;/code&gt;的构造器又依赖于&lt;code&gt;Bean A&lt;/code&gt;。在这种情况下Spring会在编译时抛出&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;class-a&quot;&gt;Class A&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ClassA {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ClassB classB;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassA&lt;/span&gt;(ClassB classB) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;classB&lt;/span&gt; = classB;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;printClass&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Class A = &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Class B = &quot;&lt;/span&gt; + classB);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;class-b&quot;&gt;Class B&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ClassB {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ClassA classA;

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassB&lt;/span&gt;(ClassA classA) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;classA&lt;/span&gt; = classA;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;printClass&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Class A = &quot;&lt;/span&gt; + classA);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Class B = &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@ContextConfiguration&lt;/span&gt;(classes = {ClassA.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, ClassB.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;})
&lt;span class=&quot;fu&quot;&gt;@RunWith&lt;/span&gt;(SpringRunner.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyTest {
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ClassA classA;
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ClassB classB;

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;() {
        classA.&lt;span class=&quot;fu&quot;&gt;printClass&lt;/span&gt;();
        classB.&lt;span class=&quot;fu&quot;&gt;printClass&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这时候运行测试就会发现抛出了&lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;异常。产生这种情况的原因是，&lt;strong&gt;Spring在创建Bean时，会首先实例化对象，然后再注入依赖&lt;/strong&gt;。假设Spring首先创建&lt;code&gt;Class A&lt;/code&gt;，那么就会发现在构造器里有&lt;code&gt;Class B&lt;/code&gt;的依赖，所以就会转去创建&lt;code&gt;Class B&lt;/code&gt;，又在&lt;code&gt;Class B&lt;/code&gt;的构造器里发现了对&lt;code&gt;Class A&lt;/code&gt;的依赖，而此时&lt;code&gt;Class A&lt;/code&gt;是还未初始化完的，因此又会转去创建&lt;code&gt;Class A&lt;/code&gt;，这样就陷入了死循环。&lt;/p&gt;

&lt;p&gt;换成&lt;code&gt;基于setter&lt;/code&gt;的依赖注入即可解决这个问题。因为&lt;code&gt;基于setter&lt;/code&gt;的依赖注入会首先调用默认构造函数来实例化对象，然后再调用&lt;code&gt;setter&lt;/code&gt;实现依赖注入。这样在对象实例化的阶段就没有了任何依赖，因此&lt;code&gt;Class A&lt;/code&gt;实例化完成后再调用&lt;code&gt;Class B&lt;/code&gt;，&lt;code&gt;Class B&lt;/code&gt;实例化完成后开始设值，而这时&lt;code&gt;Class A&lt;/code&gt;已经是实例化完成了的，所以可以成功引用到&lt;code&gt;Class A&lt;/code&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 16:17:00 +0000</pubDate>
<dc:creator>BeginnerH</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xz816111/p/9048908.html</dc:identifier>
</item>
<item>
<title>[ 搭建Redis本地服务器实践系列二 ] ：图解CentOS7配置Redis - 野原新之助，嘿</title>
<link>http://www.cnblogs.com/tczeus/p/9048890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tczeus/p/9048890.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一章 &lt;a href=&quot;http://www.cnblogs.com/tczeus/p/9042466.html&quot;&gt;&lt;span&gt;[ 搭建Redis本地服务器实践系列一 ] ：图解CentOS7安装Redis&lt;/span&gt;&lt;/a&gt; 详细的介绍了Redis的安装步骤，那么只是安装完成，此时的Redis服务器还无法正常运作，我们需要对其进行一些配置，这个章节我们重点来讲解下如何对Redis配置文件进行配置才能顺利的启动Redis服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要了解Reids的配置项，我们需要先来认识一个脚本文件redis_init_script，从名字我们就能看出来，他就是Redis的初始化脚本，那么这个脚本文件长什么样子，里面有什么内容，又该怎么找到他呢？哈哈哈，不卖关子了，小伙伴们可以在解压出来的Redis文件夹中找到，文件目录地址：redis-4.0.9/utils/redis_init_script&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/sh&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; chkconfig:   2345 90 10&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Simple Redis init.d script conceived to work on Linux systems&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; as it does use of the /proc filesystem.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务的监听端口&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; REDISPORT=6379
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis-server的默认执行路径（redis的安装目录）&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; EXEC=/usr/local/redis/4.0.9/bin/redis-&lt;span&gt;server
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis-cli的默认执行路径（redis的安装目录）&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; CLIEXEC=/usr/local/redis/4.0.9/bin/redis-&lt;span&gt;cli
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务运行进程文件路径&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; PIDFILE=/var/run/redis_&lt;span&gt;${REDISPORT}&lt;/span&gt;&lt;span&gt;.pid
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务启动所需的配置文件路径&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; CONF=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/redis/${REDISPORT}.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;  
&lt;span&gt;18&lt;/span&gt;  
&lt;span&gt;19&lt;/span&gt; case &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    start)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        then
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE exists, process is already running or crashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting Redis server...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;$EXEC&lt;/span&gt; &lt;span&gt;$CONF&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        fi
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    stop)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ ! &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        then
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE does not exist, process is not running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 PID=$(cat &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;$CLIEXEC&lt;/span&gt; -p &lt;span&gt;$REDISPORT&lt;/span&gt;&lt;span&gt; shutdown
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; [ -x /proc/&lt;span&gt;${PID}&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                     echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Waiting for Redis to shutdown ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                     sleep 1
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                done
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis stopped&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        fi
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     *&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please use start or stop as first argument&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; esac
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;恩，咋一看这个初始化脚本还真是繁多，不过不要被他的表面给吓住，细看一下还是非常容易理解的，既然我们要将Redis作为一项服务来启动，那么我们接下来要做的第一件事情就是将配置好的初始化脚本存放到目录:~/etc/init.d中，这里我们将名称修改为redis，短一点好记。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180516230812418-1993955061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，服务初始化脚本已经放置到位，为什么一定要放到路径~/etc/init.d中，这里就不多说了，不清楚的的小伙伴可以度娘一下哦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们来认识下Redis服务启动所需的配置文件，同样的我们也可以在解压出来的Redis文件夹中找到，文件目录地址：redis-4.0.9/redis.conf，这个文件和我们的Redis服务初始化脚本有什么关联，亦或者在初始化脚本中有何提现？细心的小伙伴可能已经发现了，在我们的初始化脚本中有这么一段配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务启动所需的配置文件路径&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; CONF=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/redis/${REDISPORT}.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;没错，CONF设置的就是Redis服务启动所需的配置文件路径，我们下面要做的第二件事情就是将配置文件redis.conf，存放到/etc/redis目录下并以端口6379作为文件名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180516232838960-1497795458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此为止，最重要的两件事情已经完成，接下来我们需要对文件/etc/redis/6379.conf进行必要的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置：daemonize为yes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;描述：Redis以守护进程方式运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180516234522112-653285437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上事项完成后，接下来就是见证奇迹的时候，我们来尝试启动下Redis服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; service redis start&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180516235040053-1663381822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你看到了上面画面，那么恭喜你，你已经成功的启动了Redis服务，我们可以通过命令来查看下Redis进程来确认下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; ps -ef | grep -i redis&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180516235549564-378428336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以看出，Redis服务运行进程ID为5339，接下来我们尝试停止下Redis服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; service redis stop&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180517000033972-787619348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，今天就写到这里吧，希望对有需要小伙伴们能有所帮助。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 16:03:00 +0000</pubDate>
<dc:creator>野原新之助，嘿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tczeus/p/9048890.html</dc:identifier>
</item>
<item>
<title>Java高并发之无锁与Atomic源码分析 - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/9022525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/9022525.html</guid>
<description>&lt;h3&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;CAS原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AtomicInteger&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Unsafe&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AtomicReference&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AtomicStampedReference&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AtomicIntegerArray&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AtomicIntegerFieldUpdater&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无锁的Vector&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无锁即无障碍的运行, 所有线程都可以到达临界区, 接近于无等待.&lt;/p&gt;
&lt;p&gt;无锁采用CAS(compare and swap)算法来处理线程冲突, 其原理如下&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;CAS原理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;CAS包含3个参数CAS(V,E,N).V表示要更新的变量, E表示预期值, N表示新值.&lt;/p&gt;
&lt;p&gt;仅当V值等于E值时, 才会将V的值设为N, 如果V值和E值不同, 则说明已经有其他线程做了更新, 则当前线程什么&lt;/p&gt;
&lt;p&gt;都不做. 最后, CAS返回当前V的真实值. CAS操作是抱着乐观的态度进行的, 它总是认为自己可以成功完成操作.&lt;/p&gt;
&lt;p&gt;当多个线程同时使用CAS操作一个变量时, 只有一个会胜出, 并成功更新, 其余均会失败.失败的线程不会被挂起,&lt;/p&gt;
&lt;p&gt;仅是被告知失败, 并且允许再次尝试, 当然也允许失败的线程放弃操作.基于这样的原理, CAS操作即时没有锁,&lt;/p&gt;
&lt;p&gt;也可以发现其他线程对当前线程的干扰, 并进行恰当的处理.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外, 虽然上述步骤繁多, 实际上CAS整一个操作过程是一个原子操作, 它是由一条CPU指令完成的,&lt;/p&gt;
&lt;p&gt;从指令层保证操作可靠, 不会被多线程干扰.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无锁与volatile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无锁可以通过cas来保证原子性与线程安全, 他与volatile什么区别呢?&lt;/p&gt;
&lt;p&gt;当给变量加了volatile关键字, 表示该变量对所有线程可见, &lt;strong&gt;但不保证原子性&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;以volatile i, i++为例, 分为以下四步:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载i&lt;/li&gt;
&lt;li&gt;对i进行+1&lt;/li&gt;
&lt;li&gt;回写i的值&lt;/li&gt;
&lt;li&gt;用内存屏障通知其他线程i的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中前三步是线程不安全的, 可能其他线程会对i进行读写.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;因此任何依赖于之前值的操作, 如i++, i = i *10使用volatile都不安全.&lt;/p&gt;
&lt;p&gt;而诸如get/set, boolean这类可以使用volatile.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;AtomicInteger&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;取得当前值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; get() 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置当前值&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置新值，并返回旧值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndSet(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;如果当前值为expect，则设置为u&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; u)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值加1，返回旧值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndIncrement()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值减1，返回旧值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndDecrement() 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值增加delta，返回旧值&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; delta)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值加1，返回新值&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; incrementAndGet() 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值减1，返回新值&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; decrementAndGet() 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;当前值增加delta，返回新值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; addAndGet(&lt;span&gt;int&lt;/span&gt; delta) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;源码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装了一个int对其加减&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    .......
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过unsafe 基于CPU的CAS指令来实现, 可以认为无阻塞.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, valueOffset, expect, update);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    .......
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndIncrement() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; get();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预期值&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; next = current + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSet(current, next)) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果加成功了, 则返回当前值&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果加失败了, 说明其他线程已经修改了数据, 与期望不相符,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 则继续无限循环, 直到成功. 这种乐观锁, 理论上只要等两三个时钟周期就可以设值成功
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相比于直接通过synchronized独占锁的方式操作int, 要大大节约等待时间.&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Demo&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用10个线程打印0-10000, 最终得到结果10w.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicIntegerDemo {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; AtomicInteger i = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10000; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                i.incrementAndGet();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Thread[] ts = &lt;span&gt;new&lt;/span&gt; Thread[10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             ts[k] = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddThread());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            ts[k].start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            ts[k].join();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        System.out.println(i);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Unsafe&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Unsafe类是在sun.misc包下, 可以用于一些非安全的操作，比如：&lt;/p&gt;
&lt;p&gt;根据偏移量设置值, 线程park(), 底层的CAS操作等等.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取类实例中变量的偏移量&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; valueOffset = &lt;strong&gt;unsafe&lt;/strong&gt;.objectFieldOffset(AtomicInteger.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;value&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于偏移量对值进行操作&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;strong&gt;unsafe&lt;/strong&gt;.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, expect, update);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;获得给定对象偏移量上的int值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getInt(Object o, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置给定对象偏移量上的int值&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putInt(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;获得字段在对象中的偏移量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; objectFieldOffset(Field f);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置给定对象的int值，使用volatile语义&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putIntVolatile(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;获得给定对象对象的int值，使用volatile语义&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getIntVolatile(Object o, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;和putIntVolatile()一样，但是它要求被操作字段就是volatile类型的&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putOrderedInt(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; x);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;AtomicReference&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;与AtomicInteger类似, 只是里面封装了一个对象, 而不是int, 对引用进行修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;get()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;set(V)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;compareAndSet()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; getAndSet(V)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用10个线程, 同时尝试修改AtomicReference中的String, 最终只有一个线程可以成功.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicReference;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicReferenceTest {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicReference&amp;lt;String&amp;gt; attxnicStr = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;String&amp;gt;(&quot;abc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         Thread.sleep(Math.abs((&lt;span&gt;int&lt;/span&gt;) (Math.random() * 100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (attxnicStr.compareAndSet(&quot;abc&quot;, &quot;def&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; change value to &quot; +&lt;span&gt; attxnicStr.get());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; change failed!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }.start();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;AtomicStampedReference&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;也是封装了一个引用, 主要解决ABA问题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程一准备用CAS将变量的值由A替换为B, 在此之前线程二将变量的值由A替换为C, 线程三又将C替换为A, 然后线程一执行CAS时发现变量的值仍然为A, 所以线程一CAS成功.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(V expectedReference,V newReference,&lt;span&gt;int&lt;/span&gt; expectedStamp,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newStamp)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前对象引用&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getReference()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前时间戳&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getStamp()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置当前对象引用和时间戳&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(V newReference, &lt;span&gt;int&lt;/span&gt; newStamp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部封装了一个Pair对象, 每次对对象操作的时候, stamp + 1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Pair&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; T reference;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; stamp;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Pair(T reference, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; stamp) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.reference =&lt;span&gt; reference;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.stamp =&lt;span&gt; stamp;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; stamp) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;T&amp;gt;&lt;span&gt;(reference, stamp);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Pair&amp;lt;V&amp;gt;&lt;span&gt; pair;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行cas操作的时候, 会对比stamp的值&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; compareAndSet(V   expectedReference,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                                 V   newReference,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                                  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedStamp,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                                  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newStamp) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Pair&amp;lt;V&amp;gt; current =&lt;span&gt; pair;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             expectedReference == current.reference &amp;amp;&amp;amp;
&lt;span&gt;24&lt;/span&gt;             expectedStamp == current.stamp &amp;amp;&amp;amp;
&lt;span&gt;25&lt;/span&gt;             ((newReference == current.reference &amp;amp;&amp;amp;
&lt;span&gt;26&lt;/span&gt;               newStamp == current.stamp) ||
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;             casPair(current, Pair.of(newReference, newStamp)));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台使用多个线程对用户充值, 要求只能充值一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicStampedReferenceDemo {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; AtomicStampedReference&amp;lt;Integer&amp;gt; money=&lt;span&gt;new&lt;/span&gt; AtomicStampedReference&amp;lt;Integer&amp;gt;(19,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; staticvoid main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟多个线程同时更新后台数据库，为用户充值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 3 ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; timestamp=&lt;span&gt;money.getStamp();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            newThread() {  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() { 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                            Integerm=&lt;span&gt;money.getReference();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(m&amp;lt;20&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                          &lt;span&gt;if&lt;/span&gt;(money.compareAndSet(m,m+20,timestamp,timestamp+1&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           　　　　　　　　　　　　　　　 System.out.println(&quot;余额小于20元，充值成功，余额:&quot;+money.getReference()+&quot;元&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;余额大于20元，无需充值&quot;);&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                             }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                       }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                } 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }.start();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户消费线程，模拟消费行为&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() { 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;             publicvoid run() { 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;int&lt;/span&gt; timestamp=&lt;span&gt;money.getStamp();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         Integer m=&lt;span&gt;money.getReference();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(m&amp;gt;10&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                              System.out.println(&quot;大于10元&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                           　　&lt;span&gt;if&lt;/span&gt;(money.compareAndSet(m, m-10,timestamp,timestamp+1&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                       　　　　　　 System.out.println(&quot;成功消费10元，余额:&quot;+&lt;span&gt;money.getReference());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                             }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                            System.out.println(&quot;没有足够的金额&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                              &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt; {Thread.sleep(100);} &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            } 
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }.start(); 
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;AtomicIntegerArray&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;支持无锁的数组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得数组第i个下标的元素&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得数组的长度&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数组第i个下标设置为newValue，并返回旧的值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndSet(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将第i个下标的元素加1&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndIncrement(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将第i个下标的元素减1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndDecrement(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将第i个下标的元素增加delta（delta可以是负数）&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndAdd(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; delta)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组本身基地址&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; base = unsafe.arrayBaseOffset(&lt;span&gt;int&lt;/span&gt;[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装了一个数组&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组中对象的宽度, int类型, 4个字节, scale = 4;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; scale = unsafe.arrayIndexScale(&lt;span&gt;int&lt;/span&gt;[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((scale &amp;amp; (scale - 1)) != 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;data type scale not a power of two&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前导0 : 一个数字转为二进制后, 他前面0的个数
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于4来讲, 他就是00000000 00000000 00000000 00000100, 他的前导0 就是29
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以shift = 2&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         shift = 31 -&lt;span&gt; Integer.numberOfLeadingZeros(scale);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取第i个元素&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getRaw(checkedByteOffset(i));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第i个元素, 在数组中的偏移量是多少&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; checkedByteOffset(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;lt; 0 || i &amp;gt;=&lt;span&gt; array.length)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;index &quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; byteOffset(i);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; base : 数组基地址, i &amp;lt;&amp;lt; shift, 其实就是i * 4, 因为这边是int array.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; byteOffset(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i * 4 + base&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; ((&lt;span&gt;long&lt;/span&gt;) i &amp;lt;&amp;lt; shift) +&lt;span&gt; base;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据偏移量从数组中获取数据&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getRaw(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; unsafe.getIntVolatile(array, offset);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Demo&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicIntegerArray;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicArrayDemo {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; AtomicIntegerArray arr = &lt;span&gt;new&lt;/span&gt; AtomicIntegerArray(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10000; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 arr.incrementAndGet(k %&lt;span&gt; arr.length());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Thread[] ts = &lt;span&gt;new&lt;/span&gt; Thread[10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             ts[k] = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddThread());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            ts[k].start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; 10; k++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            ts[k].join();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        System.out.println(arr);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;AtomicIntegerFieldUpdater&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;让普通变量也享受原子操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;AtomicIntegerFieldUpdater.newUpdater()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; incrementAndGet()
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Updater只能修改它可见范围内的变量。因为Updater使用反射得到这个变量。如果变量不可见，就会出错。比如如果score申明为private，就是不可行的。&lt;/li&gt;
&lt;li&gt;为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中未申明这个类型，那么简单得申明一下就行，这不会引起什么问题。&lt;/li&gt;
&lt;li&gt;由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段（Unsafe.objectFieldOffset()不支持静态变量）。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicIntegerFieldUpdaterDemo {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Candidate {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果直接把int改成atomicinteger, 可能对代码破坏比较大
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此使用AtomicIntegerFieldUpdater对score进行封装&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; score;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过反射实现&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicIntegerFieldUpdater&amp;lt;Candidate&amp;gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.&lt;span&gt;class&lt;/span&gt;, &quot;score&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查Updater是否工作正确, allScore的结果应该跟score一致&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger allScore = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Candidate stu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Candidate();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Thread[] t = &lt;span&gt;new&lt;/span&gt; Thread[10000&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             t[i] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (Math.random() &amp;gt; 0.4&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                        scoreUpdater.incrementAndGet(stu);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                        allScore.incrementAndGet();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            t[i].start();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            t[i].join();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         System.out.println(&quot;score=&quot; +&lt;span&gt; stu.score);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         System.out.println(&quot;allScore=&quot; +&lt;span&gt; allScore);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;无锁的Vector&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;jdk中Vector是加锁的, 网上找的一个无锁Vector LockFreeVector, 给他添加了源码中文注释.&lt;/p&gt;
&lt;p&gt;主要关注push_back, 添加元素的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.AbstractList;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicReference;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicReferenceArray;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt; * It is a thread safe and lock-free vector.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt; * This class implement algorithm from:&amp;lt;br&amp;gt;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt; * Lock-free Dynamically Resizable Arrays &amp;lt;br&amp;gt;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;E&amp;gt; type of element in the vector
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LockFreeVector&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; debug = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;     * Size of the first bucket. sizeof(bucket[i+1])=2*sizeof(bucket[i])
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FIRST_BUCKET_SIZE = 8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;     * number of buckets. 30 will allow 8*(2^30-1) elements
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N_BUCKET = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;     * We will have at most N_BUCKET number of buckets. And we have
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;     * sizeof(buckets.get(i))=FIRST_BUCKET_SIZE**(i+1)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;     * 为什么AtomicReferenceArray里再套一个AtomicReferenceArray呢, 类似一个篮子(buckets)里放了很多篮子
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;     * 为了在容量扩展时希望尽可能少的改动原有数据, 因此把一维数组扩展成二维数组.
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;     * 该二维数组并非均衡的分布. 可能第一个数组8个元素, 第二个数组16个元素, 第三个数组32个......
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicReferenceArray&amp;lt;AtomicReferenceArray&amp;lt;E&amp;gt;&amp;gt;&lt;span&gt; buckets;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;E&amp;gt;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WriteDescriptor&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E oldV;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E newV;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; AtomicReferenceArray&amp;lt;E&amp;gt;&lt;span&gt; addr;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; addr_ind;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;         * Creating a new descriptor.
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; addr Operation address 对哪个数组进行写
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; addr_ind  Index of address 指定index
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; oldV old operand
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newV new operand
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; WriteDescriptor(AtomicReferenceArray&amp;lt;E&amp;gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; addr_ind,
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;                               E oldV, E newV) {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.addr =&lt;span&gt; addr;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.addr_ind =&lt;span&gt; addr_ind;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.oldV =&lt;span&gt; oldV;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.newV =&lt;span&gt; newV;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;         * set newV.
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doIt() {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这边失败后重试的逻辑在另外的代码里.&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            addr.compareAndSet(addr_ind, oldV, newV);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;E&amp;gt;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Descriptor&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;volatile&lt;/span&gt; WriteDescriptor&amp;lt;E&amp;gt;&lt;span&gt; writeop;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;         * Create a new descriptor.
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; size Size of the vector
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; writeop Executor write operation
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Descriptor(&lt;span&gt;int&lt;/span&gt; size, WriteDescriptor&amp;lt;E&amp;gt;&lt;span&gt; writeop) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.writeop =&lt;span&gt; writeop;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; completeWrite() {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             WriteDescriptor&amp;lt;E&amp;gt; tmpOp =&lt;span&gt; writeop;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (tmpOp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                tmpOp.doIt();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 writeop = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this is safe since all write to writeop use
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null as r_value.&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AtomicReference&amp;lt;Descriptor&amp;lt;E&amp;gt;&amp;gt;&lt;span&gt; descriptor;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; zeroNumFirst =&lt;span&gt; Integer
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            .numberOfLeadingZeros(FIRST_BUCKET_SIZE);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;     * Constructor.
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LockFreeVector() {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         buckets = &lt;span&gt;new&lt;/span&gt; AtomicReferenceArray&amp;lt;AtomicReferenceArray&amp;lt;E&amp;gt;&amp;gt;&lt;span&gt;(N_BUCKET);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         buckets.set(0, &lt;span&gt;new&lt;/span&gt; AtomicReferenceArray&amp;lt;E&amp;gt;&lt;span&gt;(FIRST_BUCKET_SIZE));
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         descriptor = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;Descriptor&amp;lt;E&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Descriptor&amp;lt;E&amp;gt;(0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;     * add e at the end of vector.
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;     * 把元素e加到vector中
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;     *            element added
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; push_back&lt;/strong&gt;&lt;/span&gt;(E e) {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         Descriptor&amp;lt;E&amp;gt;&lt;span&gt; desc;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         Descriptor&amp;lt;E&amp;gt;&lt;span&gt; newd;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             desc =&lt;span&gt; descriptor.get();
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            desc.completeWrite();
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; desc.size   Vector 本身的大小
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FIRST_BUCKET_SIZE  第一个一维数组的大小&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; pos = desc.size +&lt;span&gt; FIRST_BUCKET_SIZE;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出pos 的前导0&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; zeroNumPos =&lt;span&gt; Integer.numberOfLeadingZeros(pos);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zeroNumFirst  为FIRST_BUCKET_SIZE 的前导0
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bucketInd 数据应该放到哪一个一维数组(篮子)里的&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; bucketInd = zeroNumFirst -&lt;span&gt; zeroNumPos;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 00000000 00000000 00000000 00001000 第一个篮子满 8
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 00000000 00000000 00000000 00011000 第二个篮子满 8 + 16
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 00000000 00000000 00000000 00111000 第三个篮子满 8 + 16 + 32
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... bucketInd其实通过前导0相减, 就是为了得出来当前第几个篮子是空的.
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断这个一维数组是否已经启用, 可能是第一次初始化&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (buckets.get(bucketInd) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;newLen  一维数组的长度, 取前一个数组长度 * 2&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; newLen = 2 * buckets.get(bucketInd - 1&lt;span&gt;).length();
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置失败也没关系, 只要有人初始化成功就行&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;                 buckets.compareAndSet(bucketInd, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt; AtomicReferenceArray&amp;lt;E&amp;gt;&lt;span&gt;(newLen));
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个一位数组中，我在哪个位置
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0x80000000是 10000000 00000000 00000000 00000000
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这句话就是把上述111000, 第一个1变成了0, 得到011000, 即新值的位置.&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idx = (0x80000000&amp;gt;&amp;gt;&amp;gt;zeroNumPos) ^&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过bucketInd与idx来确定元素在二维数组中的位置
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 期望写入的时候, 该位置值是null, 如果非null, 说明其他线程已经写了, 则继续循环.&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt;             newd = &lt;span&gt;new&lt;/span&gt; Descriptor&amp;lt;E&amp;gt;(desc.size + 1, &lt;span&gt;new&lt;/span&gt; WriteDescriptor&amp;lt;E&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                     buckets.get(bucketInd), idx, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, e));
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环cas设值&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;descriptor.compareAndSet(desc, newd));
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;        descriptor.get().completeWrite();
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;     * Remove the last element in the vector.
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; element removed
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop_back() {
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         Descriptor&amp;lt;E&amp;gt;&lt;span&gt; desc;
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         Descriptor&amp;lt;E&amp;gt;&lt;span&gt; newd;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;        E elem;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             desc =&lt;span&gt; descriptor.get();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;            desc.completeWrite();
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; pos = desc.size + FIRST_BUCKET_SIZE - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; bucketInd =&lt;span&gt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                     -&lt;span&gt; Integer.numberOfLeadingZeros(pos);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idx = Integer.highestOneBit(pos) ^&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;             elem =&lt;span&gt; buckets.get(bucketInd).get(idx);
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;             newd = &lt;span&gt;new&lt;/span&gt; Descriptor&amp;lt;E&amp;gt;(desc.size - 1, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;descriptor.compareAndSet(desc, newd));
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elem;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt; &lt;span&gt;     * Get element with the index.
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;     *            index
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; element with the index
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos = index +&lt;span&gt; FIRST_BUCKET_SIZE;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; zeroNumPos =&lt;span&gt; Integer.numberOfLeadingZeros(pos);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; bucketInd = zeroNumFirst -&lt;span&gt; zeroNumPos;
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; idx = (0x80000000&amp;gt;&amp;gt;&amp;gt;zeroNumPos) ^&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buckets.get(bucketInd).get(idx);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; 
&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;     * Set the element with index to e.
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;     *            index of element to be reset
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;     *            element to set
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E e) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos = index +&lt;span&gt; FIRST_BUCKET_SIZE;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; bucketInd =&lt;span&gt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;                 -&lt;span&gt; Integer.numberOfLeadingZeros(pos);
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; idx = Integer.highestOneBit(pos) ^&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         AtomicReferenceArray&amp;lt;E&amp;gt; bucket =&lt;span&gt; buckets.get(bucketInd);
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;             E oldV =&lt;span&gt; bucket.get(idx);
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bucket.compareAndSet(idx, oldV, e))
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldV;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; 
&lt;span&gt;227&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;228&lt;/span&gt; &lt;span&gt;     * reserve more space.
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newSize
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;     *            new size be reserved
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reserve(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newSize) {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; descriptor.get().size;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos = size + FIRST_BUCKET_SIZE - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                 -&lt;span&gt; Integer.numberOfLeadingZeros(pos);
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;lt; 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;             i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; initialSize = buckets.get(i - 1&lt;span&gt;).length();
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;                 - Integer.numberOfLeadingZeros(newSize + FIRST_BUCKET_SIZE - 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;             initialSize *=&lt;span&gt; FIRST_BUCKET_SIZE;
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;             buckets.compareAndSet(i, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; AtomicReferenceArray&amp;lt;E&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;                    initialSize));
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; 
&lt;span&gt;251&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt; &lt;span&gt;     * size of vector.
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; size of vector
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;256&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; descriptor.get().size;
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; 
&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E object) {
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;        push_back(object);
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 16 May 2018 16:02:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/9022525.html</dc:identifier>
</item>
<item>
<title>树莓派+花生棒+leanote搭建自己的笔记服务器 - 落花落雨不落叶</title>
<link>http://www.cnblogs.com/hongrunhui/p/9048842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongrunhui/p/9048842.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;对于一个程序猿来说。女朋友可以（暂时）没有，但是不能没有一个很好的记笔记的应用。因为记笔记可以帮助自己积累学习提升自己。每一次回头看自己记得笔记，你都会有新的理解。&lt;br/&gt;也许有人会说，用有道云啊，有道云就很好啊，你还纠结啥呢？&lt;br/&gt;我是一个对产品需求要求很苛刻的人，也是一个追求性价比的人，所以这里我想说说各个笔记产品的一些缺陷：&lt;/p&gt;
&lt;h4 id=&quot;有道云&quot;&gt;有道云：&lt;/h4&gt;
&lt;p&gt;有道云的优势是&lt;code&gt;笔记预览演示/文件上传及预览&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但对我来说他的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;markdown不支持截图直接粘贴&lt;/code&gt;，所以我一般把截图传到github的issue里或者传到博客园，再粘贴到有道云的markdown的编辑器里（是不是很蠢？）&lt;/li&gt;
&lt;li&gt;既然markdown不支持截图粘贴，所以我用有道云一般都用普通模式，可以直接截图粘贴，但是这个竟然&lt;code&gt;没有代码高亮&lt;/code&gt;，我去不能忍。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;没有脑图&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;有剪藏功能，但是做的很烂&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;leanote蚂蚁笔记&quot;&gt;leanote（蚂蚁笔记）:&lt;/h4&gt;
&lt;p&gt;leanote弥补了有道云markdwon不能粘贴图片的缺陷，他的普通模式也有代码高亮，同时也有思维导图。&lt;/p&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;leanote不能预览演示&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leanote不支持文件预览&lt;/code&gt;（有道云支持，不过对我好像无所谓，工作用的文档一般放在公司内网）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;没有剪藏功能&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有链接分享，但是有博客分享功能（但是有时候我只想分享一个链接而不是我的博客）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;印象笔记&quot;&gt;印象笔记：&lt;/h4&gt;
&lt;p&gt;其实我以前一直是印象笔记的用户，因为印象笔记的剪藏真的做得挺好，但是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;不支持markdown&lt;/code&gt;(虽然可以配马克飞象啥的，但是收费而且麻烦）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;不支持代码高亮&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;演示功能不错，但是收费&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;为知笔记&quot;&gt;为知笔记：&lt;/h4&gt;
&lt;p&gt;没用过，但是我去体验了一下，有链接分享功能，代码高亮好像做的不行，总是没有吸引我的地方，就没用了。&lt;/p&gt;
&lt;p&gt;所以我权衡了一下，准备用leanote,但是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233358289-1163577215.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这表示你不交钱根本不能用，只能当一个本地编辑器用。我很无语，因为&lt;code&gt;50一年很便宜但是每月128M流量&lt;/code&gt;，虽然比印象笔记的&lt;code&gt;60M&lt;/code&gt;限制好点，但是也很少啊。其实我已经准备交钱了，但是突然看到一篇文章：&lt;a href=&quot;https://segmentfault.com/a/1190000004000321&quot;&gt;Leanote 服务器安装&lt;/a&gt;，发现leanote是可以自己搭建服务，前提是你要有服务器。以前在学校用的腾讯1元服务器，但是毕业了就不给用了，自己买又不划算。所以我就想用我的树莓派来作为一个服务器；&lt;/p&gt;
&lt;p&gt;树莓派是一个微型电脑，长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233410320-1083913569.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个树莓派是以前参加Daocloud的活动送的，买的话加上配件大概250块钱。我的树莓派的配置是1G内存，16G存储，够用。按照&lt;a href=&quot;https://segmentfault.com/a/1190000004000321&quot;&gt;Leanote 服务器安装&lt;/a&gt;这篇文章作为参考搭建服务器。我主要说下需要注意的地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;leanote服务端代码一定要下载&lt;code&gt;arm版&lt;/code&gt;，因为树莓派内核是arm7好像，不然下载其他版本leanote服务端代码运行&lt;code&gt;run.sh&lt;/code&gt;会报错，到这里&lt;a href=&quot;https://github.com/leanote/leanote/releases&quot;&gt;下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233444873-1235762545.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;树莓派安装mongodb，只需要&lt;code&gt;sudo apt-get install mongodb&lt;/code&gt;就行，所以安装mongodb不用跟着那篇文章。&lt;/li&gt;
&lt;li&gt;为mongodb数据库添加用户且设置这个用户为管理员之后首页就访问不了了（原因暂时未知），但是可以访问/login，如&lt;code&gt;http://***.***.net:12719/login&lt;/code&gt;（这个端口），
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233514092-1877836135.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家肯定注意到我的域名后面有个端口，啥操作？其实这个域名和端口都是免费的，可以使用花生壳这个工具来映射端口，免费的，实名认证一下就行，每月有1G免费流量，也送域名；不过我用的是我很久以前买的是花生棒，98块钱，&lt;code&gt;花生棒每月有2G流量&lt;/code&gt;。大家也可以用免费的&lt;code&gt;ngrok&lt;/code&gt;。（至于花生棒怎么配置就不说了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233525632-965740125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233533776-768921157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总之就是把内网地址映射成外网可用地址，然后把这个外网地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233540977-1825292012.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233548783-878276270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就OK了，但是要注意账户你得在你搭建的服务上重新注册一个，或者你自己手动迁移你原来的数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233554455-421707500.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，再说下树莓派上的leanote,我是用了一个叫做&lt;code&gt;supervisor&lt;/code&gt;的工具来管理，具体安装配置参考：&lt;a href=&quot;https://blog.csdn.net/xyang81/article/details/51555473&quot;&gt;Supervisor安装与配置（Linux/Unix进程管理工具）&lt;/a&gt;，如有启动失败的情况，多半和权限有关，树莓派默认登录账户是pi，可以切换到root账户来操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233608749-1687837000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233622618-174523656.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是切换到root账户，你之前下载的leanote代码路径可能会变，如一开始我代码是放在pi账户下的&lt;code&gt;~/Projects/leanote/&lt;/code&gt;，但是切换到root账户之后，地址变成了&lt;code&gt;/home/pi/Projects/leanote/bin/run.sh&lt;/code&gt;，最后附上我的Supervisor的配置（名字是&lt;code&gt;leanote.conf&lt;/code&gt;,放在&lt;code&gt;/etc/supervisor/conf.d&lt;/code&gt;下面）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726124/201805/726124-20180516233633560-2032468083.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总之这么搞拿来知识积累是没问题的啦。我还有一个从以前破电脑上拆下来的750G硬盘，这个硬盘接到树莓派上对我来说可以用好久啦。&lt;/p&gt;
&lt;p&gt;最终的成本大概是：树莓派（250）+花生棒（98）=350块钱，就算加上移动硬盘差不多就600块钱吧（如果你用ngrok代替花生棒那就就花买个树莓派的钱），但是你这钱除了可以支持你用来搭建笔记服务，还可以做好多其他事情。&lt;/p&gt;
&lt;p&gt;对于我来说就是花了98块钱买花生棒。所以这笔买卖，划算。&lt;/p&gt;
&lt;p&gt;或许有人会吐槽我扣舍不得给leanote充钱，但我想说的是，我这哪里扣啦，我这是精致的生活好吧。&lt;/p&gt;
&lt;p&gt;好吧，其实我就是扣。&lt;/p&gt;
&lt;p&gt;最后声明一下，我没有给提及的产品打广告。&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 15:46:00 +0000</pubDate>
<dc:creator>落花落雨不落叶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongrunhui/p/9048842.html</dc:identifier>
</item>
<item>
<title>codeforces 983B XOR-pyramid - qrfkickit</title>
<link>http://www.cnblogs.com/kickit/p/9048837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kickit/p/9048837.html</guid>
<description>&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;定义一个函数f(a):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197092/201805/1197092-20180516233356839-1175313648.png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给出一个数组a，有q个询问，每次询问回答在l到r的区间内，连续子串的f函数的最大值。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;画图，来自codeforces &lt;a class=&quot;rated-user user-blue&quot; title=&quot;Expert SheepRanger&quot; href=&quot;http://codeforces.com/profile/SheepRanger&quot;&gt;SheepRanger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197092/201805/1197092-20180516233811947-488109867.png&quot; alt=&quot;&quot; width=&quot;377&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此图可知，f(l,r) = f(l,r-1) ^ f(l+1,r)，多画图哇！&lt;/p&gt;
&lt;p&gt;所以就变成了区间dp，同时维护f(l,r)与ans(l,r)：&lt;/p&gt;
&lt;p&gt;f[l][r] = f[l][r-1] ^ f[l+1][r]&lt;/p&gt;
&lt;p&gt;ans[l][r] = max(f[l][r],ans[l][r-1],ans[l+1][r])。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N = &lt;span&gt;5005&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dp[N][N];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a[N];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ans[N][N];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; n;i++) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i]);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; n;i++) dp[i][i] = ans[i][i] =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt; n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; l = j,r = j+&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= n) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (l == 0 &amp;amp;&amp;amp; r == 5) puts(&quot;gg&quot;);&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             dp[l][r] = dp[l][r-&lt;span&gt;1&lt;/span&gt;] ^ dp[l+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;][r];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             ans[l][r] = max(ans[l][r-&lt;span&gt;1&lt;/span&gt;],ans[l+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;][r]);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             ans[l][r] =&lt;span&gt; max(ans[l][r],dp[l][r]);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;q);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (q--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; l,r;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;l,&amp;amp;&lt;span&gt;r);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         l--,r--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans[l][r]);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 16 May 2018 15:41:00 +0000</pubDate>
<dc:creator>qrfkickit</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kickit/p/9048837.html</dc:identifier>
</item>
</channel>
</rss>