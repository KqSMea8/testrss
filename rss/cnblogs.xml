<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>zuul源码分析-探究原生zuul的工作原理 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9653067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9653067.html</guid>
<description>&lt;p&gt;最近在项目中使用了SpringCloud，基于zuul搭建了一个提供加解密、鉴权等功能的网关服务。鉴于之前没怎么使用过Zuul，于是顺便仔细阅读了它的源码。实际上，zuul原来提供的功能是很单一的：通过一个统一的Servlet入口(ZuulServlet，或者Filter入口，使用ZuulServletFilter)拦截所有的请求，然后通过内建的com.netflix.zuul.IZuulFilter链对请求做拦截和过滤处理。ZuulFilter和javax.servlet.Filter的原理相似，但是它们本质并不相同。javax.servlet.Filter在Web应用中是独立的组件，ZuulFilter是ZuulServlet处理请求时候调用的，后面会详细分析。&lt;/p&gt;

&lt;p&gt;zuul的项目地址是https://github.com/Netflix/zuul，它是著名的&quot;开源框架提供商&quot;Netflix的作品，项目的目的是：Zuul是一个网关服务，提供动态路由、监视、弹性、安全性等。在SpringCloud中引入了zuul，配合Netflix的另一个负载均衡框架Ribbon和Netflix的另一个提供服务发现与注册框架Eureka，可以实现服务的动态路由。值得注意的是，zuul在2.x甚至3.x的分支中已经引入了netty，框架的复杂性大大提高。但是当前的SpringCloud体系并没有升级zuul的版本，目前使用的是zuul1.x的最高版本1.3.1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-1.png&quot; alt=&quot;z-s-c-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们需要阅读它的源码的时候可以选择这个发布版本。值得注意的是，由于这些版本的发布时间已经比较久，有部分插件或者依赖包可能找不到，笔者在构建zuul1.3.1的源码的时候发现这几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、&lt;code&gt;nebula.netflixoss&lt;/code&gt;插件的旧版本已经不再支持，所有build.gradle文件中的&lt;code&gt;nebula.netflixoss&lt;/code&gt;插件的版本修改为5.2.0。&lt;/li&gt;
&lt;li&gt;2、2017年的时候Gradle支持的版本是2.x，笔者这里选择了gradle-2.14，选择高版本的Gradle有可能在构建项目的时候出现&lt;code&gt;jetty&lt;/code&gt;插件不支持。&lt;/li&gt;
&lt;li&gt;3、Jdk最好使用1.8，Gradle构建文件中的sourceCompatibility、targetCompatibility、languageLevel等配置全改为1.8。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，如果使用IDEA进行构建，注意配置项目的Jdk和Java环境，所有配置改为Jdk1.8，Gradle构建成功后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-2.png&quot; alt=&quot;z-s-c-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zuul-1.3.1中提供了一个Web应用的Sample项目，我们直接运行zuul-simple-webapp的Gradle配置中的Tomcat插件即可启动项目，开始Debug之旅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-3.png&quot; alt=&quot;z-s-c-3&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;zuulfilter的加载&quot;&gt;ZuulFilter的加载&lt;/h2&gt;
&lt;p&gt;从Zuul的源码来看，ZuulFilter的加载模式可能跟我们想象的大有不同，Zuul设计的初衷是ZuulFilter是存放在Groovy文件中，可以实现基于最后修改时间进行热加载。我们先看看Zuul核心类之一com.netflix.zuul.filters.FilterRegistry(Filter的注册中心，实际上是ZuulFilter的全局缓存)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterRegistry {
    
    // 饿汉式单例，确保全局只有一个ZuulFilter的缓存
    private static final FilterRegistry INSTANCE = new FilterRegistry();
    public static final FilterRegistry instance() {
        return INSTANCE;
    }

    //缓存字符串到ZuulFilter实例的映射关系，如果是从文件加载，字符串key的格式是：文件绝对路径 + 文件名，当然也可以自实现
    private final ConcurrentHashMap&amp;lt;String, ZuulFilter&amp;gt; filters = new ConcurrentHashMap&amp;lt;String, ZuulFilter&amp;gt;();

    private FilterRegistry() {
    }

    public ZuulFilter remove(String key) {
        return this.filters.remove(key);
    }

    public ZuulFilter get(String key) {
        return this.filters.get(key);
    }

    public void put(String key, ZuulFilter filter) {
        this.filters.putIfAbsent(key, filter);
    }

    public int size() {
        return this.filters.size();
    }

    public Collection&amp;lt;ZuulFilter&amp;gt; getAllFilters() {
        return this.filters.values();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上Zuul使用了简单粗暴的方式(直接使用ConcurrentHashMap)缓存了ZuulFilter，这些缓存除非主动调用&lt;code&gt;remove&lt;/code&gt;方法，否则不会自动清理。Zuul提供默认的动态代码编译器，接口是DynamicCodeCompiler，目的是把代码编译为Java的类，默认实现是GroovyCompiler，功能就是把Groovy代码编译为Java类。还有一个比较重要的工厂类接口是FilterFactory，它定义了ZuulFilter类生成ZuulFilter实例的逻辑，默认实现是DefaultFilterFactory，实际上就是利用&lt;code&gt;Class#newInstance()&lt;/code&gt;反射生成ZuulFilter实例。接着，我们可以进行分析FilterLoader的源码，这个类的作用就是加载文件中的ZuulFilter实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterLoader {
    //静态final实例，注意到访问权限是包许可，实际上就是饿汉式单例
    final static FilterLoader INSTANCE = new FilterLoader();

    private static final Logger LOG = LoggerFactory.getLogger(FilterLoader.class);

    //缓存Filter名称(主要是从文件加载，名称为绝对路径 + 文件名的形式)-&amp;gt;Filter最后修改时间戳的映射
    private final ConcurrentHashMap&amp;lt;String, Long&amp;gt; filterClassLastModified = new ConcurrentHashMap&amp;lt;String, Long&amp;gt;();
    //缓存Filter名字-&amp;gt;Filter代码的映射，实际上这个Map只使用到get方法进行存在性判断，一直是一个空的结构
    private final ConcurrentHashMap&amp;lt;String, String&amp;gt; filterClassCode = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    //缓存Filter名字-&amp;gt;Filter名字的映射，用于存在性判断
    private final ConcurrentHashMap&amp;lt;String, String&amp;gt; filterCheck = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    //缓存Filter类型名称-&amp;gt;List&amp;lt;ZuulFilter&amp;gt;的映射
    private final ConcurrentHashMap&amp;lt;String, List&amp;lt;ZuulFilter&amp;gt;&amp;gt; hashFiltersByType = new ConcurrentHashMap&amp;lt;String, List&amp;lt;ZuulFilter&amp;gt;&amp;gt;();

    //前面提到的ZuulFilter全局缓存的单例
    private FilterRegistry filterRegistry = FilterRegistry.instance();
    //动态代码编译器实例，Zuul提供的默认实现是GroovyCompiler
    static DynamicCodeCompiler COMPILER;
    //ZuulFilter的工厂类
    static FilterFactory FILTER_FACTORY = new DefaultFilterFactory();
    //下面三个方法说明DynamicCodeCompiler、FilterRegistry、FilterFactory可以被覆盖
    public void setCompiler(DynamicCodeCompiler compiler) {
        COMPILER = compiler;
    }

    public void setFilterRegistry(FilterRegistry r) {
        this.filterRegistry = r;
    }

    public void setFilterFactory(FilterFactory factory) {
        FILTER_FACTORY = factory;
    }
    //饿汉式单例获取自身实例
    public static FilterLoader getInstance() {
        return INSTANCE;
    }
    //返回所有缓存的ZuulFilter实例的总数量
    public int filterInstanceMapSize() {
        return filterRegistry.size();
    }
   
    //通过ZuulFilter的类代码和Filter名称获取ZuulFilter实例
    public ZuulFilter getFilter(String sCode, String sName) throws Exception {
        //检查filterCheck是否存在相同名字的Filter，如果存在说明已经加载过
        if (filterCheck.get(sName) == null) {
            //filterCheck中放入Filter名称
            filterCheck.putIfAbsent(sName, sName);
            //filterClassCode中不存在加载过的Filter名称对应的代码
            if (!sCode.equals(filterClassCode.get(sName))) {
                LOG.info(&quot;reloading code &quot; + sName);
                //从全局缓存中移除对应的Filter
                filterRegistry.remove(sName);
            }
        }
        ZuulFilter filter = filterRegistry.get(sName);
        //如果全局缓存中不存在对应的Filter，就使用DynamicCodeCompiler加载代码，使用FilterFactory实例化ZuulFilter
        //注意加载的ZuulFilter类不能是抽象的，必须是继承了ZuulFilter的子类
        if (filter == null) {
            Class clazz = COMPILER.compile(sCode, sName);
            if (!Modifier.isAbstract(clazz.getModifiers())) {
                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);
            }
        }
        return filter;
    }

    //通过文件加加载ZuulFilter
    public boolean putFilter(File file) throws Exception {
        //Filter名称为文件的绝对路径+文件名(这里其实绝对路径已经包含文件名，这里再加文件名的目的不明确)
        String sName = file.getAbsolutePath() + file.getName();
        //如果文件被修改过则从全局缓存从移除对应的Filter以便重新加载
        if (filterClassLastModified.get(sName) != null &amp;amp;&amp;amp; (file.lastModified() != filterClassLastModified.get(sName))) {
            LOG.debug(&quot;reloading filter &quot; + sName);
            filterRegistry.remove(sName);
        }
        //下面的逻辑和上一个方法类似
        ZuulFilter filter = filterRegistry.get(sName);
        if (filter == null) {
            Class clazz = COMPILER.compile(file);
            if (!Modifier.isAbstract(clazz.getModifiers())) {
                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);
                List&amp;lt;ZuulFilter&amp;gt; list = hashFiltersByType.get(filter.filterType());
                //这里说明了一旦文件有修改，hashFiltersByType中对应的当前文件加载出来的Filter类型的缓存要移除，原因见下一个方法
                if (list != null) {
                    hashFiltersByType.remove(filter.filterType()); //rebuild this list
                }
                filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);
                filterClassLastModified.put(sName, file.lastModified());
                return true;
            }
        }
        return false;
    }
    //通过Filter类型获取同类型的所有ZuulFilter
    public List&amp;lt;ZuulFilter&amp;gt; getFiltersByType(String filterType) {
        List&amp;lt;ZuulFilter&amp;gt; list = hashFiltersByType.get(filterType);
        if (list != null) return list;
        list = new ArrayList&amp;lt;ZuulFilter&amp;gt;();
        //如果hashFiltersByType缓存被移除，这里从全局缓存中加载所有的ZuulFilter，按照指定类型构建一个新的列表
        Collection&amp;lt;ZuulFilter&amp;gt; filters = filterRegistry.getAllFilters();
        for (Iterator&amp;lt;ZuulFilter&amp;gt; iterator = filters.iterator(); iterator.hasNext(); ) {
            ZuulFilter filter = iterator.next();
            if (filter.filterType().equals(filterType)) {
                list.add(filter);
            }
        }
        //注意这里会进行排序，是基于filterOrder
        Collections.sort(list); // sort by priority
        //这里总是putIfAbsent，这就是为什么上个方法可以放心地在修改的情况下移除指定Filter类型中的全部缓存实例的原因
        hashFiltersByType.putIfAbsent(filterType, list);
        return list;
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的几个方法和缓存容器都比较简单，这里实际上有加载和存放动作的方法只有&lt;code&gt;putFilter&lt;/code&gt;，这个方法正是Filter文件管理器FilterFileManager依赖的，接着看FilterFileManager的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterFileManager {

    private static final Logger LOG = LoggerFactory.getLogger(FilterFileManager.class);

    String[] aDirectories;
    int pollingIntervalSeconds;
    Thread poller;
    boolean bRunning = true;
    //文件名过滤器，Zuul中的默认实现是GroovyFileFilter，只接受.groovy后缀的文件
    static FilenameFilter FILENAME_FILTER;

    static FilterFileManager INSTANCE;

    private FilterFileManager() {
    }

    public static void setFilenameFilter(FilenameFilter filter) {
        FILENAME_FILTER = filter;
    }
    //init方法是核心静态方法，它具备了配置，预处理和激活后台轮询线程的功能
    public static void init(int pollingIntervalSeconds, String... directories) throws Exception, IllegalAccessException, InstantiationException{
        if (INSTANCE == null) INSTANCE = new FilterFileManager();
        INSTANCE.aDirectories = directories;
        INSTANCE.pollingIntervalSeconds = pollingIntervalSeconds;
        INSTANCE.manageFiles();
        INSTANCE.startPoller();
    }

    public static FilterFileManager getInstance() {
        return INSTANCE;
    }

    public static void shutdown() {
        INSTANCE.stopPoller();
    }

    void stopPoller() {
        bRunning = false;
    }
    //启动后台轮询守护线程，每休眠pollingIntervalSeconds秒则进行一次文件扫描尝试更新Filter
    void startPoller() {
        poller = new Thread(&quot;GroovyFilterFileManagerPoller&quot;) {
            public void run() {
                while (bRunning) {
                    try {
                        sleep(pollingIntervalSeconds * 1000);
                        //预处理文件，实际上是ZuulFilter的预加载
                        manageFiles();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        //设置为守护线程
        poller.setDaemon(true);
        poller.start();
    }
    //根据指定目录路径获取目录，主要需要转换为ClassPath
    public File getDirectory(String sPath) {
        File  directory = new File(sPath);
        if (!directory.isDirectory()) {
            URL resource = FilterFileManager.class.getClassLoader().getResource(sPath);
            try {
                directory = new File(resource.toURI());
            } catch (Exception e) {
                LOG.error(&quot;Error accessing directory in classloader. path=&quot; + sPath, e);
            }
            if (!directory.isDirectory()) {
                throw new RuntimeException(directory.getAbsolutePath() + &quot; is not a valid directory&quot;);
            }
        }
        return directory;
    }
    
    //遍历配置目录，获取所有配置目录下的所有满足FilenameFilter过滤条件的文件
    List&amp;lt;File&amp;gt; getFiles() {
        List&amp;lt;File&amp;gt; list = new ArrayList&amp;lt;File&amp;gt;();
        for (String sDirectory : aDirectories) {
            if (sDirectory != null) {
                File directory = getDirectory(sDirectory);
                File[] aFiles = directory.listFiles(FILENAME_FILTER);
                if (aFiles != null) {
                    list.addAll(Arrays.asList(aFiles));
                }
            }
        }
        return list;
    }
    //遍历指定文件列表，调用FilterLoader单例中的putFilter
    void processGroovyFiles(List&amp;lt;File&amp;gt; aFiles) throws Exception, InstantiationException, IllegalAccessException {
        for (File file : aFiles) {
            FilterLoader.getInstance().putFilter(file);
        }
    }
   //获取指定目录下的所有文件，调用processGroovyFiles，个人认为这两个方法没必要做单独封装
    void manageFiles() throws Exception, IllegalAccessException, InstantiationException {
        List&amp;lt;File&amp;gt; aFiles = getFiles();
        processGroovyFiles(aFiles);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析完FilterFileManager源码之后，Zuul中基于文件加载ZuulFilter的逻辑已经十分清晰：后台启动一个守护线程，定时轮询指定文件夹里面的文件，如果文件存在变更，则尝试更新指定的ZuulFilter缓存，FilterFileManager的&lt;code&gt;init&lt;/code&gt;方法调用的时候在启动后台线程之前会进行一次预加载。&lt;/p&gt;
&lt;h2 id=&quot;requestcontext&quot;&gt;RequestContext&lt;/h2&gt;
&lt;p&gt;在分析ZuulFilter的使用之前，有必要先了解Zuul中的请求上下文对象RequestContext。首先要有一个共识：每一个新的请求都是由一个独立的线程处理(这个线程是Tomcat里面起的线程)，换言之，请求的所有参数(Http报文信息解析出来的内容，如请求头、请求体等等)总是绑定在处理请求的线程中。RequestContext的设计就是简单直接有效，它继承于&lt;code&gt;ConcurrentHashMap&amp;lt;String, Object&amp;gt;&lt;/code&gt;，所以参数可以直接设置在RequestContext中，zuul没有设计一个类似于枚举的类控制RequestContext的可选参数，因此里面的设置值和提取值的方法都是硬编码的，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public HttpServletRequest getRequest() {
        return (HttpServletRequest) get(&quot;request&quot;);
    }

    public void setRequest(HttpServletRequest request) {
        put(&quot;request&quot;, request);
    }

    public HttpServletResponse getResponse() {
        return (HttpServletResponse) get(&quot;response&quot;);
    }

    public void setResponse(HttpServletResponse response) {
        set(&quot;response&quot;, response);
    }
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来很暴力并且不怎么优雅，但是实际上是高效的。RequestContext一般使用静态方法&lt;code&gt;RequestContext#getCurrentContext()&lt;/code&gt;进行初始化，我们分析一下它的初始化流程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //保存RequestContext自身类型
    protected static Class&amp;lt;? extends RequestContext&amp;gt; contextClass = RequestContext.class;
    //静态对象
    private static RequestContext testContext = null;
    //静态final修饰的ThreadLocal实例，用于存放所有的RequestContext，每个RequestContext都会绑定在自身请求的处理线程中
    //注意这里的ThreadLocal实例的initialValue()方法，当ThreadLocal的get()方法返回null的时候总是会调用initialValue()方法
    protected static final ThreadLocal&amp;lt;? extends RequestContext&amp;gt; threadLocal = new ThreadLocal&amp;lt;RequestContext&amp;gt;() {
        @Override
        protected RequestContext initialValue() {
            try {
                return contextClass.newInstance();
            } catch (Throwable e) {
                throw new RuntimeException(e);
            }
        }
    };


    public RequestContext() {
        super();
    }
    
    public static RequestContext getCurrentContext() {
        //这里混杂了测试的代码，暂时忽略
        if (testContext != null) return testContext;
        //当ThreadLocal的get()方法返回null的时候总是会调用initialValue()方法，所以这里是&quot;无则新建RequestContext&quot;的逻辑
        RequestContext context = threadLocal.get();
        return context;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的ThreadLocal覆盖了初始化方法&lt;code&gt;initialValue()&lt;/code&gt;，ThreadLocal的初始化方法总是在&lt;code&gt;ThreadLocal#get()&lt;/code&gt;方法返回null的时候调用，实际上静态方法&lt;code&gt;RequestContext#getCurrentContext()&lt;/code&gt;的作用就是：如果ThreadLocal中已经绑定了RequestContext静态实例就直接获取绑定在线程中的RequestContext实例，否则新建一个RequestContext实例存放在ThreadLocal(绑定到当前的请求线程中)。了解这一点后面分析ZuulServletFilter和ZuulServlet的时候就很简单了。&lt;/p&gt;
&lt;h2 id=&quot;zuulfilter&quot;&gt;ZuulFilter&lt;/h2&gt;
&lt;p&gt;抽象类com.netflix.zuul.ZuulFilter是Zuul里面的核心组件，它是用户扩展Zuul行为的组件，用户可以实现不同类型的ZuulFilter、定义它们的执行顺序、实现它们的执行方法达到定制化的目的，SpringCloud的&lt;code&gt;netflix-zuul&lt;/code&gt;就是一个很好的实现包。ZuulFilter实现了IZuulFilter接口，我们先看这个接口的定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IZuulFilter {
   
   boolean shouldFilter();

   Object run() throws ZuulException;
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，&lt;code&gt;shouldFilter()&lt;/code&gt;方法决定是否需要执行(也就是执行时机由使用者扩展，甚至可以禁用)，而&lt;code&gt;run()&lt;/code&gt;方法决定执行的逻辑。接着看ZuulFilter的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class ZuulFilter implements IZuulFilter, Comparable&amp;lt;ZuulFilter&amp;gt; {
    //netflix的配置组件，实际上就是基于配置文件提取的指定key的值
    private final AtomicReference&amp;lt;DynamicBooleanProperty&amp;gt; filterDisabledRef = new AtomicReference&amp;lt;&amp;gt;();
    
    //定义Filter的类型
    abstract public String filterType();

    //定义当前Filter实例执行的顺序
    abstract public int filterOrder();
   
    //是否静态的Filter，静态的Filter是无状态的
    public boolean isStaticFilter() {
        return true;
    }

    //禁用当前Filter的配置属性的Key名称
    //Key=zuul.${全类名}.${filterType}.disable
    public String disablePropertyName() {
        return &quot;zuul.&quot; + this.getClass().getSimpleName() + &quot;.&quot; + filterType() + &quot;.disable&quot;;
    }

    //判断当前的Filter是否禁用，通过disablePropertyName方法从配置中读取，默认是不禁用，也就是启用
    public boolean isFilterDisabled() {
        filterDisabledRef.compareAndSet(null, DynamicPropertyFactory.getInstance().getBooleanProperty(disablePropertyName(), false));
        return filterDisabledRef.get().get();
    }

    //这个是核心方法，执行Filter，如果Filter不是禁用、并且满足执行时机则调用run方法，返回执行结果，记录执行轨迹
    public ZuulFilterResult runFilter() {
        ZuulFilterResult zr = new ZuulFilterResult();
        if (!isFilterDisabled()) {
            if (shouldFilter()) {
                Tracer t = TracerFactory.instance().startMicroTracer(&quot;ZUUL::&quot; + this.getClass().getSimpleName());
                try {
                    Object res = run();
                    zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS);
                } catch (Throwable e) {
                    t.setName(&quot;ZUUL::&quot; + this.getClass().getSimpleName() + &quot; failed&quot;);
                    zr = new ZuulFilterResult(ExecutionStatus.FAILED);
                    //注意这里只保存异常的实例，即使执行抛出异常
                    zr.setException(e);
                } finally {
                    t.stopAndLog();
                }
            } else {
                zr = new ZuulFilterResult(ExecutionStatus.SKIPPED);
            }
        }
        return zr;
    }
    
    //实现Comparable，基于filterOrder升序排序，也就是filterOrder越大，执行优先度越低
    public int compareTo(ZuulFilter filter) {
        return Integer.compare(this.filterOrder(), filter.filterOrder());
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意几个地方，第一个是&lt;code&gt;filterOrder()&lt;/code&gt;方法和&lt;code&gt;compareTo(ZuulFilter filter)&lt;/code&gt;方法，子类实现ZuulFilter时候，&lt;code&gt;filterOrder()&lt;/code&gt;方法返回值越大，或者说Filter的顺序系数越大，ZuulFilter执行的优先度越低。第二个地方是可以通过zuul.${全类名}.${filterType}.disable=false通过类名和Filter类型禁用对应的Filter。第三个值得注意的地方是Zuul中定义了四种类型的ZuulFilter，后面分析ZuulRunner的时候再详细展开。ZuulFilter实际上就是使用者扩展的核心组件，通过实现ZuulFilter的方法可以在一个请求处理链中的特定位置执行特定的定制化逻辑。第四个值得注意的地方是&lt;code&gt;runFilter()&lt;/code&gt;方法执行不会抛出异常，如果出现异常，Throwable实例会保存在ZuulFilterResult对象中返回到外层方法，如果正常执行，则直接返回&lt;code&gt;runFilter()&lt;/code&gt;方法的结果。&lt;/p&gt;
&lt;h2 id=&quot;filterprocessor&quot;&gt;FilterProcessor&lt;/h2&gt;
&lt;p&gt;前面花大量功夫分析完ZuulFilter基于Groovy文件的加载机制(在SpringCloud体系中并没有使用此策略，因此，我们持了解的态度即可)以及RequestContext的设计，接着我们分析FilterProcessor去了解如何使用加载好的缓存中的ZuulFilter。我们先看FilterProcessor的基本属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterProcessor {

    static FilterProcessor INSTANCE = new FilterProcessor();
    protected static final Logger logger = LoggerFactory.getLogger(FilterProcessor.class);

    private FilterUsageNotifier usageNotifier;


    public FilterProcessor() {
        usageNotifier = new BasicFilterUsageNotifier();
    }

    public static FilterProcessor getInstance() {
        return INSTANCE;
    }

    public static void setProcessor(FilterProcessor processor) {
        INSTANCE = processor;
    }

    public void setFilterUsageNotifier(FilterUsageNotifier notifier) {
        this.usageNotifier = notifier;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像之前分析的几个类一样，FilterProcessor设计为单例，提供可以覆盖单例实例的方法。需要注意的一点是属性usageNotifier是FilterUsageNotifier类型，FilterUsageNotifier接口的默认实现是BasicFilterUsageNotifier(FilterProcessor的一个静态内部类)，BasicFilterUsageNotifier依赖于Netflix的一个工具包&lt;code&gt;servo-core&lt;/code&gt;，提供基于内存态的计数器统计每种ZuulFilter的每一次调用的状态ExecutionStatus。枚举ExecutionStatus的可选值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、SUCCESS，代表该Filter处理成功，值为1。&lt;/li&gt;
&lt;li&gt;2、SKIPPED，代表该Filter跳过处理，值为-1。&lt;/li&gt;
&lt;li&gt;3、DISABLED，代表该Filter禁用，值为-2。&lt;/li&gt;
&lt;li&gt;4、SUCCESS，代表该FAILED处理出现异常，值为-3。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，使用者也可以覆盖usageNotifier属性。接着我们看FilterProcessor中真正调用ZuulFilter实例的核心方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //指定Filter类型执行该类型下的所有ZuulFilter
    public Object runFilters(String sType) throws Throwable {
        //尝试打印Debug日志
        if (RequestContext.getCurrentContext().debugRouting()) {
            Debug.addRoutingDebug(&quot;Invoking {&quot; + sType + &quot;} type filters&quot;);
        }
        boolean bResult = false;
        //获取所有指定类型的ZuulFilter
        List&amp;lt;ZuulFilter&amp;gt; list = FilterLoader.getInstance().getFiltersByType(sType);
        if (list != null) {
            for (int i = 0; i &amp;lt; list.size(); i++) {
                ZuulFilter zuulFilter = list.get(i);
                Object result = processZuulFilter(zuulFilter);
                //如果处理结果是Boolean类型尝试做或操作，其他类型结果忽略
                if (result != null &amp;amp;&amp;amp; result instanceof Boolean) {
                    bResult |= ((Boolean) result);
                }
            }
        }
        return bResult;
    }
    //执行ZuulFilter，这个就是ZuulFilter执行逻辑
    public Object processZuulFilter(ZuulFilter filter) throws ZuulException {
        RequestContext ctx = RequestContext.getCurrentContext();
        boolean bDebug = ctx.debugRouting();
        final String metricPrefix = &quot;zuul.filter-&quot;;
        long execTime = 0;
        String filterName = &quot;&quot;;
        try {
            long ltime = System.currentTimeMillis();
            filterName = filter.getClass().getSimpleName();
            RequestContext copy = null;
            Object o = null;
            Throwable t = null;
            if (bDebug) {
                Debug.addRoutingDebug(&quot;Filter &quot; + filter.filterType() + &quot; &quot; + filter.filterOrder() + &quot; &quot; + filterName);
                copy = ctx.copy();
            }
            //简单调用ZuulFilter的runFilter方法
            ZuulFilterResult result = filter.runFilter();
            ExecutionStatus s = result.getStatus();
            execTime = System.currentTimeMillis() - ltime;
            switch (s) {
                case FAILED:
                    t = result.getException();
                    //记录调用链中当前Filter的名称，执行结果状态和执行时间
                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
                    break;
                case SUCCESS:
                    o = result.getResult();
                    //记录调用链中当前Filter的名称，执行结果状态和执行时间
                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);
                    if (bDebug) {
                        Debug.addRoutingDebug(&quot;Filter {&quot; + filterName + &quot; TYPE:&quot; + filter.filterType() + &quot; ORDER:&quot; + filter.filterOrder() + &quot;} Execution time = &quot; + execTime + &quot;ms&quot;);
                        Debug.compareContextState(filterName, copy);
                    }
                    break;
                default:
                    break;
            }
            
            if (t != null) throw t;
            //这里做计数器的统计
            usageNotifier.notify(filter, s);
            return o;

        } catch (Throwable e) {
            if (bDebug) {
                Debug.addRoutingDebug(&quot;Running Filter failed &quot; + filterName + &quot; type:&quot; + filter.filterType() + &quot; order:&quot; + filter.filterOrder() + &quot; &quot; + e.getMessage());
            }
             //这里做计数器的统计
            usageNotifier.notify(filter, ExecutionStatus.FAILED);
            if (e instanceof ZuulException) {
                throw (ZuulException) e;
            } else {
                ZuulException ex = new ZuulException(e, &quot;Filter threw Exception&quot;, 500, filter.filterType() + &quot;:&quot; + filterName);
                //记录调用链中当前Filter的名称，执行结果状态和执行时间
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
                throw ex;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面介绍了FilterProcessor中的&lt;code&gt;processZuulFilter(ZuulFilter filter)&lt;/code&gt;方法主要提供ZuulFilter执行的一些度量相关记录(例如Filter执行耗时摘要，会形成一个链，记录在一个字符串中)和ZuulFilter的执行方法，ZuulFilter执行结果可能是成功或者异常，前面提到过，如果抛出异常Throwable实例会保存在ZuulFilterResult中，在&lt;code&gt;processZuulFilter(ZuulFilter filter)&lt;/code&gt;发现ZuulFilterResult中的Throwable实例不为null则直接抛出，否则返回ZuulFilter正常执行的结果。另外，FilterProcessor中通过指定Filter类型执行所有对应类型的ZuulFilter的&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法，我们知道了&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法如果处理结果是Boolean类型尝试做或操作，其他类型结果忽略，可以理解为此方法的返回值是没有很大意义的。参考SpringCloud里面对ZuulFilter的返回值处理一般是直接塞进去当前线程绑定的RequestContext中，选择特定的ZuulFilter子类对前面的ZuulFilter产生的结果进行处理。FilterProcessor基于&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法提供了其他指定filterType的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void postRoute() throws ZuulException {
        try {
            runFilters(&quot;post&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_POST_FILTER_&quot; + e.getClass().getName());
        }
    }

    public void preRoute() throws ZuulException {
        try {
            runFilters(&quot;pre&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());
        }
    }

    public void error() {
        try {
            runFilters(&quot;error&quot;);
        } catch (Throwable e) {
            logger.error(e.getMessage(), e);
        }
    }

    public void route() throws ZuulException {
        try {
            runFilters(&quot;route&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_ROUTE_FILTER_&quot; + e.getClass().getName());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面提供的方法很简单，无法是指定参数为&lt;strong&gt;post、pre、error、route&lt;/strong&gt;对&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法进行调用，至于这些FilterType的执行位置见下一个小节的分析。&lt;/p&gt;
&lt;h2 id=&quot;zuulservletfilter和zuulservlet&quot;&gt;ZuulServletFilter和ZuulServlet&lt;/h2&gt;
&lt;p&gt;Zuul本来就是设计为Servlet规范组件的一个类库，ZuulServlet就是javax.servlet.http.HttpServlet的实现类，而ZuulServletFilter是javax.servlet.Filter的实现类。这两个类都依赖到ZuulRunner完成ZuulFilter的调用，它们的实现逻辑是完全一致的，我们只需要看其中一个类的实现，这里挑选ZuulServlet：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulServlet extends HttpServlet {

    private static final long serialVersionUID = -3374242278843351500L;
    private ZuulRunner zuulRunner;

    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        String bufferReqsStr = config.getInitParameter(&quot;buffer-requests&quot;);
        boolean bufferReqs = bufferReqsStr != null &amp;amp;&amp;amp; bufferReqsStr.equals(&quot;true&quot;) ? true : false;
        zuulRunner = new ZuulRunner(bufferReqs);
    }

    @Override
    public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {
        try {
            //实际上委托到ZuulRunner的init方法
            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);
            //初始化RequestContext实例
            RequestContext context = RequestContext.getCurrentContext();
            //设置RequestContext中zuulEngineRan=true
            context.setZuulEngineRan();
            try {
                preRoute();
            } catch (ZuulException e) {
                error(e);
                postRoute();
                return;
            }
            try {
                route();
            } catch (ZuulException e) {
                error(e);
                postRoute();
                return;
            }
            try {
                postRoute();
            } catch (ZuulException e) {
                error(e);
                return;
            }

        } catch (Throwable e) {
            error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));
        } finally {
            RequestContext.getCurrentContext().unset();
        }
    }

    void postRoute() throws ZuulException {
        zuulRunner.postRoute();
    }

    void route() throws ZuulException {
        zuulRunner.route();
    }

    void preRoute() throws ZuulException {
        zuulRunner.preRoute();
    }

    void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        zuulRunner.init(servletRequest, servletResponse);
    }
    //这里会先设置RequestContext实例中的throwable属性为执行抛出的Throwable实例
    void error(ZuulException e) {
        RequestContext.getCurrentContext().setThrowable(e);
        zuulRunner.error();
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ZuulServletFilter和ZuulServlet不相同的地方仅仅是初始化和处理方法的方法签名(参数列表和方法名)，其他逻辑甚至是代码是一模一样，使用过程中我们需要了解javax.servlet.http.HttpServlet和javax.servlet.Filter的作用去选择到底使用ZuulServletFilter还是ZuulServlet。上面的代码可以看到，ZuulServlet初始化的时候可以配置初始化布尔值参数buffer-requests，这个参数默认为false，它是ZuulRunner实例化的必须参数。ZuulServlet中的调用ZuulFilter的方法都委托到ZuulRunner实例去完成，但是我们可以从&lt;code&gt;service(servletRequest, servletResponse)&lt;/code&gt;方法看出四种FilterType(pre、route、post、error)的ZuulFilter的执行顺序，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、pre、route、post都不抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;post，error不执行。&lt;/li&gt;
&lt;li&gt;2、pre抛出异常，顺序是：pre-&amp;gt;error-&amp;gt;post。&lt;/li&gt;
&lt;li&gt;3、route抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;error-&amp;gt;post。&lt;/li&gt;
&lt;li&gt;4、post抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;post-&amp;gt;error。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，一旦出现了异常，会把抛出的Throwable实例设置到绑定到当前请求线程的RequestContext实例中的throwable属性。还需要注意在&lt;code&gt;service(servletRequest, servletResponse)&lt;/code&gt;的finally块中调用了&lt;code&gt;RequestContext.getCurrentContext().unset();&lt;/code&gt;，实际上是从RequestContext的ThreadLocal实例中移除当前的RequestContext实例，这样做可以避免ThreadLocal使用不当导致内存泄漏。&lt;/p&gt;
&lt;p&gt;接着看ZuulRunner的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulRunner {

    private boolean bufferRequests;

    public ZuulRunner() {
        this.bufferRequests = true;
    } 

    public ZuulRunner(boolean bufferRequests) {
        this.bufferRequests = bufferRequests;
    } 

    public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        RequestContext ctx = RequestContext.getCurrentContext();
        if (bufferRequests) {
            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));
        } else {
            ctx.setRequest(servletRequest);
        }
        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));
    }

    public void postRoute() throws ZuulException {
        FilterProcessor.getInstance().postRoute();
    }

    public void route() throws ZuulException {
        FilterProcessor.getInstance().route();
    }

    public void preRoute() throws ZuulException {
        FilterProcessor.getInstance().preRoute();
    }  

    public void error() {
        FilterProcessor.getInstance().error();
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;postRoute()&lt;/code&gt;、&lt;code&gt;route()&lt;/code&gt;、&lt;code&gt;preRoute()&lt;/code&gt;、&lt;code&gt;error()&lt;/code&gt;都是直接委托到FilterProcessor中完成的，实际上就是执行对应类型的所有ZuulFilter实例。这里需要注意的是，初始化ZuulRunner时候，HttpServletResponse会被包装为com.netflix.zuul.http.HttpServletResponseWrapper实例，它是Zuul实现的javax.servlet.http.HttpServletResponseWrapper的子类，主要是添加了一个属性status用来记录Http状态码。如果初始化参数bufferRequests为true，HttpServletRequest会被包装为com.netflix.zuul.http.HttpServletRequestWrapper，它是Zuul实现的javax.servlet.http.HttpServletRequestWrapper的子类，这个包装类主要是把请求的表单参数和请求体都缓存在实例属性中，这样在一些特定场景中可以提高性能。如果没有特殊需要，这个参数bufferRequests一般设置为false。&lt;/p&gt;

&lt;p&gt;我们做一个很简单的例子，场景是：对于每个POST请求，使用pre类型的ZuulFilter打印它的请求体，然后使用post类型的ZuulFilter，响应结果硬编码为字符串&quot;Hello World!&quot;。我们先为CounterFactory、TracerFactory添加两个空的子类，因为Zuul处理逻辑中依赖到这两个组件实现数据度量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultTracerFactory extends TracerFactory {

    @Override
    public Tracer startMicroTracer(String name) {
        return null;
    }
}

public class DefaultCounterFactory extends CounterFactory {

    @Override
    public void increment(String name) {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们分别继承ZuulFilter，实现一个pre类型的用于打印请求参数的Filter，命名为&lt;code&gt;PrintParameterZuulFilter&lt;/code&gt;，实现一个post类型的用于返回字符串&quot;Hello World!&quot;的Filter，命名为&lt;code&gt;SendResponseZuulFilter&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PrintParameterZuulFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return &quot;pre&quot;;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        return &quot;POST&quot;.equalsIgnoreCase(request.getMethod());
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        if (null != request.getContentType()) {
            if (request.getContentType().contains(&quot;application/json&quot;)) {
                try {
                    ServletInputStream inputStream = request.getInputStream();
                    String result = StreamUtils.copyToString(inputStream, Charset.forName(&quot;UTF-8&quot;));
                    System.out.println(String.format(&quot;请求URI为:%s,请求参数为:%s&quot;, request.getRequestURI(), result));
                } catch (IOException e) {
                    throw new ZuulException(e, 500, &quot;从输入流中读取请求参数异常&quot;);
                }
            } else if (request.getContentType().contains(&quot;application/x-www-form-urlencoded&quot;)) {
                StringBuilder params = new StringBuilder();
                Enumeration&amp;lt;String&amp;gt; parameterNames = request.getParameterNames();
                while (parameterNames.hasMoreElements()) {
                    String name = parameterNames.nextElement();
                    params.append(name).append(&quot;=&quot;).append(request.getParameter(name)).append(&quot;&amp;amp;&quot;);
                }
                String result = params.toString();
                System.out.println(String.format(&quot;请求URI为:%s,请求参数为:%s&quot;, request.getRequestURI(),
                        result.substring(0, result.lastIndexOf(&quot;&amp;amp;&quot;))));
            }
        }
        return null;
    }
}

public class SendResponseZuulFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return &quot;post&quot;;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        return &quot;POST&quot;.equalsIgnoreCase(request.getMethod());
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext context = RequestContext.getCurrentContext();
        String output = &quot;Hello World!&quot;;
        try {
            context.getResponse().getWriter().write(output);
        } catch (IOException e) {
            throw new ZuulException(e, 500, e.getMessage());
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们引入嵌入式Tomcat，简单地创建一个Servlet容器，Maven依赖为：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-embed-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jasper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jasper-el&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加带main方法的类把上面的组件和Tomcat的组件组装起来：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulMain {

    private static final String WEBAPP_DIRECTORY = &quot;src/main/webapp/&quot;;
    private static final String ROOT_CONTEXT = &quot;&quot;;

    public static void main(String[] args) throws Exception {
        Tomcat tomcat = new Tomcat();
        File tempDir = File.createTempFile(&quot;tomcat&quot; + &quot;.&quot;, &quot;.8080&quot;);
        tempDir.delete();
        tempDir.mkdir();
        tempDir.deleteOnExit();
        //创建临时目录,这一步必须先设置,如果不设置默认在当前的路径创建一个'tomcat.8080文件夹'
        tomcat.setBaseDir(tempDir.getAbsolutePath());
        tomcat.setPort(8080);
        StandardContext ctx = (StandardContext) tomcat.addWebapp(ROOT_CONTEXT,
                new File(WEBAPP_DIRECTORY).getAbsolutePath());
        WebResourceRoot resources = new StandardRoot(ctx);
        resources.addPreResources(new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;,
                new File(&quot;target/classes&quot;).getAbsolutePath(), &quot;/&quot;));
        ctx.setResources(resources);
        ctx.setDefaultWebXml(new File(&quot;src/main/webapp/WEB-INF/web.xml&quot;).getAbsolutePath());
        // FixBug: no global web.xml found
        for (LifecycleListener ll : ctx.findLifecycleListeners()) {
            if (ll instanceof ContextConfig) {
                ((ContextConfig) ll).setDefaultWebXml(ctx.getDefaultWebXml());
            }
        }
        //这里添加两个度量父类的空实现
        CounterFactory.initialize(new DefaultCounterFactory());
        TracerFactory.initialize(new DefaultTracerFactory());
        //这里添加自实现的ZuulFilter
        FilterRegistry.instance().put(&quot;printParameterZuulFilter&quot;, new PrintParameterZuulFilter());
        FilterRegistry.instance().put(&quot;sendResponseZuulFilter&quot;, new SendResponseZuulFilter());
        //这里添加ZuulServlet
        Context context = tomcat.addContext(&quot;/zuul&quot;, null);
        Tomcat.addServlet(context, &quot;zuul&quot;, new ZuulServlet());
        //设置Servlet的路径
        context.addServletMappingDecoded(&quot;/*&quot;, &quot;zuul&quot;);
        tomcat.start();
        tomcat.getServer().await();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行main方法，Tomcat正常启动后打印出熟悉的日志如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-4.png&quot; alt=&quot;z-s-c-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，用POSTMAN请求模拟一下请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-5.png&quot; alt=&quot;z-s-c-5&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Zuul虽然在它的Github仓库中的简介中说它是一个提供动态路由、监视、弹性、安全性等的网关框架，但是实际上它原生并没有提供这些功能，这些功能是需要使用者扩展ZuulFilter实现的，例如基于负载均衡的动态路由需要配置Netflix自己家的Ribbon实现。Zuul在设计上的扩展性什么良好，ZuulFilter就像插件一个可以通过类型、排序系数构建一个调用链，通过Filter或者Servlet做入口，嵌入到Servlet(Web)应用中。不过，在Zuul后续的版本如2.x和3.x中，引入了Netty，基于TCP做底层的扩展，但是编码和使用的复杂度大大提高。也许这就是SpringCloud在&lt;code&gt;netflix-zuul&lt;/code&gt;组件中选用了zuul1.x的最后一个发布版本1.3.1的原因吧。&lt;code&gt;springcloud-netflix&lt;/code&gt;中使用到Netflix的zuul(动态路由)、robbin(负载均衡)、eureka(服务注册与发现)、hystrix(熔断)等核心组件，这里立个flag先逐个组件分析其源码，逐个击破后再对&lt;code&gt;springcloud-netflix&lt;/code&gt;做一次完整的源码分析。&lt;/p&gt;
&lt;p&gt;(本文完 c-5-d)&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 最近在项目中使用了SpringCloud，基于zuul搭建了一个提供加解密、鉴权等功能的网关服务。鉴于之前没怎么使用过Zuul，于是顺便仔细阅读了它的源码。实际上，zuul原来提供的功能是很单一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9653067.html</dc:identifier>
</item>
<item>
<title>软能力那点事，你知多少 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9653019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9653019.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在我们日常工作中，常常会听到软能力这一个词汇，尤其是在称赞某个人工作表现不错的时候更是如此。&lt;br/&gt;然而关于软能力是什么，一百个人有一百种解释，就好像一千个人有一千个哈姆雷特。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一软能力是什么&quot;&gt;一、软能力是什么&lt;/h2&gt;
&lt;p&gt;什么是软能力？回答这个问题之前，我们先要了解什么是硬能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;还记得曾经如火如荼的高考吗，大家都是卯足了劲儿，挑灯夜读，为的就是上一所心仪的大学。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应试教育的背景下，考试能力、学习成绩这些就是你的硬能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231012702-978846904.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;金庸小说里，第一次华山论剑，南帝北丐展一阳指、降龙十八掌之绝技，东邪西毒现弹指神通、蛤蟆功之怪诞武艺，最终由中神通王重阳战胜群雄，获得天下第一。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在武侠小说里，武功的高低是你的硬能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915233704221-350196291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬能力&lt;/strong&gt;往往最容易被记住，而且人们也更乐于就某个人物(或事物)的硬能力进行谈论&lt;/p&gt;
&lt;p&gt;为什么？因为相对于软能力来说，硬能力更加简单，更容易被描述。&lt;/p&gt;
&lt;p&gt;那么，软能力究竟应该对应什么？&lt;/p&gt;
&lt;p&gt;在高考评估体系里面，占比重最大的无非是笔试成绩，而一些实用型能力比如沟通能力、组织协调能力却没能被考虑进去(这是国内应试教育一直被诟病的地方)，&lt;br/&gt;它们是组成软能力的重要部分。&lt;/p&gt;
&lt;p&gt;再看看华山论剑的案例，武功再高，如果品行败坏，坏事做尽，是很难获得后人世颂的。&lt;br/&gt;这时，武德便是一种软能力。另外，如果武艺高强却没有人知道，就是隐姓埋名；说不中听的，那就是废柴一个。&lt;/p&gt;
&lt;p&gt;这时候，名号的传播就很重要了，我们知道，大约宋代开始，有一种说书人，其常年以演说卖艺为生。&lt;br/&gt;在现如今，这便是隐形的营销。&lt;/p&gt;
&lt;p&gt;有人说，在当今的世界上，硬能力就是智商，软能力则是情商；&lt;br/&gt;也有人说，在企业里面，硬能力是满足岗位需求的必要技能，软能力是你与团队进行交互协作的能力。&lt;/p&gt;
&lt;p&gt;我觉得，说的都对！&lt;br/&gt;软能力是能够让你变得优秀的关键能力。&lt;/p&gt;
&lt;h2 id=&quot;二软能力-程序猿生存指南&quot;&gt;二、软能力-程序猿生存指南&lt;/h2&gt;
&lt;p&gt;让我们回到 软件开发 这个行当，当你即将成为一名程序猿，或者你已经作为程序猿好多年了之后，你是否清楚：&lt;/p&gt;
&lt;p&gt;作为一名程序猿，应该至少具备什么样的软能力，才能使你从猿猿众生中脱颖而出。&lt;/p&gt;
&lt;p&gt;在《软技能-代码之外的生存指南》一书中，作者约翰 Z. 森梅兹为以自己的经历为例，为我们仔细讲述了程序员除了写代码之外应该具备的各种软能力，&lt;br/&gt;值得一提的是，该作者还是一名出色的健身爱好者及投资客，这可能是令许多人望尘莫及的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231219056-1224600597.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;作为一个软件开发人员，在我的生活中，我经历过许多不同的旅程。
我曾走在阳关大道，也曾误入歧途，还有一些路我至今仍不知是对还是错。
这一路走来，我并没有得到太多的帮助和指导。
我从来没觉得有谁为我披荆斩棘，开辟出一条小路使我可以因循，
也从来没觉得有谁可以告诉我如何成为一名最成功的软件开发人员——
不能只编写代码，还要有精彩的人生。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在阅读完此书后，我将所能记住的软能力归纳如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231237577-1395009808.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，有点多.. 有了这些技能，相信大部分程序猿就能迎娶白富美，走上人生巅峰了吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231244747-111595792.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了简化理解，我们可以将关注点聚焦到下面几个维度上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231249686-2024403579.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来解读一下&lt;/p&gt;
&lt;h3 id=&quot;a.-沟通能力&quot;&gt;A. 沟通能力&lt;/h3&gt;
&lt;p&gt;关于沟通方面的能力是老生常谈了，沟通表达能力强的程序猿总是不一样，&lt;br/&gt;在很多场景下都会占优：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小组选拔带头人&lt;/li&gt;
&lt;li&gt;出差到客户现场露露脸&lt;/li&gt;
&lt;li&gt;介绍对象&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231413234-1954219634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;沟通好的人有一点很关键的是换位思考能力，就是能为沟通的对象着想，让你感觉很舒服。&lt;br/&gt;下面有个案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231420982-1307324241.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;b.-学习能力&quot;&gt;B. 学习能力&lt;/h3&gt;
&lt;p&gt;学习要有方法，才能取得更高的效率及更好的效果。&lt;br/&gt;在《软技能-代码之外的生存指南》一书中提到的 &quot;十步学习法&quot; 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一步：了解全局
第二步：确定范围
第三步：定义目标
第四步：寻找资源
第五步：创建学习计划
第六步：筛选资源
第七步：开始学习，浅尝辄止
第八步：动手操作，边玩边学
第九步：全面学习，学以致用
第十步：乐为人师，融会贯通&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十步学习法看似有些繁琐，其实却很有逻辑性，是一个循序渐进的过程。&lt;br/&gt;经过归纳后，我们当然可以做一些简化。&lt;/p&gt;
&lt;p&gt;这里以学习&lt;strong&gt;spring cloud&lt;/strong&gt;为例，整个过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231430632-1894489125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，关于学习过程，你可以自己归纳，但不应该是没有章法的。&lt;/p&gt;
&lt;h3 id=&quot;c.-时间管理&quot;&gt;C. 时间管理&lt;/h3&gt;
&lt;p&gt;时间管理，在职场上更多的是工作管理，即&lt;strong&gt;如何有条不紊的将工作逐个完成&lt;/strong&gt;，&lt;br/&gt;既要满足上级，也要让自己不纠结后悔。&lt;/p&gt;
&lt;p&gt;许多关于时间管理的书籍都会提到&lt;strong&gt;番茄工作法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;按照 番茄钟 的方式对工作任务进行拆解排序；
每个番茄钟对应一段25分钟的工作时间；
在每个番茄钟内部不允许有新任务插入，此时只需要将任务放到待办事项；
每个番茄钟结束后，进行5分钟的休息调整，之后进行下一个番茄钟&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在进行事务排序时，推荐使用&lt;strong&gt;四象限法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231532355-656012788.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;番茄工作法是不错的，但并不完美，许多人尽管知道但却很做到极致。&lt;br/&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很难将任务优先级进行排序，万一错了呢？&lt;/li&gt;
&lt;li&gt;很难将任务对应到25分钟内，我其实需要1个小时..&lt;/li&gt;
&lt;li&gt;很难拒绝新来的任务啊，面对主管的催促，运营MM的询问，实在纠结&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231557337-430677823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这些问题，你只能先承受着..，然后不断去尝试优化&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;李笑来在《和时间做朋友》专栏中提出一个观点：&lt;strong&gt;时间是不可管理的！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这说的倒是没错，我们其实都是时间的奴隶(尽管有些消极)。&lt;br/&gt;所以，需要知道失控是一种常态，以一种平稳的心态去看待。&lt;br/&gt;在过程中去找到你真实的现状和能力，持续探索属于自己的控制方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;d.-分解能力&quot;&gt;D. 分解能力&lt;/h3&gt;
&lt;p&gt;分解能力几乎是各个领域里最通用的能力了。&lt;br/&gt;这个世界是结构化的，大到一个庞大的帝国，小到一只蝼蚁，都是由结构组成的。&lt;br/&gt;就连本文都有一个相对不那么模糊的提纲结构。&lt;/p&gt;
&lt;p&gt;在软件世界里也一直推崇&lt;strong&gt;分而治之&lt;/strong&gt;的思想。&lt;br/&gt;技术人只有具备了良好的结构思考力，在应付一个庞大的项目时才能显得得心应手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231811455-968438845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于这种&lt;strong&gt;先总后分&lt;/strong&gt; 的结构化思维方式，也是一直传承以久的。&lt;/p&gt;
&lt;p&gt;这里推荐一本书籍，叫《结构化思考力》，作者李忠秋是专注于该领域的专家。&lt;br/&gt;将这部书多读两遍，相信会有所收获。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915233825543-757135495.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;e.-总结改进&quot;&gt;E. 总结改进&lt;/h3&gt;
&lt;p&gt;总结归纳是一种能力，但更应该成为一种习惯。&lt;br/&gt;总结的目的是为了改进，刷新自我。&lt;/p&gt;
&lt;p&gt;在《高效人士的七个习惯》中，第七条就是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“不断更新 平衡的自我更新原则”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有不少企业将总结改进作为团队管理的核心要领之一，在敏捷化项目管理中，迭代回顾也是重要形式之一。&lt;br/&gt;但是呢，对于大部分程序猿个人来说，做总结改进可能有些痛苦。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;“有那么多时间做总结，还不如多敲点代码！”&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，如果代表了你的心声，那么很遗憾，这只是你给自己找的&lt;strong&gt;关于不愿意进步&lt;/strong&gt;的一个借口。&lt;/p&gt;
&lt;h2 id=&quot;三程序猿成长路线&quot;&gt;三、程序猿成长路线&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;软能力在程序猿的成长中其实扮演了至关重要的角色，但往往只是不被察觉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常，一名程序猿的发展道路有许多种，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231835192-834996102.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，架构师、项目经理、产品经理是出镜率最高的，大多只要是不跨行的程序猿，几乎最后都是如此。&lt;br/&gt;而对于我而言，这几个角色又是特别熟悉不过的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问题：软能力于这些角色又有什么样的关系？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;架构师&quot;&gt;1. 架构师&lt;/h3&gt;
&lt;p&gt;微服务架构很火，架构师的职位也很火，程序猿看到&lt;strong&gt;架构师 21天 快速进阶&lt;/strong&gt;的字眼也很兴奋...&lt;/p&gt;
&lt;p&gt;然而比较遗憾的是，许多关于架构师的培训、书籍都是以&lt;strong&gt;架构技术&lt;/strong&gt;为主，&lt;br/&gt;认为架构师就是技术牛B就好，对于架构师的软能力一概不谈。&lt;/p&gt;
&lt;p&gt;一些初创型的公司中，创始人并不真正了解架构师，却执着于招聘架构师岗位，素不知道他只是需要一个高级码农就可以了..&lt;/p&gt;
&lt;p&gt;下面这个图来自《软件架构师的12项修炼》一书，很好的说明了架构师该具备的软技能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231845771-2078883096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;see? 技术能力只是最基础的部分，沟通、领导力、认知、创新等等却是属于更高阶的能力。&lt;/p&gt;
&lt;h3 id=&quot;项目经理&quot;&gt;2. 项目经理&lt;/h3&gt;
&lt;p&gt;项目经理是一种纯管理类的岗位，在大部分中小型公司里，项目经理更多扮演了一个&quot;打杂&quot;的角色。&lt;br/&gt;为什么？ 我们先来看看项目经理的担子有多重：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标管理&lt;/strong&gt;&lt;br/&gt;要团队的每个人都能理解目标，非强大的沟通能力不可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进度管理&lt;/strong&gt;&lt;br/&gt;天天早会，天天监工，烦不胜烦..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成本管理&lt;/strong&gt;&lt;br/&gt;至少有一点成本预算意识(投资意识)，小心老板对你不满！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人员管理&lt;/strong&gt;&lt;br/&gt;有些人不想干了，得找他谈谈心，或许还有挽留的机会..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;风险管理&lt;/strong&gt;&lt;br/&gt;总是提心吊胆，得有强大的心理素质&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;也确实，好的项目经理身上总是聚集了许多高超的软能力，然而并不是很多程序猿都想当项目经理。&lt;br/&gt;一般来说，没有技术情结或技术不到家的，想快速上位的，可以走这个路线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231855058-67421619.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;产品经理&quot;&gt;3. 产品经理&lt;/h3&gt;
&lt;p&gt;程序猿转型产品经理的案例现在也越来越多了，&lt;br/&gt;这说明什么？ 互联网渗透率在加速的涨，产品经理待遇也在涨..&lt;/p&gt;
&lt;p&gt;具备技术背景的产品经理无疑是有优势的，但只是要小心，不要掉进&lt;strong&gt;技术情结的怪圈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于胜任产品经理一事的能力诉求，我认为下面的一张图可以很好说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231909238-881132061.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【图来自豆瓣：&lt;a href=&quot;https://www.douban.com/note/321706416/&quot; class=&quot;uri&quot;&gt;https://www.douban.com/note/321706416/&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;在上面的图示中，沟通协调能力、逻辑分析、学习能力等等都在前面篇幅中提及。&lt;br/&gt;可见，在转型产品经理一职之前，程序猿要升华的部分仍然是不少！&lt;/p&gt;
&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;笔者在接触软件工作的这些年间，接触过不少程序猿，大部分人天资聪慧，热情助人，以拯救大家为己任。&lt;br/&gt;但是在面临职业生涯瓶颈转折之时，往往会产生许多纠结。&lt;br/&gt;技术出众者往往孤傲，不善于合群；技术平平者，往往能说会道，职场之路畅行无阻！&lt;/p&gt;
&lt;p&gt;在大部分情况下，软能力是获得成功的关键，本文介绍了一些模型，希望对读者能产生一些启示。&lt;br/&gt;谨以此文，献给仍然在挣扎中奋斗的技术人！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&quot;写一手好代码，做一手好菜，爱技术更爱生活，生活可以是诗和远方&quot;&lt;br/&gt;欢迎关注&lt;strong&gt;美码师&lt;/strong&gt;的公众号，跟我一起学习、交流！&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 15:21:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 在我们日常工作中，常常会听到软能力这一个词汇，尤其是在称赞某个人工作表现不错的时候更是如此。 然而关于软能力是什么，一百个人有一百种解释，就好像一千个人有一千个哈姆雷特。 一、软能力是什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9653019.html</dc:identifier>
</item>
<item>
<title>Java设计模式学习记录-观察者模式 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/9614000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/9614000.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;观察者模式也是对象行为模式的一种，又叫做发表-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、 咱们目前用的最多的就是各种MQ(Message Queue)都是基于这个模式的思想来实现的，生产者产生数据放到一个队列中，消费者观察生产者的消息队列的变化，从而接收消息，执行消费者本身的逻辑。&lt;/p&gt;
&lt;h2&gt;观察者模式&lt;/h2&gt;
&lt;h3&gt;概念介绍&lt;/h3&gt;
&lt;p&gt;观察者模式定义了一个一对多的依赖关系，让一个或多个观察者对象监察一个主题对象。这样一个主题对象在状态上的变化能够通知所有的依赖于此对象的那些观察者对象，使这些观察者对象能够自动更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915174528236-1496727001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些观察者之间没有任何关联，可以根据业务需要增加删除观察者，易于系统扩展。&lt;/p&gt;
&lt;h3&gt;举例&lt;/h3&gt;
&lt;p&gt;还是来举实际的例子，来介绍设计模式，毕竟设计模式是一种抽象的东西，需要落到真正的实现中才能体现出它的价值。当我们在网上购物时，看到一件自己比较喜欢的商品，但是最近手头有点紧（已经开始吃土了），所以会先关注一下这个商品，一般的购物网站上都会有&lt;strong&gt;关注&lt;/strong&gt;此商品这么一个功能的。为了就是当商品降价打折或是其他变化的时候能够通知到所有关注此商品的顾客。那么我们就以这个功能为例子来使用观察者模式实现一下。&lt;/p&gt;
&lt;p&gt;抽象主题类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象被观察类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Observable {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;观察者集合，存储关注商品的所有顾客&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Observer&amp;gt; observerList =&lt;span&gt; Lists.newArrayList();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加观察者（当一个顾客选择了关注商品时添加到观察者集合中）
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; observer 观察者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(Observer observer){
        observerList.add(observer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注销观察者（取消关注商品）
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; observer 观察者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detach(Observer observer){
        observerList.remove(observer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通知观察者的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notice(Object obj);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;商品类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 商品类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Getter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok get方法&lt;/span&gt;
@AllArgsConstructor &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok 以所有属性为参数的构造方法&lt;/span&gt;
@NoArgsConstructor &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok 没有参数的构造方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Product &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 商品名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 商品价格&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BigDecimal price;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品名称变更
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 商品名称
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知观察者&lt;/span&gt;
&lt;span&gt;        notice(name);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 价格变更
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; price 商品价格
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrice(BigDecimal price){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知观察者&lt;/span&gt;
&lt;span&gt;        notice(price);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通知观察者的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notice(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Objects.nonNull(observerList)&amp;amp;&amp;amp;observerList.size()&amp;gt;0&lt;span&gt;){
            observerList.forEach((Observer observer) &lt;/span&gt;-&amp;gt;&lt;span&gt; observer.update(obj));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽象观察者类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象观察者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;名称观察者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 名称观察者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NameObserver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String){
            String name &lt;/span&gt;=&lt;span&gt; (String) obj;
            System.out.println(&lt;/span&gt;&quot;您关注的商品名称发生了变化，最新的商品名称是&quot;+&lt;span&gt;name);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;价格观察者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 价格观察者 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PriceObserver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observer{


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BigDecimal){
            BigDecimal price &lt;/span&gt;=&lt;span&gt; (BigDecimal)obj;
            System.out.println(&lt;/span&gt;&quot;您关注的商品价格发生了变化，最新的商品价格是：&quot;+&lt;span&gt;price);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Product(&quot;iphoneX&quot;,&lt;span&gt;new&lt;/span&gt; BigDecimal(8999&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;您关注的商品的名称是：&quot;+product.getName()+&quot;，价格是：&quot;+&lt;span&gt;product.getPrice());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建观察者&lt;/span&gt;
        NameObserver nameObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameObserver();
        PriceObserver priceObserver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceObserver();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入观察者&lt;/span&gt;
&lt;span&gt;        product.attach(nameObserver);
        product.attach(priceObserver);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生变化，通知观察者&lt;/span&gt;
        product.setName(&quot;iphoneX Max&quot;&lt;span&gt;);
        product.setPrice(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(12999&lt;span&gt;));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
您关注的商品的名称是：iphoneX，价格是：8999&lt;span&gt;
您关注的商品名称发生了变化，最新的商品名称是iphoneX Max
您关注的商品价格发生了变化，最新的商品价格是：&lt;/span&gt;12999
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的运行结果我们就能看出来，当商品名称或价格发生变化时，会通知到相应的观察者，这就是观察者模式的具体应用了。那么通过例子我们也可以看出来观察者模式具体是由哪些角色组成的。&lt;/p&gt;
&lt;h3&gt;观察者模式的结构&lt;/h3&gt;
&lt;p&gt;观察者模式结构如下图 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915220247338-1137018364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在观察者模式中存在如下几种角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象主题角色（Subject）&lt;/strong&gt;：抽象主题角色把所有的观察者对象的引用保存在一个列表里；每个主题都可以有任何数量的观察者。主题提供一个接口，可以加上或撤销观察者对象；主题角色又被称为被观察者角色。可以用抽象类或接口来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象观察者角色（Observer）&lt;/strong&gt;：为所有的具体观察者定义一个接口，在得到通知时更新自己。抽象观察者角色通常是用一个抽象类或一个接口来实现；当然也可以用具体的类来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体主题角色（ConcreteSubject）&lt;/strong&gt;：具体主题保存对具体观察者对象有用的内部状态，在这种状态改变时，给其观察者发出一个具体的通知，具体主题角色又被称为具体被观察者角色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体观察者角色（ConcreteObserver）&lt;/strong&gt;：具体观察者角色用于保存一个指向具体主题对象的引用，和一个与主题的状态相符的状态。具体观察者角色实现抽象观察者角色所要求的更新自己的接口，以便使本身的状态与主题的状态对应。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;观察者模式是一种使用频率比较高的设计模式，凡是涉及到一对一或一对多的对象交互场景都可以使用观察者模式。&lt;/p&gt;
&lt;h3&gt;观察者模式的主要优点&lt;/h3&gt;
&lt;p&gt;1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当观察者角色。&lt;/p&gt;
&lt;p&gt;2、观察者模式在观察目标和观察者之间建立一个抽象耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。&lt;/p&gt;
&lt;p&gt;3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。&lt;/p&gt;
&lt;p&gt;4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。&lt;/p&gt;
&lt;h3&gt;观察者模式的主要缺点&lt;/h3&gt;
&lt;p&gt;1、如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。&lt;/p&gt;
&lt;p&gt;2、如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。&lt;/p&gt;
&lt;p&gt;3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。&lt;/p&gt;
&lt;h3&gt;适用场景&lt;/h3&gt;
&lt;p&gt;1、一个对象的改变将会导致一个或多个对象的改变，不清楚具体有多少对象以及这些被影响的对象是谁的情况。&lt;/p&gt;
&lt;p&gt;2、如果有这样一个影响链的情况下也可以使用，例如A的改变会影响B，B的改变会影响C......，可以使用观察者模式设计一个链式触发机制。&lt;/p&gt;


&lt;p&gt;想了解更多的设计模式请查看&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jimoer/p/9163426.html&quot;&gt;Java设计模式学习记录-GoF设计模式概述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915224244625-861430438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个是我的个人公众号，文章以后也会同步到公众号上去，欢迎关注。&lt;/p&gt;

</description>
<pubDate>Sat, 15 Sep 2018 14:52:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 观察者模式也是对象行为模式的一种，又叫做发表-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、 咱们目前用的最多的就是各种MQ(Message Queue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/9614000.html</dc:identifier>
</item>
<item>
<title>Docz 用 MDX 写 React UI 组件文档 - givebest</title>
<link>http://www.cnblogs.com/givebest/p/9652889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/givebest/p/9652889.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;为了提升开发效率，创建一套 UI 组件库是一种较为有效的方式之一：可以减少重复工作、提高可复用，所以现在越来越多团队开始创建自己的 UI 组件库。较早的 Twitter 的 &lt;a href=&quot;http://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt; 虽然只能称为 UI 库，但也大大提升了开发效率。后面 &lt;code&gt;MVVM&lt;/code&gt; 大行其道 ，前端终于可以把 HTML、CSS、JS 放在一起开发包含 UI 、交互真正意义上的组件了，现在有基于 &lt;code&gt;React&lt;/code&gt; 的 &lt;a href=&quot;https://material-ui.com/demos/app-bar/&quot;&gt;Material-UI&lt;/a&gt;、国内阿里金服基于 &lt;code&gt;React&lt;/code&gt; 的 &lt;a href=&quot;https://ant.design/docs/react/introduce-cn&quot;&gt;Ant Design&lt;/a&gt;、饿了么基于 &lt;code&gt;Vue.js&lt;/code&gt; 的 &lt;a href=&quot;https://element.eleme.io/&quot;&gt;Element&lt;/a&gt;、TalkingData 基于 &lt;code&gt;Vue.js&lt;/code&gt; 的 &lt;a href=&quot;https://iviewui.com/&quot;&gt;iView&lt;/a&gt; 等。有了这些 UI 组件，让前端开发变得前所未有的方便，完成一个项目就像是拿一块块的积木(组件)堆成一个完整项目。&lt;/p&gt;
&lt;p&gt;考虑到前期开发 UI 组件的工作量及后期维护成本，我认为在大厂开源 UI 组件库的基础上个性化色彩（一般都提供颜色定制）、增加团队的个性化需求组件、减少不需要的组件是个不错的主意。&lt;/p&gt;
&lt;p&gt;有了团队的 UI 组件库就少不了使用文档，毕竟文档还是比口口相传要靠谱的多。这里介绍一个可以快速创建 React UI 组件库使用、演示文档的项目：&lt;a href=&quot;https://github.com/pedronauck/docz&quot;&gt;Docz&lt;/a&gt;。&lt;a href=&quot;https://github.com/pedronauck/docz&quot;&gt;Docz&lt;/a&gt; 的特色是零配置、简单、快速，它使用 &lt;code&gt;Markdown&lt;/code&gt; 语法的扩展 &lt;a href=&quot;https://github.com/mdx-js/mdx&quot;&gt;MDX&lt;/a&gt; (在 Markdown 里引入 React 组件并渲染出组件)来书写文档，对于熟悉 &lt;code&gt;Markdown&lt;/code&gt; 的开发者是可以直接上手的。下面贴一张官方的图看看有多简单：&lt;br/&gt;&lt;img src=&quot;https://givebest.github.io/images/docz/docz.png&quot; alt=&quot;Docz&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;左边是创建的 &lt;code&gt;MDX&lt;/code&gt; 文档，右边是 Docz 渲染出的组件及组件代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是很方便？那下面简单介绍一下使用步骤。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;h5 id=&quot;在你的项目里安装-docz&quot;&gt;1. 在你的项目里安装 Docz：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;yarn add docz --dev 或者 npm install docz --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建-.mdx-文件并输入&quot;&gt;2. 创建 &lt;code&gt;.mdx&lt;/code&gt; 文件并输入：&lt;/h5&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;---
name: Button
---

import { Playground, PropsTable } from 'docz'
import Button from './'

# Button

&amp;lt;PropsTable of={Button} /&amp;gt;

## Basic usage

&amp;lt;Playground&amp;gt;
 &amp;lt;Button&amp;gt;Click me&amp;lt;/Button&amp;gt;
 &amp;lt;Button kind=&quot;secondary&quot;&amp;gt;Click me&amp;lt;/Button&amp;gt;
&amp;lt;/Playground&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;运行&quot;&gt;3. 运行：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;yarn docz dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就完成了一个简单的 Button 组件的演示、使用文档。&lt;br/&gt;&lt;img src=&quot;https://givebest.github.io/images/docz/docz-preview.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.171875&quot;&gt;
&lt;p&gt;更多详情：&lt;a href=&quot;http://www.docz.site/introduction/getting-started&quot; class=&quot;uri&quot;&gt;http://www.docz.site/introduction/getting-started&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;
&lt;p&gt;零配置方便是方便，但有时想界面个性化点还是很费事的(官方提供 Themes 支持，但现仅有一套官方的默认主题)，下面分享一个通过引入本地 CSS 的方式来改变默认主题的配置。&lt;/p&gt;
&lt;h5 id=&quot;创建配置文件-doczrc.js增加-htmlcontext-内容&quot;&gt;1. 创建配置文件 &lt;code&gt;doczrc.js&lt;/code&gt;，增加 htmlContext 内容。&lt;/h5&gt;
&lt;blockquote readability=&quot;1.0416666666667&quot;&gt;
&lt;p&gt;更多配置：&lt;a href=&quot;https://www.docz.site/documentation/project-configuration&quot; class=&quot;uri&quot;&gt;https://www.docz.site/documentation/project-configuration&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  htmlContext: {
    head: {
      links: [
        { rel: 'stylesheet', href: '/base.css' }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;docz-目录下创建-public-文件夹并创建-base.css在-base.css-里写自己的样式覆盖默认的即可&quot;&gt;2. &lt;code&gt;.docz&lt;/code&gt; 目录下创建 &lt;code&gt;public&lt;/code&gt; 文件夹并创建 &lt;code&gt;base.css&lt;/code&gt;，在 &lt;code&gt;base.css&lt;/code&gt; 里写自己的样式覆盖默认的即可。&lt;/h5&gt;
&lt;h4 id=&quot;最后&quot;&gt;最后&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Docz 简单好用，但现在只支持 React。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/storybooks/storybook&quot;&gt;Storybook&lt;/a&gt; 是一个更强大的集组件开发、查看、测试的文档工具，支持：
&lt;ul&gt;&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;React Native&lt;/li&gt;
&lt;li&gt;Vue&lt;/li&gt;
&lt;li&gt;Angular&lt;/li&gt;
&lt;li&gt;Polymer&lt;/li&gt;
&lt;li&gt;Mithril&lt;/li&gt;
&lt;li&gt;Marko&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;Svelte&lt;/li&gt;
&lt;li&gt;Riot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/docsifyjs/docsify&quot;&gt;Docsify&lt;/a&gt;：&lt;a href=&quot;https://docsify.js.org/#/zh-cn/vue?id=%E6%90%AD%E9%85%8D-vuep-%E5%86%99-playground&quot;&gt;搭配 Vuep 写 Playground&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;转载请注明出处-httpsblog.givebest.cnother20180915react-ui-component-docz-mdx.html&quot;&gt;转载请注明出处： &lt;a href=&quot;https://blog.givebest.cn/other/2018/09/15/react-ui-component-docz-mdx.html&quot; class=&quot;uri&quot;&gt;https://blog.givebest.cn/other/2018/09/15/react-ui-component-docz-mdx.html&lt;/a&gt;&lt;/h5&gt;
</description>
<pubDate>Sat, 15 Sep 2018 14:34:00 +0000</pubDate>
<dc:creator>givebest</dc:creator>
<og:description>这里介绍一个可以快速创建 React UI 组件库使用、演示文档的项目：Docz</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/givebest/p/9652889.html</dc:identifier>
</item>
<item>
<title>mybatis 解析配置文件（一）之XML的DOM解析方式 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9652273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9652273.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在之前的文章《mybatis 初步使用（IDEA的Maven项目, 超详细）》中， 讲解了&lt;code&gt;mybatis&lt;/code&gt;的初步使用， 并总结了以下&lt;code&gt;mybatis&lt;/code&gt;的执行流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;通过 Resources 工具类读取 mybatis-config.xml， 存入 Reader；&lt;/li&gt;
&lt;li&gt;SqlSessionFactoryBuilder使用上一步获得的reader创建SqlSessionFactory对象;&lt;/li&gt;
&lt;li&gt;通过 sqlSessionFactory 对象获得SqlSession;&lt;/li&gt;
&lt;li&gt;SqlSession对象通过selectList方法找到对应的“selectAll”语句， 执行SQL查询。&lt;/li&gt;
&lt;li&gt;底层通过 JDBC 查询后获得ResultSet, 对每一条记录， 根据resultMap的映射结果映射到Student中， 返回List。&lt;/li&gt;
&lt;li&gt;最后记得关闭 SqlSession&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;本系列文章深入讲解第 2 步， 解析配置文件。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;java-中-xml-文件解析&quot;&gt;Java 中 XML 文件解析&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mybatis&lt;/code&gt;是基于 &lt;code&gt;XML&lt;/code&gt; 来进行配置的， 因此， 我们首先要知道在&lt;code&gt;Java&lt;/code&gt;中， &lt;code&gt;XML&lt;/code&gt;是如何解析的。&lt;/p&gt;
&lt;h3 id=&quot;解析方式&quot;&gt;解析方式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;XML&lt;/code&gt; 常见的解析方式有以下三种： &lt;code&gt;DOM&lt;/code&gt;、 &lt;code&gt;SAX&lt;/code&gt; 和 &lt;code&gt;StAX&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dom-方式&quot;&gt;1. DOM 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;DOM&lt;/code&gt; 基于树形结构解析， 它会将整个文档读入内存并构建一个 &lt;code&gt;DOM&lt;/code&gt; 树， 基于这棵树的结构对各个节点进行解析。&lt;/p&gt;
&lt;h4 id=&quot;sax-方式&quot;&gt;2. SAX 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SAX&lt;/code&gt; 是基于事件模型的 &lt;code&gt;XML&lt;/code&gt; 解析方式， 它不需要将整个 &lt;code&gt;XML&lt;/code&gt; 文档加载到内存中， 而只需要将一部分 &lt;code&gt;XML&lt;/code&gt; 文档的一部分加载到内存中， 即可开始解析。&lt;/p&gt;
&lt;h4 id=&quot;stax-方式&quot;&gt;3. StAX 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;StAX&lt;/code&gt; 与 &lt;code&gt;SAX&lt;/code&gt; 类似， 也是把 &lt;code&gt;XML&lt;/code&gt; 文档作为一个事件流进行处理， 但不同之处在于 &lt;code&gt;StAX&lt;/code&gt; 采用的是“拉模式”， 即应用程序通过调用解析器推进解析的过程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;dom-解析-xml&quot;&gt;DOM 解析 XML&lt;/h2&gt;
&lt;p&gt;在加载 &lt;code&gt;mybatis-config.xml&lt;/code&gt; 配置文件与映射文件时， 使用的是 &lt;code&gt;DOM&lt;/code&gt; 解析方式， 并配合使用 &lt;code&gt;XPath&lt;/code&gt; 解析 &lt;code&gt;XML&lt;/code&gt; 配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XPath&lt;/code&gt; 之于 &lt;code&gt;XML&lt;/code&gt; 就好比 &lt;code&gt;SQL&lt;/code&gt; 之于数据库。&lt;/p&gt;
&lt;p&gt;所谓&lt;code&gt;DOM&lt;/code&gt;， 是 &lt;strong&gt;Document Object Model&lt;/strong&gt; 的缩写， 翻译过来就是文档对象模型。&lt;/p&gt;
&lt;p&gt;下面我们就来展示一下该过程。&lt;/p&gt;
&lt;h3 id=&quot;新建-xml-文件&quot;&gt;新建 XML 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;CATALOG&amp;gt;
    &amp;lt;CD id=&quot;1&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Empire Burlesque&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Bob Dylan&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;USA&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;Columbia&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;10.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1985&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;2&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Hide your heart&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Bonnie Tyler&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;UK&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;CBS Records&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1988&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;3&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Greatest Hits&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Dolly Parton&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;USA&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;RCA&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1982&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;4&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Still got the blues&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Gary Moore&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;UK&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;Virgin records&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;10.20&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1990&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;5&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Eros&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Eros Ramazzotti&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;EU&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;BMG&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1997&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
&amp;lt;/CATALOG&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;CATALOG&lt;/code&gt;中， 有很多&lt;code&gt;CD&lt;/code&gt;， &lt;code&gt;CD&lt;/code&gt;有着自己的子节点。&lt;/p&gt;
&lt;h3 id=&quot;dom-操作相关类&quot;&gt;DOM 操作相关类&lt;/h3&gt;
&lt;p&gt;以上的XML， 其对应的树形结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180915211625110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;文档结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在&lt;code&gt;Java&lt;/code&gt;中， 有很节点类型， 以下有几个主要的接口对应着&lt;code&gt;XML&lt;/code&gt;中的各个属性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt; : DOM最基本的数据类型。 表示文档树中的单个节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Element&lt;/strong&gt;：常见的元素节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attr&lt;/strong&gt;：代表元素的属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text&lt;/strong&gt;：元素或者Att的值（内容）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt;：代表整个XML文档&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;java-读取-xml-文件&quot;&gt;Java 读取 XML 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
    // 获取 DocumentBuilderFactory 
    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();

    builderFactory.setValidating(false);
    builderFactory.setNamespaceAware(false);
    builderFactory.setIgnoringComments(true);
    builderFactory.setIgnoringElementContentWhitespace(false);
    builderFactory.setCoalescing(false);
    builderFactory.setExpandEntityReferences(true);

    // 通过 DocumentBuilderFactory 获取 DocumentBuilder
    DocumentBuilder builder = builderFactory.newDocumentBuilder();

    builder.setErrorHandler(new ErrorHandler() {
        @Override
        public void warning(SAXParseException exception) throws SAXException {
            System.out.println(&quot;warning:&quot;+exception.getMessage());
        }

        @Override
        public void error(SAXParseException exception) throws SAXException {
            System.out.println(&quot;error:&quot;+exception.getMessage());
        }

        @Override
        public void fatalError(SAXParseException exception) throws SAXException {
            System.out.println(&quot;fatalError:&quot;+exception.getMessage());
        }
    });
    
    // 得到Document文件， 就是XML在JVM中的化身
     InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;xml/cds.xml&quot;);
     Document document = builder.parse(is);
    
    // 以下通过 XPath 来获取对应的信息
    XPathFactory xPathFactory = XPathFactory.newInstance();
    XPath xPath = xPathFactory.newXPath();
    // 解析 //CD//TITLE//text() ， 就是获取所有CD节点下TITLE子节点的文字内容 
    XPathExpression expression = xPath.compile(&quot;//CD//TITLE//text()&quot;);
    
    Object result = expression.evaluate(document, XPathConstants.NODESET);
    NodeList nodeList = (NodeList)result;
    for (int i = 0; i &amp;lt; nodeList.getLength(); i++) {
        System.out.println(nodeList.item(i).getNodeValue());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其主要步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; 对象;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; 创建&lt;code&gt;DocumentBuilder&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;DocumentBuilder&lt;/code&gt;， 从文件或流中创建通过&lt;code&gt;Document&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;XPathFactory&lt;/code&gt;对象， 并通过&lt;code&gt;XPathFactory&lt;/code&gt;创建&lt;code&gt;XPath&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;XPath&lt;/code&gt;解析出&lt;code&gt;XPathExpression&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;XPathExpression&lt;/code&gt;在文档中搜索出相应的节点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180915211647827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以调用相应的 &lt;code&gt;API&lt;/code&gt; 进行获取和设置各个属性， 再次就不过多的进行深入。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 13:26:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>简介 在之前的文章《mybatis 初步使用（IDEA的Maven项目, 超详细）》中， 讲解了mybatis的初步使用， 并总结了以下mybatis的执行流程： 1. 通过 Resources 工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9652273.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9652134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9652134.html</guid>
<description>&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;【&lt;a href=&quot;https://files.cnblogs.com/files/lovecindywang/ZHUYE_ARCH_S1E5.pdf&quot; target=&quot;_blank&quot;&gt;下载本文PDF进行阅读&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;一般而言中间件和框架的区别是，中间件是独立运行的用于处理某项专门业务的CS程序，会有配套的客户端和服务端，框架虽然也是处理某个专门业务的但是它不是独立程序，是寄宿在宿主程序进程内的一套类库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202444632-1262437572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图上绿色部分代表了框架，红色部分代表了管理系统，紫色部分代表了中间件。本文会着重介绍管理系统和中间件部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202416513-1889447067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较知名的分布式配置服务和管理系统有携程的&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;（上图）以及&lt;a href=&quot;https://github.com/knightliao/disconf&quot;&gt;https://github.com/knightliao/disconf&lt;/a&gt;。对于比较大型的互联网项目来说，因为业务繁杂，需求多变，往往各种系统都会有大量的配置，覆盖几个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对系统内部技术层面的各种配置，各种池的大小、 队列的大小、日志级别、各种路径、批次大小、处理间隔、重试次数、超时时间等。&lt;/li&gt;
&lt;li&gt;针对业务运营层面的各种配置，活动的周期奖励、黑白名单、弹窗、广告位等。&lt;/li&gt;
&lt;li&gt;针对运维和发布层面的配置，灰度名单、注册中心地址、数据库地址、缓存地址、MQ地址等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为一些基础组件比如SOA框架和发布系统也会用到配置，这个时候就会可能会有鸡生蛋的问题，这里我比较建议把配置系统作为最最底层的系统，其它服务都可以依赖配置系统。一般而言配置管理除了实现最基本的Key-Value的配置读取和配置之外，还会有下面的一些特性和功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能。配置服务的压力会是非常吓人的，在一次服务调用中可能就会有几十次的配置调用，如果服务的整体QPS在500那么配置服务的压力可能在1万的QPS，这样的QPS不走缓存基本是不可能的。好在即使是1万甚至是5万的QPS也不算一个很夸张的无法解决的压力。&lt;/li&gt;
&lt;li&gt;高可用。现在各种开源的配置服务是所谓的分布式配置服务，由可扩展的配置服务集群来承担负载均衡和高可用功能，配置服务一旦挂了可能会让系统瘫痪。你可能会说配置服务一般本地会有缓存，会有本地的配置文件作为后备，会有默认值，但是因为配置是运营运维在实时修改的，如果某个业务的配置没有使用最新的配置走的是错误的默认值的话，系统会处于完全混乱的状态，所以配置服务的稳定性太重要了。&lt;/li&gt;
&lt;li&gt;树形的配置体系。如果只是把所有配置堆在一个列表里，加上项目和分类的话，当配置多达几千项的时候还是会有点多。可以支持树形的层级配置，不拘泥于项目和分类这两个条件。项目下可以有模块，模块下可以有分类，分类下可以有小类，根据自己的需求动态构建配置树。&lt;/li&gt;
&lt;li&gt;好用的客户端。比如可以和SpringBoot以及@Value注解结合起来，非侵入整合配置系统，无需任何代码的改动。&lt;/li&gt;
&lt;li&gt;毫秒级粒度的修改实时生效。可以使用长连接推的方式实现，也可以实现缓存失效的方式实现。&lt;/li&gt;
&lt;li&gt;配置的分层隔离。包括按照环境、集群和项目来提供多套配置相互独立不影响，包括可以以层级的方式做配置继承。&lt;/li&gt;
&lt;li&gt;配置的权限控制。不同类型、环境、集群、项目的配置具有不同的管理权限，比如脱敏只读、只读、读写、导出。&lt;/li&gt;
&lt;li&gt;配置的版本管理。配置的每一次修改都是一个版本，可以为单独的配置或项目进行直接版本回滚。&lt;/li&gt;
&lt;li&gt;丰富的Value形式。配置的Value如果要保存列表的话，保存一个JSON阅读和修改都不方便，可以直接提供List方式的Value，在后台可以单独增删改里面的一项。在比如黑名单的引用上这种方式比较高效，否则更新一个名单每次都要修改整个黑名单。这个功能可以和Redis结合在一起进行实现。Value除了支持字符串可以是JSON和XML形式，系统可以对格式进行格式化，对格式进行校验。Value也可以是非字符串类型的各种数字格式，系统也会根据类型进行校验。&lt;/li&gt;
&lt;li&gt;丰富的配置发布生效形式。比如可以自然生效、立即生效以及定时生效。定时生效的功能适合于在某个时间点需要开启某个配置，比如用于面向用户的推送、活动业务。还有支持灰度自动发布，以一定的时间间隔来对集群里的实例进行发布，避免人工去定期逐一发布单台的麻烦。&lt;/li&gt;
&lt;li&gt;审核审计功能。配置的修改可以由管理员进行审核（也就是修改和发布的权限支持分离），避免配置错误修改。所有配置的修改记录可以查询到谁什么时候因为什么原因修改了什么配置，事后可以审计审查。&lt;/li&gt;
&lt;li&gt;配置生效跟踪和使用率跟踪。可以看到每一个配置项现在哪些客户端在使用，生效的值的版本是哪个。通过这个功能还可以排查现在系统中过去一段时间从没有用过的配置，删除无用的配置。&lt;/li&gt;
&lt;li&gt;动态配置。在API设计的时候我们引入上下文的概念，通过传入一个Map字典作为上下文，比如某个配置按照不同的用户类型、城市需要有不同的值，这个逻辑我们可以不需要在代码里面手工编写，直接通过在后台配置上下文的匹配策略来动态读取到不同的配置值。&lt;/li&gt;
&lt;li&gt;本地快照。对配置进行快照本地保存，在出现故障无法连接服务端的时候使用本地的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里可以看到要实现一个功能完善的配置系统工作量还是相当大的，一个优秀的功能强大的配置系统可以节省很多开发的工作量，因为可配置部分的功能基本就是由配置系统直接实现了，无需在数据库中在搞大量的XXConfig表（不夸张的说，很多业务系统40%的工作量在这个上面，不但需要做这些配置表还需要配以配置后台）。&lt;/p&gt;


&lt;p&gt;微服务的建设中实现远程调用只是实现了20%的工作量（但是确实满足了80%的需求）。服务管理治理这块有大量的工作要做。这也就是实现自己RPC框架的好处，这是第一步，有了这第一步让数据流过我们自己的框架以后我们接可以做更多的事情，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用链跟踪。能否记录整个调用的情况，并且查看这个调用链。下面一节会再说一下这点。&lt;/li&gt;
&lt;li&gt;注册管理。查看服务的注册情况，服务手动上线下线，集群切换，压力分配干预。&lt;/li&gt;
&lt;li&gt;配置管理。配置服务端客户端线程池和队列的配置，超时配置等等。当然，这个也可以在配置系统中进行。&lt;/li&gt;
&lt;li&gt;运维层面的管理。查看和管理方法熔断，进行并发限流配置，服务权限黑白名单配置，安全方面的配置（信息加密，日志脱敏等）。&lt;/li&gt;
&lt;li&gt;Service Store的概念。服务发布需要满足一定要求，有文档（比如可以通过注解方式在代码注释里提供），有信息（开发负责人、运维负责人，服务类型，提供的能力），满足要求后就可以以类似于苹果App Store发布程序的方式发布服务，这样我们就可以在统一的平台上查看服务的维护信息和文档。&lt;/li&gt;
&lt;li&gt;版本控制调用统计。对服务进行灰度升级，按版本路由，不同版本调用分析等等。类似于一些应用统计平台提供的功能（友盟、TalkingData）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我想说的理念是，服务能调用通是第一步，随着服务数量变多，部署方式的复杂化，依赖关系复杂化，版本的迭代，API的变更，开发人员和架构师其实急需有一套地图能够对服务能力的全貌进行整体的了解，运维也需要有系统能对服务进行观察和调配。服务治理的部分完全可以以iOS那套（开发符合时候需要符合标准+发布的时候需要有流程）方式来运作。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202455341-25214706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源的实现有&lt;a href=&quot;https://github.com/dianping/cat&quot;&gt;https://github.com/dianping/cat&lt;/a&gt;以及&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;https://github.com/naver/pinpoint&lt;/a&gt;（上图）等等。对于微服务比较多的（主流程涉及8+微服务）系统，如果没有服务的全链路调用跟踪那么排查故障以及性能问题就会很困难了。一般完善的全链路监控体系不仅仅覆盖微服务，而且功能也会更丰富，实现下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以Log、Agent、Proxy或整合进框架的方式实现，尽可能少的侵入的情况下实现数据的收集。而且确保数据的收集不会影响到主业务，收集服务端宕机的情况下业务不影响。&lt;/li&gt;
&lt;li&gt;调用跟踪。涉及到服务调用、缓存调用、数据库调用，MQ调用，不仅仅可以以树的形式呈现每次调用的类型、耗时、结果，还可以呈现完整的根，也就是对于网站请求呈现出请求的完整信息，对于Job任务呈现出Job的信息。&lt;/li&gt;
&lt;li&gt;JVM的信息（比如对于Java）。呈现每一个进程JVM层次的GC、Threads、Memory、CPU的使用情况。可以进行远程Stack的查看和Heap的快照（没有进程的内存信息，很多时候基于服务器层面粗粒度的资源使用情况的监控，基本不可能分析出根本原因），并且可以设定策略进行定期的快照。虚拟机的信息查看和调用跟踪甚至可以通过快照进行关联，在出现问题的时候能够了解当时虚拟机的状态对于排查问题是非常有好处的。&lt;/li&gt;
&lt;li&gt;依赖关系一览。有的时候我们做架构方案，第一步就是梳理模块和服务之间的依赖关系，只有这样我们才能确定影响范围重构范围，对于微服务做的比较复杂的项目来说，每个人可能只是关注自己服务的上下游，对于上游的上游和下游的下游完全不清楚，导致公司也没有人可以说的清楚架构的全貌。这个时候我们有全链路跟踪系统的话，可以对通过分析过去的调用来绘制出一张依赖关系的架构图。这个图如果对QPS做一些热点的话，还可以帮助我们做一些运维层面的容量规划。&lt;/li&gt;
&lt;li&gt;高级分析建议。比如在全链路压测后定位分析瓶颈所在。定时分析所有组件的执行性能，得出性能衰退的趋势，提早进行问题预警。分析JVM的线程和GC情况，辅助定位High CPU和Memory Leak的问题。退一万步说，即使没有这样的自动化的高级分析，有了调用跟踪的图和组件依赖关系图，至少在出问题的时候我们人能分析出来咋回事。&lt;/li&gt;
&lt;li&gt;Dashboard。非必须，只要数据收集足够全面，如之前文章所示，我们可以用Grafana来进行各种个性化的图表配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源的实现有C实现的&lt;a href=&quot;https://github.com/Qihoo360/Atlas&quot;&gt;https://github.com/Qihoo360/Atlas&lt;/a&gt;以及Go实现的&lt;a href=&quot;https://github.com/flike/kingshard&quot;&gt;https://github.com/flike/kingshard&lt;/a&gt; 等。数据访问中间件是独立部署的数据库的透明代理，本身需要是以集群方式支持高可用，背后还需要对接多套数据库作为一个集群，一般而言会提供如下的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最常用的功能就是读写分离。也包括负载均衡和故障转移的功能，自动在多个从库做负载均衡，通过可用性探测，在主库出现故障的时候配合数据库的高可用和复制做主库的切换。&lt;/li&gt;
&lt;li&gt;随着数据量的增多需要分片功能。分片也就是Sharding，把数据按照一定的维度均匀分散到不同的表，然后把表分布在多个物理数据库中，实现压力的分散。这里写入的Sharding一般而言没有太多的差异，但是读取方面因为涉及到归并汇总的过程，如果要实现复杂功能的话还是比较麻烦的。由于分片的维度往往可能有多个，这方面可以采用多写多个维度的底层表来实现也可以采用维度索引表方式来实现。&lt;/li&gt;
&lt;li&gt;其它一些运维方面的功能。比如客户端权限控制，黑白名单，限流，超时熔断，和调用链搭配起来的调用跟踪，全量操作的审计搜索，数据迁移辅助等等。&lt;/li&gt;
&lt;li&gt;更高级的话可以实现SQL的优化功能。随时进行SQL的Profiler，然后达到一定阈值后提供索引优化建议。类似&lt;a href=&quot;https://github.com/Meituan-Dianping/SQLAdvisor&quot;&gt;https://github.com/Meituan-Dianping/SQLAdvisor&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;其它。极少的代理实现了分布式事务的功能（XA）。还可以实现代理层面的分布式悲观锁的功能。其实细想一下，SQL因为并不是直接扔到数据库执行，这里的可能性就太多了，想干啥都可以。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现上一般需要做下面几件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有一个高性能的网络模型，一般基于高性能的网络框架实现，毕竟Proxy的网络方面的性能不能成为瓶颈。&lt;/li&gt;
&lt;li&gt;有一个MySQL协议的解析器，开源实现很多，拿过来直接用即可。&lt;/li&gt;
&lt;li&gt;有一个SQL语法的解析器，Sharding以及读写分离免不了需要解析SQL，一般流程为SQL解析、查询优化、SQL路由、SQL重写，在把SQL提交到多台数据库执行后进行结果归并。&lt;/li&gt;
&lt;li&gt;Proxy本身最好是无状态节点，以集群方式实现高可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些功能除了Proxy方式的实现还有和数据访问标准结合起来的实现，比如改写JDBC的框架方式实现，两种实现方式各有优缺点。框架方式的实现不局限于数据库类型，性能略高，Proxy方式的实现支持任意的语言更透明，功能也可以做的更强大一些。最近还出现了边车Sidecard方式实现的理念，类似于ServiceMesh的概念，网上有一些资料，但是这种方式到目前为止还没看到成熟的实现。&lt;/p&gt;


&lt;p&gt;类似于数据库的Proxy，这里是以缓存服务作为后端，提供一些集群化的功能。比如以Redis为后端的开源的实现有&lt;a href=&quot;https://github.com/CodisLabs/codis&quot;&gt;https://github.com/CodisLabs/codis&lt;/a&gt;以及饿了么的&lt;a href=&quot;https://github.com/eleme/corvus&quot;&gt;https://github.com/eleme/corvus&lt;/a&gt; 等等。其实不采用Proxy方式做，开发一个缓存客户端在框架层面做也是完全可以的，但是之前也说了这两种方式各有优劣。代理方式的话更透明，如果有Java、Python、Go都需要链接Redis，我们无需开发多套客户端了。一般实现下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式。这是最基本的，通过各种算法把Key分散到各个节点，提供一定的容量规划和容量报警功能。&lt;/li&gt;
&lt;li&gt;高可用。配合Redis的一些高可用方案实现一定程度的高可用。&lt;/li&gt;
&lt;li&gt;运维方面的功能。比如客户端权限控制，黑白名单，限流，超时熔断，全量操作的审计搜索，数据迁移辅助等等。&lt;/li&gt;
&lt;li&gt;跟踪和问题分析。配合全链路监控实现一体化的缓存访问跟踪。以及更智能的分析使用的情况，结合缓存的命中率，Value的大小，压力平衡性提供一些优化建议和报警，尽早发现问题，缓存的崩盘往往是有前兆的。&lt;/li&gt;
&lt;li&gt;完善的管理后台，可以一览集群的用量、性能，以及做容量规划和迁移方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果Redis集群特别大的话的确是有一套的自己的Proxy体系会更方便，小型项目一般用不到。&lt;/p&gt;


&lt;p&gt;之前有提到过，Job是我认为的互联网架构体系中三马车的三分之一，扮演了重要的角色。开源实现有&lt;a href=&quot;http://elasticjob.io/&quot;&gt;http://elasticjob.io/&lt;/a&gt;。Job的管理的实现有两种方式，一种是类似于框架的方式，也就是Job的进程是一直启动着的，由框架在合适的时候调用方法去执行。一种是类似于外部服务的方式，也就是Job的进程是按需要在合适的机器启动的。在本文一开始的图中，我画了一个任务调度的中间件，对于后一种方式的实现，我们需要有一套中间件或独立的服务来复杂Job进程的拉起。整个过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找一些机器加入集群作为我们的底层服务器资源。&lt;/li&gt;
&lt;li&gt;Job编译后打包部署到统一的地方。Job可以是各个语言实现的，这没有关系。可以是裸程序，也可以使用Docker来实现。&lt;/li&gt;
&lt;li&gt;在允许Job前我们需要对资源进行分配，估算一下Job大概需要怎么样的资源，然后根据执行频次统一计算得出一个合适的资源分配。&lt;/li&gt;
&lt;li&gt;由中间件根据每一个Job的时间配置在合适的时候把进程（或Docker）拉起执行，执行前根据当前的情况计算分配一个合适的机器，完成后释放资源，下一次执行不一定在同一台机器执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的中间件是更底层的一套服务，一般而言任务框架会提供如下的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式。Job不会受限于单机，可以由集群来提供运行支持，可以随着压力的上升进行集群扩容，任何一台机器的宕机不会成为问题。如果我们采用中间件方式的话，这个功能由底层的中间件来支持了。&lt;/li&gt;
&lt;li&gt;API层面提供丰富的Job执行方式。比如任务式的Job，拉数据和处理分开的Job。拉数据和处理分开的话，我们可以对数据的处理进行分片执行，实现类似Map-Reduce的效果。&lt;/li&gt;
&lt;li&gt;执行依赖。我们可以配置Job的依赖关系实现自动化的Job执行流程分析。业务只管实现拆散的业务Job，Job的编排通过规则由框架分析出来。&lt;/li&gt;
&lt;li&gt;整合到全链路监控体系的监控跟踪。&lt;/li&gt;
&lt;li&gt;丰富的管理后台，提供统一的执行时间、数据取量配置，提供Job执行状态和依赖分析一览，查看执行历史，运行、暂停、停止Job等等管理功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发布管理其实和开发没有太大的关联，但是我觉得这也是整个体系闭环中的一个环节。发布管理可以使用Jenkins等开源实现，在后期可能还是需要有自己的发布系统。可以基于Jenkins再包一层，也可以如最开始的图所示，直接基于通用的任务调度中间件实现底层的部署。一般而言，发布管理有下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;丰富的任务类型和插件，支持各种语言程序的构建和发布。有最基本的发布、回滚、重启、停止功能。&lt;/li&gt;
&lt;li&gt;支持项目的依赖关系设置，实现自动化的依赖路径上的程序自动发布。&lt;/li&gt;
&lt;li&gt;一些运维层面的控制。比如和CMDB结合做权限控制，做发布窗口控制。&lt;/li&gt;
&lt;li&gt;用于集群的发布流程。比如可以一览集群的分组，设置自动的灰度发布方案。&lt;/li&gt;
&lt;li&gt;适合自己公司的发布流程。比如在流程控制上，我们是Dev环境到QA到Stage到Live。其中，QA环境经过QA的确认后可以进入Stage环境，经过开发主管的确认后可以到Stage环境，经过产品经理的确认后可以进入Live环境进行发布。在发布系统上我们可以结合OA做好这个流程的控制。&lt;/li&gt;
&lt;li&gt;在构建的时候，集成单元测试，集成编码规范检查等等，在后台可以方便的看到每一次发布的代码变更，测试执行情况以及代码规范违例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Jenkins等系统在对于1和2做的比较好，对于和公司层面其它系统的结合无能力为，往往处于这个原因我们需要在Jenkins之上包装出来自己的发布系统。&lt;/p&gt;

&lt;p&gt;总结一下，之所以标题说不断耕耘的基础中间件，是指中间件也好框架也好，往往也需要一个小团队来独立维护，而且功能是不断迭代增加，这套体系如果结合的好，就不仅仅是实现功能这个最基本的标准了，而是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运维自动化API化和AI化的很重要的构成。把控是因为我们掌握了数据流，数据都是从我们的中间件穿越过去到达底层的服务、数据库、缓存，有了把控就有了自动化的可能，有了智能监控一体化报警的可能。&lt;/li&gt;
&lt;li&gt;也因为数据流的经过，通过对数据进行分析，我们可以给到开发很多建议，我们可以在这上面做很多标准。这些事情都可以由框架架构团队默默去做，不需要业务研发的配合。&lt;/li&gt;
&lt;li&gt;因为底层数据源的屏蔽，加上服务框架一起，我们实现的是业务系统被框架包围而不是业务系统在使用框架和中间件这么一个形态，那么对于公司层面的一些大型架构改造，比如多活架构，我们可以实现业务系统的改造最小。数据+服务+流程都已经被中间件所包围和感知，业务系统只是在实现业务功能而已，我们可以在业务系统无感知的情况下对数据做动态路由，对服务做动态调用，对流程做动态控制。如下图，是不是有点Mesh的意思？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202505830-883895301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文很多地方基于思考和YY，开源组件要实现这个理念需要有大量的修改和整合，很多大公司内部都一定程度做了这些事情，但是也因为框架的各种粘连依赖无法彻底开源，这块工作要做好需要大量的时间精力，真的需要不断耕耘和沉淀才能发展出适合自己公司技术栈的各种中间件和管理系统体系。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 12:25:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 【下载本文PDF进行阅读】 一般而言中间件和框架的区别是，中间件是独立运行的用于处理某项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9652134.html</dc:identifier>
</item>
<item>
<title>用量子物理学原理解释为什么振金可以吸收能量（论发散思维的重要性） - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/9652126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/9652126.html</guid>
<description>&lt;h2&gt;写了很多年技术文章，现在也来做做科普，另外，也让大家体验下思维的真正力量。知识并不重要，重要的是驾驭知识的能力以及天马行空的想象力！希望广大读者不要将本文当成一篇普通的科普文章，而当做进入思维殿堂的入口。无论读者从事哪种职业，思维，尤其是发散思维，都会对你未来的人生起到至关重要的影响。&lt;/h2&gt;
&lt;h3&gt;说在前面的话&lt;/h3&gt;
&lt;p&gt;尽管本文标题是做一下量子物理学科普以及解释为什么“振金”可以吸收能量，但本文所展现的知识关联和联想能力是一切科学（包括但不限于计算机、物理、化学、生物学、机械工程学）所必备的基本素养，只有拥有这些能力，才会在科学研究以及工作中有新的突破。不管你是程序员、还是科学家、工程师、医生、教师，都会从这种能力中获得力量。&lt;/p&gt;
&lt;p&gt;本文将回答如下为什么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么原子要不断运动&lt;/li&gt;
&lt;li&gt;如何得知亿万光年外天体的大气组成&lt;/li&gt;
&lt;li&gt;为什么我们会感觉到太阳的温暖&lt;/li&gt;
&lt;li&gt;高温火焰为什么是蓝色的&lt;/li&gt;
&lt;li&gt;电子真的存在吗&lt;/li&gt;
&lt;li&gt;在量子世界中原子和电子有怎样的关系&lt;/li&gt;
&lt;li&gt;光的频率是怎样产生的&lt;/li&gt;
&lt;li&gt;美国队长的盾×××为什么能那么抗揍&lt;/li&gt;
&lt;li&gt;“振金”为什么能吸收能量&lt;/li&gt;
&lt;li&gt;“振金”为什么能为瓦坎达提供能源&lt;/li&gt;
&lt;li&gt;“振金”在通过磁悬浮高速列车运输时为什么要使用声波稳定器才安全&lt;/li&gt;
&lt;li&gt;“振金”汽车为什么会被脉冲武器轻而易举摧毁&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;相信很多人都看过漫威旗下的各种超级英雄电影。尤其是2018年上映的几部，如黑豹、复仇者联盟3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-e1955b56b4ff03f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过我在这里并不会讨论电影的细节。而是将焦点放在《黑豹》中的虚构国家瓦坎达中特有的金属“振金”上。尽管漫威宇宙和《黑豹》的故事是完全虚构的，但科幻也分为硬科幻和软科幻，像那些什么玄幻小说，完全胡说八道那种，很明显属于软科幻，也就是毫无科学依据，完全凭作者的想象力写成的。而硬科幻尽管故事情节是虚构的，但很多高科技产品或武器都是以现实世界的科学理论为基础的延伸，就拿“振金”来说，最引人注目的特性就是可以吸收能量。那么问题来了，“振金”也是金属的一种，为什么可以吸收能量呢？吸收的能量跑到哪里去了，其实这个问题完全可以用量子物理学解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-dcf973acca4c0044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;量子物理，听起来好高深的样子，好像是只有极少数科学家才能玩的东西。其实如果你不试图用复杂的数学公式去证明假设和推导理论的话，还是相对好理解的，因为量子就在我们身边。&lt;/p&gt;
&lt;p&gt;首先要理解一下什么是量子。要将这个词分成两部分，一个是“量”，一个是“子”，“量”是指能量的意思，“子”是指粒子的意思。也就是说，“量子”的意思就是“带有能量的粒子”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-bb698eefac8c1036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在暂时将量子抛到一边，感受一下太阳给我们带来的温暖，然而这些温暖的感觉是怎样来的呢？ 太阳距离地球1个天文单位（约1.5亿公里），我们怎么会感觉到离得如此遥远的天体的温度呢？&lt;/p&gt;
&lt;p&gt;我们拿着三棱镜反射阳光，会看到三棱镜将太阳光分解成多种不同颜色的光，这就是大家再熟悉不过的七色光（赤橙黄绿青蓝紫）。那么为什么会有不同颜色的光呢？其实有过一点点光学知识的同学都应该清楚，光的颜色是由频率决定的，频率越高，颜色就越偏蓝，频率越低，颜色就越偏红。频率低到一定程度，发出来的光肉眼就看不到了，称为红外线，频率高到一定程度，发出来的光肉眼也看不到了，称为紫外线。而只有在一定频率内的光，肉眼才会看到，称为可见光，也就是三棱镜反射出来的七色光。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-c457b33bfb6be55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实不同物质发出的光的频率是不同的，所以我们会看到五彩缤纷的世界，不同物质发出不同频率的光的特性在天文学上有一个非常重要的应用，就是分析亿万光年外天体的大气成分。由于不同物质（包括各种气体）会发出不同频率的光，所以氢气、氦气、氧气、氮气发出的光的频率是不同的，只要分析接收到的光谱，就可以很容易得知是什么物质发出来的光，从而得知这个天体的气体成分。&lt;/p&gt;
&lt;p&gt;通过光学的基础知识，只能得出光的颜色和频率的关系。但问题又来了，为什么不同物质可以发出不同频率的光呢？为什么在火把面前会感受到它的温度呢？&lt;/p&gt;
&lt;p&gt;不管是初等化学，还是初等物理，都会讲到物质的最小单元是原子，原子由原子核和围绕在原子核周围的电子组成。原子核带正电、电子带负电，正负抵消，所以物质才不带电。其实这只是表象而已。&lt;/p&gt;
&lt;p&gt;对于刚开始接触物理和化学的学生，老师只会给他们讲这个，因为更高深的理论可能老师也不太清楚。然而，在1925年，著名物理学家海森堡就已经给出了答案：电子并不总是存在，而只在原子相互作用下才存在的。&lt;/p&gt;
&lt;p&gt;在1925年的一个晚上，海森堡一个人在大街上一边散步，一边思考高深的物理问题（也就是本文要涉及的量子理论），在1925年，可不像现在半夜12点还灯火通明，到了晚上，基本就是漆黑一片，只有零星的路灯，周围的环境只比绝对漆黑亮一点。海森堡突然看到前方一个人在走路，由于路灯的作用，那个人走到的路灯下，会清楚地看到那个人，当走到黑暗的地方，那个人就会消失，于是海森堡灵光乍现，意识到那个人并不是真的显现或消失，只是在路灯和黑暗的作用下才会若隐若现，于是迅速回到办公室，经过复杂的数学计算，得到了我们前面给出的结论：电子并不总是存在，而只在原子相互作用下才存在。&lt;/p&gt;
&lt;p&gt;那么这个结论是什么意思呢？基本的意思就是电子和科幻电影一样，为了解释物质是中性的而虚构出来的，那么物质确实是中性的，这又怎么解释呢？其实解释只有一个，电子确实存在，但并不像我们想象的那样，将原子核比作恒星，电子比作若干个行星，围绕着原子核恒星旋转，其实这完全是错误的理解。这只是用宏观世界的展现形式来理解微观世界，量子世界与宏观世界完全是两回事（看过《蚁人》的同学应该很清楚）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-e905e59460fd59c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实有一股能量将原子核的能量抵消掉了，这是一堆能量包，或者称为量子的集合（带有能量的粒子），现在的问题是，这些能量包是如何产生的呢？这就要看海森堡的下半句话了：而只在原子相互作用下才存在。这里的原子相互作用是指原子之间的相互碰撞。碰撞就会产生能量，这些能量就是我们所说的电子，也就是说，电子本质上是经过原子（其实就是原子核）之间不断碰撞而产生的能量包。而不是大多数人认为的像玻璃球一样真实存在的带有维度的小颗粒。这里还有一个隐含的意思，就是为了产生大量的能量包（电子），组成物质的原子必须不断地运动，也就是说，地球上存在的所有物质中的原子都不是静止的，而是不断运动，相互碰撞的。&lt;/p&gt;
&lt;p&gt;当原子之间碰撞产生能量包后，能量包（也可以成为量子）会沿着不同轨道运动，不过根据量子含有的能量大小不同，这些量子会突然跳到另外的轨道，在物理学上称为“量子跃迁”，量子跃迁可能会很多次，在一定时间内，量子跃迁的次数称为量子跃迁的频率。某种物质的原子的量子跃迁频率是固定的，而原子之间的碰撞会不断进行，所以量子也会不断产生，就会有很多量子脱离原子，以电磁波形式向外传播，这就是为什么我们会感觉到火把、太阳光的温度，因为我们被脱离原子的量子击中。那么每一个量子到底带多少能量呢？我们都知道爱因斯坦的能量公式：E = mc^2。但在量子物理学中还有另外一个用于计算量子包含能量的公式：E = kv。其中k是普朗克常数，而v是一个变量，表示量子跃迁的频率，从光学角度看，就相当于光波的频率。这里的光波本质上就是量子以电磁波形式传播，所以光本身拥有波粒二象性。也就是说，既可以用波的理论解释，也可以用粒子理论解释。根据这个公式，很显然，量子跃迁的频率越高，包含的能量越大，从宏观表现看就是我们的皮肤感觉到越热。&lt;/p&gt;
&lt;p&gt;由于量子跃迁的宏观表现就是光的频率，量子跃迁频率越高，光的频率越高，也就是光的颜色越偏蓝色，这样我们就会感觉到越热。所以温度的高低不是由总能量决定的，而是由光的频率（量子跃迁频率）决定的，这也是为什么高温的火焰都是呈现蓝色的原因。&lt;/p&gt;
&lt;p&gt;前面说了一大堆，最终得到了一个理论，或称为一个知识点。也就是组成任何已知的物质的原子都是在不断运动的，以便产生量子来抵消原子核的能量，还有就是向外不断以电磁波形式发射能量包（量子）。现在回到本文的主题“振金”上来，根据漫威宇宙的描述，“振金”的原子是完全静止的，也就是说，“振金”内部是不会产生任何量子的。当然，这也会带来科学上的不严谨，如果不产生量子，物质就会带有能量，很显然，“振金”表面上不带任何能量，只会吸收能量。我们暂且做一个假设，“振金”的原子核也比较特殊，即使没有量子，在一般情况下，也不会将能量释放出来。但在高速运动（注意，这是一个彩蛋）或在巨大力量撞击时，就会释放原子核中的能量。&lt;/p&gt;
&lt;p&gt;看过《美国队长》全系列以及《复仇者联盟》全系列的同学应该了解美国队长的盾×××，这不是普通的盾×××，而是用“振金”做成的盾×××，就是用这个盾×××，挡住了×××、挡住了×××、挡住了绿巨人的拳头、挡住了雷神的锤子，甚至挡住了获得6块无限原石的灭霸的一记重拳。这些×××都有一个共同点，就是冲击力巨大。而“振金”的特性就是当遇到巨大冲击力时，原子核的能量就会释放（根据冲击力的大小，会释放相应等级的能量），但由于冲击力同样会产生巨大的能量，所以冲击力的能量和原子核所释放的能量正好抵消了，这也是为什么用“振金”做的盾×××几乎可以抵御任何强度的能量×××原因。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-02d6b5410c966e5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实“振金”还有另外一个用途，就是可以提供能源，而且是绝对清洁的能源。因为“振金”原子核蕴含着巨大的能量，通过某些方式可以让其释放，所以瓦坎达人发现这一特性后，科技就迅速崛起，因为能源是文明发展的基石，一个文明能控制的能源越多，就发展的越快，科技也会越先进。不过当瓦坎达人在用高速磁悬浮列车运输“振金”时，却需要将“振金”稳定，而黑豹-特查拉同父异母的妹妹苏瑞公主想到一个办法，用声波稳定器在运输的过程中稳定“振金”。之所以要稳定“振金”，就是因为“振金”中的原子核不光在受到巨大冲击力时会释放能量，而且在高速运动时也会释放能量，相信瓦坎达在以前研究“振金”时也因此出过事，死过人，所以才想到这样一个办法。&lt;/p&gt;
&lt;p&gt;《黑豹》中并没有解释过声波稳定器的原理，但根据量子理论不难猜到，无外乎用以下两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增强原子核的稳定性，让其在高速运动时不会释放能量。&lt;/li&gt;
&lt;li&gt;让“振金”的原子像普通物质的原子核一样运动和碰撞，产生足够中和“振金”原子核释放出的能量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管用那种方法，声波稳定器会将“振金”暂时变成普通的金属。这也就是为什么黑豹的“振金”战衣在受到声波稳定器的影响后不能保护黑豹的原因，因为战衣已经暂时变成了由普通金属做成的战衣了。&lt;/p&gt;
&lt;p&gt;在《黑豹》中还有一个场景，瓦坎达人驾驶着由“振金”做成的汽车追一些偷“振金”的贼，结果被有个家伙用从瓦坎达偷走的脉冲武器击中了“振金”汽车，结果“振金”汽车立刻零碎了。很多漫威粉感到奇怪，“振金”盾×××甚至可以抵御灭霸的拳头，难道区区一个脉冲枪都抵挡不了？看到有很多人解释，是由于“振金”汽车中参有其他普通金属，脉冲武器就是击中了这些普通金属，所以才会让“振金”汽车解体。我要说的是，你在逗我吗？瓦坎达的“振金”堆成山，就连灯罩都用“振金”做的，还缺汽车上的那几块金属？怎会让“振金”汽车有这么严重的瑕疵。&lt;/p&gt;
&lt;p&gt;“振金”汽车被脉冲武器摧毁的原因只有一个。就是脉冲武器的原理类似于声波稳定器，可以让“振金”暂时变成普通金属，无法吸收能量。而“振金”汽车并不像普通的汽车通过焊接和螺丝组装在一起。而是通过“振金”零部件中蕴含的能量通过某种方式连接在一起的，当“振金”变成普通金属后，无法吸收能量，这些连接就自动失效了，而且脉冲武器应该也会带有一定的能量输出。所以“振金”汽车就会四分五裂。不过“振金”汽车并没有爆炸哦，甚至连一点火花都没有。这也说明一点，“振金”汽车使用的能源并不是普通汽车使用的汽油或电能，而是使用“振金”本身的能源，也就是说，“振金”汽车本身就是一块超级电池，这块电池释放出的能量也许够这辆汽车使用10000年。估计现在要是有这样的电池，特斯拉就会立刻破产了。&lt;/p&gt;
&lt;p&gt;好了，本文要解释的理论都说完了，最后感谢漫威宇宙和瓦坎达给我们带了的视觉盛宴、丰富的想象力以及背后的科学知识，瓦坎达万岁！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-8923ff4638294622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 12:21:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>写了很多年技术文章，现在也来做做科普，另外，也让大家体验下思维的真正力量。知识并不重要，重要的是驾驭知识的能力以及天马行空的想象力！希望广大读者不要将本文当成一篇普通的科普文章，而当做进入思维殿堂的入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nokiaguy/p/9652126.html</dc:identifier>
</item>
<item>
<title>程序员如何自我成长 - Learning hard</title>
<link>http://www.cnblogs.com/zhili/p/9652010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhili/p/9652010.html</guid>
<description>&lt;p&gt;&lt;span&gt;大多数未毕业和工作不久的程序员同学都存在以下几点迷茫：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对未毕业的计算机同学来说，存在迷茫点有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 不知道社会上企业需要怎样的技能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 不知道如何选择第一份工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 在大学接下来的日子如何提升自己，为找工作做准备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对工作5年之内的程序员同学来说，普遍存在的迷茫点有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 工作过程中如何提升自我技能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 跳槽面试超级不自信，觉得工作1-2年感觉什么都没学到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 自己渴望有所提升，希望有大牛带领自己提升，但是迟迟找不到，非常困惑如何提高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 对自己后面工作规划完全不清楚，担心下一份工作坑更大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文，将对以上迷茫点结合自己的一些经历来给广大存在迷茫的同学指引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对还未毕业的程序员同学而言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先第一点，不知道企业需要怎样的技能，针对这点相信有一些动手能力的同学都会上网百度类似“Java 面试题”或者“买一些面试宝典的书籍”，没有动手能力的同学可能希望大牛告诉他们答案。也许是因为他们觉得网上的帖子不够专业吧。但是这里需要强调的一点就是，做程序员最重要的是动手能力，所以我这篇文章做完指引之后，大家一定也去看和实践。别空想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里针对第一点，我这边给出2篇认为比较全面的知识点的文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//maimai.cn/article/detail%3Ffid%3D363806014%26from%3Dtimeline&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;阿里，百度，腾讯等一线互联网公司招聘Java程序员的技术标准&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/JMo0W8nJ05LpBQglkN4GBA&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;Java面试通关要点 汇总集【最终版】&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家可以在校期间可以努力把这2篇文章中的知识点弄懂，相信出来的找工作的时候就能游刃有余了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第二点，不知道如何选择第一份工作，我个人的建议，毕业后第一份工作比较重要，如果有好学历的同学可以优先考虑去BAT等这样的大公司，因为大公司对于人的培养比较看重，尤其自己刚工作，不知道如何选择的时候，如果没有好学历的同学，也有一些参考指标：去一些比较有潜力的创业公司。比如电商、金融、旅游等领域。实在没有不好区分，或者进第一家公司后，感觉不是自己很满意的，也不要自暴自弃或者立刻选择离开。这时候应该静下来心来，想想当初选择这家公司是什么吸引你，以及你最初想进来打算如何做。如果目前没有达到你最初想进来学到的水平，那先不要换新的机会，因为这样你同样到另一家也会面临这样的情况。目前可以按照自己的初衷，先在这家公司学习，公司给不了平台，先自己学习，网上那么多资料，书籍，现在想学的技术，或者其他方面，相信自然可以找到地方可以让你提升的，然后在看看公司有没有项目可以拿来实践，这个实践如果老大不认可，你可以抽一个模块用私底下的时间来做练习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第三点，也就是好好把第一点列出来的知识点去看去实践，摸透模深。同时某些点可以结合一些网上好的开源项目，比如阿里的dubbo、 spring 框架等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对工作了1到5年的小伙伴：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能未工作的时候未做好规划，或者工作后又陷入迷茫了，也大多数会有我以上列出的几点问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第一点，工作过程中不知道如何提升。其实这点我觉得很多人根本不是不知道，而是懒得做。或者说没有执行力吧，或者觉得学了这个之后好像没什么用等待想法。工作中的提升我总结下来分为几个点（后面还有更大一些点）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 技术能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 沟通能力和学习能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 责任心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 行业的看法和管理人的能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，不知道如何提升的同学，可以针对这几点进行提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;技术能力——无非也就是前面列出的一些知识点。以及多看一些技术博客、书籍和开源代码。但是看的过程中，一定要多为自己多个为什么？dubbo 的超时机制是如何实现的、netty如何做到高性能的、Spring是如何做到自动注入的、Spring的类的加载方式怎么完成等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;沟通能力和学习能力——这点就看自己了，需要做大量第一点的练习，一步步积累学习能力。等你懂了很多原理性的东西之后，看的源码实现方式多了之后，学习能力自然提升了。沟通能力可以看看一些软文、书籍、如：人性的缺点、好好说话等书籍吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;责任心——这个可能需要工作过程中慢慢培养的吧。总之，就是做一个靠谱的人，怎样算一个靠谱的人，今天看到的一句话就是,凡事有交代、件件有着落、事事有回音。觉得概况的非常好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;行业的看法和管理能力——这点就是慢慢自己积累了，可以通过一些书籍和文章进行参考。例如 技术领导力、技术管理之巅等书籍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第二点，跳槽不自信。有这个问题，根源还是出在第一个问题上面。因为有些同学在之前工作过程中，以上4点能力根本没有提升，但是又不满足现在的公司，所以想跳槽，但是面试被打击后就越来越不自信了，不知道如何提升可以面试到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我还是那句话，对于程序员来说，动手非常重要，不自信是因为你不懂，所以要让自己自信，需要从0开始，做好一件或者多件自己之前不擅长的事情，这样慢慢就会有底气有自信。做成一件不擅长的事情包括：弄懂一个自己不了解的技术点，如Spring 框架原理等、如自己英语不好，从头开始学，最后取得好的成绩点。这个点没有人可以帮助到你，只有你自己，坚持、耐得住&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第三点，是和第一点有重合，第一点也介绍具体如何提升了的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于第四点，在换下一份工作的初衷吧。有些人同学可能会为了钱换一份工作、有些会为了发展、能力的提升。所以如果是为了钱，你就换一家高薪的，能够换到的前提在于前面说的4点的提升。如果是为了持续发展，这时候就需要找一些大的平台，以及知名的平台的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天本篇文章的介绍就到这里，如果觉得对有有所启发和帮助，帮忙转发和赞赏下的，谢谢。如果有任何问题，也随时欢迎和我沟通的&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 12:04:00 +0000</pubDate>
<dc:creator>Learning hard</dc:creator>
<og:description>大多数未毕业和工作不久的程序员同学都存在以下几点迷茫： 针对未毕业的计算机同学来说，存在迷茫点有： 1. 不知道社会上企业需要怎样的技能 2. 不知道如何选择第一份工作 3. 在大学接下来的日子如何提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhili/p/9652010.html</dc:identifier>
</item>
<item>
<title>告别set和get，两大利器轻松搞定model转换 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/lombok_and_orika.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/lombok_and_orika.html</guid>
<description>&lt;p&gt;&lt;strong&gt;场景一：&lt;/strong&gt;一般我们遇到需要新建model，常规做法就是创建一个类，老老实实的定义好model中的所有属性，一般来说属性对应的set方法和get方法都是少不了的，有时候还需要toString甚至equals和hashCode方法。&lt;/p&gt;
&lt;p&gt;现在的IDE已经很成熟了，一般不会手写set和get方法，采用IDE自带的快捷方式自动生成居多。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201809/619240-20180915195842693-420507235.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方式相对手写方法来说，效率已经有了很大的提升，但还是有进一步的提升空间（下文会介绍）。而且该种方式维护性较差，当需要修改某个属性名称或者属性类型时，对应的set和get方法以及toString都需要调整。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景二：&lt;/strong&gt;大部分时候，我们都是基于当前流行的微服务架构和SSM（Spring+Spring MVC + Mybatis）框架进行开发，这时候我个人经常遇到一个问题就是model的转换问题。&lt;/p&gt;
&lt;p&gt;不同层会有不同的model，比如DAO层的model，service层的model，对外API接口的model，还有更上层的controller层的model以及提供给前端的View model。&lt;/p&gt;
&lt;p&gt;为了能够是接口正常调用，我们不得不处理这些model的转换，没有一个称手的工具，我们只能手写转换类，通过一个又一个的set和get方法来完成model的转换。&lt;/p&gt;
&lt;p&gt;有时候，我们在测试接口的时候发现有些属性没有值，调试半天才发现，是因为其中一个属性忘记写set方法了。我们明知道这些工作并不需要太多的思考，但是却不得不小心翼翼的对待。&lt;/p&gt;
&lt;p&gt;那么，是否有更加优雅的处理方式，请看下文介绍&lt;/p&gt;
&lt;h3 id=&quot;lombok&quot;&gt;Lombok&lt;/h3&gt;
&lt;p&gt;这是一个插件，能够很好的解决&lt;strong&gt;场景一&lt;/strong&gt;中的难题&lt;/p&gt;
&lt;h4 id=&quot;下载安装&quot;&gt;下载安装&lt;/h4&gt;
&lt;p&gt;我用的IDE是Intellij idea，可以在Preferences-&amp;gt;Plugins中找到相应的插件安装并重启即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201809/619240-20180915195855343-388976589.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该插件的实现已经放在github上，有兴趣可以到https://github.com/mplushnikov/lombok-intellij-plugin查看&lt;/p&gt;
&lt;h4 id=&quot;lombok使用&quot;&gt;lombok使用&lt;/h4&gt;
&lt;h5 id=&quot;添加jar包依赖&quot;&gt;添加jar包依赖&lt;/h5&gt;
&lt;p&gt;在你需要的项目的pom文件中添加如下的依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;1.16.18&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;编写model&quot;&gt;编写model&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

import java.util.Date;

public class AuthorDTO {   private String name;

    private Date birthday;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;添加需要的注解&quot;&gt;添加需要的注解&lt;/h5&gt;
&lt;p&gt;Lombok可以通过注解的方式实现你需要添加的方法，比如你需要添加这些属性对应的set方法，那么只要在model类上添加注解&lt;code&gt;@Setter&lt;/code&gt;即可，相应的，如果需要get方法添加&lt;code&gt;@Getter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外还有&lt;code&gt;@ToString&lt;/code&gt;，&lt;code&gt;@NoArgsConstructor&lt;/code&gt;，&lt;code&gt;@AllArgsConstructor&lt;/code&gt;等方便使用的注解。&lt;/p&gt;
&lt;p&gt;事实上，我们真的只需要这样添加注解的方式，就能够实现轻松调用set和get方法的需要。这样，以后如果model的属性有改变，我们只需要直接改相应的属性即可，不再需要做任何一点多余的操作。&lt;/p&gt;
&lt;h5 id=&quot;将注解还原为具体方法&quot;&gt;将注解还原为具体方法&lt;/h5&gt;
&lt;p&gt;Lombok为我们提供可以将对应注解还原为对应方法的功能。&lt;/p&gt;
&lt;p&gt;点击Refactor-&amp;gt;Delombok选择想还原的方法即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201809/619240-20180915195906441-370068013.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很好用？&lt;/p&gt;
&lt;h3 id=&quot;orika&quot;&gt;Orika&lt;/h3&gt;
&lt;p&gt;Orika是一个简单快速的model拷贝框架。&lt;/p&gt;
&lt;h4 id=&quot;orika使用&quot;&gt;Orika使用&lt;/h4&gt;
&lt;h5 id=&quot;添加jar包依赖-1&quot;&gt;添加jar包依赖&lt;/h5&gt;
&lt;p&gt;在需要使用的项目的pom文件中添加如下依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;ma.glasnost.orika&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;orika-core&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;1.5.2&amp;lt;/version&amp;gt;  &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建两个需要转换的model&quot;&gt;创建两个需要转换的model&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;BookEntity&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.Date;

@Setter @Getter @AllArgsConstructor @NoArgsConstructor public class BookEntity {   private String bookName;

    private String authorName;

    private Date authorBirthday;

    private String bookInformation;

    private Integer type;

} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BookDTO&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

import lombok.Getter;
import lombok.Setter;

@Setter @Getter public class BookDTO {   private String bookName;

    private AuthorDTO author;

    private BookType bookType;

    private BookInfo bookInfo;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：这里的AuthorDTO、BookType和BookInfo如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

import lombok.*;

import java.util.Date;

@Setter @Getter @ToString @NoArgsConstructor @AllArgsConstructor public class AuthorDTO {   private String name;

    private Date birthday;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

public enum BookType {
 NOVEL(1),
    ESSAY(2);

    private int value;

    BookType(int value) {
 this.value = value;
    }   public static BookType getBookType(int value) {
 BookType bookType = null;

        switch (value) {
 case 1:
                bookType = NOVEL;
                break;
            case 2:
                bookType = ESSAY;
                break;
            default:
                break;
        }
 return bookType;
    }   public int getValue() {
 return value;
    } } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika.model;

import lombok.Getter;
import lombok.Setter;

@Setter @Getter public class BookInfo {   private String ISBN;

    private int page;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没看错，就是BookDTO和BookEntity这两个model，需要相互转换，Orika可以帮你搞定，具体看下面是如何实现的。&lt;/p&gt;
&lt;h5 id=&quot;model转换&quot;&gt;model转换&lt;/h5&gt;
&lt;p&gt;我们看到两个model中包含了多种情况&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;属性名称完全一样的，比如bookName&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个属性对应一个对象的，BookDTO中的AuthorDTO对应BookEntity中的authorName以及authorBirthday&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;枚举类型的，比如BookEntity的type和BookDTO的BookType&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JSON类型的，比如BookEntity的bookInformation和BookDTO的bookInfo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1、属性名称完全一样的属性拷贝&lt;/p&gt;
&lt;p&gt;新建测试类OrikaTest&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.wowjava.best.practice.java.orika;

import com.alibaba.fastjson.JSON;
import com.jackie.wowjava.best.practice.java.orika.model.BookDTO;
import com.jackie.wowjava.best.practice.java.orika.model.BookEntity;
import com.jackie.wowjava.best.practice.java.orika.model.BookInfo;
import com.jackie.wowjava.best.practice.java.orika.model.BookType;
import ma.glasnost.orika.MapperFactory;
import ma.glasnost.orika.MappingContext;
import ma.glasnost.orika.converter.BidirectionalConverter;
import ma.glasnost.orika.impl.DefaultMapperFactory;
import ma.glasnost.orika.metadata.Type;

import java.time.LocalDate;
import java.time.Month;
import java.time.ZoneId;
import java.util.Date;

public class OrikaTest {   private static final MapperFactory mapperFactory = new DefaultMapperFactory.Builder().build();

    public static void main(String[] args) {   BookEntity bookEntity = new BookEntity(
 &quot;银河系漫游指南&quot;,
                &quot;道格拉斯·亚当斯&quot;,
                Date.from(LocalDate.of(1952, Month.MARCH, 11).atStartOfDay(ZoneId.systemDefault()).toInstant()),
                &quot;{\&quot;ISBN\&quot;: \&quot;9787532754687\&quot;, \n \&quot;page\&quot;: 279\n }&quot;,
                1);

        BookDTO bookDTO = mapperFactory.getMapperFacade().map(bookEntity, BookDTO.class);

        System.out.println(JSON.toJSONString(bookDTO));
    } } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{&quot;bookName&quot;:&quot;银河系漫游指南&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，只有名称相同的属性被转换了。&lt;/p&gt;
&lt;p&gt;从代码来看，我们不需要做任何特殊化处理就能做到这一点，因为Orika默认就是按照名称相同就拷贝进行处理的。&lt;/p&gt;
&lt;p&gt;2、一个属性对应一个对象的属性拷贝&lt;/p&gt;
&lt;p&gt;这里我们是想BookDTO中的AuthorDTO对应BookEntity中的authorName以及authorBirthday。&lt;/p&gt;
&lt;p&gt;我们只需要添加如下代码即可实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
mapperFactory.classMap(BookDTO.class, BookEntity.class)
 .field(&quot;author.name&quot;, &quot;authorName&quot;)
 .field(&quot;author.birthday&quot;, &quot;authorBirthday&quot;)
 .byDefault()
 .register();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{&quot;author&quot;:{&quot;birthday&quot;:-562060800000,&quot;name&quot;:&quot;道格拉斯·亚当斯&quot;},&quot;bookName&quot;:&quot;银河系漫游指南&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、枚举类型的属性拷贝&lt;/p&gt;
&lt;p&gt;这时候我们需要新建一个转换器并注册到mapperFactory上。&lt;/p&gt;
&lt;p&gt;注册转换器代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
mapperFactory.getConverterFactory().registerConverter(&quot;bookTypeConvert&quot;, new BidirectionalConverter&amp;lt;BookType, Integer&amp;gt;() {
 @Override
 public Integer convertTo(BookType bookType, Type&amp;lt;Integer&amp;gt; type, MappingContext mappingContext) {
 return bookType.getValue();
    }   @Override
 public BookType convertFrom(Integer value, Type&amp;lt;BookType&amp;gt; type, MappingContext mappingContext) {
 return BookType.getBookType(value);
    } });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册转换器代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
mapperFactory.classMap(BookDTO.class, BookEntity.class)
 .field(&quot;author.name&quot;, &quot;authorName&quot;)
 .field(&quot;author.birthday&quot;, &quot;authorBirthday&quot;)
 .fieldMap(&quot;bookType&quot;, &quot;type&quot;).converter(&quot;bookTypeConvert&quot;).add()
 .byDefault()
 .register();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{&quot;author&quot;:{&quot;birthday&quot;:-562060800000,&quot;name&quot;:&quot;道格拉斯·亚当斯&quot;},&quot;bookName&quot;:&quot;银河系漫游指南&quot;,&quot;bookType&quot;:&quot;NOVEL&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、JSON类型的属性转换&lt;/p&gt;
&lt;p&gt;该属性的转换原理和上述的枚举类型转换相同，需要创建转换器并注册使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
mapperFactory.getConverterFactory().registerConverter(&quot;bookInfoConvert&quot;, new BidirectionalConverter&amp;lt;BookInfo, String&amp;gt;() {
 @Override
 public String convertTo(BookInfo bookInfo, Type&amp;lt;String&amp;gt; type, MappingContext mappingContext) {
 return JSON.toJSONString(bookInfo);
    }   @Override
 public BookInfo convertFrom(String s, Type&amp;lt;BookInfo&amp;gt; type, MappingContext mappingContext) {
 return JSON.parseObject(s, BookInfo.class);
    } });



mapperFactory.classMap(BookDTO.class, BookEntity.class)
 .field(&quot;author.name&quot;, &quot;authorName&quot;)
 .field(&quot;author.birthday&quot;, &quot;authorBirthday&quot;)
 .fieldMap(&quot;bookType&quot;, &quot;type&quot;).converter(&quot;bookTypeConvert&quot;).add()
 .fieldMap(&quot;bookInfo&quot;, &quot;bookInformation&quot;).converter(&quot;bookInfoConvert&quot;).add()
 .byDefault()
 .register();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
{&quot;author&quot;:{&quot;birthday&quot;:-562060800000,&quot;name&quot;:&quot;道格拉斯·亚当斯&quot;},&quot;bookInfo&quot;:{&quot;iSBN&quot;:&quot;9787532754687&quot;,&quot;page&quot;:279},&quot;bookName&quot;:&quot;银河系漫游指南&quot;,&quot;bookType&quot;:&quot;NOVEL&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很神奇？&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;相信有了这两大神奇Lombok和Orika，基本上实现了和set和get的真正告别。&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/DMinerJackie/rome&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 12:03:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>你还在自动生成set和get方法，你还在哼哧哼哧的一行行的写model之间的转换，使用这两大利器帮你轻松搞定model转换，从流水线上解放出来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/lombok_and_orika.html</dc:identifier>
</item>
<item>
<title>推荐一款MongoDB的客户端管理工具--nosqlbooster - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9651800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9651800.html</guid>
<description>&lt;p&gt;今天给大家推荐一款MongoDB的客户端工具--nosqlbooster，这个也是我工作中一直使用的连接管理MongoDB的工具。这个工具还有个曾用名--mongobooster。nosqlbooster立志做“The Smartest IDE for MongoDB”。它支持 MongoDB v2.6-4.0所有版本，并且更新升级及时。它既有免费版，也有加强升级的付费版。&lt;/p&gt;
&lt;p&gt;nosqlbooster的官网地址为https://nosqlbooster.com。大家如果想直接下载，可以登入下载网址https://nosqlbooster.com/downloads。&lt;/p&gt;
&lt;p&gt;工具支持Windows、Linux 和 Mac OS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915164219008-989132070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我将常见的一些操作 和大家讲解一下：&lt;/p&gt;
&lt;h2&gt;1 连接登入&lt;/h2&gt;
&lt;p&gt;很多人第一次使用某工具时，往往打怵，排斥，感觉很不好用。我们先从连接操作的具体细节的讲起，来减少这种不适。&lt;/p&gt;
&lt;p&gt;step 1 点击上面工具栏的【Connect】按钮&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915172813760-863345025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; step 2 在弹出的Connections 界面中 点击[Create]按钮。因为是第一次，连接信息要新建。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915172912526-537181329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;step 3 在弹出的Connection Editor 界面编辑登入信息。&lt;/p&gt;
&lt;p&gt;主要有三类信息要求输入 1. Basic；2.Authentication；3.Default Database。&lt;/p&gt;

&lt;p&gt;1. Basic 编辑界面；这时候大家一定要注意Port端口，因为它默认的是27017，大家要根据实际需求调整修改。还有就是Name是显示名称，可以修改为更有代表性的名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915174041758-241915366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.点击【Authentication】，进入Authentication界面。此处需输入 Auth DB 数据（数据库名称），用户数据 和 密码数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915174405898-1183351420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.点击【Default DataBase】，进入Default DataBase界面。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915175408334-2108474745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请一定要输入指定的数据库，否则可能提示错误，如下。&lt;/p&gt;
&lt;p&gt;MongoError：Authentication failed&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915175559741-1094352708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;或者 可以登入进去，但是看不到任何 集合。&lt;/p&gt;
&lt;p&gt;但是，随着版本的升级，新版本这个栏位的值在登入时可能会自动获取前面输入Auth DB的 输入值，但是目前来看还不是很稳定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，还以建议大家手动输入Default DataBase 数据。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2.打开一个新的查询界面&lt;/h2&gt;
&lt;p&gt;在很多工具，都会有一个打开查询界面的按钮。&lt;/p&gt;
&lt;p&gt;例如连接SQL Server的 SSMS客户端，工具栏很明显就有一个功能按钮【新建查询】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915181034387-110301601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单nosqlbooster 工具没有，然人着急，无从下手。&lt;/p&gt;
&lt;p&gt;其实，它可以通过快捷方式来实现。如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915181431406-1040596245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意点击时，请先用鼠标点击选中要指定的集合或数据库】&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;3.查询代码生成器&lt;/h2&gt;
&lt;p&gt;这个工具还有一个查询代码生成器，可以将用户编写的查询语言装换成 MongoDB Shell, JavaScript (Node.js), Java, C# and Python 等各种语言。&lt;/p&gt;
&lt;p&gt;特别有利于初学者 对MongoDB上手，熟悉各种语法。&lt;/p&gt;
&lt;p&gt;例如 将以下的工具语言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915182454914-1682163281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 转换为可以执行C# 语句。从这儿我们可以看到很多C# 语言关于MongoDB的操作写法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915182246024-905556369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 4. 查询语句生成器&lt;/h2&gt;
&lt;p&gt;刚学习MongoDB，可能对一些查询写法比较陌生，没关系，这个工具可以自动生成一些查询语句。&lt;/p&gt;
&lt;p&gt;生成器按钮，点击红色标注的[Query]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915200350630-1552504460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;弹出 可视化的查询编辑器，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180915193948995-1915697854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【OK and Run】就可以生成MongoDB Shell 查询语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【一定要在生成了db.collectionname..find({}) 命令的界面上编辑，否则，点击Query无效】&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;5 可以使用SQL（结构化查询语言）查询&lt;/h2&gt;
&lt;p&gt;在前面的2中，我们说过了，点击【Ctrl+Alt+T】可以打开一个 SQL 查询界面。说明nosqlbooster支持SQL查询语言。&lt;/p&gt;
&lt;p&gt;例如 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.employees.aggregate([ { $group: { _id: &lt;span class=&quot;hljs-string&quot;&gt;&quot;$department&quot;, total: { $sum: &lt;span class=&quot;hljs-string&quot;&gt;&quot;$salary&quot; } }, } ])&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以转换为SQL语言，如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mb.runSQLQuery(` SELECT department, SUM(salary) AS total FROM employees GROUP BY department `);&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其执行结果是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【另外，为了促使自己尽快的熟悉mongo语言和其更高的执行性能，推荐大家还是使用mongo这种JSON类的语言，而不是SQL的语言】&lt;/strong&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 11:51:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>今天给大家推荐一款MongoDB的客户端工具--nosqlbooster，这个也是我工作中一直使用的连接管理MongoDB的工具。这个工具还有个曾用名--mongobooster。nosqlboost</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9651800.html</dc:identifier>
</item>
</channel>
</rss>