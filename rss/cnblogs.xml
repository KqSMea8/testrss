<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>我所理解的HTTP协议 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/9426018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/9426018.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;对于HTTP协议，想必大家都不陌生，在工作中经常用到，特别是针对移动端和前端开发人员来说，要获取服务端数据，基本走的网络请求都是基于HTTP协议，特别是RESTFUL + JSON 这种搭配特别主流。那如果让大家具体讲讲HTTP协议背后的历史、原理、交互流程、与HTTPS区别、身份认证、Web攻防技术等等信息，大家能讲的出来吗，反正我讲的也是一知半解，虽然会经常看这方面的文章，但也只是在具体项目进行开发过程中碰到对某个概念不清楚，才会去特意看下，却没有特意去总结归纳为一直知识点，没有完整的表达描述过，其实对这个知识点还是没掌握好的，所以用写作方式来进行阐述是很好一个方式，目前也正在践行着。&lt;/p&gt;
&lt;h3 id=&quot;思维导图&quot;&gt;思维导图&lt;/h3&gt;
&lt;p&gt;在写作之前，这篇文章主要想讲的内容在以下这张图中，通过做思维导图方式来表达一篇文章内容，我觉得逻辑会特别清楚，同时也是对某个知识点会很好进行总结归纳。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-c953d708184099e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;HTTP&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;http历史&quot;&gt;HTTP历史&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发展由来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在1989 年 3 月， 互联网还只属于少数人。 在这一互联网的黎明期， HTTP 诞生了。CERN（ 欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（ Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。 最初设想 的 基本理念是： 借助多文档之间相互关联形成的超文本（ HyperText），连成可相互参阅的 WWW（ World Wide Web，万维网）。并且版本从 HTTP 1.0 到 HTTP 1.1 再到现在的 HTTP 2.0，目前主流版本还是基于 HTTP 1.1，HTTP 协议同时也是目前互联网上应用最为广泛的一种网络协议，所有的 WWW 文件都必须遵守这个标准，设计HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都知道 HTTP 协议在 根据 TCP/IP 网络分层来看，它是属于应用层，TCP/IP 网络分层总共有5层，它是属于最上层，它的下一层则是 TCP/IP 传输层，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-60330f3a5d61b33f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;TCP通信过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从逻辑平行来看，发送方和接受方都是处于同一平行层，发送方每层传递的信息会在下一层进行信息封装加密，然后逐层传递，通过实际物理链路进行传递，然后接收方接收到信息进行解密分析，不断把报文头信息进行还原，最后处理发送方发送过来的信息，处理完之后，再用同样的方式传递回去，两者传输通信方式是全双工模式。在此之前需要一个建立连接过程，所谓的三次握手，通信结束也有断开连接过程，也就是四次握手断开操作。&lt;/p&gt;
&lt;p&gt;在讲述 HTTP 协议为何了解 TCP/IP 内容呢，因为我们需要知道 HTTP 协议实际通信过程是怎么样的，它所依赖的环境是怎么样的，从切面角度去看，实际是经历了这5层通信，从平面去看，默认以为是客户端与服务端仅仅进行平层通信而已，那是因为封装的方便。&lt;/p&gt;
&lt;h3 id=&quot;http-1.1&quot;&gt;HTTP 1.1&lt;/h3&gt;
&lt;p&gt;因为目前主流在用的还是以 HTTP 1.1 版本为主，那就用这个版本来分析。&lt;/p&gt;
&lt;h4 id=&quot;http请求协议详解&quot;&gt;HTTP请求协议详解&lt;/h4&gt;
&lt;p&gt;一个典型HTTP1.1的请求协议报文结构，大体上可以分为三块，即请求行、头部、消息主体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-c131948e28ff98b3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;HTTP请求报文协议&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求行包含HTTP请求方法、请求的URL、HTTP协议版本三个内容，它们之间以空格间隔，并以回车+换行结束。HTTP请求方法有下面几种,常用的有GET、POST请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OPTIONS&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;li&gt;TRACE&lt;/li&gt;
&lt;li&gt;CONNECT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;请求头部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头部可以分成三个部分，为常用头域、请求头域、实体头域。其中常用头域和实体头域部分内容在响应协议部分也有相同的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用头域&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;缓存控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;HTTP 1.1默认是支持长连接的(Keep-Alive)，如果不希望支持长连接则需要在此域中写入close&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;表明消息产生的日期和时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Pragma&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Trailer&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;给出了发送端可能想要”升级”使用的新版本或协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;显示了报文经过的中间节点(代理、网关)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;请求头域&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;指明请求端可以接受处理的媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;指明请求端可以接受的字符集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;指明请求端可以接受的编码格式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Expect&lt;/td&gt;
&lt;td&gt;允许客户端列出某请求所要求的服务器行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;提供了客户端用户的E-mail地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;指明请求端的网络主机和端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;If-Match&lt;/td&gt;
&lt;td&gt;服务端在响应头部里面返回ETag信息，客户端请求时在头部添加If-Match（值为响应的ETag），服务端接收后判断ETag是否相同，若相同则处理请求，否则不处理请求。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;客户端在请求某一资源文件时，在头部加上If-Modified-Since(值为该资源文件的最后修改时间)，服务端接收后将客户端上报的修改时间与服务器存储的文件的最后修改时间做对比，如果相同，说明资源文件没有更新，返回304状态码，告诉客户端使用原来的缓存文件。否则返回资源内容。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;If-None-Match&lt;/td&gt;
&lt;td&gt;服务端在响应头部里面返回ETag信息，客户端请求时在头部添加If-None-Match(值为响应的ETag)，服务端接收后判断ETag是否相同，若相同，说明资源没有更新，返回304状态码，告诉客户端使用原来的缓存文件。否则返回资源内容。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;If-Range&lt;/td&gt;
&lt;td&gt;该头域与Range头域一起使用，服务端在响应头部里面返回ETag信息,客户端请求时在头部添加If-Range（值为响应的ETag)，服务端接收后判断ETag是否相同，若相同，则返回状态码206，返回内容为Range指定的字节范围。若不相同，则返回状态码200，返回内容为整个实体。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td&gt;客户端在请求某一资源文件时，在头部加上If-Modified-Since(值为该资源文件的最后修改时间)，端接收后将客户端上报的修改时间与服务器存储的文件的最后修改时间做对比，如果相同，则返回资源内容，如果不相同则返回状态码412。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Max-Forwards&lt;/td&gt;
&lt;td&gt;配合TRACE、OPTIONS方法使用，限制在通往服务器的路径上的代理或网关的数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Proxy-Authorization&lt;/td&gt;
&lt;td&gt;代理授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;表示客户端向服务端请求指定范围的字节数量:Range:bytes=0-500表示请求第1个到第501个的字节数量。Range:bytes=100-表示请求第101到文件倒数第一个字节的字节数量。Range:bytes=-500表示请求最后500个字节的数量。Range可以同时指定多组(Range:bytes=500-600,601-999)。并不是所有的服务端都支持字节范围请求的，如果支持字节范围请求，服务端会返回状态码206，若不支持则会返回200，客户端需要根据状态码来判断服务端是否支持字节范围操作。此域可用于断点下载，即在断点处请求后面的内容，也可用于多线程下载同一个文件，每个线程负责一个文件的一部分下载工作，多个线程协同完成整个文件的下载。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;用于指定客户端请求的来源，是从搜索引擎过来的？还是从其它网站链接过来的？服务器根据此域，有时可以用做防盗链处理，不在指定范围内的来源，统统拒绝。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;指明客户端可以接受哪些传输编码。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;实体头域&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Allow&lt;/td&gt;
&lt;td&gt;指明被请求的资源所支持的方法，如GET、HEAD、PUT&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;指明实体内容所采用的编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-Language&lt;/td&gt;
&lt;td&gt;指明实体内容使用的语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;指明请求实体的字节数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;可以用来为实体提供对应资源的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-MD5&lt;/td&gt;
&lt;td&gt;指定实体内容的MD5，用于内容的完整性校验(base64的128位MD5)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Content-Range&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;指定实体的媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;指明实体的过期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Last-Modified&lt;/td&gt;
&lt;td&gt;指明实体最后被修改的时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;http响应协议详解&quot;&gt;HTTP响应协议详解&lt;/h4&gt;
&lt;p&gt;HTTP1.1的响应协议报文结构，大体上可以分为三块，即状态行、头部、消息主体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-268970be1c54f665.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;HTTP响应报文协议&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态行包含HTTP协议版本、状态码、原因短语三个内容，它们之间以空格间隔，并以回车+换行结束。&lt;/p&gt;
&lt;p&gt;状态码由三位数字组成，第一位数字定义了响应类型，主要有如下五种类型的状态码&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;报告（请求被接收，继续处理）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;成功（请求被成功的接收并处理）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;重发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端出错（客户端错误的协议格式和不能处理的请求）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;服务器出错（服务器无法完成有效的请求处理）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;状态码和对应的原因短语详细描述&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;继续&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching Protocols&lt;/td&gt;
&lt;td&gt;切换协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;已创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;202&lt;/td&gt;
&lt;td&gt;Accepted&lt;/td&gt;
&lt;td&gt;接受&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;203&lt;/td&gt;
&lt;td&gt;Non-Authoritative information&lt;/td&gt;
&lt;td&gt;非权威信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No Content&lt;/td&gt;
&lt;td&gt;无内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;205&lt;/td&gt;
&lt;td&gt;Reset Content&lt;/td&gt;
&lt;td&gt;重置内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;部分内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;Multiple Choices&lt;/td&gt;
&lt;td&gt;多个选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;永久移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Found&lt;/td&gt;
&lt;td&gt;发现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;303&lt;/td&gt;
&lt;td&gt;See Other&lt;/td&gt;
&lt;td&gt;见其它&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;Not Modified&lt;/td&gt;
&lt;td&gt;没有改变&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;305&lt;/td&gt;
&lt;td&gt;Use Proxy&lt;/td&gt;
&lt;td&gt;使用代理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;307&lt;/td&gt;
&lt;td&gt;Temporary Redirect&lt;/td&gt;
&lt;td&gt;临时重发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;坏请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;未授权的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;402&lt;/td&gt;
&lt;td&gt;Payment Required&lt;/td&gt;
&lt;td&gt;必需的支付&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;禁用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;没有找到&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method Not Allowed&lt;/td&gt;
&lt;td&gt;方法不被允许&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;406&lt;/td&gt;
&lt;td&gt;Not Acceptable&lt;/td&gt;
&lt;td&gt;不可接受的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;407&lt;/td&gt;
&lt;td&gt;Proxy Authentication Required&lt;/td&gt;
&lt;td&gt;需要代理验证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;408&lt;/td&gt;
&lt;td&gt;Request Timeout&lt;/td&gt;
&lt;td&gt;请求超时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;409&lt;/td&gt;
&lt;td&gt;Confilict&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;410&lt;/td&gt;
&lt;td&gt;Gone&lt;/td&gt;
&lt;td&gt;不存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;411&lt;/td&gt;
&lt;td&gt;Length Required&lt;/td&gt;
&lt;td&gt;长度必需&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;412&lt;/td&gt;
&lt;td&gt;Precondition Failed&lt;/td&gt;
&lt;td&gt;先决条件失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;413&lt;/td&gt;
&lt;td&gt;Request Entity Too Large&lt;/td&gt;
&lt;td&gt;请求实体太大&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;414&lt;/td&gt;
&lt;td&gt;Request-URI Too Long&lt;/td&gt;
&lt;td&gt;请求URI太长&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;415&lt;/td&gt;
&lt;td&gt;Unsupported Media Type&lt;/td&gt;
&lt;td&gt;不支持的媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;416&lt;/td&gt;
&lt;td&gt;Requested Range Not Satisfiable&lt;/td&gt;
&lt;td&gt;请求范围不被满足&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;417&lt;/td&gt;
&lt;td&gt;Expectation Failed&lt;/td&gt;
&lt;td&gt;期望失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;内部服务器错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;501&lt;/td&gt;
&lt;td&gt;Not Implemented&lt;/td&gt;
&lt;td&gt;服务端没有实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;坏网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service Unavailable&lt;/td&gt;
&lt;td&gt;服务不能获得&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;504&lt;/td&gt;
&lt;td&gt;Gateway Timeout&lt;/td&gt;
&lt;td&gt;网关超时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;505&lt;/td&gt;
&lt;td&gt;HTTP Version Not Supported&lt;/td&gt;
&lt;td&gt;HTTP协议版本不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;响应头域&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Ranges&lt;/td&gt;
&lt;td&gt;服务器向客户端指明服务器对范围请求的接受度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Age&lt;/td&gt;
&lt;td&gt;从原始服务器到代理缓存形成的估算时间（以秒计，非负）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ETag&lt;/td&gt;
&lt;td&gt;实体标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Location&lt;/td&gt;
&lt;td&gt;指定重定向的URI&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Proxy-Autenticate&lt;/td&gt;
&lt;td&gt;它指出认证方案和可应用到代理的该URL上的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Retry-After&lt;/td&gt;
&lt;td&gt;如果实体暂时不可取，通知客户端在指定时间之后再次尝试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;指明服务器用于处理请求的软件信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Vary&lt;/td&gt;
&lt;td&gt;告诉下游代理是使用缓存响应还是从原始服务器请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;WWW-Authenticate&lt;/td&gt;
&lt;td&gt;表明客户端请求实体应该使用的授权方案&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;交互流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-855381d9a827fc85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;HTTP通信过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体通信其实就是发送/响应过程，一个请求过去，对方有响应内容来返回，请求发送和响应回答方式，同时 HTTP 1.1 的特点是无状态的、快速响应的，一次连接则马上就断开。HTTP 2.0 则是相反，完善了 HTTP 1.1 出现的问题，两者连接是可复用的，同时可支持并行发送，一次多个文件传递，多个文件响应，支持传递的文件大小以二进制方式，这样确保可支持更大文件，在安全性上比 HTTP 1.1上更强大，具体细节可查阅相关文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL 和 URI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里有必要提下 URL 和 URI 这个两个名词的区别。URL表示标记了一个WWW互联网资源（用地址标记），并给出了他的访问地址。而URI表示一个网络资源，仅此而已。&lt;/p&gt;
&lt;h3 id=&quot;https&quot;&gt;HTTPS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通信流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/788498-39f6429fcb324789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;HTTPS通信过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt;步骤 1：客户端通过发送 Client Hello 报文开始 SSL 通信。 报文中包含客户端支持的 SSL 的指定版本、 加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。&lt;/p&gt;
&lt;p&gt;步骤 2：服务器可进行 SSL 通信时， 会以 Server Hello 报文作为应答。 和客户端一样， 在报文中包含 SSL 版本 以及加密组件。 服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。&lt;/p&gt;
&lt;p&gt;步骤 3：之后服务器发送 Certificate 报文。 报文中包含公开密钥证书。&lt;/p&gt;
&lt;p&gt;步骤 4：最后服务器发送 Server Hello Done 报文通知客户端， 最初阶段的 SSL 握手协商部分结束。&lt;/p&gt;
&lt;p&gt;步骤 5：SSL 第一次握手结束之后， 客户端以 Client Key Exchange 报文作为回应。 报文中包含通信加密中使用 的一种被称为 Pre- master secret 的随机密码串。 该报文已用步骤 3 中的公开密钥进行加密。&lt;/p&gt;
&lt;p&gt;步骤 6：接着客户端继续发送 Change Cipher Spec 报文。 该报文会提示服务器， 在此报文之后的通信会采用 Pre- master secret 密钥加密。&lt;/p&gt;
&lt;p&gt;步骤 7：客户端发送 Finished 报文。 该报文包含连接至今全部报文的整体校验值。 这次握手协商是否能够成功， 要以服务器是否能够正确解密该报文作为判定标准。&lt;/p&gt;
&lt;p&gt;步骤 8：服务器同样发送 Change Cipher Spec 报文。&lt;/p&gt;
&lt;p&gt;步骤 9：服务器同样发送 Finished 报文。&lt;/p&gt;
&lt;p&gt;步骤 10：服务器和客户端的 Finished 报文交换完毕之后， SSL 连接就算建立完成。 当然， 通信会受到 SSL 的保护。 从此处开始进行应用层协议的通信， 即发送 HTTP 请求。&lt;/p&gt;
&lt;p&gt;步骤 11： 应用层协议通信， 即发送 HTTP 响应。&lt;/p&gt;
&lt;p&gt;步骤 12： 最后 由 客户 端断开连接。 断开连接时， 发送 close_ notify 报文。 上图做了一些省略， 这步之后再 发送 TCP FIN 报文来关闭与 TCP 的通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加密算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的加密&lt;strong&gt;算法&lt;/strong&gt;可以分成三类，对称加密算法，非对称加密算法和Hash算法。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。对称加密算法的安全性取决于加密密钥的保存情况，但要求企业中每一个持有密钥的人都保守秘密是不可能的，他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户密钥加密的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的对称加密算法：&lt;/strong&gt;DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的非对称加密算法：&lt;/strong&gt;RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;Hash算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的Hash算法：&lt;/strong&gt;MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数字证书和数字签名证书&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;数字证书是由权威的CA机构颁发的无法被伪造的证书，用于校验发送方实体身份的认证。解决如上问题，只需要发送方A找一家权威的CA机构申请颁发数字证书，证书内包含A的相关资料信息以及A的公钥，然后将正文A、数字证书以及A生成的数字签名发送给B，此时中间人M是无法篡改正文内容而转发给B的，因为M不可能拥有这家CA的私钥，无法随机制作数字证书。当然，如果M也申请了同一家CA的数字证书并替换发送修改后的正文、M的数字证书和M的数字签名，此时B接收到数据时，会校验数字证书M中的信息与当前通信方是否一致，发现数字证书中的个人信息为M并非A，说明证书存在替换风险，可以选择中断通信。&lt;/p&gt;
&lt;p&gt;为什么CA制作的证书是无法被伪造的？其实CA制作的数字证书内还包含CA对证书的数字签名，接收方可以使用CA公开的公钥解密数字签名，并使用相同的摘要算法验证当前数字证书是否合法。制作证书需要使用对应CA机构的私钥，因此CA颁发的证书是无法被非法伪造的（CA的私钥泄露不在考虑讨论与考虑范围内）。&lt;/p&gt;
&lt;p&gt;数字证书签名的基础就是非对称加密算法和数字签名，其无法伪造的特性使得其应用面较广，HTTPS中就使用了数字证书来保证握手阶段服务端传输的公钥的可靠性。&lt;/p&gt;
&lt;p&gt;数字签名是非对称加密算法和摘要算法的一种应用，能够保证信息在传输过程中不被篡改，也能保证数据不能被伪造。使用时，发送方使用摘要算法获得发布内容的摘要，然后使用私钥对摘要进行加密（加密后的数据就是数字签名），然后将发布内容、数字签名和公钥一起发送给接收方即可。接收方接收到内容后，首选取出公钥解密数字签名，获得正文的摘要数据，然后使用相同的摘要算法计算摘要数据，将计算的摘要与解密的摘要进行比较，若一致，则说明发布内容没有被篡改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;身份认证&quot;&gt;身份认证&lt;/h3&gt;
&lt;p&gt;计算机本身无法判断坐在显示器前的使用者的身份。 进一步说， 也无法确认网络的那头究竟有谁。 可见，为了 弄清究竟是谁在访问服务器， 就得让对方的客户端自报家门。 比如，就算正在访问服务器的对方声称自己是 小明， 身份是否属实这点却也无从谈起。 为确认小明本人是否真的具有访问系统的权限， 就需要核对“ 登录者 本人才知道的信息”、“ 登录者本人才会有的信息”。所以才需要以下几种验证。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Basic认证&lt;/strong&gt;：Basic 认证是HTTP中非常简单的认证方式，因为简单，所以不是很安全，不过仍然非常常用。当一个客户端向一个需要认证的HTTP服务器进行数据请求时，如果之前没有认证过，HTTP服务器会返回401状态码，要求客户端输入用户名和密码。用户输入用户名和密码后，用户名和密码会经过BASE64加密附加到请求信息中再次请求HTTP服务器，HTTP服务器会根据请求头携带的认证信息，决定是否认证成功及做出相应的响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Digest认证：&lt;/strong&gt;Digest 认证试图解决 Basic 认证的诸多缺陷而设计，用户密码在整个认证过程中是个关键性要素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL客户端认证：&lt;/strong&gt;从使用用户 ID 和密码的认证方式方面来讲， 只要二者的内容正确， 即可认证是本人的 行为。 但如果用户 ID 和密码被盗， 就很有可能被第三者冒充。 利用 SSL 客户端认证则可以避免 该情况的发生。 SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。 凭借客户端证书认证， 服务器可确认访问是否来自已登录的客户 端。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;web攻防技术&quot;&gt;Web攻防技术&lt;/h3&gt;
&lt;p&gt;常见的web攻击技术有哪些呢，如下：&lt;/p&gt;
&lt;p&gt;1，XSS 跨站攻击技术：主要是攻击者往网页里嵌入恶意脚本，或者通过改变 HTML 元素属性来实现攻击，主要原因在于开发者对用户的变量直接使用导致进入 HTML 中会被直接编译成 JS，通常的 GET 请求通过 URL 来传参，可以在 URL 中传入恶意脚本，从而获取信息，解决方法：特殊字符过滤。&lt;/p&gt;
&lt;p&gt;2，SQL 注入攻击：主要是就是通过把 SQL 命令插入到 Web &lt;strong&gt;表单&lt;/strong&gt;提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令，比如 select * from test where username=&quot;wuxu&quot; or 1=1，这样会使用户跳过密码直接登录，具体解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特殊字符过滤，不要用拼接字符串的方法来凑sql语句。&lt;/li&gt;
&lt;li&gt;对 sql 语句进行预编译，比如 java 的 preparedstatement。&lt;/li&gt;
&lt;li&gt;关闭错误信息，攻击者可能会通过不断的尝试来得到数据库的一些信息，所以关闭错误信息变得重要起来。&lt;/li&gt;
&lt;li&gt;客户端对数据进行加密，使原来传进来的参数因为加密而被过滤掉。&lt;/li&gt;
&lt;li&gt;控制数据库的权限，比如只能 select，不能 insert，防止攻击者通过 select * from test ；drop tables这种操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3，OS 命令注入攻击：系统提供命令执行类函数主要方便处理相关应用场景的功能.而当不合理的使用这类函数，同时调用的变量未考虑安全因素，就会执行恶意的命令调用，被攻击利用。主要原因是服务端在调用系统命令时采用的是字符串连接的方式，比如 a=&quot;a.txt;rm -rf *&quot;,system(&quot;rm -rf {$a}&quot;)，这会给服务端带去惨痛的代价，具体解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在程序开发时少用系统命令，执行命令的参数尽量不要从外部获取。&lt;/li&gt;
&lt;li&gt;参数特殊字符过滤&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4，HTTP 首部注入攻击&lt;/p&gt;
&lt;p&gt;5，邮件首部注入攻击：它允许恶意攻击者注入任何邮件头字段,BCC、CC、主题等,它允许&lt;strong&gt;黑客&lt;/strong&gt;通过注入手段从受害者的邮件服务器发送垃圾邮件。主要是利用邮件系统传参的bug来进行攻击，解决方法：1、使用正则表达式来过滤用用户提交的数据。例如,我们可以在输入字符串中搜索(r 或 n)。2、永远不要信任用户的输入。3、使用外部组建和库&lt;/p&gt;
&lt;p&gt;6，目录遍历攻击：目录遍历是Http所存在的一个安全漏洞，它使得攻击者能够访问受限制的目录，并在Web服务器的根目录以外执行命令。&lt;/p&gt;
&lt;p&gt;7，远程目录包含攻击，原理就是注入一段用户能控制的脚本或代码，并让服务端执行。比如 php 中的include($filename)，而此 filename 由用户传入，用户即可传入一段恶意脚本，从而对服务其造成伤害，解决方法：当采用文件包含函数的时候，不应动态传入，而应该有具体的文件名，如果动态传入，要保证动态变量不被用户所控制&lt;/p&gt;
&lt;p&gt;8，会话劫持：这是一种通过获取用户Session ID后，使用该 Session ID 登录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效 Session。会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏，通俗一点就是用户在登录时，唯一标示用户身份的 session id被劫持，使得攻击者可以用这个 session id 来进行登录后操作，而攻击者主要是通过 窃取：使用网络嗅探，XSS 攻击等方法获得。而第一种方式网络嗅探，我们可以通过 ssl 加密，也就是 https 来对报文进行加密，从而防止报文被截获，而第二种方式xss 攻击，方式在第一种已经给出，不再赘述。此外通过设置 HttpOnly。通过设置 Cookie 的 HttpOnly 为 true，可以防止客户端脚本访问这个 Cookie，从而有效的防止 XSS 攻击，还有就是设置 token 验证。关闭透明化Session ID。透明化 Session ID 指当浏览器中的 Http 请求没有使用 Cookie 来存放 Session ID 时，Session ID 则使用URL来传递。&lt;/p&gt;
&lt;p&gt;9，会话固定：会话固定是会话劫持的一种，区别就是，会话固定是攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；用户携带sessionid进行登录，攻击者获取sessionid来进行会话，解决方案：服务端设置用户登录后的sessionid与登录前不一样即可，另外会话劫持的方法也可以用在会话固定上&lt;/p&gt;
&lt;p&gt;10，csrf跨站伪造请求攻击：其实就是攻击者盗用了你的身份，以你的名义发送恶意请求。&lt;/p&gt;
&lt;p&gt;总的来说，通过输出这么一篇文章，自己的对 HTTP 协议有了进一步的认知，同时也通过写作整理过程让自己对某一个知识点有很好的联想和串联，积累从点开始，然后形成面，最后就会有一个知识树生长起来。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 07:46:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/9426018.html</dc:identifier>
</item>
<item>
<title>从零开始学 Web 之 CSS3（六）动画animation，Web字体 - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/9425553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/9425553.html</guid>
<description>&lt;blockquote readability=&quot;8.7013274336283&quot;&gt;
&lt;p&gt;大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新......&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;github：https://github.com/Daotin/Web&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;a href=&quot;https://github.com/Daotin/pic/raw/master/wx.jpg&quot;&gt;Web前端之巅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博客园：http://www.cnblogs.com/lvonve/&lt;/li&gt;
&lt;li&gt;CSDN：https://blog.csdn.net/lvonve/&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里我会从 Web 前端零基础开始，一步步学习 Web 相关的知识点，期间也会分享一些好玩的项目。现在就让我们一起进入 Web 前端学习的冒险之旅吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;创建动画&quot;&gt;1、创建动画&lt;/h2&gt;
&lt;p&gt;好的前端工程师，会更注重用户的体验和交互。那么动画就是将我们的静态页面，变成具有灵动性，为我们的界面添加个性的一种方式。&lt;/p&gt;
&lt;p&gt;一个动画至少需要两个属性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-name&lt;/code&gt; ：动画的名字（创建动画时起的名字，如下为 moveTest）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-duration&lt;/code&gt; ：动画的耗时&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;animation-name: moveTest;
animation-duration: 2s;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如需在 CSS3 中创建动画，需要学习 &lt;code&gt;@keyframes&lt;/code&gt; 规则。&lt;code&gt;@keyframes&lt;/code&gt; 规则用于创建动画。在 &lt;code&gt;@keyframes&lt;/code&gt; 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@keyframes&lt;/code&gt;关键字来创建动画。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;@keyframes moveTest {
  /*百分比是指整个动画耗时的百分比*/
  0% {
    transform: translate(0px, 0px);
  }
  50% {
    transform: translateY(200px);
  }
  100% {
    transform: translate(200px,200px);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其中，百分比是指整个动画耗时的百分比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        div {
            width: 100px;
            height: 100px;
            background-color: blue;

            animation-name: moveTest;
            animation-duration: 2s;
        }

        @keyframes moveTest {
            0% {
                transform: translate(0px, 0px);
            }
            50% {
                transform: translateY(200px);
            }
            100% {
                transform: translate(200px,200px);
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;0%&lt;/code&gt;：动画起始位置，也可以写成 from&lt;/p&gt;
&lt;p&gt;&lt;code&gt;100%&lt;/code&gt;：动画终点位置，也可以写成 to。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180805150637028-950648312.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;动画的其他属性&quot;&gt;2、动画的其他属性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;：设置动画的播放次数，默认为1次&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-direction&lt;/code&gt;：设置交替动画&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-delay&lt;/code&gt;：设置动画的延迟&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-fill-mode&lt;/code&gt;：设置动画结束时的状态：默认情况下，动画执行完毕之后，会回到原始状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-timing-function&lt;/code&gt;：动画的时间函数（动画的效果，平滑？先快后慢等）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;animation-play-state&lt;/code&gt;：设置动画的播放状态 paused:暂停 running:播放&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*3.设置动画的播放次数，默认为1次  可以指定具体的数值，也可以指定infinite(无限次)*/
animation-iteration-count: 1;
/*4.设置交替动画  alternate:来回交替*/
animation-direction: alternate;
/*5.设置动画的延迟*/
animation-delay: 2s;
/*5.设置动画结束时的状态：默认情况下，动画执行完毕之后，会回到原始状态
forwards:会保留动画结束时的状态，在有延迟的情况下，并不会立刻进行到动画的初始状态
backwards:不会保留动画结束时的状态，在添加了动画延迟的前提下，如果动画有初始状态，那么会立刻进行到初始状态
both:会保留动画的结束时状态，在有延迟的情况下也会立刻进入到动画的初始状态*/
animation-fill-mode: both;
/*6.动画的时间函数:linear,ease...*/
animation-timing-function: linear;
/*设置动画的播放状态  paused:暂停   running:播放*/
animation-play-state: running;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;案例无缝滚动&quot;&gt;3、案例：无缝滚动&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            margin: 0;
            padding: 0;
        }
        div {
            width: 600px;
            height: 100px;
            margin: 100px auto;
            background-color: #ccc;
            overflow: hidden;
        }
        ul {
            width: 200%;
            animation: moveLeft 6s linear 0s infinite;
        }
        ul &amp;gt; li {
            float: left;
            list-style: none;
        }
        li &amp;gt; img {
            width: 200px;
            height: 100px;
        }
        div:hover &amp;gt; ul {
            cursor: pointer;
            animation-play-state: paused;
        }
        @keyframes moveLeft {
            from {
                transform: translateX(0);
            }
            to {
                transform: translateX(-600px);
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img1.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img2.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img3.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;!-- 复制的一份图片 --&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img1.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img2.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;img src=&quot;images/img3.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1、将要显示的图片复制一份，以完成无缝滚动的需求。&lt;/p&gt;
&lt;p&gt;2、然后让 ul 移动整个ul的宽度即可，并且无限循环，就实现无线轮播的效果。&lt;/p&gt;
&lt;p&gt;3、然后在鼠标放上去的时候，使得动画暂停。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180805150653382-1748685789.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例时钟&quot;&gt;4、案例：时钟&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            padding: 0;
            margin: 0;
        }
        .clock {
            width: 300px;
            height: 300px;
            margin: 100px auto;
            border: 10px solid #ccc;
            border-radius: 50%;
            position: relative;
        }
        .line {
            width: 8px;
            height: 300px;
            background-color: #ccc;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .line2 {
            transform: translate(-50%, -50%) rotate(30deg);
        }
        .line3 {
            transform: translate(-50%, -50%) rotate(60deg);
        }
        .line4 {
            width: 10px;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        .line5 {
            transform: translate(-50%, -50%) rotate(120deg);
        }
        .line6 {
            transform: translate(-50%, -50%) rotate(150deg);
        }
        .cover {
            width: 250px;
            height: 250px;
            background-color: #fff;
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .center {
            width: 20px;
            height: 20px;
            background-color: #ccc;
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .hour {
            width: 12px;
            height: 80px;
            background-color: red;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%);
            transform-origin: center bottom;
            animation: clockMove 43200s linear infinite;
        }
        .minute {
            width: 8px;
            height: 100px;
            background-color: blue;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%);
            transform-origin: center bottom;
            animation: clockMove 3600s linear infinite;
        }
        .second {
            width: 4px;
            height: 120px;
            background-color: green;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%);
            transform-origin: center bottom;
            animation: clockMove 60s infinite steps(60);
        }
        
        @keyframes clockMove {
            from {
                transform: translate(-50%, -100%) rotate(0deg);
            }
            to {
                transform: translate(-50%, -100%) rotate(360deg);
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;clock&quot;&amp;gt;
        &amp;lt;div class=&quot;line line1&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;line line2&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;line line3&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;line line4&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;line line5&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;line line6&quot;&amp;gt;&amp;lt;/div&amp;gt;    
        &amp;lt;div class=&quot;cover&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;hour&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;minute&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;second&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;center&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们让秒针step(60)一步一步走，效果更好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180805150711410-516862237.gif&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;web字体&quot;&gt;1、web字体&lt;/h2&gt;
&lt;p&gt;我们有些时候需要在网页上显示一些特殊的字体，如果这些特殊的字体在电脑上没有安装的话，就会显示系统默认的字体，而不是这些特殊的字体。&lt;/p&gt;
&lt;p&gt;这时就有了 Web 字体。开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。它的支持程度比较好，甚至 IE 低版本浏览器也能支持。&lt;/p&gt;
&lt;h2 id=&quot;字体格式&quot;&gt;2、字体格式&lt;/h2&gt;
&lt;p&gt;不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;TureTpe(.ttf)&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;OpenType(.otf)&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Web Open Font Format(.woff)&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Embedded Open Type(.eot)&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SVG(.svg)&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;3、使用步骤&lt;/h2&gt;
&lt;p&gt;需要注意的是，我们在使用 Web 字体的时候，应该首先把需要用到特殊字体的这些字写好，然后在网络上生成这些字体对应的 Web 字体库，并将其下载下来。下图为一个网站生成和下载web字体的网站，点击立即使用就可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180805150737774-402801849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载下来之后，把下在下来的所有文件导入自己的项目，注意路径的匹配问题。&lt;/p&gt;
&lt;p&gt;之后在我们css样式里面使用&lt;code&gt;@font-face&lt;/code&gt;关键字来自定义 Web 字体。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;@font-face {
  font-family: 'shuangyuan';
  src: url('../fonts/webfont.eot'); /* IE9*/
  src: url('../fonts/webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
    url('../fonts/webfont.woff') format('woff'), /* chrome、firefox */
    url('../fonts/webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
    url('../fonts/webfont.svg#webfont') format('svg'); /* iOS 4.1- */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在使用的时候：&lt;code&gt;font-family: &quot;shuangyuan&quot;;&lt;/code&gt; 就可以使用 shuangyuan 这种字体了。&lt;/p&gt;
&lt;h2 id=&quot;字体图标&quot;&gt;4、字体图标&lt;/h2&gt;
&lt;p&gt;字体图标就是我们常见的字体，不过这个字体的表现形式为一个图标。这样我们就可以使用这些特殊的字体来代替精灵图了。&lt;/p&gt;
&lt;p&gt;常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体包，然后就可以像使用文字一样使用图标了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将所有图标打包成字体库，减少请求；&lt;/li&gt;
&lt;li&gt;具有矢量性，可保证清晰度；&lt;/li&gt;
&lt;li&gt;使用灵活，便于维护&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方法一&quot;&gt;4.1、方法一&lt;/h3&gt;
&lt;p&gt;使用方法和Web字体一样。也是先下载需要的图标字体库文件，然后使用关键字 &lt;code&gt;@font-face&lt;/code&gt; 生成自己的web图标字体。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        @font-face {
            font-family: 'iconfont';
            src: url('../fonts/iconfont.eot'); /* IE9*/
            src: url('../fonts/iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
            url('../fonts/iconfont.woff') format('woff'), /* chrome、firefox */
            url('../fonts/iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
            url('../fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */
        }
        .myFont{
            font-family: iconfont;
        }
        /*笑脸*/
        .smile::before{
            content: &quot;\e641&quot;;
            color: red;
            font-size: 50px;
        }
        /*输出*/
        .output::before{
            content: &quot;\e640&quot;;
            color: blue;
            font-size: 50px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--使用字体图标的时候，得自己指定你想使用的图片--&amp;gt;
&amp;lt;span class=&quot;myFont smile&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;myFont output&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;myFont&quot;&amp;gt;&amp;amp;#xe642;&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法二&quot;&gt;4.2、方法二&lt;/h3&gt;
&lt;p&gt;直接在线调用网上web图标 css库&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用的时候：和方法一一样，直接使用类属性 &lt;code&gt;class='fa fa-play&lt;/code&gt; 的方式，fa-play是一个播放的图标，不同的图标的名字含义不同，只需要到 font-awesome 官网（http://www.fontawesome.com.cn/）找到对应的图标的名称即可。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;a href=&quot;javascript:void(0);&quot; class=&quot;fa fa-play&quot;&amp;gt;&amp;lt;/a&amp;gt;  &amp;lt;!--播放图标--&amp;gt;
&amp;lt;a href=&quot;javascript:void(0);&quot; class=&quot;fa fa-arrows-alt&quot;&amp;gt;&amp;lt;/a&amp;gt;   &amp;lt;!--全屏图标--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：class 样式的 第一个 fa 是必写的，表示的是用的 font-awesome 的字体图标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 07:08:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/9425553.html</dc:identifier>
</item>
<item>
<title>项目微管理28 - 反馈 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/9425262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/9425262.html</guid>
<description>&lt;p&gt;路飞试用期期间，按照四代的安排，在内部技术培训结束以后，就直接参与到产品的日常开发和维护中来了。&lt;/p&gt;

&lt;p&gt;在四代规划的转正考核中，在转正的当天，新同学需要准备一份考核，内容只有一个，就是对软件提出修改建议。不过在路飞转正前，其实他已经提出过许多软件的修改建议了，四代最终觉的这个考核似乎有点多余，所以路飞不用经过这个环节了。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805134036604-2082211057.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;而对于转正的另外一个环节，路飞是需要准备的，那就是提出试用期的反馈。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;猫论、摸论和不争论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;说到反馈，就要提及四代一直做事的风格，而提到做事的风格，就要提及一位伟大的前辈。之所以这么说，是因为他有非常有特点的三个论断：“猫论”，“摸论”和“不争论”，不管是不是他老人家的原创，但是是他将这些简单的道理放到建设中，取得了丰功伟绩。&lt;/p&gt;

&lt;p&gt;说到这，你已经知道他是谁了吧！&lt;/p&gt;

&lt;p&gt;“猫论”就是那句经典的“不管白猫黑猫，抓到老鼠就是好猫”。（当然，很多人片面的接受了这句话。）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805134748232-1538718204.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;“摸论”就是指“摸着石头过河”。&lt;/p&gt;

&lt;p&gt;“不争论”指的就是“不争论，是为了争取时间干。一争论就复杂了，把时间都争掉了，什么也干不成。不争论，大胆地试，大胆地闯...证券、股市，这些东西究竟好不好，有没有危险……能不能用？允许看，但要坚决地试。看对了，搞一两年对了，放开；错了，纠正，关了就是了。关，也可以快关，也可以慢关，也可以留一点尾巴。怕什么，坚持这种态度就不要紧，就不会犯大错误”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805134846400-2000562185.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代觉得，这些论断即使是放到互联网时代的瞬息万变的快速演变中，同样意义重大，真的没有哪套理论能这么生动而深刻的描述如何应对新事物或者经验的了。对于新事物或者经验，我们先不要争论其对不对，而是觉的可行，就拿过来试试，不行就调整一下，实在不行就取消嘛。&lt;/p&gt;

&lt;p&gt;而且，从来没有什么经验和教训是直接可以拿到红细胞来直接套用的，引入任何新的理念和方法，都先需要研究可行性，然后再经过“本地化”环节，也就是先将不适合当前团队现状的细枝末节修减掉，然后将新事物的核心思路抽取出来，针对团队的当前状况重新填充一些必要的细节，然后就是在团队中试运行，再接着非常非常重要的一步就是持续的收集团队的反馈，然后根据这些翔实的数据来调整新事物或者取消新事物的采用。&lt;/p&gt;

&lt;p&gt;很多团队引入新经验失败，要么是没有本地化，要么就是没有持续的收集反馈。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805135344160-348548597.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;所以在四代的所有流程中，反馈都是非常重要的一环，针对入职培训和试用期的工作，四代同样也要从当事人收集反馈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;求之于势，不责于人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;路飞对于入职培训，觉得还不错，至少有机会练习了一下演讲的技能，学习了一些新的知识，而对于试用期的工作，他唯一的反馈就是对软件还不怎么熟悉。&lt;/p&gt;

&lt;p&gt;针对这个问题，很多人会说，这摆明是自己不努力嘛，自己应该首先要花时间去熟悉软件啊，这句话没有毛病，对于个人成长来说也非常正确，但是放到一个团队中，就是可以优化的。&lt;/p&gt;

&lt;p&gt;四代始终认同《孙子兵法》中的一句话：“求之于势，不责于人”，这个事情，团队可以构建一种让个人迅速熟悉软件的环境，而不是纯粹的依靠个人的自觉。懒惰是大部分人的天性，不能依靠“自觉和勤奋”这个小概率事件来解决让新人熟悉软件这个问题。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805135514114-217226494.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;能提出反馈，是反馈环节的第一步。如何根据反馈及时做出响应才是更重要的一步。很多的团队貌似提供了很多反馈的途径，但是由于收到反馈没有任何实质性的改变，就导致反馈机制名存实亡。&lt;/p&gt;

&lt;p&gt;就比如四代所在园区的食堂，平时也提供本子和笔，你可以写一些意见，不过他们收集到意见后，基本情况是，领导也就是随便的解释一下面临的困难，敷衍一下，然后就这么过了，然后呢，然后大家自然不会再提什么意见了。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805135753116-1832043480.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;当四代收到了路飞的反馈以后，四代觉得非常有道理，他需要及时做出响应，对于路飞，实习期已经过了，他已经没机会再经历一次实习期了，所以四代只能让他在开发过程中逐渐去熟悉软件的各项功能了。&lt;/p&gt;

&lt;p&gt;不过针对这种情况，四代专门安排了路飞和鼬参与到测试文档的整理工作中，希望通过这样，让他们更快的熟悉起软件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;试用期内容的调整&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;针对路飞的反馈，四代对新人试用期间的工作进行了调整，他觉的是有必要增加一个环节来让新人快速的熟悉软件的各项功能；同时，四代觉得让路飞他们参与到测试文档的做法也不错，那就不如将这个环节加到试用期里面吧。&lt;/p&gt;

&lt;p&gt;说干就干，四代迅速的调整了试用期内的工作内容：&lt;/p&gt;

&lt;p&gt;新人入职前两周，专心参加公司的相关培训和红细胞的内部培训。当然了，内部培训期间，他还是需要准备部分培训内容作为培训考核。培训结束后，紧接着的两周就是参与到技术支持工作中，感受一下客户是怎么使用软件的，软件常见有哪些问题。再接着的两周是配合测试团队整理一部分测试文档并充分的熟悉软件的所有内容。当这些工作结束后，新人再逐渐的参与到开发团队日常的工作中。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805135932895-285395463.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;三个月试用期结束以后，新人要准备实习期的考核，四代思前想后，觉得还是不应该省略这个过程。&lt;/p&gt;

&lt;p&gt;其实对于实习期结束，需不需要考核一直是个问题。&lt;/p&gt;

&lt;p&gt;很多公司没有这个考核，只要实习期表现差强人意就没问题，况且任何人在试用期内都会有意识的表现很好，因为这个阶段公司开除人成本要比转正后开除人低的多，这是一种压力。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201808/109061-20180805140036409-1810830333.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代觉得实习期结束以后还是应该考核一下，这样新人会有个目标，既然作为目标，那么这个考核就不能太随意，那么制定什么样的考核才是合适的呢？四代皱起了眉头。&lt;/p&gt;

</description>
<pubDate>Sun, 05 Aug 2018 06:07:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/9425262.html</dc:identifier>
</item>
<item>
<title>HBase查询优化 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/9425343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/9425343.html</guid>
<description>&lt;p&gt;HBase是一个实时的非关系型数据库，用来存储海量数据。但是，在实际使用场景中，在使用HBase API查询HBase中的数据时，有时会发现数据查询会很慢。本篇博客将从客户端优化和服务端优化两个方面来介绍，如何提高查询HBase的效率。&lt;/p&gt;

&lt;p&gt;这里，我们先给大家介绍如何从客户端优化查询速度。&lt;/p&gt;
&lt;h2&gt;2.1 客户端优化&lt;/h2&gt;
&lt;p&gt;客户端查询HBase，均通过HBase API的来获取数据，如果在实现代码逻辑时使用API不当，也会造成读取耗时严重的情况。&lt;/p&gt;
&lt;h3&gt;2.1.1 Scan优化&lt;/h3&gt;
&lt;p&gt;在使用HBase的Scan接口时，一次Scan会返回大量数据。客户端向HBase发送一次Scan请求，实际上并不会将所有数据加载到本地，而是通过多次RPC请求进行加载。这样设计的好处在于避免大量数据请求会导致网络带宽负载过高影响其他业务使用HBase，另外从客户端的角度来说可以避免数据量太大，从而本地机器发送OOM（内存溢出）。&lt;/p&gt;
&lt;p&gt;默认情况下，HBase每次Scan会缓存100条，可以通过属性hbase.client.scanner.caching来设置。另外，最大值默认为-1，表示没有限制，具体实现见源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * @return the maximum result size in bytes. See {@link #setMaxResultSize(long)}
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  public &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; getMaxResultSize() {
    return maxResultSize;
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Set the maximum result size. The default is -1; this means that no specific
   * maximum result size will be set for this scan, and the global configured
   * value will be used instead. (Defaults to unlimited).
   *
   * @param maxResultSize The maximum result size in bytes.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  public Scan setMaxResultSize(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxResultSize) {
    this.maxResultSize &lt;/span&gt;=&lt;span&gt; maxResultSize;
    return this;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般情况下，默认缓存100就可以满足，如果数据量过大，可以适当增大缓存值，来减少RPC次数，从而降低Scan的总体耗时。另外，在做报表曾显时，建议使用HBase分页来返回Scan的数据。&lt;/p&gt;
&lt;h3&gt;2.1.2 Get优化&lt;/h3&gt;
&lt;p&gt;HBase系统提供了单条get数据和批量get数据，单条get通常是通过请求表名+rowkey，批量get通常是通过请求表名+rowkey集合来实现。客户端在读取HBase的数据时，实际是与RegionServer进行数据交互。在使用批量get时可以有效的较少客户端到各个RegionServer之间RPC连接数，从而来间接的提高读取性能。批量get实现代码见org.apache.hadoop.hbase.client.HTable类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
public Result[] get(List&amp;lt;Get&amp;gt;&lt;span&gt; gets) throws IOException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gets.size() == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
      return new Result[]{get(gets.get(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))};
    }
    try {
      Object[] r1 &lt;/span&gt;=&lt;span&gt; new Object[gets.size()];
      batch((List&lt;/span&gt;&amp;lt;? extends Row&amp;gt;&lt;span&gt;)gets, r1, readRpcTimeoutMs);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Translate.&lt;/span&gt;
      Result [] results =&lt;span&gt; new Result[r1.length];
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object obj: r1) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Batch ensures if there is a failure we get an exception instead&lt;/span&gt;
        results[i++] =&lt;span&gt; (Result)obj;
      }
      return results;
    } catch (InterruptedException e) {
      throw (InterruptedIOException)new InterruptedIOException().initCause(e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从实现的源代码分析可知，批量get请求的结果，要么全部返回，要么抛出异常。&lt;/p&gt;
&lt;h3&gt;2.1.3 列簇和列优化&lt;/h3&gt;
&lt;p&gt;通常情况下，HBase表设计我们一个指定一个列簇就可以满足需求，但也不排除特殊情况，需要指定多个列簇（官方建议最多不超过3个），其实官方这样建议也是有原因的，HBase是基于列簇的非关系型数据库，意味着相同的列簇数据会存放在一起，而不同的列簇的数据会分开存储在不同的目录下。如果一个表设计多个列簇，在使用rowkey查询而不限制列簇，这样在检索不同列簇的数据时，需要独立进行检索，查询效率固然是比指定列簇查询要低的，列簇越多，这样影响越大。&lt;/p&gt;
&lt;p&gt;而同一列簇下，可能涉及到多个列，在实际查询数据时，如果一个表的列簇有上1000+的列，这样一个大表，如果不指定列，这样查询效率也是会很低。通常情况下，在查询的时候，可以查询指定我们需要返回结果的列，对于不需要的列，可以不需要指定，这样能够有效地的提高查询效率，降低延时。&lt;/p&gt;
&lt;h3&gt;2.1.4 禁止缓存优化&lt;/h3&gt;
&lt;p&gt;批量读取数据时会全表扫描一次业务表，这种提现在Scan操作场景。在Scan时，客户端与RegionServer进行数据交互（RegionServer的实际数据时存储在HDFS上），将数据加载到缓存，如果加载很大的数据到缓存时，会对缓存中的实时业务热数据有影响，由于缓存大小有限，加载的数据量过大，会将这些热数据“挤压”出去，这样当其他业务从缓存请求这些数据时，会从HDFS上重新加载数据，导致耗时严重。&lt;/p&gt;
&lt;p&gt;在批量读取（T+1）场景时，建议客户端在请求是，在业务代码中调用setCacheBlocks(false)函数来禁止缓存，默认情况下，HBase是开启这部分缓存的。源代码实现为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Set whether blocks should be cached for this Get.
   * &amp;lt;p&amp;gt;
   * This is true by default.  When true, default settings of the table and
   * family are used (this will never override caching blocks if the block
   * cache is disabled for that family or entirely).
   *
   * @param cacheBlocks if false, default settings are overridden and blocks
   * will not be cached
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  public Get setCacheBlocks(boolean cacheBlocks) {
    this.cacheBlocks &lt;/span&gt;=&lt;span&gt; cacheBlocks;
    return this;
  }

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Get whether blocks should be cached for this Get.
   * @return true if default caching should be used, false if blocks should not
   * be cached
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  public boolean getCacheBlocks() {
    return cacheBlocks;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 服务端优化&lt;/h2&gt;
&lt;p&gt;HBase服务端配置或集群有问题，也会导致客户端读取耗时较大，集群出现问题，影响的是整个集群的业务应用。&lt;/p&gt;
&lt;h3&gt;2.2.1 负载均衡优化&lt;/h3&gt;
&lt;p&gt;客户端的请求实际上是与HBase集群的每个RegionServer进行数据交互，在细分一下，就是与每个RegionServer上的某些Region进行数据交互，每个RegionServer上的Region个数上的情况下，可能这种耗时情况影响不大，体现不够明显。但是，如果每个RegionServer上的Region个数较大的话，这种影响就会很严重。笔者这里做过统计的数据统计，当每个RegionServer上的Region个数超过800+，如果发生负载不均衡，这样的影响就会很严重。&lt;/p&gt;
&lt;p&gt;可能有同学会有疑问，为什么会发送负载不均衡？负载不均衡为什么会造成这样耗时严重的影响？&lt;/p&gt;
&lt;h4&gt;1.为什么会发送负载不均衡？&lt;/h4&gt;
&lt;p&gt;负载不均衡的影响通常由以下几个因素造成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有开启自动负载均衡&lt;/li&gt;
&lt;li&gt;集群维护，扩容或者缩减RegionServer节点&lt;/li&gt;
&lt;li&gt;集群有RegionServer节点发生宕机或者进程停止，随后守护进程又自动拉起宕机的RegionServer进程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这些因素，可以通过以下解决方案来解决：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启自动负载均衡，执行命令：echo &quot;balance_switch true&quot; | hbase shell&lt;/li&gt;
&lt;li&gt;在维护集群，或者守护进程拉起停止的RegionServer进程时，定时调度执行负载均衡命令：echo &quot;balancer&quot; | hbase shell&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.负载不均衡为什么会造成这样耗时严重的影响？&lt;/h4&gt;
&lt;p&gt;这里笔者用一个例子来说，集群每个RegionServer包含由800+的Region数，但是，由于集群维护，有几台RegionServer节点的Region全部集中到一台RegionServer，分布如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201808/666745-20180805123042543-512818204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样之前请求在RegionServer2和RegionServer3上的，都会集中到RegionServer1上去请求。这样就不能发挥整个集群的并发处理能力，另外，RegionServer1上的资源使用将会翻倍（比如网络、磁盘IO、HBase RPC的Handle数等）。而原先其他正常业务到RegionServer1的请求也会因此受到很大的影响。因此，读取请求不均衡不仅会造成本身业务性能很长，还会严重影响其他正常业务的查询。同理，写请求不均衡，也会造成类似的影响。故HBase负载均衡是HBase集群性能的重要体现。&lt;/p&gt;
&lt;h3&gt;2.2.2 BlockCache优化&lt;/h3&gt;
&lt;p&gt;BlockCache作为读缓存，合理设置对于提高读性能非常重要。默认情况下，BlockCache和Memstore的配置各站40%，可以通过在hbase-site.xml配置以下属性来实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hfile.block.cache.size，默认0.4，用来提高读性能&lt;/li&gt;
&lt;li&gt;hbase.regionserver.global.memstore.size，默认0.4，用来提高写性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇博客主要介绍提高读性能，这里我们可以将BlockCache的占比设置大一些，Memstore的占比设置小一些（总占比保持在0.8即可）。另外，BlockCache的策略选择也是很重要的，不同的策略对于读性能来说影响不大，但是对于GC的影响却比较明显，在设置hbase.bucketcache.ioengine属性为offheap时，GC表现的很优秀。缓存结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201808/666745-20180805125621644-552171040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置BlockCache可以在hbase-site.xml文件中，配置如下属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 分配的内存大小尽可能的多些，前提是不能超过 (机器实际物理内存-JVM内存) --&amp;gt;
&amp;lt;property&amp;gt;  
   &amp;lt;name&amp;gt;hbase.bucketcache.size&amp;lt;/name&amp;gt;  
   &amp;lt;value&amp;gt;&lt;span&gt;16384&lt;/span&gt;&amp;lt;/value&amp;gt; 
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
 &amp;lt;name&amp;gt;hbase.bucketcache.ioengine&amp;lt;/name&amp;gt;
 &amp;lt;value&amp;gt;offheap&amp;lt;/value&amp;gt; 
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置块内存大小，可以参考入下表格：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;标号&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;计算公式或值&lt;/td&gt;
&lt;td&gt;结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;物理内存选择：on-heap(JVM)+off-heap(Direct)&lt;/td&gt;
&lt;td&gt;单台物理节点内存值，单位MB&lt;/td&gt;
&lt;td&gt;262144&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;HBASE_HEAPSIZE('-Xmx)&lt;/td&gt;
&lt;td&gt;单位MB&lt;/td&gt;
&lt;td&gt;20480&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;-XX:MaxDirectMemorySize，off-heap允许的最大内存值&lt;/td&gt;
&lt;td&gt;A-B&lt;/td&gt;
&lt;td&gt;241664&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Dp&lt;/td&gt;
&lt;td&gt;hfile.block.cache.size和hbase.regionserver.global.memstore.size总和不要超过0.8&lt;/td&gt;
&lt;td&gt;读取比例占比*0.8&lt;/td&gt;
&lt;td&gt;0.5*0.8=0.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Dm&lt;/td&gt;
&lt;td&gt;JVM Heap允许的最大BlockCache（MB）&lt;/td&gt;
&lt;td&gt;B*Dp&lt;/td&gt;
&lt;td&gt;20480*0.4=8192&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Ep&lt;/td&gt;
&lt;td&gt;hbase.regionserver.global.memstore.size设置的最大JVM值&lt;/td&gt;
&lt;td&gt;0.8-Dp&lt;/td&gt;
&lt;td&gt;0.8-0.4=0.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;用于其他用途的off-heap内存，例如DFSClient&lt;/td&gt;
&lt;td&gt;推荐1024到2048&lt;/td&gt;
&lt;td&gt;2048&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;BucketCache允许的off-heap内存&lt;/td&gt;
&lt;td&gt;C-F&lt;/td&gt;
&lt;td&gt;241664-2048=239616&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;另外，BlockCache策略，能够有效的提高缓存命中率，这样能够间接的提高热数据覆盖率，从而提升读取性能。&lt;/p&gt;
&lt;h3&gt;2.2.3 HFile优化&lt;/h3&gt;
&lt;p&gt;HBase读取数据时会先从BlockCache中进行检索（热数据），如果查询不到，才会到HDFS上去检索。而HBase存储在HDFS上的数据以HFile的形式存在的，文件如果越多，检索所花费的IO次数也就必然增加，对应的读取耗时也就增加了。文件数量取决于Compaction的执行策略，有以下2个属性有关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hbase.hstore.compactionThreshold，默认为3，表示store中文件数超过3个就开始进行合并操作&lt;/li&gt;
&lt;li&gt;hbase.hstore.compaction.max.size，默认为9223372036854775807，合并的文件最大阀值，超过这个阀值的文件不能进行合并&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 另外，hbase.hstore.compaction.max.size值可以通过实际的Region总数来计算，公式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hbase.hstore.compaction.max.size = RegionTotal / hbase.hstore.compactionThreshold
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2.4 Compaction优化&lt;/h3&gt;
&lt;p&gt;Compaction操作是将小文件合并为大文件，提高后续业务随机读取的性能，但是在执行Compaction操作期间，节点IO、网络带宽等资源会占用较多，那么什么时候执行Compaction才最好？什么时候需要执行Compaction操作？&lt;/p&gt;
&lt;h4&gt;1.什么时候执行Compaction才最好？&lt;/h4&gt;
&lt;p&gt;实际应用场景中，会关闭Compaction自动执行策略，通过属性hbase.hregion.majorcompaction来控制，将hbase.hregion.majorcompaction=0，就可以禁止HBase自动执行Compaction操作。一般情况下，选择集群负载较低，资源空闲的时间段来定时调度执行Compaction。&lt;/p&gt;
&lt;p&gt;如果合并的文件较多，可以通过设置如下属性来提生Compaction的执行速度，配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;hbase.regionserver.thread.compaction.large&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;&lt;span&gt;8&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;hbase.regionserver.thread.compaction.small&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;&lt;span&gt;5&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.什么时候需要执行Compaction操作？&lt;/h4&gt;
&lt;p&gt;一般维护HBase集群后，由于集群发生过重启，HBase数据本地性较低，通过HBase页面可以观察，此时如果不执行Compaction操作，那么客户端查询的时候，需要跨副本节点去查询，这样来回需要经过网络带宽，对比正常情况下，从本地节点读取数据，耗时是比较大的。在执行Compaction操作后，HBase数据本地性为1，这样能够有效的提高查询效率。&lt;/p&gt;

&lt;p&gt;本篇博客HBase查询优化从客户端和服务端角度，列举一些常见有效地额优化手段。当然，优化还需要从自己实际应用场景出发，例如代码实现逻辑、物理机的实际配置等方面来设置相关参数。大家可以根据实际情况来参考本篇博客进行优化。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《Hadoop大数据挖掘从入门到进阶实战》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 05:54:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/9425343.html</dc:identifier>
</item>
<item>
<title>【解码】浮点数精度问题 | 为什么(int)(32.3 x 100) = 3229？ - KPlayer</title>
<link>http://www.cnblogs.com/kplayer/p/9410476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kplayer/p/9410476.html</guid>
<description>&lt;h3&gt;零 | 序&lt;/h3&gt;
&lt;p&gt;前几天在找一个代码问题时，苦思不得其解，简直要怀疑人生。查看各种参数，输入输出，都符合条件，最后各种排除法之后，定位到一段简单的代码，简化后大致如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = &lt;span&gt;32.3&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    b = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    c = (&lt;span&gt;int&lt;/span&gt;)(a*&lt;span&gt;b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;c = &lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c); //c = 3229
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原代码中本来预想c应该会等于3230，可是最后的结果却是&lt;span&gt;&lt;strong&gt;3229！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一反应就觉得应该是浮点数精度问题，但是怎么条理清晰地向别人解释呢？好像有点难度，于是回家认真翻阅了下书籍，整理了一下思路。&lt;/p&gt;
&lt;p&gt;一个简单的解释是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们都知道计算机中只有0和1，也没有小数点，因此要表示浮点数时有自己的一套表示方法，这套表示方法在有限位数情况下有时并不能精确的表示某个浮点数，只能尽量逼近它，例如这个例子中，我们定义了一个double型的32.3，我们以为它表示32.3，但是计算机用有限长的0和1只能表示32.2999999......，这样当这个数乘上100时，就变成了3229.99999，当它从double转型成int时，小数点被舍掉了，就变成了3229。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这个解释......好像似懂非懂的样子，那么问题来了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 浮点数在计算机中到底是怎么存储的？为什么有的小数无法精确表示？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 浮点数乘法是怎么实现的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. double转型成int时，为什么会把小数舍掉？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;一 | 浮点数表示&lt;/h3&gt;
&lt;p&gt;要理解上面的问题，我们先从更简单的2进制小数开始，我们知道在10进制中：123.45 = 1 x 10&lt;sup&gt;2&lt;/sup&gt; + 2 x 10&lt;sup&gt;1&lt;/sup&gt; + 3 x 10&lt;sup&gt;0&lt;/sup&gt; + 4 x 10&lt;sup&gt;-1&lt;/sup&gt; + 5 x 10&lt;sup&gt;-2&lt;/sup&gt;，&lt;/p&gt;
&lt;p&gt;类似的2进制小数也可以这样表示：101.11 = 1 x 2&lt;sup&gt;2&lt;/sup&gt; + 0 x 2&lt;sup&gt;1&lt;/sup&gt; + 1 x 2&lt;sup&gt;0&lt;/sup&gt; + 1 x 2&lt;sup&gt;-1&lt;/sup&gt; + 1 x 2&lt;sup&gt;-2&lt;/sup&gt; = 5.75，&lt;/p&gt;
&lt;p&gt;如果考虑有限长度，我们知道1/3在10进制中没办法准确表示，同样的，二进制中也有不能精确表示的数，如1/5，二进制只能表示那些能被写成&lt;span&gt;&lt;strong&gt;a x 2&lt;sup&gt;b&lt;/sup&gt;&lt;/strong&gt;&lt;/span&gt;的数，就像上面的5.75。&lt;/p&gt;
&lt;p&gt;所以本文开始的例子中32.3 = 0010 0000.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 ...... = 32.29999999999......&lt;/p&gt;
&lt;p&gt;这就解释了为什么32.3在计算机中是32.999999999999......&lt;/p&gt;

&lt;p&gt;等等！不是说计算机中没有小数点的吗？&lt;/p&gt;
&lt;p&gt;确实如此，因此在实际计算机中，采用的是IEEE浮点表示法（IEEE-754标准），即&lt;strong&gt;&lt;span&gt;&lt;em&gt;V=(-1)&lt;sup&gt;s&lt;/sup&gt; x (1.M) x 2&lt;sup&gt;E-f&lt;/sup&gt;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;表示一个浮点数，其中&lt;strong&gt;&lt;span&gt;&lt;em&gt;s&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;是符号，&lt;em&gt;&lt;span&gt;&lt;strong&gt;M&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;是尾数，&lt;span&gt;&lt;strong&gt;&lt;em&gt;E&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;是阶码，其存储规则如下：&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单精度格式（32位）：符号位（s）1位；阶码（Ｅ）8位，阶码的偏移量（f）为127（7FH）；尾数（M）23位，用小数表示，小数点放在尾数域的最前面；&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;双精度格式（64位）：符号位（s）1位；阶码（Ｅ）11位，阶码的偏移量（f）为1023（3FFH）；尾数（M）52位，用小数表示，小数点放在尾数域的最前面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个简单的例子：(1.75)&lt;sub&gt;10&lt;/sub&gt; = (1.11)&lt;sub&gt;2&lt;/sub&gt; = 1.11 x 2&lt;sup&gt;0&lt;/sup&gt;，所以在单精度格式中s = 0，M = 11，E = 127 = (01111111)&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;因此在计算机中，float型的1.75存储为 0 01111111 11000000000000000000000 = (3FE00000)&lt;sub&gt;16&lt;/sub&gt;，&lt;/p&gt;
&lt;p&gt;而double型的1.75存储为(3FFC000000000000)&lt;sub&gt;16&lt;/sub&gt;，这个就留给您自己去推算一遍了。&lt;/p&gt;

&lt;p&gt;下面我们通过一段代码来验证一下上面的原理，证实1.75在计算机中确实是这样存储的。&lt;/p&gt;
&lt;p&gt;首先我们定义一个指向类型为unsigned char的对象指针，然后定义一个show_bytes方法，打印出每个以16进制表示的字节，%.2x表示整数必须用至少两个数字的十六进制格式输出。接着定义show_int，show_float，show_double分别调用show_bytes，根据不同的类型和长度，打印出对应的字节表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;

typedef unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;byte_pointer; //定义一个指向类型为unsigned char的对象指针
&lt;br/&gt;//以16进制打印指针指向地址中的字节序列
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; show_bytes(byte_pointer start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%.2x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,start[i]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
//打印整数型变量
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; show_int(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
    show_bytes((byte_pointer)&lt;/span&gt;&amp;amp;x, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
}
//打印单精度浮点变量
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; show_float(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; x){
    show_bytes((byte_pointer)&lt;/span&gt;&amp;amp;x, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;&lt;span&gt;));
}
//打印双精度浮点变量
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; show_double(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x){
    show_bytes((byte_pointer)&lt;/span&gt;&amp;amp;x, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;));
}&lt;p&gt;//主程序&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = &lt;span&gt;1.75&lt;/span&gt;&lt;span&gt;;
    show_float(a);
    show_double(a);&lt;br/&gt;　　 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0000e03f&lt;/span&gt;&lt;span&gt;
000000000000fc3f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到这里结果似乎跟我们推算的值不太一样，这是因为我的计算机采用小端法存储（这个概念如不清楚请Google之），即把低序的存在低地址，所以00 00 e0 3f从高地址开始读就是3f e0 00 00。那么本文一开始提到的32.3在双精度中是怎么表示的呢？修改程序后运行可得：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cdcc0042
9a99999999194040&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二 | 浮点数乘法&lt;/h3&gt;
&lt;p&gt;搞清楚了浮点数的存储方式，我们来看看浮点数的乘法是怎么实现的。假设有两个浮点数：&lt;/p&gt;
&lt;p&gt;x = M&lt;sub&gt;x&lt;/sub&gt; x 2&lt;sup&gt;E&lt;sub&gt;x&lt;/sub&gt;&lt;/sup&gt;　　y = M&lt;sub&gt;y&lt;/sub&gt; x 2&lt;sup&gt;E&lt;sub&gt;y&lt;/sub&gt;&lt;/sup&gt; &lt;/p&gt;
&lt;p&gt;那么x*y =( M&lt;sub&gt;x&lt;/sub&gt; x 2&lt;sup&gt;E&lt;sub&gt;x&lt;/sub&gt;&lt;/sup&gt; ) ( M&lt;sub&gt;y&lt;/sub&gt; x 2&lt;sup&gt;E&lt;sub&gt;y&lt;/sub&gt;&lt;/sup&gt; ) = 2&lt;sup&gt;E&lt;sub&gt;x&lt;/sub&gt;+E&lt;sub&gt;y&lt;/sub&gt;&lt;/sup&gt;·(M&lt;sub&gt;x&lt;/sub&gt; * M&lt;sub&gt;y&lt;/sub&gt;)，&lt;/p&gt;
&lt;p&gt;也就是说&lt;span&gt;&lt;strong&gt;两个浮点数相乘的结果就是它们的阶码相加，尾数相乘&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以在双精度中32.3 x 100 = (1.0000 0010 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 x 2&lt;sup&gt;5&lt;/sup&gt;) x (1.1001 x 2&lt;sup&gt;6&lt;/sup&gt;)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　= 1.1001 0011 1011 1111 1111 1111 1111... x 2&lt;sup&gt;11&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　= (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;100 0000 1010&lt;/span&gt; 1001 0011 1011 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111)&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　= 3299.9999999999......&lt;/p&gt;
&lt;p&gt;这里是以二进制小数的方式简单说明了下浮点数的乘法，虽然浮点数的乘法可以转换成定点数的加法和乘法，但我们知道在计算机中的0和1，也并没有真正的“加法”和“乘法”，所有的操作是通过寄存器和逻辑门操作完成的，想要真正“理解”浮点数乘法操作是怎么实现的，不妨研读下“汇编语言”相关内容。&lt;/p&gt;
&lt;p&gt;PS. 顺便说一下，浮点数32.3乘整数100，按C语言的规则是100转成浮点数再运算，而不是32.3先转成整数再运算。&lt;/p&gt;

&lt;h3&gt;三 | 浮点数转型成整数&lt;/h3&gt;
&lt;p&gt;浮点数转型成整数时，会把小数点舍掉，有人说，这是C语言规定的，没什么好解释的。但是计算机总有自己的一套规则吧，究竟是怎么转换的呢？这方面容我再好好深入学习下《汇编原理》和《深入理解计算机系统》，再来向各位汇报，也欢迎各位大神指导。&lt;/p&gt;

&lt;p&gt;另外，如果把文章开头的double a = 32.3变成float a = 32.3，结果c会变成3230，各位读者如果有兴趣可以思考下为什么。 &lt;/p&gt;
&lt;p&gt;总结一下，浮点有风险，使用需谨慎！&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;1. 《深入理解计算机系统（第2版）》 机械工业出版社&lt;/p&gt;
&lt;p&gt;2. https://en.wikipedia.org/wiki/IEEE_754_revision&lt;/p&gt;
&lt;p&gt;3. http://share.onlinesjtu.com/mod/tab/view.php?id=176 &lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 05:01:00 +0000</pubDate>
<dc:creator>KPlayer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kplayer/p/9410476.html</dc:identifier>
</item>
<item>
<title>AspNetCore 基于AOP实现Polly的使用 - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/9425164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/9425164.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;说起&lt;/span&gt;AOP，其实我们在做MVC/API 的时候应该没少接触，比如说各种的Fitter 就是典型的AOP了。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;本来在使用&lt;/span&gt;Polly的时候我最初的打算是使用过滤器来实现的，后来发现实现起来相当的困难，利用NetCore的中间以及过滤器去实现一个AOP的独立应用服务简直了，我有点无奈，相当的难写。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;后来又使用了，&lt;/span&gt;Autofac 做拦截器来实现也是有点小无力。估计还是基础太薄弱。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;目前我了解到的实现&lt;/span&gt;Polly比较方便的第三方Aop框架的有&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;（1）&lt;span&gt;、&lt;/span&gt;AspectCore:是一款 AspNetCore轻量级的Aop解决方案。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;（2）&lt;span&gt;、&lt;/span&gt;Dora.Interception 老A写的一个Aop解决方案,这个用到解决方案中就需要等到老A升级下一版了。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在使用&lt;/span&gt;Policy 的时候主要点是策略的制定，在保证代码整洁，并且不破坏当前代码逻辑的情况下，使用Aop是最合适的解决方案了。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当我们使用过滤器的时候我们会发现，&lt;/span&gt;Pollicy 制定了一个错误规则，并且在错误过滤器中使用、抓取不到任何的错误信息，因为错误信息被错误过滤器抓取了，这个时候不会触发Pollicy&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后尝试着&lt;/span&gt; &lt;span&gt;用过滤实现一个&lt;/span&gt; &lt;span&gt;当程序发生错误的时候，执行另一个方法的功能，类似&lt;/span&gt;Policy的重试策略或降级。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;下面代码：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;编写：一个过滤器类：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc.Filters;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;


&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; InterceptorCoreLibrary
{
    [AttributeUsage(AttributeTargets.Class&lt;/span&gt;|&lt;span&gt;AttributeTargets.Method)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoreExceptionFilter:Attribute, IExceptionFilter,IActionFilter
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发生错误的时候重新执行的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FallBackClass { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发生错误的时候重新执行的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FallBackMethod { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取方法的参数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] InvokeParameters { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数使用该类时参数为方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fallBackMethod&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; CoreExceptionFilter(&lt;span&gt;string&lt;/span&gt; fallBackClass, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fallBackMethod) 
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FallBackMethod =&lt;span&gt; fallBackMethod;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FallBackClass =&lt;span&gt; fallBackClass;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用新方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;asm&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;parameters&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; UseNewMethod(Assembly asm, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
        {
            Object obj &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Type type &lt;span&gt;in&lt;/span&gt;&lt;span&gt; asm.GetExportedTypes())
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type.Name ==&lt;span&gt; FallBackClass)
                {
                    obj &lt;/span&gt;=&lt;span&gt; System.Activator.CreateInstance(type);
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; type.GetMethods())
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.Name ==&lt;span&gt; FallBackMethod)
                        {
                            obj &lt;/span&gt;=&lt;span&gt; type.GetMethod(FallBackMethod).Invoke(obj, parameters);
                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有被监控方法的参数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] parameters = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[context.ActionArguments.Count];
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; context.ActionArguments)
            {
                parameters[Count] &lt;/span&gt;=&lt;span&gt; item.Value;
                Count&lt;/span&gt;++&lt;span&gt;;
            }
            InvokeParameters &lt;/span&gt;=&lt;span&gt; parameters;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误的时候执行新的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objectResult = context.Exception &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Exception;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (objectResult.Message != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.Result = new ObjectResult(UseNewMethod(this.GetType().Assembly, InvokeParameters));&lt;/span&gt;
                 context.Result = &lt;span&gt;new&lt;/span&gt; ObjectResult(&lt;span&gt;new&lt;/span&gt; { Success = &lt;span&gt;true&lt;/span&gt;, code = &lt;span&gt;200&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Data = UseNewMethod(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType().Assembly, InvokeParameters) });
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuted(ActionExecutedContext context)
        {
           
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;在控制器中使用：&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [CoreExceptionFilter(nameof(UserModel), nameof(Delete))]

 

   在执行的时候我抛送一个异常信息

    [CoreExceptionFilter(nameof(UserModel), nameof(Delete))]

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE api/values/5&lt;/span&gt;
&lt;span&gt;
        [HttpDelete(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)

        {

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;当方法执行出错的时候执行另一个方法：&lt;/span&gt;&lt;/h3&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;如下：注意参数一致：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; InterceptorCoreLibrary
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新执行一遍代码&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;执行结果：&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180805121416916-642903960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;返回结果：&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180805121441391-1834548105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这个时候我们能看到过滤器先抓取了错误信息，&lt;/span&gt;Policy 就抓不到了，但同样实现了降级的功能。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果我们不使用&lt;/span&gt;Aop的话 直接在控制器中写&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;比如：&lt;span&gt;这样写一个两个还行多了的话，代码就相当的乱了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE api/values/5&lt;/span&gt;
        [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; PolicyExecute = Policy.Handle&amp;lt;Exception&amp;gt;().Fallback(() =&amp;gt;&lt;span&gt;
              {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序报错重新执行一个新的方法&lt;/span&gt;
                  UserModel userModel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserModel();
                  userModel.Delete(id);
             });
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;
             PolicyExecute.Execute(() =&amp;gt;&lt;span&gt;            {
                                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception();
                            }
                           );
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上代码虽然没有实现policy ,但是也演示出了大致使用Aop实现 Policy的过程原理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里贴出一份杨中科老师 在普及AspNetCore微服务课程中的代码：支持原创，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整的代码这里贴出过:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://www.cnblogs.com/qhbm/p/9228238.html&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;我在Demo中进行了简单的实现：这里就不贴出了，因为框架还不是很完善，我问了作者老A，要等到下一版出来后用在项目中才比较稳妥。大家可以关注一下老A博客。&lt;/p&gt;
&lt;p&gt;截图说明一下两个框架的区别，到时候可根据框架需要酌情使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180805123523239-616960432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;有不足之处&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;希望大家指出相互学习，&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                   　　本文&lt;span&gt;&lt;strong&gt;原创：&lt;/strong&gt;转载请注明出处 谢谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Aug 2018 04:36:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/9425164.html</dc:identifier>
</item>
<item>
<title>分布式事务最终一致看这篇“大白话”的实践 - 薛家明</title>
<link>http://www.cnblogs.com/xuejiaming/p/9417386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuejiaming/p/9417386.html</guid>
<description>&lt;p&gt;　　我们都知道微服务现在很火热，那么我们将业务才开后随之而来的数据一致性问题也很棘手，这篇博客我将阐述一下我是如何通过实践加理论来完成最终一致的高可用并且讲述一下dotnetcore下的&lt;a href=&quot;https://github.com/dotnetcore/CAP&quot; target=&quot;_blank&quot;&gt;cap&lt;/a&gt;是如何实现的,话不多说直接上问题。&lt;/p&gt;
&lt;p&gt;　　1我们在编写代码的时候是否有过如下经历的转变:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
//原先的业务
begin tran
     update table set column=x where id = y;
     update table2 set column = x where id = y;
commit
//进化后的业务需要调用第三方接口通知其完成方法：OtherService.Complete()
方法1：
OtherService.Complete();
begin tran
     update table set column=x where id = y;
     update table2 set column = x where id = y;
commit
方法2：
begin tran
     OtherService.Complete();
     update table set column=x where id = y;
     update table2 set column = x where id = y;
commit
方法3：
begin tran
     update table set column=x where id = y;
     OtherService.Complete();
     update table2 set column = x where id = y;
commit
方法4：
begin tran
     update table set column=x where id = y;
     update table2 set column = x where id = y;
     OtherService.Complete();
commit
方法5：
begin tran
     update table set column=x where id = y;
     update table2 set column = x where id = y;
commit
OtherService.Complete();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以发现业务的进化是不可阻挠的,但是如何来确保本地事务的成功外加远程调用的成功呢，首先我们排除业务逻辑上的，就是说如果不存在网络问题那么一定是会成功的只要他执行了，那么根据aop我们会发现每个方法都会有6个切面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180804094652350-142997005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　谁也没法保证在哪个切面会发生网络或者断电等异常，大家可以思考一下关于上述5种方法的任何切面出现问题会有什么影响哪些切面出问题是不会有数据不一致的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180805112345169-70782444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面我可以看到只有4-5方法出现了一个不一致，但是方法5不排除本身调用失败，所以我们一般选择的方法4，因为在所有这么多方法中只有方法4可以称之为“伪事务”，这边可以发现只要远程调用出错那么事务会回滚可以极大的保障数据一致性，但是也不排除切面5发生错误，一旦切面5发生错误那么数据就会不一直，除非手工的去处理。有人会说了我们用mq啊，mq有特殊机制可以确定后再去除消息（rabbitmq的ack机制。）那么我们再来看下这一系列的问题。假设基于方法4的前提下将方法调用改成mq的消息机制，我们来看：&lt;/p&gt;
&lt;p&gt;假设前面执行一切正常但是在执行ack确认完成mq清除掉消息后（channel.BasicAck(ea.DeliveryTag, false);）网络异常本地客户端没有得到正常的response那么一样等于切面4报错还是会产生消息不一致，那么说了这么多我们到底该如何才能保证消息不丢失呢。假设我们改造下mq，我先发一个消息给mq告诉他我等会会让你干什么事，如果过了多少秒我还没告诉你你来问我到底这件事还做不做了，这样我们就可以保证我们发给mq的消息不丢失，我们来看一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180805114211217-222202629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个改进后我们发现其实还是有问题如果4-5步骤出问题了还是数据不一致，那么我们就需要再进一步改进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180805115151771-1987363165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以保证消息准确无误的抵达系统B并且可以执行完成，但是这么做需要有一个强业务类型逻辑校验，保证除了网络等不可抗拒因素以外都要成功。但是有人要说了，就我们的水平不是人人都是bat里的怎么可能改进mq系统让他支持，改源码毕竟还是不太现实，那么接下来我就给大家带来2种解决方案，而且其中一种就是cap的实现。&lt;/p&gt;
&lt;p&gt;方案1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180805120433497-45215933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过代码我们可以看到利用本地数据库事务特性将要对其他系统的处理消息插入本地消息表，之后再commit之后去执行并且更新消息表，自带轮询查询消息表达到数据一致，cap就是这个方式来实现的最终一致。不过这种方法需要本地存储支持事务特性，而且并发量受本地数据库性能的限制，但是特点是实现起来简单有效方便。那么第二种方案是自己实现一个独立的可靠消息中间件。&lt;/p&gt;
&lt;p&gt;方案2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346660/201808/1346660-20180805121416122-1444142371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方案2这里要说的是系统a需要提供查询接口来供消息系统查询未处理的消息来确认是否要执行，系统b需要做的是提供查询接口来让消息系统来确认是否已经执行成功，因为消息系统在发消息给系统b的时候中间也会存在网络终端问题，而且这样一个消息系统就完全不存在事务的依赖关系，而且也不对原先的业务进行侵入，并发完全由消息系统自己独立控制。尤其是系统B和消息系统需要做好的是消息的重复消费要保证幂等的关系，所谓的幂等就是我同一个消息我执行一次和执行n次都只会成功一次，具体可以靠并发字段或者rowversion来保证，之后有时间我会单独写一个独立的消息中间件的demo，对了消息系统可以自身携带轮询系统，也可以有第三方的控制台程序或者其他定时程序来实现轮询&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 04:21:00 +0000</pubDate>
<dc:creator>薛家明</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuejiaming/p/9417386.html</dc:identifier>
</item>
<item>
<title>Docker | 第六章：构建私有仓库 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/docker-six.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/docker-six.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上一章节，讲解了利用&lt;code&gt;Dockerfile&lt;/code&gt;和&lt;code&gt;commit&lt;/code&gt;进行自定义镜像的构建。大部分时候，公司运维或者实施部门在构建了符合公司业务的镜像环境后，一般上不会上传到公共资源库的。这就需要自己搭建一个私有仓库，来存放自己的镜像数据，同时也可以存储其他镜像，方便拉取，比较国内的网络环境连接还是比较慢的。所以，本章节介绍下如何构建私有仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装registry&quot;&gt;安装Registry&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;官方提供了&lt;code&gt;Registry&lt;/code&gt;镜像，方便构建自己的私有仓库。所以，接下来讲解下私有仓库服务的安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;拉取Registry镜像&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  docker pull registry&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;启动Registry镜像&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;由于&lt;code&gt;Registry&lt;/code&gt;是一个镜像，运行后若我们删除了容器，里面的资源就都丢失了，所以我们在运行时，指定一个资源的挂载目录，映射到宿主的一个目录下，这样资源就不会丢失了。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -v /opt/docker/registry:/var/lib/registry -p 1888:5000 --restart=always  --name registry registry:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示：&lt;code&gt;restart=always&lt;/code&gt; 是指&lt;code&gt;docker&lt;/code&gt;重启时此容器自动启动。&lt;br/&gt;启动后，就能通过：http://宿主IP:1888/v2 ，访问了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/54053342.jpg&quot; alt=&quot;registry http访问&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;本地推送镜像至仓库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在本地创建一个镜像，同时推送到仓库上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 利用tag 标记一个新镜像
 docker tag hello-world 127.0.0.1:1888/demo/hello-world:latest
 # 推送镜像
 docker push 127.0.0.1:1888/demo/hello-world:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，访问私有仓库地址：http://宿主IP:1888/v2/_catalog， 即可看见推送的镜像信息了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/81673186.jpg&quot; alt=&quot;所有镜像&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;远程推送镜像至仓库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;直接使用&lt;code&gt;127.0.0.1&lt;/code&gt;或者&lt;code&gt;local&lt;/code&gt;时，是没有进行安全检验的。当我们使用外部的ip地址推送时，&lt;code&gt;Registr&lt;/code&gt;y为了安全性考虑，默认是需要&lt;code&gt;https&lt;/code&gt;证书支持的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误提示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izbp16chpwsnff41nrjtfhz ~]# docker push 47.98.238.247:1888/demo/hello-world:v1
The push refers to repository [47.98.238.247:1888/demo/hello-world]
Get https://47.98.238.247:1888/v2/: http: server gave HTTP response to HTTPS client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搜索相关资料后，有两种方案：一种是通过&lt;code&gt;daemon.json&lt;/code&gt;配置一个&lt;code&gt;insecure-registries&lt;/code&gt;属性；另一种就直接配置一个&lt;code&gt;https&lt;/code&gt;的证书了。&lt;code&gt;https&lt;/code&gt;的相关配置不在本章节讲解范围了，这里就不示例了，&lt;strong&gt;最稳妥的做法可以是：利用&lt;code&gt;nginx&lt;/code&gt;进&lt;code&gt;行https&lt;/code&gt;证书支持，然后代理到&lt;code&gt;Registry&lt;/code&gt;服务。有兴趣的可以自己动手实现下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对第一种做法，这里示例下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
&quot;insecure-registries&quot;: [&quot;实际的ip:端口&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后重启&lt;code&gt;Docker&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后再进行推送就能推送成功了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker push 47.98.238.247:1888/demo/hello-world:v1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看下镜像的版本列表就能知道是否上传成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/16616126.jpg&quot; alt=&quot;镜像tag列表&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;管理registry&quot;&gt;管理Registry&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;仓库很大，要是没有一套管理规则，也是很头疼的事情。所以接下来，讲解下如何管理Registry。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;registry接口列表&quot;&gt;Registry接口列表&lt;/h3&gt;
&lt;p&gt;以下转至：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1116799&quot; class=&quot;uri&quot; title=&quot;https://cloud.tencent.com/developer/article/1116799&quot;&gt;https://cloud.tencent.com/developer/article/1116799&lt;/a&gt; 。详细可点击查看。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/&lt;/td&gt;
&lt;td&gt;Base&lt;/td&gt;
&lt;td&gt;检查是否支持2.0接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/${image}/tags/list&lt;/td&gt;
&lt;td&gt;Tags&lt;/td&gt;
&lt;td&gt;获取镜像标签列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/${image}/manifests/&lt;/td&gt;
&lt;td&gt;Manifest&lt;/td&gt;
&lt;td&gt;获取镜像主要信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;/v2/${image}/manifests/&lt;/td&gt;
&lt;td&gt;Manifest&lt;/td&gt;
&lt;td&gt;修改镜像主要信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;/v2/${image}/manifests/&lt;/td&gt;
&lt;td&gt;Manifest&lt;/td&gt;
&lt;td&gt;删除镜像的主要信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/&lt;/td&gt;
&lt;td&gt;Blob&lt;/td&gt;
&lt;td&gt;获得镜像层&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/&lt;/td&gt;
&lt;td&gt;Blob&lt;/td&gt;
&lt;td&gt;删除镜像层&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/uploads/&lt;/td&gt;
&lt;td&gt;Initiate Blob Upload&lt;/td&gt;
&lt;td&gt;开始分块上传&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/uploads/&lt;/td&gt;
&lt;td&gt;Blob Upload&lt;/td&gt;
&lt;td&gt;获得分块上传的速度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/uploads/&lt;/td&gt;
&lt;td&gt;Blob Upload&lt;/td&gt;
&lt;td&gt;分块上传数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/uploads/&lt;/td&gt;
&lt;td&gt;Blob Upload&lt;/td&gt;
&lt;td&gt;完成上传&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;/v2/${image}/blobs/uploads/&lt;/td&gt;
&lt;td&gt;Blob Upload&lt;/td&gt;
&lt;td&gt;取消上传&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/v2/_catalog&lt;/td&gt;
&lt;td&gt;Catalog&lt;/td&gt;
&lt;td&gt;获得镜像列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;基本上的管理都是通过以上的api接口方式了，大家可自行尝试下。&lt;/p&gt;
&lt;h3 id=&quot;删除镜像示例&quot;&gt;删除镜像示例&lt;/h3&gt;
&lt;p&gt;这里就简单示例下比较常用的也比较麻烦的&lt;code&gt;删除镜像&lt;/code&gt;方法。这里直接使用&lt;code&gt;curl&lt;/code&gt;也可使用&lt;code&gt;POSTMAN&lt;/code&gt;等api尝试工具进行.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：由于默认是不允许删除镜像的(提示方法不支持)，所以需要进行配置，开启删除功能。所以我们在启动时，直接设置参数(&lt;code&gt;REGISTRY_STORAGE_DELETE_ENABLED=true&lt;/code&gt;)：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -v /opt/docker/registry:/var/lib/registry -p 1888:5000 --restart=always  --name registry -e &quot;REGISTRY_STORAGE_DELETE_ENABLED=true&quot; registry:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;或者可设置&lt;code&gt;/etc/docker/registry/config.yml&lt;/code&gt;，加入&lt;code&gt;storage.delete.enabled&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;(yaml格式)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: /var/lib/registry
  delete:
    enable: true
http:        
  addr: :5000                        
  headers:                           
    X-Content-Type-Options: [nosniff]
health:          
  storagedriver: 
    enabled: true
    interval: 10s
    threshold: 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/50055595.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后&lt;strong&gt;重启(restart)容器&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：对于&lt;code&gt;config.yml&lt;/code&gt;配置文件，里面可以设置很多的属性信息，具体属性可查看官网说明：&lt;/strong&gt;&lt;a href=&quot;https://docs.docker.com/registry/configuration/&quot; class=&quot;uri&quot; title=&quot;https://docs.docker.com/registry/configuration/&quot;&gt;https://docs.docker.com/registry/configuration/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除镜像&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -I -X --header &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; DELETE http://127.0.0.1:1888/v2/demo/hello-world/manifests/sha256:aca41a608e5eb015f1ec6755f490f3be26b48010b178e78c00eac21ffbe246f1&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;name：镜像名称。&lt;/li&gt;
&lt;li&gt;reference：删除时必须是镜像对应sha256值，推送时，可以获悉sha256值。&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/79634614.jpg&quot; alt=&quot;删除时reference必须为digest&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/78723959.jpg&quot; alt=&quot;sha256值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者利用get获取对应镜像信息：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X GET \
  http://47.98.238.247:1888/v2/demo/hello-world/manifests/v1 \
  -H 'Cache-Control: no-cache'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再或者可以直接根据存储目录查看(由于挂载宿主目录，所以我们直接在宿主机查看)：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/opt/docker/registry/docker/registry/v2/repositories/demo/hello-world/_manifests/tags/v2/index/sha256/link&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/50859677.jpg&quot; alt=&quot;查看目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用cat命令 或者 直接打开文件查看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/74623357.jpg&quot; alt=&quot;sha256查看&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;题外话：关于&lt;code&gt;Postman&lt;/code&gt;用法，可&lt;a href=&quot;http://blog.lqdev.cn/2018/07/28/springboot/chapter-fifteen/&quot; title=&quot;点击&quot;&gt;点击&lt;/a&gt;查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/60347034.jpg&quot; alt=&quot;postman方式&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;删除前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/15207967.jpg&quot; alt=&quot;删除前&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源库大小：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/78575494.jpg&quot; alt=&quot;删除前资源库大小&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行删除后，发现&lt;code&gt;tag&lt;/code&gt;已经为null了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/88813453.jpg&quot; alt=&quot;删除后&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再看看大小，是没有变化的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/35962720.jpg&quot; alt=&quot;删除后资源库大小&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为只删除了&lt;code&gt;tag&lt;/code&gt;，镜像文件没有删除。所以我们进入容器执行下回收命令：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/ # registry garbage-collect /etc/docker/registry/config.yml
demo/hello-world
test/hello-world
test/hello-world: marking manifest sha256:aca41a608e5eb015f1ec6755f490f3be26b48010b178e78c00eac21ffbe246f1 
test/hello-world: marking blob sha256:2cb0d9787c4dd17ef9eb03e512923bc4db10add190d3f84af63b744e353a9b34
test/hello-world: marking blob sha256:9db2ca6ccae029dd195e331f4bede3d2ea2e67e0de29d6a0f8c1572e70f32fa7

3 blobs marked, 1 blobs eligible for deletion
blob eligible for deletion: sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4
INFO[0000] Deleting blob: /docker/registry/v2/blobs/sha256/a3/a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4  go.version=go1.7.6 instance.id=de550dcd-7e54-4279-a9e4-d3609c83b11b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这个时候就已经回收了。目前貌似没有自动回收机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/65594500.jpg&quot; alt=&quot;镜像被回收后大小&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看见大小发生了变化了，说明镜像已经被清理了。也可以去刚刚查看&lt;code&gt;sha256目录&lt;/code&gt;查看，里面的信息已经被删除了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-5/93858167.jpg&quot; alt=&quot;删除后目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后想说，利用命令去删除之类的太麻烦了，现在有很多开源的工具可以管理仓库。大家可以自行搜索下。这里可以看看这个开源的删除资源的工具类：&lt;a href=&quot;https://github.com/burnettk/delete-docker-registry-image&quot; class=&quot;uri&quot; title=&quot;https://github.com/burnettk/delete-docker-registry-image&quot;&gt;https://github.com/burnettk/delete-docker-registry-image&lt;/a&gt;，具体使用方法有具体说明。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;官方的文档还是很齐全的，建议大家还是直接去官网查看相关资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;官网：https://docs.docker.com/registry&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/sunshingheavy/article/details/54143764&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://cloud.tencent.com/developer/article/1116799&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/nklinsirui/article/details/80705306&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://github.com/burnettk/delete-docker-registry-image&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本章节主要是介绍如何利用&lt;code&gt;Registry&lt;/code&gt;进行私有仓库的创建及管理。对于单纯的&lt;code&gt;api&lt;/code&gt;调用而言，有点麻烦，可以上网找写批量的脚本，简化步骤下。由于对linux命令不是很熟悉，大家还是自行谷歌吧。正常而言，还是应该有个管理的UI界面会更方便点。在后面讲解&lt;code&gt;Docker可视化界面管理&lt;/code&gt;时再来详细说明下，因为本人也没有搭建过，后面会为了这个章节找些资料，然后分享给大家。敬请期待！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若文中有错误或者遗漏之处，还望指出，共同进步！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.lqdev.cn/2018/08/05/docker/docker-six/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn/2018/08/05/docker/docker-six/&quot;&gt;http://blog.lqdev.cn/2018/08/05/docker/docker-six/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 04:17:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/docker-six.html</dc:identifier>
</item>
<item>
<title>日志系统 - 只喝牛奶的杀手</title>
<link>http://www.cnblogs.com/viaiu/p/9382088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viaiu/p/9382088.html</guid>
<description>&lt;p&gt;       上一篇说了一下《&lt;a title=&quot;解决问题的一般套路&quot; href=&quot;http://www.cnblogs.com/viaiu/p/9382114.html&quot; target=&quot;_blank&quot;&gt;解决问题的一般套路&lt;/a&gt;》,里面讲到了日志系统的重要性，日志重要吗？监控重要吗？of course！日志就是要能找到用户做了什么请求那个机器。&lt;/p&gt;
&lt;p&gt;       上下游接口请求，请求参数和入参是否正确，我们可以统一写一个面向切面方法去打印日志，不用每一处去写，切入点大家自己按照规则定义，AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Aspect
@Component
public class ControllerLogAspect {
    private Logger logger = LoggerFactory.getLogger(getClass());

    ThreadLocal&amp;lt;Long&amp;gt; startTime = new ThreadLocal&amp;lt;&amp;gt;();

    @Pointcut(&quot;execution(* com.xxx.mobile.web.controller..*.*(..))&quot;)
    public void controllerLog() {

    }

    @Before(&quot;controllerLog()&quot;)
    public void doBefore(JoinPoint joinPoint) throws Throwable {
        startTime.set(System.currentTimeMillis());
        if (joinPoint == null) {
            return;
        }
        Signature signature = joinPoint.getSignature();
        // 接收到请求，记录请求内容
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes attributes = null;
        HttpServletRequest request = null;
        String requestUrl = &quot;&quot;;
        String httpMethod = &quot;&quot;;
        String declaringTypeName = &quot;&quot;;
        String actionName = &quot;&quot;;
        String ip = &quot;&quot;;
        if (requestAttributes != null) {
            attributes = (ServletRequestAttributes) requestAttributes;
        }
        if (attributes != null) {
            request = attributes.getRequest();
        }
        if (request != null) {
            requestUrl = request.getRequestURL().toString();
            httpMethod = request.getMethod();
            ip = IpUtils.getIpAddr(request);
        }
        if (signature != null) {
            declaringTypeName = joinPoint.getSignature().getDeclaringTypeName();
            actionName = joinPoint.getSignature().getName();
        }
        // 记录下请求内容
        logger.debug(&quot;URL:[{}] HTTP_METHOD:[{}] CLASS_METHOD:[{}.{}] ip:[{}] ARGS:{}&quot;,
                requestUrl, httpMethod, declaringTypeName, actionName, ip, Arrays.toString(joinPoint.getArgs()));
    }

    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;controllerLog()&quot;)
    public void doAfterReturning(Object ret) throws Throwable {
        // 处理完请求，返回内容
        logger.debug(&quot;Execute Time:{}ms \n{}&quot;, (System.currentTimeMillis() - startTime.get()), ret);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      下面将使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;处理全局异常，将异常信息更加人性化的输出给用户。当然我们记录日志还是会用log4j。至于log4j的用法大家可以百度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ControllerAdvice
public class MobileWebExceptionHandler {

    private static Logger logger = LoggerFactory.getLogger(MobileWebExceptionHandler.class);

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public Object exceptionHandler(HttpServletRequest request, Exception e) throws Exception {
        String message = String.format(&quot;Url:[%s]-%s&quot;, request.getRequestURL().toString(), e.getMessage());
        logger.error(message, e);
        return MobileWebResponse.error(CODE_INVALID_PARAMETER, e.getMessage());
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过&lt;code&gt;@ControllerAdvice&lt;/code&gt;。我们可以将对于控制器的全局配置放置在同一个位置，注解了&lt;code&gt;@ControllerAdvice&lt;/code&gt;的类的方法可以使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;，&lt;code&gt;@InitBinder&lt;/code&gt;，&lt;code&gt;@ModelAttribute&lt;/code&gt;注解到方法上，这对所有注解了&lt;code&gt;@RequestMapping&lt;/code&gt;的控制器内的方法有：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;@ExceptionHandler&lt;/code&gt;：用于全局处理控制器里面的异常。&lt;br/&gt;&lt;code&gt;@InitBinder&lt;/code&gt;：用来设置&lt;code&gt;WebDataBinder&lt;/code&gt;，&lt;code&gt;WebDataBinder&lt;/code&gt;用来自动绑定前台请求参数到&lt;code&gt;Model&lt;/code&gt;中。&lt;br/&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;：&lt;code&gt;@ModelAttribute&lt;/code&gt;本来的作用是绑定键值对到&lt;code&gt;Model&lt;/code&gt;里，此处是让全局的&lt;code&gt;@RequestMapping&lt;/code&gt;都能获得在此处设置的键值对。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;      什么时候该打印什么样的日志级别，这个也很重要，一般情况下我们打印德日志级别info,warn,error居多，日志级别有：&lt;span class=&quot;fontstyle1&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ALL：&lt;span class=&quot;fontstyle1&quot;&gt;最低等级的，用于打开所有日志记录。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;TRACE： designates finer­grained informational events than the DEBUG.Since:1.2.12&lt;span class=&quot;fontstyle1&quot;&gt;，很低的日志级别，一般不会使用。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;DEBUG： &lt;span class=&quot;fontstyle1&quot;&gt;指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;INFO： &lt;span class=&quot;fontstyle1&quot;&gt;消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;WARN： &lt;span class=&quot;fontstyle1&quot;&gt;表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;ERROR： &lt;span class=&quot;fontstyle1&quot;&gt;指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;FATAL： &lt;span class=&quot;fontstyle1&quot;&gt;指出每个严重的错误事件将会导致应用程序的退出。这个级别比较高了。重大错误，这种级别你可以直接停止程序了。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;OFF： &lt;span class=&quot;fontstyle1&quot;&gt;最高等级的，用于关闭所有日志记录 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;     SpringBootAdmin显示日志监控级别，我们可以根据自己的需求控制打印什么样的日志：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/810680/201807/810680-20180728151306102-1290844008.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们在打印日志一般日志头会有时间，应用名，spanId，traceId，代码行数，堆栈信息等，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;2018-08-05 11:52:58.470 WARN [xxx-web,e1ec017e8247b79e,e1ec017e8247b79e,true] 10652 --- [qtp1033348658-177] o.s.web.servlet.PageNotFound [1147 ] : No mapping found for HTTP request with URI [/flyway] in DispatcherServlet with name 'dispatcherServlet'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       如果那个app报错了，错误日志怎样让大家看到，会选择用RabbitMq+ELK(Elasticsearch , Logstash, Kibana), 这篇ELK原理与介绍(https://www.cnblogs.com/aresxin/p/8035137.html)，这位小哥哥说的还不错。Kafka可以被redis和RabbitMq 所替换。最终错误日志会显示在kibana上，如下图，除了时时监控错误的个数，还可以DSL语言查询某个时间段发生的错误日志，帮助我们分析问题。欢迎指正！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/810680/201808/810680-20180805114622547-711502105.png&quot; alt=&quot;&quot; width=&quot;835&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Aug 2018 04:13:00 +0000</pubDate>
<dc:creator>只喝牛奶的杀手</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viaiu/p/9382088.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——配置 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9424398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9424398.html</guid>
<description>&lt;p&gt;熟悉ASP.NET的开发者一定对web.config文件不陌生。在ASP.NET环境中，要想添加配置参数，一般也都会在此文件中操作。其中最常用的莫过于AppSettings与ConnectionStrings两项。而要在代码中获得文件中的配置信息，ConfigurationManager则是必不可少需要引入的程序集。&lt;/p&gt;
&lt;p&gt;然而到了ASP.NET Core时代，存储与读取配置的方式都发生了改变。&lt;/p&gt;
&lt;p&gt;如果对ASP.NET Core项目有所了解的话，应该会看到过appsettings.json这个文件。这里就从JSON文件配置方式开始解释ASP.NET Core中是如何读取配置信息的。&lt;/p&gt;
&lt;p&gt;假设有预先设置的appsettings.json文件：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;option1&quot;: &quot;value1_from_json&quot;,
  &quot;option2&quot;: 2,

  &quot;subsection&quot;: {
    &quot;suboption1&quot;: &quot;subvalue1_from_json&quot;
  },
  &quot;wizards&quot;: [
    {
      &quot;Name&quot;: &quot;Gandalf&quot;,
      &quot;Age&quot;: &quot;1000&quot;
    },
    {
      &quot;Name&quot;: &quot;Harry&quot;,
      &quot;Age&quot;: &quot;17&quot;
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中读取可以按下面的方式操作：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static IConfiguration Configuration { get; set; }

    public static void Main(string[] args = null)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;appsettings.json&quot;);

        Configuration = builder.Build();

        Console.WriteLine($&quot;option1 = {Configuration[&quot;Option1&quot;]}&quot;);
        Console.WriteLine($&quot;option2 = {Configuration[&quot;option2&quot;]}&quot;);
        Console.WriteLine(
            $&quot;suboption1 = {Configuration[&quot;subsection:suboption1&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Wizards:&quot;);
        Console.Write($&quot;{Configuration[&quot;wizards:0:Name&quot;]}, &quot;);
        Console.WriteLine($&quot;age {Configuration[&quot;wizards:0:Age&quot;]}&quot;);
        Console.Write($&quot;{Configuration[&quot;wizards:1:Name&quot;]}, &quot;);
        Console.WriteLine($&quot;age {Configuration[&quot;wizards:1:Age&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，实例化一个ConfigurationBuilder对象，接着设置基础路径。&lt;/p&gt;
&lt;p&gt;SetBasePath的操作其实是在ConfigurationBuilder的属性字典里设置FileProvider的值。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IConfigurationBuilder SetBasePath(this IConfigurationBuilder builder, string basePath)
{
    ...
    
    return builder.SetFileProvider(new PhysicalFileProvider(basePath));
}

public static IConfigurationBuilder SetFileProvider(this IConfigurationBuilder builder, IFileProvider fileProvider)
{
    ...

    builder.Properties[FileProviderKey] = fileProvider ?? throw new ArgumentNullException(nameof(fileProvider));
    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是添加JSON文件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange)
{
    ...

    return builder.AddJsonFile(s =&amp;gt;
    {
        s.FileProvider = provider;
        s.Path = path;
        s.Optional = optional;
        s.ReloadOnChange = reloadOnChange;
        s.ResolveFileProvider();
    });
}

public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action&amp;lt;JsonConfigurationSource&amp;gt; configureSource)
    =&amp;gt; builder.Add(configureSource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConfigurationBuilder里添加了一个JsonConfigurationSource对象。&lt;/p&gt;
&lt;p&gt;最后，执行ConfigurationBuilder的Build方法，就可以得到保存配置信息的Configuration对象。&lt;/p&gt;
&lt;p&gt;总结例子中的代码，获取配置信息的操作其实就分为两步:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成Configuration对象&lt;/li&gt;
&lt;li&gt;按键值从Configuration对象中获取信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成Configuration对象的步骤至少要有三个基础环节。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成ConfigurationBuilder对象&lt;/li&gt;
&lt;li&gt;添加ConfigurationSource对象&lt;/li&gt;
&lt;li&gt;创建Configuration对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;查看创建Configuration对象的代码，会发现内部利用的其实是ConfigurationSource中创建的ConfigurationProvider对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IConfigurationRoot Build()
{
    var providers = new List&amp;lt;IConfigurationProvider&amp;gt;();
    foreach (var source in Sources)
    {
        var provider = source.Build(this);
        providers.Add(provider);
    }
    return new ConfigurationRoot(providers);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看IConfiguratonSource接口，也只有一个Build方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IConfigurationSource
{
    IConfigurationProvider Build(IConfigurationBuilder builder);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终创建的Configuration对象，即ConfigurationRoot中包含了所有的ConfigurationProvider，说明配置信息都由这些ConfigurationProvider所提供。&lt;/p&gt;
&lt;p&gt;跟踪至ConfigurationRoot类型的构造方法，果然在其生成对象时，对所有ConfigurationProvider进行了加载操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ConfigurationRoot(IList&amp;lt;IConfigurationProvider&amp;gt; providers)
{
    ...

    _providers = providers;
    foreach (var p in providers)
    {
        p.Load();
        ChangeToken.OnChange(() =&amp;gt; p.GetReloadToken(), () =&amp;gt; RaiseChanged());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如JsonConfigurationProvider中：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override void Load(Stream stream)
{
    try
    {
        Data = JsonConfigurationFileParser.Parse(stream);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过JSON解析器，将JSON文件的配置信息读取至ConfigurationProvider的Data属性中。这个属性即是用于保存所有配置信息。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  /// &amp;lt;summary&amp;gt;
  /// The configuration key value pairs for this provider.
  /// &amp;lt;/summary&amp;gt;
  protected IDictionary&amp;lt;string, string&amp;gt; Data { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了ConfigurationRoot对象后，获取配置信息的操作就很简单了。遍历各个ConfigurationProvider，从中获取第一个匹配键值的数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public string this[string key]
{
    get
    {
        foreach (var provider in _providers.Reverse())
        {
            string value;

            if (provider.TryGet(key, out value))
            {
                return value;
            }
        }

        return null;
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConfigurationProvider对象从Data属性获取配置的值。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual bool TryGet(string key, out string value)
    =&amp;gt; Data.TryGetValue(key, out value);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在最初的例子中可以看&lt;code&gt;Configuration[&quot;wizards:0:Name&quot;]&lt;/code&gt;这样的写法，这是因为在Load文件时，存储的方式就是用&lt;code&gt;:&lt;/code&gt;为分隔符，以作为嵌套对象的键值。&lt;/p&gt;
&lt;p&gt;也可以用另一种方法来写，将配置信息绑定为对象。&lt;/p&gt;
&lt;p&gt;先定义对象类型：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AppSettings
{
    public string Option1 { get; set; }
    public int Option2 { get; set; }
    public Subsection Subsection { get; set; }
    public IList&amp;lt;Wizards&amp;gt; Wizards { get; set; }
}

public class Subsection
{
    public string Suboption1 { get; set; }
}

public class Wizards
{
    public string Name { get; set; }
    public string Age { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再绑定对象：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    var builder = new ConfigurationBuilder()
        .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile(&quot;appsettings.json&quot;);

    Configuration = builder.Build();

    var appConfig = new AppSettings();
    Configuration.Bind(appConfig);

    Console.WriteLine($&quot;option1 = {appConfig.Option1}&quot;);
    Console.WriteLine($&quot;option2 = {appConfig.Option2}&quot;);
    Console.WriteLine(
        $&quot;suboption1 = {appConfig.Subsection.Suboption1}&quot;);
    Console.WriteLine();

    Console.WriteLine(&quot;Wizards:&quot;);
    Console.Write($&quot;{appConfig.Wizards[0].Name}, &quot;);
    Console.WriteLine($&quot;age {appConfig.Wizards[0].Age}&quot;);
    Console.Write($&quot;{appConfig.Wizards[1].Name}, &quot;);
    Console.WriteLine($&quot;age {appConfig.Wizards[1].Age}&quot;);
    Console.WriteLine();

    Console.WriteLine(&quot;Press a key...&quot;);
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写法变成了常见的对象调用属性方式，但结果是一样的。&lt;/p&gt;
&lt;p&gt;除了可以用JSON文件存储配置信息外，ASP.NET Core同时也支持INI与XML文件。当然有其它类型文件时，也可以通过实现&lt;code&gt;IConfigurationSource&lt;/code&gt;接口并继承&lt;code&gt;ConfigurationProvider&lt;/code&gt;类建立自定义的ConfigrationProvider对象来加载配置文件。&lt;/p&gt;
&lt;p&gt;至于文件以外的方式，ASP.NET Core也提供了不少。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令行，AddCommandLine&lt;/li&gt;
&lt;li&gt;环境变量，AddEnvironmentVariables&lt;/li&gt;
&lt;li&gt;内存， AddInMemoryCollection&lt;/li&gt;
&lt;li&gt;用户机密，AddUserSecrets&lt;/li&gt;
&lt;li&gt;Azure Key Vault，AddAzureKeyVault&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择何种存储与读取配置的方法取决于实际场景，ASP.NET Core已经开放了配置方面的入口，任何接入方式理论上都是可行的。实践方面，则需要开发者们不断去尝试与探索。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Aug 2018 03:07:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9424398.html</dc:identifier>
</item>
</channel>
</rss>