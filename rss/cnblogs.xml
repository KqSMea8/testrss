<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>krpano自动缩略图分组插件 - 李佳鹏-前端</title>
<link>http://www.cnblogs.com/lijiapeng/p/9816680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiapeng/p/9816680.html</guid>
<description>&lt;h2&gt;描述&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;从巡视场景中自动生成漂亮的滚动缩略图。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它允许您将大拇指/场景分组到集合或专辑中，当您进行具有许多场景的大型巡视时非常有用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可在桌面和移动/触摸设备中无缝工作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要Textfield，Scrollearea和&lt;/span&gt;&lt;a href=&quot;http://krpano.com/plugins/userplugins/tooltip&quot;&gt;&lt;span&gt;Tooltip&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（包含）插件。&lt;/span&gt;&lt;span&gt;对于Krpano 1.17及更高版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;_mce_tagged_br&quot;&gt;&lt;span&gt;用法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;包含xml文件（它们应该位于Textfield和Scrollarea插件的同一文件夹中）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt; include url =“plugins / auto_thumbs.xml”/&amp;gt;

&amp;lt; include url =“plugins / tooltip.xml”/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件下载地址：&lt;a href=&quot;http://pan.baidu.com/s/1dFj7v0l&quot;&gt;http://pan.baidu.com/s/1dFj7v0l&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;插件共有两个文件，auto_thumbs.xml和tooltip.xml，&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-medium wp-image-390&quot; src=&quot;http://www.krpano.tech/wp-content/uploads/2017/03/3-3-300x90.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;90&quot; data-attachment-id=&quot;390&quot; data-permalink=&quot;http://www.krpano.tech/archives/387/3-6&quot; data-orig-file=&quot;/wp-content/uploads/2017/03/3-3.png&quot; data-orig-size=&quot;489,146&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;0&amp;quot;}&quot; data-image-title=&quot;3&quot; data-image-description=&quot;&quot; data-medium-file=&quot;/wp-content/uploads/2017/03/3-3-300x90.png&quot; data-large-file=&quot;/wp-content/uploads/2017/03/3-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;auto_thumbs.xml负责对场景进行分组展示&lt;/p&gt;
&lt;p&gt;tooltip.xml负责显示提示文字。&lt;/p&gt;

&lt;p&gt;提示：如果需要商业使用，请自行去官网购买，谢谢合作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;只需一点拇指就会显示在游览的左下方。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501724/201810/1501724-20181019151847076-242588850.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：插件从&lt;/span&gt;&lt;span&gt;每个场景中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;em&gt;thumburl&lt;/em&gt;&lt;span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;span&gt;获取缩略图图像&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;这些是在使用Make VTour工具时自动生成的，或者您也可以手动定义它们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要定义组/专辑，请将&lt;/span&gt;&lt;em&gt;专辑&lt;/em&gt;&lt;span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;到每个所需专辑的第一个场景中。&lt;/span&gt;&lt;span&gt;相册将包含第一个场景，以及所有以下场景，直到定义另一个相册。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501724/201810/1501724-20181019151934824-1604588.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如，要定义2个分组，每个分组有2个场景：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;scene thumburl=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scene 1 title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  album=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Album 1 title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&amp;lt;scene thumburl=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scene 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&amp;lt;scene thumburl=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scene 3 title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; album=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Album 2 title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&amp;lt;scene thumburl=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scene 4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;如何隐藏/显示插件&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;整个插件包含在name =“auto_thumbs”的图层中，您可以通过操作来显示或隐藏插件。&lt;/span&gt;&lt;span&gt;一个基本的例子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;layer name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toggle_thumbs_button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  onclick&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;switch(layer[auto_thumbs].visible)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
  ...
&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;您还可以使用alpha属性，并使用tween（）操作来实现更平滑的操作。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;设置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这些是所有可能的设置及其默认值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt; settings  name =&lt;span&gt;“auto_thumbs”
           thumb_size &lt;/span&gt;=“&lt;span&gt;120&lt;/span&gt;&lt;span&gt;”
           thumb_background_size &lt;/span&gt;=“&lt;span&gt;156&lt;/span&gt;&lt;span&gt;”
           thumb_spacing &lt;/span&gt;=“&lt;span&gt;0&lt;/span&gt;&lt;span&gt;”
           left &lt;/span&gt;=“&lt;span&gt;10&lt;/span&gt;&lt;span&gt;”   
           right &lt;/span&gt;=“&lt;span&gt;10&lt;/span&gt;&lt;span&gt;” 
           bottom &lt;/span&gt;=“&lt;span&gt;5&lt;/span&gt;&lt;span&gt;”  
           albums_right &lt;/span&gt;=“&lt;span&gt;10&lt;/span&gt;&lt;span&gt;” 
           onstart &lt;/span&gt;=&lt;span&gt;“” 
          &lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thumb_size &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;thumb_background_size &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;thumb_spacing&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;定义&lt;/span&gt;&lt;strong&gt;&lt;span&gt;缩略图&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的大小。&lt;/span&gt;&lt;span&gt;值是2x。&lt;/span&gt;&lt;span&gt;如果您使用默认的其他外观，则仅更改它们。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;left &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;right &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;bottom&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;允许您定义拇指相对于屏幕边缘的位置。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;albums_right&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;仅适用于专辑版本。&lt;/span&gt;&lt;span&gt;允许您为底部的拇指行定义不同的右边距。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onstart&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在设置插件后将调用的操作。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面是两个示例，包括和不包含相册，以及指向其xml源的链接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单的：&lt;a title=&quot;简单的，未分组&quot; href=&quot;https://krpano.com/plugins/userplugins/autothumbs/example/example1.html&quot; target=&quot;_blank&quot;&gt;https://krpano.com/plugins/userplugins/autothumbs/example/example1.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带有分组的：&lt;a title=&quot;带有分组的&quot; href=&quot;https://krpano.com/plugins/userplugins/autothumbs/example/example2.html&quot; target=&quot;_blank&quot;&gt;https://krpano.com/plugins/userplugins/autothumbs/example/example2.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 19 Oct 2018 07:27:00 +0000</pubDate>
<dc:creator>李佳鹏-前端</dc:creator>
<og:description>描述 从巡视场景中自动生成漂亮的滚动缩略图。 它允许您将大拇指/场景分组到集合或专辑中，当您进行具有许多场景的大型巡视时非常有用。 可在桌面和移动/触摸设备中无缝工作。 需要Textfield，Scr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiapeng/p/9816680.html</dc:identifier>
</item>
<item>
<title>妈妈再也不用担心爬虫被封号了！手把手教你搭建Cookies池 - 猿妙不可言</title>
<link>http://www.cnblogs.com/9527huaan/p/9816668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9527huaan/p/9816668.html</guid>
<description>&lt;p&gt;很多时候，在爬取没有登录的情况下，我们也可以访问一部分页面或请求一些接口，因为毕竟网站本身需要做SEO，不会对所有页面都设置登录限制。&lt;/p&gt;
&lt;p&gt;但是，不登录直接爬取会有一些弊端，弊端主要有以下两点。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;设置了登录限制的页面无法爬取。如某论坛设置了登录才可查看资源，某博客设置了登录才可查看全文等，这些页面都需要登录账号才可以查看和爬取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一些页面和接口虽然可以直接请求，但是请求一旦频繁，访问就容易被限制或者IP直接被封，但是登录之后就不会出现这样的问题，因此登录之后被反爬的可能性更低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就第二种情况做一个简单的实验。以微博为例，我们先找到一个Ajax接口，例如新浪财经官方微博的信息接口https://m.weibo.cn/api/container/getIndex?uid=1638782947&amp;amp;luicode=20000174&amp;amp;type=uid&amp;amp;value=1638782947&amp;amp;containerid=1005051638782947，如果用浏览器直接访问，返回的数据是JSON格式，如下图所示，其中包含了新浪财经官方微博的一些信息，直接解析JSON即可提取信息。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93bfd946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93bfd946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;462&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这个接口在没有登录的情况下会有请求频率检测。如果一段时间内访问太过频繁，比如打开这个链接，一直不断刷新，则会看到请求频率过高的提示，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93de1526?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93de1526?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;509&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果重新打开一个浏览器窗口，打开https://passport.weibo.cn/signin/login?entry=mweibo&amp;amp;r=https://m.weibo.cn/，登录微博账号之后重新打开此链接，则页面正常显示接口的结果，而未登录的页面仍然显示请求过于频繁，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93d22427?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93d22427?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中左侧是登录了账号之后请求接口的结果，右侧是未登录账号请求接口的结果，二者的接口链接是完全一样的。未登录状态无法正常访问，而登录状态可以正常显示。&lt;/p&gt;
&lt;p&gt;因此，登录账号可以降低被封禁的概率。&lt;/p&gt;
&lt;p&gt;我们可以尝试登录之后再做爬取，被封禁的几率会小很多，但是也不能完全排除被封禁的风险。如果一直用同一个账号频繁请求，那就有可能遇到请求过于频繁而封号的问题。&lt;/p&gt;
&lt;p&gt;如果需要做大规模抓取，我们就需要拥有很多账号，每次请求随机选取一个账号，这样就降低了单个账号的访问频率，被封的概率又会大大降低。&lt;/p&gt;
&lt;p&gt;那么如何维护多个账号的登录信息呢？这时就需要用到Cookies池了。接下来我们看看Cookies池的构建方法。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;一、本节目标&lt;/h2&gt;
&lt;p&gt;我们以新浪微博为例来实现一个Cookies池的搭建过程。Cookies池中保存了许多新浪微博账号和登录后的Cookies信息，并且Cookies池还需要定时检测每个Cookies的有效性，如果某Cookies无效，那就删除该Cookies并模拟登录生成新的Cookies。同时Cookies池还需要一个非常重要的接口，即获取随机Cookies的接口，Cookies运行后，我们只需请求该接口，即可随机获得一个Cookies并用其爬取。&lt;/p&gt;
&lt;p&gt;由此可见，Cookies池需要有自动生成Cookies、定时检测Cookies、提供随机Cookies等几大核心功能。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;二、准备工作&lt;/h2&gt;
&lt;p&gt;搭建之前肯定需要一些微博的账号。需要安装好Redis数据库并使其正常运行。需要安装Python的RedisPy、requests、Selelnium、Flask库。另外，还需要安装Chrome浏览器并配置好ChromeDriver。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-2&quot;&gt;三、Cookies池架构&lt;/h2&gt;
&lt;p&gt;Cookies的架构和代理池类似，同样是4个核心模块，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93a3787b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93a3787b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;662&quot; data-height=&quot;412&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cookies池架构的基本模块分为4块：存储模块、生成模块、检测模块、接口模块。每个模块的功能如下。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;存储模块负责存储每个账号的用户名密码以及每个账号对应的Cookies信息，同时还需要提供一些方法来实现方便的存取操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;生成模块负责生成新的Cookies。此模块会从存储模块逐个拿取账号的用户名和密码，然后模拟登录目标页面，判断登录成功，就将Cookies返回并交给存储模块存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;检测模块需要定时检测数据库中的Cookies。在这里我们需要设置一个检测链接，不同的站点检测链接不同，检测模块会逐个拿取账号对应的Cookies去请求链接，如果返回的状态是有效的，那么此Cookies没有失效，否则Cookies失效并移除。接下来等待生成模块重新生成即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;接口模块需要用API来提供对外服务的接口。由于可用的Cookies可能有多个，我们可以随机返回Cookies的接口，这样保证每个Cookies都有可能被取到。Cookies越多，每个Cookies被取到的概率就会越小，从而减少被封号的风险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上设计Cookies池的的基本思路和前面讲的代理池有相似之处。接下来我们设计整体的架构，然后用代码实现该Cookies池。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-3&quot;&gt;四、Cookies池的实现&lt;/h2&gt;
&lt;p&gt;首先分别了解各个模块的实现过程。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-4&quot;&gt;1. 存储模块&lt;/h2&gt;
&lt;p&gt;其实，需要存储的内容无非就是账号信息和Cookies信息。账号由用户名和密码两部分组成，我们可以存成用户名和密码的映射。Cookies可以存成JSON字符串，但是我们后面得需要根据账号来生成Cookies。生成的时候我们需要知道哪些账号已经生成了Cookies，哪些没有生成，所以需要同时保存该Cookies对应的用户名信息，其实也是用户名和Cookies的映射。这里就是两组映射，我们自然而然想到Redis的Hash，于是就建立两个Hash，结构分别如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93b6f6b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93b6f6b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93ebb35c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44b93ebb35c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hash的Key就是账号，Value对应着密码或者Cookies。另外需要注意，由于Cookies池需要做到可扩展，存储的账号和Cookies不一定单单只有本例中的微博，其他站点同样可以对接此Cookies池，所以这里Hash的名称可以做二级分类，例如存账号的Hash名称可以为accounts:weibo，Cookies的Hash名称可以为cookies:weibo。如要扩展知乎的Cookies池，我们就可以使用accounts:zhihu和cookies:zhihu，这样比较方便。&lt;/p&gt;
&lt;p&gt;接下来我们创建一个存储模块类，用以提供一些Hash的基本操作，代码如下：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们新建了一个&lt;code&gt;RedisClien&lt;/code&gt;t类，初始化&lt;code&gt;__init__()&lt;/code&gt;方法有两个关键参数&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;website&lt;/code&gt;，分别代表类型和站点名称，它们就是用来拼接Hash名称的两个字段。如果这是存储账户的Hash，那么此处的&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;accounts&lt;/code&gt;、&lt;code&gt;website&lt;/code&gt;为&lt;code&gt;weibo&lt;/code&gt;，如果是存储Cookies的Hash，那么此处的&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;cookies&lt;/code&gt;、&lt;code&gt;website&lt;/code&gt;为&lt;code&gt;weibo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来还有几个字段代表了Redis的连接信息，初始化时获得这些信息后初始化&lt;code&gt;StrictRedis&lt;/code&gt;对象，建立Redis连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name()&lt;/code&gt;方法拼接了&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;website&lt;/code&gt;，组成Hash的名称。&lt;code&gt;set()&lt;/code&gt;、&lt;code&gt;get()&lt;/code&gt;、&lt;code&gt;delete()&lt;/code&gt;方法分别代表设置、获取、删除Hash的某一个键值对，&lt;code&gt;count()&lt;/code&gt;获取Hash的长度。&lt;/p&gt;
&lt;p&gt;比较重要的方法是&lt;code&gt;random()&lt;/code&gt;，它主要用于从Hash里随机选取一个Cookies并返回。每调用一次&lt;code&gt;random()&lt;/code&gt;方法，就会获得随机的Cookies，此方法与接口模块对接即可实现请求接口获取随机Cookies。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-5&quot;&gt;2. 生成模块&lt;/h2&gt;
&lt;p&gt;生成模块负责获取各个账号信息并模拟登录，随后生成Cookies并保存。我们首先获取两个Hash的信息，看看账户的Hash比Cookies的Hash多了哪些还没有生成Cookies的账号，然后将剩余的账号遍历，再去生成Cookies即可。&lt;/p&gt;
&lt;p&gt;这里主要逻辑就是找出那些还没有对应Cookies的账号，然后再逐个获取Cookies，代码如下：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
https://blog.csdn.net/qq_41534566/article/details/83182789
&lt;/pre&gt;
&lt;p&gt;因为我们对接的是新浪微博，前面我们已经破解了新浪微博的四宫格验证码，在这里我们直接对接过来即可，不过现在需要加一个获取Cookies的方法，并针对不同的情况返回不同的结果，逻辑如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里返回结果的类型是字典，并且附有状态码&lt;code&gt;status&lt;/code&gt;，在生成模块里我们可以根据不同的状态码做不同的处理。例如状态码为1的情况，表示成功获取Cookies，我们只需要将Cookies保存到数据库即可。如状态码为2的情况，代表用户名或密码错误，那么我们就应该把当前数据库中存储的账号信息删除。如状态码为3的情况，则代表登录失败的一些错误，此时不能判断是否用户名或密码错误，也不能成功获取Cookies，那么简单提示再进行下一个处理即可，类似代码实现如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要扩展其他站点，只需要实现&lt;code&gt;new_cookies()&lt;/code&gt;方法即可，然后按此处理规则返回对应的模拟登录结果，比如1代表获取成功，2代表用户名或密码错误。&lt;/p&gt;
&lt;p&gt;代码运行之后就会遍历一次尚未生成Cookies的账号，模拟登录生成新的Cookies。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-6&quot;&gt;3. 检测模块&lt;/h2&gt;
&lt;p&gt;我们现在可以用生成模块来生成Cookies，但还是免不了Cookies失效的问题，例如时间太长导致Cookies失效，或者Cookies使用太频繁导致无法正常请求网页。如果遇到这样的Cookies，我们肯定不能让它继续保存在数据库里。&lt;/p&gt;
&lt;p&gt;所以我们还需要增加一个定时检测模块，它负责遍历池中的所有Cookies，同时设置好对应的检测链接，我们用一个个Cookies去请求这个链接。如果请求成功，或者状态码合法，那么该Cookies有效；如果请求失败，或者无法获取正常的数据，比如直接跳回登录页面或者跳到验证页面，那么此Cookies无效，我们需要将该Cookies从数据库中移除。&lt;/p&gt;
&lt;p&gt;此Cookies移除之后，刚才所说的生成模块就会检测到Cookies的Hash和账号的Hash相比少了此账号的Cookies，生成模块就会认为这个账号还没生成Cookies，那么就会用此账号重新登录，此账号的Cookies又被重新更新。&lt;/p&gt;
&lt;p&gt;检测模块需要做的就是检测Cookies失效，然后将其从数据中移除。&lt;/p&gt;
&lt;p&gt;为了实现通用可扩展性，我们首先定义一个检测器的父类，声明一些通用组件，实现如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里定义了一个父类叫作&lt;code&gt;ValidTester&lt;/code&gt;，在&lt;code&gt;__init__()&lt;/code&gt;方法里指定好站点的名称&lt;code&gt;website&lt;/code&gt;，另外建立两个存储模块连接对象&lt;code&gt;cookies_db&lt;/code&gt;和&lt;code&gt;accounts_db&lt;/code&gt;，分别负责操作Cookies和账号的Hash，&lt;code&gt;run()&lt;/code&gt;方法是入口，在这里是遍历了所有的Cookies，然后调用&lt;code&gt;test()&lt;/code&gt;方法进行测试，在这里&lt;code&gt;test()&lt;/code&gt;方法是没有实现的，也就是说我们需要写一个子类来重写这个&lt;code&gt;test()&lt;/code&gt;方法，每个子类负责各自不同网站的检测，如检测微博的就可以定义为&lt;code&gt;WeiboValidTester&lt;/code&gt;，实现其独有的&lt;code&gt;test()&lt;/code&gt;方法来检测微博的Cookies是否合法，然后做相应的处理，所以在这里我们还需要再加一个子类来继承这个&lt;code&gt;ValidTester&lt;/code&gt;，重写其&lt;code&gt;test()&lt;/code&gt;方法，实现如下：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test()&lt;/code&gt;方法首先将Cookies转化为字典，检测Cookies的格式，如果格式不正确，直接将其删除，如果格式没问题，那么就拿此Cookies请求被检测的URL。&lt;code&gt;test()&lt;/code&gt;方法在这里检测微博，检测的URL可以是某个Ajax接口，为了实现可配置化，我们将测试URL也定义成字典，如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;TEST_URL_MAP = {
    &lt;span class=&quot;hljs-string&quot;&gt;'weibo': &lt;span class=&quot;hljs-string&quot;&gt;'https://m.weibo.cn/'
}&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要扩展其他站点，我们可以统一在字典里添加。对微博来说，我们用Cookies去请求目标站点，同时禁止重定向和设置超时时间，得到Response之后检测其返回状态码。如果直接返回200状态码，则Cookies有效，否则可能遇到了302跳转等情况，一般会跳转到登录页面，则Cookies已失效。如果Cookies失效，我们将其从Cookies的Hash里移除即可。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-7&quot;&gt;4. 接口模块&lt;/h2&gt;
&lt;p&gt;生成模块和检测模块如果定时运行就可以完成Cookies实时检测和更新。但是Cookies最终还是需要给爬虫来用，同时一个Cookies池可供多个爬虫使用，所以我们还需要定义一个Web接口，爬虫访问此接口便可以取到随机的Cookies。我们采用Flask来实现接口的搭建，代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;https://blog.csdn.net/qq_41534566/article/details/83182789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们同样需要实现通用的配置来对接不同的站点，所以接口链接的第一个字段定义为站点名称，第二个字段定义为获取的方法，例如，/weibo/random是获取微博的随机Cookies，/zhihu/random是获取知乎的随机Cookies。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-8&quot;&gt;5. 调度模块&lt;/h2&gt;
&lt;p&gt;最后，我们再加一个调度模块让这几个模块配合运行起来，主要的工作就是驱动几个模块定时运行，同时各个模块需要在不同进程上运行，实现如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
https://blog.csdn.net/qq_41534566/article/details/83182789
&lt;/pre&gt;
&lt;p&gt;这里用到了两个重要的配置，即产生模块类和测试模块类的字典配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;这样的配置是为了方便动态扩展使用的，键名为站点名称，键值为类名。如需要配置其他站点可以在字典中添加，如扩展知乎站点的产生模块，则可以配置成：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;GENERATOR_MAP = {
    &lt;span class=&quot;hljs-string&quot;&gt;'weibo': &lt;span class=&quot;hljs-string&quot;&gt;'WeiboCookiesGenerator',
    &lt;span class=&quot;hljs-string&quot;&gt;'zhihu': &lt;span class=&quot;hljs-string&quot;&gt;'ZhihuCookiesGenerator',
}&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Scheduler里将字典进行遍历，同时利用&lt;code&gt;eval()&lt;/code&gt;动态新建各个类的对象，调用其入口&lt;code&gt;run()&lt;/code&gt;方法运行各个模块。同时，各个模块的多进程使用了multiprocessing中的Process类，调用其&lt;code&gt;start()&lt;/code&gt;方法即可启动各个进程。&lt;/p&gt;
&lt;p&gt;另外，各个模块还设有模块开关，我们可以在配置文件中自由设置开关的开启和关闭，如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;定义为True即可开启该模块，定义为False即关闭此模块。&lt;/p&gt;
&lt;p&gt;至此，我们的Cookies就全部完成了。接下来我们将模块同时开启，启动调度器，控制台类似输出如下所示：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;API接口开始运行
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
Cookies生成进程开始运行
Cookies检测进程开始运行
正在生成Cookies 账号 14747223314 密码 asdf1129
正在测试Cookies 用户名 14747219309
Cookies有效 14747219309
正在测试Cookies 用户名 14740626332
Cookies有效 14740626332
正在测试Cookies 用户名 14740691419
Cookies有效 14740691419
正在测试Cookies 用户名 14740618009
Cookies有效 14740618009
正在测试Cookies 用户名 14740636046
Cookies有效 14740636046
正在测试Cookies 用户名 14747222472
Cookies有效 14747222472
Cookies检测完成
验证码位置 420 580 384 544
成功匹配
拖动顺序 [1, 4, 2, 3]
成功获取到Cookies {&lt;span class=&quot;hljs-string&quot;&gt;'SUHB': &lt;span class=&quot;hljs-string&quot;&gt;'08J77UIj4w5n_T', &lt;span class=&quot;hljs-string&quot;&gt;'SCF': &lt;span class=&quot;hljs-string&quot;&gt;'AimcUCUVvHjswSBmTswKh0g4kNj4K7_U9k57YzxbqFt4SFBhXq3Lx4YSNO9VuBV841BMHFIaH4ipnfqZnK7W6Qs.', &lt;span class=&quot;hljs-string&quot;&gt;'SSOLoginState': &lt;span class=&quot;hljs-string&quot;&gt;'1501439488', &lt;span class=&quot;hljs-string&quot;&gt;'_T_WM': &lt;span class=&quot;hljs-string&quot;&gt;'99b7d656220aeb9207b5db97743adc02', &lt;span class=&quot;hljs-string&quot;&gt;'M_WEIBOCN_PARAMS': &lt;span class=&quot;hljs-string&quot;&gt;'uicode%3D20000174', &lt;span class=&quot;hljs-string&quot;&gt;'SUB': &lt;span class=&quot;hljs-string&quot;&gt;'_2A250elZQDeRhGeBM6VAR8ifEzTuIHXVXhXoYrDV6PUJbkdBeLXTxkW17ZoYhhJ92N_RGCjmHpfv9TB8OJQ..'}
成功保存Cookies&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上所示是程序运行的控制台输出内容，我们从中可以看到各个模块都正常启动，测试模块逐个测试Cookies，生成模块获取尚未生成Cookies的账号的Cookies，各个模块并行运行，互不干扰。&lt;/p&gt;
&lt;p&gt;我们可以访问接口获取随机的Cookies，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44baf630329?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/10/162ae44baf630329?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫只需要请求该接口就可以实现随机Cookies的获取。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 07:26:00 +0000</pubDate>
<dc:creator>猿妙不可言</dc:creator>
<og:description>很多时候，在爬取没有登录的情况下，我们也可以访问一部分页面或请求一些接口，因为毕竟网站本身需要做SEO，不会对所有页面都设置登录限制。 但是，不登录直接爬取会有一些弊端，弊端主要有以下两点。 设置了登</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9527huaan/p/9816668.html</dc:identifier>
</item>
<item>
<title>终极方案-前端组件切换样式还原 - zweizhao</title>
<link>http://www.cnblogs.com/ZweiZhao/p/9816642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZweiZhao/p/9816642.html</guid>
<description>&lt;p&gt;先看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181019152040761-767457814.gif&quot; alt=&quot;效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个文章的启发是来自这几天跟别人讨论跨平台解决方案时候意外发现，许多多年前端经验的跨平台开发工程师，都在考虑组件切换引起的瞬间白屏以及组件返回，原组件显示还原问题。&lt;/p&gt;
&lt;h2 id=&quot;误导思路&quot;&gt;误导思路&lt;/h2&gt;
&lt;p&gt;厉害的前端工程师总是可以解决问题，比如上面那个问题，我们拿 A、B 两个组件做实例。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;组件切换，手写（transition）或使用 Vue-Router 来做 A、B 组件切换动画&lt;/li&gt;
&lt;li&gt;A 切换到 B，没有什么问题，无外乎动画优雅度问题&lt;/li&gt;
&lt;li&gt;B 回到 A，B 走了，没问题，但是 A 的出现便出现了问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;A 具体出现的问题，请允许我用语言描述，因为我后面的代码示例并非列表类型。&lt;/p&gt;
&lt;p&gt;场景：列表到详情页面，列表上百个。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用户使用滚动，到下个或下下个屏幕的列表项，点击前往详情，详情浏览完毕后，点击返回或后退到列表页。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;问题出现，列表内容得重新填充，还要把列表所在的滚动位置还原。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OK，有小伙伴说，记录下滚动的 scroll 即可。没错，但是如果这个页面有很多表格（有点扯），或者有其他各种交互变化，然后返回呢？一一去记录配置吗？&lt;/p&gt;
&lt;p&gt;一一配置当然没有问题，但是工作量以及 bug 几率，啧啧啧……&lt;/p&gt;
&lt;h2 id=&quot;分析原因&quot;&gt;分析原因&lt;/h2&gt;
&lt;p&gt;原因本身就是切换层级问题，简单来说就是：兄弟组件的切换，就是一个此消彼长的过程。&lt;/p&gt;
&lt;p&gt;说人话！&lt;/p&gt;
&lt;p&gt;好吧，就是说上面的 A 与 B 页面只能存活一个的意思。&lt;/p&gt;
&lt;p&gt;A 出现，B 就不见；同样的，B 出现，A 页面也就消失了。&lt;/p&gt;
&lt;p&gt;所以，从 B 返回 A 时候，A 需要重新渲染 DOM，从而导致相关的问题，也就是说，如果 A 是个简单页面，就不存在这个问题了。&lt;/p&gt;
&lt;h2 id=&quot;推出结论&quot;&gt;推出结论&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;层级问题&lt;/li&gt;
&lt;li&gt;解决层级问题的方案&lt;/li&gt;
&lt;li&gt;所谓方案就是 B 出现时候 A 不消失&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;明白了么，这个原理，小伙伴。&lt;/p&gt;
&lt;p&gt;话不多说，终于上代码：&lt;/p&gt;
&lt;h3 id=&quot;router&quot;&gt;Router&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import Vue from 'vue'
import VueRouter from 'vue-router'
import Delegate from '../component/delegate/delegate.vue'
import Rule from '../component/rule/rule.vue'
import Rank from '../component/rank/rank.vue'
import More from '../component/more/more.vue'
import Login from '../component/login/login.vue'
import Empty from '../component/empty/empty.vue'

Vue.use(VueRouter)

export default new VueRouter({
  routes: [
    {path: '/empty', component: Empty, alias: '/'},
    {path: '//delegate', component: Delegate},
    {path: '/rule', component: Rule},
    {path: '/rank', component: Rank},
    {path: '/more', component: More},
    {path: '/login', component: Login},
  ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意几方面东西。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;斜杠代表了层级，因为我懒得写子级 route，所以出现 &lt;code&gt;//delegate&lt;/code&gt; 来代表子子级。&lt;/li&gt;
&lt;li&gt;empty 作用，后面说，但是这里注意默认是 empty 即可，即 &lt;code&gt;alias: '/'&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;animation&quot;&gt;animation&lt;/h3&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.push-enter {
  transform: translateX(100%);
  opacity: 0.8;
}

.push-enter-active {
  transition: all 0.3s ease;
}

.push-enter-to, .push-leave {
  transform: translateX(0);
  opacity: 1;
}

.push-leave-active {
  transition: all 0.3s ease;
}

.push-leave-to, .pop-enter {
  transform: translateX(-50%);
  opacity: 0.8; 
}

.pop-enter-active {
  transition: all 0.3s ease;
}

.pop-enter-to, .pop-leave {
  transform: translateX(0);
  opacity: 1;
}

.pop-leave-active {
  transition: all 0.3s ease;
  z-index: 999;
}

.pop-leave-to {
  transform: translateX(100%);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动画效果，这里模仿的是移动端页面切换动画，有移动端经验小伙伴能看懂，就是类似 VC 与 Activity 切换那种出栈入栈效果。&lt;/p&gt;
&lt;p&gt;但是截止位置，都没有解决上面的问题，没错，重点是下面。&lt;/p&gt;
&lt;h3 id=&quot;放置一个空的子组件在当前页面上&quot;&gt;放置一个空的子组件在当前页面上&lt;/h3&gt;
&lt;p&gt;说是说没解决，实际上逻辑上已经有那个意思了，回看 Router 那里，是不是有个 Empty，没错，这个就是在每个页面都显示出来的时候，放置在已有页面上的一个子组件，只不过大小为 0x0，位置随意，建议放在左上角，因为我们控制的 CSS 是修改 x 方向。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;empty&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {

}
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里偷懒，所以就这样写了 empty.vue 了。&lt;/p&gt;
&lt;p&gt;然后就是配置与 Empty 同级的兄弟组件了，也许你已经想到，这个兄弟组件的位置在右边，然后在屏幕外面等着呢（尽管目前可能没有渲染）。&lt;/p&gt;
&lt;p&gt;所以，它的关键样式（公有）是这样的：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.page {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合上面的入场动画，就可以实现类似在右边划进来的效果了。&lt;/p&gt;
&lt;p&gt;这里提一下，建议使用 absolute 来代替 fixed，虽然 fixed 看似一劳永逸，但是在不同平台上会有不同的问题。&lt;/p&gt;
&lt;p&gt;到这里，基本原理说清楚了，下面简单总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;做的不是兄弟组件视觉切换&lt;/li&gt;
&lt;li&gt;做的是父子级视觉切换&lt;/li&gt;
&lt;li&gt;但是实际上依然是兄弟组件切换&lt;/li&gt;
&lt;li&gt;一个默认的 Empty 组件放在了已有的父组件上面，大小 0x0&lt;/li&gt;
&lt;li&gt;切换的是这个 0x0 组件与其兄弟组件变化&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;实际效果&quot;&gt;实际效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181019144545129-329172143.gif&quot; alt=&quot;全功能 Demo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;体验地址：&lt;a href=&quot;https://www.zweizhao.com/VueMobileFramework/dist/index.html&quot;&gt;全功能 Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仿写：&lt;a href=&quot;https://github.com/ZweiZhao/GoTop&quot;&gt;仿写&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ZweiZhao/VueMobileFramework&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果解决了你遇到的问题，请随手丢个 star 哈。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 07:22:00 +0000</pubDate>
<dc:creator>zweizhao</dc:creator>
<og:description>本文使用 Vue 做例子，其他框架或原生一样原理 先看效果 这个文章的启发是来自这几天跟别人讨论跨平台解决方案时候意外发现，许多多年前端经验的跨平台开发工程师，都在考虑组件切换引起的瞬间白屏以及组件返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZweiZhao/p/9816642.html</dc:identifier>
</item>
<item>
<title>百度&amp;高德地图小区景点边界轮廓实现 - 冷星1024</title>
<link>http://www.cnblogs.com/ld1024/p/9816628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ld1024/p/9816628.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;经常的我们在使用地图功能时，会发现在选择一个小区或者一个热门景点的时候，地图上面会给出其边界轮廓，能够方便我们知道其范围大小，有时候在我们使用地图组件的时候，也会面临着类似的需求。比如在地图上面标识出一个商场范围内的热力图，一个热门景点的游览情况等。那么，我们该如何利用地图功能来实现这类效果呢，今天我们一起来探讨一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.lengxing.club/2018/09/27/2018-09-27/1.gif&quot; alt=&quot;效果截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近我们就有一个需求，需要标识出一些热门场所的人流的热力图情况，同时需要给出该热门场所的边界轮廓。经过查看百度地图和高德地图的开发者API文档，发现并没有这类公共接口提供我们使用。目前地图能够提供我们使用的，基本只能是一些行政区划的边界范围，这个在我之前的文章中也有写过，大家可以参照&lt;a href=&quot;https://lengxing.club/2018/06/28/2018-06-28/&quot;&gt;《仿链家地图找房的简单实现》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那么现在面临的需求该如何实现呢？&lt;/p&gt;
&lt;p&gt;通过查看地图功能的接口调用情况和在网上查询相关资料，最终我们找到了下面这个“不算是方法的方法”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用了地图的相关API接口获取相关数据&lt;/li&gt;
&lt;li&gt;API接口不是官方给出的，所以也就面临着稳定性的问题，可能随时被关（高德的只能简单参考，本身就存在较大缺陷，后面会说）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt;
&lt;ul readability=&quot;1.3722109533469&quot;&gt;&lt;li readability=&quot;2.1195652173913&quot;&gt;
&lt;p&gt;通过地图的POI查询服务获取到兴趣点id&lt;/p&gt;
&lt;p&gt;那么什么是POI呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;检索服务提供某一特定地区的兴趣点位置查询服务（POI：Point of Interest，感兴趣点）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关的官方文档请参照以下地址：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过兴趣点id获取该兴趣点的详细信息&lt;/p&gt;
&lt;p&gt;这里面需要用到的相关API就需要我们查看地图的执行过程，找到对应的API了。（也希望各个地图官方能够给出官方的方法吧）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS:地图功能的使用情况在本篇不做说明，具体申请相关Key的过程请分别参照官网说明即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们来分别给出百度地图和高德地图的实现方法：&lt;/p&gt;
&lt;h3 id=&quot;百度地图实现&quot;&gt;&lt;a href=&quot;https://lengxing.club/Sample/bMap.html&quot;&gt;百度地图实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;闲话休谈，咱们直接上码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;/html&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;百度地图DEMO&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;amp;ak=你申请的AK&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {

        var queryHouseOutline = function(hid, callback) {
            var baseURL = 'http://map.baidu.com/?reqflag=pcmap&amp;amp;coord_type=3&amp;amp;from=webmap&amp;amp;qt=ext&amp;amp;ext_ver=new&amp;amp;l=18';
            var url = baseURL + &quot;&amp;amp;uid=&quot; + hid;
            callback &amp;amp;&amp;amp; (window.queryHouseOutlineCallback = callback);
            $.ajax({
                type: &quot;get&quot;,
                async: false,
                url: url,
                dataType: &quot;jsonp&quot;,
                jsonpCallback: &quot;queryHouseOutlineCallback&quot;,
                success: function(datas) {}
            });
        };

        /**
         * 模糊查询小区信息, 无返回值
         * @param {} house  小区名称
         * @param {} city   所属城市名称
         * @param {} ak     百度地图AK
         * @param {} callback   回调函数，该函数可以接收到请求的返回值
         */
        var queryHouse = function(house, city, ak, callback) {
            var baseURL = 'http://api.map.baidu.com/place/v2/search?output=json&amp;amp;scope=2';
            var url = baseURL + &quot;&amp;amp;q=&quot; + house + &quot;&amp;amp;region=&quot; + city + &quot;&amp;amp;ak=&quot; + ak;
            callback &amp;amp;&amp;amp; (window.queryHouseCallback = callback);
            $.ajax({
                type: &quot;get&quot;,
                async: false,
                url: url,
                dataType: &quot;jsonp&quot;,
                jsonpCallback: &quot;queryHouseCallback&quot;,
                success: function(datas) {}
            });
        };

        /**
         * 墨卡托坐标转百度坐标
         * @param {} coordinate
         * @return {}
         */
        var coordinateToPoints = function(map, coordinate) {
            var points = [];
            if (coordinate) {
                var arr = coordinate.split(&quot;;&quot;);
                if (arr) {
                    for (var i = 0; i &amp;lt; arr.length; i++) {
                        var coord = arr[i].split(&quot;,&quot;);
                        if (coord &amp;amp;&amp;amp; coord.length == 2) {
                            var mctXY = new BMap.Pixel(coord[0], coord[1]);
                            var project = map.getMapType().getProjection();
                            var point = project.pointToLngLat(mctXY);
                            points.push(new BMap.Point(point.lng, point.lat));
                        }
                    }
                }
            }
            return points;
        };
        /**
         * 墨卡托坐标解析
         * @param {} mocator
         * @return {}
         */
        var parseGeo = function(mocator) {
            if (typeof mocator != 'string') {
                return {};
            }
            var t = mocator.split(&quot;|&quot;);
            var n = parseInt(t[0]);
            var i = t[1];
            var r = t[2];
            var o = r.split(&quot;;&quot;);
            if (n === 4) {
                for (var a = [], s = 0; s &amp;lt; o.length - 1; s++) {
                    &quot;1&quot; === o[s].split(&quot;-&quot;)[0] &amp;amp;&amp;amp; a.push(o[s].split(&quot;-&quot;)[1]);
                }
                o = a;
                o.push(&quot;&quot;);
            }
            var u = [];
            switch (n) {
                case 1:
                    u.push(o[0]);
                    break;
                case 2:
                case 3:
                case 4:
                    for (var s = 0; s &amp;lt; o.length - 1; s++) {
                        var l = o[s];
                        if (l.length &amp;gt; 100) {
                            l = l.replace(/(-?[1-9]\d*\.\d*|-?0\.\d*[1-9]\d*|-?0?\.0+|0|-?[1-9]\d*),(-?[1-9]\d*\.\d*|-?0\.\d*[1-9]\d*|-?0?\.0+|0|-?[1-9]\d*)(,)/g,
                                &quot;$1,$2;&quot;);
                            u.push(l);
                        } else {
                            for (var c = [], d = l.split(&quot;,&quot;), f = 0; f &amp;lt; d.length; f += 2) {
                                var p = d[f];
                                var h = d[f + 1];
                                c.push(p + &quot;,&quot; + h);
                            }
                            u.push(c.join(&quot;;&quot;))
                        }
                    }
                    break;
                default:
                    break;
            }

            if (u.length &amp;lt;= 1) {
                u = u.toString();
            }

            var result = {
                type: n,
                bound: i,
                points: u
            };
            return result;
        };


        var map = new BMap.Map(&quot;allmap&quot;); // 创建Map实例
        map.centerAndZoom(&quot;北京&quot;, 19);
        map.addControl(new BMap.MapTypeControl()); //添加地图类型控件

        map.enableScrollWheelZoom(false); //开启鼠标滚轮缩放

        /**
         * 第一个参数是城市名，第二参数是小区名 
         */
        var showArea = function(city, area) {
            queryHouse(area, city, &quot;你申请的AK&quot;, function(data) {
                if (data.message == 'ok') {
                    var houses = data.results;
                    if (houses &amp;amp;&amp;amp; houses.length &amp;gt; 0) {
                        var house = houses[0];
                        queryHouseOutline(house.uid, function(houseOutline) {
                            var geo = houseOutline.content.geo;
                            if (!geo) {
                                var location = house.location;
                                var point = new BMap.Point(location.lng, location.lat);
                                map.centerAndZoom(point, 19);
                                var marker = new BMap.Marker(point);
                                marker.setAnimation(BMAP_ANIMATION_BOUNCE);
                                map.addOverlay(marker);
                            } else {
                                map.clearOverlays();
                                var geoObj = parseGeo(geo);
                                //边界点
                                var points = coordinateToPoints(map, geoObj.points);
                                var ply = new BMap.Polygon(points, {
                                    strokeWeight: 2,
                                    strokeColor: &quot;#F01B2D&quot;,
                                    strokeOpacity: 0.9,
                                    fillColor: &quot;transparent&quot;
                                }); //建立多边形覆盖物
                                map.addOverlay(ply); //添加覆盖物
                                map.setViewport(ply.getPath()); //调整视野 
                            }
                        });
                    }
                }
            });
        };

        showArea($('#cityId').val(), $('#areaId').val());

        $('#showBtn').click(function() {
            debugger;
            showArea($('#cityId').val(), $('#areaId').val());
        });

        $(&quot;#areaId&quot;).keydown(function(e) {
            if (event.keyCode == &quot;13&quot;) {
                showArea($('#cityId').val(), $('#areaId').val());
            }
        })
    });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;table&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;城市:&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input id=&quot;cityId&quot; type=&quot;text&quot; value=&quot;北京&quot; /&amp;gt;
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;小区:&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input id=&quot;areaId&quot; type=&quot;text&quot; value=&quot;故宫博物院&quot; /&amp;gt;
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;button id=&quot;showBtn&quot;&amp;gt;显示&amp;lt;/button&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
    &amp;lt;div id=&quot;allmap&quot; style=&quot;width: 90vw; height: 90vh;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关的代码注释都有所添加，参照即可。其中需要注意的是百度地图获取到的坐标点需要进行转换成百度地图识别的点位形式。&lt;br/&gt;另外，边界的描画使用到的是地图的Polygon功能，相关内容&lt;a href=&quot;http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a3b14&quot;&gt;请参照&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;高德地图实现&quot;&gt;&lt;a href=&quot;https://lengxing.club/Sample/aMap.html&quot;&gt;高德地图实现&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;/html&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;高德地图DEMO&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.10&amp;amp;key=你申请的AK&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        var map = new AMap.Map('allmap', {
            zoom: 19,
            center: [116.397428, 39.90923]
        }); // 创建Map实例

        /**
         * 第一个参数是城市名，第二参数是小区名 
         */
        var showArea = function(city, area) {
            queryHouse(area, city, &quot;你申请的AK&quot;, function(data) {
                console.error(data)
                if (data.status == 1) {
                    var houses = data.pois;
                    if (houses &amp;amp;&amp;amp; houses.length &amp;gt; 0) {
                        var house = houses[0];
                        queryHouseOutline(house.id, function(houseOutline) {
                            console.error(&quot;get outline success&quot;);

                            var pathPoints = houseOutline.data.spec.mining_shape.shape;
                            
                            var tmpPath = pathPoints.split(&quot;;&quot;);

                            var points = [];
                            tmpPath.forEach(function(value, index, array) {
                                points.push(value.split(&quot;,&quot;))
                            });

                            map.clearMap();

                            var ply = new AMap.Polygon({
                                map: map,
                                path: points,
                                strokeColor: &quot;#F01B2D&quot;,
                                fillColor: &quot;transparent&quot;
                            }); //建立多边形覆盖物

                            map.setFitView(); //调整最佳显示
                        });
                    }
                }
            });
        };

        var queryHouseOutline = function(hid, callback) {
            var baseURL = 'https://www.amap.com/detail/get/detail';
            $.ajax({
                type: &quot;get&quot;,
                data: {
                    id: hid
                },
                url: baseURL,
                dataType: &quot;json&quot;,
                success: function(datas) {
                    callback(datas)
                }
            });
        };

        /**
         * 模糊查询小区信息, 无返回值
         * @param {} house  小区名称
         * @param {} city   所属城市名称
         * @param {} ak     高德地图AK
         * @param {} callback   回调函数，该函数可以接收到请求的返回值
         */
        var queryHouse = function(house, city, ak, callback) {
            var baseURL = 'http://restapi.amap.com/v3/place/text?&amp;amp;keywords=' + house + '&amp;amp;city=' + city + '&amp;amp;output=json&amp;amp;offset=20&amp;amp;page=1&amp;amp;key=' + ak;
            callback &amp;amp;&amp;amp; (window.queryHouseCallback = callback);
            $.ajax({
                type: &quot;get&quot;,
                async: false,
                url: baseURL,
                dataType: &quot;jsonp&quot;,
                jsonpCallback: &quot;queryHouseCallback&quot;,
                success: function(datas) {}
            });
        };

        showArea($('#cityId').val(), $('#areaId').val());

        $('#showBtn').click(function() {
            showArea($('#cityId').val(), $('#areaId').val());
        });

        $(&quot;#areaId&quot;).keydown(function(e) {
            if (event.keyCode == &quot;13&quot;) {
                showArea($('#cityId').val(), $('#areaId').val());
            }
        })
    });
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;table&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;城市:&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input id=&quot;cityId&quot; type=&quot;text&quot; value=&quot;北京&quot; /&amp;gt;
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;小区:&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;input id=&quot;areaId&quot; type=&quot;text&quot; value=&quot;故宫博物院&quot; /&amp;gt;
            &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;button id=&quot;showBtn&quot;&amp;gt;显示&amp;lt;/button&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
    &amp;lt;div id=&quot;allmap&quot; style=&quot;width: 90vw; height: 90vh;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;高德地图的实现方式根据实际的效果来看，本身应该是做了API接口限制的处理，经常会出现获取不到详细信息或者给出的详细信息中的边界信息数据不准确。&lt;br/&gt;这里只是作为一个对比参照，高德地图不推荐来做这个需求，API接口稳定性太差。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;①百度地图会涉及到功能接口配额的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.lengxing.club/2018/09/27/2018-09-27/3.png&quot; alt=&quot;配额截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要会涉及到上面的&lt;code&gt;地点检索&lt;/code&gt;配额，如果只是个人简单使用的，可以注册个人开发者，基本配额就够使用了&lt;/p&gt;
&lt;p&gt;②高德地图没有找到配额相关的数据，毕竟走的非正规手段吧&lt;/p&gt;
&lt;p&gt;③百度地图和高德地图对于一些位置的边界数据不同&lt;/p&gt;
&lt;p&gt;有些地点只会在其中一个能够获取到（高德地图能够返回数据的情况下）&lt;/p&gt;
&lt;p&gt;④高德地图在检索位置时，能够支持全拼音输入，也能检索出来（感觉这个厉害，但是中文多音字处理不知道会怎么样）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhonghuart/article/details/77934693&quot;&gt;百度地图小区边界（轮廓）处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34464926/article/details/79128211&quot;&gt;高德地图之python爬取POI数据及其边界经纬度(根据关键字在城市范围内搜索)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 07:20:00 +0000</pubDate>
<dc:creator>冷星1024</dc:creator>
<og:description>经常的我们在使用地图功能时，会发现在选择一个小区或者一个热门景点的时候，地图上面会给出其边界轮廓，能够方便我们知道其范围大小，有时候在我们使用地图组件的时候，也会面临着类似的需求。比如在地图上面标识出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ld1024/p/9816628.html</dc:identifier>
</item>
<item>
<title>了解 HTTPS，读这篇文章就够了 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/9816250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/9816250.html</guid>
<description>&lt;p&gt;今天接到个活儿，让我科普 HTTPS 。讲 HTTP 我都“方”，想要通俗易懂的说完 HTTPS， 我有点“圆”。在讲什么是 HTTPS 之前，我们先来看个漫画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/80097-cd81eaa6ffbe4c00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;△ 图片来源于阮一峰的网络日志&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 图片来源于阮一峰的网络日志&lt;/p&gt;

&lt;p&gt;漫画中其实就是 HTTPS 的握手过程，但是我相信大段的英文你看着也不怎么流畅，下面就由我简单讲解下吧。HTTPS 是在 HTTP 的基础上增加了 SSL 或 TLS 安全协议，这些协议有众多的套件，这些套件则是由加密算法和哈希算法组成，而这些算法最后则涉及到了数学。数学是我上学时期最头痛的学科，还记得上数学课时，我传纸条给坐在我后面的班花……咦，好像有点跑偏了，拉回来，坐好了，开始我们的 HTTPS 之旅。&lt;/p&gt;
&lt;h2 id=&quot;sectionhttps&quot;&gt;HTTPS 是什么&lt;/h2&gt;
&lt;p&gt;HTTPS 是为了安全的使用 HTTP ，缩写展开：Hyper Text Transfer Protocol over Secure Socket Layer 。从英文释义可以看出，HTTPS 就是 HTTP + SSL 或者 HTTP + TLS 。&lt;/p&gt;
&lt;p&gt;“我读书少，你可不要骗我，上面的英文缩写不是 HTTP over SSL 吗？”呃...是这样的，HTTPS 最初使用的加密协议的确是 SSL，SSL 最近的三个版本是：SSL 1.0 、SSL 2.0 、SSL 3.0 ，不过随着加密算法的发展和人们对传输安全性要求的提高，截止目前已经长江后浪推前浪依次推出了 TLS 的四个版本，分别是：TLS 1.0 、TLS 1.1 、TLS 1.2 以及前不久刚推出的 TLS 1.3 。实际上，业内也有人把 TLS 1.0 叫做 SSL 3.1 ，事实上，TLS 是在 SSL 的基础上发展起来的更安全的加密协议。&lt;/p&gt;
&lt;h2 id=&quot;sectionhttps-1&quot;&gt;为什么要使用 HTTPS&lt;/h2&gt;
&lt;p&gt;这个问题要从为什么逐渐的抛弃 HTTP 说起。HTTP 从 1991 年的 HTTP/0.9 一直发展到 1999 年的 HTTP/1.1 ，虽然功能不断增加，性能也不断提高，但是随着互联网技术和网络设备的迅速普及，导致信息大爆炸，众多的网民们对网络传输的速度和安全性有了越来越高的要求。2012 年，谷歌推出了 SPDY 方案，优化了 HTTP/1.x 的请求延迟和安全性问题，进一步普及了 HTTPS，截止到 2015 年，HTTP/2 已经成为标准，更是进一步推动了全网 HTTPS 的进程。&lt;/p&gt;
&lt;p&gt;全网 HTTPS 是大势所趋，那么为什么抛弃 HTTP 呢？最重要的原因就是安全问题，因为 HTTP 是明文传输的，这对于目前从娃娃就开始玩智能手机，学习 python 编程的新一代来说，抓个包估计是不在话下，更别提浸淫网络多年的“黑客”了。是时候跑步进入 HTTPS 加密时代的了。&lt;/p&gt;
&lt;h2 id=&quot;sectionhttps-2&quot;&gt;HTTPS 为什么安全&lt;/h2&gt;
&lt;p&gt;上文已经有提到，HTTPS 就是 HTTP + SSL or TLS ，除了 HTTPS 传输标准严格和规范外，主要是 SSL 或者 TLS 对传输的信息有一整套的加解密和校验方案。这套方案主要从下面三个方面确保传输的安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 身份认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输之前首先通过数字证书来确认身份，各大 CA 厂商干的就是这个事情。这里涉及到一个名词：数字证书。数字证书分为公钥和私钥，CA 厂商会用自己的私钥来给证书申请者签发一套包含私钥和公钥的客户证书，客户的公钥证书谁都可以获取，里面包含了客户站点和证书的基本信息，用来确保访问者访问的就是他想要访问的站点。&lt;/p&gt;
&lt;p&gt;这个证书不可以伪造吗？答案是真的不可以。&lt;/p&gt;
&lt;p&gt;原因一：系统早已内置了各大 CA 厂商的公钥来校验证书是否是对应的站点的证书，如果不是，就会给出证书不匹配的提示，除非你给别人的设备强行植入假的 CA 公钥。&lt;/p&gt;
&lt;p&gt;原因二：这个证书是 CA 厂商通过哈希并加密得到的，基本无法逆向破解并伪造一个新的，除非是你黑进 CA 获取了 CA 的私钥，那这家 CA 也基本可以倒闭了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 数据保密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据保密包括对话秘钥传输时候的保密和数据的加密传送。&lt;/p&gt;
&lt;p&gt;对话秘钥：以 TLS 1.2 使用的套件之一 DHE-RSA-AES256-SHA256 为例：该套件是以 DHE 、RSA 作为秘钥交换算法，这两种秘钥交换算法都是使用的非对称加密，数学原理分别依赖于计算离散对数的难度和大数分解的难度。也就是在建立 HTTPS 链接的过程中，刚开始是有一些明文出现的，不过想要根据这些已知的明文推算出“对话秘钥”却非常困难。&lt;/p&gt;
&lt;p&gt;对话加密：客户端和和服务端协商并成功获取到对话秘钥后就开始用对话秘钥进行对称加密会话，上面的套件我们可以看到使用的是 AES256 加密算法。&lt;/p&gt;
&lt;p&gt;那么为什么“对话秘钥”的交换使用非对称加密，正式对话数据的传输使用对称加密？因为非对称加密虽然安全性比较高，但是它的效率比较低，速度比较慢，所以我们一般只使用它们来交换一下对话秘钥，后面的对话加密则使用速度更快，效率更高的对称加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3\. 数据完整&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份认证成功后，到了数据加密传输的阶段，所有数据都以明文（HTTP）收发，只不过收发的是加密后的明文。这时候也遇到了一个问题，虽然中间人很难破解加密后的数据，但是如果他对数据进行了篡改，那该怎么办？此时加密套件验证数据一致性的哈希算法就派上用场了，哈希算法有多种，比如 MD5 ，SHA1 或者 SHA2 等，上面举例的加密套件使用的是 SHA2 中的 SHA256 来对数据进行哈希计算。这样就使得任何的数据更改都会导致通信双方在校验时发现问题，进而发出警报并采取相应的措施。&lt;/p&gt;
&lt;p&gt;以上主要从使用 HTTPS 的必要性及 HTTPS 能安全传输的原理进行了简单的阐述，HTTPS 的实现不仅仅是网络技术的集中应用，底层还涉及到了大量的算法以及密码学的众多知识，小编也无法一下子概述完整（笑哭）。另外，不论是 PFS，或是国际互联网组织正在推行的 HSTS 安全传输协议，他们的主要目的就是避免中间人攻击，使信息在传输过程中更安全，更快速。想要更详细的了解 HTTPS 相关知识，我们在推荐阅读里准备了大量的 HTTPS 干货，欢迎查阅。&lt;/p&gt;
&lt;p&gt;彩蛋：你是不是想吐槽一下标题说读这篇就够了，哈哈，你得允许我皮一下嘛~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/338/%25E4%25B8%258D%25E6%2598%25AF%2520HTTPS%2520%25E6%258B%2596%25E6%2585%25A2%25E7%25BD%2591%25E7%25AB%2599%25E9%2580%259F%25E5%25BA%25A6%25EF%25BC%258C%25E8%2580%258C%25E6%2598%25AF%25E4%25BC%2598%25E5%258C%2596%25E5%2581%259A%25E7%259A%2584%25E4%25B8%258D%25E5%25A4%259F%25E4%25BC%2598%25E7%25A7%2580.html&quot; target=&quot;_blank&quot;&gt;不是 HTTPS 拖慢网站速度，而是优化做的不够优秀​&lt;/a&gt; &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/286/%25E7%25A7%2591%25E6%2599%25AE%2520TLS%25201.3%2520%25E2%2580%2594%2520%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B8%258E%25E5%25BC%2580%25E5%2590%25AF%25E6%2596%25B9%25E5%25BC%258F.html&quot; target=&quot;_blank&quot;&gt;科普 TLS 1.3 — 新特性与开启方式&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/242/%25E4%25BB%258E%2520HTTP%2520%25E5%2588%25B0%2520HTTPS%2520%25E5%2586%258D%25E5%2588%25B0%2520HSTS.html&quot; target=&quot;_blank&quot;&gt;从 HTTP 到 HTTPS 再到 HSTS&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 06:29:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<og:description>今天接到个活儿，让我科普 HTTPS 。讲 HTTP 我都“方”，想要通俗易懂的说完 HTTPS， 我有点“圆”。在讲什么是 HTTPS 之前，我们先来看个漫画。 △ 图片来源于阮一峰的网络日志 漫画</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/9816250.html</dc:identifier>
</item>
<item>
<title>第一行代码：以太坊（3）-使用更多的工具编写和测试智能合约 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/9815949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/9815949.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://item.jd.com/12442886.html&quot; rel=&quot;nofollow&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
《第一行代码：以太坊》开始连载了&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上文中已经使用了Remix环境运行和测试了本书编写的第一个智能合约程序，不过编写和测试智能合约的测试方式很多，例如，在testrpc环境测试；在Intellij IDEA集成开发环境中用Solidity语言编写智能合约；在纯Web环境中测试智能合约；使用AJAX方式测试智能合约等。本文将详细介绍这些用于编写和测试智能合约的方法。&lt;/p&gt;
&lt;h3&gt;1.安装本地remix环境（Windows、Mac OS X和Linux）&lt;/h3&gt;
&lt;p&gt;在本节使用Remix环境运行和测试了Calc智能合约，不过使用的是在线Remix环境。由于某些原因（如没有网络，或网络速度很慢），我们希望使用本地的Remix环境运行和测试智能合约，这就要就将Remix环境安装在本地。Remix是跨平台的，所以本节介绍的安装方法同时适用于Windows、Mac OS X和Linux。&lt;/p&gt;
&lt;p&gt;不管是在什么操作系统下安装Remix，都必须安装Node.js，读者可以到https://nodejs.org下载Node.js的最新版直接安装即可。&lt;/p&gt;
&lt;p&gt;安装完Node.js后，需要使用git命令下载Remix的代码库（browser-solidity），命令行如下：&lt;/p&gt;
&lt;p&gt;git clone &lt;a href=&quot;https://github.com/ethereum/browser-solidity&quot; rel=&quot;nofollow&quot;&gt;https://github.com/ethereum/browser-solidity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Mac OS X和Linux下，一般会集成git命令，但在Windows下，默认是没有git命令的，所以需要到下面的页面下载Windows版的git工具，下载完后直接安装即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/download/win&quot; rel=&quot;nofollow&quot;&gt;https://git-scm.com/download/win&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用git命令下载完Remix的代码库后，使用cd命令进入browser-solidity目录，该目录在下载Remix代码库的过程中自动在当前目录中创建。&lt;/p&gt;
&lt;p&gt;在browser-solidity目录中执行下面的命令安装browser-solidity。&lt;/p&gt;
&lt;p&gt;npm install&lt;/p&gt;
&lt;p&gt;安装browser-solidity的过程比较漫长，读者要耐心等待。下图是在Windows下安装browser-solidity环境的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-e1531beb15c1a3ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果成功安装了browser-solidity，可以使用下面的命令启动Remix服务。&lt;/p&gt;
&lt;p&gt;npm start&lt;/p&gt;
&lt;p&gt;下图是Mac OS X下启动Remix服务后的输出信息，Windows和Linux会输出类似的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-b91319d20e3d343a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Remix服务默认的端口号是8080，如果在浏览器地址栏中输入下面的Url，就可以使用本地的Remix环境编写和测试智能合约。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8080/&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 安装testrpc&lt;/h3&gt;
&lt;p&gt;testrpc与geth不同，geth是真正的以太坊环境，而testrpc是在本地模拟的一个以太坊环境，主要用于开发调试。当智能合约使用testrpc调试通过后，可以部署在真正的以太坊环境中。&lt;br/&gt;安装testrpc仍然需要Node.js环境，所以读者应该事先安装好Node.js，然后使用下面的命令安装testrpc。&lt;br/&gt;npm install -g ethereumjs-testrpc&lt;/p&gt;
&lt;p&gt;安装好testrpc后，可以使用testrpc命令运行testrpc。下图是Mac OS X下启动testrpc服务的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-284c5819ba8404f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是Windows下启动testrpc服务的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-42c42d8bf0aa0349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，不管是在哪一个平台上启动testrpc服务，都会自动生成10个账号（Accounts）和10个私钥（Private Keys）。这些账号和私钥都是用于测试的，而且每一个账号拥有的以太币几乎是无限大的，因此，不用担心进行某些操作后没有以太币可用。&lt;/p&gt;
&lt;p&gt;testrpc本身是一个服务，默认的端口号是8545，这个端口号是用于像web3.js、web3.py一样的程序库连接以太坊节点的，testrpc其实也相当于一个用于测试的以太坊节点。&lt;/p&gt;
&lt;h3&gt;3.使用testrpc测试智能合约&lt;/h3&gt;
&lt;p&gt;本节会将智能合约部署到testrpc服务上，然后使用web3.js连接testrpc服务，并调用智能合约中的函数。具体的操作步骤如下：&lt;/p&gt;
&lt;h4&gt;（1）编写智能合约&lt;/h4&gt;
&lt;p&gt;启动本地的Remix环境，然后在Remix环境中输入下面的智能合约代码。&lt;/p&gt;
&lt;p&gt;本例编写了一个名为Factorial的智能合约程序，在该智能合约中有一个factorial函数，用于计算n的阶乘。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;pragma solidity ^&lt;span class=&quot;hljs-number&quot;&gt;0.4&lt;span class=&quot;hljs-number&quot;&gt;.0;
contract Factorial 
{
    &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个智能合约用于计算n的阶乘。&lt;/p&gt;
&lt;h4&gt;（2）将智能合约部署在testrpc节点上&lt;/h4&gt;
&lt;p&gt;在Remix环境的右侧进入“Run”页面，并在“Environment”列表中选择“Web3 Provider”，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-36ef084a16066df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Web3 Provider环境下，Remix可以将智能合约直接部署到testrpc服务上。进入Web3 Provider之前，会弹出一个对话框，询问是否连接以太坊节点，单击“OK”按钮，会弹出如下图所示的对话框。在该对话框中有一个文本框，默认值是http://localhost:8545，如果要连接本地的testrpc节点或以太坊节点，直接单击“OK”按钮即可。如果testrpc节点已经启动，那么Remix本地环境会成功连接到testrpc节点上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-940fa37b1a978c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击“Run”页面的“Deploy”按钮，会将Factorial智能合约部署到testrpc上。部署成功后，会在“Run”页面的下方出现“factorial”按钮，如下图所示。在按钮右侧的文本框输入要计算阶乘的n的值，然后点击该按钮即可在以太坊测试环境（testrpc）下执行factorial函数，不过在日志区域点击“Details”按钮后，并没有看到factorial函数的输出结果，这是因为factoria函数是直接在以太坊网络中运行的，所有的数据都存在于以太坊网络中，并不会直接将数据返回给以太坊客户端。&lt;/p&gt;
&lt;p&gt;在“factorial”按钮的上方是Factorial智能合约的地址，如果在客户端要访问这个智能合约，需要使用这个地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-7cb3c3d54942cad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;（3）安装Solidity编译器&lt;/h4&gt;
&lt;p&gt;Solidity编译器是用于编译Solidity源代码文件（.sol文件）的，可以将Solidity源代码文件编译成多种目标文件。使用下面的命令行可以安装Solidity编译器。&lt;/p&gt;
&lt;p&gt;npm install -g solc&lt;/p&gt;
&lt;h4&gt;（4）编译Solidity源代码文件&lt;/h4&gt;
&lt;p&gt;在当前目录创建一个Factorial.sol文件，然后将例3.2中的代码复制到Factorial.sol文件中。接下来会使用上一步安装的Solidity编译器对Factorial.sol文件进行编译。要注意，尽管安装的是solc，但编译器命令行工具是solcjs。这个工具可以将Solidity源代码文件编译成多种目标文件，对于本例来说，只需要abi文件即可，该文件是智能合约的接口文件。也就是说，使用Web3.js调用智能合约，需要使用abi文件才能调用智能合约中函数。&lt;/p&gt;
&lt;p&gt;使用下面的命令可以将Factorial.sol文件编译生成abi文件。其中--abi是命令行参数，表示生成的目标文件类型是abi。&lt;/p&gt;
&lt;p&gt;solcjs --abi Factorial.sol&lt;/p&gt;
&lt;p&gt;执行完上面的命令后，会在当前目录生成一个Factorial_sol_Factorial.abi文件，该文件就是Factorial.sol对应的abi文件。&lt;/p&gt;
&lt;h4&gt;（5）安装Web3.js&lt;/h4&gt;
&lt;p&gt;在使用Web3.js之前必须安装Web3.js，Web3.js是Node.js的一个模块，所以需要使用下面的命令安装。&lt;/p&gt;
&lt;p&gt;npm install web3&lt;/p&gt;
&lt;p&gt;使用上面的命令会安装web3的最新版，如果读者使用web3最新版不太习惯，可以使用下面的命令安装指定版本。&lt;/p&gt;
&lt;p&gt;npm install web3@0.20.6&lt;/p&gt;
&lt;h4&gt;（6）用Web3.js连接testrpc节点&lt;/h4&gt;
&lt;p&gt;现在执行node命令进入Node.js的REPL环境（命令行交互环境），然后在Node的REPL环境执行下面的命令。要注意，在执行这些命令之前，要先启动testrpc节点，并且利用Remix环境将例3.2中的智能合约部署到testrpc节点上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var Web3 = &lt;span class=&quot;hljs-built_in&quot;&gt;require(&lt;span class=&quot;hljs-string&quot;&gt;&quot;web3&quot;);
&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var web3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Web3(&lt;span class=&quot;hljs-keyword&quot;&gt;new Web3.providers.HttpProvider(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://localhost:8545&quot;)); 
&lt;span class=&quot;hljs-literal&quot;&gt;undefined
&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var eth = web3.eth
&lt;span class=&quot;hljs-literal&quot;&gt;undefined
&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var abi = &lt;span class=&quot;hljs-built_in&quot;&gt;JSON.parse(fs.readFileSync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Factorial_sol_Factorial.abi&quot;).toString());
&lt;span class=&quot;hljs-literal&quot;&gt;undefined
&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var contract = eth.contract(abi);
&lt;span class=&quot;hljs-literal&quot;&gt;undefined
&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var instance = contract.at(&lt;span class=&quot;hljs-string&quot;&gt;'0x371f45db1a077bbcbeb50d2a21bc85e4e18c1f1f')
&lt;span class=&quot;hljs-literal&quot;&gt;undefined
&amp;gt; instance.factorial.call(&lt;span class=&quot;hljs-number&quot;&gt;3)
{ [&lt;span class=&quot;hljs-built_in&quot;&gt;String: &lt;span class=&quot;hljs-string&quot;&gt;'6'] s: &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-attr&quot;&gt;e: &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-attr&quot;&gt;c: [ &lt;span class=&quot;hljs-number&quot;&gt;6 ] }
&amp;gt; instance.factorial(&lt;span class=&quot;hljs-number&quot;&gt;10, {&lt;span class=&quot;hljs-attr&quot;&gt;from:eth.accounts[&lt;span class=&quot;hljs-number&quot;&gt;0]})
&lt;span class=&quot;hljs-string&quot;&gt;'0xbb291fec53c4c5aefc87e2d7e8475c4abd4c54d03ef06e857665a10db0c1a3ff'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的内容中“&amp;gt;”表示命令提示符，后面是输入的代码，下面是输出值，undefined是Node输出的，表示当前语句什么也没有输出（定义变量的JavaScript语句不会输出任何东西）。从这几行代码可以了解通过Web3.js连接testrpc节点的核心步骤（与连接以太坊节点的步骤相同）如下。&lt;/p&gt;
&lt;h4&gt;（1）导入web3模块，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var Web3 = &lt;span class=&quot;hljs-built_in&quot;&gt;require(&lt;span class=&quot;hljs-string&quot;&gt;&quot;web3&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（2）创建Web3类的实例，并通过该类的构造方法参数指定testrpc节点的Url（IP和端口号），代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var web3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Web3(&lt;span class=&quot;hljs-keyword&quot;&gt;new Web3.providers.HttpProvider(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://localhost:8545&quot;));&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（3）读取Factorial_sol_Factorial.abi文件的内容，并将文件的内容转换为JSON对象，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var abi = &lt;span class=&quot;hljs-built_in&quot;&gt;JSON.parse(fs.readFileSync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Factorial_sol_Factorial.abi&quot;).toString());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（4）使用abi创建智能合约对象，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var contract = eth.contract(abi);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（5）将智能合约与testrpc中部署的智能合约绑定，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var instance = contract.at(&lt;span class=&quot;hljs-string&quot;&gt;'0x371f45db1a077bbcbeb50d2a21bc85e4e18c1f1f')
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中at方法的参数值就是图3-12所示的factorial方法上方的智能合约地址，也是以太坊中唯一能定位特定智能合约的标识。点击地址右侧的按钮可以将该地址复制到剪贴板上。&lt;/p&gt;
&lt;h4&gt;（6）本地调用智能合约中的factorial函数，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;instance&lt;span class=&quot;hljs-selector-class&quot;&gt;.factorial&lt;span class=&quot;hljs-selector-class&quot;&gt;.call(3)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本地调用智能合约，不会对以太坊网络造成任何影响。本地调用智能合约中的函数会直接输出函数的返回值，如果函数返回的是数值类型，会以BigNumber类型返回，这是一个JavaScript扩展，允许JavaScript操作任何的数值，BigNumber类型会在本书后面的章节详细讲解。&lt;/p&gt;
&lt;p&gt;执行上面的代码，会输出如下内容，很明显，3的阶乘是6。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[String: '6'] &lt;span class=&quot;hljs-selector-tag&quot;&gt;s: 1, &lt;span class=&quot;hljs-selector-tag&quot;&gt;e: 0, &lt;span class=&quot;hljs-selector-tag&quot;&gt;c: &lt;span class=&quot;hljs-selector-attr&quot;&gt;[ 6 ] }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;（7）在以太坊网络上调用智能合约，代码如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;instance&lt;span class=&quot;hljs-selector-class&quot;&gt;.factorial(10, {&lt;span class=&quot;hljs-attribute&quot;&gt;from:eth.accounts[&lt;span class=&quot;hljs-number&quot;&gt;0]})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以太坊网络上调用智能合约的函数不会在客户端直接得到函数的返回值，而会得到一个如下的交易地址。&lt;/p&gt;
&lt;p&gt;0xbb291fec53c4c5aefc87e2d7e8475c4abd4c54d03ef06e857665a10db0c1a3ff&lt;/p&gt;
&lt;p&gt;因为任何在以太坊网络上进行的操作都被视作一次交易，既然有交易，就需要有交易地址，可以通过相应的API根据交易地址查询交易情况。在以太坊网络中有很多类型的地址，如矿工地址、智能合约地址、交易地址等。每一类地址都由若干位十六进制数组成，但不同类型地址的位数可能不同。&lt;/p&gt;
&lt;p&gt;在真正的以太坊网络中，任何交易都需要矿工挖矿进行处理，同时每一笔交易会给与完成工作的矿工一定的奖励，也就是矿工的挖矿所得。不过在testrpc节点中由于是模拟以太坊网络和挖矿，所以不需要挖矿，直接会执行以太坊网络上的操作，因此，如果客户端连接的是testrpc节点，发起交易后，会立刻执行。另外，在以太坊网络上调用智能合约，需要指定是谁（一个表示用户的地址）发起的交易，因为在实际的以太坊网络中，要从这个地址扣除相应的以太币给矿工。本例使用eth.accounts[0]指定的地址。其中eth.accounts可以获取testrpc节点启动时生成的10个测试账户的地址，eth.accounts[0]就是第一个测试账户的地址。&lt;/p&gt;
&lt;p&gt;从本节的案例来看，客户端访问以太坊网络的步骤就是连接以太坊节点和发起交易两步，当然，以太坊网络要处理交易，就需要矿工挖矿（争夺处理交易的权利，同时获得回报）了。&lt;br/&gt;3.2.4 Intellij IDEA Solidity插件&lt;br/&gt;不管是Remix，还是Windows记事本，或是其他的文本编辑器，都不会用于开发复杂的智能合约，一是界面并不友好，二是也没有必要的智能提示功能，而且如果智能合约的代码量很大，可能会造成Remix死掉。所以前面介绍的工具只是为了测试智能合约的，并不是用来开发实际的智能合约项目的。如果要开发大型的智能合约项目，通常会使用本地的IDE，如Intellij IDEA。这款IDE最初是为开发Java项目推出的，不过由于Intellij IDEA支持第三方插件，所以从理论上，Intellij IDEA可以支持任何的编程语言。&lt;/p&gt;
&lt;p&gt;可能很多读者对Intellij IDEA并不熟悉，实际上，这款IDE就是大名鼎鼎的JetBrains公司推出的，如果不了解JetBrains以及它的产品，那么对Android和Google推出的Android开发工具Android Studio一定不陌生，Android Studio就是在Intellij IDEA社区版的基础上开发的。而且JetBrains公司还开发出了大名鼎鼎的Kotlin语言，现在已经成为开发Android App的官方推荐编程语言。&lt;/p&gt;
&lt;p&gt;读者可以到下面的页面下载Intellij IDEA的免费版本（社区版）。&lt;br/&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/download&quot; rel=&quot;nofollow&quot;&gt;https://www.jetbrains.com/idea/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Solidity语言同样提供了Intellij IDEA插件，建议使用在线安装方式。如果是Mac OSX版本的Intellij IDEA，单击左上角的IntelliJ IDEA菜单的Preferences菜单项，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-c48871fe98cb8e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是Windows版的Intellij IDEA，需要单击File菜单的Settings菜单项。单击该菜单项后，会弹出偏好（设置）窗口，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-68e70f5bc180477d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Preferences窗口中间的列表列出了Intellij IDEA已经安装的所有插件。单击窗口下方的Browse repositories按钮，会弹出Browse Repositories窗口，在窗口左上角的文本框中输入Solidity，会在线搜索相关的插件，如下图所示，如果找到，会在右侧显示当前选中插件的详细信息，如果没有安装该插件，会在右侧显示install按钮，单击install按钮即可安装插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-a6fc085abc5cd88e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完插件后，在Intellij IDEA中创建一个Java或其他工程（Solidity插件并没有提供Solidity工程），然后在工程右键菜单中单击new菜单项，会显示如下图所示的子菜单。在子菜单上会找到一个Smart contract菜单项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-086d1fa96502885d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击Smart contract菜单项，会显示如下图所示的New Solidity File窗口，从Kind列表框可以选择Solidity文件类型（Smart contract或Solidity library），本例选择Smart contract。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-8d5be3b27f5d4b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Name文本框中输入Solidity文件名后，单击OK按钮创建Solidity文件。然后在Intellij IDEA左侧的工程树中双击刚才创建的Solidity文件，会在右侧显示代码编辑区域，并输入如下图所示的Solidity代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-05ac7ce49e836370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管可以在Intellij IDEA中编写Solidity代码，也支持代码高亮显示和智能提示，但编译Solidity源代码文件仍然需要切换到终端，使用solcjs命令编译，很麻烦，所以在下一节会教大家如何将solcjs命令集成进Intellij IDEA，无需切换到终端就可以编译Solidity源代码文件。&lt;/p&gt;
&lt;h3&gt;5.将Solidity编译工具与Intellij IDEA集成&lt;/h3&gt;
&lt;p&gt;Intellij IDEA有一个扩展工具功能，可以将可执行程序与Intellij IDEA集成，也就是说，不用切换到终端，就可以执行这些程序。&lt;/p&gt;
&lt;p&gt;现在打开偏好窗口（Windows中是设置窗口），在左侧区域找到Tools &amp;gt; External Tools节点，单击该节点后，会在右侧显示当前集成的扩展工具列表，默认是空。然后单击该区域下方“+”按钮，会弹出一个Create Tool窗口，在该窗口需要填写如下4个字段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name：solidity&lt;/li&gt;
&lt;li&gt;Program：solcjs&lt;/li&gt;
&lt;li&gt;Parameters：--abi --bin $FileName$ -o $OutputPath$&lt;/li&gt;
&lt;li&gt;Working directory：$FileDir$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;填写后的效果如下图所示，最后单击OK按钮创建扩展工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-1e1bba1cc6f58897.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建扩展工具应该了解如下几点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name只是用于显示的扩展工具名字，可以任意指定，甚至可以与已经存在的扩展工具重名。&lt;/li&gt;
&lt;li&gt;Program指定的solcjs命令要在终端可以直接执行，否则会出现无法执行该命令的错误。所以在创建扩展工具之前，先要使用npm install -g solc命令安装solcjs。&lt;/li&gt;
&lt;li&gt;Parameters表示solcjs的命令行参数，其中--abi表示将Solidity源代码文件编译成接口文件（.abi文件），--bin表示将Solidity源代码文件编译成二进制文件（.bin文件），用于发布智能合约。尽管这两类文件并不是在任何时候都需要，但为了省事，干脆将它们一起生成吧。&lt;/li&gt;
&lt;li&gt;-o表示生成的目标文件（.abi和.bin文件）的路径。&lt;/li&gt;
&lt;li&gt;$FileName$、$OutputPath$和$FileDir$都是Intellij IDEA提供的环境变量，$FileName$表示当前选择的文件名，$OutputPath$表示文件的输出目录，$FileDir$表示当前选择文件所在的目录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是在Mac OS X下，$OutputPath$指向工程目录的out子目录，与工程相关的生成文件都放在这个目录中，目录结构与src目录相同。图3-20是out目录的结构，注意，读者机器上的目录结构可能有差异，但.abi和.bin文件都在out/production目录或其子目录中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-7fa57f75b6c0c1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果在Windows下，并不能执行solcjs文件，因为这个文件是在Mac OS X和Linux使用的，Windows下是solcjs.cmd，所以要将Program改成solcjs.cmd。而Windows版的Intellij IDEA并没有内置的$OutputPath$变量，所以可以将这个变量改成其他的值，如$FileDir$，这样以来，就会在.sol文件同一个目录生成.abi和.bin文件。所以Windows版的Intellij IDEA需要按下面的内容设置扩展工具。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name：solidity&lt;/li&gt;
&lt;li&gt;Program：solcjs.cmd&lt;/li&gt;
&lt;li&gt;Parameters：--abi --bin $FileName$ -o $FileDir$&lt;/li&gt;
&lt;li&gt;Working directory：$FileDir$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按前面的方式设置完扩展工具后，选中一个.sol文件（假设文件名是MyCalc.sol，里面的智能合约名是Calc），在Intellij IDEA的Tools &amp;gt; External Tools 菜单中出现了一个solidity菜单项，如图3-21所示，单击该菜单项，就会调用solcjs编译MyCalc.sol文件，并在相应的目录生成MyCalc_sol_Calc.abi和MyCalc_sol_Calc.bin文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-d50994cc91297f2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实在工程的右键菜单中也可以找到External Tools &amp;gt; solidity菜单项，如下图所示，单击该菜单项，效果是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-71024e4a922c8b05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 05:34:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>在上文中已经使用了Remix环境运行和测试了本书编写的第一个智能合约程序，不过编写和测试智能合约的测试方式很多，例如，在testrpc环境测试；在Intellij IDEA集成开发环境中用Solidi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nokiaguy/p/9815949.html</dc:identifier>
</item>
<item>
<title>SpringCloud 中使用 Ribbon（默认轮询规则 + 自定义规则） - 沛昕的博客</title>
<link>http://www.cnblogs.com/lpxdbk/p/9815324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lpxdbk/p/9815324.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;SpringCloud 中使用 Ribbon&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在前两章已经给大家讲解了Ribbon负载均衡的规则 以及 如何搭建Ribbon并调用服务，那么在这一章呢 将会给大家说一说如何在SpringCloud中去使用Ribbon。在搭建之前 我们需要做一些准备工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 搭建Eureka服务器：springCloud-ribbon-server（项目名称）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 服务提供者：springCloud-ribbon-police（项目名称）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 服务调用者：springCloud-ribbon-person（项目名称）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;搭建Eureka服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;配置 pom.xml，加入springCloud核心依赖、配置及eureka服务器依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.13.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;Dalston.SR5&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;配置 application.yml（&lt;span&gt;红色部分是必须要写的&lt;/span&gt;，黑色部分不写也能正常运行 但是建议写上，在这里笔者将官网的代码贴上）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8761&lt;/span&gt;&lt;span&gt;&lt;span&gt;
eureka:&lt;/span&gt;
  instance:
    hostname: localhost
  &lt;span&gt;client:
    registerWithEureka: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;false  禁止向eureka注册服务，因为它自己本身就是服务器
    fetchRegistry: false  这里不需要抓取注册表&lt;/span&gt;&lt;span&gt;
    serviceUrl:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建启动类：Application.java（将服务跑起来放着，稍后会用到）配置 pom.xml，加入springCloud核心依赖、配置及eureka服务依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;span&gt;@EnableEurekaServer
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(Application.&lt;span&gt;class&lt;/span&gt;).web(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).run(args);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019114325392-971146800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务提供者 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;配置 pom.xml，加入springCloud核心依赖、配置及eureka客户端依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.13.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;Dalston.SR5&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;配置 application.yml（需要使用&lt;span&gt;defaultZone&lt;/span&gt;向服务器注册服务，否则就算该服务运行起来了，但没有向服务器注册服务，也是使用不了的）（&lt;span&gt;name &lt;span&gt;这个名称是显示在服务列表中的名称，养成好习惯，一定要起有意义的名称&lt;/span&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    &lt;span&gt;name&lt;/span&gt;: springCloud&lt;/span&gt;-ribbon-&lt;span&gt;police
eureka:
  client:
    serviceUrl:
      &lt;span&gt;defaultZone&lt;/span&gt;: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为该服务是提供服务的，所以下面会建一个实体类及Controller用来对外提供服务，创建实体类：Police.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Police {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String id;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 警察编号，用来保存用户输入的参数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String url;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理请求的服务器url&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String message;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提示信息&lt;/span&gt;
    
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUrl() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; url;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUrl(String url) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.url =&lt;span&gt; url;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMessage() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMessage(String message) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建对外提供服务的Controller：PoliceController.java（@RestController注解中包含了@Controller+@ResponseBody）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PoliceController {

    @RequestMapping(value&lt;/span&gt;=&quot;/getPolice&quot;, method=RequestMethod.GET, produces=&lt;span&gt;MediaType.APPLICATION_JSON_VALUE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Police getPolice(HttpServletRequest request){
        Police p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Police();
        p.setUrl(request.getRequestURL().toString());
        p.setMessage(&lt;/span&gt;&quot;警察派出成功&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }
    
    @RequestMapping(value&lt;/span&gt;=&quot;/getPoliceById/{id}&quot;, method=RequestMethod.GET, produces=&lt;span&gt;MediaType.APPLICATION_JSON_VALUE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Police getPolice(HttpServletRequest request, @PathVariable(&quot;id&quot;&lt;span&gt;) String id){
        Police p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Police();
        p.setId(id);
        p.setUrl(request.getRequestURL().toString());
        p.setMessage(&lt;/span&gt;&quot;指定警察派出成功&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为我们要测试负载均衡，所以这里的服务提供者需要开启多个服务实例，下面我们用读取手动输入端口号的方法，启动多个服务实例，笔者在这里启动了两个服务实例：8080、8081&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;span&gt;@EnableEurekaClient
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PoliceApplication {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Scanner scan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String port &lt;/span&gt;=&lt;span&gt; scan.nextLine();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(PoliceApplication.&lt;span&gt;class&lt;/span&gt;).properties(&quot;server.port=&quot;+&lt;span&gt;port).run(args);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图，出现了两个服务实例，分别是：8080、8081，红色的信息咱们先不管他，如果实在有看着不顺眼的小伙伴，可以配置心跳（简单的来说，就是配置服务器每隔多久检查一次服务实例状态，如果某个服务因为某些原因停掉 不能用了，那么就将该服务 从服务列表中移除掉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019114630403-1222864696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务调用者&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 配置 pom.xml，加入springCloud核心依赖、配置及eureka客户端依赖、Ribbon依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.13.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;Dalston.SR5&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 配置 application.yml（这里也将该服务注册到服务器，一定要进行注册）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;9090&lt;span&gt;
spring:
  application:
    name: springCloud&lt;/span&gt;-ribbon-&lt;span&gt;person
eureka:
  client:
    serviceUrl:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 创建调用服务Controller：PersonController.java&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RestTemplate 是由 Spring Web 模块提供的工具类，与 SpringCloud 无关，是独立存在的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因 SpringCloud 对 RestTemplate 进行了一定的扩展，所以 RestTemplate 具备了负载均衡的功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PersonController {

    &lt;span&gt;@Bean
    @LoadBalanced
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public RestTemplate getRestTemplate(){
        return new&lt;/span&gt;&lt;span&gt;&lt;span&gt; RestTemplate();
    }&lt;/span&gt;
    
    @RequestMapping(&lt;/span&gt;&quot;/getPolice&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPolice(){
        RestTemplate rt &lt;/span&gt;=&lt;span&gt; getRestTemplate();
        String result &lt;/span&gt;= rt.getForObject(&quot;http://springCloud-ribbon-police/getPolice&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    @RequestMapping(&lt;/span&gt;&quot;/getPoliceById/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getPoliceById(@PathVariable(&quot;id&quot;&lt;span&gt;) String id){
        RestTemplate rt &lt;/span&gt;=&lt;span&gt; getRestTemplate();
        String result &lt;/span&gt;= rt.getForObject(&quot;http://springCloud-ribbon-police/getPoliceById/&quot;+id, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建启动类：PersonApplication.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableEurekaClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PersonApplication {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(PersonApplication.&lt;span&gt;class&lt;/span&gt;).web(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).run(args);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019115824680-1853320114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 到目前为止，eureka服务器、服务提供者、服务调用者（负载均衡）就已经全写好了，下面我们访问接口，来试一下 服务到底能不能调通&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我们分别调用：&lt;strong&gt;http://localhost:9090/getPolice&lt;/strong&gt;、&lt;strong&gt;http://localhost:9090/getPoliceById/100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019120045891-1583975982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019120158295-1154653566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是默认的轮询规则，8080、8081轮询去访问服务，，，那么下面说一下如何自定义规则，在上一章的 “&lt;strong&gt;Ribbon 负载均衡机制（自定义负载均衡规则）&lt;/strong&gt;” 中有贴过自定义负载均衡的自定义规则类，在这里就不再重复的贴了，大家可以到文章中去看一下。&lt;/p&gt;
&lt;p&gt;那么下面就直接说，既然Ribbon和SpringCloud一起使用了，在这里给大家说一下如何使用&lt;span&gt;&lt;strong&gt;配置类&lt;/strong&gt;&lt;/span&gt;或者&lt;strong&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/strong&gt;进行配置。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面直接用一个配置类&lt;/span&gt;，直接搞定。这样每当请求过来的时候，那么该请求就会走咱们配置的自定义规则类了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：建议写服务名称     configuration：配置类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http://springCloud-ribbon-police/getPolice&lt;/span&gt;&lt;span&gt; 调用&quot;springCloud-ribbon-police&quot;这个服务ID的时候，将会启用下面的配置&lt;/span&gt;
@RibbonClient(name=&quot;springCloud-ribbon-police&quot;, configuration=LbConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LbConfig {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule getRule(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRule();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019150024887-1890696913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 再说一下，如何使用配置文件进行配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;格式是：服务ID &amp;gt;&amp;gt;&amp;gt; 命名空间 &amp;gt;&amp;gt;&amp;gt; 配置属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
springCloud-ribbon-&lt;span&gt;police:
  ribbon:
    NFLoadBalancerRuleClassName: com.lpx.pro.utils.MyRule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489309/201810/1489309-20181019151236048-2112862573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;以上两种配置方法都是有效的，，由此可以看出，我们配置的自定义规则起作用了。那么以上 就是本章讲解的全部内容，通过这个简单的例子，希望可以帮到大家，感谢大家的支持！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 19 Oct 2018 04:28:00 +0000</pubDate>
<dc:creator>沛昕的博客</dc:creator>
<og:description>SpringCloud 中使用 Ribbon 在前两章已经给大家讲解了Ribbon负载均衡的规则 以及 如何搭建Ribbon并调用服务，那么在这一章呢 将会给大家说一说如何在SpringCloud中去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lpxdbk/p/9815324.html</dc:identifier>
</item>
<item>
<title>Android Studio 一个完整的APP实例（附源码和数据库） - AnneHan</title>
<link>http://www.cnblogs.com/AnneHan/p/9815645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AnneHan/p/9815645.html</guid>
<description>&lt;p&gt;这是我独立做的第一个APP，是一个记账本APP。&lt;/p&gt;
&lt;p&gt;This is the first APP, I've ever done on my own. It's a accountbook APP.&lt;/p&gt;


&lt;p&gt;          &lt;span&gt;欢迎satr or fork&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;APP中所涉及到的&lt;span&gt;图标请勿商用&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;（备注：在把图片制作成gif时，图片的质量受损，所以最终呈现出来的gif图片，背景变得有些模糊）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785246/201810/785246-20181019114206602-412214180.gif&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;


&lt;p&gt;IDE：Android Studio&lt;/p&gt;
&lt;p&gt;Database：SQLite&lt;/p&gt;


&lt;p&gt;该APP共包含6个功能，分别是：&lt;/p&gt;
&lt;p&gt;1、登录&amp;amp;注册功能：&lt;br/&gt;　进入该界面，默认是让用户进行登录操作；&lt;br/&gt;　若用户之前没有注册过，则会提示让用户进行注册；&lt;br/&gt;　若用户忘记登录密码，也有重置密码的功能。&lt;/p&gt;
&lt;p&gt;2、收入&amp;amp;支出功能：&lt;br/&gt;　该功能分为两个页签：明细、类别报表&lt;br/&gt;　这两个页签内容，都根据月份来统计呈现（开发中，目前是呈现所有收支明细）&lt;br/&gt;　并根据月份，显示当月的收入与支出（开发中，目前是呈现固定值）&lt;/p&gt;
&lt;p&gt;　明细页签：&lt;br/&gt;　　在该页签最下方会显示【记一笔】按钮，点击该按钮，会提示让用户选择记录的类型，是收入 or 支出&lt;br/&gt;　　然后会进入到记录收支明细的界面&lt;br/&gt;　　根据用户的选择类型，来呈现不同的内容&lt;br/&gt;　　当用户录入好收支明细，点击保存，会返回到明细页签，此时会刷新明细页签的内容（刷新功能开发中）&lt;/p&gt;
&lt;p&gt;　类别报表页签：&lt;br/&gt;　　该页签会根据用户的收支明细的类别来进行统计，呈现方式是圆形饼图（具体的统计逻辑开发中）&lt;/p&gt;
&lt;p&gt;3、统计功能：&lt;br/&gt;　该功能分为两个页签：明细、类别报表（该功能和收入&amp;amp;支出功能类似）&lt;br/&gt;　这两个页签内容，都根据月份来统计呈现（开发中，目前是呈现所有收支明细）&lt;br/&gt;　并根据月份，显示当月的结余，以及相比上月支出（开发中，目前是呈现固定值）&lt;/p&gt;
&lt;p&gt;4、特殊设置功能：该功能正在设计中。&lt;/p&gt;
&lt;p&gt;5、心愿墙功能：该功能正在设计中。&lt;/p&gt;
&lt;p&gt;6、关于我们功能：该功能主要是对APP进行简要介绍。&lt;/p&gt;


&lt;p&gt;目前APP共涉及到三个表，分别是：用户信息表、配置表、收支明细表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(SQLiteDatabase db){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;user table&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     db.execSQL(&quot;create table if not exists user_tb(_id integer primary key autoincrement,&quot; +
&lt;span&gt; 4&lt;/span&gt;             &quot;userID text not null,&quot; +
&lt;span&gt; 5&lt;/span&gt;             &quot;pwd text not null)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configuration table&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     db.execSQL(&quot;create table if not exists refCode_tb(_id integer primary key autoincrement,&quot; +
&lt;span&gt; 9&lt;/span&gt;             &quot;CodeType text not null,&quot; +
&lt;span&gt;10&lt;/span&gt;             &quot;CodeID text not null,&quot; +
&lt;span&gt;11&lt;/span&gt;             &quot;CodeName text null)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;costDetail_tb&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     db.execSQL(&quot;create table if not exists basicCode_tb(_id integer primary key autoincrement,&quot; +
&lt;span&gt;15&lt;/span&gt;             &quot;userID text not null,&quot; +
&lt;span&gt;16&lt;/span&gt;             &quot;Type integer not null,&quot; +
&lt;span&gt;17&lt;/span&gt;             &quot;incomeWay text not null,&quot; +
&lt;span&gt;18&lt;/span&gt;             &quot;incomeBy text not null,&quot; +
&lt;span&gt;19&lt;/span&gt;             &quot;category text not null,&quot; +
&lt;span&gt;20&lt;/span&gt;             &quot;item text not null,&quot; +
&lt;span&gt;21&lt;/span&gt;             &quot;cost money not null,&quot; +
&lt;span&gt;22&lt;/span&gt;             &quot;note text not null,&quot; +
&lt;span&gt;23&lt;/span&gt;             &quot;makeDate text not null)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下博文是根据APP中涉及到的功能进行整理的，如下：&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;首页的旋转菜单参考该博文：&lt;a href=&quot;https://blog.csdn.net/lmj623565791/article/details/43131133&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前的版本为V1.0&lt;/p&gt;
&lt;p&gt;APP还有很多功能需要继续完善，希望有兴趣的小伙伴可以一起参与进来，和我一起来开发完善。&lt;/p&gt;


&lt;p&gt;不论遇到什么困难，都不应该成为我们放弃的理由&lt;/p&gt;

</description>
<pubDate>Fri, 19 Oct 2018 03:53:00 +0000</pubDate>
<dc:creator>AnneHan</dc:creator>
<og:description>前言： 这是我独立做的第一个APP，是一个记账本APP。 This is the first APP, I've ever done on my own. It's a account</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AnneHan/p/9815645.html</dc:identifier>
</item>
<item>
<title>初尝微信小程序开发与实践 - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/9795306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/9795306.html</guid>
<description>&lt;p&gt; 以后端程序员的视角来聊一聊小程序。&lt;/p&gt;
&lt;p&gt;小程序的火热相信不用我多说了，年初的时候老婆去浦东某达面试，甚至都被问有没有小程序测试经验。俨然小程序成为了互联网公司自PC，WAP，安卓，IOS之后又一不可或缺的入口。正好这段时间公司也在做一款小程序，于是顺便也学习了一把。当然因为我是一个后端猿，自然是以后端的视角来谈谈，肯定和前端的同学还是比不上的。&lt;/p&gt;
&lt;p&gt;学习小程序，我认为对于后端同学还是比较有优势的，因为后端同学对于HTML，CSS以及JS这些前端基本知识还是有所涉猎的，而前端的同学对于后端可能就没那么了解了。接下来，以我的实践经历来简单聊一聊小程序，算是总结也算是个分享。&lt;/p&gt;

&lt;p&gt;“触手可及”，“用完即走”。感觉这两个词把小程序的特点描述的真的是淋漓尽致。以微信的用户量，小程序免去了用户还需安装APP的繁琐。而且用完之后，无需刻意退出，直接离开即可，当下次某个时间点在想起来，重新翻出来就行了。这对很多行业来说可能是颠覆性的。以我个人的观点来看，小程序适合做一些业务简单，性能要求不高，使用频率相对较低的应用。比如像垂直电商行业就是典型的受益者，自媒体电商，生鲜电商，如果让用户去下载一个这样的APP成本是很大的，而使用小程序确悄然的避免了拉新客的难题。又比如我自己，如果我把自己的博客做成了一个APP，相信几乎不会有同学去下载，而使用小程序却偶尔还会有些同学会点进来看看的，哈哈。&lt;/p&gt;

&lt;p&gt;首先开发小程序，需要一个专门的工具【微信开发者工具】，这个大家可以直接到微信公众平台下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181015223518503-2126664831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们首先新建个快速启动模板看一下，如果你有注册账号有appid的可以填入，没有的话也没关系。点击图中小程序即可使用测试账号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181015223809454-1696458729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，进入后即可看到这些文件。&lt;/p&gt;
&lt;p&gt;可以说一个简单的小程序只有这些了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;app.js 主要是全局公共的js方法声明及调用所在的文件&lt;/li&gt;
&lt;li&gt;app.json 是小程序全局的配置文件，所以有的页面都在要此注册，不然不允许访问&lt;/li&gt;
&lt;li&gt;app.wxss 是小程序全局的css文件&lt;/li&gt;
&lt;li&gt;pages下是对应着所有页面，每个页面，可以添加四种类型的文件，.json，.wxss，.wxml，.js&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外在说下这四种类型的文件，小程序pages下面基本上每个文件夹相当于一个页面，每个文件夹下面有四种命名相同但类型不同的文件，这四种构成了页面的全部。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.json&lt;/code&gt; 后缀的 &lt;code&gt;JSON&lt;/code&gt; 配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.wxml&lt;/code&gt; 后缀的 &lt;code&gt;WXML&lt;/code&gt; 模板文件，类似web开发的html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.wxss&lt;/code&gt; 后缀的 &lt;code&gt;WXSS&lt;/code&gt; 样式文件，类似web开发的css&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.js&lt;/code&gt; 后缀的 &lt;code&gt;JS&lt;/code&gt; 脚本逻辑文件，它就是一个js啊，不过小程序的js不能操作dom，是基于数据绑定的哦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们在看下js文件的构成，注释很清晰：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Page({

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 页面的初始数据
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  data: {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面加载
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onLoad: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (options) {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面初次渲染完成
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onReady: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面显示
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onShow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面隐藏
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onHide: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 生命周期函数--监听页面卸载
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onUnload: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 页面相关事件处理函数--监听用户下拉动作
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onPullDownRefresh: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 页面上拉触底事件的处理函数
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onReachBottom: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 用户点击右上角分享
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onShareAppMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解了这些基本上小程序开发就没问题了，其他就剩翻文档了。这里我建议把文档当成字典来读，读完简易教程和框架后，其他需要什么来查什么就行了，没必要像教科书一样一字不落的全看完。&lt;/p&gt;
&lt;p&gt;因为微信开发者工具还比较初始，之前每建一个页面，我都是先建一个文件夹，然后在分别把四个文件建好。这里我介绍个小技巧，大家可以&lt;strong&gt;&lt;span&gt;首先将要新建的页面注册进app.json，这时候工具会自动把文件夹和四种文件给你建好&lt;/span&gt;&lt;/strong&gt;。说实话很奇怪，这种方法在官方文档上我并没有看到，不知道是我眼花还是官方真的没有写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再说下页面的注册，当我们在app.json文件中注册的时候，【pages/index/index】会将该页面下index.xx的四种文件加载进来，而不必一个个写了。还有就是文件夹名字和文件名是可以不同的，比如【pages/index/launch】会将index文件夹下所有的launch文件加载。但是建议还是一样把，不然看着挺别扭的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后在多说句，小程序的域名白名单问题&lt;/span&gt;&lt;/strong&gt;，我发现很多同学不知道，包括身边的同事，一直还在用内网穿透来开发。&lt;/p&gt;
&lt;p&gt;首先小程序对应用请求的域名是有限制的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求的域名必须在后台配置，非配置域名无法请求成功。&lt;/li&gt;
&lt;li&gt;域名协议必须是https的，如果是http请求也是会失败的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，这是对线上版本来说。如果是我们本地开发，小程序提供了一个很人性化的功能。可以忽略这个限制，甚至你可以直接请求本地的&lt;span&gt;IP地址+端口号&lt;/span&gt;，而不必使用繁琐的内网穿透的方式了。&lt;/p&gt;
&lt;p&gt;具体操作方式就是在微信开发者工具中，点击【设置】-【项目设置】-【勾选】不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书 即可，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181017094047216-1142663237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就结合我的实践小程序来简单聊一聊，更多的资料大家可以&lt;strong&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/&quot; target=&quot;_blank&quot;&gt;查阅文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;恰巧前段时间做了个练手的yyblog的开源项目，这次就拿这个项目做个简单的小程序客户端了。还是惯例，大家先看下效果图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181015231127148-524223225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181015231147005-611744644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单纯的html,css,js实现，没有应用任何前端框架，还是比较适合参考学习的。ppps：反正我是不会说因为我不会才不用的 呜呜~~~流下了没有技术的泪水┭┮﹏┭┮。&lt;/p&gt;
&lt;p&gt;微信小程序总的来说虽然已经上线那么久，但和传统意义上的开发语言上比，还不是那么稳定的，官方也在不断的调整中。&lt;/p&gt;
&lt;p&gt;相信很多同学有遇到过这样的场景，当你第一次进入一个小程序的时候，会弹出来一个用户信息授权的弹窗。刚开始我写的时候也是这样处理的，但是后来在上传代码的时候看到，微信在9月12号的时候发了一个公告。&lt;/p&gt;
&lt;p&gt;主要是取消了分享监听接口的回调，将获取用户信息的getUserInfo接口改为只有用户点击了相关授权组件才能触发，还有就是openSetting接口也改为了点击才能触发。所以做微信小程序开发还是要做关注下官方的动态，以免做好的功能确不能正常使用的尴尬。&lt;/p&gt;
&lt;h2&gt;全局配置&lt;/h2&gt;
&lt;p&gt;前面有说app.xx的相关文件，是小程序的全局配置文件，这里在单独说下app.js这个文件。当我们某些参数是全局需要的时候，我们就可以将相关的参数写在这个文件里面，比如我们请求的基础url，亦或是用户信息，用户ID这种请求必须携带的参数。同时我们可以将版本校验的代码写在这里，这里在多说一句，微信是支持版本校验的，当有新的版本代码的时候，可以做用户更新提示，这里不再需要我们后台校验，还是比较方便的。相关的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;App({

  onLaunch() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkUpdate();
  },

  globalData: {
    userInfo: {},
    apiBase: &lt;/span&gt;&quot;https://www.laoyeye.net&quot;&lt;span&gt;,
    userId: &lt;/span&gt;&quot;&quot;&lt;span&gt;
  },

  checkUpdate() {
    const updateManager &lt;/span&gt;=&lt;span&gt; wx.getUpdateManager();
    updateManager.onCheckForUpdate(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求完新版本信息的回调&lt;/span&gt;
&lt;span&gt;      console.log(res.hasUpdate)
    })
    updateManager.onUpdateReady(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      wx.showModal({
        title: &lt;/span&gt;'更新提示'&lt;span&gt;,
        content: &lt;/span&gt;'新版本已经准备好，是否重启应用？'&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.confirm) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的版本已经下载好，调用 applyUpdate 应用新版本并重启&lt;/span&gt;
&lt;span&gt;            updateManager.applyUpdate()
          }
        }
      })
    })

    updateManager.onUpdateFailed(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新版本下载失败&lt;/span&gt;
      console.log('更新失败！'&lt;span&gt;)
    })
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 启动页&lt;/h2&gt;
&lt;p&gt;用户在刚开始进入小程序的时候，首先会展现一个启动页。起初我也不是这样设计的，基本上是用户进入后直接进入主页，弹出用户授权就行了，但是因为9.12的调整，也不得不作出了修改。让用户首先进入启动页授权，授权后跳转到主页。已授权的用户就把授权按钮隐藏，然后在等待1.5s后跳转到主页。这个过程中我除了做了获取用户授权的操作之外，还请求后台服务器在后台创建了用户数据，最终将userId返回到小程序。以后用户做评论，点赞，收藏等操作，均会携带userId，方便区分具体的用户。&lt;/p&gt;
&lt;p&gt;这个页面其实有两个比较重要的知识要点，这里特别强调下。&lt;/p&gt;
&lt;p&gt;首先，我们需要获取每个用户对于当前应用的openId，以便下次用户访问时，避免再次授权的重复操作。&lt;/p&gt;
&lt;p&gt;调用wx.login()接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）等。但是需要注意的是，&lt;strong&gt;&lt;span&gt;用code去换取openid的操作，需要在服务端后台来做&lt;/span&gt;&lt;/strong&gt;，如果在小程序js上交换，在开发版本你会看到也是可以正常获取登录，但是到生产上就不行了，因为小程序的安全限制，&lt;span&gt;官方的域名是无法设置到白名单里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;login(auth) {
    let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用微信登录接口&lt;/span&gt;
&lt;span&gt;    wx.login({
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
        wx.request({
          url: app.globalData.apiBase &lt;/span&gt;+ '/api/wx/login?code=' + res.code + '&amp;amp;nickname=' + app.globalData.userInfo.nickName +
            '&amp;amp;avatar=' +&lt;span&gt; app.globalData.userInfo.avatarUrl,
          header: {
            &lt;/span&gt;'content-type': 'application/json'&lt;span&gt;
          },
          success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (res.data.code == 200&lt;span&gt;) {
              app.globalData.userId &lt;/span&gt;=&lt;span&gt; res.data.data;
              console.log(&lt;/span&gt;'获取用户信息=' +&lt;span&gt; res.data.data);
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (auth == 'auth'&lt;span&gt;) {
                that.direct();
              } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                let timer &lt;/span&gt;= setTimeout(() =&amp;gt;&lt;span&gt; {
                  clearTimeout(timer)
                  that.direct()
                }, &lt;/span&gt;1500&lt;span&gt;)
              }
            }
          }
        })
      }
    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二，就是getUserInfo这个接口了，因为新规定的限制，以往如果用户没有授权，是会弹出授权的弹窗的。但是新规定之后如果你调用这个接口是在用户没有授权的情况下，那么会直接进入fail失败的回调的。所以你必须通过组件获取用户的授权，然后在用户点击的回调里在调用这个方法。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;show-btn&quot;&lt;/span&gt;&lt;span&gt; wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{userInfo.length == 0}}&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;primary&quot;&lt;/span&gt;&lt;span&gt; open-type&lt;/span&gt;&lt;span&gt;=&quot;getUserInfo&quot;&lt;/span&gt;&lt;span&gt; bindgetuserinfo&lt;/span&gt;&lt;span&gt;=&quot;onGetUserInfo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 授权登录 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;onGetUserInfo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    wx.getSetting({
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.authSetting['scope.userInfo'&lt;span&gt;]) {
          wx.getUserInfo({
            success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
              app.globalData.userInfo &lt;/span&gt;=&lt;span&gt; res.userInfo;
              that.login(&lt;/span&gt;'auth'&lt;span&gt;);
            },
            fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
              console.log(&lt;/span&gt;'系统错误'&lt;span&gt;)
            }
          })
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          wx.showToast({
            title: &lt;/span&gt;&quot;授权失败&quot;&lt;span&gt;,
            duration: &lt;/span&gt;1000&lt;span&gt;,
            icon: &lt;/span&gt;&quot;none&quot;&lt;span&gt;
          })
        }
      },
      fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'获取用户信息失败'&lt;span&gt;);
      }
    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后，这里在讲个小问题，我不知道是不是我个人的问题，我在做页面数据赋值的时候，会使用&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;this.data.requestUrl = requestUrl;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;或者
&lt;div&gt;
&lt;blockquote&gt;
&lt;p&gt;this.setData({&lt;/p&gt;
&lt;p&gt;postList: totalData&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;的方法。&lt;strong&gt;&lt;span&gt;如果是异步情况下，必须使用方法二，页面上才能取到数据。但是有些情况下非异步方法里使用方法一数据竟然取不出来，可是我在断点中明明看到数据是赋值成功的啊。而这个时候换成方法二却又成功了。真的是不明所以，大家尽量使用方法二吧。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;主页、技术页&lt;/h2&gt;
&lt;p&gt;把这两个页面一起讲，原因就是两个页面虽然展现形式上不同，但是技术特点上还是想同的。唯一的区别，可能就是后期我会把两个页面的数据接口做个调整，请求不同的数据了。&lt;/p&gt;
&lt;p&gt;这个页面主要是两个知识点，上拉加载更多和下拉刷新了。&lt;/p&gt;
&lt;p&gt;首先是上滑加载更多数据，这个其实是小程序官方提供的一个onReachBottom的方法，只要用户上滑到一定距离就会触发，这里我做了分页的处理。首次进入展示五条数据，当触发事件后请求第二页的数据。当然请求到第二页的数据并不能覆盖之前的数据哦，不然当用户在下滑时，刚才的数据没了，是不符合用户习惯的。&lt;/p&gt;
&lt;p&gt;上滑事件触发的距离也是可以通过onReachBottomDistance实现的，默认50px&lt;/p&gt;
&lt;p&gt;具体实现的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上滑加载更多数据&lt;/span&gt;
  onReachBottom: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nextUrl = &lt;span&gt;this&lt;/span&gt;.data.requestUrl +
      &quot;?page=&quot; + &lt;span&gt;this&lt;/span&gt;.data.page + &quot;&amp;amp;limit=5&quot;&lt;span&gt;;
    util.ajax(nextUrl, &lt;/span&gt;&quot;get&quot;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.processData)
    wx.showNavigationBarLoading()
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  processData: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (indexData) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; totalData =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要绑定新加载的数据，那么需要同旧有的数据合并在一起&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.isEmpty) {
      totalData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.postList.concat(indexData);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      totalData &lt;/span&gt;=&lt;span&gt; indexData;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.isEmpty = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      postList: totalData
    });

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.page += 1&lt;span&gt;;
    wx.hideNavigationBarLoading();
    wx.stopPullDownRefresh();
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是下拉刷新，下拉刷新默认是不开启的，需要我们在*.json配置中通过enablePullDownRefresh属性开启，默认为false。&lt;/p&gt;
&lt;p&gt;如果在app.json中设置为全局开启下拉刷新，在具体页面中即为当前页面开启。&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;navigationBarTitleText&quot;:&quot;小卖铺的老爷爷&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;enablePullDownRefresh&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  onPullDownRefresh: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refreshUrl = &lt;span&gt;this&lt;/span&gt;.data.requestUrl +
      &quot;?page=0&amp;amp;limit=5&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.techList =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.isEmpty = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.page = 1&lt;span&gt;;
    util.ajax(refreshUrl, &lt;/span&gt;&quot;get&quot;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.processData);
    wx.showNavigationBarLoading();
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这两种方法，在大家看官方文档全局配置的时候就会看到的。上面我也有说过学习小程序，官方文档的简易教程和框架还是必看的，其他的就没那么重要了。&lt;/p&gt;
&lt;h2&gt;详情页&lt;/h2&gt;
&lt;p&gt;详情页其实就一个要讲，富文本的解析。&lt;/p&gt;
&lt;p&gt;因为微信小程序并不支持html语言，所以需要转换为微信支持的wxml。&lt;/p&gt;
&lt;p&gt;总的来说微信对富文本的支持并不好，官方也没什么好用的富文本解析组件。这次我使用的是github上关注度最高的小程序富文本组件&lt;a href=&quot;https://github.com/icindy/wxParse&quot;&gt;wxParse&lt;/a&gt; ，虽说相对比较完善了，BUG还是不少的，而且作者好像也不维护了。但是目前实在没有找到其他什么好的替代方案，只能用这个了。如果大家还有其他组件，可以告诉我一下哈。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/icindy/wxParse&quot;&gt;wxParse&lt;/a&gt; 的使用，项目上已经讲的很清楚了，大家方便可以移步：https://github.com/icindy/wxParse 查看。&lt;/p&gt;
&lt;p&gt;我这边对wxParse做了一些小改动，主要解决部分手机报错无法解析的问题。原因是微信小程序不支持&lt;span class=&quot;pl-en&quot;&gt;console.&lt;span class=&quot;pl-c1&quot;&gt;dir()的写法，这个小程序官方也有在社区说明。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;pl-en&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;分享&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当你在页面的js文件中，定义了onShareAppMessage函数，这时候页面便拥有了分享功能，可以转发给微信好友。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 用户点击右上角分享
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onShareAppMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      title: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.postData.title,
      path: &lt;/span&gt;'/pages/post-detail/post-detail?id=' + &lt;span&gt;this&lt;/span&gt;.data.id + &quot;&amp;amp;title=&quot; + '小卖铺的老爷爷' + &quot;&amp;amp;share=1&quot;&lt;span&gt; 
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，是我的分享代码，设置了分享的标题，以及跳转的路径等。这里我对路径做了参数处理，以便我能区分出用户的来源。为什么要区分用户来源呢，因为小程序的分享页面进入后有个很奇怪的问题，没有返回主页的按钮。所以我这边单独做了区分，当用户来自分享时，显示一个悬浮的返回首页的图标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181017205114445-1581693615.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;666&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181017205138626-1121985103.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 回到首页(分享的时候显示) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{share}}&quot;&lt;/span&gt;&lt;span&gt; bindtap&lt;/span&gt;&lt;span&gt;='onBackHome' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='back-home' &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='/images/icon/home-page.png' &lt;/span&gt;&lt;span&gt;lazy-load&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * 回到首页(分享的时候)
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onBackHome: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    wx.reLaunch({
      url: &lt;/span&gt;'/pages/launch/launch?share=1&quot;'&lt;span&gt;
    })
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;我的&lt;/h2&gt;
&lt;p&gt;最后在说说我的这个页面，其实这个页面没啥重要的东西。只是静态页面的跳转。&lt;/p&gt;
&lt;p&gt;个人信息后期我会做成可绑定PC端账户的形式。&lt;/p&gt;
&lt;p&gt;我的收藏是已经实现过的，只是可能详情页还没有具体收藏的入口，后期我会加上。具体的效果图如下。&lt;/p&gt;
&lt;p&gt;还有一个就是打赏赞助这个页面，刚开始是准备做成小程序间关联，使用给赞api的接入方式。但是最近小程序官方对多个小程序间的跳转也要增加限制，就懒得弄了。&lt;/p&gt;
&lt;p&gt;直接做了个详情页的跳转，详情页面贴了张赞赏码完事。需要注意的是小程序页面并不支持直接长按扫描哦，需要点击下图片，在弹出的图片上在长按识别图中的二维码。&lt;/p&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181017201019758-2098741913.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;571&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181017201026622-1658010847.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;573&quot;/&gt;&lt;/p&gt;
&lt;p&gt;令我意外的是，虽然我的小程序上线没多久，但是竟然收到了两笔赞赏，真的是意外之喜。虽然不多，但是还是很感谢两位同学的支持。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ppps：写完文章后才想起来这个页面忘记说一个东西。小程序是可以使用阿里icon库的，具体使用方法大家网上看看吧。不说了，有兴趣的也可以看下我源码中的实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;最后的最后 &lt;/h2&gt;
&lt;p&gt;附上小程序微信预览地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075594/201810/1075594-20181018225239902-1015130412.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前有说这个项目是基于我前面的开源项目yyblog来写的，所以项目的PC端是已经完成的。所有请求的接口均已在yyblog实现。&lt;/p&gt;
&lt;p&gt;小程序的源码也已在yyblog中上传，具体地址在：&lt;a href=&quot;https://github.com/allanzhuo/yyblog/tree/master/yymini&quot; target=&quot;_blank&quot;&gt;https://github.com/allanzhuo/yyblog/tree/master/yymini&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果本文对您有帮助，或者项目能对您有所启发的话，希望帮忙给&lt;span&gt;&lt;a href=&quot;https://github.com/allanzhuo/yyblog&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;yyblog项目&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;点个&lt;span&gt;&lt;strong&gt;Star&lt;/strong&gt;&lt;/span&gt;吧，&lt;a href=&quot;https://github.com/allanzhuo/yyblog&quot; target=&quot;_blank&quot;&gt;https://github.com/allanzhuo/yyblog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;篇幅有限，写得有点长了，就到这里吧。总的来说技术难度不大，但是小坑还是比较多的。如果您有什么想法欢迎在评论中与我交流，码字不易，记得帮忙点个Star哦~&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 03:43:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<og:description>以后端程序员的视角来聊一聊小程序。 小程序的火热相信不用我多说了，年初的时候老婆去浦东某达面试，甚至都被问有没有小程序测试经验。俨然小程序成为了互联网公司自PC，WAP，安卓，IOS之后又一不可或缺的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/9795306.html</dc:identifier>
</item>
<item>
<title>React Native之code-push的热更新(ios android) - jackson影琪</title>
<link>http://www.cnblogs.com/jackson-zhangjiang/p/9805266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson-zhangjiang/p/9805266.html</guid>
<description>&lt;p&gt;React Native支持大家用React Native技术开发APP，并打包生成一个APP。在动态更新方面React Native只是提供了动态更新的基础，对将应用部署到哪里，如何进行动态更新并没有支持的那么完善。好在微软开发了CodePush，填补React Native 应用在动态更新方面的空白。CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。下面将向大家分享如何使用CodePush实时更新你的应用。&lt;/p&gt;
&lt;h2&gt;一,CodePush简介&lt;/h2&gt;
&lt;p&gt;CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。&lt;br/&gt;CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。&lt;/p&gt;
&lt;p&gt;CodePush 可以进行实时的推送代码更新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接对用户部署代码更新&lt;/li&gt;
&lt;li&gt;管理 Alpha，Beta 和生产环境应用&lt;/li&gt;
&lt;li&gt;支持 React Native 和 Cordova&lt;/li&gt;
&lt;li&gt;支持JavaScript 文件与图片资源的更新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CodePush开源了react-native版本，&lt;a href=&quot;https://github.com/Microsoft/react-native-code-push&quot; target=&quot;_blank&quot;&gt;react-native-code-push&lt;/a&gt;托管在GitHub上。&lt;/p&gt;
&lt;h2&gt;二,安装与注册CodePush&lt;/h2&gt;
&lt;h3&gt;2.1,安装 CodePush CLI&lt;/h3&gt;
&lt;p&gt;在终端输入如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; npm install -g code-push-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  code-push -v &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看版本 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2,创建一个CodePush 账号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; code-push register
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在终端输入&lt;code&gt;code-push register&lt;/code&gt;，会打开注册页面让你选择授权账号。授权通过之后，CodePush会告诉你“access key”，复制此key到终端即可完成注册。&lt;a target=&quot;_blank&quot;&gt; https://appcenter.ms/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;三,集成CodePush SDK&lt;/h2&gt;
&lt;p&gt;第一步：在项目中安装 react-native-code-push插件，终端进入你的项目根目录然后运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; npm install --save react-native-code-push
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.1,Android集成SDK&lt;/h3&gt;
&lt;p&gt;第二步： 运行 &lt;code&gt;npm link react-native-code-push&lt;/code&gt;。这条命令将会自动帮我们在anroid文件中添加好设置&lt;/p&gt;
&lt;p&gt;第三步： 在 android/app/build.gradle文件里面添如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果第二步没有成功，则手动配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;dependencies {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     implementation project(':react-native-code-push'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在/android/settings.gradle中添加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; include ':react-native-code-push'
&lt;span&gt;2&lt;/span&gt; project(':react-native-code-push').projectDir = &lt;span&gt;new&lt;/span&gt; File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在/android/app/src/com/.../.../MainApplication.java中添加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.microsoft.codepush.react.CodePush;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getJSBundleFile() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CodePush.getJSBundleFile();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; List&amp;lt;ReactPackage&amp;gt;&lt;span&gt; getPackages() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Arrays.&amp;lt;ReactPackage&amp;gt;&lt;span&gt;asList(
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;               ...
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CodePush(CODEPUSH_KEY_STAGING, getApplicationContext(), BuildConfig.DEBUG)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四步: 运行 &lt;code&gt;code-push deployment -k ls &amp;lt;appName&amp;gt;&lt;/code&gt;获取 部署秘钥。默认的部署名是 staging，所以 部署秘钥（deployment key ） 就是 staging。&lt;/p&gt;
&lt;p&gt;第五步： 添加配置。当APP启动时我们需要让app向CodePush咨询JS bundle的所在位置，这样CodePush就可以控制版本。更新 MainApplication.java文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainApplication &lt;span&gt;extends&lt;/span&gt; MultiDexApplication &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ReactApplication {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CODEPUSH_KEY_PRODUCTIO = &quot;ZaHJQhSDR7XVGMMjzbQnc686dbac&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CODEPUSH_KEY_STAGING = &quot;wiIxKA1Hp7g3Tb5Phytc686dbac-&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReactNativeHost mReactNativeHost = &lt;span&gt;new&lt;/span&gt; ReactNativeHost(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getJSBundleFile() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CodePush.getJSBundleFile();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getUseDeveloperSupport() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BuildConfig.DEBUG;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; List&amp;lt;ReactPackage&amp;gt;&lt;span&gt; getPackages() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Arrays.&amp;lt;ReactPackage&amp;gt;&lt;span&gt;asList(
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CodePush(CODEPUSH_KEY_STAGING, getApplicationContext(), BuildConfig.DEBUG)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getJSMainModuleName() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReactNativeHost getReactNativeHost() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mReactNativeHost;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第六步：修改versionName。&lt;br/&gt;在 android/app/build.gradle中有个 android.defaultConfig.versionName属性，我们需要把 应用版本改成 0.0.1（默认是1.0，但是codepush需要三位数）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;android{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    defaultConfig{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        versionName &quot;0.0.1&quot;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2,iOS集成&lt;/h3&gt;
&lt;p&gt;第二步： 运行 &lt;code&gt;rnpm link react-native-code-push&lt;/code&gt;。这条命令将会自动帮我们在ios中添加好设置&lt;/p&gt;
&lt;p&gt;在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。&lt;/p&gt;
&lt;p&gt;如果第二部没有成功则手动link 。&lt;/p&gt;
&lt;p&gt;1,首先在node_modules 中找到这个codepush 文件，然后拖进去如下图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018145722307-2127347478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2,特别注意一点由于这个库需要一个link 一个静态库（libz）如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018145738107-1256609553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018145829538-202766916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3,添加codepush的头文件路径，在 header Search Paths 中添加这句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(SRCROOT)/../node_modules/react-native-code-push/ios/CodePush
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步： 在build Settings页签中单击 + 按钮然后选择添加User-Defined Setting，然后输入CODEPUSH_KEY(名称随意)，然后填入deployment key：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018143200894-167480241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018142900448-613530151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：打开 Info.plist文件，在CodePushDeploymentKey中输入$(CODEPUSH_KEY)，并修改Bundle versions为三位&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018150204367-115845632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四,使用CodePush&lt;/h2&gt;
&lt;h3&gt;4.1,codepush常用命令&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;安装 CodePush CLI: npm install -g code-push-cli&lt;/li&gt;
&lt;li&gt;创建一个CodePush 账号: code-push register&lt;/li&gt;
&lt;li&gt;登陆：code-push login&lt;/li&gt;
&lt;li&gt;注销：code-push loout&lt;/li&gt;
&lt;li&gt;列出登陆的token: code-push access-key ls&lt;/li&gt;
&lt;li&gt;删除某个 access-key: code-push access-key rm &amp;lt;accessKye&amp;gt;&lt;/li&gt;
&lt;li&gt;创建一个app： code-push app add &amp;lt;appName&amp;gt; &amp;lt;os&amp;gt; &amp;lt;platform&amp;gt; 其中os为ios或android，platform为react-native&lt;/li&gt;
&lt;li&gt;在账号里移除一个 app:code-push app remove 或者 rm&lt;/li&gt;
&lt;li&gt;重命名一个存在 app: code-push app rename&lt;/li&gt;
&lt;li&gt;列出账号下面的所有 app: code-push app list 或则 ls&lt;/li&gt;
&lt;li&gt;把app的所有权转移到另外一个账号:code-push app transfer&lt;/li&gt;
&lt;li&gt;直接使用下面的命令查到对应应用的deployment key: code-push deployment ls &amp;lt;appName&amp;gt; -k&lt;/li&gt;
&lt;li&gt;部署:code-push deployment add &amp;lt;appName&amp;gt;&lt;/li&gt;
&lt;li&gt;重命名:code-push deployment rename &amp;lt;appName&amp;gt;&lt;/li&gt;
&lt;li&gt;删除部署:code-push deployment rm &amp;lt;appName&amp;gt;&lt;/li&gt;
&lt;li&gt;列出应用的部署情况:code-push deployment ls &amp;lt;appName&amp;gt;&lt;/li&gt;
&lt;li&gt;查看部署的key:code-push deployment ls &amp;lt;appName&amp;gt; -k&lt;/li&gt;
&lt;li&gt;查看历史版本:code-push deployment history &amp;lt;appName&amp;gt; &amp;lt;deploymentNmae&amp;gt; (Production 或者 Staging)&lt;/li&gt;
&lt;li&gt;发布热更新：code-push release-react &amp;lt;appName&amp;gt; &amp;lt;os&amp;gt; --description &quot;1.描述&quot;&lt;/li&gt;
&lt;li&gt;发布热更新:code-push release-react &amp;lt;appName&amp;gt; &amp;lt;os&amp;gt; -t 版本 -d 环境 --des 描述 -m true （强制更新）&lt;/li&gt;
&lt;li&gt;删除部署：code-push deployment rm &amp;lt;appName&amp;gt; &amp;lt;deploymentNmae&amp;gt; deploymentNmae(Production 或者 Staging)&lt;/li&gt;
&lt;li&gt;清除历史部署记录 code-push deployment clear &amp;lt;appName&amp;gt; Production or Staging&lt;/li&gt;
&lt;li&gt;回滚 code-push rollback &amp;lt;appName&amp;gt; Production --targetRelease v4(codepush服务部署的版本号)&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;4.2,更新方式&lt;/h3&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;div readability=&quot;57.5&quot;&gt;
&lt;p&gt;1、首先最简单的一种就是  这种无声的热更新，也就是说热更新不会给用户任何提示，都在默默的进行更新，用户完全体会不到整个过程&lt;/p&gt;
&lt;p&gt;classMyAppextendsComponent&amp;lt;{}&amp;gt; {}&lt;/p&gt;
&lt;p&gt;MyApp= codePush(MyApp);&lt;/p&gt;
&lt;p&gt;exportdefaultMyApp;&lt;/p&gt;
&lt;p&gt;2、第二种 也是无声更新，比第一种情况多了一种就是热更新每次会在后台返回前台的时候进行热更新。这里可以看到几个参数，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;checkFrequency&lt;/strong&gt;&lt;strong&gt;有三种状态如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ON_APP_START：  //在组件初始化的时候进行热更新&lt;/p&gt;
&lt;p&gt;ON_APP_RESUME：//在每次app从后台回到前台的时候进行热更新&lt;/p&gt;
&lt;p&gt;MANUAL：//不进行热更新，需要自己手动配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InstallMode&lt;/strong&gt; &lt;strong&gt;有如下几种状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IMMEDIATE  ：// 安装热更新，并且重启app&lt;/p&gt;
&lt;p&gt;ON_NEXT_RESTART：  //下次启动的时候启动热更新&lt;/p&gt;
&lt;p&gt;ON_NEXT_RESUME  //从后台回到前台的时候启动&lt;/p&gt;
&lt;p&gt;ON_NEXT_SUSPEND：  在后台的时候进行热更新&lt;/p&gt;
&lt;p&gt;classMyAppextendsComponent&amp;lt;{}&amp;gt; {}&lt;/p&gt;
&lt;p&gt;MyApp= codePush({ checkFrequency: codePush.CheckFrequency.ON_APP_RESUME, installMode: codePush.InstallMode.ON_NEXT_RESUME})(MyApp);&lt;/p&gt;
&lt;p&gt;exportdefaultMyApp;&lt;/p&gt;
&lt;p&gt;updateDialog  当为true 是，可以在更新的时候提示用户需要更新&lt;/p&gt;
&lt;h3&gt;4.3,codepush使用&lt;/h3&gt;
&lt;p&gt;1,登陆成功后，使用code-push app add &amp;lt;appName&amp;gt; &amp;lt;os&amp;gt; &amp;lt;platform&amp;gt;创建一个app,如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; code-push app add Test-ios ios react-native
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建成功后会返回对应的deployment key，将其拷贝到对应的配置文件即可&lt;/p&gt;
&lt;p&gt;iOS：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1040068/201810/1040068-20181018155711445-595837610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Android:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainApplication &lt;span&gt;extends&lt;/span&gt; MultiDexApplication &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ReactApplication {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CODEPUSH_KEY_PRODUCTIO = &quot;CuEhrwd_ZaHJ&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CODEPUSH_KEY_STAGING = &quot;XoFT5uAm_wiI&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReactNativeHost mReactNativeHost = &lt;span&gt;new&lt;/span&gt; ReactNativeHost(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {

...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2,配置js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt; CodePush.sync({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            updateDialog: {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否显示更新描述&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 appendReleaseDescription : &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新描述的前缀。 默认为&quot;Description&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 descriptionPrefix : ''&lt;span&gt; ,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 mandatoryUpdateMessage: ''&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制更新按钮文字，默认为continue&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 mandatoryContinueButtonLabel : '立即更新'&lt;span&gt; ,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非强制更新时，按钮文字,默认为&quot;ignore&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 optionalIgnoreButtonLabel : '稍后'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非强制更新时，确认按钮文字. 默认为&quot;Install&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 optionalInstallButtonLabel : '后台更新'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非强制更新时，检查到更新的消息文本&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 optionalUpdateMessage : ' '&lt;span&gt; ,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alert窗口的标题&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 title : '更新提示'
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            deploymentKey: CODE_PUSH_STAGING,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         },(status) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (status) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CodePush.SyncStatus.CHECKING_FOR_UPDATE:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(CodePush.SyncStatus.CHECKING_FOR_UPDATE);&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case CodePush.SyncStatus.AWAITING_USER_ACTION:&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     alert('codePush.SyncStatus.AWAITING_USER_ACTION');&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     break;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CodePush.SyncStatus.DOWNLOADING_PACKAGE:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用更新中，请稍后...&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CodePush.SyncStatus.INSTALLING_UPDATE:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    CodePush.allowRestart();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CodePush.SyncStatus.UP_TO_DATE:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前已是最新版本&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case CodePush.SyncStatus.UPDATE_IGNORED:&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     alert('codePush.SyncStatus.UPDATE_IGNORED');&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     break;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case CodePush.SyncStatus.UPDATE_INSTALLED:&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     alert('codePush.SyncStatus.UPDATE_INSTALLED');&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     break;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case CodePush.SyncStatus.SYNC_IN_PROGRESS:&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     alert('codePush.SyncStatus.SYNC_IN_PROGRESS');&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     break;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; case CodePush.SyncStatus.UNKNOWN_ERROR:&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     alert('codePush.SyncStatus.UNKNOWN_ERROR');&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;break;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         },
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;五,发布更新&lt;/h2&gt;
&lt;p&gt;code-push release-react &amp;lt;appName&amp;gt; &amp;lt;os&amp;gt; --description &quot;1.描述&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; code-push release-react Test-ios ios --description &quot;1.测试热更新&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; code-push release-react Test-android android --description &quot;1.测试热更新&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下发布更新需手动打包：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;code-push release &amp;lt;应用名称&amp;gt; &amp;lt;Bundles所在目录&amp;gt; &amp;lt;对应的应用版本&amp;gt; --deploymentName： 更新环境 --description： 更新描述 --mandatory： 是否强制更新&lt;/code&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; react-native bundle --platform ios --entry-file index.js --bundle-output ./bundles/index.ios.bundle --dev &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; code-push release Test-ios ./bundles/index.ios.bundle 1.0.0 --description &quot;1.测试热更新&quot; --mandatory &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Fri, 19 Oct 2018 03:33:00 +0000</pubDate>
<dc:creator>jackson影琪</dc:creator>
<og:description>React Native之code-push的热更新(ios android) React Native支持大家用React Native技术开发APP，并打包生成一个APP。在动态更新方面React</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson-zhangjiang/p/9805266.html</dc:identifier>
</item>
</channel>
</rss>