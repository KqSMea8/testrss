<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>我与 windows kernel 的一段时光 - .....?</title>
<link>http://www.cnblogs.com/fanling999/p/8150059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanling999/p/8150059.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本科毕业设计是实现一个基于 windows 的透明加密过滤系统。由此对 windows kernel development，尤其是 file system 进行过较为深入的探索。对于防终止的需求，转到调用层实现，由此对 HOOK 技术进行了系统的学习和探索。&lt;/p&gt;
&lt;p&gt;学习过程中作了不少笔记，但由于时间原因只是间断零碎的整理了一些到博客中。后来研究生阶段转向 machine learning 和 data mining 的相关课题，对系统安全的这一块内容涉及甚少，也就没有进一步整理更新。&lt;/p&gt;
&lt;p&gt;期间有不少网友与我沟通联系表示对该话题很感兴趣。工作落实以后，对自己的文件进行整理，现在将一些自己的学习资料跟大家分享，希望对研究系统尤其是 windows 内核的同仁们有一点帮助。&lt;/p&gt;
&lt;p&gt;这里主要对曾经已经发布的资料进行梳理并将一些 demo 进行分享。 &lt;strong&gt;需要注意的是，分享的程序在 Windows 7 及以前版本的操作系统上运行没有问题，但不保证其他环境可以正常运行。对于相关的环境配置和参数说明，至今不一定适用。建议读者注意参考官网最新的文档，通过 google或更新的blog解决问题。不过话说回来，最靠谱的还是官方文档！！&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此处主要是对自己工作的一个总结，如果能对大家起到帮助就更好了。代码和调试过程的细节本人不再提供支持和维护，毕竟精力有限。由于个人能力有限，资料难免有纰漏，欢迎指正。如果大家有更有趣的发现或更好的进展欢迎分享，相互学习。&lt;/p&gt;
&lt;p&gt;总的来说，整个学习过程确实踩了不少坑，但也正因此让整个过程更有趣。 &lt;strong&gt;The road to success was trial and error development, recompilation, and lots of crashes.&lt;/strong&gt; ——— 这句话是曾经看书时记下来的，用来形容这一过程再贴切不过。与大家共勉～。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hfl15/windows_kernel_development&quot;&gt;github 文件夹&lt;/a&gt;, 可能会不定期更新。&lt;/p&gt;
&lt;h2 id=&quot;资料整理&quot;&gt;资料整理&lt;/h2&gt;
&lt;p&gt;相关内容整理如下。&lt;a href=&quot;https://github.com/hfl15/windows_kernel_development/tree/master/TechnicalSharon-windows_kernel_programing&quot;&gt;技术分享-windows kernel&lt;/a&gt; 是一次技术沙龙的分享，对内核程序开发进行了一个粗略的介绍，其中还分享了一些有趣的小 demo。&lt;a href=&quot;https://github.com/hfl15/windows_kernel_development/tree/master/demo_source_code&quot;&gt;HOOK&lt;/a&gt;，一些 HOOK 的小程序和code。&lt;a href=&quot;https://github.com/hfl15/windows_kernel_development/tree/master/graduation_thesis&quot;&gt;防终止的基于Windows透明加密 过滤系统研究与实现&lt;/a&gt; 是我的论文和答辩 ppt，可以对 windows 内核文件系统一个较为系统的了解。&lt;/p&gt;
&lt;h2 id=&quot;一些学习资源&quot;&gt;一些学习资源：&lt;/h2&gt;
</description>
<pubDate>Sat, 30 Dec 2017 07:37:00 +0000</pubDate>
<dc:creator>.....?</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanling999/p/8150059.html</dc:identifier>
</item>
<item>
<title>nodejs+mongodb+vue前后台配置ueditor - cheer4chai</title>
<link>http://www.cnblogs.com/cheerup/p/8150055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cheerup/p/8150055.html</guid>
<description>&lt;p&gt;笔者在做一个个人博客项目的时候需要一个富文本框输入组件与后台进行交互，但是官方配置里面没有关于nodejs的，于是自己查阅资料研究了一下，最后终于应用到了系统中。&lt;/p&gt;
&lt;h3&gt;一、后台配置&lt;/h3&gt;
&lt;p&gt;首先是找到了这个项目：https://github.com/netpi/ueditor，可以通过他开源的代码将ueditor应用的node上面，大概方法如下：&lt;/p&gt;
&lt;p&gt;1.先安装依赖： &lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install ueditor --save&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2. 配置Node设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//引入接口文件
const api = require('./api');
//引入文件模块
const fs = require('fs');
//引入处理路径模块
const path = require('path');
//引入处理post数据模块
var bodyParser = require('body-parser');

//引入express
const express = require('express');
const app = express();
//引入ueditor
const ueditor = require(&quot;ueditor&quot;)

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

//更改限定大小
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));
// parse application/json
app.use(bodyParser.json())
app.use(api)

app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, 'public'), function(req, res, next) {
    //客户端上传文件设置
    var imgDir = '/img/ueditor/'
    var ActionType = req.query.action;
    if (ActionType === 'uploadimage' || ActionType === 'uploadfile' || ActionType === 'uploadvideo') {
        var file_url = imgDir; //默认图片上传地址
        /*其他上传格式的地址*/
        if (ActionType === 'uploadfile') {
            file_url = '/file/ueditor/'; //附件
        }
        if (ActionType === 'uploadvideo') {
            file_url = '/video/ueditor/'; //视频
        }
        res.ue_up(file_url); //你只要输入要保存的地址 。保存操作交给ueditor来做
        res.setHeader('Content-Type', 'text/html');
    }
    //  客户端发起图片列表请求
    else if (req.query.action === 'listimage') {
        var dir_url = imgDir;
        res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片
    }
    // 客户端发起其它请求
    else {
        // console.log('config.json')
        res.setHeader('Content-Type', 'application/json');
        res.redirect('../nodejs/config.json');
    }
}));

//处理静态文件 todo
// 访问静态资源文件 这里是访问所有dist目录下的静态资源文件
app.use(express.static(path.resolve(__dirname, 'public/')))
app.use('/ueditor', function(req, res) {
    res.render('views/');
});

//监听8888端口
app.listen(8888);
console.log('sucess listen......')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里需要注意的是因为已经require了ueditor，所以该插件已经安装到了node_module内，所以不需要再拷贝额外的文件了，只需要需要在这个目录下面新建public文件夹存放返回给后台的数据，另外，还需要引入配置文件config.json&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;二、前台配置&lt;/h3&gt;
&lt;p&gt;vue的前台配置需要下载ueditor的文件放在目录中，我将其放在了static文件夹中，在vue入口文件中引入ueditor的文件：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import '../static/UE/ueditor.config.js'&lt;span&gt;
import &lt;/span&gt;'../static/UE/ueditor.all.min.js'&lt;span&gt;
import &lt;/span&gt;'../static/UE/lang/zh-cn/zh-cn.js'&lt;span&gt;
import &lt;/span&gt;'../static/UE/ueditor.parse.min.js'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得一提的是需要将ueditor.config.js文件中的目录配置为放置该插件的目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.UEDITOR_HOME_URL = &quot;/static/UE/&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;20.5&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1048172/201712/1048172-20171230152816351-1723725319.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;然后在组件中配置好就可以了&lt;/p&gt;
&lt;p&gt;我的UE.vue组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;script :id=id type=&quot;text/plain&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;'UE'&lt;span&gt;,
    data () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        editor: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
      }
    },
    props: {
      defaultMsg: {
        type: String
      },
      config: {
        type: Object
      },
      id: {
        type: String
      },
    },
    mounted() {
      const _this &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editor = UE.getEditor(&lt;span&gt;this&lt;/span&gt;.id, &lt;span&gt;this&lt;/span&gt;.config); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化UE&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.editor.addListener(&quot;ready&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        _this.editor.setContent(_this.defaultMsg); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确保UE加载完成后，放入内容。&lt;/span&gt;
&lt;span&gt;      });
    },
    methods: {
      getUEContent() { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取内容方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.editor.getContent()
      }
    },
    destroyed() {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.editor.destroy();
    }
  }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;UE :defaultMsg=defaultMsg :config=config :id=ue1 ref=&quot;ue&quot;&amp;gt;&amp;lt;/UE&amp;gt;
&lt;span&gt;
data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      defaultMsg: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
      image: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
      config: {
        initialFrameWidth: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
        initialFrameHeight: &lt;/span&gt;350&lt;span&gt;
      },
      ue1: &lt;/span&gt;&quot;ue1&quot;&lt;span&gt;
    };
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以成功配置好ueditor的基本功能了&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt; 
&lt;h3&gt;三、前后台请求代理&lt;/h3&gt;
&lt;p&gt;在vue dev环境下可以设置webpack的proxyTable将后端请求代理转发，就可以轻松调试文件上传功能了，同理，vue build之后的文件则需要用Node将静态文件代理到和后端同一个端口上才可以请求后台端口&lt;/p&gt;

&lt;p&gt;篇幅有限，文章可能讲述的不太清晰，具体的可以看我这个项目的代码：https://github.com/cheer4chai/myBlog&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;code/&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Dec 2017 07:35:00 +0000</pubDate>
<dc:creator>cheer4chai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cheerup/p/8150055.html</dc:identifier>
</item>
<item>
<title>SSH框架完全整合 - MindMrWang</title>
<link>http://www.cnblogs.com/MindMrWang/p/8150048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MindMrWang/p/8150048.html</guid>
<description>&lt;p&gt;大三学期渐末，事情也挺多的，上周就开始着手整合SSH框架，到现在才真正的完成，过程中碰到了许多小问题（小问题大折腾，哭脸.jpg）。本着善始善终的原则，最终把它给完成了。&lt;/p&gt;
&lt;p&gt;本篇文章就在：&lt;br/&gt;win7 64位，eclipse最新版（2017.9），Spring4.3.13，Hibernate5.0.1，Struts2.3.34 环境下，整合SSH。在下一篇文章，我们也来使用Maven来整合一下（毕竟学了就要用嘛，哈哈）。&lt;/p&gt;
&lt;p&gt;首先先介绍一下jar包：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171228214530154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171228214543177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是我使用完整的jar包清单，我们分别导入了三个框架所需要的jar包，在导jar包的时候需要注意以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jar包冲突：struts2的javassist和Hibernate的javassist有冲突，我们选择最新的版本的（根据你的自身情况选择）。&lt;/li&gt;
&lt;li&gt;log4j，log4j-api，log4jcore，slf4j-api，slf4j-log4j12的的冲突，我们依旧看情况选择最新版本。&lt;/li&gt;
&lt;li&gt;c3p0jar包，我们选择最新的（框架之间有重复的记得删除重复）。&lt;/li&gt;
&lt;li&gt;Spring整合struts2需要导入Spring-web和struts2-spring-plugin jar包，不要丢掉。&lt;/li&gt;
&lt;li&gt;数据库jar驱动jar包，根据自身使用的数据库进行选择&lt;/li&gt;
&lt;li&gt;因为我这里使用Spring对事务的管理，所以还要导入事务的jar包，spring -jdbc的jar包,spring-orm,Aspectj的jar包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;以上都是我们需要特别注意的，否则整合的过程中会给你带来不小的麻烦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jar包就介绍差不多了，那我们就来开始吧：&lt;br/&gt;首先看一下我的目录结构：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171228215718529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目大体可以分为三层，视图层，service层，DAO层，因为我们这里没有什么业务，单纯的是调用DAO，所以可能service层和DAO层之间的区别不是很明显。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实三个框架的整合，就是将Hibernate的session创建交给Spring，将Struts2的Action交给Spring。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（一）在Hibernate中，我们自己通过以下的一系列操作获取session：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         //加载配置文件
        Configuration config = new Configuration().configure();
        //根据配置文件创建会话工厂
        SessionFactory factory = config.buildSessionFactory();
        //根据会话工厂创建会话
        Session session = factory.getCurrentSession();
        //创建一个事物对象
        Transaction tx = session.beginTransaction();
        //new 一个学生对象
        Student student = new Student(&quot;小三&quot;,19,99);
        //将对象持久化到数据表中
        session.save(student);
        //提交事务
        tx.commit();
        //关闭会话
        session.close();
        //关闭工厂
        factory.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样为了解耦，在项目中，我们不再自己手动的来获取session了，而是通过Spring来帮我们创建，并且service层中需要DAO，DAO需要session，也是Spring进行注入。&lt;/p&gt;
&lt;p&gt;（二）在Struts2中，我们通过自己在Struts2的主配置文件中指定对应请求的Action的全限定类名，Struts2和Spring整合则是将Action的创建交给了Spring，由Spring来管理Action对象。&lt;/p&gt;
&lt;p&gt;接下来我们就这两个方面分别整合Spring和Hibernate，Spring和Struts2，最后在Struts2 Action的execute方法中调用service，对业务进行操作。&lt;/p&gt;
&lt;p&gt;下面为了代码的可读性，博主不会将代码分块分析，很重要的将会指出，大多数的过程说明将在注释中给出：&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;整合spring和hibernate&quot;&gt;整合Spring和Hibernate：&lt;/h2&gt;
&lt;p&gt;先给出我们的基本代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//DAO接口：
public interface StudentDao {
    void insert(Student student);
    void delete(Student student);
    void update(Student student);
    List&amp;lt;Student&amp;gt; selectAllStudents();
    boolean selectStudentByIdAndName(String name,int age);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//DAO的实现类，里面注入了SessionFactory对象，利用这个我们可以获取session

public class StudentDaoImpl implements StudentDao{
    //这里的sessionFactory由Spring进行注入
    private SessionFactory sessionFactory;
    //所以这里需要setter方法，这里的getter方法顺带添上，如果以后需要获取sessionFactory的话可以调用
    public SessionFactory getSessionFactory() {
        return sessionFactory;
    }
    //依赖注入，需要setter方法
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    @Override
    public void insert(Student student) {
        sessionFactory.getCurrentSession().save(student);
    }

    @Override
    public void delete(Student student) {
        sessionFactory.getCurrentSession().delete(student);
    }

    @Override
    public void update(Student student) {
        sessionFactory.getCurrentSession().update(student);
    }


    @Override
    public List&amp;lt;Student&amp;gt; selectAllStudents() {
        String hql = &quot;from Student&quot;;
        return sessionFactory.getCurrentSession().createQuery(hql).list();
    }

    //通过name和age来判别学生是否存在
    @Override
    public boolean selectStudentByIdAndName(String name, int age) {
        String hql = &quot;from Student where name=? and age=?&quot;;
        boolean flag = false;
        if(sessionFactory.getCurrentSession().createQuery(hql).setString(0, name).setInteger(1, age).uniqueResult()!=null) {
            flag = true;
        }
        return flag;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面的DAO，我们获取session不再使用原始的方法了，而是使用Spring注入的方式为我们程序获取session，具体的SessionFactory配置，将在后面的Spring配置文件给出。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来我们看Service：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//service接口
public interface StudentService {
    void add(Student student);
    void remove(Student student);
    void modify(Student student);
    List&amp;lt;Student&amp;gt; findAllStudents();
    boolean findByNameAndAge(String name,int age);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;//service实现类
public class StudentServiceImpl implements StudentService {
    //这里的Dao对象是由Spring注入，下面要有setter方法
    private StudentDao studentdao; 
    public StudentDao getStudentdao() {
        return studentdao;
    }
    public void setStudentdao(StudentDao studentdao) {
        this.studentdao = studentdao;
    }
    @Override
    public void add(Student student) {
        studentdao.insert(student);
    }

    @Override
    public void remove(Student student) {
        studentdao.delete(student);
        
    }

    @Override
    public void modify(Student student) {
        studentdao.update(student);
        
    }

    @Override
    public List&amp;lt;Student&amp;gt; findAllStudents() {
        return studentdao.selectAllStudents();
    }
    @Override
    public boolean findByNameAndAge(String name, int age) {
        return studentdao.selectStudentByIdAndName(name, age);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;接着便是我们Spring的配置文件（下面的配置文件是完整的配置文件，即整合ssh的完整配置文件，其实也就是在整合Hibernate的基础上注册了Action类的bean）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
    &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;

    &amp;lt;!-- 注册c3p0数据源 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;!--处理中文乱码问题--&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test?useUnicode=true&amp;amp;amp;characterEncoding=utf8&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;123&quot;/&amp;gt;
        &amp;lt;!-- ?useUnicode=true&amp;amp;amp;characterEncoding=utf8 --&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注册sessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;MysessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        &amp;lt;!--不要缺少classpath，否则在整合Struts2时候会找不到映射文件--&amp;gt;
        &amp;lt;property name=&quot;mappingDirectoryLocations&quot; value=&quot;classpath:com/testSpring/Entity&quot;/&amp;gt;
        
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQL5Dialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.current_session_context_class&quot;&amp;gt;org.springframework.orm.hibernate5.SpringSessionContext&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注册studentDao --&amp;gt;
    &amp;lt;bean id=&quot;StudentDao&quot; class=&quot;com.testSpring.Dao.StudentDaoImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;MysessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注册studentService --&amp;gt;
    &amp;lt;bean id=&quot;studentservice&quot; class=&quot;com.testSpring.Service.StudentServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;studentdao&quot; ref=&quot;StudentDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 将Action交由Spring来管理  ref里面的studentservice引用的是上面的bean，这个是多例的，因为每个请求对应一个Action，不能多个用户共用一个Action--&amp;gt;
    &amp;lt;bean id=&quot;RegisterAction&quot; class=&quot;com.testSpring.Action.RegisterAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;property name=&quot;studentservice&quot; ref=&quot;studentservice&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注册事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;MysessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注册事务通知 --&amp;gt;
    &amp;lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;transactionManager&quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;tx:method name=&quot;add&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&amp;gt;
            &amp;lt;tx:method name=&quot;remove&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;modify&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;findAllStudents&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&amp;gt;
            &amp;lt;tx:method name=&quot;findByNameAndAge&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;
    
    &amp;lt;!-- aop配置切入点 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut expression=&quot;execution(* *..Service.*.*(..))&quot; id=&quot;myPointCut&quot;/&amp;gt;
        &amp;lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;myPointCut&quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整合Hibernate，&lt;br/&gt;我们需要注册SessionFactory，&lt;br/&gt;class为&lt;code&gt;org.springframework.orm.hibernate5.LocalSessionFactoryBean&lt;/code&gt;，位于我们Spring orm包下，对于不同版本的Hibernate，我们应该选用不同的整合class。&lt;/p&gt;
&lt;p&gt;上面的Spring主配置文件中用&lt;code&gt;&amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;&lt;/code&gt;属性来替代了我们导入Hibernate的主配置文件，当然我们也可以直接导入Hibernate的主配置文件，不过为了简洁，我们这样比较方便。&lt;/p&gt;
&lt;p&gt;关于配置文件后面对事务的管理，我们这里就不多说了，我的前几篇文章都有详细的介绍，有兴趣的同学可以去看看：&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_39266910/article/details/78826171&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_39266910/article/details/78826171&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果做到上面的这些，我们便可以进行测试了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//测试类
public class Test01 {
    private StudentService service;
    
    @Before
    public void before() {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        service = (StudentService)ac.getBean(&quot;studentservice&quot;);
    }

    @Test
    public void test01() {
        service.add(new Student(&quot;中文&quot;,18));
        System.out.println(&quot;Success&quot;);
    }
    
    @Test
    public void test02() {
        Student student = new Student();
        student.setId(1);
        service.remove(student);
    }
    
    @Test
    public void test03() {
        Student student = new Student(&quot;张三&quot;,25);
        student.setId(10);
        service.modify(student);
    }
    
    @Test
    public void test06() {
        System.out.println(service.findAllStudents());
    }
    
    @Test
    public void test07() {
        System.out.println(service.findByNameAndAge(&quot;中&quot;, 18));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是Spring整合Hibernate的全过程，接下来我们来整合Struts2：&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;spring整合struts2&quot;&gt;Spring整合Struts2&lt;/h2&gt;
&lt;p&gt;首先是Struts2的主配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;
    
&amp;lt;struts&amp;gt;
     &amp;lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&amp;gt;
     &amp;lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&amp;gt;

     &amp;lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot; &amp;gt;
     &amp;lt;!--下面的全限定类名可以改为RegisterAction，当我们在Spring中注册当前Action类的bean--&amp;gt;
            &amp;lt;action name=&quot;register&quot; class=&quot;com.testSpring.Action.RegisterAction&quot;&amp;gt;
            &amp;lt;result name=&quot;success&quot;&amp;gt;/welcome.jsp&amp;lt;/result&amp;gt;
            &amp;lt;result name=&quot;error&quot;&amp;gt;/error.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
    &amp;lt;/package&amp;gt;
&amp;lt;/struts&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;接着是对应的Action：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RegisterAction extends ActionSupport{
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    //Spring会为我们自动注入service，但是这个属性名要和Spring主配置文件里面注册的studentservice的id保持一致。
    //或者将Action交由Spring管理，在Spring配置Action的bean，为bean注入service，如果这样，我们在struts2主配置文件的class就不必写成Action的全限定类名，而是Spring中注册的id。
    private StudentService studentservice;
    public RegisterAction() {
        super();
    }
    
    public RegisterAction(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    
    //  注入Service，我们需要保留set方法
    public void setStudentservice(StudentService studentservice) {
        this.studentservice = studentservice;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String execute() {
        System.out.println(studentservice);
        System.out.println(name);
        System.out.println(age);
        studentservice.add(new Student(name,age));
        return SUCCESS;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是模拟完成一个注册功能，view层发送一个请求，包含姓名和年龄，后台负责接收，并调用service层进行处理，service层调用DAO，DAO调用SessionFactory获取session，最终达到对数据库的操作。&lt;/p&gt;
&lt;p&gt;如果仅仅这样你是不是忘了些什么？&lt;br/&gt;①我们需要在web.xml中添加Struts2的核心过滤器。&lt;br/&gt;②设置一个监听器，监听当web容器创建的时候，即创建我们的Spring容器，这样我们不再需要自己加载Spring的主配置文件。&lt;br/&gt;③设置web容器全局参数，自定义Spring主配置文件的位置和命名&lt;/p&gt;
&lt;p&gt;具体的看web.xml:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&amp;gt;
    
  &amp;lt;!--  自定义Spring主配置文件的位置 --&amp;gt;
  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
  
  &amp;lt;!-- 使用ContextLoaderListener初始化Spring容器 --&amp;gt;
  &amp;lt;listener&amp;gt;
      &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;
    
  &amp;lt;!-- 定义Struts 2的FilterDispathcer的Filter --&amp;gt;
  &amp;lt;filter&amp;gt;
      &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
      &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;/filter&amp;gt;
  &amp;lt;!-- FilterDispatcher用来初始化Struts 2并且处理所有的WEB请求。 --&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
      &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
      &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;
  
  &amp;lt;welcome-file-list&amp;gt;
    &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
  &amp;lt;/welcome-file-list&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;我们一并给出jsp页面（success和error页面就不写了，一个形式）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;register&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;register&quot; method=&quot;post&quot;&amp;gt;
        姓名&amp;lt;input type=&quot;text&quot; name=&quot;name&quot;&amp;gt;&amp;lt;br&amp;gt;
        年龄&amp;lt;input type=&quot;text&quot; name=&quot;age&quot;&amp;gt;&amp;lt;br&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;注册&quot;&amp;gt;    
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们进行测试：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171229160113873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后，跳转到：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171229160150218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后看看数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171229160230148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上的ssh整合大体上是没有什么问题的，但是碰上延时加载的话会出现一些意想不到的事情，在讲Hibernate的session的时候，我们说过session有两种获取的方式，一个是getCurrentSession，另一个是openSession，它们两个获取的session的区别是，getSession获得的session必须要在事务中执行，也就说没有事务是不能获取session的，当我们使用session.load进行查询的时候，这就是一个延时加载，执行加载方法的时候会产生一个代理，这个代理是一个空代理，只有当我们真正需要这个代理的详细数据的时候，才会真正的进行查询，但是当它真正的查询的时候，已经没有了事务（因为我们这里的事务是通过Spring整合AspectJ，通过AOP的方式实现添加事务的），所以这个时候也就没有了session，所以当再执行详情查询的时候就会报错（no session）。&lt;/p&gt;
&lt;p&gt;所以我们需要在web.xml中添加一个过滤器，来获取session，这个过滤器的名字叫做&lt;strong&gt;OpenSessionInViewFilter&lt;/strong&gt;，添上这个过滤器后，当我们进行延时加载的话，就不会再出现no session的情况了！&lt;br/&gt;在OpenSessionInViewFilter的源码中，获取session是利用的SessionFactory，也就是我们自己在Spring的注册的SessionFactory，且在里面，这个类有一个默认的SessionFactory名字就叫做sessionFactory：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230145711298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：添加这个过滤器，一定要在Struts2的核心过滤器之前！&lt;/strong&gt;&lt;br/&gt;具体原因是：Struts2的核心过滤器中，当有Action请求的时候，会执行executeAction方法，即执行Action，不会有chain.doFilter(执行下一个过滤器)，有源码有真相：&lt;br/&gt;这里的mapping就是对应的action请求。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230150426642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是openSessionInViewFilter的具体配置方法，初始化参数是为了自定义我们的sessionFactory的bean id，因为openSessionInViewFilter里面有setter方法，可以为之前设置好的默认值进行修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171230144807133?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;总结：当代码都写出来了，觉得很简单，但是这过程中一直小bug不断（当然大多数都是由自己的粗心造成的），其实三个框架之间的真核无非就是将所有关于类的创建管理交由Spring，由Spring来为需要的注入所需要的bean，不再需要手动的创建一个个的类，使得各个层级之间耦合度降低，即使一层代码出现了问题不需要修改另一层的代码，便于我们项目的维护和更新，也便于出现问题能够即使定位出错的位置。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上是自己的心得体会，代码均由博主亲自验证，可以运行，文章方便博主以后查阅，也供大家参考，如有错误不吝赐教！&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 07:32:00 +0000</pubDate>
<dc:creator>MindMrWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MindMrWang/p/8150048.html</dc:identifier>
</item>
<item>
<title>浅谈，html\css脱离标准文档流相关 - 世外古道</title>
<link>http://www.cnblogs.com/HL-123-blogs/p/8149893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HL-123-blogs/p/8149893.html</guid>
<description>&lt;p&gt;　　（个人知识有限，难免有误，请见谅）&lt;/p&gt;
&lt;p&gt;　　标准文档流，顾名思义，是要按照一定规矩排列的，默认的就是元素会从左至右，从上至下排列，块级会独占一行，行内元素会和小伙伴们共享一行。&lt;/p&gt;
&lt;p&gt;　　本来在标准文档流下，各个元素相安无事，可突然有一天某个元素心想啊，我那么优秀，不该出现在这里啊，于是它成精了，它发现了一道大门走向另一个空间BFC。&lt;/p&gt;
&lt;p&gt;　　BFC：直译为“块级格式化上下文”，这是一个独立的区域，这个区域与外部没有关系了，互不招惹，个人常用的会开启BFC空间的方式有&lt;/p&gt;
&lt;p&gt;　　1.float的值不是none  &lt;/p&gt;
&lt;p&gt;　　2.position的值不为relative和static&lt;/p&gt;
&lt;p&gt;　　3.display为inline-block&lt;/p&gt;
&lt;p&gt;　　4.overflow不为visible&lt;/p&gt;
&lt;p&gt;　　当然还有其他的方式会产生BFC，这里就不列举了。&lt;/p&gt;
&lt;p&gt;　　先说说float，浮动，它会相对于自己最近的父元素进行定位，往左或者往右，这种方式会给我们布局带来便利，也可以变相的清除一些空文本给我们带来的不必要的空隙，但是使用它的时候需要注意清除它，不然由于它会脱离文档流的缘故，它的兄弟元素会跑到它原来的位置占位，或者它的父元素会因此而坍塌，这样会造成布局的混乱，就好比是在同一个位置，不同的时空，虽然浮动之后的元素还在，但是其他元素却看不见它，当然这个比喻并不怎么恰当，为了防止布局的混乱，也就是浮动之后带来的你不想要的效果，浮动之后一定要记得清除浮动，清除浮动常用的方式可以直接clear掉，当然也可以使用伪类:after来清除浮动，对于overflow:hidden,还有给浮动元素的父元素设置float来撑开父元素的高度，其原理也是开启BFC，将父元素与子元素置于同一个空间。&lt;/p&gt;
&lt;p&gt;　　再说说position，position定位也是一种脱离普通文档流的做法，它的定位方式是相对于最近的已经定位的祖先元素，常见的方式就是子绝父相，子元素绝对定位，父元素相对定位，使用这种方式可以让子元素相对于父元素做定位，使用position:absolute的时候记得设置x,y轴的值，也就是left,top（当然也可以rigth,top，具体情况自己决定）的值，目前我不知道有什么方式可以让position为absolute与fixed的元素再从自己开辟的BFC中出来，建议只在必须的情况下使用position定位，因为position定位使用多了，大家都脱离了普通文档流，可能会给后续的布局带来困难，既然说到了position，那就顺带再提提z-index，z-index相当于布局中的z轴，在使用了position:relative 或者absolute 或者fixed的时候z-index值便会生效，简单的说如果有几个元素重叠在了一起，这时z-index后面的值谁大，谁就会显示，其实其它元素也还在，只是被z-index值最大的那个元素挡住了，注意z-index后面的值没有单位的哈。&lt;/p&gt;
&lt;p&gt;　　最后，关于display:inline-block，我最长用的时候无非就是让霸气的块级元素能够容忍其它元素和它共享一行，或者让谦逊的行类元素拥有能够设置width,height的能力。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 06:36:00 +0000</pubDate>
<dc:creator>世外古道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HL-123-blogs/p/8149893.html</dc:identifier>
</item>
<item>
<title>PHP中public,private,protected,abstract等关键字用法详解 - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8098698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8098698.html</guid>
<description>&lt;p&gt;&lt;span&gt; 在PHP中包含了很多对函数和类进行限制的关键字，常用的通常有abstract,final,interface，public，protected,private,static等等，下面我们就将对这些进行分析整理各个的用法。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;变量与方法的关键字public,private,protected&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;public的权限最大，既可以让子类使用，也可以支持实例化之后的调用，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;protected表示的是受保护的，访问的权限是只有在子类和本类中才可以被访问到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;private 表示的是私有，只能够是在当前的类中可以被访问到&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;//
/*&lt;/span&gt;&lt;span&gt;*
* Define MyClass
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$public&lt;/span&gt; = 'Public'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;$protected&lt;/span&gt; = 'Protected'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;$private&lt;/span&gt; = 'Private'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; printHello()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; pro_test(){
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(1&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;$obj&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass();
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$obj&lt;/span&gt;-&amp;gt;&lt;span&gt;public&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这行能被正常执行
//echo $obj-&amp;gt;protected; // 这行会产生一个致命错误
//echo $obj-&amp;gt;private; // 这行也会产生一个致命错误&lt;/span&gt;
&lt;span&gt;$obj&lt;/span&gt;-&amp;gt;printHello(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 Public、Protected 和 Private&lt;/span&gt;
&lt;span&gt;$obj&lt;/span&gt;-&amp;gt;pro_test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接报错&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;变量与方法的关键字static &lt;/h2&gt;
&lt;p&gt;&lt;span&gt; static的作用就是能够实现值或者方法在类中不需实例化的情况下调用，同时static修饰的变量具有与值存储的功能，例如我们不使用static运行的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
    &lt;/span&gt;&lt;span&gt;$var&lt;/span&gt;=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$var&lt;/span&gt;.&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$var&lt;/span&gt;++&lt;span&gt;;
}
test();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;如果我们给变量加上static那么就会变成这样&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$var&lt;/span&gt;=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$var&lt;/span&gt;.&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$var&lt;/span&gt;++&lt;span&gt;;
}
test();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 这里可能不能够体会到PHP这样做的好处，那么我们就先来假设一下读者也熟悉JS，在JS中是没有static这个关键字的，所以如果我们要来实现一个具有能够保存每一次程序运算结果作为下一次运算的依据的一个程序我们需要这样来写。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; glo=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
        glo&lt;/span&gt;++&lt;span&gt;;
        document.writeln(glo);
    }
    test();
    test();
    test();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这样就会把glo泄漏到全局变量中，如果生成的变量比较多，就会导致内存泄露（内存泄漏所指代的就是变量占用过多的内存空间没有别释放）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; glo=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
        glo&lt;/span&gt;++&lt;span&gt;;
        document.writeln(glo);
    }
    test();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
    test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
    test();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 &lt;/span&gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;所以相比于在没有定义static的语言中，它具有一个优势是保持变量，不泄露内存，也不容易导致全局变量被误用（因为作用域不在全局）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$age&lt;/span&gt;=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$age&lt;/span&gt;++&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test1() {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt; = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$age&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt;.&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test2() {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt; = 1000&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$age&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$age&lt;/span&gt;.&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;;
}

test1(); // 101
test2(); // 1001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; class与方法的关键字final&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;final只能够用来修饰class与function，使用了final之后就不能够被继承，例如如下的代码就会直接报错&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseClass {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;$public&lt;/span&gt; = 'Public'&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test() {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;BaseClass::test() called\n&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; moreTesting() {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;BaseClass::moreTesting() called\n&quot;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseClass {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; moreTesting() {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;ChildClass::moreTesting() called\n&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;特殊关键字interface,abstract&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;interface的意义在于规范编程的风格，设想一下就是如果是实现了一个接口那么我们在使用这个接口类的时候就必须要实现里面的方法，起到了统一命名的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;class是可以多继承接口的，接口与接口之间的单继承是通过extends来实现的，class与接口之间的关系确立是通过implements&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; testA{
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcA();
}
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; testB{
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcB();
}
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt; testC &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; testA {
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcC();
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; run &lt;span&gt;implements&lt;/span&gt; testC ,&lt;span&gt;testB {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcA()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Implement funcA() method.&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcB()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Implement funcB() method.&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; funcC()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Implement funcC() method.&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;abstract的作用跟interface其实是一样的，但是在interface中所有的方法都是必须要实现的，但是在abstract修饰的类中，可以有一个或者是多个的abstract修饰方法，所以我们可以这样理解，interface就是abstract的一种特殊情况（当所有的方法都是抽象方法，都是必须要实现的）。abstract有以下的这些特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 只要类中有至少一个方法使用了abstract关键字，那么这个类是abstract，要加上相应的关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 抽象方法，只有方法的声明部分，没有方法体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是在我看来，abstract在实际的应用中有这样的几种场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 多人编程的时候规范公共部分的命名规则（不做任何说明，原理跟interface一样）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 实现不让父级直接实例化使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;样式代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; shopping
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; buy()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;buy&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; loan()
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;loan&quot;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; leslieBuy &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; shopping
{

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$test1=new shopping;//直接语法错误&lt;/span&gt;
&lt;span&gt;$leslieSie&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; leslieBuy;
&lt;/span&gt;&lt;span&gt;$leslieSie&lt;/span&gt;-&amp;gt;loan();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印出loan&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 30 Dec 2017 06:03:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8098698.html</dc:identifier>
</item>
<item>
<title>Python 项目实践二（下载数据）第三篇 - GodChao</title>
<link>http://www.cnblogs.com/majianchao/p/8149758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/majianchao/p/8149758.html</guid>
<description>&lt;p&gt;接着上节继续学习，在本章中，你将从网上下载数据，并对这些数据进行可视化。网上的数据多得难以置信，且大多未经过仔细检查。如果能够对这些数据进行分析，你就能发现别人没有发现的规律和关联。我们将访问并可视化以两种常见格式存储的数据：CSV和JSON。我们将使用Python模块csv来处理以CSV（逗号分隔的值）格式存储的天气数据，找出两个不同地区在一段时间内的最高温度和最低温度。然后，我们将使用matplotlib根据下载的数据创建一个图表，展示两个不同地区的气温变化：阿拉斯加锡特卡和加利福尼亚死亡谷。在本章的后面，我们将使用模块json来访问以JSON格式存储的人口数据，并使用Pygal绘制一幅按国别划分的人口地图。&lt;/p&gt;
&lt;h2&gt;一 CSV格式&lt;/h2&gt;
&lt;p&gt;要在文本文件中存储数据，最简单的方式是将数据作为一系列以逗号分隔的值（CSV）写入文件。这样的文件称为CSV文件。例如，下面是一行CSV格式的天气数据：&lt;br/&gt;2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195&lt;/p&gt;
&lt;h2&gt;二 分析CSV文件头&lt;/h2&gt;
&lt;p&gt;csv模块包含在Python标准库中，可用于分析CSV文件中的数据行，让我们能够快速提取感兴趣的值。下面先来查看这个文件的第一行，其中包含一系列有关数据的描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv

filename = 'sitka_weather_07-2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)
    print(header_row)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1）调用csv.reader()，并将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的阅读器（reader）对象。我们将这个阅读器对象存储在reader中。&lt;/p&gt;
&lt;p&gt;（2）模块csv包含函数next()，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。在前面的代码中，我们只调用了next()一次，因此得到的是文件的第一行，&lt;/p&gt;
&lt;p&gt;结果如下：['AKDT', 'Max TemperatureF', 'Mean TemperatureF', 'Min TemperatureF', 'Max Dew PointF', 'MeanDew PointF', 'Min DewpointF', 'Max Humidity', ' Mean Humidity', ' Min Humidity', ' Max Sea Level PressureIn', ' Mean Sea Level PressureIn', ' Min Sea Level PressureIn', ' Max VisibilityMiles', ' Mean VisibilityMiles', ' Min VisibilityMiles', ' Max Wind SpeedMPH', ' Mean Wind SpeedMPH', ' Max Gust SpeedMPH', 'PrecipitationIn', ' CloudCover', ' Events', ' WindDirDegrees']&lt;/p&gt;
&lt;p&gt;这个csv文件时这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230113311663-1118345070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三 打印头文件以及其位置&lt;/h2&gt;
&lt;p&gt;为让文件头数据更容易理解，将列表中的每个文件头及其位置打印出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv

filename = 'sitka_weather_07-2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)

&lt;span&gt;    for index,column_header in enumerate(header_row):
        print(index,column_header)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230113734382-1640580216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四 提取并读取数据&lt;/h2&gt;
&lt;p&gt;知道需要哪些列中的数据后，我们来读取一些数据。首先读取每天的最高气温：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv

filename = 'sitka_weather_07-2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)

    #for index,column_header in enumerate(header_row):
     #   print(index,column_header) 



   &lt;span&gt; highs=[]
    for row in reader :
        high = int(row[1])
        highs.append(high)

    print(highs)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;[64, 71, 64, 59, 69, 62, 61, 55, 57, 61, 57, 59, 57, 61, 64, 61, 59, 63, 60, 57, 69, 63, 62, 59, 57, 57, 61, 59, 61, 61, 66]&lt;/p&gt;
&lt;h2&gt;五 绘制气温图标&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv
&lt;span&gt;from matplotlib import pyplot as plt&lt;/span&gt;

filename = 'sitka_weather_07-2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)

    #for index,column_header in enumerate(header_row):
     #   print(index,column_header) 



    highs=[]
    for row in reader :
        high = int(row[1])
        highs.append(high)

    print(highs)

   &lt;span&gt; fig = plt.figure(dpi=128,figsize=(10,6))
    plt.plot(highs,c=&quot;red&quot;)

    #设置图形的格式
    plt.title(&quot;Daily high temperatures,July 2014,&quot;, fontsize=24)
    plt.xlabel(&quot;&quot;,fontsize=16)
    plt.ylabel(&quot;Temperature(F)&quot;,fontsize=16)
    plt.tick_params(axis=&quot;both&quot;,which =&quot;major&quot;,labelsize=16)

    plt.show()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230123333335-1429823935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 六 模块datetime&lt;/h2&gt;
&lt;p&gt;首先导入了模块datetime中的datetime类，然后调用方法strptime()，并将包含所需日期的字符串作为第一个实参。第二个实参告诉Python如何设置日期的格式。在这个示例中，'%Y-'让Python将字符串中第一个连字符前面的部分视为四位的年份；'%m-'让Python将第二个连字符前面的部分视为表示月份的数字；而'%d'让Python将字符串的最后一部分视为月份中的一天（1~31）。&lt;/p&gt;
&lt;p&gt;方法strptime()可接受各种实参，并根据它们来决定如何解读日期。一下列出了其中一些这样的实参：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230123755632-949343137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;七 在图表中添加日期&lt;/h2&gt;
&lt;p&gt; 知道如何处理CSV文件中的日期后，就可对气温图形进行改进了，即提取日期和最高气温，并将它们传递给plot()，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv
from matplotlib import pyplot as plt
&lt;span&gt;from datetime import datetime&lt;/span&gt;

filename = 'sitka_weather_07-2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)

    #for index,column_header in enumerate(header_row):
     #   print(index,column_header) 


    #从文件中获取日期和最高气温
     
 &lt;span&gt;   dates,highs=[],[]&lt;/span&gt;
    for row in reader :
        &lt;span&gt;current_date = datetime.strptime(row[0],&quot;%m/%d/%Y&quot;)
        dates.append(current_date)&lt;/span&gt;
        high = int(row[1])
        highs.append(high)

    print(highs)

    fig = plt.figure(dpi=128,figsize=(10,6))
    plt.plot(dates,highs,c=&quot;red&quot;)

    #设置图形的格式
    plt.title(&quot;Daily high temperatures,July 2014,&quot;, fontsize=24)
    plt.xlabel(&quot;&quot;,fontsize=16)
 &lt;span&gt;   fig.autofmt_xdate()&lt;/span&gt;
    plt.ylabel(&quot;Temperature(F)&quot;,fontsize=16)
    plt.tick_params(axis=&quot;both&quot;,which =&quot;major&quot;,labelsize=16)

    plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　我们创建了两个空列表，用于存储从文件中提取的日期和最高气温（见）。然后，我们将包含日期信息的数据（row[0]）转换为datetime对象，并将其附加到列表dates末尾。我们将日期和最高气温值传递给plot()。我们调用了fig.autofmt_xdate()来绘制斜的日期标签，以免它们彼此重叠。下图显示了改进后的图表。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230130416773-345989619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;八 再绘制一个数据系列&lt;/h2&gt;
&lt;p&gt;改进后的图表显示了大量意义深远的数据，但我们可以在其中再添加最低气温数据，使其更有用。为此需要从数据文件中提取最低气温，并将它们添加到图表中，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import csv
from matplotlib import pyplot as plt
from datetime import datetime

filename = 'sitka_weather_2014.csv'
with open(filename) as f :
    reader = csv.reader(f)
    header_row = next(reader)

    #for index,column_header in enumerate(header_row):
     #   print(index,column_header) 


    #从文件中获取日期和最高气温,最低气温
     
    &lt;span&gt;dates,highs,lows=[],[],[]&lt;/span&gt;
    for row in reader :
        current_date = datetime.strptime(row[0],&quot;%Y-%m-%d&quot;)
        dates.append(current_date)

        &lt;span&gt;low=int(row[3])
        lows.append(low)&lt;/span&gt;
        high = int(row[1])
        highs.append(high)

   # print(highs)

    fig = plt.figure(dpi=128,figsize=(10,6))
    plt.plot(dates,highs,c=&quot;red&quot;)

   &lt;span&gt; plt.plot(dates,lows,c=&quot;blue&quot;)&lt;/span&gt;

    #设置图形的格式
    plt.title(&quot;Daily high temperatures - 2014,&quot;, fontsize=24)
    plt.xlabel(&quot;&quot;,fontsize=16)
    fig.autofmt_xdate()
    plt.ylabel(&quot;Temperature(F)&quot;,fontsize=16)
    plt.tick_params(axis=&quot;both&quot;,which =&quot;major&quot;,labelsize=16)

    plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230133220601-1907433892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;九 给图标区域着色&lt;/h2&gt;
&lt;p&gt;添加两个数据系列后，我们就可以了解每天的气温范围了。下面来给这个图表做最后的修饰，通过着色来呈现每天的气温范围。为此，我们将使用方法fill_between()，它接受一个x值系列和两个y值系列，并填充两个y值系列之间的空间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
plt.plot(dates,highs,c=&quot;red&quot;,alpha=0.5)
plt.plot(dates,lows,c=&quot;blue&quot;,alpha=0.5)
plt.fill_between(dates,highs,lows,facecolor=&quot;blue&quot;,alpha=0.1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1）实参alpha指定颜色的透明度。Alpha值为0表示完全透明，1（默认设置）表示完全不透明。通过将alpha设置为0.5，可让红色和蓝色折线的颜色看起来更浅。&lt;/p&gt;
&lt;p&gt;（2）我们向fill_between()传递了一个x值系列：列表dates，还传递了两个y值系列：highs和lows。&lt;/p&gt;
&lt;p&gt;（3）实参facecolor指定了填充区域的颜色，我们还将alpha设置成了较小的值0.1，让填充区域将两个数据系列连接起来的同时不分散观察者的注意力。&lt;/p&gt;
&lt;p&gt;（4）显示了最高气温和最低气温之间的区域被填充的图表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230134445273-1611915329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未完待续！元旦三天小长假已经来了，祝大家元旦快乐！&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 05:49:00 +0000</pubDate>
<dc:creator>GodChao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/majianchao/p/8149758.html</dc:identifier>
</item>
<item>
<title>.NET开发一个微信跳一跳辅助程序 - 中国.NET研究协会</title>
<link>http://www.cnblogs.com/dotnet-org-cn/p/8149693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-org-cn/p/8149693.html</guid>
<description>&lt;p&gt;昨天微信更新了，出现了一个小游戏“跳一跳”，玩了一下 赶紧还蛮有意思的 但纯粹是拼手感的，玩了好久，终于搞了个135分拿了个第一名，没想到过一会就被朋友刷下去了，最高的也就200来分把，于是就想着要是开发个辅助就好了，于是简单想了一下最高游戏&lt;/p&gt;
&lt;p&gt;先来说下这个游戏的界面和规则：&lt;/p&gt;
&lt;p&gt;先看看界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/542536/201712/542536-20171230130017929-758624955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;规则：按住屏幕 按一定时间松开就可以跳跃，跳跃到前方的图案中得1分，图按中间得2分（连续多个中间累加2分，比如第一个2分 第二个4分 第三个6分 最高累计32分） 其它规则不说明了&lt;/p&gt;
&lt;p&gt;整理了下实现原理，其实挺简单的：就是计算黑人的底部到图案中间的距离，然后就调试时间，调好时间后就计算一个像素点的最佳时间X，然后以后每次测试黑人底部到图案中心的距离*X 就是最佳时间&lt;/p&gt;
&lt;p&gt;理论知识好了 就来实践把&lt;/p&gt;
&lt;p&gt;1、首先要获取手机屏幕的图片 并展示在winform程序里面&lt;br/&gt;2、让客户点击黑人底部和图案中心点（根据图片去获取这两个点 貌似有点困难 至少我现在的技术困难）&lt;/p&gt;
&lt;p&gt;3、模拟屏幕按下并按住多长时间&lt;/p&gt;
&lt;p&gt;获取屏幕图片我们可以根据安卓的adb.exe来获取，但我对这个东西不太熟悉，就百度了几个命令  1、截屏命令 2 传输命令 和模拟滑动命令&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot; as3&quot;&gt;
&lt;strong&gt;adb&lt;/strong&gt; shell /system/bin/screencap -p /sdcard/screenshot.png（保存到SDCard）
&lt;strong&gt;adb&lt;/strong&gt; pull /sdcard/screenshot.png d:/screenshot.png（保存到电脑）&lt;br/&gt;adb shell input swipe 250 250 300 300 100 滑动  前四个是坐标 最后一个是时间
&lt;/pre&gt;
&lt;p&gt;好了实现的方法也找到了 就码代码把&lt;/p&gt;
&lt;p&gt;执行adb命令的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_75df4a9b-5892-4099-bcb8-49479d4f836f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_75df4a9b-5892-4099-bcb8-49479d4f836f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_75df4a9b-5892-4099-bcb8-49479d4f836f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行adb命令
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;arguments&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ischeck&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; cmdAdb(&lt;span&gt;string&lt;/span&gt; arguments,&lt;span&gt;bool&lt;/span&gt; ischeck=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ischeck&amp;amp;&amp;amp;!&lt;span&gt;HasAndroid)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (Process p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Process())
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 p.StartInfo.FileName = Program.AdbPath;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @&quot;C:\Android\sdk\platform-tools\adb.exe&quot;;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 p.StartInfo.Arguments =&lt;span&gt; arguments;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 p.StartInfo.UseShellExecute = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 p.StartInfo.RedirectStandardInput = &lt;span&gt;true&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向标准输入   &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 p.StartInfo.RedirectStandardOutput = &lt;span&gt;true&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向标准输出   &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 p.StartInfo.RedirectStandardError = &lt;span&gt;true&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向错误输出   &lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 p.StartInfo.CreateNoWindow = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                p.Start();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 ret =&lt;span&gt; p.StandardOutput.ReadToEnd();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                p.Close();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;//图片点击事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce24dbd8-5753-4bea-8237-f82d7c7bcf37&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce24dbd8-5753-4bea-8237-f82d7c7bcf37&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce24dbd8-5753-4bea-8237-f82d7c7bcf37&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 黑人底部位置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Point Start;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 图案中心或者白点位置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Point End;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pictureBox1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; me =&lt;span&gt; ((System.Windows.Forms.MouseEventArgs)(e));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (me.Button==MouseButtons.Left)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下左键是黑人底部的坐标&lt;/span&gt;
&lt;span&gt;            {
                Start &lt;/span&gt;=&lt;span&gt; ((System.Windows.Forms.MouseEventArgs)(e)).Location;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (me.Button == MouseButtons.Right)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下右键键是黑人底部的坐标&lt;/span&gt;
&lt;span&gt;            {
                End &lt;/span&gt;=&lt;span&gt; ((System.Windows.Forms.MouseEventArgs)(e)).Location;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算两点直接的距离&lt;/span&gt;
                &lt;span&gt;double&lt;/span&gt; value = Math.Sqrt(Math.Abs(Start.X - End.X) * Math.Abs(Start.X - End.X) + Math.Abs(Start.Y - End.Y) * Math.Abs(Start.Y -&lt;span&gt; End.Y));
                Text &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;两点之间的距离：{0}，需要按下时间：{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, value, (&lt;span&gt;3.999022243950134&lt;/span&gt; * value).ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.999022243950134  这个是我通过多次模拟后得到 我这个分辨率的最佳时间&lt;/span&gt;
                cmdAdb(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shell input swipe 100 100 200 200 {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;3.999022243950134&lt;/span&gt; * value).ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;就这样核心代码就完成了 是不是赶紧很简单了。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/542536/201712/542536-20171230133031242-578632085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/542536/201712/542536-20171230133133273-1781108596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后放出效果把 ，（可惜被我女票手贱就截屏了，截屏的时候手碰了屏幕 导致按下去跳下去了，不然我是要刷到1W分的 哈哈）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/542536/201712/542536-20171230132422617-884136984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我估计这个分数 纯手玩 估计比较心碎把 哈哈  朋友圈就霸占第一名把  哈哈 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/542536/201712/542536-20171230132620851-1537804294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后给源码把  地址：&lt;a href=&quot;https://files.cnblogs.com/files/dotnet-org-cn/tiaotitiao.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/dotnet-org-cn/tiaotitiao.ra&lt;/a&gt;r&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 05:34:00 +0000</pubDate>
<dc:creator>中国.NET研究协会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-org-cn/p/8149693.html</dc:identifier>
</item>
<item>
<title>ABP .Net Core Entity Framework迁移使用MySql数据库 - DonaldTDZ</title>
<link>http://www.cnblogs.com/donaldtdz/p/8149598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donaldtdz/p/8149598.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、迁移说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ABP模板项目Entity Framework Core默认使用的是Sql Server，也很容易将数据库迁移到MySQL，步骤如下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、迁移MySQL步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、 下载项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请到 &lt;a href=&quot;http://aspnetboilerplate.com/Templates&quot; target=&quot;_blank&quot;&gt;http://aspnetboilerplate.com/Templates&lt;/a&gt; 下载一个新的项目，选择ASP.NET Core 2.x标签，Target Framework:选中.Net Core就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、 移除默认SQL Server相关包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在EntityFrameworkCore项目下移除包&lt;span&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/span&gt;、&lt;span&gt;Microsoft.EntityFrameworkCore.Design&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230125537648-47887587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、  添加MySql程序包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 添加程序包&lt;span&gt;Pomelo.EntityFrameworkCore.MySql&lt;/span&gt;、&lt;span&gt;Pomelo.EntityFrameworkCore.MySql.Design&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230125602976-1496327434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、  修改源代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改DbContextConfigurer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbpBasicDbContextConfigurer
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(DbContextOptionsBuilder&amp;lt;AbpBasicDbContext&amp;gt; builder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionString)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.UseSqlServer(connectionString);&lt;/span&gt;
&lt;span&gt;            builder.UseMySql(connectionString);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(DbContextOptionsBuilder&amp;lt;AbpBasicDbContext&amp;gt;&lt;span&gt; builder, DbConnection connection)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.UseSqlServer(connection);&lt;/span&gt;
&lt;span&gt;            builder.UseMySql(connection);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130241273-108682709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、  修改数据库链接字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在web项目配置文件appsettings.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&quot;ConnectionStrings&quot;: {
    //&quot;Default&quot;: &quot;Server=localhost; Database=AbpBasicDb; Trusted_Connection=True;&quot;
    &quot;Default&quot;: &quot;Server=localhost; port=3306; Database=AbpBasicDb; uid=root; pwd=****; Convert Zero Datetime=True&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130314867-1725372930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、  数据迁移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重新生成迁移文件&lt;/p&gt;
&lt;p&gt;在下载启动模板的时候，如果你选择了包含 Module Zero。这里会有一些迁移文件会包含在你的项目中，但是这些文件是为Sql Server迁移使用的。请打开 .EntityFramework 项目中的Migrations文件夹，然后删除这些迁移文件。迁移文件是以时间戳开始的。迁移文件的名字像这样：201506210746108_AbpZero_Initial。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130349742-1892751986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在删除所有的迁移文件后，选择你的 .Web 项目为开始项目，打开VS的包管理控制台，并在包管理控制台中选择 .EntityFramework 项目作为默认项目。然后在控制台中执行下面命令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Add-Migration &quot;AbpZero_Initial&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130916335-787099237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在你可以使用下面命令来创建数据库：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Update-Database&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130518382-476358510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的事情都已完成，检查 MySQL数据库已生产成功&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130553460-1344382035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、  完成MySQL迁移后运行浏览成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1011466/201712/1011466-20171230130628460-1160545399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 05:11:00 +0000</pubDate>
<dc:creator>DonaldTDZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donaldtdz/p/8149598.html</dc:identifier>
</item>
<item>
<title>通过 JS 判断页面是否有滚动条的简单方法 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/8117535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/8117535.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在写插件的过程中，需要使用 JS 判断是否有滚动条，搜了一下，大致方法都差不多，但都有些啰嗦，代码不够简洁。最终通过参考不同方法，写了一个比较简单的方法。在判断滚动条的同时也需要计算滚动条的宽度，通过本篇文章一并与大家分享。&lt;/p&gt;
&lt;h2&gt;为什么要判断滚动条&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/999445/201712/999445-20171230123125695-538561219.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;判断滚动条的需求在弹窗插件中用的较多，因为弹窗大多会添加 &lt;code&gt;overflow: hidden&lt;/code&gt; 的属性，如果页面比较长的话，添加这个属性之后页面会有晃动。&lt;/p&gt;
&lt;p&gt;为了增强用户体验，通过判断是否有滚动条而添加 &lt;code&gt;margin-left&lt;/code&gt; 属性以抵消 &lt;code&gt;overflow: hidden&lt;/code&gt; 之后的滚动条位置。&lt;/p&gt;
&lt;h2&gt;判断是否有滚动条的方法&lt;/h2&gt;
&lt;p&gt;其实只需要一行 JS 就可以，测试兼容 IE7&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hasScrollbar() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; document.body.scrollHeight &amp;gt; (window.innerHeight ||&lt;span&gt; document.documentElement.clientHeight);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般情况下，使用 &lt;code&gt;document.body.scrollHeight &amp;gt; window.innerHeight&lt;/code&gt; 就可以判断。&lt;/p&gt;
&lt;p&gt;但是在 IE7，IE8 中 &lt;code&gt;window.innerHeight&lt;/code&gt; 为 &lt;code&gt;underfined&lt;/code&gt;，所以为了兼容 IE7、IE8，需要使用 &lt;code&gt;document.documentElement.clientHeight&lt;/code&gt; 属性计算窗口高度。&lt;/p&gt;
&lt;h2&gt;计算滚动条宽度的方法&lt;/h2&gt;
&lt;p&gt;还是以弹窗为例，因为 IE 10 以上以及移动端浏览器的滚动条都是不占据页面宽度的透明样式（其中 IE 10 以上浏览器可以通过 CSS 属性还原原始的滚动条样式），所以为了进一步增强用户体验，我们还需要计算滚动条的宽度，根据情况添加合理的 &lt;code&gt;margin-left&lt;/code&gt; 数值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/999445/201712/999445-20171230123945054-1162711022.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算滚动条宽度的方法比较简单，新建一个带有滚动条的 &lt;code&gt;div&lt;/code&gt; 元素，通过该元素的 &lt;code&gt;offsetWidth&lt;/code&gt; 和 &lt;code&gt;clientWidth&lt;/code&gt; 的差值即可获得，我在此借鉴 Magnific-popup 中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getScrollbarWidth() {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scrollDiv = document.createElement(&quot;div&quot;&lt;span&gt;);
    scrollDiv.style.cssText &lt;/span&gt;= 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;'&lt;span&gt;;
    document.body.appendChild(scrollDiv);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scrollbarWidth = scrollDiv.offsetWidth -&lt;span&gt; scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; scrollbarWidth;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;使用 JS 实现一个功能可能并不困难，但作为编程人员应该时刻思考如何更简单更优雅的实现这个功能，并且时刻以提升用户体验为原则。对于条件判断，也许十行的逻辑判断可能只需要一行，最近感受极为深刻，而且要善于使用三元表达式替代 &lt;code&gt;if..else&lt;/code&gt; 来精简代码。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 04:54:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nzbin/p/8117535.html</dc:identifier>
</item>
<item>
<title>HTML的三种布局：DIV+CSS、FLEX、GRID - 宁墨</title>
<link>http://www.cnblogs.com/ruchun/p/8149287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruchun/p/8149287.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Div+css布局&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是盒子模型，有W3C盒子模型，IE盒子模型。盒子模型由四部分组成margin、border、padding、content。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么区别这两种模型呢，区别在于w3c中的width是content的宽，IE的width是content+border+padding。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的可以看下面的图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;W3C盒子（标准盒子）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1305195/201712/1305195-20171230095248257-596764432.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;IE盒子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1305195/201712/1305195-20171230095258960-812040626.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;Flex弹性布局&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过使用display：flex；或者display：inline-flex；坏处就是不能再设置子元素的float、clear、vertical-align。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里面主要是在元素里建立主轴（main axis、横向的、水平的），交叉轴（cross axis、垂直的，竖向的）。主轴从左到右，左是main start，右是main end，之间是main size。交叉轴是从上到下，上是cross start，下是cross end，之间是cross size。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1305195/201712/1305195-20171230100355117-228714095.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就用这个为例子嘛：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&lt;br/&gt;　　&amp;lt;p class=&quot;item&quot;&amp;gt;1&amp;lt;/p&amp;gt;&lt;br/&gt;　　&amp;lt;p class=&quot;item&quot;&amp;gt;2&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;在父元素div.box中可以设置的属性有六个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.flex-direction：row | row-reverse | column | column-reverse;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：这个主要用于设置子元素的排列顺序。row表示横向排列，从左到右；row-reverse表示横向排列，从右到左；column表示竖向排列，从上到下；column-reverse表示竖向排列，从下到上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.flex-warp:nowarp | warp | warp-reverse;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：设置元素的换行，nowarp表示不换行；warp表示换行，按一般的规律换到下面去；warp-reverse表示换行，不过换行是换到这一行的上面去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.flex-flow&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：他是flex-direction和flex-warp的简写，默认值是row，nowarp。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.justify-content： flex-start | center | flex-end | space-between | space-around ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：元素在主轴上的对齐方式。 flex-start左对齐；center居中；flex-end右对齐；space-between两端对齐；space-around四周对齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.align-items: flex-start | center | flex-end | baseline | stretch ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：元素在交叉轴上的对齐方式。flex-start上对齐；center居中对齐； flex-end下对齐；baseline文字基线对齐；stretch没有高度或高度为auto时自动充满高度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.align-content：flex-start | center | flex-end | space-between | space-around | stretch；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：主轴和交叉轴同时出现时的对齐方式。flex-start左上角对齐；center中间对齐；flex-end右下角对齐；space-between两端对齐，轴线之间平均分布；space-around每根轴线两侧间隔线相等；stretch沿交叉轴方向填充。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子元素（div.item）的六个属性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.order：number ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：设置元素的排列顺序，数值越小越靠前，默认为0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.flex-grow：number；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释:元素放大的比例，默认为0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.flex-shrink：number；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：元素缩小比例，默认为1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.flex-basis：length | auto；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：元素占据的固定空间，默认auto。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.flex：none| auto | 其他值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：flex-grow、flex-shrink、flex-basis的简写，默认值为0，1，auto。none表示（0，0，auto），auto表示（1，1，auto）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.align-self：auto | flex-start | center | flex-end | baseline | baseline | stretch；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：允许单个元素与其他元素不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示基础呢个父元素的align-items若无父元素，则等同于stretch。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我贴一个我自己的例子嘛：（主要是通过写骰子里面的圆点的位置来练习的）&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;style&amp;gt;&lt;br/&gt;/*基本的元素样子*/&lt;br/&gt;.box{&lt;br/&gt;width: 300px;&lt;br/&gt;height: 300px;&lt;br/&gt;border: 1px solid red;&lt;br/&gt;margin: 15px auto;&lt;br/&gt;background-color: gainsboro;&lt;br/&gt;}&lt;br/&gt;.item{&lt;br/&gt;background-color: fuchsia;&lt;br/&gt;width: 60px;&lt;br/&gt;height: 60px;&lt;br/&gt;border-radius: 30px;&lt;br/&gt;margin: 15px;&lt;br/&gt;border: 1px solid black;&lt;br/&gt;text-align: center;&lt;br/&gt;line-height: 60px;&lt;br/&gt;font-size: 18px;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&lt;br/&gt;&amp;lt;p class=&quot;item&quot;&amp;gt;1&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p class=&quot;item&quot;&amp;gt;2&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!--flex样式--&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;style&amp;gt;&lt;br/&gt;.box{&lt;br/&gt;display:flex;&lt;br/&gt;}&lt;br/&gt;/*1*/&lt;br/&gt;/*.box{&lt;br/&gt;display:flex;&lt;br/&gt;}*/&lt;br/&gt;/*2*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: center;&lt;br/&gt;}*/&lt;/p&gt;&lt;p&gt;/*3*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: flex-end;&lt;br/&gt;}*/&lt;br/&gt;/*4*/&lt;br/&gt;/*.box{&lt;br/&gt;align-items: center;&lt;br/&gt;}*/&lt;br/&gt;/*5*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: center;&lt;br/&gt;}&lt;br/&gt;.item{&lt;br/&gt;align-self: center;&lt;br/&gt;}*/&lt;br/&gt;/*或者*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: center;&lt;br/&gt;align-items: center;&lt;br/&gt;}*/&lt;br/&gt;/*6*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: flex-end;&lt;br/&gt;align-items: center;&lt;br/&gt;}*/&lt;br/&gt;/*7*/&lt;br/&gt;/*.box{&lt;br/&gt;align-items: flex-end;&lt;br/&gt;}*/&lt;br/&gt;/*8*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: center;&lt;br/&gt;align-items: flex-end;&lt;br/&gt;}*/&lt;br/&gt;/*9*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: flex-end;&lt;br/&gt;align-items: flex-end;&lt;br/&gt;}*/&lt;br/&gt;/*12*/&lt;/p&gt;&lt;p&gt;/*13*/&lt;br/&gt;/*.box{&lt;br/&gt;flex-direction: row;&lt;br/&gt;justify-content: space-between;&lt;br/&gt;}*/&lt;br/&gt;/*14*/&lt;br/&gt;/*.box{&lt;br/&gt;flex-direction: column;&lt;br/&gt;}*/&lt;br/&gt;/*15*/&lt;br/&gt;/*.box{}&lt;br/&gt;.item:nth-child(2){&lt;br/&gt;align-self: center;&lt;br/&gt;}*/&lt;br/&gt;/*16*/&lt;br/&gt;/*.box{&lt;br/&gt;flex-direction: row;&lt;br/&gt;align-items: center;&lt;br/&gt;justify-content: space-between;&lt;br/&gt;}&lt;br/&gt;.item:nth-child(1){&lt;br/&gt;align-self: flex-start;&lt;br/&gt;}*/&lt;br/&gt;/*17*/&lt;br/&gt;/*.box{&lt;br/&gt;flex-direction: column;&lt;br/&gt;align-content: space-between;&lt;br/&gt;}*/&lt;br/&gt;/*18*/&lt;br/&gt;/*.box{&lt;br/&gt;align-items: center;&lt;br/&gt;}&lt;br/&gt;.item:nth-child(1){&lt;br/&gt;align-self: flex-start;&lt;br/&gt;}&lt;br/&gt;.item:nth-child(2){&lt;br/&gt;align-self: flex-end;&lt;br/&gt;}*/&lt;br/&gt;/*或者*/&lt;br/&gt;/*.box{&lt;br/&gt;align-items: flex-end;&lt;br/&gt;}&lt;br/&gt;.item:nth-child(1){&lt;br/&gt;align-self: flex-start;&lt;br/&gt;}*/&lt;br/&gt;/*19*/&lt;br/&gt;/*.box{&lt;br/&gt;justify-content: space-between;&lt;br/&gt;}&lt;br/&gt;.item:nth-child(2){&lt;br/&gt;align-self: flex-end;&lt;br/&gt;}*/&lt;/p&gt;&lt;p&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;Grid网格布局&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过display：grid；或者display：inline-grid；网格线将元素分成一个一个的小格子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1305195/201712/1305195-20171230114514773-1852440951.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如图，每一条线都是网格线，水平的网格线从上到下一次是网格线1、网格线2、网格线3；垂直的网格线是网格线1、网格线2、网格线3、网格线4。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给元素划分网格父元素会使用到如下的属性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.grid-temlate-columns：number/perecent；划分列。可以有多个值（可以是具体的100px也可以是百分比），每一个值代表一列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.grin-template-rows：number/percent；划分行。与划分列的规则一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子元素可以独占一个网格也可以占多个网格，属性设置如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.grid-columns-start：number；元素从哪个网格线列开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.grid-columns-end：number；元素到哪个网格线列结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.grid-row-start：元素从哪个网格线行开始；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.grid-row-end：元素从哪个网格行结束；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1~4这几个属性就相当于设置元素的跨几行、跨几列这样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是我自己写的例子，仅供参考哦：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;style&amp;gt;&lt;br/&gt;.warpper{&lt;br/&gt;display: grid;&lt;br/&gt;border: 3px solid aquamarine;&lt;br/&gt;text-align: center;&lt;br/&gt;grid-template-columns: 100px 100px 100px;&lt;br/&gt;grid-template-rows: 100px 100px 100px;&lt;br/&gt;}&lt;br/&gt;div:nth-child(1) {&lt;br/&gt;background-color: firebrick;&lt;br/&gt;}&lt;br/&gt;div:nth-child(2) {&lt;br/&gt;background-color: forestgreen;&lt;br/&gt;}&lt;br/&gt;div:nth-child(3) {&lt;br/&gt;background-color: fuchsia;&lt;br/&gt;}&lt;br/&gt;div:nth-child(4) {&lt;br/&gt;background-color: cornflowerblue;&lt;br/&gt;}&lt;br/&gt;div:nth-child(5) {&lt;br/&gt;background-color: gold;&lt;br/&gt;}&lt;br/&gt;div:nth-child(6) {&lt;br/&gt;background-color: greenyellow;&lt;br/&gt;}&lt;br/&gt;.item1{&lt;br/&gt;grid-column-start: 1;&lt;br/&gt;grid-column-end: 3;&lt;br/&gt;}&lt;br/&gt;.item3{&lt;br/&gt;grid-row-start: 2;&lt;br/&gt;grid-row-end: 4;&lt;br/&gt;}&lt;br/&gt;.item4{&lt;br/&gt;grid-column-start: 2;&lt;br/&gt;grid-column-end: 4;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;div class=&quot;warpper&quot;&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item1&quot;&amp;gt;1&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item2&quot;&amp;gt;2&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item3&quot;&amp;gt;3&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item4&quot;&amp;gt;4&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item5&quot;&amp;gt;5&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;item6&quot;&amp;gt;6&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;以上就是我自己对与HTML中的三种布局的认识，有不足的地方还请各位帮我指出来，这样下次就会多加注意啦！！！谢谢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想我应该把我自己参考学习的博客贴出来的，可是不知道怎么弄，我再研究下，这样下一篇就可以贴出来&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 04:10:00 +0000</pubDate>
<dc:creator>宁墨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ruchun/p/8149287.html</dc:identifier>
</item>
</channel>
</rss>