<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>zookeeper环境配置 - 薄点</title>
<link>http://www.cnblogs.com/songweideboke/p/9704289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songweideboke/p/9704289.html</guid>
<description>
&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;一，下载与解压&lt;/p&gt;
&lt;p&gt;zookeeper 下载地址&lt;/p&gt;
&lt;p&gt;&lt;span&gt;：&lt;/span&gt;http://www.apache.org/dyn/closer.cgi/zookeeper/&lt;/p&gt;
&lt;p&gt;下载以后通过SerureCRT的sftp工具解压上传到指定的虚拟机文件目录的地址下&lt;/p&gt;

&lt;p&gt;                                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925203525024-428606208.bmp&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传完毕以后可以在指定的目录下解压&lt;/p&gt;

&lt;p&gt;                                                &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925204917824-798238815.bmp&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里复制粘贴CRT右键会和我的飞秋上的截图工具冲突，导致下图情况（关闭 飞秋截图即可解决）：&lt;/p&gt;
&lt;p&gt;                                &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925205123535-624209348.bmp&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二， zookeeper 配置&lt;/p&gt;
&lt;p&gt;        1，先在解压文件后的文件zookeeper-3.4.10中创建data文件夹 ，用来存放开启zookeeper时的临时连接文件，连接报错文件和myid文件。&lt;/p&gt;

&lt;p&gt;                                                           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925210027104-312411006.bmp&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                                          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925210048053-1602761924.bmp&quot; alt=&quot;300&quot; width=&quot;489&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;


&lt;p&gt;        2，&lt;span&gt;在&lt;/span&gt;conf&lt;span&gt;目录下创建一个配置文件&lt;/span&gt;&lt;span&gt;zoo.cfg，会有一个zoo作为参考。（创建完zoo.cfg 删除参考即可）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      zoo.cfg文件内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      tickTime=2000                                            #tickTime&lt;span&gt;：发送心跳的间隔时间，单位：毫秒&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      dataDir=/home/zookeeper-3.4.10/data/     #zookeeper&lt;span&gt;保存数据的目录。&lt;/span&gt;&lt;span&gt;必须新建一个目录,建议在&lt;/span&gt;zookeeper/data/&lt;span&gt;，里面存放&lt;/span&gt;&lt;span&gt;myid&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      dataLogDir=/home/zookeeper-3.4.10/dataLog     &lt;/p&gt;

&lt;p&gt;      clientPort=2181                                          #&lt;span data-mce-=&quot;&quot;&gt;客户端连接 Zookeeper &lt;span data-mce-=&quot;&quot;&gt;服务器的端口, &lt;span data-mce-=&quot;&quot;&gt;Zookeeper &lt;span data-mce-=&quot;&quot;&gt;会监听这个端口，接受客户的访问请求。最好&lt;span data-mce-=&quot;&quot;&gt;一台客户端机器配一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      initLimit=5                                                  #&lt;span&gt;这个配置项是用来配置&lt;/span&gt; Zookeeper &lt;span&gt;接受客户端（这里所说的客户端不是用户连接&lt;/span&gt; &lt;span&gt;Zookeeper&lt;/span&gt; &lt;span&gt;服务器的客户端，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      syncLimit=2                                               #&lt;span&gt;这个配置项标识&lt;/span&gt; Leader &lt;span&gt;与&lt;/span&gt; &lt;span&gt;Follower&lt;/span&gt; &lt;span&gt;之间发送消息，请求和应答时间长度，最长不能超过多少个&lt;/span&gt; &lt;span&gt;tickTime&lt;/span&gt; &lt;span&gt;的时间长度，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      server.1=192.168.184.131:2888:3888                              # server.n     表示第几号服务器    nserver.1  与  myid中的数字相对应&lt;br/&gt;      server.2=192.168.184.133:2888:3888                              #192.168.184.133  为对应服务器的ip地址   &lt;br/&gt;      server.3=192.168.184.134:2888:3888                              #2888  &lt;span&gt;表示&lt;/span&gt;&lt;span&gt;的是这个服务器与集群中的&lt;/span&gt; Leader &lt;span&gt;服务器交换信息的端口；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三 ， 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1，测试启动zookeeper&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            没有配置环境变量时，在安装文件的bin目录下 :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 ./zkServer.sh start/stop&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            启动成功时会有：&lt;/span&gt;&lt;span&gt;显示：&lt;/span&gt;Starting zookeeper ... STARTED 表示启动成功&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    2，测试启动客户端      &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             没有配置环境变量时，在安装文件的bin目录下 ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                  ./zkCli.sh    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             启动成功时会有：&lt;/span&gt;WATCHER::&lt;/p&gt;
&lt;p&gt;                                             WatchedEvent state:SyncConnected type:None path:null&lt;/p&gt;
&lt;p&gt;                                             [zk: localhost:2181(CONNECTED) 0]&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  3，配置环境变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               在 vi /etc/proflie 添加，如图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1474168/201809/1474168-20180925234051180-1403419389.bmp&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 25 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>薄点</dc:creator>
<og:description>恢复内容开始 一，下载与解压 zookeeper 下载地址 ：http://www.apache.org/dyn/closer.cgi/zookeeper/ 下载以后通过SerureCRT的sftp工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songweideboke/p/9704289.html</dc:identifier>
</item>
<item>
<title>parrotsec 和 kali安装系统的时候出现“executing grub-install dummy”的解决方案 - Ritte</title>
<link>http://www.cnblogs.com/ritte/p/9704292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ritte/p/9704292.html</guid>
<description>&lt;p&gt;在物理机的环境下安装系统出现点问题，弄了好一会才弄出解决方法&lt;/p&gt;
&lt;p&gt;1、parrot和kali安装的时候出现了无efi分区不能继续的问题，要知道我之前安装的时候一直都是\ ; 内存; \home三个分区搞定，然后我一直以为是我刻盘的问题，这里其实解决方法很简单，他要什么分区你分个什么分区给他就是，分个500m分区挂载到efi下就好了&lt;/p&gt;
&lt;p&gt;2、安装的时候还出现了“executing grub-install dummy 的情况，这的解决方法贴到下面&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
可以跳过安装引导的这一步，然后重启通过U盘live启动之后，进入系统安装如下命令执行
sudo mount /dev/sda* /mnt
这里的星号是你自己的“/”目录分区，我的是/dev/sda2/ 你的自己找
mount --bind /dev /mnt/dev
mount --bind /proc /mnt/proc
mount --bind /sys /mnt/sys
mount /dev/sda+ /mnt/boot/efi
这里的加号是你的efi分区，我的是 /dev/sda1/ 你的自己找
mount -o remount,rw /dev/sda+ /mnt/boot/efi
mkdir /mnt/hostrun
mount --bind /run /mnt/hostrun
chroot /mnt
mkdir /run/lvm
mount --bind /hostrun/lvm /run/lvm
grub-install /dev/sda
update-grub
exit
umount /mnt/dev
umount /mnt/proc
umount /mnt/sys
umount /mnt/boot/efi
umount /mnt/hostrun
umount /mnt/run/lvm
umount /mnt

使用fdisk -l命令来查看所有分区
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、reboot重启拔掉U盘即可。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>Ritte</dc:creator>
<og:description>在物理机的环境下安装系统出现点问题，弄了好一会才弄出解决方法 1、parrot和kali安装的时候出现了无efi分区不能继续的问题，要知道我之前安装的时候一直都是\ ; 内存; \home三个分区搞定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ritte/p/9704292.html</dc:identifier>
</item>
<item>
<title>44个javascript 变态题解析 - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/9704252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/9704252.html</guid>
<description>&lt;p&gt;原题来自: &lt;a href=&quot;http://javascript-puzzlers.herokuapp.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;javascript-puzzlers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;读者可以先去做一下感受感受. 当初笔者的成绩是 21/44…&lt;/p&gt;
&lt;p&gt;当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了….&lt;/p&gt;
&lt;p&gt;不过, 对于基础知识的理解是深入编程的前提. 让我们一起来看看这些变态题到底变态不变态吧!&lt;/p&gt;
&lt;h2 id=&quot;第1题&quot;&gt;第1题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值&lt;/p&gt;
&lt;p&gt;其中回调函数接受三个参数 currentValue, index, arrary;&lt;/p&gt;
&lt;p&gt;而题目中, map只传入了回调函数–parseInt.&lt;/p&gt;
&lt;p&gt;其次, parseInt 只接受两个两个参数 string, radix(基数).&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).&lt;/li&gt;
&lt;li&gt;如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。&lt;/li&gt;
&lt;li&gt;如果字符串 string 以其它任何值开头，则基数是10 (十进制)。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;所以本题即问&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;parseInt('1', 0);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt('2', 1);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt('3', 2);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先后两者参数不合法.&lt;/p&gt;
&lt;p&gt;所以答案是 &lt;code&gt;[1, NaN, NaN]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第2题&quot;&gt;第2题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[typeof null, null instanceof Object]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;两个知识点:&lt;/p&gt;
&lt;p&gt;typeof 返回一个表示类型的字符串.&lt;/p&gt;
&lt;p&gt;instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.&lt;/p&gt;
&lt;p&gt;这个题可以直接看链接… 因为 &lt;code&gt;typeof null === 'object'&lt;/code&gt; 自语言之初就是这样….&lt;/p&gt;
&lt;p&gt;typeof 的结果请看下表:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;type         result&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Undefined   &quot;undefined&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Null        &quot;object&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Boolean     &quot;boolean&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Number      &quot;number&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;String      &quot;string&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Symbol      &quot;symbol&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Host object Implementation-dependent&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Function    &quot;function&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Object      &quot;object&quot;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以答案 &lt;code&gt;[object, false]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第3题&quot;&gt;第3题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arr.reduce(callback[, initialValue])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;reduce接受两个参数, 一个回调, 一个初始值.&lt;/p&gt;
&lt;p&gt;回调函数接受四个参数 &lt;code&gt;previousValue, currentValue, currentIndex, array&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;If the array is empty and no initialValue was provided, TypeError would be thrown.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以第二个表达式会报异常. 第一个表达式等价于 &lt;code&gt;Math.pow(3, 2) =&amp;gt; 9; Math.pow(9, 1) =&amp;gt;9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;an error&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第4题&quot;&gt;第4题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var val = 'smtg';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;两个知识点:&lt;/p&gt;
&lt;p&gt;简而言之 &lt;code&gt;+&lt;/code&gt; 的优先级 大于 &lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以原题等价于 &lt;code&gt;'Value is true' ? 'Somthing' : 'Nonthing'&lt;/code&gt; 而不是 &lt;code&gt;'Value is' + (true ? 'Something' : 'Nonthing')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;'Something'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第5题&quot;&gt;第5题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var name = 'World!';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(function () {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    if (typeof name === 'undefined') {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var name = 'Jack';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Goodbye ' + name);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } else {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Hello ' + name);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个相对简单, 一个知识点:&lt;/p&gt;
&lt;p&gt;在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。&lt;/p&gt;
&lt;p&gt;这个题目相当于&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var name = 'World!';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(function () {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var name;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    if (typeof name === 'undefined') {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        name = 'Jack';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Goodbye ' + name);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    } else {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Hello ' + name);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以答案是 &lt;code&gt;'Goodbye Jack'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第6题&quot;&gt;第6题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var END = Math.pow(2, 53);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var START = END - 100;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var count = 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;for (var i = START; i &amp;lt;= END; i++) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    count++;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(count);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一个知识点:&lt;/p&gt;
&lt;p&gt;&lt;del&gt;在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;补充: &lt;a href=&quot;https://github.com/jelly7723&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;@jelly7723&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。&lt;br/&gt;2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。&lt;br/&gt;9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第7题&quot;&gt;第7题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var ary = [0,1,2];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ary[10] = 10;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ary.filter(function(x) { return x === undefined;});&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案是 &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看一篇文章理解稀疏数组&lt;/p&gt;
&lt;p&gt;我们来看一下 Array.prototype.filter 的 polyfill:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;if (!Array.prototype.filter) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  Array.prototype.filter = function(fun/*, thisArg*/) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    'use strict';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    if (this === void 0 || this === null) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      throw new TypeError();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var t = Object(this);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var len = t.length &amp;gt;&amp;gt;&amp;gt; 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    if (typeof fun !== 'function') {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      throw new TypeError();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var res = [];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var thisArg = arguments.length &amp;gt;= 2 ? arguments[1] : void 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    for (var i = 0; i &amp;lt; len; i++) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      if (i in t) { // 注意这里!!!&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var val = t[i];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        if (fun.call(thisArg, val, i, t)) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;          res.push(val);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;      }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return res;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  };&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;0 in ary; =&amp;gt; true&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3 in ary; =&amp;gt; false&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10 in ary; =&amp;gt; true&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.&lt;/p&gt;
&lt;h2 id=&quot;第8题&quot;&gt;第8题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var two   = 0.2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var one   = 0.1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var eight = 0.8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var six   = 0.6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[two - one == one, eight - six == two]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;IEEE 754标准中的浮点数并不能精确地表达小数&lt;/p&gt;
&lt;p&gt;那什么时候精准, 什么时候不经准呢? 笔者也不知道…&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;[true, false]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第9题&quot;&gt;第9题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function showCase(value) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    switch(value) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case 'A':&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Case A');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case 'B':&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Case B');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case undefined:&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('undefined');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Do not know!');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;showCase(new String('A'));&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;两个知识点:&lt;/p&gt;
&lt;p&gt;switch 是严格比较, String 实例和 字符串不一样.&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var s_prim = 'foo';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var s_obj = new String(s_prim);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(typeof s_prim); // &quot;string&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(typeof s_obj);  // &quot;object&quot;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(s_prim === s_obj); // false&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案是 &lt;code&gt;'Do not know!'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第10题&quot;&gt;第10题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function showCase2(value) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    switch(value) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case 'A':&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Case A');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case 'B':&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Case B');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    case undefined:&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('undefined');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        break;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        console.log('Do not know!');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;showCase2(String('A'));&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;解释:&lt;br/&gt;&lt;code&gt;String(x) does not create an object but does return a string, i.e. typeof String(1) === &quot;string&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;'Case A'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第11题&quot;&gt;第11题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function isOdd(num) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return num % 2 == 1;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;function isEven(num) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return num % 2 == 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;function isSane(num) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return isEven(num) || isOdd(num);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var values = [7, 4, '13', -9, Infinity];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;values.map(isSane);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一个知识点&lt;/p&gt;
&lt;p&gt;此题等价于&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;7 % 2 =&amp;gt; 1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4 % 2 =&amp;gt; 0&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;'13' % 2 =&amp;gt; 1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;-9 % % 2 =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;Infinity % 2 =&amp;gt; NaN&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要注意的是 余数的正负号随第一个操作数.&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;[true, true, true, false, false]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第12题&quot;&gt;第12题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;parseInt(3, 8)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt(3, 2)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt(3, 0)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第一个题讲过了, 答案 &lt;code&gt;3, NaN, 3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第13题&quot;&gt;第13题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;Array.isArray( Array.prototype )&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一个知识点:&lt;/p&gt;
&lt;p&gt;一个鲜为人知的实事: &lt;code&gt;Array.prototype =&amp;gt; []&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;—&amp;gt; &lt;a href=&quot;https://github.com/renaesop/blog/issues/17&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;对JS原型的一些思考 by renaesop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答案: &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第14题&quot;&gt;第14题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = [0];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;if ([0]) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  console.log(a == true);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;} else {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&quot;wut&quot;);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;解析:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Boolean([0]) === true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[0] == true
&lt;ul&gt;&lt;li&gt;true 转换为数字 =&amp;gt; 1&lt;/li&gt;
&lt;li&gt;[0] 转化为数字失败, 转化为字符串 ‘0’, 转化成数字 =&amp;gt; 0&lt;/li&gt;
&lt;li&gt;0 !== 1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;答案: &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第15题&quot;&gt;第15题&lt;/h2&gt;
&lt;p&gt;[] 是Object, 两个 Object 不相等&lt;/p&gt;
&lt;p&gt;答案是 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第16题&quot;&gt;第16题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;'5' + 3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;'5' - 3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;两个知识点:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 用来表示两个数的和或者字符串拼接, &lt;code&gt;-&lt;/code&gt;表示两数之差.&lt;/p&gt;
&lt;p&gt;请看例子, 体会区别:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&amp;gt; '5' + 3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;'53'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 5 + '3'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;'53'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 5 - '3'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; '5' - 3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; '5' - '3'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;也就是说 &lt;code&gt;-&lt;/code&gt; 会尽可能的将两个操作数变成数字, 而 &lt;code&gt;+&lt;/code&gt; 如果两边不都是数字, 那么就是字符串拼接.&lt;/p&gt;
&lt;p&gt;答案是 &lt;code&gt;'53', 2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第17题&quot;&gt;第17题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1 + - + + + - + 1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里应该是(倒着看)&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1 + (a)  =&amp;gt; 2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a = - (b) =&amp;gt; 1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;b = + (c) =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;c = + (d) =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;d = + (e) =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;e = + (f) =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f = - (g) =&amp;gt; -1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;g = + 1   =&amp;gt; 1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以答案 &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第18题&quot;&gt;第18题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var ary = Array(3);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ary[0]=2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ary.map(function(elem) { return '1'; });&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;稀疏数组. 同第7题.&lt;/p&gt;
&lt;p&gt;题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.&lt;/p&gt;
&lt;p&gt;所以答案是 &lt;code&gt;[&quot;1&quot;, undefined × 2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里贴上 Array.prototype.map 的 polyfill.&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;Array.prototype.map = function(callback, thisArg) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var T, A, k;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        if (this == null) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            throw new TypeError(' this is null or not defined');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var O = Object(this);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var len = O.length &amp;gt;&amp;gt;&amp;gt; 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        if (typeof callback !== 'function') {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            throw new TypeError(callback + ' is not a function');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        if (arguments.length &amp;gt; 1) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            T = thisArg;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        A = new Array(len);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        k = 0;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        while (k &amp;lt; len) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            var kValue, mappedValue;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            if (k in O) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                kValue = O[k];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                mappedValue = callback.call(T, kValue, k, O);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                A[k] = mappedValue;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            k++;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        return A;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    };&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;第19题&quot;&gt;第19题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function sidEffecting(ary) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  ary[0] = ary[2];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;function bar(a,b,c) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  c = 10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  sidEffecting(arguments);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  return a + b + c;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;bar(1,1,1)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是一个大坑, 尤其是涉及到 ES6语法的时候&lt;/p&gt;
&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;首先 &lt;code&gt;The arguments object is an Array-like object corresponding to the arguments passed to a function.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也就是说 &lt;code&gt;arguments&lt;/code&gt; 是一个 &lt;code&gt;object&lt;/code&gt;, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.&lt;/p&gt;
&lt;p&gt;所以答案是 &lt;code&gt;21&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;然而!!!!!!&lt;/p&gt;
&lt;p&gt;当函数参数涉及到 &lt;code&gt;any rest parameters, any default parameters or any destructured parameters&lt;/code&gt; 的时候, 这个 arguments 就不在是一个 &lt;code&gt;mapped arguments object&lt;/code&gt; 了…..&lt;/p&gt;
&lt;p&gt;请看:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function sidEffecting(ary) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  ary[0] = ary[2];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;function bar(a,b,c=3) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  c = 10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  sidEffecting(arguments);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  return a + b + c;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;bar(1,1,1)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案是 &lt;code&gt;12&lt;/code&gt; !!!!&lt;/p&gt;
&lt;p&gt;请读者细细体会!!&lt;/p&gt;
&lt;h2 id=&quot;第20题&quot;&gt;第20题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var a = 111111111111111110000,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b = 1111;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a + b;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案还是 &lt;code&gt;111111111111111110000&lt;/code&gt;. 解释是 &lt;code&gt;Lack of precision for numbers in JavaScript affects both small and big numbers.&lt;/code&gt; 但是笔者不是很明白……………. 请读者赐教!&lt;/p&gt;
&lt;h2 id=&quot;第21题&quot;&gt;第21题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var x = [].reverse;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;x();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个题有意思!&lt;/p&gt;
&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 &lt;code&gt;window&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;补充:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;@stellar91 这个笔者实践了一下 发现 firefox 是 window, chrome 报错 &lt;code&gt;VM190:2 Uncaught TypeError: Array.prototype.reverse called on null or undefined(…)&lt;/code&gt; 可能是实现不同, 在 chrome 中应该是对调用者做了检查.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是 &lt;code&gt;window&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第22题&quot;&gt;第22题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;Number.MIN_VALUE &amp;gt; 0&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5217391304348&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/10081677wc&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;@10081677wc&lt;/a&gt;&lt;br/&gt;MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数），它的近似值为 5 x 10-324。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第23题&quot;&gt;第23题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[1 &amp;lt; 2 &amp;lt; 3, 3 &amp;lt; 2 &amp;lt; 1]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个题也还可以.&lt;/p&gt;
&lt;p&gt;这个题会让人误以为是 &lt;code&gt;2 &amp;gt; 1 &amp;amp;&amp;amp; 2 &amp;lt; 3&lt;/code&gt; 其实不是的.&lt;/p&gt;
&lt;p&gt;这个题等价于&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1 &amp;lt; 2 =&amp;gt; true;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;true &amp;lt; 3 =&amp;gt;  1 &amp;lt; 3 =&amp;gt; true;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3 &amp;lt; 2 =&amp;gt; false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;false &amp;lt; 1 =&amp;gt; 0 &amp;lt; 1 =&amp;gt; true;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案是 &lt;code&gt;[true, true]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第24题&quot;&gt;第24题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;// the most classic wtf&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2 == [[[2]]]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个题我是猜的. 我猜的 &lt;code&gt;true&lt;/code&gt;, 至于为什么…..&lt;/p&gt;
&lt;p&gt;&lt;code&gt;both objects get converted to strings and in both cases the resulting string is &quot;2&quot;&lt;/code&gt; 我不能信服…&lt;/p&gt;
&lt;h2 id=&quot;第25题&quot;&gt;第25题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;3.toString()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3..toString()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3...toString()&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个题也挺逗, 我做对了 :) 答案是 &lt;code&gt;error, '3', error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你如果换一个写法就更费解了&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = 3;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a.toString()&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个答案就是 &lt;code&gt;'3'&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;为啥呢?&lt;/p&gt;
&lt;p&gt;因为在 js 中 &lt;code&gt;1.1&lt;/code&gt;, &lt;code&gt;1.&lt;/code&gt;, &lt;code&gt;.1&lt;/code&gt; 都是合法的数字. 那么在解析 &lt;code&gt;3.toString&lt;/code&gt; 的时候这个 &lt;code&gt;.&lt;/code&gt; 到底是属于这个数字还是函数调用呢? 只能是数字, 因为&lt;code&gt;3.&lt;/code&gt;合法啊!&lt;/p&gt;
&lt;h2 id=&quot;第26题&quot;&gt;第26题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(function(){&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  var x = y = 1;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(y);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;console.log(x);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案是 &lt;code&gt;1, error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 &lt;code&gt;ReferenceError&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第27题&quot;&gt;第27题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = /123/,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b = /123/;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a == b&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a === b&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;即使正则的字面量一致, 他们也不相等.&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;false, false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第28题&quot;&gt;第28题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = [1, 2, 3],&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b = [1, 2, 3],&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    c = [1, 2, 4]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a ==  b&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a === b&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a &amp;gt;   c&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a &amp;lt;   c&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;字面量相等的数组也不相等.&lt;/p&gt;
&lt;p&gt;数组在比较大小的时候按照字典序比较&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;false, false, false, true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第29题&quot;&gt;第29题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = {}, b = Object.prototype;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[a.prototype === b, Object.getPrototypeOf(a) === b]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;只有 Function 拥有一个 prototype 的属性. 所以 &lt;code&gt;a.prototype&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt; 返回一个具体对象的原型(该对象的内部&lt;code&gt;[[prototype]]&lt;/code&gt;值)&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;false, true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第30题&quot;&gt;第30题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function f() {}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var a = f.prototype, b = Object.getPrototypeOf(f);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a === b&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.&lt;/p&gt;
&lt;p&gt;f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.&lt;/p&gt;
&lt;p&gt;请看:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a === Object.getPrototypeOf(new f()) // true&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;b === Function.prototype // true&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第31题&quot;&gt;第31题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function foo() { }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var oldName = foo.name;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;foo.name = &quot;bar&quot;;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[oldName, foo.name]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案 &lt;code&gt;['foo', 'foo']&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;函数的名字不可变&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;第32题&quot;&gt;第32题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&quot;1 2 3&quot;.replace(/\d/g, parseInt)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str.replace(regexp|substr, newSubStr|function)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;match 首先是匹配的字符串&lt;/li&gt;
&lt;li&gt;p1, p2 …. 然后是正则的分组&lt;/li&gt;
&lt;li&gt;offset match 匹配的index&lt;/li&gt;
&lt;li&gt;string 整个字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于题目中的正则没有分组, 所以等价于问&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;parseInt('1', 0)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt('2', 2)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parseInt('3', 4)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;答案: &lt;code&gt;1, NaN, 3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第33题&quot;&gt;第33题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function f() {}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var parent = Object.getPrototypeOf(f);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f.name // ?&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;parent.name // ?&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;typeof eval(f.name) // ?&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;typeof eval(parent.name) //  ?&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;先说以下答案 &lt;code&gt;'f', 'Empty', 'function', error&lt;/code&gt; 这个答案并不重要…..&lt;/p&gt;
&lt;p&gt;这里第一小问和第三小问很简单不解释了.&lt;/p&gt;
&lt;p&gt;第二小问笔者在自己的浏览器测试的时候是 &lt;code&gt;''&lt;/code&gt;, 第四问是 &lt;code&gt;'undefined'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以应该是平台相关的. 这里明白 &lt;code&gt;parent === Function.prototype&lt;/code&gt; 就好了.&lt;/p&gt;
&lt;h2 id=&quot;第34题&quot;&gt;第34题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var lowerCaseOnly =  /^[a-z]+$/;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[lowerCaseOnly.test(null), lowerCaseOnly.test()]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;这里 test 函数会将参数转为字符串. &lt;code&gt;'nul'&lt;/code&gt;, &lt;code&gt;'undefined'&lt;/code&gt; 自然都是全小写了&lt;/p&gt;
&lt;p&gt;答案: &lt;code&gt;true, true&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第35题&quot;&gt;第35题&lt;/h2&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[,,,].join(&quot;, &quot;)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;[,,,] =&amp;gt; [undefined × 3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为javascript 在定义数组的时候允许最后一个元素后跟一个&lt;code&gt;,&lt;/code&gt;, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)&lt;/p&gt;
&lt;p&gt;答案: &lt;code&gt;&quot;, , &quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第36题&quot;&gt;第36题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = {class: &quot;Animal&quot;, name: 'Fido'};&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a.class&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个题比较流氓.. 因为是浏览器相关, &lt;code&gt;class&lt;/code&gt;是个保留字(现在是个关键字了)&lt;/p&gt;
&lt;p&gt;所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 &lt;code&gt;a['class']&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第37题&quot;&gt;第37题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = new Date(&quot;epoch&quot;)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.&lt;/p&gt;
&lt;p&gt;另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 &lt;code&gt;Invalid Date&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;Invalid Date&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第38题&quot;&gt;第38题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = Function.length,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b = new Function().length&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a === b&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们知道一个function(Function 的实例)的 &lt;code&gt;length&lt;/code&gt; 属性就是函数签名的参数个数, 所以 b.length == 0.&lt;/p&gt;
&lt;p&gt;另外 Function.length 定义为1……&lt;/p&gt;
&lt;p&gt;所以不相等…….答案 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第39题&quot;&gt;第39题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = Date(0);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var b = new Date(0);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var c = new Date();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[a === b, b === c, a === c]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还是关于Date 的题, 需要注意的是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果不传参数等价于当前时间.&lt;/li&gt;
&lt;li&gt;如果是函数调用 返回一个字符串.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;答案 &lt;code&gt;false, false, false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第40题&quot;&gt;第40题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var min = Math.min(), max = Math.max()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;min &amp;lt; max&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;有趣的是, Math.min 不传参数返回 &lt;code&gt;Infinity&lt;/code&gt;, Math.max 不传参数返回 &lt;code&gt;-Infinity&lt;/code&gt; 😆&lt;/p&gt;
&lt;p&gt;答案: &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第41题&quot;&gt;第41题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;22.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function captureOne(re, str) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  var match = re.exec(str);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  return match &amp;amp;&amp;amp; match[1];&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var numRe  = /num=(\d+)/ig,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    wordRe = /word=(\w+)/i,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    a1 = captureOne(numRe,  &quot;num=1&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    a2 = captureOne(wordRe, &quot;word=1&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    a3 = captureOne(numRe,  &quot;NUM=2&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[a1 === a2, a3 === a4]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;通俗的讲&lt;/p&gt;
&lt;p&gt;因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var myRe = /ab*/g;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var str = 'abbcdefabh';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;var myArray;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;while ((myArray = myRe.exec(str)) !== null) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  var msg = 'Found ' + myArray[0] + '. ';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  msg += 'Next match starts at ' + myRe.lastIndex;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  console.log(msg);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;// Found abb. Next match starts at 3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;// Found ab. Next match starts at 9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以 a1 = ‘1’; a2 = ‘1’; a3 = null; a4 = ‘2’&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;[true, false]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第42题&quot;&gt;第42题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;var a = new Date(&quot;2014-03-19&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    b = new Date(2014, 03, 19);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个….&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;a.getDay()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;b.getDay()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;a.getMonth()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;b.getMonth()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;都是套路!&lt;/p&gt;
&lt;p&gt;答案 &lt;code&gt;[false, false]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第43题&quot;&gt;第43题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;if ('http://giftwrapped.com/picture.jpg'.match('.gif')) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  'a gif file'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;} else {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  'not a gif file'&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;String.prototype.match 接受一个正则, 如果不是, 按照 &lt;code&gt;new RegExp(obj)&lt;/code&gt; 转化. 所以 &lt;code&gt;.&lt;/code&gt; 并不会转义&lt;br/&gt;那么 &lt;code&gt;/gif&lt;/code&gt; 就匹配了 /.gif/&lt;/p&gt;
&lt;p&gt;答案: &lt;code&gt;'a gif file'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;第44题&quot;&gt;第44题&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;function foo(a) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var a;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return a;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;function bar(a) {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var a = 'bye';&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return a;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[foo('hello'), bar('hello')]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在两个函数里, a作为参数其实已经声明了, 所以 &lt;code&gt;var a; var a = 'bye'&lt;/code&gt; 其实就是 &lt;code&gt;a; a ='bye'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以答案 &lt;code&gt;'hello', 'bye'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全部结束!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://webfly.com.cn/2018/09/25/44%E4%B8%AAjavascript-%E5%8F%98%E6%80%81%E9%A2%98%E8%A7%A3%E6%9E%90/&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 15:32:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<og:description>原题来自: javascript-puzzlers 读者可以先去做一下感受感受. 当初笔者的成绩是 21/44… 当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了…. 不过, 对于基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/9704252.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之七 ----- 享元模式和代理模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9704228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9704228.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9630850.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了结构型模式的组合模式和过滤器模式。本篇则来学习下结构型模式最后的两个模式， 享元模式和代理模式。&lt;/p&gt;
&lt;h2 id=&quot;享元模式&quot;&gt;享元模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用通俗的话来说就是进行共用。生活中也有一些例子，比如之前很火的共享单车，更早之前的图书馆，编程中经常用的String类，数据库连接池等等。当然，享元模式主要的目的是复用，如果该对象没有的话，就会进行创建。&lt;/p&gt;
&lt;p&gt;享元模式的角色主要分为三大类，抽象享元类、具体享元类以及享元工厂类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象享元类：所有具体享元类的超类或者接口，通过这个接口，可以接受并作用于外部专题。&lt;/li&gt;
&lt;li&gt;具体享元类：实现抽象享元类接口的功能并增加存储空间。&lt;/li&gt;
&lt;li&gt;享元工厂类：用来创建并管理抽象享元类对象，它主要用来确保合理地共享。每当接受到一个请求是，便会提供一个已经创建的抽象享元类对象或者新建一个。 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在 ，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其它的就不再多说，这里依旧使用一个简单的示例来加以说明。&lt;br/&gt;在我们以前读书的时候，经常会用到笔，其中铅笔又是最早接触的，我们最开始使用铅笔可能不是写字，而是进行画画。这里我们可以把笔当作一个抽象享元类，铅笔当作一个具体享元类，然后再创建一个享元工厂类，用于创建和管理，最后再由调用者决定用铅笔进行干嘛。&lt;/p&gt;
&lt;p&gt;首先，我们创建一个接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface Pen {
   void write();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再创建一个享元工厂类，指定需要内部需要做的事情。&lt;br/&gt;```&lt;br/&gt;class Penil implements Pen {&lt;br/&gt;private String name;&lt;br/&gt;private String something;&lt;br/&gt;private int i;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Penil(String name) {
    this.name = name;
    i++;
    System.out.println(name+&quot; 第:&quot;+i+&quot;次创建&quot;);
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getSomething() {
    return something;
}

public void setSomething(String something) {
    this.something = something;
}

@Override
public void write() {
    System.out.println(name+&quot; 用于铅笔  &quot;+something);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

 继而再创建一个工厂类，用于创建和管理。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;class PenFactory {&lt;br/&gt;private static final Map&amp;lt;String, Penil&amp;gt; map = new HashMap&amp;lt;String, Penil&amp;gt;();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Penil get(String name) {
    Penil penil = map.get(name);
    if (penil == null) {
        penil = new Penil(name);
        map.put(name, penil);
    }
    return penil;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
最后再来进行调用测试。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;public class FlyweightTest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;String names[] = { &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;虚无境&quot; };&lt;br/&gt;for (int i = 0; i &amp;lt; 8; i++) {&lt;br/&gt;Penil penil = PenFactory.get(names[i&amp;gt;3?i-4:i]);&lt;br/&gt;penil.setSomething(&quot;画了一条鱼&quot;);&lt;br/&gt;penil.write();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

**输出结果:**&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        张三 第:1次创建
        张三 用于铅笔  画了一条鱼
        李四 第:1次创建
        李四 用于铅笔  画了一条鱼
        王五 第:1次创建
        王五 用于铅笔  画了一条鱼
        虚无境 第:1次创建
        虚无境 用于铅笔  画了一条鱼
        张三 用于铅笔  画了一条鱼
        李四 用于铅笔  画了一条鱼
        王五 用于铅笔  画了一条鱼
        虚无境 用于铅笔  画了一条鱼&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
上述示例中，每个对象都使用了两次，但是每个对象都只是创建了一次而已，而享元模式核心的目的其实就是复用，只要我们理解了这一点，想必掌握该模式也就不在话下了。

**享元模式优点：**

&amp;gt; 极大的减少对象的创建，从而降低了系统的内存，提升了效率。

**享元模式缺点：**

&amp;gt; 提高了系统的复杂度，因为需要将状态进行分离成内部和外部，并且也使外部状态固有化，使得随着内部状态的变化而变化，会造成系统的混乱。


**使用场景：** 

&amp;gt; 系统有大量相似对象。


**注意事项：** 

&amp;gt; 需要注意划分外部状态和内部状态，否则可能会引起线程安全问题。  这些类必须有一个工厂对象加以控制。

**与单例模式比较**
&amp;gt; 虽然它们在某些方面很像，但是实际上却是不同的东西，单例模式的目的是限制创建多个对象，避免冲突，比如使用数据库连接池。而享元模式享元模式的目的是共享，避免多次创建耗费资源，比如使用String类。



## 代理模式
**简介**

&amp;gt; 代理模式于结构型模式，主要是通过一个类代表另一个类的功能。通常，我们创建具有现有对象的对象，以便向外界提供功能接口。

代理模式，如其名，也就是代理作用。 我们生活中也有不少示例，比如典型的代购，土豪专用的支票，Windows 里面的快捷方式，以及spring中的aop 等等。

代理模式主要由这三个角色组成，抽象角色、代理角色和真实角色。

 - 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
 - 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
 - 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。

代理模式又分为静态代理、动态代理。
 - 静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
 - 动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。


这里我们依旧用一个简单的示例来进行说明。
张三和李四是室友，某天，张三在寝室内玩游戏正带劲，感觉肚子饿了，本想下楼去吃饭的，但是想起李四可能快要回来，于是打电话给李四，让李四帮自己带份盒饭。这里的李四就扮演着代理者的作用。

### 静态代理
首先我们用`静态代理`来实现该功能。

这里实现相对而言较为简单，依旧是定义一个接口，然后定义一个真实的角色，实现该接口的功能，继而定义一个代理者，也实现该接口，但是添加该真实角色的对象进行相应的业务逻辑处理。
那么该`静态代理`代码实现如下:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interface Shopping {&lt;br/&gt;void buyFood();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;class ExecutePerson implements Shopping {&lt;br/&gt;private String name;&lt;br/&gt;public ExecutePerson(String name) {&lt;br/&gt;this.name = name;&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void buyFood() {
    System.out.println(name + &quot; 买东西&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;class ProxyPerson implements Shopping {&lt;br/&gt;private ExecutePerson ep;&lt;br/&gt;public ProxyPerson(ExecutePerson ep) {&lt;br/&gt;this.ep = ep;&lt;br/&gt;}&lt;br/&gt;@Override&lt;br/&gt;public void buyFood() {&lt;br/&gt;ep.buyFood();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public class ProxyTest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;String name = &quot;李四&quot;;&lt;br/&gt;Shopping shopping = new ProxyPerson(new ExecutePerson(name));&lt;br/&gt;shopping.buyFood();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
输入结果:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;李四 买东西&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在使用静态代理实现该功能之后，我们发现实现起来很简单，通过一个代理类就可以在不影响目标对象的前提进行扩展使用。但是我们也发现一个问题，如果我们不确定需要代理某个真实类的时候会比较麻烦，而且在类过多的时候，目标对象与代理对象都要维护，会使系统复杂度提升，维护起来也更加麻烦。
不过这时我们就可以使用`动态代理`来进行解决。

### 动态代理
所谓`动态代理`可以不必强行指定某个真实的角色，只需要在运行时决定就可以了。这里我们可以使用JDK中`java.lang.reflect`来进行开发。

JDK对动态代理提供了以下支持:

 - java.lang.reflect.Proxy 动态生成代理类和对象
 -  java.lang.reflect.InvocationHandler   
    - 可以通过invoke方法实现对真实角色的代理访问;
    -   每次通过Proxy生成代理类对象时都要指定对象的处理器对象.

那么废话不在多说，开始进行代码改造，之前的接口和真实者不需要更改，我们只需要更改代理者就可以了。
更改之后的代码如下:
   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;class ProxyPerson2 implements InvocationHandler {&lt;br/&gt;private Shopping shopping;&lt;br/&gt;private final String methodName = &quot;buyFood&quot;;&lt;br/&gt;public ProxyPerson2(Shopping shopping) {&lt;br/&gt;this.shopping = shopping;&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object result = null;
    if (methodName.equals(method.getName())) {
        result = method.invoke(shopping, args);
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
测试代码，注意这里调用和之前不同！
这里通过Proxy类中的newProxyInstance方法会动态生成一个代理类，然后进行调用。其中这三个参数的说明如下:

 - ClassLoader: 生成一个类, 这个类也需要加载到方法区中, 因此需要指定ClassLoader来加载该类
 -  Class[] interfaces: 要实现的接口
 -   InvocationHandler: 调用处理器

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;public class ProxyTest {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;Shopping shopping2 = (Shopping)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Shopping.class}, new ProxyPerson2(new ExecutePerson(name)));&lt;br/&gt;shopping2.buyFood();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、职责清晰。 2、高扩展性。 3、智能化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代理模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。&lt;br/&gt;2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。&lt;br/&gt;和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代理模式参考:&lt;br/&gt;http://www.runoob.com/design-pattern/proxy-pattern.html&lt;br/&gt;https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/8374046&lt;br/&gt;https://blog.csdn.net/zjf280441589/article/details/50411737&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很带感的电音！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 15:25:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9704228.html</dc:identifier>
</item>
<item>
<title>架构设计之服务限流 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/9593569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/9593569.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;32.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;服务限流概念&lt;/h2&gt;
&lt;p&gt;在介绍限流概念之前，我们先来聊聊身边有哪些限流，如果有在帝都的码农估计对限流是最深有感触的，帝都但凡开个XXX会议，各大地铁站都会限流。&lt;/p&gt;
&lt;p&gt;每年的双11都是剁手族的天堂，11月11号0点0几秒的时候，下面这些场景或许你曾经遇到过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201809/506684-20180910110852973-1150514847.png&quot; alt=&quot;架构设计之服务限流&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201809/506684-20180910110859212-1647253506.png&quot; alt=&quot;架构设计之服务限流&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这几年双11各大电商对并发的支持做的越来越好，这里只是借鉴双11刚推出之际，常常需要应对的一些问题。&lt;/p&gt;
&lt;p&gt;通过这两个场景，基本上服务限流的作用也就明白：&lt;/p&gt;
&lt;p&gt;「服务限流」其实是指当系统资源不够，不足以应对大量请求，即系统资源与访问量出现矛盾的时候，我们为了保证有限的资源能够正常服务，因此对系统按照预设的规则进行流量限制或功能限制的一种方法。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;为何要服务限流&lt;/h2&gt;
&lt;p&gt;再举一个我们生活中的例子：一些热门的旅游景点，往往会对每日的旅游参观人数有严格的限制，比如北京的故宫、欢乐谷等，每天只会卖出固定数目的门票，如果你去的晚了，可能当天的票就已经卖完了，当天就无法进去游玩了，即使你进去了，排队也能排到你怀疑人生。&lt;/p&gt;
&lt;p&gt;为什么旅游景点要做这样的限制呢？多卖一些门票多赚一些钱岂不是更好？&lt;/p&gt;
&lt;p&gt;其实对于旅游景点而言，她们也很无奈，因为景点的服务资源有限嘛，每日能服务的人数是有限的，一旦放开限制了，景点的工作人员就会不够用，卫生情况也得不到保障，安全也有隐患，超密集的人群也会严重的影响游客的体验。但由于景区名气大，来游玩的旅客络绎不绝，远超出了景区的承载能力，因此景区只好做出限制每日人员流量的举措。&lt;/p&gt;
&lt;p&gt;同理，在IT软件行业中，系统服务也是这样的。&lt;/p&gt;
&lt;p&gt;如果你的系统理论是时间单位内可服务100W用户，但是今天却突然来了300W用户，由于用户流量的随机性，如果不加以限流，很有可能这300W用户一下子就压垮了系统，导致所有人都得不到服务。&lt;/p&gt;
&lt;p&gt;因此为了保证系统至少还能为100W用户提供正常服务，我们需要对系统进行限流设计。&lt;/p&gt;
&lt;p&gt;有的人可能会想，既然会有300W用户来访问，那为啥系统不干脆设计成能足以支撑这么大量用户的集群呢？&lt;/p&gt;
&lt;p&gt;这是个好问题。如果系统是长期有300W的用户来访问，肯定是要做上述升级的，但是常常面临的情况是，系统的日常访问量就是100W，只不过偶尔有一些不可预知的特定原因导致的短时间的流量激增，这个时候，公司往往出于节约成本的考虑，不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;如何服务限流&lt;/h2&gt;
&lt;p&gt;对系统服务进行限流，一般有如下几个模式：&lt;/p&gt;
&lt;p&gt;1. 熔断：&lt;/p&gt;
&lt;p&gt;这个模式是需要系统在设计之初，就要把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。&lt;/p&gt;
&lt;p&gt;2. 服务降级：&lt;/p&gt;
&lt;p&gt;将系统的所有功能服务进行一个分级，当系统出现问题，需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。&lt;/p&gt;
&lt;p&gt;例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。&lt;/p&gt;
&lt;p&gt;3. 延迟处理：&lt;/p&gt;
&lt;p&gt;这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。&lt;/p&gt;
&lt;p&gt;4. 特权处理：&lt;/p&gt;
&lt;p&gt;这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。&lt;/p&gt;
&lt;p&gt;那在实际项目中，对访问流量的限制，可采用如下几种技术方法：&lt;/p&gt;
&lt;h4&gt;♛ 熔断技术&lt;/h4&gt;
&lt;p&gt;熔断的技术可以重点参考Netflix的开源组件&lt;a title=&quot;hystrix&quot; href=&quot;https://github.com/Netflix/Hystrix&quot; target=&quot;_blank&quot;&gt;hystrix&lt;/a&gt;的做法，主要有三个模块：熔断请求判断算法、熔断恢复机制、熔断报警。&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201809/506684-20180905173918872-2089164393.png&quot; alt=&quot;服务限流&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h4&gt;♛ 计数器方法&lt;/h4&gt;
&lt;p&gt;系统维护一个计数器，来一个请求就加1，请求处理完成就减1，当计数器大于指定的阈值，就拒绝新的请求。&lt;/p&gt;
&lt;p&gt;基于这个简单的方法，可以再延伸出一些高级功能，比如阈值可以不是固定值，是动态调整的。另外，还可以有多组计数器分别管理不同的服务，以保证互不影响等。&lt;/p&gt;
&lt;h4&gt;♛ 队列方法&lt;/h4&gt;
&lt;p&gt;就是基于FIFO队列，所有请求都进入队列，后端程序从队列中取出待处理的请求依次处理。&lt;/p&gt;
&lt;p&gt;基于队列的方法，也可以延伸出更多的玩法来，比如可以设置多个队列以配置不同的优先级。&lt;/p&gt;
&lt;h4&gt;♛ 令牌桶方法&lt;/h4&gt;
&lt;p&gt;首先还是要基于一个队列，请求放到队列里面。但除了队列以外，还要设置一个令牌桶，另外有一个脚本以持续恒定的速度往令牌桶里面放令牌，后端处理程序每处理一个请求就必须从桶里拿出一个令牌，如果令牌拿完了，那就不能处理请求了。我们可以控制脚本放令牌的速度来达到控制后端处理的速度，以实现动态流控。&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;注意事项&lt;/h2&gt;
&lt;p&gt;我们在做服务限流的时候，还是有一些原则和事项需要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;实时监控：&lt;/span&gt;系统必须要做好全链路的实时监控，才能保证限流的及时检测和处理。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;手动开关：&lt;/span&gt;除系统自动限流以外，还需要有能手动控制的开关，以保证随时都可以人工介入。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;限流的性能：&lt;/span&gt;限流的功能理论上是会在一定程度影响到业务正常性能的，因此需要做到限流的性能优化和控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;系统故障常常都是不可预测且难以避免的，因此作为系统设计师的我们，必须要提前预设各种措施，以应对随时可能的系统风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 25 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/9593569.html</dc:identifier>
</item>
<item>
<title>补习系列(10)-springboot 之配置读取 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9703855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9703855.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在早前的博客中曾经写过 Spring 程序通过 Bean 映射实现配置信息的读取。&lt;br/&gt;在SpringBoot 框架中读取配置的方式变得非常多样，这导致读者在搜寻资料时反而容易迷糊。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到底，SpringBoot 是按什么顺序加载配置？&lt;/li&gt;
&lt;li&gt;相应的，我们该选择什么样的方式去读取？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一配置样例&quot;&gt;一、配置样例&lt;/h2&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Compoment
public class BuildConfig{

   @Value(&quot;${buildinfo.version&quot;)
   private String version;

  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中，&lt;strong&gt;@Component&lt;/strong&gt; 将 BuildConfig 注册为 Bean ，&lt;br/&gt;接下来使用 &lt;strong&gt;@Value&lt;/strong&gt; 注解，将 配置中的 &lt;strong&gt;&lt;em&gt;buildinfo.version&lt;/em&gt;&lt;/strong&gt;键映射到了 version 字段上。&lt;/p&gt;
&lt;p&gt;我们都知道，通过 &lt;strong&gt;application.properties&lt;/strong&gt; 可以方便的配置一些属性。&lt;br/&gt;属性的值是支持变量替换的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myName=Lilei
myDesc=${myName} is a good man &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这点，是由 SpringBoot 自动生成的 PropertyPlaceholderConfigurer 对象实现的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;除了 上面所说 &lt;strong&gt;application.properties&lt;/strong&gt; 之外，还有什么途径？&lt;br/&gt;下面介绍如何注入配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二如何注入配置&quot;&gt;二、如何注入配置&lt;/h2&gt;
&lt;h3 id=&quot;缺省配置文件&quot;&gt;1. 缺省配置文件&lt;/h3&gt;
&lt;p&gt;类路径中 &lt;strong&gt;application.properties(yml)&lt;/strong&gt; 是默认的配置文件。&lt;br/&gt;此外如果启动应用时，当前目录中存在同名的配置文件，则以此优先。&lt;/p&gt;
&lt;p&gt;在此规则之下，SpringBoot 还能识别不同 profile下的配置，这将在后面篇幅中介绍。&lt;/p&gt;
&lt;h3 id=&quot;使用注解&quot;&gt;2. 使用注解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;@PropertySource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可指定属性配置文件的位置，&lt;br/&gt;样例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration

@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)

public class AppConfig {

     @Autowired

     Environment env;



     @Bean

     public TestBean testBean() {

         TestBean testBean = new TestBean();

         testBean.setName(env.getProperty(&quot;testbean.name&quot;));

         return testBean;

     }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@TestPropertySource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 @PropertySource 类似，该注解用于指定测试环境中的属性文件，其优先级高于 @PropertySource。&lt;/p&gt;
&lt;h3 id=&quot;启动参数&quot;&gt;3. 启动参数&lt;/h3&gt;
&lt;p&gt;以下的命令以指定参数启动 SpringBoot 应用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar application.jar --server.port=9000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;server.port&lt;/strong&gt; 值将被注入为环境属性值。&lt;/p&gt;
&lt;p&gt;而以下的命令还可以指定 配置文件的位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar application.jar --spring.config.location=/etc/xxx.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;strong&gt;spring.config.location&lt;/strong&gt;就是指的配置文件位置，&lt;br/&gt;默认情况下，SpringBoot 会从下面几路径找到配置文件：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;file:./config/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;file:./&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;classpath:/config/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;classpath:/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;还有..&quot;&gt;还有..&lt;/h3&gt;
&lt;p&gt;SpringBoot 注入配置的方式其实非常多，完整顺序如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;@TestPropertySource 注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;@SpringBootTest 注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;命令行参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;SPRING_APPLICATION_JSON 属性值(或环境变量)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Servlet 相关参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;JNDI 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;Java 系统属性 (System.getProperties())&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;操作系统环境变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;RandomValuePropertySource 随机属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;Jar包外部 application-{profile}.properties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Jar包内部 application-{profile}.properties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;Jar包外部 application.properties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Jar包内部 application.properties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;@PropertySource 注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;SpringApplication 默认值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;三如何读取配置&quot;&gt;三、如何读取配置&lt;/h2&gt;
&lt;h3 id=&quot;value-注解&quot;&gt;@Value 注解&lt;/h3&gt;
&lt;p&gt;如以下的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class AppConfig {
    
    @Value(&quot;${api.log.enabled:false}&quot;)
    private boolean apiLogEnabled;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了类型自动转换之外，通过&lt;strong&gt;:false&lt;/strong&gt;后缀可以指定默认值。&lt;/p&gt;
&lt;h3 id=&quot;environment-接口&quot;&gt;Environment 接口&lt;/h3&gt;
&lt;p&gt;Environment 是一个类似 Properties 的接口，用来获取属性非常方便。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class AppConfig {

    @Autowired
    private Environment environment;

    public String getApplicationId() {
        return this.environment.getProperty(&quot;application.id&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;configurationproperties-注解&quot;&gt;@ConfigurationProperties 注解&lt;/h3&gt;
&lt;p&gt;该注解一般用作前缀匹配，下面的代码摘自Mongodb&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;)
public class MongoProperties {

 /**
  * Mongo server host.
  */
 private String host;

 /**
  * Mongo server port.
  */
 private Integer port = null;

 /**
  * Database name.
  */
 private String database;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相应的 Mongodb 配置信息如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.data.mongodb.host=127.0.0.1
spring.data.mongodb.port=27017
spring.data.mongodb.database=xxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四不同环境中的配置&quot;&gt;四、不同环境中的配置&lt;/h2&gt;
&lt;p&gt;Spring 提供了 &lt;strong&gt;Profile&lt;/strong&gt; 机制用于管理不同环境的配置。&lt;/p&gt;
&lt;p&gt;配置内容可以是 &lt;strong&gt;Java Config&lt;/strong&gt;(对应@Component或@Configuration)，也可以是配置文件。&lt;br/&gt;如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@Profile(&quot;prod&quot;)
public class ProdConfiguration {

 // ...

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过@Profile注解可将代码配置关联到&lt;strong&gt;&lt;em&gt;某个配置环境&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在具体应用中，Profile的用途通常有二：&lt;/p&gt;
&lt;h3 id=&quot;区别开发测试发布环境&quot;&gt;1. 区别开发、测试、发布环境&lt;/h3&gt;
&lt;p&gt;对于dev、prod、test分别做不同的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//for dev
application-dev.properties

//for prod
application-prod.properties

//for test
application-test.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在 application.properties 指定启用的环境：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.profiles.active=dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以通过命令行指定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar app.jar --spring.profiles.active=prod&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明多配置文件&quot;&gt;2. 声明多配置文件&lt;/h3&gt;
&lt;p&gt;当内容过多时，可以将配置信息进行拆分，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;application-mongodb.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.data.mongodb.host=127.0.0.1
spring.data.mongodb.port=27017
spring.data.mongodb.username=xxx
spring.data.mongodb.password=xxx
spring.data.mongodb.database=xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;application-mail.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.mail.host=xxx
spring.mail.username=xxx
spring.mail.password=xxx

spring.mail.from=xxx
spring.mail.to=xxx
spring.mail.cc=xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在主配置文件指定包含关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.profiles.include=mongodb,mail&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html&lt;br/&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，如果觉得老司机的文章还不赖，请多多分享转发^-^&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 14:01:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 简介 在早前的博客中曾经写过 Spring 程序通过 Bean 映射实现配置信息的读取。 在SpringBoot 框架中读取配置的方式变得非常多样，这导致读者在搜寻资料时反而容易迷糊。 到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9703855.html</dc:identifier>
</item>
<item>
<title>堆、堆排序和优先队列的那些事 - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9703629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9703629.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章图片来源于 GitHub，网速不佳的朋友，请看&lt;a href=&quot;https://godbmw.com/passage/58&quot;&gt;《堆、堆排序和优先队列的那些事》&lt;/a&gt; 或者 来我的技术小站 &lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是堆&quot;&gt;1. 什么是堆？&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;堆是一种数据结构，它是一颗完全二叉树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;堆分为最大堆和最小堆：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最大堆：任意节点的值不大于其父亲节点的值。&lt;/li&gt;
&lt;li&gt;最小堆：任意节点的值不小于其父亲节点的值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如下图所示，就是个最大堆：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文中的代码实现是最大堆，最小堆的实现相似，不再冗赘。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;堆有什么用途&quot;&gt;2. 堆有什么用途？&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;堆最常用于优先队列以及相关动态问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优先队列指的是元素入队和出队的顺序与时间无关，既不是先进先出，也不是先进后出，而是根据元素的重要性来决定的。&lt;/p&gt;
&lt;p&gt;例如，操作系统的任务执行是优先队列。一些情况下，会有新的任务进入，并且之前任务的重要性也会改变或者之前的任务被完成出队。而这个出队、入队的过程利用堆结构，时间复杂度是&lt;code&gt;O(log2_n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现堆结构&quot;&gt;3. 实现堆结构&lt;/h3&gt;
&lt;h4 id=&quot;元素存储&quot;&gt;3.1 元素存储&lt;/h4&gt;
&lt;p&gt;堆中的元素存储，一般是借用一个数组：&lt;strong&gt;这个数组是从 1 开始计算的&lt;/strong&gt;。更方便子节点和父节点的表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/3.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;入堆&quot;&gt;3.2 入堆&lt;/h4&gt;
&lt;p&gt;入堆即向堆中添加新的元素，然后将元素移动到合适的位置，以保证堆的性质。&lt;/p&gt;
&lt;p&gt;在入堆的时候，需要&lt;code&gt;shift_up&lt;/code&gt;操作，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入 52 元素后，不停将元素和上方父亲元素比较，如果大于，则交换元素；直到达到堆顶或者小于等于父亲元素。&lt;/p&gt;
&lt;h4 id=&quot;出堆&quot;&gt;3.3 出堆&lt;/h4&gt;
&lt;p&gt;出堆只能弹出堆顶元素（最大堆就是最大的元素），调整元素为止保证堆的性质。&lt;/p&gt;
&lt;p&gt;在入堆的时候，需要&lt;code&gt;shift_down&lt;/code&gt;操作，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经取出了堆顶元素，然后将位于最后一个位置的元素放入堆顶（图中是&lt;code&gt;16&lt;/code&gt;被放入堆顶）。&lt;/p&gt;
&lt;p&gt;重新调整元素位置。此时元素应该和子节点比较，如果大于等于子节点或者没有子节点，停止比较；否则，选择子节点中最大的元素，进行交换，执行此步，直到结束。&lt;/p&gt;
&lt;h4 id=&quot;实现优化&quot;&gt;3.4 实现优化&lt;/h4&gt;
&lt;p&gt;在优化的时候，有两个部分需要做：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;swap&lt;/code&gt;操作应该被替换为：单次赋值，&lt;strong&gt;减少赋值次数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;入堆操作：空间不够的时候，应该开辟 2 倍空间，&lt;strong&gt;防止数组溢出&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;代码实现&quot;&gt;3.5 代码实现&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// MaxHeap.h
// Created by godbmw.com on 2018/9/19.
//

#ifndef MAXHEAP_MAXHEAP_H
#define MAXHEAP_MAXHEAP_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cassert&amp;gt;
#include &amp;lt;typeinfo&amp;gt;

using namespace std;

template &amp;lt;typename Item&amp;gt;
class MaxHeap {
private:
    Item* data; // 堆数据存放
    int count; // 堆目前所含数据量大小
    int capacity; // 堆容量大小

    void shift_up(int k) {
        Item new_item = this-&amp;gt;data[k]; // 保存新插入的值
//      如果新插入的值比父节点的值小, 则父节点的值下移, 依次类推, 直到到达根节点或者满足最大堆定义
        while( k &amp;gt; 1 &amp;amp;&amp;amp; this-&amp;gt;data[k/2] &amp;lt; new_item ) {
            this-&amp;gt;data[k] = this-&amp;gt;data[k/2];
            k /= 2;
        }
        this-&amp;gt;data[k] = new_item; // k就是 新插入元素 应该在堆中的位置
    }

    void shift_down(int k) {
        Item root = this-&amp;gt;data[1];
//        在完全二叉树中判断是否有左孩子即可
        while(2*k &amp;lt;= this-&amp;gt;count) {
            int j = k + k;
//            如果有右子节点，并且右节点 &amp;gt; 左边点
            if( j + 1 &amp;lt;= this-&amp;gt;count &amp;amp;&amp;amp; this-&amp;gt;data[j + 1] &amp;gt; this-&amp;gt;data[j]) {
                j += 1;
            }
//            root找到了堆中正确位置 k 满足堆性质, 跳出循环
            if(root &amp;gt;= this-&amp;gt;data[j]) {
                break;
            }
            this-&amp;gt;data[k] = this-&amp;gt;data[j];
            k = j;
        }
        this-&amp;gt;data[k] = root;
    }
public:
    MaxHeap(int capacity) {
        this-&amp;gt;data = new Item[capacity + 1]; // 堆中数据从索引为1的位置开始存储
        this-&amp;gt;count = 0;
        this-&amp;gt;capacity = capacity;
    }
//    将数组构造成堆：heapify
    MaxHeap(Item arr[], int n) {
        this-&amp;gt;data = new Item[n+1];
        this-&amp;gt;capacity = n;
        this-&amp;gt;count = n;
        for(int i = 0; i &amp;lt; n; i++) {
            this-&amp;gt;data[i + 1] = arr[i];
        }
        for(int i = n/2; i &amp;gt;= 1; i--) {
            this-&amp;gt;shift_down(i);
        }
    }
    ~MaxHeap(){
        delete[] this-&amp;gt;data;
    }
//    返回堆中元素个数
    int size() {
        return this-&amp;gt;count;
    }
//    返回布尔值：堆中是否为空
    bool is_empty() {
        return this-&amp;gt;count == 0;
    }

//    向堆中插入元素
    void insert(Item item) {
        // 堆空间已满, 开辟新的堆空间.
        // 按照惯例，容量扩大到原来的2倍
        if(this-&amp;gt;count &amp;gt;= this-&amp;gt;capacity) {
            this-&amp;gt;capacity = this-&amp;gt;capacity + this-&amp;gt;capacity; // 容量变成2倍
            Item* more_data = new Item[this-&amp;gt;capacity + 1]; // data[0] 不存放任何元素
            copy(this-&amp;gt;data, this-&amp;gt;data + this-&amp;gt;count + 1, more_data); // 将原先 data 中的有效数据拷贝到 more_data 中
            delete[] this-&amp;gt;data;
            this-&amp;gt;data = more_data;
        }
        this-&amp;gt;data[this-&amp;gt;count + 1] = item; // 插入堆尾部
        this-&amp;gt;shift_up(this-&amp;gt;count + 1); // 执行 shift_up，将新插入的元素移动到应该在的位置
        this-&amp;gt;count ++;
    }

//    取出最大值
    Item extract_max() {
        assert(this-&amp;gt;count &amp;gt; 0);
        Item ret = this-&amp;gt;data[1]; // 取出根节点
        swap(this-&amp;gt;data[1], this-&amp;gt;data[this-&amp;gt;count]); // 将根节点元素和最后元素交换
        this-&amp;gt;count --; // 删除最后一个元素
        this-&amp;gt;shift_down(1); // shift_down 将元素放到应该在的位置
        return ret;
    }
};
#endif //MAXHEAP_MAXHEAP_H&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;堆排序&quot;&gt;4. 堆排序&lt;/h3&gt;
&lt;p&gt;根据实现的&lt;code&gt;MaxHeap&lt;/code&gt;类，实现堆排序很简单：将元素逐步&lt;code&gt;insert&lt;/code&gt;进入堆，然后再&lt;code&gt;extract_max&lt;/code&gt;逐个取出即可。当然，这个建堆的平均时间复杂度是&lt;code&gt;O(n*log2_n)&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
void heap_sort1(T arr[], int n) {
    MaxHeap&amp;lt;T&amp;gt; max_heap = MaxHeap&amp;lt;T&amp;gt;(n);
    for(int i = 0; i &amp;lt; n; i++) {
        max_heap.insert(arr[i]);
    }
    for(int i = n -1; i &amp;gt;= 0; i--) {
        arr[i] = max_heap.extract_max();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细观察前面实现的构造函数，构造函数可以传入数组参数。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//    将数组构造成堆：heapify
MaxHeap(Item arr[], int n) {
    this-&amp;gt;data = new Item[n+1];
    this-&amp;gt;capacity = n;
    this-&amp;gt;count = n;
    for(int i = 0; i &amp;lt; n; i++) {
        this-&amp;gt;data[i + 1] = arr[i];
    }
    for(int i = n/2; i &amp;gt;= 1; i--) {
        this-&amp;gt;shift_down(i);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过程叫做&lt;code&gt;heapify&lt;/code&gt;,实现思路如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数组的值逐步复制到&lt;code&gt;this-&amp;gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从第一个非叶子节点开始，执行&lt;code&gt;shift_down&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重复第 2 步，直到堆顶元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种建堆方法的时间复杂度是: &lt;code&gt;O(n)&lt;/code&gt;。因此, 编写&lt;code&gt;heap_sort2&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//  建堆复杂度：O(N)
template &amp;lt;typename T&amp;gt;
void heap_sort2(T arr[], int n) {
    MaxHeap&amp;lt;T&amp;gt; max_heap = MaxHeap&amp;lt;T&amp;gt;(arr, n);
    for(int i = n -1; i &amp;gt;= 0; i--) {
        arr[i] = max_heap.extract_max();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面阐述的两种排序方法，借助实现的最大堆这个类，都需要在类中开辟&lt;code&gt;this-&amp;gt;data&lt;/code&gt;，空间复杂度为&lt;code&gt;O(n)&lt;/code&gt;。&lt;strong&gt;其实，借助&lt;code&gt;shift_down&lt;/code&gt;可以实现原地堆排序&lt;/strong&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 这里的 swap 操作并没有优化
// 请对比 MaxHeap 中的 shift_down 函数
template &amp;lt;typename T&amp;gt;
void __shift_down(T arr[], int n, int k) {
    while( 2*k + 1 &amp;lt; n) {
        int j = 2 * k + 1;
        if( j + 1 &amp;lt; n &amp;amp;&amp;amp; arr[j + 1] &amp;gt; arr[j]) {
            j += 1;
        }
        if(arr[k] &amp;gt;= arr[j]) {
            break;
        }
        swap(arr[k], arr[j]);
        k = j;
    }
}

//  原地堆排序
template &amp;lt;typename T&amp;gt;
void heap_sort3(T arr[], int n) {
    for(int i = (n -1)/2; i&amp;gt;=0; i--) {
        __shift_down(arr, n, i);
    }
    for(int i = n-1; i &amp;gt; 0; i--) {
        swap(arr[0], arr[i]);
        __shift_down(arr, i, 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;5. 测试&lt;/h3&gt;
&lt;h4 id=&quot;测试maxheap类&quot;&gt;5.1 测试&lt;code&gt;MaxHeap&lt;/code&gt;类&lt;/h4&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &quot;MaxHeap.h&quot;
#include &quot;SortHelper.h&quot;

#define HEAP_CAPACITY 10
#define MAX_NUM 100

using namespace std;

int main() {

    MaxHeap&amp;lt;int&amp;gt; max_heap = MaxHeap&amp;lt;int&amp;gt;(HEAP_CAPACITY);
    srand(time(NULL));
    for(int i = 0; i &amp;lt; HEAP_CAPACITY + 5; i++) { // 容量超出初始化时的容量。测试：自动
        max_heap.insert(rand() % MAX_NUM);
    }

    while( !max_heap.is_empty() ) {
        cout&amp;lt;&amp;lt; max_heap.extract_max() &amp;lt;&amp;lt; &quot; &quot;; // 控制台输出数据是从大到小
    }
    cout&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试堆排序&quot;&gt;5.2 测试堆排序&lt;/h4&gt;
&lt;p&gt;借助前几篇文章的&lt;code&gt;SortHelper.h&lt;/code&gt;封装的测试函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &quot;MaxHeap.h&quot;
#include &quot;SortHelper.h&quot;

#define HEAP_CAPACITY 10
#define MAX_NUM 100

using namespace std;

int main() {
    int n = 100000;
    int* arr = SortTestHelper::generateRandomArray&amp;lt;int&amp;gt;(n, 0, n);
    int* brr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
    int* crr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
    SortTestHelper::testSort&amp;lt;int&amp;gt;(arr, n, heap_sort1&amp;lt;int&amp;gt;, &quot;first heap_sort&quot;);
    SortTestHelper::testSort&amp;lt;int&amp;gt;(brr, n, heap_sort2&amp;lt;int&amp;gt;, &quot;second heap_sort&quot;);
    SortTestHelper::testSort&amp;lt;int&amp;gt;(crr, n, heap_sort3&amp;lt;int&amp;gt;, &quot;third heap_sort&quot;);
    delete[] arr;
    delete[] brr;
    delete[] crr;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 25 Sep 2018 13:23:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>文章图片来源于 GitHub，网速不佳的朋友，请看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9703629.html</dc:identifier>
</item>
<item>
<title>.NET Core部署中你不了解的框架依赖与独立部署 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9703460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9703460.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：https://www.cnblogs.com/yilezhu/p/9703460.html&lt;br/&gt;NET Core项目发布的时候你有没有注意到这两个选项呢？有没有纠结过框架依赖与独立部署到底有什么区别呢？如果有的话那么这篇文章可以参考下！&lt;br/&gt;为什么要写这篇文章呢？因为今天同事问我框架依赖与独立部署到底应该选哪个呢？有什么区别。印象中只知道框架依赖发布后文件比独立部署要小很多，然后就是独立部署不占用net core的共享资源，而框架依赖需要与其他net core程序共享net core的一些资源。感觉很模糊，所以查了下资料整理如下，希望对大家有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;依赖框架的部署-fdd&quot;&gt;依赖框架的部署 (FDD)&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;框架依赖的部署：顾名思义，依赖框架的部署 (FDD) 依赖目标系统上存在共享系统级版本的 .NET Core。 由于已存在 .NET Core，因此应用在 .NET Core 安装程序间也是可移植的。 应用仅包含其自己的代码和任何位于 .NET Core 库外的第三方依赖项。 FDD 包含可通过在命令行中使用 dotnet 实用程序启动的 .dll 文件。 例如，dotnet app.dll 就可以运行一个名为 app 的应用程序。&lt;br/&gt;对于 FDD，仅部署应用程序和第三方依赖项。 不需要部署 .NET Core，因为应用将使用目标系统上存在的 .NET Core 版本。 这是定目标到 .NET Core 的 .NET Core 和 ASP.NET Core 应用程序的默认部署模型。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;不需要提前定义 .NET Core 应用将在其上运行的目标操作系统。 因为无论什么操作系统，.NET Core 的可执行文件和库都是用通用的 PE 文件格式，因此，无论什么基础操作系统，.NET Core 都可执行应用。&lt;/li&gt;
&lt;li&gt;部署包很小。 只需部署应用及其依赖项，而无需部署 .NET Core 本身。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;许多应用都可使用相同的 .NET Core 安装，从而降低了主机系统上磁盘空间和内存使用量。&lt;/p&gt;
&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;仅当主机系统上已安装你设为目标的 .NET Core 版本或更高版本时，应用才能运行。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果不了解将来版本，.NET Core 运行时和库可能发生更改。 在极少数情况下，这可能会更改应用的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;独立部署-scd&quot;&gt;独立部署 (SCD)&lt;/h2&gt;
&lt;h3 id=&quot;定义-1&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;独立部署：与 FDD 不同，独立部署 (SCD) 不依赖目标系统上存在的共享组件。 所有组件（包括 .NET Core 库和 .NET Core 运行时）都包含在应用程序中，并且独立于其他 .NET Core 应用程序。 SCD 包括一个可执行文件（如 Windows 平台上名为 app 的应用程序的 app.exe），它是特定于平台的 .NET Core 主机的重命名版本，还包括一个 .dll 文件（如 app.dll），而它是实际的应用程序。&lt;br/&gt;对于独立部署，可以部署应用和所需的第三方依赖项以及生成应用所使用的 .NET Core 版本。 创建 SCD 不包括各种平台上的 .NET Core 本机依赖项，因此运行应用前这些依赖项必须已存在。&lt;br/&gt;从 NET Core 2.1 SDK（版本 2.1.300）开始，.NET Core 支持修补程序版本前滚。 在创建独立部署时，.NET Core 工具会自动包含你的应用程序所指向的 .NET Core 版本的最新服务的运行时。 （最新服务的运行时包括安全修补程序和其他 bug 修复程序。）服务的运行时不需要存在于你的生成系统上；它会从 NuGet.org 自动下载。&lt;br/&gt;FDD 和 SCD 部署使用单独的主机可执行文件，使你可以使用发布者签名为 SCD 签署主机可执行文件。&lt;/p&gt;
&lt;h3 id=&quot;优点-1&quot;&gt;优点&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;可以对与应用一起部署的 .NET Core 版本具有单独的控制权&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请放心，目标系统可以运行你的 .NET Core 应用，因为你提供的是应用将在其上运行的 .NET Core 版本&lt;/p&gt;
&lt;h3 id=&quot;缺点-1&quot;&gt;缺点&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;由于 .NET Core 包含在部署包中，因此必须提前选择为其生成部署包的目标平台&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;部署包相对较大，因为需要将 .NET Core 和应用及其第三方依赖项包括在内。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从.NET Core 2.0 开始，可以通过使用 .NET Core 全球化固定模式在 Linux 系统上减少大约 28 MB 的部署大小。 通常，Linux 上的 .NET Core 依赖于 ICU 库来实现全球化支持。 在固定模式下，库不包含在部署中，并且所有区域性的行为均类似于固定区域性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;向系统部署大量独立的 .NET Core 应用可能会使用大量磁盘空间，因为每个应用都会复制 .NET Core 文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实例演示-.net-core-应用的部署发布&quot;&gt;实例演示 .NET Core 应用的部署发布&lt;/h2&gt;
&lt;p&gt;上面已经说了，可以将 .NET Core 应用程序部署为依赖框架的部署或独立部署，前者包含应用程序二进制文件，但依赖目标系统上存在的 .NET Core，而后者同时包含应用程序和 .NET Core 二进制文件。&lt;/p&gt;
&lt;h3 id=&quot;不包含第三方依赖的框架依赖的部署&quot;&gt;不包含第三方依赖的框架依赖的部署&lt;/h3&gt;
&lt;ol readability=&quot;17&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为项目创建一个目录，并将其设为当前目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在命令行中，键入 dotnet new console 以创建新的 C# 控制台项目&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;在编辑器中打开 Program.cs 文件，然后使用下列代码替换自动生成的代码。 它会提示用户输入文本，并显示用户输入的个别词。 它使用正则表达式 &lt;code&gt;\w+&lt;/code&gt; 来将输入文本中的词分开。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Text.RegularExpressions;

namespace Applications.ConsoleApps
{
    public class ConsoleParser
    {
        public static void Main()
        {
            Console.WriteLine(&quot;Enter any text, followed by &amp;lt;Enter&amp;gt;:\n&quot;);
            String s = Console.ReadLine();
            ShowWords(s);
            Console.Write(&quot;\nPress any key to continue... &quot;);
            Console.ReadKey();
        }

        private static void ShowWords(String s)
        {
            String pattern = @&quot;\w+&quot;;
            var matches = Regex.Matches(s, pattern);
            if (matches.Count == 0)
            {
                Console.WriteLine(&quot;\nNo words were identified in your input.&quot;);
            }
            else
            {
                Console.WriteLine($&quot;\nThere are {matches.Count} words in your string:&quot;);
                for (int ctr = 0; ctr &amp;lt; matches.Count; ctr++)
                {
                    Console.WriteLine($&quot;   #{ctr,2}: '{matches[ctr].Value}' at position {matches[ctr].Index}&quot;);
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行 dotnet restore（请参阅注释）命令，还原项目中指定的依赖项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;dotnet build&lt;/code&gt;命令生成应用程序，或使用 &lt;code&gt;dotnet run&lt;/code&gt;命令生成并运行应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;完成程序调试和测试后，使用下列命令创建部署&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;dotnet publish -f netcoreapp2.1 -c Release&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将创建一个应用的发行版（而不是调试版）。 生成的文件位于名为“publish”的目录中，该目录位于项目的 bin 目录的子目录中。&lt;/p&gt;
&lt;p&gt;与应用程序的文件一起，发布过程将发出包含应用调试信息的程序数据库 (.pdb) 文件。 该文件主要用于调试异常。 可以选择不将其与应用程序的文件一起分布。 但是，如果要调试应用的发布版本，则应保存该文件。&lt;/p&gt;
&lt;p&gt;可以采用任何喜欢的方式部署完整的应用程序文件集。 例如，可以使用简单的 &lt;code&gt;copy&lt;/code&gt; 命令将其打包为 Zip 文件，或者使用选择的安装包进行部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装成功后，用户可通过使用 dotnet 命令或提供应用程序文件名（如 dotnet fdd.dll）来执行应用程序。&lt;br/&gt;除应用程序二进制文件外，安装程序还应捆绑共享框架安装程序，或在安装应用程序的过程中将其作为先决条件进行检查。 安装共享框架需要管理员/根访问权限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;包含第三方依赖项的依赖框架的部署&quot;&gt;包含第三方依赖项的依赖框架的部署&lt;/h3&gt;
&lt;p&gt;要使用一个或多个第三方依赖项来部署依赖框架的部署，需要这些依赖项都可供项目使用。 在运行 dotnet restore命令之前，还需执行额外两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;向 csproj 文件的 部分添加对所需第三方库的引用。 以下 部分包含 Json.NET 的依赖项（作为第三方库）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
  &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;10.0.2&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;如果尚未安装，请下载包含第三方依赖项的 NuGet 包。 若要下载该包，请在添加依赖项后执行 &lt;code&gt;dotnet restore&lt;/code&gt;命令。 因为依赖项在发布时已从本地 NuGet 缓存解析出来，因此它一定适用于你的系统。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;请注意，如果依赖框架的部署具有第三方依赖项，则其可移植性只与第三方依赖项相同。 例如，如果某个第三方库只支持 macOS，该应用将无法移植到 Windows 系统。 当第三方依赖项本身取决于本机代码时，也可能发生此情况。 Kestrel 服务器就是一个很好的示例，它需要 libuv 的本机依赖项。 当为具有此类第三方依赖项的应用程序创建 FDD 时，已发布的输出会针对每个本机依赖项支持（存在于 NuGet 包中）的运行时标识符 (RID) 包含一个文件夹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;不包含第三方依赖项的独立部署&quot;&gt;不包含第三方依赖项的独立部署&lt;/h3&gt;
&lt;p&gt;部署没有第三方依赖项的独立部署包括创建项目、修改 csproj 文件、生成、测试以及发布应用。 一个用 C# 编写的简单示例可说明此过程。 该示例演示如何使用命令行中的 dotnet 实用工具创建独立部署。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为项目创建一个目录，并将其设为当前目录。&lt;/li&gt;
&lt;li&gt;在命令栏行中，键入 &lt;code&gt;dotnet new console&lt;/code&gt;，在该目录中创建新的 C# 控制台项目&lt;/li&gt;
&lt;li&gt;在编辑器中打开 Program.cs 文件，然后使用下列代码替换自动生成的代码。 它会提示用户输入文本，并显示用户输入的个别词。 它使用正则表达式 &lt;code&gt;\w+&lt;/code&gt; 来将输入文本中的词分开。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Text.RegularExpressions;

namespace Applications.ConsoleApps
{
    public class ConsoleParser
    {
        public static void Main()
        {
            Console.WriteLine(&quot;Enter any text, followed by &amp;lt;Enter&amp;gt;:\n&quot;);
            String s = Console.ReadLine();
            ShowWords(s);
            Console.Write(&quot;\nPress any key to continue... &quot;);
            Console.ReadKey();
        }

        private static void ShowWords(String s)
        {
            String pattern = @&quot;\w+&quot;;
            var matches = Regex.Matches(s, pattern);
            if (matches.Count == 0)
            {
                Console.WriteLine(&quot;\nNo words were identified in your input.&quot;);
            }
            else
            {
                Console.WriteLine($&quot;\nThere are {matches.Count} words in your string:&quot;);
                for (int ctr = 0; ctr &amp;lt; matches.Count; ctr++)
                {
                    Console.WriteLine($&quot;   #{ctr,2}: '{matches[ctr].Value}' at position {matches[ctr].Index}&quot;);
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 csproj 文件（该文件用于定义应用的目标平台）的 部分中创建 标记，然后指定每个目标平台的运行时标识符 (RID)。 请注意，还需要添加分号来分隔 RID。 请查看&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/rid-catalog&quot;&gt;运行时标识符目录&lt;/a&gt;，获取运行时标识符列表。&lt;br/&gt;例如，以下 部分表明应用在 64 位 Windows 10 操作系统和 64 位 OS X 10.11 版本的操作系统上运行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;RuntimeIdentifiers&amp;gt;win10-x64;osx.10.11-x64&amp;lt;/RuntimeIdentifiers&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意， 元素可能出现在 csproj 文件的任何 中。 本节后面部分将显示完整的示例 csproj 文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;运行 &lt;code&gt;dotnet restore&lt;/code&gt;命令，还原项目中指定的依赖项。&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;dotnet restore&lt;/code&gt;（请参阅注释）命令，还原项目中指定的依赖项。特别是如果应用面向 Linux，则可以通过利用全球化固定模式来减小部署的总规模。 全球化固定模式适用于不具有全局意识且可以使用固定区域性的格式约定、大小写约定以及字符串比较和排序顺序的应用程序。要启用固定模式，右键单击“解决方案资源管理器”中的项目（不是解决方案），然后选择“编辑 SCD.csproj”。 然后将以下突出显示的行添加到文件中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;RuntimeHostConfigurationOption Include=&quot;System.Globalization.Invariant&quot; Value=&quot;true&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt; 
&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在命令行中，使用 dotnet run 生成命令。&lt;/li&gt;
&lt;li&gt;调试并测试程序后，为应用的每个目标平台创建要与应用一起部署的文件。&lt;br/&gt;同时对两个目标平台使用 dotnet publish 命令，如下所示：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;dotnet publish -c Release -r win10-x64
dotnet publish -c Release -r osx.10.11-x64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将为每个目标平台创建一个应用的发行版（而不是调试版）。 生成的文件位于名为“发布”的子目录中，该子目录位于项目的 .\bin\Release\netcoreapp2.1 子目录的子目录中。 请注意，每个子目录中都包含完整的启动应用所需的文件集（既有应用文件，也有所有 .NET Core 文件）。&lt;/p&gt;
&lt;p&gt;与应用程序的文件一样，发布过程将生成包含应用调试信息的程序数据库 (.pdb) 文件。 该文件主要用于调试异常。 可以选择不使用应用程序文件打包该文件。 但是，如果要调试应用的发布版本，则应保存该文件。&lt;br/&gt;可按照任何喜欢的方式部署已发布的文件。 例如，可以使用简单的 copy 命令将其打包为 Zip 文件，或者使用选择的安装包进行部署。&lt;br/&gt;下面是此项目完整的 csproj 文件。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;RuntimeIdentifiers&amp;gt;win10-x64;osx.10.11-x64&amp;lt;/RuntimeIdentifiers&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;包含第三方依赖项的独立部署&quot;&gt;包含第三方依赖项的独立部署&lt;/h3&gt;
&lt;p&gt;部署包含一个或多个第三方依赖项的独立部署包括添加依赖项。 在运行 dotnet restore命令之前，还需执行额外两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将对任何第三方库的引用添加到 csproj 文件的 部分。 以下 部分使用 Json.NET 作为第三方库。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;10.0.2&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果尚未安装，请将包含第三方依赖项的 NuGet 包下载到系统。 若要使依赖项对应用适用，请在添加依赖项后执行 dotnet restore命令。 因为依赖项在发布时已从本地 NuGet 缓存解析出来，因此它一定适用于你的系统。&lt;br/&gt;下面是此项目的完整 csproj 文件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;RuntimeIdentifiers&amp;gt;win10-x64;osx.10.11-x64&amp;lt;/RuntimeIdentifiers&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;10.0.2&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部署应用程序时，应用中使用的任何第三方依赖项也包含在应用程序文件中。 运行应用的系统上不需要第三方库。&lt;br/&gt;请注意，可以只将具有一个第三方库的独立部署部署到该库支持的平台。 这与依赖框架的部署中具有本机依赖项和第三方依赖项相似，其中的本机依赖项必须与部署应用的平台兼容。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;备注：&lt;br/&gt;从 .NET Core 2.0 开始，无需运行 &lt;code&gt;dotnet restore&lt;/code&gt;，因为它由所有需要还原的命令隐式运行，如 &lt;code&gt;dotnet new&lt;/code&gt;、&lt;code&gt;dotnet build&lt;/code&gt; 和 &lt;code&gt;dotnet run&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文首先介绍了框架依赖与独立部署的概念，然后分别介绍了框架依赖与独立部署的优缺点让大家加深理解！最后通过一个实例来讲述了如何进行框架依赖与独立部署。采用的实例使用的是控制台的方式进行的，当然你也可以使用vs进行发布。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 12:54:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文地址：https://www.cnblogs.com/yilezhu/p/9703460.html NET Core项目发布的时候你有没有注意到这两个选项呢？有没有纠结过框架依赖与独</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9703460.html</dc:identifier>
</item>
<item>
<title>数据库索引结构知多少 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9678478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9678478.html</guid>
<description>&lt;p&gt;前几天在看 2018 云栖大会，来自中科院计算所的陈世敏研究员在“数据库内核专场”做了一场《NVM在数据库领域的研究和探索 》的报告演讲。在30分钟的演讲中，其中有近10页PPT的内容和B+Tree这种索引有关。&lt;/p&gt;
&lt;p&gt;例如其中的两页&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180921153238534-1445526616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180921153203133-1858917312.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;为此，将自己对索引相关的理解梳理如下：&lt;/p&gt;
&lt;h2&gt;1.什么是索引？&lt;/h2&gt;
&lt;p&gt;索引是磁盘上组织数据记录的一种数据结构，它用来优化某类数据查询的操作。索引使得我们能够有效地查询满足索引的查询码（搜索码）字段上的查询条件的那些记录。可以在一个给定的数据记录集合上创建多个索引，每个索引有不同的查询码（搜索码）。&lt;/p&gt;
&lt;h2&gt;2.主键 与 聚集索引&lt;/h2&gt;
&lt;p&gt;主键是一种约束，主要用来保证数据的完整性，而聚集索引是一种文件（数据记录）的组织形式，索引的目的是查询优化，两者是不同的概念。&lt;/p&gt;
&lt;p&gt;但两者并非完全没有联系，比如SQL SERVER默认是在主键上建立聚集索引的。在大多数情况下，默认建立的聚集索引是不起作用的，还是需要结合实际的业务场景来考虑，特别是在选择自增ID或GUID这种主键的情况。&lt;/p&gt;
&lt;p&gt;创建主键,不可以再允许为Null值的列上创建,并且既有的数据记录中不可以有重复值,否则报错。聚集索引没有限制建立聚集索引的列一定必须 not null ，并且数据即可以唯一，也可以不唯一。&lt;/p&gt;
&lt;h2&gt;3.聚集索引 与 非聚集索引&lt;/h2&gt;
&lt;p&gt;聚集索引叶子层：具体的数据，按照聚集键顺序存储&lt;/p&gt;
&lt;p&gt;非聚集索引叶子层：指针，指针有2类数据 RID或者是聚集键。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RID（堆表） RID【文件号：页号：槽号  8 bytes — 文件号（4 bytes）：页号（2 bytes）：槽号（2 bytes）】&lt;/li&gt;
&lt;li&gt;聚集键（聚集表） 聚集键（聚集索引主键）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;聚集键与非聚集索引有紧密的依赖关系,聚集键在每个非聚集索引叶子层都保存，&lt;strong&gt;慎重选择聚集键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非聚集索引是第二索引， 对提高查询性能至关重要。&lt;/p&gt;
&lt;h2&gt;4.什么是书签查找&lt;/h2&gt;
&lt;p&gt;非聚集索引不包含查询需要的列，需要通过书签查找来获取所查询列信息。常见的书签查找有两种：一个是键查找（key lookup，聚簇索引的表），还有一个就是RID查找（RID lookup，堆表）。&lt;/p&gt;
&lt;p&gt;使用覆盖索引，让非聚集索引包含查询列，从而避免书签查找。但是非聚集索引最大键列数为16，最大索引键大小为900字节，所以覆盖索引还是有限制的，此时可以考虑 使用include属性来包含非键列。&lt;/p&gt;
&lt;h2&gt;5.二叉树 与 B-树&lt;/h2&gt;
&lt;p&gt; 索引的存放为什么不用大家熟悉的二叉树，从数据结构上来讲 二叉树的查找速度最快和比较次数最少。主要考虑的因此是I/O的次数。查找时，在某非叶子节点决定下一步向左（小于）还是向右（大于或等于）的判断比较时，都需要将节点数据I/O到内存中，即需要发生一次I/O。所以最坏的情况下磁盘IO的次数有数的高度来决定（最坏的情况可以理解为想要查找的数在叶子节点上）。所以减少磁盘I/O的次数就必须要压缩树的高度。从数据库的基本原理，我们就知道，页I/O（从磁盘输入到主存及从主存输出到磁盘）的代价代表了典型的数据库操作代价，因此需要十分小心地优化数据库系统来减少这个代价。而B-树正好瞒住了这个要求。在B-树中，每一个非叶子节点可以容纳很多节点指针，从而树的高度在实际中很少超过3或4.一个平衡数的高度是从根到叶子的路径长度。实际上，根通常是存放在缓冲池中，因为它要被频繁的访问，所以一个高度为3的树，其实只需要3次I/O。&lt;/p&gt;
&lt;p&gt;非叶子节点的平均孩子树称为树的扇出（fan-out）。如果每一个非叶子节点有n个孩子，则高度为h的树有n&lt;sup&gt;h&lt;/sup&gt;叶子页。实际 上  ，节点并没有相同数量的孩子，但是用n的平均数值F，我们可以获得叶子页数量的很好的近似结果F&lt;sup&gt;h&lt;/sup&gt;。在实际情况中，F至少为100，这意味着高度为4的树包含1亿个叶子页。因此，可以只用4次I/O就从有1亿个叶子页的文件中搜索到想要的页。与之相似，采用二分法搜索同样的文件则需要花费log&lt;sub&gt;2&lt;/sub&gt;100000000 （超过25）次I/0&lt;/p&gt;
&lt;h2&gt;6.B-树 与 B+树&lt;/h2&gt;
&lt;p&gt;与B-Tree相比，B+Tree有以下不同点：&lt;br/&gt;每个节点的指针上限为2d而不是2d+1。&lt;/p&gt;
&lt;p&gt;B+树是一种保证在一颗给定树中从根到叶所有路径都等长的索引结构，即，这种树的高度总是平衡的。&lt;br/&gt;内节点不存储data，只存储key。 B+Tree的搜索与B-Tree也基本相同，区别是B+Tree只有达到叶子结点才命中（B-Tree可以在非叶子结点命中）。&lt;/p&gt;
&lt;p&gt;在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，形成了带有顺序访问指针的B+Tree。因此在搜索中出现的磁盘I/O数就等于从根节点到页节点的路径长加上满足条件的数据项的叶子页的个数。&lt;/p&gt;
&lt;p&gt;优化的目的是为了提高区间访问的性能，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。&lt;/p&gt;
&lt;h2&gt;7.B+树 与 InnoDB&lt;/h2&gt;
&lt;p&gt;在MySQL InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Tue, 25 Sep 2018 12:17:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>前几天在看 2018 云栖大会，来自中科院计算所的陈世敏研究员在“数据库内核专场”做了一场《NVM在数据库领域的研究和探索 》的报告演讲。在30分钟的演讲中，其中有近10页PPT的内容和B+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9678478.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--20 硬件实例化与视锥体裁剪 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9702966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9702966.html</guid>
<description>&lt;p&gt;这一章将了解如何在DirectX 11利用硬件实例化技术高效地绘制重复的物体，以及使用视锥体裁剪技术提前将位于视锥体外的物体进行排除。&lt;/p&gt;
&lt;p&gt;在此之前需要额外了解的章节如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;硬件实例化指的是在场景中绘制同一个物体多次，但是是以不同的位置、旋转、缩放、材质以及纹理来绘制(比如一棵树可能会被多次使用以构建出一片森林)。在以前，每次实例绘制(Draw方法)都会引发一次顶点缓冲区和索引缓冲区经过输入装配阶段传递进渲染管线中，大量重复的绘制则意味着多次反复的输入装配操作，会引发十分庞大的性能开销。事实上在绘制同样物体的时候顶点缓冲区和索引缓冲区应当只需要传递一次，然后真正需要多次传递的也应该是像世界矩阵、材质、纹理等这些可能会经常变化的数据。&lt;/p&gt;
&lt;p&gt;要能够实现上面的这种操作，还需要图形库底层API本身能够支持按对象绘制。对于每个对象，我们必须设置它们各自的材质、世界矩阵等，然后才是调用绘制命令。尽管在Direct3D 10和后续的版本已经将原本Direct3D 9的一些API重新设计以尽可能最小化性能上的开销，部分多余的开销仍然存在。因此，Direct3D提供了一种机制，不需要通过API上的额外性能开销来实现实例化，我们称之为硬件实例化。&lt;/p&gt;
&lt;p&gt;为什么要担忧API性能开销呢？Direct3D 9应用程序通常因为API导致在CPU上遇到瓶颈，而不是在GPU。以前关卡设计师喜欢使用单一材质和纹理来绘制许多对象，因为对于它们来说需要经常去单独改变它的状态并且去调用绘制。场景将会被限制在几千次的调用绘制以维持实时渲染的速度，主要在于这里的每次API调用都会引起高级别的CPU性能开销。现在图形引擎可以使用批处理技术以最小化绘制调用的次数。硬件实例化是API帮助执行批处理的一个方面。&lt;/p&gt;
&lt;h2 id=&quot;顶点着色器&quot;&gt;顶点着色器&lt;/h2&gt;
&lt;p&gt;硬件实例化需要在输入装配阶段额外提供以二进制数据流表示的实例数据才能工作，而不仅仅是提供顶点/索引数据。然后我们将通过调用对应的Draw命令来告诉硬件需要绘制这个网格模型多少次，即绘制多少个这样的实例。对应顶点着色器来说，可以同时接受来自顶点信息和实例信息的数据作为输入：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct InstancePosNormalTex
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float2 Tex : TEXCOORD;
    row_major matrix World : World;
    row_major matrix WorldInvTranspose : WorldInvTranspose;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中前面三项数据来自顶点，后面两项数据则是来自一个实例，因为对于一个实例来说，在绘制的时候它的世界矩阵是不会发生变化的。&lt;/p&gt;
&lt;p&gt;输出的结构体和以前一样：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosHWNormalTex
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;  // 在世界中的位置
    float3 NormalW : NORMAL; // 法向量在世界中的方向
    float2 Tex : TEXCOORD;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顶点着色器代码变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;VertexPosHWNormalTex VS(InstancePosNormalTex pIn)
{
    VertexPosHWNormalTex pOut;
    
    row_major matrix viewProj = mul(gView, gProj);
    
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), pIn.World).xyz;
    pOut.PosH = mul(float4(pOut.PosW, 1.0f), viewProj);
    pOut.NormalW = mul(pIn.NormalL, (float3x3) pIn.WorldInvTranspose);
    pOut.Tex = pIn.Tex;
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于像素着色器，和上一章为模型所使用的着色器的保持一致。&lt;/p&gt;
&lt;h3 id=&quot;实例id&quot;&gt;实例ID&lt;/h3&gt;
&lt;p&gt;系统值&lt;code&gt;SV_InstanceID&lt;/code&gt;可以告诉我们当前进行绘制的顶点来自哪个实例。通常在绘制N个实例的情况下，第一个实例的索引值为0，一直到最后一个实例索引值为N - 1.它可以应用在需要个性化的地方，比如使用一个纹理数组，然后不同的索引去映射到对应的纹理，以绘制出网格模型相同，但纹理不一致的物体。&lt;/p&gt;
&lt;h2 id=&quot;流式实例化数据&quot;&gt;流式实例化数据&lt;/h2&gt;
&lt;p&gt;和之前顶点着色器的做法一样，我们需要使用&lt;code&gt;D3D11_INPUT_ELEMENT_DESC&lt;/code&gt;来描述实例的字节流对应的元素信息：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt; typedef struct D3D11_INPUT_ELEMENT_DESC
 {
    LPCSTR SemanticName;    // 语义名
    UINT SemanticIndex;     // 语义名对应的索引值
    DXGI_FORMAT Format;     // DXGI数据格式
    UINT InputSlot;         // 输入槽
    UINT AlignedByteOffset; // 对齐的字节偏移量
    D3D11_INPUT_CLASSIFICATION InputSlotClass;  // 输入槽类别(顶点/实例)
    UINT InstanceDataStepRate;  // 实例数据步进值
 }  D3D11_INPUT_ELEMENT_DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后两个成员与实例所有联系：&lt;br/&gt;1.&lt;code&gt;InputSlotClass&lt;/code&gt;:指定输入的元素是作为顶点元素还是实例元素。枚举值含义如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_INPUT_PER_VERTEX_DATA&lt;/td&gt;
&lt;td&gt;作为顶点元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_INPUT_PER_INSTANCE_DATA&lt;/td&gt;
&lt;td&gt;作为实例元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;2.&lt;code&gt;InstanceDataStepRate&lt;/code&gt;:指定每份实例数据绘制出多少个实例。例如，假如你想绘制6个实例，但提供了只够绘制3个实例的数据，1份实例数据绘制出1种颜色，分别为红、绿、蓝。那么我们可以设置该成员的值为2，使得前两个实例绘制成红色，中间两个实例绘制成绿色，后两个实例绘制成蓝色。通常在绘制实例的时候我们会将该成员的值设为1，保证1份数据绘制出1个实例。对于顶点成员来说，设置该成员的值为0.&lt;/p&gt;
&lt;p&gt;对于前面的结构体&lt;code&gt;InstancePosNormalTex&lt;/code&gt;，与之对应的输入成员描述数组如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_INPUT_ELEMENT_DESC basicInstLayout[] = {
    { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { &quot;NORMAL&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { &quot;TEXCOORD&quot;, 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { &quot;World&quot;, 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;World&quot;, 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;World&quot;, 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 32, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;World&quot;, 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 48, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;WorldInvTranspose&quot;, 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 64, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;WorldInvTranspose&quot;, 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 80, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;WorldInvTranspose&quot;, 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 96, D3D11_INPUT_PER_INSTANCE_DATA, 1},
    { &quot;WorldInvTranspose&quot;, 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 112, D3D11_INPUT_PER_INSTANCE_DATA, 1}
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;DXGI_FORMAT&lt;/code&gt;一次最多仅能够表达128位(16字节)数据，在对应矩阵的语义时，需要重复描述4次，区别在于语义索引为0-3.&lt;/p&gt;
&lt;p&gt;除此之外，观察到有关顶点的数据占用输入槽0，而实例数据占用的则是输入槽1.这样就需要我们使用两个缓冲区以提供给输入装配阶段。第一个作为顶点缓冲区，而第二个作为实例缓冲区以存放有关实例的数据。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
struct VertexPosNormalColor
{
    DirectX::XMFLOAT3 pos;
    DirectX::XMFLOAT3 normal;
    DirectX::XMFLOAT4 color;
    static const D3D11_INPUT_ELEMENT_DESC inputLayout[3];
};

struct InstancedData
{
    XMMATRIX world;
    XMMATRIX worldInvTranspose;
};


// ...
UINT strides[2] = { sizeof(VertexPosNormalTex), sizeof(InstancedData) };
UINT offsets[2] = { 0, 0 };
ID3D11Buffer * buffers[2] = { vertexBuffer.Get(), mInstancedBuffer.Get() };

// 设置顶点/索引缓冲区
deviceContext-&amp;gt;IASetVertexBuffers(0, 2, buffers, strides, offsets);
deviceContext-&amp;gt;IASetInputLayout(instancePosNormalTexLayout.Get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;绘制实例数据&quot;&gt;绘制实例数据&lt;/h2&gt;
&lt;h3 id=&quot;id3d11devicecontextdrawindexedinstanced方法--带索引数组的实例绘制&quot;&gt;ID3D11DeviceContext::DrawIndexedInstanced方法--带索引数组的实例绘制&lt;/h3&gt;
&lt;p&gt;通常我们使用&lt;code&gt;ID3D11DeviceContext::DrawIndexedInstanced&lt;/code&gt;方法来绘制实例数据：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::DrawIndexedInstanced(
    UINT IndexCountPerInstance,     // [In]每个实例绘制要用到的索引数目
    UINT InstanceCount,             // [In]绘制的实例数目
    UINT StartIndexLocation,        // [In]起始索引偏移值
    INT BaseVertexLocation,         // [In]起始顶点偏移值
    UINT StartInstanceLocation      // [In]起始实例偏移值
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个调用示例：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;deviceContext-&amp;gt;DrawIndexedInstanced(part.indexCount, numInsts, 0, 0, 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;id3d11devicecontextdrawinstanced方法--实例绘制&quot;&gt;ID3D11DeviceContext::DrawInstanced方法--实例绘制&lt;/h3&gt;
&lt;p&gt;若没有索引数组，也可以用&lt;code&gt;ID3D11DeviceContext::DrawInstanced&lt;/code&gt;方法来进行绘制&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::DrawInstanced(
    UINT VertexCountPerInstance,    // [In]每个实例绘制要用到的顶点数目
    UINT InstanceCount,             // [In]绘制的实例数目
    UINT StartVertexLocation,       // [In]起始顶点偏移值
    UINT StartInstanceLocation      // [In]起始实例偏移值
);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实例缓冲区的创建&quot;&gt;实例缓冲区的创建&lt;/h2&gt;
&lt;p&gt;和之前创建顶点/索引缓冲区的方式一样，我们需要创建一个&lt;code&gt;ID3D11Buffer&lt;/code&gt;，只不过在缓冲区描述中，我们需要将其指定为动态缓冲区(即&lt;code&gt;D3D11_BIND_VERTEX_BUFFER&lt;/code&gt;)，并且要指定&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 设置实例缓冲区描述
D3D11_BUFFER_DESC vbd;
ZeroMemory(&amp;amp;vbd, sizeof(vbd));
vbd.Usage = D3D11_USAGE_DYNAMIC;
vbd.ByteWidth = count * (UINT)sizeof(XMMATRIX) * 2;
vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
vbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
// 新建实例缓冲区
HR(device-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mInstancedBuffer.ReleaseAndGetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意这里&lt;code&gt;ByteWidth&lt;/code&gt;每个实例使用两个矩阵，一个世界矩阵，一个是世界矩阵求逆后的转置。&lt;/p&gt;
&lt;p&gt;因为我们不需要访问里面的数据，因此不用添加&lt;code&gt;D3D11_CPU_ACCESS_READ&lt;/code&gt;标记。&lt;/p&gt;
&lt;h2 id=&quot;实例缓冲区数据的修改&quot;&gt;实例缓冲区数据的修改&lt;/h2&gt;
&lt;p&gt;若需要修改实例缓冲区的内容，则需要使用&lt;code&gt;ID3D11DeviceContext::Map&lt;/code&gt;方法将其映射到CPU内存当中。对于使用了&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;标签的动态缓冲区来说，在更新的时候只能使用&lt;code&gt;D3D11_MAP_WRITE_DISCARD&lt;/code&gt;标签，而不能使用&lt;code&gt;D3D11_MAP_WRITE&lt;/code&gt;或者&lt;code&gt;D3D11_MAP_READ_WRITE&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;将需要提交上去的实例数据存放到映射好的CPU内存区间后，使用&lt;code&gt;ID3D11DeviceContext::Unmap&lt;/code&gt;方法将实例数据更新到显存中以应用。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_MAPPED_SUBRESOURCE mappedData;
HR(deviceContext-&amp;gt;Map(mInstancedBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;amp;mappedData));
InstancedData * iter = reinterpret_cast&amp;lt;InstancedData *&amp;gt;(mappedData.pData);
// 省略写入细节...

deviceContext-&amp;gt;Unmap(mInstancedBuffer.Get(), 0);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在前面的所有章节中，顶点的抛弃通常发生在光栅化阶段。这意味着如果一份模型数据的所有顶点在经过矩阵变换后都不会落在屏幕区域内的话，这些顶点数据将会经历顶点着色阶段，可能会经过曲面细分阶段和几何着色阶段，然后在光栅化阶段的时候才抛弃。让这些不会被绘制的顶点还要走过这么漫长的阶段才被抛弃，可以说是一种非常低效的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视锥体裁剪&lt;/strong&gt;，就是在将这些模型的相关数据提交给渲染管线之前，生成一个包围盒，与摄像机观察空间的视锥体进行碰撞检测。若为相交或者包含，则说明该模型对象是可见的，需要被绘制出来，反之则应当拒绝对该对象的绘制调用，或者不传入该实例对象相关的数据。这样做可以节省GPU资源以避免大量对不可见对象的绘制，对CPU的性能开销也不大。&lt;/p&gt;
&lt;p&gt;可以说，若一个场景中的模型数目越多，或者视锥体的可视范围越小，那么视锥体裁剪的效益越大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201809/1172605-20180925193234385-302599377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看上图，可以知道的是物体A和D没有与视锥体发生碰撞，因此需要排除掉物体A的实例数据。而物体B和E与视锥体有相交，物体C则被视锥体所包含，这三个物体的实例数据都应当传递给实例缓冲区。&lt;/p&gt;
&lt;p&gt;视锥体裁剪有三种等价的代码表现形式。需要已知当前物体的包围盒、世界变换矩阵、观察矩阵和投影矩阵。其中投影矩阵本身可以构造出视锥体包围盒。&lt;/p&gt;
&lt;p&gt;下面有关视锥体裁剪的方法都放进了&lt;code&gt;Collision.h&lt;/code&gt;中。&lt;/p&gt;
&lt;h2 id=&quot;方法1&quot;&gt;方法1&lt;/h2&gt;
&lt;p&gt;现在已知物体的包围盒位于自身的局部坐标系，我们可以使用世界变换矩阵将其变换到世界空间中。同样，由投影矩阵构造出来的视锥体包围盒也位于自身局部坐标系中，而观察矩阵实质上是从世界矩阵变换到视锥体所处的局部坐标系中。因此，我们可以使用观察矩阵的逆矩阵，将视锥体包围盒也变换到世界空间中。这样就好似物体与视锥体都位于世界空间中，可以进行碰撞检测了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::vector&amp;lt;XMMATRIX&amp;gt; XM_CALLCONV Collision::FrustumCulling(
    const std::vector&amp;lt;XMMATRIX&amp;gt;&amp;amp; Matrices,const BoundingBox&amp;amp; localBox, FXMMATRIX View, CXMMATRIX Proj)
{
    std::vector&amp;lt;DirectX::XMMATRIX&amp;gt; acceptedData;

    BoundingFrustum frustum;
    BoundingFrustum::CreateFromMatrix(frustum, Proj);
    XMMATRIX InvView = XMMatrixInverse(nullptr, View);
    // 将视锥体从局部坐标系变换到世界坐标系中
    frustum.Transform(frustum, InvView);

    BoundingOrientedBox localOrientedBox, orientedBox;
    BoundingOrientedBox::CreateFromBoundingBox(localOrientedBox, localBox);
    for (auto&amp;amp; mat : Matrices)
    {
        // 将有向包围盒从局部坐标系变换到世界坐标系中
        localOrientedBox.Transform(orientedBox, mat);
        // 相交检测
        if (frustum.Intersects(orientedBox))
            acceptedData.push_back(mat);
    }

    return acceptedData;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法2&quot;&gt;方法2&lt;/h2&gt;
&lt;p&gt;该方法对应的正是龙书中所使用的裁剪方法，基本思路为：分别对观察矩阵和世界变换矩阵求逆，然后使用观察逆矩阵将视锥体从自身坐标系搬移到世界坐标系，再使用世界变换的逆矩阵将其从世界坐标系搬移到物体自身坐标系来与物体进行碰撞检测。改良龙书的碰撞检测代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::vector&amp;lt;DirectX::XMMATRIX&amp;gt; XM_CALLCONV Collision::FrustumCulling2(
    const std::vector&amp;lt;DirectX::XMMATRIX&amp;gt;&amp;amp; Matrices,const DirectX::BoundingBox&amp;amp; localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj)
{
    std::vector&amp;lt;DirectX::XMMATRIX&amp;gt; acceptedData;

    BoundingFrustum frustum, localFrustum;
    BoundingFrustum::CreateFromMatrix(frustum, Proj);
    XMMATRIX InvView = XMMatrixInverse(nullptr, View);
    for (auto&amp;amp; mat : Matrices)
    {
        XMMATRIX InvWorld = XMMatrixInverse(nullptr, mat);

        // 将视锥体从观察坐标系(或局部坐标系)变换到物体所在的局部坐标系中
        frustum.Transform(localFrustum, InvView * InvWorld);
        // 相交检测
        if (localFrustum.Intersects(localBox))
            acceptedData.push_back(mat);
    }

    return acceptedData;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法3&quot;&gt;方法3&lt;/h2&gt;
&lt;p&gt;这个方法理解起来也比较简单，直接将物体先用世界变换矩阵从物体自身坐标系搬移到世界坐标系，然后用观察矩阵将其搬移到视锥体自身的局部坐标系来与视锥体进行碰撞检测。代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::vector&amp;lt;DirectX::XMMATRIX&amp;gt; XM_CALLCONV Collision::FrustumCulling3(
    const std::vector&amp;lt;DirectX::XMMATRIX&amp;gt;&amp;amp; Matrices,const DirectX::BoundingBox&amp;amp; localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj)
{
    std::vector&amp;lt;DirectX::XMMATRIX&amp;gt; acceptedData;

    BoundingFrustum frustum;
    BoundingFrustum::CreateFromMatrix(frustum, Proj);

    BoundingOrientedBox localOrientedBox, orientedBox;
    
    BoundingOrientedBox::CreateFromBoundingBox(localOrientedBox, localBox);
    for (auto&amp;amp; mat : Matrices)
    {
        // 将有向包围盒从局部坐标系变换到视锥体所在的局部坐标系(观察坐标系)中
        localOrientedBox.Transform(orientedBox, mat * View);
        // 相交检测
        if (frustum.Intersects(orientedBox))
            acceptedData.push_back(mat);
    }

    return acceptedData;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三种方法的裁剪表现效果是一致的。&lt;/p&gt;

&lt;h2 id=&quot;gameappcreaterandomtrees方法--创建大量随机位置和方向的树&quot;&gt;GameApp::CreateRandomTrees方法--创建大量随机位置和方向的树&lt;/h2&gt;
&lt;p&gt;该方法创建了树的模型，并以随机的方式在一个大范围的圆形区域中生成了225棵树，即225个实例的数据（世界矩阵）。其中该圆形区域被划分成16个扇形区域，每个扇形划分成4个面，距离中心越远的扇面生成的树越多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201809/1172605-20180925193256027-1077579506.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::CreateRandomTrees()
{
    // 初始化树
    mObjReader.Read(L&quot;Model\\tree.mbo&quot;, L&quot;Model\\tree.obj&quot;);
    mTrees.SetModel(Model(md3dDevice, mObjReader));
    XMMATRIX S = XMMatrixScaling(0.015f, 0.015f, 0.015f);
    
    BoundingBox treeBox = mTrees.GetLocalBoundingBox();
    // 获取树包围盒顶点
    mTreeBoxData = Collision::CreateBoundingBox(treeBox, XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f));
    // 让树木底部紧贴地面位于y = -2的平面
    treeBox.Transform(treeBox, S);
    XMMATRIX T0 = XMMatrixTranslation(0.0f, -(treeBox.Center.y - treeBox.Extents.y + 2.0f), 0.0f);
    // 随机生成256颗随机朝向的树
    float theta = 0.0f;
    for (int i = 0; i &amp;lt; 16; ++i)
    {
        // 取5-125的半径放置随机的树
        for (int j = 0; j &amp;lt; 4; ++j)
        {
            // 距离越远，树木越多
            for (int k = 0; k &amp;lt; 2 * j + 1; ++k)
            {
                float radius = (float)(rand() % 30 + 30 * j + 5);
                float randomRad = rand() % 256 / 256.0f * XM_2PI / 16;
                XMMATRIX T1 = XMMatrixTranslation(radius * cosf(theta + randomRad), 0.0f, radius * sinf(theta + randomRad));
                XMMATRIX R = XMMatrixRotationY(rand() % 256 / 256.0f * XM_2PI);
                XMMATRIX World = S * R * T0 * T1;
                mInstancedData.push_back(World);
            }
        }
        theta += XM_2PI / 16;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameobjectresizebuffer方法--重新调整实例缓冲区的大小&quot;&gt;GameObject::ResizeBuffer方法--重新调整实例缓冲区的大小&lt;/h2&gt;
&lt;p&gt;若实例缓冲区的大小容不下当前增长的实例数据，则需要销毁原来的实例缓冲区，并重新创建一个更大的，以确保刚好能容得下之前的大量实例数据。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameObject::ResizeBuffer(ComPtr&amp;lt;ID3D11Device&amp;gt; device, size_t count)
{
    // 设置实例缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DYNAMIC;
    vbd.ByteWidth = count * (UINT)sizeof(XMMATRIX) * 2;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
    // 创建实例缓冲区
    HR(device-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mInstancedBuffer.ReleaseAndGetAddressOf()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameobjectdrawinstanced方法--绘制游戏对象的多个实例&quot;&gt;GameObject::DrawInstanced方法--绘制游戏对象的多个实例&lt;/h2&gt;
&lt;p&gt;该方法接受一个装满世界矩阵的数组，把数据装填进实例缓冲区（若容量不够则重新扩容），然后交给设备上下文进行实例的绘制&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameObject::DrawInstanced(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicFX &amp;amp; effect, const std::vector&amp;lt;DirectX::XMMATRIX&amp;gt;&amp;amp; data)
{
    std::vector&amp;lt;XMMATRIX&amp;gt; acceptedData;
    D3D11_MAPPED_SUBRESOURCE mappedData;
    UINT numInsts = (UINT)data.size();
    // 若传入的数据比实例缓冲区还大，需要重新分配
    if (numInsts &amp;gt; mCapacity)
    {
        ComPtr&amp;lt;ID3D11Device&amp;gt; device;
        deviceContext-&amp;gt;GetDevice(device.GetAddressOf());
        ResizeBuffer(device, numInsts);
    }

    HR(deviceContext-&amp;gt;Map(mInstancedBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;amp;mappedData));

    InstancedData * iter = reinterpret_cast&amp;lt;InstancedData *&amp;gt;(mappedData.pData);
    XMMATRIX worldInvTranspose;
    for (auto&amp;amp; mat : data)
    {
        worldInvTranspose = XMMatrixTranspose(XMMatrixInverse(nullptr, mat));
        iter-&amp;gt;world = mat;
        iter-&amp;gt;worldInvTranspose = worldInvTranspose;
        iter++;
    }

    deviceContext-&amp;gt;Unmap(mInstancedBuffer.Get(), 0);

    UINT strides[2] = { sizeof(VertexPosNormalTex), sizeof(InstancedData) };
    UINT offsets[2] = { 0, 0 };
    ID3D11Buffer * buffers[2] = { nullptr, mInstancedBuffer.Get() };
    for (auto&amp;amp; part : mModel.modelParts)
    {
        buffers[0] = part.vertexBuffer.Get();

        // 设置顶点/索引缓冲区
        deviceContext-&amp;gt;IASetVertexBuffers(0, 2, buffers, strides, offsets);
        deviceContext-&amp;gt;IASetIndexBuffer(part.indexBuffer.Get(), part.indexFormat, 0);

        // 更新数据并应用
        effect.SetTextureAmbient(part.texA);
        effect.SetTextureDiffuse(part.texD);
        effect.SetMaterial(part.material);
        effect.Apply(deviceContext);

        deviceContext-&amp;gt;DrawIndexedInstanced(part.indexCount, numInsts, 0, 0, 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩余的代码都可以在GitHub项目中浏览。&lt;/p&gt;

&lt;p&gt;该项目展示了一个同时存在225棵树的场景，用户可以自行设置开启/关闭视锥体裁剪或硬件实例化。若关闭硬件实例化，则是对每个对象单独调用绘制命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201809/1172605-20180925193403958-124143806.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Sep 2018 11:56:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 这一章将了解如何在DirectX 11利用硬件实例化技术高效地绘制重复的物体，以及使用视锥体裁剪技术提前将位于视锥体外的物体进行排除。 在此之前需要额外了解的章节如下： |章节回顾| | | |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9702966.html</dc:identifier>
</item>
</channel>
</rss>