<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>客户懂点代码是最致命的毒药 - 郎中令</title>
<link>http://www.cnblogs.com/Sientuo/p/7688257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sientuo/p/7688257.html</guid>
<description>&lt;p&gt;       这里绝对不是吐槽，只是记录一个非常搞笑的事情。&lt;/p&gt;
&lt;p&gt;       台企业向来以绝对的服务称道，即使客户是 Naive ，Simple。作为银行的网站，在项目快上线的时候，一声惊雷传来，&lt;span&gt;将所有逻辑实现类的代码拷贝至 一个logic.cs类中，将所有实体类拷贝至Model.cs类中。&lt;span&gt;没错,没有听错，老夫驰骋项目多年，第一次听过如此奇葩的要求！！！给出的理由绝对惊讶： 客户懂代码，逻辑类分开写看的不舒服！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 这个荒唐的理由下，需要做的处理：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ①原来面向各个界面的逻辑实现类的类名以序列编号重命名的形式全部拷贝至Logic.cs中 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ②所有实体类拷贝至Model.cs类中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ③所有的控制器中调用的方法全部重新设置路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ④所有视图中引用的实体类文件路径重新设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ⑤对翻新后的文件进行测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 完成之后，整个项目简洁明了（光秃秃），尤其是逻辑层就两个类文件，无任何文件夹，仅仅只有一个Logic.cs 和 Model.cs 两个文件，后期的维护怎么做？哦，不是，客户懂点代码，想着是，文件个数，以后维护可以自行动手，不用再花钱。这算盘。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 粗略算了下，负重的Logic.cs文件 里面会有近20K行的代码。整个项目翻新一遍，加上测试，两个人差不多需要四到五天的时间，说不准，一个星期之后，客户又觉得不好，还能再改回来，毕竟这样的事情经常发生，一步一注释，十步一备注，步步才能走的稳呐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     作为一名开发人员，尽量以最优、最简明的目的去对待项目。如果客户什么都不懂，那么我们给出各种方案，客户认可的标准就是 运行正常、（高效）、简单操作。恰恰如果客户懂点代码，但是有时那种什么都不知道的门外行，那真是叫痛苦，想来什么就是什么，需求没有不合理之说，界面管，代码结构管，实现方式管，这都是开发文档中明确的事情，无可厚非，如果客户连这种傻逼都都知道是荒谬的需求还要一意孤行的去执行。sa又向来弱势，那么坑爹的就是程序员；大家普遍对台企印象不好，或者说很差，其实也是有道理的。我在这家台企工作快两年，算大公司，所在的研发分部就有不下1000人，不加班，双休，5天七小时，13薪，年涨薪20% ，日常工作轻松自由，可以磨洋工，去楼顶吹风，去楼下花园散散步，时间自由轻松。看来还算不错。弊端也有，员工无积极性。企业的态度是唯用户至上，如客户仅仅提供几个思路，实际是无稽之谈，完全不可行，但是也要开发人员短时间内给出一定的开发测试。在客户面前，台湾的sa毫无主见（反正也不是他们开发）,照单全收，然后统统转交至开发部，当开发人员在请求确认的时候，往往一两个星期都得不到反馈，甚至更久，看看人家强哥的24小时必回邮件制度。出了问题，还被强行背锅，有一次一个简单的需求，就是改下存储过程中X表的一栏位，结果sa描述成其它的意思，最后用户发现不对，质问sa，于是陆陆续续出现了A、B、C、D、E、F 六个版本，结果sa仍然没有搞清楚用户的需求。最后小组长被强行背锅，理由也是十分荒唐，一个运行十年的项目，维护的时候开发人员不能正确理解sa的要求。这强加的理由也是醉了，作为开发人员，按照需求来维护项目，更改的需求本身就是错的，还能怪到开发身上。大公司中很多项目都能拖上个一两年才出来一个版本，项目管理有时候很混乱，部门繁杂，流程拖沓。毕竟不差钱，养的起人，交的起电费。除了台企，也真是没谁了。长此以往，也导致了很多开发人员离职。然后长时间又招收不到合适的替补人员，用大量的实习生来做技术储备，水平又参差不齐，有的毕业了还培训过的却连断点都不知道怎么打，想想真是可笑。这么说来，实力，提升自身实力是第一目标，只有自己强大，才能有底气的强势些，证明自己的存在感，只管糊墙不看图纸的泥瓦匠不是一个好的程序员。   &lt;/p&gt;
&lt;p&gt;     岁月悠悠，每天两点一线的生活，公司-住处，下班闲暇之余买些专业书来啃，唯恐被淘汰，毕竟对公司来说，创造价值与成本比是第一位的。多读书，理想还是要有的，说不定那天就实现了呢，保持一份简单的心，毕竟我们每天都在做着改变世界的事情！！！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:32:00 +0000</pubDate>
<dc:creator>郎中令</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sientuo/p/7688257.html</dc:identifier>
</item>
<item>
<title>用FastDFS一步步搭建文件管理系统 - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/fastdfs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/fastdfs.html</guid>
<description>&lt;h2&gt; 一、FastDFS介绍&lt;/h2&gt;
&lt;p&gt;FastDFS开源地址：&lt;a href=&quot;https://github.com/happyfish100&quot; target=&quot;_blank&quot;&gt;https://github.com/happyfish100&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://blog.chinaunix.net/uid-20196318-id-4058561.html&quot; target=&quot;_blank&quot;&gt;分布式文件系统FastDFS设计原理&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/Leo_wl/p/6731647.html&quot; target=&quot;_blank&quot;&gt;FastDFS分布式文件系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人封装的FastDFS Java API：&lt;a href=&quot;https://github.com/bojiangzhou/lyyzoo-fastdfs-java&quot; target=&quot;_blank&quot;&gt;https://github.com/bojiangzhou/lyyzoo-fastdfs-java&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1、简介&lt;/h3&gt;
&lt;p&gt;FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。&lt;/p&gt;
&lt;p&gt;FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Tracker Server&lt;/strong&gt;：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Storage Server&lt;/strong&gt;：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Client&lt;/strong&gt;：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011144153840-1185141903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、FastDFS的存储策略&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。&lt;/p&gt;
&lt;p&gt;在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、FastDFS的上传过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。&lt;/p&gt;
&lt;p&gt;Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。&lt;/p&gt;
&lt;p&gt;当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012121639387-1574147926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4、FastDFS的文件同步&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。&lt;/p&gt;
&lt;p&gt;每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。&lt;/p&gt;
&lt;p&gt;storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5、FastDFS的文件下载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;客户端uploadfile成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/380252/201704/380252-20170415090611017-204910775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟upload file一样，在downloadfile时客户端可以选择任意tracker server。tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求。&lt;/p&gt;

&lt;h2&gt;二、安装FastDFS环境&lt;/h2&gt;
&lt;h3&gt;0、前言&lt;/h3&gt;
&lt;p&gt;操作环境：CentOS7 X64，以下操作都是单机环境。&lt;/p&gt;
&lt;p&gt;我把所有的安装包下载到/softpackages/下，解压到当前目录。&lt;/p&gt;
&lt;p&gt;先做一件事，修改hosts，将文件服务器的ip与域名映射(单机TrackerServer环境)，因为后面很多配置里面都需要去配置服务器地址，ip变了，就只需要修改hosts即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/hosts

增加如下一行，这是我的IP
192.168.51.128 file.ljzsg.com

如果要本机访问虚拟机，在C:\Windows\System32\drivers\etc\hosts中同样增加一行
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1、下载安装 libfastcommon&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;libfastcommon是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库，基础环境，安装即可 。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 下载libfastcommon&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf V1.0.7.tar.gz
# cd libfastcommon-1.0.7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ./make.sh
# ./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ libfastcommon.so 安装到了/usr/lib64/libfastcommon.so，但是FastDFS主程序设置的lib目录是/usr/local/lib，所以需要创建软链接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so
# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so
# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、下载安装FastDFS&lt;/h3&gt;
&lt;p&gt;① 下载FastDFS&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf V5.05.tar.gz
# cd fastdfs-5.05
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ./make.sh
# ./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;④ 默认安装方式安装后的相应文件与目录&lt;br/&gt;　　A、服务脚本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/init.d/fdfs_storaged
/etc/init.d/fdfs_tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　B、配置文件（这三个是作者给的样例配置文件） :&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/fdfs/client.conf.sample
/etc/fdfs/storage.conf.sample
/etc/fdfs/tracker.conf.sample
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　C、命令工具在 /usr/bin/ 目录下：&lt;span class=&quot;fontstyle0&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
fdfs_appender_test
fdfs_appender_test1
fdfs_append_file
fdfs_crc32
fdfs_delete_file
fdfs_download_file
fdfs_file_info
fdfs_monitor
fdfs_storaged
fdfs_test
fdfs_test1
fdfs_trackerd
fdfs_upload_appender
fdfs_upload_file
stop.sh
restart.sh 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ &lt;span class=&quot;fontstyle0&quot;&gt;FastDFS 服务脚本设置的 bin 目录是 /usr/local/bin， 但实际命令安装在 /usr/bin/ 下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　》 一是修改&lt;span class=&quot;fontstyle0&quot;&gt;FastDFS 服务脚本中相应的命令路径，也就是把 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/init.d/fdfs_storaged &lt;span class=&quot;fontstyle0&quot;&gt;和 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/init.d/fdfs_tracker &lt;span class=&quot;fontstyle0&quot;&gt;两个脚本中的 &lt;span class=&quot;fontstyle0&quot;&gt;/usr/local/bin &lt;span class=&quot;fontstyle0&quot;&gt;修改成 &lt;span class=&quot;fontstyle0&quot;&gt;/usr/bin。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;span class=&quot;fontstyle0&quot;&gt;# &lt;span class=&quot;fontstyle0&quot;&gt;vim fdfs_trackerd&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　使用查找替换命令进统一修改:&lt;span class=&quot;fontstyle0&quot;&gt;%s+/usr/local/bin+/usr/bin&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　# &lt;span class=&quot;fontstyle0&quot;&gt;vim fdfs_storaged&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　使用查找替换命令进统一修改:&lt;span class=&quot;fontstyle0&quot;&gt;%s+/usr/local/bin+/usr/bin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011104718043-576731412.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;140&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　》 二是建立 /usr/bin 到 /usr/local/bin 的软链接，我是用这种方式。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ln -s /usr/bin/fdfs_trackerd   /usr/local/bin
# ln -s /usr/bin/fdfs_storaged   /usr/local/bin
# ln -s /usr/bin/stop.sh         /usr/local/bin
# ln -s /usr/bin/restart.sh      /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、配置FastDFS跟踪器(Tracker)&lt;/h3&gt;
&lt;p&gt;配置文件详细说明参考：&lt;a id=&quot;thread_subject&quot; href=&quot;http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;amp;tid=1941456&amp;amp;extra=page%3D1%26filter%3Ddigest%26digest%3D1&quot; target=&quot;_blank&quot;&gt;FastDFS 配置文件详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;① 进入 /etc/fdfs，复制 FastDFS 跟踪器样例配置文件 tracker.conf.sample，并重命名为 tracker.conf。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp tracker.conf.sample tracker.conf
# vim tracker.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 编辑&lt;span class=&quot;fontstyle0&quot;&gt;tracker.conf ，标红的需要修改下，其它的默认即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# 配置文件是否不生效，false 为生效
disabled=false&lt;br/&gt;# 提供服务的端口
port=22122&lt;br/&gt;# Tracker 数据和日志目录地址(根目录必须存在,子目录会自动创建)
&lt;span&gt;base_path=/ljzsg/fastdfs/tracker&lt;br/&gt;&lt;/span&gt;
# HTTP 服务端口
&lt;span&gt;http.server_port=80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 创建tracker基础数据目录，即base_path对应的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# mkdir -p /ljzsg/fastdfs/tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 防火墙中打开跟踪端口（默认的22122）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables&lt;br/&gt;添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT&lt;br/&gt;重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 启动Tracker&lt;/p&gt;
&lt;p&gt;初次成功启动，会在 /ljzsg/fdfsdfs/tracker/ (配置的base_path)下创建 data、logs 两个目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
可以用这种方式启动
# /etc/init.d/fdfs_trackerd start

也可以用这种方式启动，前提是上面创建了软链接，后面都用这种方式
# service fdfs_trackerd start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;查看 FastDFS Tracker 是否已成功启动 ，22122端口正在被监听，则算是Tracker服务安装成功。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# netstat -unltp|grep fdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011121344184-1089101646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关闭Tracker命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# service fdfs_trackerd stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 设置Tracker开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# chkconfig fdfs_trackerd on&lt;p&gt;或者：&lt;br/&gt;# vim /etc/rc.d/rc.local&lt;br/&gt;加入配置：&lt;br/&gt;/etc/init.d/fdfs_trackerd start 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ &lt;span class=&quot;fontstyle0&quot;&gt;tracker server &lt;span class=&quot;fontstyle2&quot;&gt;目录及文件结构&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Tracker服务启动成功后，会在base_path下创建data、logs两个目录。目录结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
${base_path}
  |__data
  |   |__storage_groups.dat：存储分组信息
  |   |__storage_servers.dat：存储服务器列表
  |__logs
  |   |__trackerd.log： tracker server 日志文件 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、&lt;span class=&quot;fontstyle0&quot;&gt;配置 FastDFS 存储 (Storage)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;① 进入 /etc/fdfs 目录，&lt;span class=&quot;fontstyle0&quot;&gt;复制 FastDFS 存储器样例配置文件 storage.conf.sample，并重命名为 storage.conf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp storage.conf.sample storage.conf&lt;br/&gt;# vim storage.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 编辑storage.conf&lt;/p&gt;
&lt;p&gt;标红的需要修改，其它的默认即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# 配置文件是否不生效，false 为生效
disabled=false 

# 指定此 storage server 所在 组(卷)
group_name=group1

# storage server 服务端口
port=23000

# 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)
heart_beat_interval=30

# Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)
&lt;span&gt;base_path=/ljzsg/fastdfs/storage&lt;/span&gt;

# 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。
store_path_count=1


# 逐一配置 store_path_count 个路径，索引号基于 0。
# 如果不配置 store_path0，那它就和 base_path 对应的路径一样。
&lt;span&gt;store_path0=/ljzsg/fastdfs/file&lt;/span&gt;

# FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 
# 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。
subdir_count_per_path=256

# tracker_server 的列表 ，会主动连接 tracker_server
# 有多个 tracker server 时，每个 tracker server 写一行
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;# 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;sync_start_time=00:00&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;sync_end_time=23:59&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
# 访问端口&lt;br/&gt;&lt;span&gt;http.server_port=80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 创建Storage基础数据目录，对应base_path目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# mkdir -p /ljzsg/fastdfs/storage

# 这是配置的store_path0路径
# mkdir -p /ljzsg/fastdfs/file
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ &lt;span class=&quot;fontstyle0&quot;&gt;防火墙中打开存储器端口（默认的 23000）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables

添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT

重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011133233777-1903096242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ 启动 Storage&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;启动Storage前确保Tracker是启动的。初次启动成功，会在 /ljzsg/fastdfs/storage 目录下创建 data、 logs 两个目录。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
可以用这种方式启动
# /etc/init.d/fdfs_storaged start

也可以用这种方式，后面都用这种
# service fdfs_storaged start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 Storage 是否成功启动，23000 端口正在被监听，就算 Storage 启动成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# netstat -unltp|grep fdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011134723387-604894314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关闭Storage命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# service fdfs_storaged stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看Storage和Tracker是否在通信：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171016093815615-757608481.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑥ 设置 Storage 开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# chkconfig fdfs_storaged on&lt;/pre&gt;
&lt;pre&gt;
或者：&lt;br/&gt;# vim /etc/rc.d/rc.local&lt;br/&gt;加入配置：&lt;br/&gt;/etc/init.d/fdfs_storaged start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ Storage 目录&lt;/p&gt;
&lt;p&gt;同 Tracker，Storage 启动成功后，在base_path 下创建了data、logs目录，记录着 Storage Server 的信息。&lt;/p&gt;
&lt;p&gt;在 store_path0 目录下，创建了N*N个子目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011135658074-1715166829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、文件上传测试&lt;/h3&gt;
&lt;p&gt;① 修改 Tracker &lt;span class=&quot;fontstyle0&quot;&gt;服务器中的客户端配置文件 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp client.conf.sample client.conf
# vim client.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改如下配置即可，其它默认。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# Client 的数据和日志目录
&lt;span&gt;base_path=/ljzsg/fastdfs/client&lt;/span&gt;

# Tracker端口
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 上传测试&lt;/p&gt;
&lt;p&gt; 在linux内部执行如下命令上传 namei.jpeg 图片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf namei.jpeg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传成功后返回文件ID号：group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011142634105-1857091563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回的文件ID由&lt;span class=&quot;kwd&quot;&gt;group&lt;span class=&quot;pun&quot;&gt;、存储目录、两级子目录、&lt;span class=&quot;pln&quot;&gt;fileid&lt;span class=&quot;pun&quot;&gt;、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011151728965-914197096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、安装Nginx&lt;/h2&gt;
&lt;p&gt;上面将文件上传成功了，但我们无法下载。因此安装Nginx作为服务器以支持Http方式访问文件。同时，后面安装FastDFS的Nginx模块也需要Nginx环境。&lt;/p&gt;
&lt;p&gt;Nginx只需要安装到StorageServer所在的服务器即可，用于访问文件。我这里由于是单机，TrackerServer和StorageServer在一台服务器上。&lt;/p&gt;
&lt;h3&gt;1、安装nginx所需环境　　&lt;/h3&gt;
&lt;p&gt;① gcc 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# yum install gcc-c++
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② PCRE pcre-devel 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y pcre pcre-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ zlib 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y zlib zlib-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ OpenSSL 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y openssl openssl-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、安装Nginx&lt;/h3&gt;
&lt;p&gt;① 下载nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget -c https://nginx.org/download/nginx-1.12.1.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf nginx-1.12.1.tar.gz
# cd nginx-1.12.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 使用默认配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# ./configure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# make
# make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 启动nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# cd /usr/local/nginx/sbin/
# ./nginx 

其它命令
# ./nginx -s stop
# ./nginx -s quit
# ./nginx -s reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 设置开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# vim /etc/rc.local

添加一行：
/usr/local/nginx/sbin/nginx&lt;p&gt;# 设置执行权限&lt;br/&gt;# &lt;span class=&quot;hljs-keyword&quot;&gt;chmod &lt;span class=&quot;hljs-number&quot;&gt;755 rc.&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ 查看nginx的版本及模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/local/nginx/sbin/nginx -V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011165300730-1693050013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑧ &lt;span class=&quot;fontstyle0&quot;&gt;防火墙中打开Nginx端口（默认的 80） &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;添加后就能在本机使用80端口访问了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables

添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT

重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011172121746-2118138931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、访问文件&lt;/h3&gt;
&lt;p&gt;简单的测试访问文件&lt;/p&gt;
&lt;p&gt;① 修改nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# vim /usr/local/nginx/conf/nginx.conf

添加如下行，将 /group1/M00 映射到 /ljzsg/fastdfs/file/data
location /group1/M00 {
    alias /ljzsg/fastdfs/file/data;
}&lt;p&gt;# 重启nginx&lt;br/&gt;# /usr/local/nginx/sbin/nginx -s reload
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011180543746-937678567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 在浏览器访问之前上传的图片、成功。&lt;/p&gt;
&lt;p&gt;http://file.ljzsg.com/group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/p&gt;

&lt;h2&gt;四、FastDFS 配置 Nginx 模块&lt;/h2&gt;
&lt;h3&gt;1、安装配置Nginx模块&lt;/h3&gt;
&lt;p&gt;① fastdfs-nginx-module 模块说明&lt;/p&gt;
&lt;p&gt;　　FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制， 有同步延迟的问题。&lt;/p&gt;
&lt;p&gt;　　假设 Tracker 服务器将文件上传到了 192.168.51.128，上传成功后文件 ID已经返回给客户端。&lt;/p&gt;
&lt;p&gt;　　此时 FastDFS 存储集群机制会将这个文件同步到同组存储 192.168.51.129，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.51.129 上取文件,就会出现文件无法访问的错误。&lt;/p&gt;
&lt;p&gt;　　而 fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误。&lt;/p&gt;
&lt;p&gt;② 下载 fastdfs-nginx-module、解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# 这里为啥这么长一串呢，因为最新版的master与当前nginx有些版本问题。
# wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip

# 解压
# unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip

# 重命名
# mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 配置Nginx&lt;/p&gt;
&lt;p&gt;在nginx中添加模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
# 先停掉nginx服务&lt;br/&gt;# /usr/local/nginx/sbin/ngix -s stop&lt;p&gt;进入解压包目录
# cd /softpackages/nginx-1.12.1/

# 添加模块
# ./configure --add-module=../fastdfs-nginx-module-master/src

重新编译、安装
# make &amp;amp;&amp;amp; make install
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ④ 查看Nginx的模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/local/nginx/sbin/nginx -V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有下面这个就说明添加模块成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011224125574-1739252073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ 复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# cd /softpackages/fastdfs-nginx-module-master/src&lt;p&gt;# cp mod_fastdfs.conf /etc/fdfs/
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改如下配置，其它默认&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 连接超时时间&lt;/span&gt;&lt;br/&gt;connect_timeout=10&lt;/span&gt;

# Tracker Server
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;
&lt;br/&gt;# StorageServer 默认端口
storage_server_port=23000

# 如果文件ID的uri中包含/group**，则要设置为true
&lt;span&gt;url_have_group_name = true&lt;/span&gt;

# Storage 配置的store_path0路径，必须和storage.conf中的一致
&lt;span&gt;store_path0=/ljzsg/fastdfs/file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 复制 FastDFS 的部分配置文件到/etc/fdfs 目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /softpackages/fastdfs-5.05/conf/

# cp anti-steal.jpg http.conf mime.types /etc/fdfs/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ⑦ 配置nginx，修改nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# vim /usr/local/nginx/conf/nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改配置，其它的默认&lt;/p&gt;
&lt;p&gt;在80端口下添加fastdfs-nginx模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location ~/group([0-9])/M00 {
    ngx_fastdfs_module;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011184247777-40074297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　listen 80 &lt;span class=&quot;fontstyle0&quot;&gt;端口值是要与 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/fdfs/storage.conf &lt;span class=&quot;fontstyle0&quot;&gt;中的 &lt;span class=&quot;fontstyle0&quot;&gt;http.server_port=80 (前面改成80了)&lt;span class=&quot;fontstyle0&quot;&gt;相对应。如果改成其它端口，则需要统一，同时在防火墙中打开该端口。&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　location 的配置，如果有多个group则配置&lt;span class=&quot;fontstyle0&quot;&gt;location &lt;span class=&quot;fontstyle0&quot;&gt;~/group([0-9])/M00 ，没有则不用配group。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑧ &lt;span class=&quot;fontstyle0&quot;&gt;在/ljzsg/fastdfs/file 文件存储目录下创建软连接，将其链接到实际存放数据的目录，这一步可以省略。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ln -s /ljzsg/fastdfs/file/data/ /ljzsg/fastdfs/file/data/M00 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑨ 启动nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/local/nginx/sbin/nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印处如下就算配置成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011230509512-654301113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑩ 在地址栏访问。&lt;/p&gt;
&lt;p&gt;能下载文件就算安装成功。注意和第三点中直接使用nginx路由访问不同的是，这里配置 fastdfs-nginx-module 模块，可以重定向文件链接到源服务器取文件。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;http://file.ljzsg.com/group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;最终部署结构图(盗的图)：可以按照下面的结构搭建环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012180511480-692747720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、Java客户端&lt;/h2&gt;
&lt;p&gt;前面文件系统平台搭建好了，现在就要写客户端代码在系统中实现上传下载，这里只是简单的测试代码。&lt;/p&gt;
&lt;h3&gt;1、首先需要搭建 FastDFS 客户端Java开发环境&lt;/h3&gt;
&lt;p&gt;① 项目中使用maven进行依赖管理，可以在pom.xml中引入如下依赖即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;net.oschina.zcx7878&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.27.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它的方式，参考官方文档：https://github.com/happyfish100/fastdfs-client-java&lt;/p&gt;
&lt;p&gt;② 引入配置文件&lt;/p&gt;
&lt;p&gt;可直接复制包下的 fastdfs-client.properties.sample 或者 fdfs_client.conf.sample，到你的项目中，去掉.sample。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012112805371-395330483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里直接复制 fastdfs-client.properties.sample 中的配置到项目配置文件 config.properties 中，修改tracker_servers。只需要加载这个配置文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012120004199-247798219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、客户端API&lt;/h3&gt;
&lt;p&gt;个人封装的FastDFS Java API以同步到github：&lt;a href=&quot;https://github.com/bojiangzhou/lyyzoo-fastdfs-java.git&quot; target=&quot;_blank&quot;&gt;https://github.com/bojiangzhou/lyyzoo-fastdfs-java.git&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;六、权限控制&lt;/h3&gt;
&lt;p&gt;前面使用nginx支持http方式访问文件，但所有人都能直接访问这个文件服务器了，所以做一下权限控制。&lt;/p&gt;
&lt;p&gt;FastDFS的权限控制是在服务端开启token验证，客户端根据文件名、当前unix时间戳、秘钥获取token，在地址中带上token参数即可通过http方式访问文件。&lt;/p&gt;
&lt;p&gt;① 服务端开启token验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
修改http.conf
# vim /etc/fdfs/http.conf

设置为true表示开启token验证
&lt;span readability=&quot;2&quot;&gt;http.anti_steal.check_token=true&lt;p&gt;&lt;span&gt;设置token失效的时间单位为秒(s)&lt;/span&gt;&lt;br/&gt;http.anti_steal.token_ttl=1800&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
密钥，跟客户端配置文件的fastdfs.http_secret_key保持一致
&lt;span&gt;http.anti_steal.secret_key=FASTDFS1234567890&lt;/span&gt;

如果token检查失败，返回的页面
&lt;span&gt;http.anti_steal.token_check_fail=/ljzsg/fastdfs/page/403.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得重启服务。&lt;/p&gt;
&lt;p&gt;② 配置客户端&lt;/p&gt;
&lt;p&gt;客户端只需要设置如下两个参数即可，两边的密钥保持一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# token 防盗链功能
fastdfs.http_anti_steal_token=true
# 密钥
fastdfs.http_secret_key=FASTDFS1234567890
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 客户端生成token&lt;/p&gt;
&lt;p&gt;访问文件需要带上生成的token以及unix时间戳，所以返回的token是token和时间戳的拼接。&lt;/p&gt;
&lt;p&gt;之后，将token拼接在地址后即可访问：file.ljzsg.com/group1/M00/00/00/wKgzgFnkaXqAIfXyAAEoRmXZPp878.jpeg?token=078d370098b03e9020b82c829c205e1f&amp;amp;ts=1508141521&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 获取访问服务器的token，拼接到地址后面
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; filepath 文件路径 group1/M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; httpSecretKey 密钥
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回token，如： token=078d370098b03e9020b82c829c205e1f&amp;amp;ts=1508141521
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getToken(String filepath, String httpSecretKey){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unix seconds&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ts = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) Instant.now().getEpochSecond();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; token&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         String token = &quot;null&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             token =&lt;span&gt; ProtoCommon.getToken(getFilename(filepath), ts, httpSecretKey);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MyException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         sb.append(&quot;token=&quot;&lt;span&gt;).append(token);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         sb.append(&quot;&amp;amp;ts=&quot;&lt;span&gt;).append(ts);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 注意事项&lt;/p&gt;
&lt;p&gt;如果生成的token验证无法通过，请进行如下两项检查：&lt;br/&gt;　　A. 确认调用token生成函数(ProtoCommon.getToken)，传递的文件ID中没有包含group name。传递的文件ID格式形如：M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg&lt;/p&gt;
&lt;p&gt;　　B. 确认服务器时间基本是一致的，注意服务器时间不能相差太多，不要相差到分钟级别。&lt;/p&gt;
&lt;p&gt;⑤ 对比下发现，如果系统文件隐私性较高，可以直接通过fastdfs-client提供的API去访问即可，不用再配置Nginx走http访问。配置Nginx的主要目的是为了快速访问服务器的文件(如图片)，如果还要加权限验证，则需要客户端生成token，其实已经没有多大意义。&lt;/p&gt;
&lt;p&gt;关键是，这里我没找到FastDFS如何对部分资源加token验证，部分开放。有知道的还请留言。&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;OK，以上就是单机中使用FastDFS搭建文件系统并上传下载的过程。&lt;/p&gt;
&lt;p&gt;完！！！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:24:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chiangchou/p/fastdfs.html</dc:identifier>
</item>
<item>
<title>Java集合源码分析（二）Linkedlist - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7688304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7688304.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面一篇我们分析了ArrayList的源码，这一篇分享的是LinkedList。我们都知道它的底层是由链表实现的，所以我们要明白什么是链表？&lt;/p&gt;

&lt;h2&gt;1.1、LinkedList概述&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018185451506-2136799134.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LinkedList是一种可以在&lt;span&gt;任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;br/&gt;　　LinkedList 实现 List 接口，能对它进行队列操作。&lt;br/&gt;　　LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;br/&gt;　　LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;br/&gt;　　LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;br/&gt;　　LinkedList 是非同步的。&lt;/p&gt;
&lt;h2&gt;1.2、LinkedList的数据结构&lt;/h2&gt;
&lt;p&gt;　　1）基础知识补充&lt;/p&gt;
&lt;p&gt;　　　　1.1）单向链表：&lt;/p&gt;
&lt;p&gt;　　　　　　element：用来存放元素&lt;/p&gt;
&lt;p&gt;　　　　　　next：用来指向下一个节点元素&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018163705615-546509635.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.2）单向循环链表&lt;/p&gt;
&lt;p&gt;　　　　　　element、next 跟前面一样&lt;/p&gt;
&lt;p&gt;　　　　　　在&lt;span&gt;单向链表的最后一个节点的next会指向头节点，而不是指向null，这样存成一个环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018163849318-946854643.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.3）双向链表&lt;/p&gt;
&lt;p&gt;　　　　　　element：存放元素&lt;/p&gt;
&lt;p&gt;　　　　　　pre：用来指向前一个元素&lt;/p&gt;
&lt;p&gt;　　　　　　next：指向后一个元素&lt;/p&gt;
&lt;p&gt;　　　　　　双向链表是&lt;span&gt;包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164025990-1035906814.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.4）双向循环链表&lt;/p&gt;
&lt;p&gt;　　　　　　element、pre、next 跟前面的一样&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;　第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164246521-25397602.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）LinkedList的数据结构&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164511396-1020210450.png&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如上图所示，&lt;span&gt;LinkedList底层使用的双向链表结构&lt;/span&gt;，有一个头结点和一个尾结点，双向链表意味着我们可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。&lt;/p&gt;
&lt;h2&gt;1.3、LinkedList的特性&lt;/h2&gt;
&lt;p&gt;　　在我们平常中我们只知道一些常识性的特点：&lt;/p&gt;
&lt;p&gt;　　　　1）是通过链表实现的，&lt;/p&gt;
&lt;p&gt;　　　　2）如果在频繁的插入，或者删除数据时，就用linkedList性能会更好。&lt;/p&gt;
&lt;p&gt;　　那我们通过API去查看它的一些特性&lt;/p&gt;
&lt;p&gt;　　　　1）Doubly-linked list implementation of the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Deque&lt;/code&gt; interfaces. Implements all optional list operations, and permits all elements (including &lt;code&gt;null&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;　　　　　　这告诉我们，&lt;span&gt;linkedList是一个双向链表，并且实现了List和Deque接口中所有的列表操作&lt;/span&gt;，&lt;span&gt;并且能存储任何元素，包括null&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　　　这里我们可以知道linkedList除了可以&lt;span&gt;当链表使用，还可以当作队列使用&lt;/span&gt;，并能进行相应的操作。&lt;/p&gt;
&lt;p&gt;　　　　2）All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.&lt;/p&gt;
&lt;p&gt;　　　　　　这个告诉我们，&lt;span&gt;linkedList在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所需要的的值&lt;/span&gt;。通俗点讲，这就告诉了我们这个是&lt;span&gt;顺序存取，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　每次操作必须先按开始到结束的顺序遍历，随机存取，就是arrayList，能够通过index。随便访问其中的任意位置的数据，这就是随机列表的意思&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　3）api中接下来讲的一大堆，就是说明&lt;span&gt;linkedList是一个非线程安全的(异步)&lt;/span&gt;，其中在操作Interator时，如果改变列表结构(add\delete等)，会发生fail-fast。&lt;/p&gt;
&lt;p&gt;　　通过API再次总结一下LinkedList的特性：　　&lt;/p&gt;
&lt;p&gt;　　　　1）异步，也就是非线程安全&lt;/p&gt;
&lt;p&gt;　　　　2）双向链表。由于实现了list和Deque接口，能够当作队列来使用。&lt;/p&gt;
&lt;p&gt;　　　　　　链表：查询效率不高，但是插入和删除这种操作性能好。&lt;/p&gt;
&lt;p&gt;　　　　3）是顺序存取结构（注意和随机存取结构两个概念搞清楚）&lt;/p&gt;

&lt;h2&gt;2.1、LinkedList的继承结构以及层次关系&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018170001771-1514436408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　我们可以看到，linkedList在最底层，说明他的功能最为强大，并且细心的还会发现，arrayList只有四层，这里多了一层AbstractSequentialList的抽象类，为什么呢？&lt;/p&gt;
&lt;p&gt;　　　　通过API我们会发现：&lt;/p&gt;
&lt;p&gt;　　　　　　1）减少实现顺序存取（例如LinkedList）这种类的工作，通俗的讲就是方便，抽象出类似LinkedList这种类的一些共同的方法&lt;/p&gt;
&lt;p&gt;　　　　　　2）既然有了上面这句话，那么以后如果自己想&lt;span&gt;实现顺序存取这种特性的类(就是链表形式)，那么就继承这个AbstractSequentialList抽象类&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果想像&lt;span&gt;数组那样的随机存取的类，那么就去实现AbstracList抽象类&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　3）这样的分层，就很符合我们抽象的概念，&lt;span&gt;越在高处的类，就越抽象，往在底层的类，就越有自己独特的个性&lt;/span&gt;。自己要慢慢领会这种思想。&lt;/p&gt;
&lt;p&gt;　　　　　　4）LinkedList的类继承结构很有意思，我们着重要看是&lt;span&gt;Deque接口，Deque接口表示是一个双端队列，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　那么也意味着LinkedList是双端队列的一种实现，所以，基于双端队列的操作在LinkedList中全部有效&lt;/span&gt;。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7be78dd2-b633-49d5-943c-9659bf688715')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7be78dd2-b633-49d5-943c-9659bf688715',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt;&lt;span&gt;
extends AbstractList&lt;/span&gt;&amp;lt;E&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里第一段就解释了这个类的作用，这个类为实现list接口提供了一些重要的方法，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尽最大努力去减少实现这个“顺序存取”的特性的数据存储(例如链表)的什么鬼，对于
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机存取数据(例如数组)的类应该优先使用AbstractList
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从上面就可以大概知道，AbstractSwquentialList这个类是为了减少LinkedList这种顺&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序存取的类的代码复杂度而抽象的一个类，&lt;/span&gt;
This &lt;span&gt;class&lt;/span&gt; provides a skeletal implementation of the List &lt;span&gt;interface&lt;/span&gt; to minimize the effort required to implement &lt;span&gt;this&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; backed by a &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sequential access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data store (such &lt;span&gt;as&lt;/span&gt; a linked list). For random access data (such &lt;span&gt;as&lt;/span&gt; an array), AbstractList should be used &lt;span&gt;in&lt;/span&gt; preference to &lt;span&gt;this&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一段大概讲的就是这个AbstractSequentialList这个类和AbstractList这个类是完全&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相反的。比如get、add这个方法的实现&lt;/span&gt;
This &lt;span&gt;class&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; the opposite of the AbstractList &lt;span&gt;class&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; the sense that it implements the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;random access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; methods (&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index), &lt;span&gt;set&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element), add(&lt;span&gt;int&lt;/span&gt; index, E element) and remove(&lt;span&gt;int&lt;/span&gt; index)) on top of the list&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s list iterator, instead of the other way around.&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是讲一些我们自己要继承该类，该做些什么事情，一些规范。&lt;/span&gt;
To implement a list the programmer needs only to extend &lt;span&gt;this&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; and provide implementations &lt;span&gt;for&lt;/span&gt; the listIterator and size methods. For an unmodifiable list, the programmer need only implement the list iterator&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s hasNext, next, hasPrevious, previous and index methods.&lt;/span&gt;
&lt;span&gt;
For a modifiable list the programmer should additionally implement the list iterator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s set method. For a variable-size list the programmer should additionally implement the list iterator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s remove and add methods.

The programmer should generally provide a &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (no argument) and collection constructor, &lt;span&gt;as&lt;/span&gt; per the recommendation &lt;span&gt;in&lt;/span&gt; the Collection &lt;span&gt;interface&lt;/span&gt; specification.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AbstractSequentialList&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　实现接口分析：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018171102756-1197666604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　1）List接口：列表，add、set、等一些对列表进行操作的方法&lt;/p&gt;
&lt;p&gt;　　　　　　2）Deque接口：有队列的各种特性，&lt;/p&gt;
&lt;p&gt;　　　　　　3）Cloneable接口：能够复制，使用那个copy方法。&lt;/p&gt;
&lt;p&gt;　　　　　　4）Serializable接口：能够序列化。&lt;/p&gt;
&lt;p&gt;　　　　　　5）应该注&lt;span&gt;意到没有RandomAccess：那么就推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator都可以&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;2.2、类的属性　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt;
    extends AbstractSequentialList&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt;
    implements List&lt;/span&gt;&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际元素个数&lt;/span&gt;
    transient &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点&lt;/span&gt;
    transient Node&amp;lt;E&amp;gt;&lt;span&gt; first;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾结点&lt;/span&gt;
    transient Node&amp;lt;E&amp;gt;&lt;span&gt; last;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　LinkedList的属性非常简单，&lt;span&gt;一个头结点、一个尾结点、一个表示链表中实际元素个数的变量&lt;/span&gt;。注意，&lt;span&gt;头结点、尾结点都有transient关键字修饰，这也意味着在序列化时该域是不会序列化的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3、LinkedList的构造方法&lt;/h2&gt;
&lt;p&gt;　　两个构造方法(两个构造方法都是规范规定需要写的）&lt;/p&gt;
&lt;p&gt;　　1）空参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Constructs an empty list.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）有参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param  c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;   //&lt;/span&gt;&lt;span&gt;将集合c中的各个元素构建成LinkedList链表。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
     // 调用无参构造函数
        this();
        // 添加集合中所有的元素
        addAll(c);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：会调用无参构造函数，并且会把集合中所有的元素添加到LinkedList中。　　　&lt;/p&gt;
&lt;h2&gt;2.4、内部类（Node）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里。
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据域（当前节点的值）&lt;/span&gt;
        Node&amp;lt;E&amp;gt; next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后继（指向当前一个节点的后一个节点）&lt;/span&gt;
        Node&amp;lt;E&amp;gt; prev; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱（指向当前节点的前一个节点）
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数，赋值前驱后继&lt;/span&gt;
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：内部类Node就是实际的结点，用于存放实际元素的地方。　　　　　&lt;/p&gt;
&lt;h2&gt; 2.5、核心方法&lt;/h2&gt;
&lt;h3&gt;　　2.5.1、add()方法&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018180421865-139109156.png&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;126&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　1）add(E)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean add(E e) {
       　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到末尾&lt;/span&gt;
&lt;span&gt;        　　linkLast(e);
        　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  　　  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：add函数&lt;span&gt;用于向LinkedList中添加一个元素，并且添加到链表尾部。具体添加到尾部的逻辑是由linkLast函数完成的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　分析：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;　LinkLast(XXXXX)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Links e as last element.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; l = last;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;临时节点l(L的小写)保存last，也就是l指向了最后一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将e封装为节点，并且e.prev指向了最后一个节点&lt;/span&gt;
        last = newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newNode成为了最后一个节点，所以last指向了它&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是不是一开始链表中就什么都没有，如果没有，则newNode就成为了第一个节点，first和last都要指向它&lt;/span&gt;
            first =&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的最后一个节点，原先的最后一个节点就变成了倒数第二个节点&lt;/span&gt;
            l.next =&lt;span&gt; newNode;
        size&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个节点，size自增&lt;/span&gt;
        modCount++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：对于&lt;span&gt;添加一个元素至链表中会调用add方法 -&amp;gt; linkLast方法&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　举例一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　List&amp;lt;Integer&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
　　　　lists.add(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
　　　　lists.add(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　首先调用无参构造函数，之后添加元素5，之后再添加元素6。具体的示意图如下：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018180943006-1444550237.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　上图的表明了在执行每一条语句后，链表对应的状态。&lt;/p&gt;
&lt;h3&gt;　　2.5.2、addAll方法&lt;/h3&gt;
&lt;p&gt;　　　　addAll有两个重载函数，addAll(Collection&amp;lt;? extends E&amp;gt;)型和addAll(int, Collection&amp;lt;? extends E&amp;gt;)型，我们平时习惯调用的addAll(Collection&amp;lt;? extends E&amp;gt;)型会转化为addAll(int, Collection&amp;lt;? extends E&amp;gt;)型。&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　1）addAll(c);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; boolean addAll(Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续往下看&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; addAll(size, c);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;　　2）addAll(size，c)：这个方法，能包含三种情况下的添加，我们这里分析的只是构造方法，空链表的情况(情况一)看的时候只需要按照不同的情况分析下去就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正核心的地方就是这里了，记得我们传过来的是size，c&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; boolean addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查index这个是否为合理。这个很简单，自己点进去看下就明白了。&lt;/span&gt;
&lt;span&gt;        checkPositionIndex(index);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将集合c转换为Object数组 a&lt;/span&gt;
        Object[] a =&lt;span&gt; c.toArray();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组a的长度numNew，也就是由多少个元素&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numNew == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合c是个空的，直接返回false，什么也不做。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合c是非空的，定义两个节点(内部类)，每个节点都有三个属性，item、next、prev。注意：不要管这两个什么含义，就是用来做临时存储节点的。这个Node看下面一步的源码分析，Node就是linkedList的最核心的实现，可以直接先跳下一个去看Node的分析&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; pred, succ;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法中传过来的就是index==size&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;linkedList中三个属性：size、first、last。 size：链表中的元素个数。 first：头节点  last：尾节点，就两种情况能进来这里

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况一、：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedList中是空的。什么节点都没有。succ=null、pred=last=null

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况二、：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。&lt;/span&gt;
            succ = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            pred &lt;/span&gt;=&lt;span&gt; last;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，就需要知道第一个位置是谁，原位置也就是第二个位置上是谁，然后才能将自己插到第二个位置上。如果这里还不明白，先看一下文章开头对于各种链表的删除，add操作是怎么实现的。&lt;/span&gt;
            succ =&lt;span&gt; node(index);
            pred &lt;/span&gt;=&lt;span&gt; succ.prev;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面的准备工作做完了，将遍历数组a中的元素，封装为一个个节点。&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : a) {
            @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) E e =&lt;span&gt; (E) o;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pred就是之前所构建好的，可能为null、也可能不为null，为null的话就是属于情况一、不为null则可能是情况二、或者情况三&lt;/span&gt;
            Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(pred, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，此时的newNode就当作第一个节点，所以把newNode给first头节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                first &lt;/span&gt;=&lt;span&gt; newNode;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果pred！=null，说明可能是情况2或者情况3，如果是情况2，pred就是last，那么在最后一个节点之后追加到newNode，如果是情况3，在中间插入，pred为原index节点之前的一个节点，将它的next指向插入的节点，也是对的&lt;/span&gt;
                pred.next =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将pred换成newNode，注意，这个不在else之中，请看清楚了。&lt;/span&gt;
            pred =&lt;span&gt; newNode;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (succ == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果succ==null，说明是情况一或者情况二，&lt;/span&gt;
情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，last=&lt;span&gt;newNode，所以linkedList的first、last都指向第一个节点。
情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点了，就是newNode。
            last &lt;/span&gt;=&lt;span&gt; pred;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果succ！=null，说明可能是情况三、在中间插入节点，举例说明这几个参数的意义，有1、2两个节点，现在想在第二个位置插入节点newNode，根据前面的代码，pred=newNode，succ=2，并且1.next=newNode，&lt;/span&gt;
1已经构建好了，pred.next=succ，相当于在newNode.next = &lt;span&gt;2&lt;/span&gt;； succ.prev = pred，相当于 &lt;span&gt;2&lt;/span&gt;.prev =&lt;span&gt; newNode， 这样一来，这种指向关系就完成了。first和last不用变，因为头节点和尾节点没变
            pred.next &lt;/span&gt;=&lt;span&gt; succ;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;。。&lt;/span&gt;
            succ.prev =&lt;span&gt; pred;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加了几个元素，就把 size = size +numNew 就可以了&lt;/span&gt;
        size +=&lt;span&gt; numNew;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：参数中的index表示在索引下标为index的结点（实际上是第index + 1个结点）的前面插入。　　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　　在addAll函数中，addAll函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索引下标找到该结点并返回，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断插入的位置在链表前半段或者是后半段&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入位置在前半段&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; first; 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从头结点开始正向遍历&lt;/span&gt;
                x =&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入位置在后半段&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; last; 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从尾结点开始反向遍历&lt;/span&gt;
                x =&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：在根据索引查找结点时，会有一个小优化，结点在前半段则从头开始遍历，在后半段则从尾开始遍历，这样就保证了只需要遍历最多一半结点就可以找到指定索引的结点。&lt;/p&gt;
&lt;p&gt;　　　　举例说明调用addAll函数后的链表状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　　　List&amp;lt;Integer&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
　　　　lists.add(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
　　　　lists.addAll(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, Arrays.asList(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　上述代码内部的链表结构如下：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018183422099-2095962383.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　addAll()中的一个问题&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　　在addAll函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？&lt;/p&gt;
&lt;p&gt;　　　　从效果上两者是完全等价的，都可以达到遍历的效果。关于为什么要转化为数组的问题，我的思考如下：1. 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，&lt;/p&gt;
&lt;p&gt;　　　　这个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。2. 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，&lt;/p&gt;
&lt;p&gt;　　　　所以占用的时间相对是较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的效率，尽可能短时间的阻塞。&lt;/p&gt;
&lt;h3&gt;　　2.5.3、remove(Object o)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Removes the first occurrence of the specified element from this list,
     * if it is present.  If this list does not contain the element, it is
     * unchanged.  More formally, removes the element with the lowest index
     * {@code i} such that
     * &amp;lt;tt&amp;gt;(o==null&amp;amp;nbsp;?&amp;amp;nbsp;get(i)==null&amp;amp;nbsp;:&amp;amp;nbsp;o.equals(get(i)))&amp;lt;/tt&amp;gt;
     * (if such an element exists).  Returns {@code true} if this list
     * contained the specified element (or equivalently, if this list
     * changed as a result of the call).
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if this list contained the specified element
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先通过看上面的注释，我们可以知道，如果我们要移除的值在链表中存在多个一样的值，那么我们会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean remove(Object o) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以看到，linkedList也能存储null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历链表，直到找到null值，然后使用unlink移除该值。下面的这个else中也一样&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　unlink(xxxx)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Unlinks non-null node x.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能传一个null值过，注意，看之前要注意之前的next、prev这些都是谁。&lt;/span&gt;
    E unlink(Node&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到节点x的三个属性&lt;/span&gt;
        final E element =&lt;span&gt; x.item;
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里开始往下就进行移除该元素之后的操作，也就是把指向哪个节点搞定。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明移除的节点是头节点，则first头节点应该指向下一个节点&lt;/span&gt;
            first =&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是头节点，prev.next=next：有1、2、3，将1.next指向3&lt;/span&gt;
            prev.next =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后解除x节点的前指向。&lt;/span&gt;
            x.prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明移除的节点是尾节点&lt;/span&gt;
            last =&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是尾节点，有1、2、3，将3.prev指向1. 然后将2.next=解除指向。&lt;/span&gt;
            next.prev =&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的前后指向都为null了，也把item为null，让gc回收它&lt;/span&gt;
        x.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除一个节点，size自减&lt;/span&gt;
        modCount++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; element;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于一开始已经保存了x的值到element，所以返回。&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5.4、get(index)&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;　get(index)查询元素的方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the element at the specified position in this list.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里没有什么，重点还是在node(index)中&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　node(index)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the (non-null) Node at the specified element index.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里查询使用的是先从中间分一半查找&lt;/span&gt;
    Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;&amp;lt;&quot;:*2的几次方 “&amp;gt;&amp;gt;”:/2的几次方，例如：size&amp;lt;&amp;lt;1：size*2的1次方，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个if中就是查询前半部分&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index&amp;lt;size/2&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前半部分没找到，所以找后半部分&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5.5、indexOf(Object o)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个很简单，就是通过实体元素来查找到该元素在链表中的位置。跟remove中的代码类似，只是返回类型不一样。&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是ListItr，还有一个是DescendingIterator。&lt;/p&gt;
&lt;h2&gt;　　3.1、ListItr内部类&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184723521-1419677680.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看一下他的继承结构，发现只继承了一个ListIterator，到ListIterator中一看：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184923443-1278868049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看到方法名之后，就发现不止有向后迭代的方法，还有向前迭代的方法，所以我们就知道了这个ListItr这个内部类干嘛用的了，就是能让linkedList不光能像后迭代，也能向前迭代。&lt;/p&gt;
&lt;p&gt; 　　　　看一下ListItr中的方法，可以发现，在迭代的过程中，还能移除、修改、添加值得操作。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184651412-1550358605.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　3.2、DescendingIterator内部类　　　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Adapter to provide descending iterators via ListItr.previous
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
　　　　&lt;span&gt;看一下这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维去写代码，例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DescendingIterator implements Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final ListItr itr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(size());
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.hasPrevious();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.previous();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            itr.remove();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1）linkedList本质上是&lt;span&gt;一个双向链表，通过一个Node内部类实现的这种链表结构&lt;/span&gt;。&lt;br/&gt;　　2）能&lt;span&gt;存储null值&lt;/span&gt;&lt;br/&gt;　　3）跟&lt;span&gt;arrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好&lt;/span&gt;&lt;br/&gt;　　4）从源码中看，&lt;span&gt;它不存在容量不足的情况&lt;/span&gt;&lt;br/&gt;　　5）linkedList不光&lt;span&gt;能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值&lt;/span&gt;。&lt;br/&gt;　　6）linkedList不光能&lt;span&gt;当链表，还能当队列使用，这个就是因为实现了Deque接口&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;喜欢就点个“推荐”！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:18:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7688304.html</dc:identifier>
</item>
<item>
<title>JavaScript中的this基本问题 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7689783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7689783.html</guid>
<description>&lt;p&gt;在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。 &lt;/p&gt;
&lt;p&gt;执行上下文环境 ：&lt;/p&gt;
&lt;p&gt; **定义**：执行函数的时候，会产生一个上下文的对象，里面保存变量，函数声明和this。&lt;/p&gt;
&lt;p&gt; **作用**：用来保存本次运行时所需要的数据&lt;/p&gt;
&lt;p&gt;当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。&lt;/p&gt;
&lt;p&gt;关于 this 的取值，大体上可以分为以下几种情况：&lt;/p&gt;
&lt;h2&gt;情况一：全局 &amp;amp; 调用普通函数&lt;/h2&gt;
&lt;p&gt;在全局环境中，this 永远指向 window。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(&lt;span&gt;this&lt;/span&gt; === window);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。&lt;/p&gt;
&lt;p&gt;但是如果在严格模式下调用的话会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
function first(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught TypeError: Cannot read property 'x' of undefined&lt;/span&gt;
&lt;span&gt;}
first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;情况二：构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;First {x:1}&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; First();
console.log(first.x);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。&lt;/p&gt;
&lt;p&gt;但是如果直接调用 First函数，而不是 new First()，那就变成情况1，这时候 First() 就变成普通函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =1&lt;span&gt;;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first =&lt;span&gt; First();
console.log(first.x);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;情况三：对象方法&lt;/h2&gt;
&lt;p&gt;如果函数作为对象的方法时，方法中的 this 指向该对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;.x);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;    }
};
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意：若是在对象方法中定义函数，那么情况就不同了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        function second(){
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
            console.log(&lt;span&gt;this&lt;/span&gt;.x);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;        }
        second();
    }
}
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这么理解：函数 second虽然是在 obj.first 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。&lt;/p&gt;
&lt;p&gt;在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x:1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        function second(){
            console.log(self);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{x: 1}&lt;/span&gt;
            console.log(self.x);    &lt;span&gt;//1&lt;/span&gt;
&lt;span&gt;        }
        second();
    }
}
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 first 函数不作为对象方法被调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;.x);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; obj.first;
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;obj.first 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。&lt;/p&gt;
&lt;h2&gt;情况四：构造函数 prototype 属性&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
First.prototype.getX &lt;/span&gt;=&lt;span&gt; function () {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;First {x: 1, getX: function}&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; First();
first.getX();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 First.prototype.getX 函数中，this 指向的first 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。&lt;/p&gt;
&lt;h2&gt;情况五：函数用 call&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x:1&lt;/span&gt;&lt;span&gt;
}
function first(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{x: 1}&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}
first.call(obj);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个函数被 call调用时，this 的值就取传入的对象的值。&lt;/p&gt;
&lt;p&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;链接：https://zhuanlan.zhihu.com/p/25294187?utm_source=com.youdao.note&amp;amp;utm_medium=social&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&quot;PostIndex-authorName&quot; href=&quot;https://www.zhihu.com/people/lindongzhou&quot; target=&quot;_blank&quot;&gt;林东洲&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:17:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7689783.html</dc:identifier>
</item>
<item>
<title>前端笔记----jquery入门知识点总结 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/7633623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/7633623.html</guid>
<description>&lt;h3 id=&quot;一jquery的加载方法&quot;&gt;一、jquery的加载方法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;$(document).ready(function(){js代码});&lt;/li&gt;
&lt;li&gt;$(function(){js代码});（一般使用这个）;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意点1：使用jquery必须先导入函数库文件，使用一个单独的script标签，结束代码另起一行script。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;./jquery-1.12.4.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    
&amp;lt;script&amp;gt;js的代码&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点2：在加载完毕后需要判断是否加载成功，一般使用length属性判断输出，如果不成功，length输出0；成功输出非0.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
        $(function () {
            $div = $(&quot;.box&quot;);
            console.log($Div.length);
        })
    &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二jquery选择器获取标签&quot;&gt;二、jquery选择器，获取标签&lt;/h3&gt;
&lt;p&gt;说明：选择器和css选择器的写法相同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;选择元素：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(document) //选择整个文档对象
$('li') //标签选择元素
$('#myId') //通过id选择元素
$('.myClass') // 通过class属性选择
$('input[name=first]') // 选择name属性等于first的input元素，通过行内属性和标签结合选择
$('#ul1 li span') //层级选择
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;修饰过滤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$('ul li:first') //选择ul元素下的第一个li
$('ul li:odd') //选择ul元素下的li的奇数行
$('ul li:eq(2)') //选择ul元素下的第3个li
$('ul li:gt(2)') // 选择ul元素下的第三个之后的li
$('ul li:lt(2)') // 选择ul元素下的第三个之前的li，不包括第三个
$('div:visible') //选择可见的div元素&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数过滤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$('div').has('p'); // 选择包含p元素的div元素
$('div').not('.myClass'); //选择class不等于myClass的div元素
$('div').filter('.myClass'); //选择class等于myClass的div元素
$('div').first(); //选择页面中第1个div元素
$('div').eq(5); //选择角标是5的div元素
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;选择集转移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$('div').prev('p'); //选择div元素前面的第一个p元素
$('div').next('p'); //选择div元素后面的第一个p元素
$('div').closest('div'); //选择离div最近的那个div父元素
$('div').parent(); //选择div的一级父元素
$('div').children(); //选择div的所有子元素
$('div').siblings(); //选择div的同级元素
$('div').find('.myClass'); //选择div内的class等于myClass的所有元素
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三jquery的动画animate方法分析&quot;&gt;三、jquery的动画animate方法分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用方法&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$('#div1').animate({
  &quot;width&quot;:300,
  &quot;height&quot;:300
},1000,'swing',function(){
  alert('done!');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;参数分析：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第一个参数设置需要变化的属性，一般用来设置与尺寸相关的属性变化，如果改变的是颜色需要额外引入jquery.color的库。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意1：属性名必须添加引号，多个属性用逗号隔开值设置如上，可以是300,&quot;300&quot;，&quot;300px&quot;,程序可以识别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意2：如果只写第一个参数，则默认500ms，匀速运动，没有执行后动作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展：点击按钮返回顶部页面的通用方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;html,body&quot;).animate({
    &quot;scrollTop&quot;:0
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四绑定点击事件click&quot;&gt;四、绑定点击事件click&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$('#btn1').click(function(){});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：参数可以是匿名函数，也可以是命名函数；但如果需要传参，则必须使用匿名函数。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;内部&lt;/strong&gt;：使用$(this)代表当前点击的这个元素，如果使用this则是原生的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;几乎所有的元素类型都可以使用click事件，点击触发，不一定是a、input标签。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;五页面滚动事件&quot;&gt;五、页面滚动事件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$(window).scroll(function(){  
    ......  
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之相关的有两个常用的获取滚动距离的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(document).scrollTop(); //获取距离文档顶部的距离 
$(document).scrollLeft();//获取距离文档左边的距离&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：滚动事件只有在文档的高度或宽度大于窗口的宽高时才会生效。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;六操作属性&quot;&gt;六、操作属性&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;普通样式&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 获取div的样式
$(&quot;div&quot;).css(&quot;width&quot;);
//设置div的样式
$(&quot;div&quot;).css(&quot;width&quot;,&quot;30px&quot;);
$(&quot;div&quot;).css({fontSize:&quot;30px&quot;,color:&quot;red&quot;});&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意点1：设置样式时，如果只有一个样式，用逗号隔开，不是冒号；当多个样式设置时才用冒号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点2：选择器获取的是一个选择集，那么获取到的样式为第一个标签的样式。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;操作类名&quot;&gt;&lt;strong&gt;操作类名：&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#div1&quot;).addClass(&quot;divClass2&quot;) //为id为div1的对象追加样式divClass2
$(&quot;#div1&quot;).removeClass(&quot;divClass&quot;)  //移除id为div1的对象的class名为divClass的样式
$(&quot;#div1&quot;).removeClass(&quot;divClass divClass2&quot;) //移除多个样式
$(&quot;#div1&quot;).toggleClass(&quot;anotherClass&quot;) //重复切换anotherClass样式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：addClass()方法中的括号内直接写类名，不再是选择样式。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;操作html标签&quot;&gt;&lt;strong&gt;操作html标签&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 取出html内容
var $htm = $('#div1').html();
// 设置html内容
$('#div1').html('&amp;lt;div&amp;gt;xxx&amp;lt;/div&amp;gt;');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：取出时会将这个标签下的所有的html内容输出，包括标签本身。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;只取文本内容&quot;&gt;&lt;strong&gt;只取文本内容&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 取出文本内容
var $htm = $('#div1').text();
// 设置文本内容
$('#div1').text('添加文字');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：设置文本内容时，加入标签是没有作用的，标签会被当做文本进行解析。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;设置行内属性&quot;&gt;&lt;strong&gt;设置行内属性&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 取出按钮的值
var $value = $('input').attr('value');
// 设置按钮的值
$('input').attr({ &quot;value&quot;:&quot;按钮&quot; });
// 取出图片的地址
var $src = $('#img').prop('src');
// 设置图片的地址和alt属性
$('#img').prop({src: &quot;test.jpg&quot;, alt: &quot;&quot; });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：以上attr方法和prop方法使用方式一样；但是attr可以获取系统不存在的自定义的属性，而prop获取不到；所有的属性需要用引号包裹，否则报错。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;操作尺寸&quot;&gt;操作尺寸&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取元素尺寸&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(&quot;div&quot;).width() // 获取元素width
$(&quot;div&quot;).height() //获取元素height  
$(&quot;div&quot;).innerWidth() //获取包括padding的width
$(&quot;div&quot;).innerHeight() //获取包括padding的height  
$(&quot;div&quot;).outerWidth() //包括padding和border的width
$(&quot;div&quot;).outerHeight()//包括padding和border的height    
$(&quot;div&quot;).outerWidth(true)//包括padding和border以及margin的width
$(&quot;div&quot;).outerHeight(true)//包括padding和border以及margin的height&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取浏览器可视区的宽高&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(window).width();
$(window).height();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取页面文档的宽度高度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
$(document).width();
$(document).height();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取元素相对页面的绝对位置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var $n1 = $(&quot;div&quot;).offset();
$left = $n1.left;  # 获取相对页面左边的距离
$top = $n1.top;  # 获取相对页面上边的距离&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取元素相对父类的绝对位置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var $n1 = $(&quot;div&quot;).offsetParent();
$left = $n1.left;  # 获取相对父类左边的距离
$top = $n1.top;  # 获取相对父类上边的距离
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七常用的特殊效果动画&quot;&gt;七、常用的特殊效果（动画）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;淡入、淡出和切换淡入淡出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; $('#div1').fadeIn(1000,'swing',function(){
    alert('done!');
});  //淡入，事件1秒，渐变，参数和animate相仿
fadeOut() 淡出
fadeToggle() 切换淡入淡出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：下面的动画方法和这里的参数一样。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;隐藏、显示和切换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;hide() 隐藏元素
show() 显示元素
toggle() 切换显示状态，参数和上面相同&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;展开、卷起和切换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;slideDown() 向下展开
slideUp() 向上卷起
slideToggle() 展开和卷起切换&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：以上的效果一般使用在点击事件中。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;八循环&quot;&gt;八、循环&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; $('div').each(function(i,j){
    ...
    })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：当一次获取了多个div时，如果需要对每个元素进行不同的有规律的操作，使用each方法，内部用$(this)代表循环到的那个元素。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;默认参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;循环方法中的function匿名函数中携带了两个默认参数，如上代码，i代表当前div的角标值，j代表当前div元素本身;这两个参数可以用任何变量表示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;each循环和annimate动画嵌套不能改变颜色，如下：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$div.each(function (i,j) {
    $(this).animate({
         &quot;background&quot;:&quot;blue&quot;,
        });                   
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：该代码欲要实现每个div背景色逐个变蓝，实际不会起任何的作用；但对于宽高等属性是起作用的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;九this关键字&quot;&gt;九、this关键字&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$lis.click(function () {
    //此时的$(this)代表$lis选择集下的当前点击的$lis
    $(this).prevAll().each(function () {
        //$(this)代表点击的$lis.prevAll()，this代表的元素发生了改变
        $(this).animate({
        &quot;left&quot;: 21 * $(this).index(),
        })
    })
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结this-永远代表当前触发事件的那个对象&quot;&gt;总结：this 永远代表当前触发事件的那个对象。&lt;/h4&gt;
</description>
<pubDate>Wed, 18 Oct 2017 15:17:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/7633623.html</dc:identifier>
</item>
<item>
<title>hadoop之 hadoop 2.2.X 弃用的配置属性名称及其替换名称对照表 - 张冲andy</title>
<link>http://www.cnblogs.com/andy6/p/7689773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy6/p/7689773.html</guid>
<description>&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;create.empty.dir.if.nonexist&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobcontrol.createdir.ifnotexist&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.access.time.precision&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.accesstime.precision&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.backup.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.backup.address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.backup.http.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.backup.http-address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.balance.bandwidthPerSec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.datanode.balance.bandwidthPerSec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.block.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.blocksize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.data.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.datanode.data.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.datanode.max.xcievers&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.datanode.max.transfer.threads&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.df.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;fs.df.interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.federation.nameservice.id&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.nameservice.id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.federation.nameservices&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.nameservices&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.http.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.http-address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.https.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.https-address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.https.client.keystore.resource&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.client.https.keystore.resource&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.https.need.client.auth&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.client.https.need-auth&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.max.objects&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.max.objects&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.max-repl-streams&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.replication.max-streams&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.name.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.name.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.name.dir.restore&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.name.dir.restore&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.name.edits.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.edits.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.permissions&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.permissions.enabled&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.permissions.supergroup&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.permissions.superusergroup&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.read.prefetch.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.client.read.prefetch.size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.replication.considerLoad&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.replication.considerLoad&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.replication.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.replication.interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.replication.min&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.replication.min&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.replication.pending.timeout.sec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.replication.pending.timeout-sec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.safemode.extension&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.safemode.extension&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.safemode.threshold.pct&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.safemode.threshold-pct&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.secondary.http.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.secondary.http-address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.socket.timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.client.socket-timeout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.umaskmode&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;fs.permissions.umask-mode&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;dfs.write.packet.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.client-write-packet-size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;fs.checkpoint.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.checkpoint.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;fs.checkpoint.edits.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.checkpoint.edits.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;fs.checkpoint.period&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.checkpoint.period&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;fs.default.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;fs.defaultFS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.configured.node.mapping&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;net.topology.configured.node.mapping&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.job.history.location&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.jobhistory.location&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.native.lib&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;io.native.lib.available&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.net.static.resolutions&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.net.static.resolutions&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.command-file.keep&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.commandfile.preserve&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.executable.interpretor&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.executable.interpretor&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.executable&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.executable&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.java.mapper&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.isjavamapper&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.java.recordreader&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.isjavarecordreader&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.java.recordwriter&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.isjavarecordwriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.java.reducer&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.isjavareducer&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;hadoop.pipes.partitioner&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.partitioner&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;heartbeat.recheck.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.namenode.heartbeat.recheck-interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;io.bytes.per.checksum&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.bytes-per-checksum&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;io.sort.factor&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.io.sort.factor&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;io.sort.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.io.sort.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;io.sort.spill.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.sort.spill.percent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;jobclient.completion.poll.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.client.completion.pollinterval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;jobclient.output.filter&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.client.output.filter&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;jobclient.progress.monitor.poll.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.client.progressmonitor.pollinterval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;job.end.notification.url&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.end-notification.url&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;job.end.retry.attempts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.end-notification.retry.attempts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;job.end.retry.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.end-notification.retry.interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;job.local.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.local.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;keep.failed.task.files&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.files.preserve.failedtasks&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;keep.task.files.pattern&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.files.preserve.filepattern&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;key.value.separator.in.input.line&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.keyvaluelinerecordreader.key.value.separator&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;local.cache.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.cache.local.size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;map.input.file&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.input.file&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;map.input.length&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.input.length&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;map.input.start&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.input.start&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;map.output.key.field.separator&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.output.key.field.separator&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;map.output.key.value.fields.spec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.fieldsel.map.output.key.value.fields.spec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.acls.enabled&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.acls.enabled&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.binary.partitioner.left.offset&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.partition.binarypartitioner.left.offset&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.binary.partitioner.right.offset&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.partition.binarypartitioner.right.offset&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.archives&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.archives&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.archives.timestamps&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.archives.timestamps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.files&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.files&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.files.timestamps&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.files.timestamps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.localArchives&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.local.archives&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cache.localFiles&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.cache.local.files&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.child.tmp&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.tmp.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cluster.average.blacklist.threshold&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.blacklist.average.threshold&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cluster.map.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.mapmemory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cluster.max.map.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.maxmapmemory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cluster.max.reduce.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.maxreducememory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.cluster.reduce.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.reducememory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.committer.job.setup.cleanup.needed&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.committer.setup.cleanup.needed&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.compress.map.output&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.output.compress&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.data.field.separator&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.fieldsel.data.field.separator&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.debug.out.lines&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.debugout.lines&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.healthChecker.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.healthchecker.interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.healthChecker.script.args&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.healthchecker.script.args&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.healthChecker.script.path&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.healthchecker.script.path&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.healthChecker.script.timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.healthchecker.script.timeout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.heartbeats.in.second&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.heartbeats.in.second&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.hosts.exclude&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.hosts.exclude.filename&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.hosts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.hosts.filename&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.inmem.merge.threshold&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.merge.inmem.threshold&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.input.dir.formats&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.multipleinputs.dir.formats&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.input.dir.mappers&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.multipleinputs.dir.mappers&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.input.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.fileinputformat.inputdir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.input.pathFilter.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.pathFilter.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jar&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.jar&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.classpath.archives&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.classpath.archives&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.classpath.files&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.classpath.files&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.id&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobinit.threads&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.jobinit.threads&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.map.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.memory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.name&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.priority&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.priority&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.queue.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.queuename&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.reduce.input.buffer.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.input.buffer.percent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.reduce.markreset.buffer.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.markreset.buffer.percent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.reduce.memory.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.memory.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.reduce.total.mem.bytes&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.memory.totalbytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.reuse.jvm.num.tasks&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.jvm.numtasks&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.shuffle.input.buffer.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.shuffle.input.buffer.percent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.shuffle.merge.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.shuffle.merge.percent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.handler.count&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.handler.count&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.history.completed.location&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.jobhistory.completed.location&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.http.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.http.address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.instrumentation&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.instrumentation&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.job.history.block.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.jobhistory.block.size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.jobhistory.lru.cache.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.jobhistory.lru.cache.size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.maxtasks.per.job&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.maxtasks.perjob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.persist.jobstatus.active&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.persist.jobstatus.active&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.persist.jobstatus.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.persist.jobstatus.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.persist.jobstatus.hours&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.persist.jobstatus.hours&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.restart.recover&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.restart.recover&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.retiredjobs.cache.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.retiredjobs.cache.size&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.job.tracker.retire.jobs&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.retirejobs&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.taskalloc.capacitypad&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.taskscheduler.taskalloc.capacitypad&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.taskScheduler&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.taskscheduler&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.jobtracker.taskScheduler.maxRunningTasksPerJob&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.taskscheduler.maxrunningtasks.perjob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.join.expr&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.join.expr&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.join.keycomparator&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.join.keycomparator&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.lazy.output.format&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.lazyoutputformat.outputformat&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.line.input.format.linespermap&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.lineinputformat.linespermap&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.linerecordreader.maxlength&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.linerecordreader.line.maxlength&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.local.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.local.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.local.dir.minspacekill&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.local.dir.minspacekill&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.local.dir.minspacestart&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.local.dir.minspacestart&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.child.env&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.env&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.child.java.opts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.java.opts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.child.log.level&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.log.level&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.max.attempts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.maxattempts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.output.compression.codec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.output.compress.codec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.mapoutput.key.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.output.key.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.mapoutput.value.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.output.value.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.mapper.regex.group&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.mapper.regexmapper..group&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.mapper.regex&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.mapper.regex&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.task.debug.script&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.debug.script&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.tasks&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.maps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.map.tasks.speculative.execution&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.speculative&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.max.map.failures.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.failures.maxpercent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.max.reduce.failures.percent&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.failures.maxpercent&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.max.split.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.fileinputformat.split.maxsize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.max.tracker.blacklists&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.tasktracker.maxblacklists&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.max.tracker.failures&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.maxtaskfailures.per.tracker&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.merge.recordsBeforeProgress&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.merge.progress.records&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.min.split.size&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.fileinputformat.split.minsize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.min.split.size.per.node&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.fileinputformat.split.minsize.per.node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.min.split.size.per.rack&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.fileinputformat.split.minsize.per.rack&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.compression.codec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.fileoutputformat.compress.codec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.compression.type&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.fileoutputformat.compress.type&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.compress&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.fileoutputformat.compress&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.fileoutputformat.outputdir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.key.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.output.key.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.key.comparator.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.output.key.comparator.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.value.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.output.value.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.output.value.groupfn.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.output.group.comparator.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.permissions.supergroup&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.permissions.supergroup&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.pipes.user.inputformat&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.pipes.inputformat&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.child.env&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.env&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.child.java.opts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.java.opts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.child.log.level&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.log.level&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.max.attempts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.maxattempts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.parallel.copies&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.shuffle.parallelcopies&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.slowstart.completed.maps&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.reduce.slowstart.completedmaps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.task.debug.script&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.debug.script&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.tasks&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.reduces&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.reduce.tasks.speculative.execution&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.speculative&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.seqbinary.output.key.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.seqbinaryoutputformat.key.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.seqbinary.output.value.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.seqbinaryoutputformat.value.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.shuffle.connect.timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.shuffle.connect.timeout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.shuffle.read.timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.shuffle.read.timeout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.attempts.to.start.skipping&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.skip.start.attempts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.map.auto.incr.proc.count&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.skip.proc-count.auto-incr&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.map.max.skip.records&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.skip.maxrecords&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.on&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.skiprecords&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.out.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.skip.outdir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.reduce.auto.incr.proc.count&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.skip.proc-count.auto-incr&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.skip.reduce.max.skip.groups&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.skip.maxgroups&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.speculative.execution.slowNodeThreshold&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.speculative.slownodethreshold&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.speculative.execution.slowTaskThreshold&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.speculative.slowtaskthreshold&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.speculative.execution.speculativeCap&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.speculative.speculativecap&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.submit.replication&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.client.submit.file.replication&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.system.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.system.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.cache.levels&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.taskcache.levels&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.id&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.attempt.id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.is.map&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.ismap&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.partition&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.partition&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.profile&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.profile&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.profile.maps&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.profile.maps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.profile.params&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.profile.params&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.profile.reduces&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.profile.reduces&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.timeout&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.timeout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.dns.interface&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.dns.interface&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.dns.nameserver&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.dns.nameserver&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.events.batchsize&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.events.batchsize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.expiry.interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.expire.trackers.interval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.tracker.http.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.http.address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.indexcache.mb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.indexcache.mb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.instrumentation&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.instrumentation&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.map.tasks.maximum&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.map.tasks.maximum&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.memory_calculator_plugin&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.resourcecalculatorplugin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.memorycalculatorplugin&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.resourcecalculatorplugin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.reduce.tasks.maximum&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.reduce.tasks.maximum&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.tracker.report.address&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.report.address&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.task.tracker.task-controller&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.taskcontroller&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.taskmemorymanager.monitoring-interval&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.taskmemorymanager.monitoringinterval&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tasktracker.tasks.sleeptime-before-sigkill&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.tasks.sleeptimebeforesigkill&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.temp.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.temp.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.text.key.comparator.options&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.partition.keycomparator.options&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.text.key.partitioner.options&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.partition.keypartitioner.options&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.textoutputformat.separator&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.output.textoutputformat.separator&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.tip.id&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.combine.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.combine.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.inputformat.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.inputformat.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.job.counters.limit&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.counters.max&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.permissions.supergroup&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.cluster.permissions.supergroup&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.map.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.map.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.outputformat.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.outputformat.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.partitioner.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.partitioner.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapreduce.reduce.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.reduce.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.used.genericoptionsparser&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.client.genericoptionsparser.used&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.userlog.limit.kb&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.userlog.limit.kb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.userlog.retain.hours&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.userlog.retain.hours&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.working.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.working.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;mapred.work.output.dir&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.task.output.dir&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;min.num.spills.for.combine&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.map.combine.minspills&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;reduce.output.key.value.fields.spec&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.fieldsel.reduce.output.key.value.fields.spec&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;security.job.submission.protocol.acl&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;security.job.client.protocol.acl&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;security.task.umbilical.protocol.acl&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;security.job.task.protocol.acl&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;sequencefile.filter.class&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.sequencefileinputfilter.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;sequencefile.filter.frequency&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.sequencefileinputfilter.frequency&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;sequencefile.filter.regex&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.input.sequencefileinputfilter.regex&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;session.id&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.metrics.session-id&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td align=&quot;left&quot;&gt;slave.host.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dfs.datanode.hostname&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;slave.host.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.host.name&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;tasktracker.contention.tracking&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.contention.tracking&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;tasktracker.http.threads&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.tasktracker.http.threads&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;topology.node.switch.mapping.impl&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;net.topology.node.switch.mapping.impl&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;topology.script.file.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;net.topology.script.file.name&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;topology.script.number.args&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;net.topology.script.number.args&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td align=&quot;left&quot;&gt;user.name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.job.user.name&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;webinterface.private.actions&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mapreduce.jobtracker.webinterface.trusted&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;yarn.app.mapreduce.yarn.app.mapreduce.client-am.ipc.max-retries-on-timeouts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;yarn.app.mapreduce.client-am.ipc.max-retries-on-timeouts&lt;/td&gt;
&lt;/tr&gt;</description>
<pubDate>Wed, 18 Oct 2017 15:15:00 +0000</pubDate>
<dc:creator>张冲andy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy6/p/7689773.html</dc:identifier>
</item>
<item>
<title>使用Xshell5连接虚拟机VMware中安装的CentOS7系统 - 水木梵华</title>
<link>http://www.cnblogs.com/iskylite/p/7689751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iskylite/p/7689751.html</guid>
<description>&lt;h2 id=&quot;准备材料&quot;&gt;准备材料&lt;/h2&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;Xshell、 VMware Workstation 12 Pro的安装我就不多做详述了，网上一大堆，大家自己问度娘吧。&lt;br/&gt;这里附上虚拟机的密钥：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;5A02H-AU243-TZJ49-GTC7K-3C61N&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用xshell5连接vmware中安装的centos7系统-1&quot;&gt;使用Xshell5连接VMware中安装的CentOS7系统&lt;/h2&gt;
&lt;h3 id=&quot;新建虚拟机&quot;&gt;1、新建虚拟机&lt;/h3&gt;
&lt;p&gt;按照顺序安装就行，加载CentOS7系统镜像不能忘了，否则安装时会出现网络安装界面，导致无法安装。然后就是内存和存储空间的选择，按推荐配置就可以。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230824287-1395731985.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;虚拟机网络配置&quot;&gt;2、虚拟机网络配置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我的计算机 &amp;gt;&amp;gt; CentOS 64位 &amp;gt;&amp;gt; 编辑虚拟机设置 &amp;gt;&amp;gt; 网络适配器 &amp;gt;&amp;gt; 自定义：特定虚拟网络 &amp;gt;&amp;gt; VMnet8(NAT模式) &amp;gt;&amp;gt; 确定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（至于选择VMnet8(NAT模式)的原因，大家自己百度。）&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230906584-144222587.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230920396-1295947899.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装centos7系统&quot;&gt;3、安装CentOS7系统&lt;/h3&gt;
&lt;p&gt;具体过程不再赘述&lt;/p&gt;
&lt;h3 id=&quot;centos7系统网络ip设置&quot;&gt;4、CentOS7系统网络ip设置&lt;/h3&gt;
&lt;p&gt;CentOS安装完毕后，执行以下命令：&lt;/p&gt;
&lt;blockquote readability=&quot;2.5&quot;&gt;
&lt;p&gt;[&lt;a href=&quot;mailto:root@localhost&quot;&gt;root@localhost&lt;/a&gt; ~]# ifconfig&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如执行结果是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-bash: ifconfig: command not found&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明没有安装ifconfig&lt;/p&gt;
&lt;p&gt;本人使用的是最小化安装，也没有这个命令。可以使用以下命令&lt;/p&gt;
&lt;blockquote readability=&quot;2.6666666666667&quot;&gt;
&lt;p&gt;[&lt;a href=&quot;mailto:root@localhost&quot;&gt;root@localhost&lt;/a&gt; ~]# ip address&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
    2: eno16777736: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:e9:ac:17 brd ff:ff:ff:ff:ff:ff
    inet 192.168.206.100/24 brd 192.168.206.255 scope global eno16777736
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fee9:ac17/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;a href=&quot;http://www.cnblogs.com/iskylite/p/7689751.html&quot;&gt;eno16777736&lt;/a&gt;是设备名，&lt;a href=&quot;http://www.cnblogs.com/iskylite/p/7689751.html&quot;&gt;inet&lt;/a&gt;后面跟的就是ip地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inet 192.168.206.100&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果输出结果没有具体的ip地址，可以直接修改ip的配置文件：&lt;/p&gt;
&lt;blockquote readability=&quot;7.4357682619647&quot;&gt;
&lt;p&gt;[&lt;a href=&quot;mailto:root@localhost&quot;&gt;root@localhost&lt;/a&gt; ~]# cd /etc/sysconfig/network-scripts/&lt;br/&gt;[&lt;a href=&quot;mailto:root@localhost&quot;&gt;root@localhost&lt;/a&gt; network-scripts]# vi ifcfg--eno16777736&lt;br/&gt;TYPE=Ethernet&lt;br/&gt;BOOTPROTO=dhcp&lt;br/&gt;DEFROUTE=yes&lt;br/&gt;PEERDNS=yes&lt;br/&gt;PEERROUTES=yes&lt;br/&gt;IPV4_FAILURE_FATAL=no&lt;br/&gt;IPV6INIT=yes&lt;br/&gt;IPV6_AUTOCONF=yes&lt;br/&gt;IPV6_DEFROUTE=yes&lt;br/&gt;IPV6_PEERDNS=yes&lt;br/&gt;IPV6_PEERROUTES=yes&lt;br/&gt;IPV6_FAILURE_FATAL=no&lt;br/&gt;NAME=eno16777736&lt;br/&gt;UUID=21c7a9c7-c582-42bf-9fe3-05ae2a0a99ca&lt;br/&gt;DEVICE=eno16777736&lt;br/&gt;ONBOOT=no&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将上述配置修改为：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TYPE=Ethernet&lt;br/&gt;BOOTPROTO=static (静态)&lt;br/&gt;DEFROUTE=yes&lt;br/&gt;PEERDNS=yes&lt;br/&gt;PEERROUTES=yes&lt;br/&gt;IPV4_FAILURE_FATAL=no&lt;br/&gt;IPV6INIT=yes&lt;br/&gt;IPV6_AUTOCONF=yes&lt;br/&gt;IPV6_DEFROUTE=yes&lt;br/&gt;IPV6_PEERDNS=yes&lt;br/&gt;IPV6_PEERROUTES=yes&lt;br/&gt;IPV6_FAILURE_FATAL=no&lt;br/&gt;NAME=eno16777736&lt;br/&gt;UUID=21c7a9c7-c582-42bf-9fe3-05ae2a0a99ca&lt;br/&gt;DEVICE=eno16777736&lt;br/&gt;ONBOOT=yes&lt;br/&gt;IPADDR=192.168.206.100 (ip 地址)&lt;br/&gt;NETMASK=255.255.255.0 (掩码)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并执行下述命令，重启网络服务&lt;/p&gt;
&lt;blockquote readability=&quot;3.955223880597&quot;&gt;
&lt;p&gt;[&lt;a href=&quot;mailto:root@localhost&quot;&gt;root@localhost&lt;/a&gt; network-scripts]# systemctl restart network.service&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在查看ip，发现没有更改，可以重启。&lt;/p&gt;
&lt;h3 id=&quot;xshell连接centos-7&quot;&gt;5、Xshell连接CentOS 7&lt;/h3&gt;
&lt;p&gt;文件 &amp;gt;&amp;gt; 新建 &amp;gt;&amp;gt; 名称 &amp;gt;&amp;gt; 主机（ip）&amp;gt;&amp;gt; 确定 &amp;gt;&amp;gt; 用户名/密码&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230950006-330343529.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230955787-485082513.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1139524/201710/1139524-20171018230959256-146957911.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;连接成功&quot;&gt;6、连接成功&lt;/h3&gt;
&lt;p&gt;没截图，和容易判断&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 15:11:00 +0000</pubDate>
<dc:creator>水木梵华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iskylite/p/7689751.html</dc:identifier>
</item>
<item>
<title>机器学习技法：01 Linear Support Vector Machine - cherrychenlee</title>
<link>http://www.cnblogs.com/cherrychenlee/p/7689655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherrychenlee/p/7689655.html</guid>
<description>[unable to retrieve full-text content]Roadmap Course Introduction Large-Margin Separating Hyperplane Standard Large-Margin Problem Support Vector Machine Reasons behind Large-Margin Hyperp</description>
<pubDate>Wed, 18 Oct 2017 15:01:00 +0000</pubDate>
<dc:creator>cherrychenlee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherrychenlee/p/7689655.html</dc:identifier>
</item>
<item>
<title>Linux 进程与信号的概念和操作 linux process and signals - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/7689667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/7689667.html</guid>
<description>&lt;h2 id=&quot;进程&quot;&gt;进程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要参考: &lt;a href=&quot;http://www.bogotobogo.com/Linux/linux_process_and_signals.php&quot; class=&quot;uri&quot;&gt;http://www.bogotobogo.com/Linux/linux_process_and_signals.php&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;信号与进程几乎控制了操作系统的每个任务。&lt;/p&gt;
&lt;p&gt;在shell中输入&lt;strong&gt;ps -ef&lt;/strong&gt;命令，我们将得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（译者注：-e Select all processes. Identical to -A； -f Do full-format listing. This option can be combined with many other UNIX-style options to add additional columns. It also causes the command arguments to be printed.）&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0  2010 ?        00:01:48 init 
root     21033     1  0 Apr04 ?        00:00:39 crond
root     24765     1  0 Apr08 ?        00:00:01 /usr/sbin/httpd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171018231150459-1901662608.png&quot; alt=&quot;ProcessState.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个进程都会被赋予一个特殊的整数，称为&lt;strong&gt;进程标识符&lt;/strong&gt; (process identifier &lt;strong&gt;PID&lt;/strong&gt;) ，&lt;strong&gt;PID&lt;/strong&gt;的范围是2~32768。当一个进程启动的时候，数字最少会从2开始算，因为1是为&lt;strong&gt;init&lt;/strong&gt;进程保留的——正如上面这个例子可以看到的，&lt;strong&gt;init&lt;/strong&gt;进程会管理其他的进程。&lt;/p&gt;
&lt;p&gt;当我们运行一个程序时，保存在硬盘上的可执行指令集就会被加载到内存中的一个区块中，通常来说，一个linux进程是不能向这个区块进行写操作的。（所以说，这个区块可以被安全地共享）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171018231206709-738285740.png&quot; alt=&quot;process&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样，系统的库也可以被共享。因此，即使很多程序都用到了&lt;code&gt;printf&lt;/code&gt;这个函数，在内存中只要有一份拷贝就够了。&lt;/p&gt;
&lt;p&gt;与能够共享的库不同，一个程序或许会有自己的内部变量，这些变量是保存在程序自己独有的栈空间中的，无法和另外的进程共享。每个进程也有自己管理的独有的环境变量。另外，每个进程也应该有自己独有的程序计数器（PC）——用来记录程序执行到哪里了。（执行线程请参考 &lt;a href=&quot;http://www.bogotobogo.com/cplusplus/multithreaded3.php&quot;&gt;linux pthread&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;进程表&quot;&gt;进程表&lt;/h4&gt;
&lt;p&gt;进程表中保存了当前内存中加载的所有进程，我们可以使用&lt;code&gt;ps&lt;/code&gt;命令将其显示出来。但是，默认情况下&lt;code&gt;ps&lt;/code&gt;只会显示和终端或者伪终端或者串行链接（serial line）保持连接的进程。其他不需要和用户终端交互的进程是由操作系统负责管理共享资源的。为了显示所有的程序，我可以使用&lt;code&gt;-e&lt;/code&gt;和&lt;code&gt;-f&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;（译者注：To see every process on the system using standard syntax: ps -ef）&lt;/p&gt;
&lt;h4 id=&quot;系统进程&quot;&gt;系统进程&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ps -ax
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     1:48 init [3]
    2 ?        S&amp;lt;     0:03 [migration/0]
    3 ?        SN     0:00 [ksoftirqd/0]
 ....
 2981 ?        S&amp;lt;sl  10:14 auditd
 2983 ?        S&amp;lt;sl   3:43 /sbin/audispd
 ....
 3428 ?        SLs    0:00 ntpd -u ntp:ntp -p /var/run/ntpd.pid -g
 3464 ?        Ss     0:00 rpc.rquotad
 3508 ?        S&amp;lt;     0:00 [nfsd4]
 ....
 3812 tty1     Ss+    0:00 /sbin/mingetty tty1
 3813 tty2     Ss+    0:00 /sbin/mingetty tty2
 3814 tty3     Ss+    0:00 /sbin/mingetty tty3
 3815 tty4     Ss+    0:00 /sbin/mingetty tty4
.....
19874 pts/1    R+     0:00 ps -ax
19875 pts/1    S+     0:00 more
21033 ?        Ss     0:39 crond
24765 ?        Ss     0:01 /usr/sbin/httpd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;STAT对应的字符含义如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;正在运行或者有能力运行。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;不间断的睡眠 (等待中) - 通常是为了等待完成输入输出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;睡眠中. 通常是在等待一个事件, 例如一个信号或者输入变成可获得的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;已停止. 通常是被shell的job控制了或者正在被一个调试器进行调试。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;死亡/失效的僵尸进程.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;低优先级, nice（译者注：nice后面会提到）.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;分页.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;这个进程是会话中的首进程.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;这个进程在前台工作组中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;这个进程是多线程的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;高优先级的任务。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;观察下面这个进程：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;1 ?        Ss     1:48 init [3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个子进程都是由父进程fork出来的。当linux开始运行时，它只运行了一个进程：&lt;strong&gt;init&lt;/strong&gt;, PID为1。&lt;strong&gt;init&lt;/strong&gt;是系统的进程管理者，并且它是其他所有进程的直接/间接父进程。当&lt;strong&gt;init&lt;/strong&gt; fork出进程后，这些进程又开始fork进程（类似于病毒传播）。登录就是一个例子：&lt;strong&gt;init&lt;/strong&gt;会为每个终端通过fork出&lt;strong&gt;getty&lt;/strong&gt;这个进程，通过它我们可以进行登录操作。如下所示：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; 3812 tty1     Ss+    0:00 /sbin/mingetty tty1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;getty&lt;/strong&gt;进程会等待被终端激活，为用户输出登录时候的提示符，然后把控制交给登录相关的程序，这些程序会建立起用户的环境然后启动一个shell。当用户从这个shell退出的时候，&lt;strong&gt;init&lt;/strong&gt;会启动另一个&lt;strong&gt;getty&lt;/strong&gt;进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动新的进程并等待他们结束&lt;/strong&gt;是一个操作系统的基本任务。我们也可以通过使用系统调用&lt;strong&gt;fork(), exec(), wait(),&lt;/strong&gt; 完成这些工作。&lt;/p&gt;
&lt;p&gt;一个系统调用相当于一个可控的和内核交流的入口，通过这些调用，进程可以要求内核提供一些服务和工作。&lt;/p&gt;
&lt;p&gt;事实上，一个系统调用会将处理器的用户状态转化为内核状态，因此cpu可以访问内存中被保护的内核模块。内核通过系统调用API为进程提供了非常丰富的服务。&lt;/p&gt;
&lt;h4 id=&quot;进程调度&quot;&gt;进程调度&lt;/h4&gt;
&lt;p&gt;让我看看&lt;strong&gt;ps ax&lt;/strong&gt;本身的STAT:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;23603 pts/1    R+     0:00 ps ax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt;代表进程23603处于runnable状态。换句话说，它监测了自己的状态。指示器只是表明了这个程序处于可运行状态，并不一定正在运行（参见下面的资料，可能在runqueue中）。&lt;strong&gt;R+&lt;/strong&gt;表示出这个进程是在前台工作组中，所以它不会等待其他的进程完成也不会等待输入输出完毕。这也是为什么我们可能在&lt;strong&gt;ps&lt;/strong&gt;的输出中看到两个以上&lt;strong&gt;R+&lt;/strong&gt;的进程。&lt;/p&gt;
&lt;p&gt;（译者：这个地方感谢胡尧学长指点，之前有几句话没有理解正确）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;译者：参考一下&lt;a href=&quot;http://www.linfo.org/process_state.html&quot;&gt;Process State Definition&lt;/a&gt;和&lt;a href=&quot;http://www.linfo.org/runnable_process.html&quot;&gt;Runnable Process Definition&lt;/a&gt; :（有时间我会把这两篇翻译一下）&lt;/p&gt;
&lt;p&gt;1.节选Process State Definition中前一部分：&lt;/p&gt;
&lt;blockquote readability=&quot;35.950507614213&quot;&gt;
&lt;p&gt;&lt;em&gt;Process state&lt;/em&gt; is the &lt;em&gt;state&lt;/em&gt; field in the &lt;em&gt;process descriptor&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A process descriptor is a &lt;em&gt;task_struct&lt;/em&gt;-type &lt;em&gt;data structure&lt;/em&gt; whose fields contain all of the information about a single &lt;a href=&quot;http://www.linfo.org/process.html&quot;&gt;&lt;em&gt;process&lt;/em&gt;&lt;/a&gt;. A process, also referred to as a &lt;em&gt;task&lt;/em&gt;, is an instance of a &lt;a href=&quot;http://www.linfo.org/program.html&quot;&gt;program&lt;/a&gt; in execution.&lt;/p&gt;
&lt;p&gt;A data structure is a way of storing data in a computer so that it can be used efficiently. task_struct is a relatively large data structure (roughly 1.7 kilo&lt;a href=&quot;http://www.linfo.org/byte.html&quot;&gt;bytes&lt;/a&gt; on a 32-bit machine) that is designed to hold all the information that the &lt;a href=&quot;http://www.linfo.org/kernel.html&quot;&gt;&lt;em&gt;kernel&lt;/em&gt;&lt;/a&gt; (i.e., the core of the &lt;a href=&quot;http://www.linfo.org/operating_systems_list.html&quot;&gt;operating system&lt;/a&gt;) has and needs about a process.&lt;/p&gt;
&lt;p&gt;The state field in the process descriptor describes what is currently happening to a process. This field contains one of the following five &lt;em&gt;flags&lt;/em&gt; (i.e., values):&lt;/p&gt;
&lt;p&gt;TASK_RUNNING: The process is runnable, and it is either currently running or it is on a &lt;em&gt;runqueue&lt;/em&gt; waiting to run. This is the only possible state for a process executing in &lt;a href=&quot;http://www.linfo.org/user_space.html&quot;&gt;&lt;em&gt;user space&lt;/em&gt;&lt;/a&gt; (i.e., that portion of system &lt;a href=&quot;http://www.linfo.org/memory.html&quot;&gt;memory&lt;/a&gt; in which user processes run); it can also apply to a process in &lt;a href=&quot;http://www.linfo.org/kernel_space.html&quot;&gt;&lt;em&gt;kernel space&lt;/em&gt;&lt;/a&gt; (i.e., that portion of memory in which the kernel executes and provides its services) that is actively running. A &lt;a href=&quot;http://www.linfo.org/runnable_process.html&quot;&gt;&lt;em&gt;runnable process&lt;/em&gt;&lt;/a&gt; is a process that is in the TASK_RUNNING process state.&lt;/p&gt;
&lt;p&gt;A runqueue is the basic data structure in the &lt;em&gt;scheduler&lt;/em&gt;, and it contains the list of runnable processes for the CPU (central processing unit), or for one CPU on a multiprocessor system. The scheduler, also called the &lt;em&gt;process scheduler&lt;/em&gt;, is a part of the kernel that allocates the scare CPU time among the various runnable processes on the system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.Runnable Process Definition&lt;/p&gt;
&lt;blockquote readability=&quot;33.859470468432&quot;&gt;
&lt;p&gt;A &lt;em&gt;runnable process&lt;/em&gt; is a &lt;a href=&quot;http://www.linfo.org/process.html&quot;&gt;&lt;em&gt;process&lt;/em&gt;&lt;/a&gt; which is in the TASK_RUNNING &lt;em&gt;process state&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A process, also referred to as a &lt;em&gt;task&lt;/em&gt;, is an instance of a &lt;a href=&quot;http://www.linfo.org/program.html&quot;&gt;program&lt;/a&gt; in execution. A process state is a field in the &lt;em&gt;process descriptor&lt;/em&gt;. This field can accept any of five possible &lt;em&gt;flags&lt;/em&gt; (i.e., values), one of which is TASK_RUNNING.&lt;/p&gt;
&lt;p&gt;A process descriptor is a &lt;em&gt;task_struct&lt;/em&gt;-type &lt;em&gt;data structure&lt;/em&gt; whose fields contain all of the information regarding a single process. Its process state field describes what is currently happening to the process. A data structure is a way of storing data in a computer so that it can be used efficiently. A task_struct data structure is a data structure that is used to describe a process on the system.&lt;/p&gt;
&lt;p&gt;The TASK_RUNNING state means that the process is runnable, and it is either currently running or on a &lt;em&gt;runqueue&lt;/em&gt; waiting to run. This is the only possible state for a process executing in &lt;a href=&quot;http://www.linfo.org/user_space.html&quot;&gt;&lt;em&gt;user space&lt;/em&gt;&lt;/a&gt; (i.e., that portion of system &lt;a href=&quot;http://www.linfo.org/memory.html&quot;&gt;memory&lt;/a&gt; in which user processes run); it can also apply to a process in &lt;a href=&quot;http://www.linfo.org/kernel_space.html&quot;&gt;&lt;em&gt;kernel space&lt;/em&gt;&lt;/a&gt; (i.e., that portion of memory in which the &lt;a href=&quot;http://www.linfo.org/kernel.html&quot;&gt;kernel&lt;/a&gt; executes and provides its services) that is actively running.&lt;/p&gt;
&lt;p&gt;A runqueue is the basic data structure in the &lt;em&gt;scheduler&lt;/em&gt;, and it contains the list of runnable processes for the CPU (central processing unit), or for one CPU on a multiprocessor system. The scheduler, also called the &lt;em&gt;process scheduler&lt;/em&gt;, is a part of the kernel that allocates the scare CPU time among the various runnable processes on the system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;Linux内核使用一个叫做&lt;strong&gt;进程调度器&lt;/strong&gt;的程序通过&lt;strong&gt;进程的优先级&lt;/strong&gt;判断哪个进程会获得下一个&lt;strong&gt;cpu时间片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通常情况下，几个程序会同时竞争计算资源。如果一个程序只占用少量的计算资源并且会停下来等待输入，我们就说它是“安分守己的”——与此相反，有的进程会不断的霸占系统的计算资源。术语上我们把“安分守己”的程序称作&lt;strong&gt;美好（nice）程序&lt;/strong&gt;。同时，这种美好程度（niceness）也是&lt;strong&gt;可计量&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;操作系统通过进程的nice值来判断该进程的优先级。长时间不暂停的程序通常会有更低的优先级（译者：没懂，如果这样的程序是非常不nice的——需要很多计算资源的进程，还是给它很小的优先级吗？），相反地，暂停的程序会得到“奖赏”——这保证了交互式进程可以很快的相应用户，当它在等待用户输入时，操作系统会提高的它的优先级，这样当它准备恢复运行的时候就已经是高优先级了。&lt;/p&gt;
&lt;p&gt;nice值（niceness）是一个从-20到20的整数，-20代表最高的优先级，19或者20代表最低的优先级。一个子进程的默认优先级是从它的父进程继承来的，通常是0。我们可以通过&lt;code&gt;nice&lt;/code&gt;命令设置nice值，也可以使用&lt;code&gt;renice&lt;/code&gt;命令更改nice值。&lt;code&gt;nice&lt;/code&gt;命令每次会把进程的nice值提高10，使得它的优先级降低。只有root权限的用户可以降低进程的nice值（提高优先级）。在Linux上你可以改变 &lt;strong&gt;/etc/security/limits.conf&lt;/strong&gt;来允许别的用户或者组降低nice值。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;ps&lt;/code&gt;和参数&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;-f&lt;/code&gt;查看进程的nice值：&lt;/p&gt;
&lt;p&gt;（译者注：-l Long format. The -y option is often useful with this. -y Do not show flags; show rss in place of addr. This option can only be used with -l.）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S   601 12649 12648  0  75   0 -  1135 wait   pts/0    00:00:00 bash
0 S   601 12681 12649  0  76   0 -  1122 wait   pts/0    00:00:00 myTest.sh
0 S   601 12682 12681  0  76   0 -   929 -      pts/0    00:00:00 sleep
0 R   601 12683 12649  0  76   0 -  1054 -      pts/0    00:00:00 ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;:这里我们可以看到 &lt;strong&gt;myTest.sh&lt;/strong&gt;程序是运行在默认nice值0下（译者注：NI列）。但如果它是这么启动的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ nice ./myTest.sh &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么它的nice值就会+10。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S   601  9835  9834  0  75   0 -  1135 wait   pts/1    00:00:00 bash
0 S   601 12744 12649  0  86  10 -  1122 wait   pts/0    00:00:00 myTest.sh
0 S   601 12745 12744  0  86  10 -   929 -      pts/0    00:00:00 sleep
0 R   601 12746 12649  0  76   0 -  1054 -      pts/0    00:00:00 ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以这样做：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ renice 10 12681
12681: old priority 0, new priority 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了更高的nice值，这个程序会更少的运行。如下图所示，STAT列的值多了一个&lt;strong&gt;N&lt;/strong&gt;标记，说明这个进程的nice值和默认不同了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ps x
12649 pts/0    Ss     0:00 -bash
12744 pts/0    SN     0:00 /bin/bash ./myTest.sh
12745 pts/0    SN     0:00 sleep 100
12867 pts/0    R+     0:00 ps x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;strong&gt;PPID&lt;/strong&gt; field of &lt;strong&gt;ps&lt;/strong&gt; output indicates the parent process ID, the &lt;strong&gt;PID&lt;/strong&gt; of either the process that caused this process to start or, if that process is no longer running, &lt;strong&gt;init (PID 1)&lt;/strong&gt;.&lt;code&gt;ps&lt;/code&gt;输出中&lt;strong&gt;PPID&lt;/strong&gt;列表示了该进程父进程的&lt;strong&gt;PID&lt;/strong&gt;，如果那个父进程没有运行了，就会是&lt;strong&gt;init(PID 1)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;init进程-守护进程&quot;&gt;init进程 / 守护进程&lt;/h4&gt;
&lt;p&gt;（译者注：守护来自于daemon这个词，它有两个含义：1.(esp in Greek mythology) supernatural being that is half god, half man （尤指希腊神话中的）半人半神的精灵. 2. spirit that inspires sb to action or creativity 守护神.）&lt;/p&gt;
&lt;p&gt;当我们启动系统的时候，内核会创建一个叫做&lt;strong&gt;init&lt;/strong&gt;的进程（来自于&lt;strong&gt;/sbin/init&lt;/strong&gt;），它是&lt;strong&gt;所有其他进程的“祖宗”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统上所有的其他进程都是通过调用&lt;code&gt;fork()&lt;/code&gt;从&lt;strong&gt;init&lt;/strong&gt;或者它的后代生成的。&lt;strong&gt;init&lt;/strong&gt;进程总是拥有为1的&lt;strong&gt;PID&lt;/strong&gt;和超级用户的权限。它也不能被终止掉，除非机器关机。&lt;strong&gt;inti&lt;/strong&gt;的主要功能就是相应操作系统生成其他进程并监视管理所有进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;守护&lt;/strong&gt;进程是一个有着特殊目的的进程（例如syslogd, httpd等等），它也是由操作系统负责生成并管理的，但它和普通的进程有以下两个不同：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;长寿命。一个守护程序通常会在系统启动的时候就开始运行，直到机器关机。&lt;/li&gt;
&lt;li&gt;它是在后台运行的，也就是说没有一个和它连接的终端可以用来输入输出。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建一个新进程&quot;&gt;创建一个新进程&lt;/h4&gt;
&lt;p&gt;我们可以在一个程序中启动另一个程序，&lt;code&gt;system&lt;/code&gt;库函数就是用来创建新进程的。下面这个例子就通过调用&lt;code&gt;system&lt;/code&gt;运行了&lt;strong&gt;ps&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// mySysCall.c&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  system(&lt;span class=&quot;st&quot;&gt;&quot;ps ax&quot;&lt;/span&gt;);
  std::cout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;&quot;Done.&quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果运行这个程序，输出如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$./mySysCall
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     1:48 init [3]
....
24447 pts/0    S+     0:00 ./mySysCall
24448 pts/0    R+     0:00 ps ax
Done.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;system&lt;/code&gt;是通过一个&lt;strong&gt;shell&lt;/strong&gt;启动新的进程的，我们也可以做一个改变：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;  system(&quot;ps ax &amp;amp;&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个新的版本，输出如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Done.
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     1:48 init [3]
....
24849 pts/1    Ss+    0:00 -bash
25802 pts/1    R      0:00 ps ax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，&lt;code&gt;system&lt;/code&gt;在shell命令完成后就立即返回了。因为它要求shell将这个新程序放在后台运行，shell会在&lt;strong&gt;ps&lt;/strong&gt;程序启动后立即返回。这和我们在shell中输入相同的命令是一样的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ps ax &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shell返回后，我们的程序就打印出“Done.“并在&lt;strong&gt;ps&lt;/strong&gt;命令有机会完成输出前退出。这看起来有些难以理解，所以我们也需要完全控制进程的行为。&lt;/p&gt;
&lt;h4 id=&quot;exec-系统调用&quot;&gt;exec() 系统调用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;函数会将当前的进程替换为一个新的进程，这个新的进程可以由&lt;strong&gt;路径&lt;/strong&gt;或者&lt;strong&gt;文件参数&lt;/strong&gt;指定。我们可以使用&lt;code&gt;exec&lt;/code&gt;将我们正在执行的程序切换到另一个。&lt;/p&gt;
&lt;p&gt;如下图所示，我们在bash中发起&lt;strong&gt;ls&lt;/strong&gt;命令。在这种情况下，shell作为父进程，通过调用&lt;code&gt;fork()&lt;/code&gt;创建出一个子进程，这个子进程随之调用&lt;code&gt;exec()&lt;/code&gt;将之变为&lt;strong&gt;ls&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171018231244662-1556193060.png&quot; alt=&quot;exec_ls.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;会比&lt;code&gt;system&lt;/code&gt;更加有效率，因为调用&lt;code&gt;exec&lt;/code&gt;后父进程就不会再运行了。&lt;/p&gt;
&lt;p&gt;（译者注： The exec() family of functions replaces the current process image with a new process image. ）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* Execute PATH with arguments ARGV and environment from `environ'.  */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; execv (__const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__path, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__const __argv[])
     __THROW __nonnull ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));

&lt;span class=&quot;co&quot;&gt;/* Execute PATH with all arguments after PATH until a NULL pointer,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   and the argument after that for environment.  */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; execle (__const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__path, __const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__arg, ...)
     __THROW __nonnull ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));

&lt;span class=&quot;co&quot;&gt;/* Execute PATH with all arguments after PATH until&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   a NULL pointer and environment from `environ'.  */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; execl (__const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__path, __const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__arg, ...)
     __THROW __nonnull ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));

&lt;span class=&quot;co&quot;&gt;/* Execute FILE, searching in the `PATH' environment variable if it contains&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   no slashes, with arguments ARGV and environment from `environ'.  */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; execvp (__const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__file, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__const __argv[])
     __THROW __nonnull ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));

&lt;span class=&quot;co&quot;&gt;/* Execute FILE, searching in the `PATH' environment variable if&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   it contains no slashes, with all arguments after FILE until a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   NULL pointer and environment from `environ'.  */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; execlp (__const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__file, __const &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *__arg, ...)
     __THROW __nonnull ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数大多是通过使用&lt;code&gt;execve&lt;/code&gt;实现的，以&lt;strong&gt;p&lt;/strong&gt;作为后缀的函数会在环境变量&lt;strong&gt;PATH&lt;/strong&gt;对应的地方搜寻那个要运行的程序，如果没有找到可运行的那个程序，你必须给这个函数传入一个文件的绝对路径作为参数。&lt;/p&gt;
&lt;p&gt;全局变量&lt;strong&gt;environ&lt;/strong&gt;可以给新的程序传递环境参数。&lt;code&gt;execle&lt;/code&gt;和&lt;code&gt;execve&lt;/code&gt;有另外的方法：你可以传入一个字符串数组用来建立新程序的环境。&lt;/p&gt;
&lt;p&gt;下面是使用&lt;code&gt;execlp&lt;/code&gt;的一个例子：&lt;/p&gt;
&lt;p&gt;（译者注：&lt;strong&gt;unistd.h&lt;/strong&gt; 是 C 和 &lt;a href=&quot;https://baike.baidu.com/item/C%2B%2B&quot;&gt;C++&lt;/a&gt; 程序设计语言中提供对 &lt;a href=&quot;https://baike.baidu.com/item/POSIX&quot;&gt;POSIX&lt;/a&gt; 操作系统 &lt;a href=&quot;https://baike.baidu.com/item/API&quot;&gt;API&lt;/a&gt; 的访问功能的&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%B4%E6%96%87%E4%BB%B6&quot;&gt;头文件&lt;/a&gt;的名称。该头文件由 POSIX.1 标准（单一UNIX规范的基础）提出，故所有遵循该标准的操作系统和&lt;a href=&quot;https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8&quot;&gt;编译器&lt;/a&gt;均应提供该头文件（如 Unix 的所有官方版本，包括 &lt;a href=&quot;https://baike.baidu.com/item/Mac%20OS%20X&quot;&gt;Mac OS X&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Linux&quot;&gt;Linux&lt;/a&gt; 等）。）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// my_ps.c&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  printf(&lt;span class=&quot;st&quot;&gt;&quot;ps with execlp&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
  execlp(&lt;span class=&quot;st&quot;&gt;&quot;ps&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;ps&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
  printf(&lt;span class=&quot;st&quot;&gt;&quot;Done.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们运行这个程序，输出将会只有&lt;strong&gt;ps&lt;/strong&gt;的标准输出而没有&lt;strong&gt;&quot;Done&quot;&lt;/strong&gt;, 同样的，我们在&lt;strong&gt;ps&lt;/strong&gt;的输出中也找不到my_ps这个进程。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$./my_ps
ps with execlp
  PID TTY          TIME CMD
12377 pts/0    00:00:00 bash
18304 pts/0    00:00:00 ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序打印出了第一个“ps with execlp”，然后调用了&lt;code&gt;execlp()&lt;/code&gt; ——在&lt;strong&gt;PATH&lt;/strong&gt;环境变量对应的地方搜索一个叫做&lt;strong&gt;ps&lt;/strong&gt;的程序。最后它执行&lt;strong&gt;ps&lt;/strong&gt;以代替&lt;strong&gt;my_ps&lt;/strong&gt; ，就像我们在shell中执行以下命令一样：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（译者注：举个例子，实际上，bash里面就有一个exec命令，我们平时在bash中执行的命令都是在生成了子进程，并没有替换当前shell的进程，如果在bash中直接使用&lt;code&gt;exec ps&lt;/code&gt;会马上”退出“bash——输出你也来不到，如果我们在一个bash中输入bash，然后输入&lt;code&gt;exec ps&lt;/code&gt; ，就会得到正确的输出，但是这个时候实际上已经在第一个bash里面了，输入一个exit就能退出shell了。）&lt;/p&gt;
&lt;p&gt;所以，当&lt;strong&gt;ps&lt;/strong&gt;进程完毕时，我们会得到一个shell的提示符而不是返回到&lt;strong&gt;my_ps&lt;/strong&gt; 。因此，第二个&lt;code&gt;printf&lt;/code&gt;没有打印出”Done“这个消息。exec得到的新进程的PID和nice值都是和”父进程“一样的。&lt;/p&gt;
&lt;p&gt;为了让一个进程可以同时进行多个函数，我们可以使用&lt;code&gt;threads&lt;/code&gt;或者完全创建另一个进程，就像&lt;strong&gt;init&lt;/strong&gt;做的，而不是像&lt;code&gt;exec&lt;/code&gt;一样替换现有进程。&lt;/p&gt;
&lt;p&gt;其中的一种方法就是调用&lt;code&gt;fork()&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;fork-与-execv&quot;&gt;fork() 与 execv()&lt;/h4&gt;
&lt;p&gt;在下面的代码中，&lt;code&gt;fork&lt;/code&gt;先在父进程中穿创建子进程，随后这个子进程调用&lt;code&gt;exec&lt;/code&gt;将父进程的代码替换为&lt;strong&gt;path&lt;/strong&gt;中指定的值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *argv[]) （译者：main函数第一个参数还可以指针类型？）
{ 
    pid_t pid = fork(); 
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pid == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) 
    { 
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Child&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;); 
        execv(path, argv); 
    } 
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; 
    { 
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Parent %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, pid); 
    } 
    printf(&lt;span class=&quot;st&quot;&gt;&quot;Parent prints this line &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;); 
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;fork-系统调用&quot;&gt;fork() 系统调用&lt;/h4&gt;
&lt;p&gt;（译者注：可以先看一下中文的一个教程&lt;a href=&quot;http://blog.csdn.net/jason314/article/details/5640969&quot;&gt;linux中fork（）函数详解（原创！！实例讲解）&lt;/a&gt;,觉得讲解的不错，特别是&lt;code&gt;fork&lt;/code&gt;的时候流缓冲区的问题和&lt;code&gt;fork&lt;/code&gt;返回值的问题很有意思。）&lt;/p&gt;
&lt;p&gt;我们可以调用&lt;code&gt;fork()&lt;/code&gt;来创建一个新的进程。这个系统调用会”复制“当前的进程，在进程表中产生一个新的入口，新的进程的很多属性和负进程是相同的。&lt;/p&gt;
&lt;p&gt;理解&lt;code&gt;fork()&lt;/code&gt;的关键点在于当它返回时，会存在两个进程，并且，在两个进程中，程序会从&lt;code&gt;fork()&lt;/code&gt;返回的地方继续开始执行。&lt;/p&gt;
&lt;p&gt;Linux会复制父进程完整的地址空间并把它赋值给子进程。因此，父进程和子进程拥有完全相同&lt;strong&gt;内容&lt;/strong&gt;的地址空间/代码。但是这两个进程是互相独立的，它们有自己的独立的环境，数据空间，文件描述符等等。所以，和&lt;code&gt;exec()&lt;/code&gt;相结合，&lt;code&gt;fork()&lt;/code&gt;就是我门需要用来创建新程序的调用。&lt;/p&gt;
&lt;p&gt;另外，要注意的是，&lt;code&gt;fork()&lt;/code&gt;被调用一次会返回两次！（译者注，这句话本来放在前面，但放在这好像好一些）&lt;/p&gt;
&lt;p&gt;对于父进程，&lt;code&gt;fork()&lt;/code&gt;会返回新创建的子进程的&lt;strong&gt;PID&lt;/strong&gt; ——这是很有用的，因为父进程可能会创建很多进程并监视它们的状态（通过&lt;code&gt;wait()&lt;/code&gt;函数）（译者注：wait, waitpid, waitid - wait for process to change state），对于子进程，&lt;code&gt;fork()&lt;/code&gt;会返回0。如果必要的话，进程可以通过&lt;code&gt;getpid()&lt;/code&gt;获得本进程的&lt;strong&gt;PID&lt;/strong&gt; ，通过&lt;code&gt;getppid()&lt;/code&gt;获得父进程的&lt;strong&gt;PID&lt;/strong&gt; （译者注：如果父进程已经死亡，&lt;strong&gt;PPID&lt;/strong&gt;将会是1）。如果&lt;code&gt;fork()&lt;/code&gt;调用失败会返回-1，这要么是因为子进程数量上的限制（&lt;strong&gt;CHILD_MAX&lt;/strong&gt; ，&lt;strong&gt;errno&lt;/strong&gt;会被设置成&lt;strong&gt;EAGAIN&lt;/strong&gt;) ，要么是因为进程表中没有足够的空间再创建一个入口或者（虚拟）内存不足（&lt;strong&gt;errno&lt;/strong&gt;会被设置成&lt;strong&gt;ENOMEM&lt;/strong&gt; ）。&lt;/p&gt;
&lt;p&gt;那么，在&lt;code&gt;fork()&lt;/code&gt;之后哪一个进程会先运行呢？&lt;/p&gt;
&lt;p&gt;是子进程？还是父进程？&lt;/p&gt;
&lt;p&gt;事实上，这是未定义的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171018231310756-1036177117.png&quot; alt=&quot;fork_diagram.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的参考图来自于 &quot;The Linux Programming Interface&quot;&lt;/p&gt;
&lt;p&gt;下面是个总结:&lt;/p&gt;
&lt;p&gt;系统调用&lt;code&gt;fork()&lt;/code&gt;不需要参数转入并且会返回一个&lt;strong&gt;PID&lt;/strong&gt;. 使用&lt;code&gt;fork()&lt;/code&gt;的目的在于创建一个新的进程，也就是其父进程的子进程。在新的子进程创建后，父与子都会从&lt;code&gt;fork()&lt;/code&gt;调用的下一条指令开始执行。因此，我们必须&lt;strong&gt;区分哪一个是父进程，哪一个是子进程&lt;/strong&gt;，这可以通过&lt;code&gt;fork()&lt;/code&gt;的返回值来判断：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果返回一个&lt;strong&gt;负值&lt;/strong&gt;，那么调用失败。&lt;/li&gt;
&lt;li&gt;如果返回的是&lt;strong&gt;0&lt;/strong&gt;，那么当前处于新创建的子进程。&lt;/li&gt;
&lt;li&gt;如果返回一个&lt;strong&gt;正数&lt;/strong&gt;，那这个数代表新创建的子进程的&lt;strong&gt;PID&lt;/strong&gt;（这个正数是&lt;strong&gt;pid_t&lt;/strong&gt;类型的，声明在&lt;strong&gt;sys/types.h&lt;/strong&gt;）。正常情况下，这个正数是一个整数。另外，一个进程可以使用&lt;code&gt;getpid()&lt;/code&gt;来获取本进程的PID。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt; &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//译者注：还应该包括unistd.h&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 150&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid = fork();
  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[BUF_SIZE];
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; print_count;

  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (pid)
  {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
      perror(&lt;span class=&quot;st&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;);
      exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
      &lt;span class=&quot;co&quot;&gt;/* When fork() returns 0, we are in the child process. */&lt;/span&gt;
      print_count = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;child process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;co&quot;&gt;/* + */&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;/* When fork() returns a positive number, we are in the parent process&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;       * (the fork return value is the PID of the newly created child process) */&lt;/span&gt;
      print_count = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;parent process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
  }
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;print_count &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; print_count--) {
      puts(buf);
      sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
  }
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Output is:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;child process: pid = 0
parent process: pid = 13510
child process: pid = 0
parent process: pid = 13510
child process: pid = 0
parent process: pid = 13510
child process: pid = 0
parent process: pid = 13510
child process: pid = 0
parent process: pid = 13510
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如输出中所看到的，&lt;code&gt;fork()&lt;/code&gt;在父进程中返回了子进程的&lt;strong&gt;PID&lt;/strong&gt;，在子进程中返回了0. 我们使用&lt;code&gt;fork()&lt;/code&gt;创建的子进程独立于父进程运行。但是有些时候，我们想要知道子进程是否运行完了，如果父进程提前于子进程运行完毕，就像上面这个例子，这会很让人困惑。所以，我们需要通过&lt;code&gt;wait()&lt;/code&gt;函数来等待子进程执行完毕。&lt;/p&gt;
&lt;p&gt;译者注：在我的机器（Ubuntu 16.04 gcc 5.4 bash 4.3.48）上运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;frank@under:~/tmp$ ./a.out 
parent process: pid = 24238
child process: pid = 0
parent process: pid = 24238
child process: pid = 0
parent process: pid = 24238
child process: pid = 0
parent process: pid = 24238
child process: pid = 0
parent process: pid = 24238
child process: pid = 0
child process: pid = 0
frank@under:~/tmp$ child process: pid = 0 #这里
child process: pid = 0
child process: pid = 0
child process: pid = 0
ls
a.out  hellolinux  hellolinux.c  test.c  test.s
frank@under:~/tmp$ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这其中标识的那一行很有意思，bash的提示符先于子程序结束前出现了，我猜想是因为bash只是等待父进程执行完毕然后开始接受新的输入，对于这个父进程产生的子进程它并不关心。于是乎我做了一个小实验：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 150&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid = fork();
  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[BUF_SIZE];
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; print_count;

  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (pid)
  {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
      perror(&lt;span class=&quot;st&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;);
      exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
      &lt;span class=&quot;co&quot;&gt;/* When fork() returns 0, we are in the child process. */&lt;/span&gt;
      print_count = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;child process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;co&quot;&gt;/* + */&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;/* When fork() returns a positive number, we are in the parent process&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;       * (the fork return value is the PID of the newly created child process) */&lt;/span&gt;
      print_count = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;parent process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
  }
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;print_count &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; print_count--) {
      puts(buf);
      sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(pid)
  {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//the parent process&lt;/span&gt;
  }
  &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
  {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//the child process&lt;/span&gt;
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果bash也监控子进程，那么由于子进程是后来完成的，bash得到的返回值应该是0，否则就是1.结果输出如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;frank@under:~/tmp$ ./a.out 
parent process: pid = 26290
child process: pid = 0
parent process: pid = 26290
child process: pid = 0
parent process: pid = 26290
child process: pid = 0
parent process: pid = 26290
child process: pid = 0
parent process: pid = 26290
child process: pid = 0
child process: pid = 0
frank@under:~/tmp$ child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
echo $?
1
frank@under:~/tmp$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，其返回值是1，猜想正确。&lt;/p&gt;
&lt;h4 id=&quot;wait-系统调用&quot;&gt;wait() 系统调用&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;wait()&lt;/code&gt;的主要是为了和子进程的同步性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;暂时将父进程挂起，直到某一个子进程终止。&lt;/li&gt;
&lt;li&gt;返回值是终止子进程的&lt;strong&gt;PID&lt;/strong&gt;,对于一个成功返回的进程，父进程将会回收子进程 。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;child_status != NULL&lt;/strong&gt; ， &lt;strong&gt;status&lt;/strong&gt; 的值将会反映子进程终止的原因。&lt;/li&gt;
&lt;li&gt;如果父进程有多个子进程，那么&lt;code&gt;wait()&lt;/code&gt;将会在&lt;strong&gt;任何&lt;/strong&gt;一个子进程终止的时候返回。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;waitpid()&lt;/code&gt;可以被用来等待特定的子进程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;父进程需要知道什么时候它的子进程终止了或者状态改变了或者接收到一个信号而停止了。&lt;code&gt;wait()&lt;/code&gt;就是监视子进程的其中一个方法（另一个是&lt;strong&gt;SIGCHLD&lt;/strong&gt;信号）。&lt;/p&gt;
&lt;p&gt;（译者注：&lt;strong&gt;SIGCHLD&lt;/strong&gt; 20,17,18 Ign Child stopped or terminated）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt;会锁住调用的进程&lt;strong&gt;直到它的子进程退出或者接收到了一个信号&lt;/strong&gt;，&lt;code&gt;wait()&lt;/code&gt;会接受一个整型的地址参数并返回完成的子进程的&lt;strong&gt;PID&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;
pid_t wait(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *child_status);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再一次说明。调用&lt;code&gt;wait()&lt;/code&gt;的一个主要目的就是等待子进程执行完毕。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt;的执行可以分为两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果调用&lt;code&gt;wait()&lt;/code&gt;的时候存在子进程，调用者将暂时被挂起，直到其中一个子进程终止它才会恢复运行。&lt;/li&gt;
&lt;li&gt;如果调用&lt;code&gt;wait()&lt;/code&gt;的时候没有子进程，那么&lt;code&gt;wait()&lt;/code&gt;相当于不起作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;系统调用&lt;strong&gt;wait(&amp;amp;status)&lt;/strong&gt; 有两个目的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果调用子进程没有调用 &lt;strong&gt;exit()&lt;/strong&gt;退出，调用者将暂时被挂起，直到其中一个子进程终止它才会恢复运行。（译者：这他妈不都讲了几遍啊，严重怀疑作者凑字数）&lt;/li&gt;
&lt;li&gt;子进程的终止状态返回到了&lt;code&gt;wait()&lt;/code&gt;的status变量里。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//译者：#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//译者：#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//译者：这作者是不是喝酒了啊，自己都说wait在sys/wait.h里面。。）&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 150&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid = fork();
  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[BUF_SIZE];
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; print_count;

  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (pid)
  {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
      perror(&lt;span class=&quot;st&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;);
      exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;child process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;parent process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
  }
  &lt;span class=&quot;co&quot;&gt;//if(!pid) { 译者注：又TMD写错了，这是子进程，醉了。。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(pid) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; status;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid_child = wait(&amp;amp;status;);
  }
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;print_count &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; print_count--) puts(buf);
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在父进程会等待子进程执行完毕才会开始打印：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
parent process: pid = 22652
parent process: pid = 22652
parent process: pid = 22652
parent process: pid = 22652
parent process: pid = 22652&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;译者注：稍微改了一下，看看&lt;code&gt;wait()&lt;/code&gt;的返回值和对status做的改变：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 150&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid = fork();
  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[BUF_SIZE];
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; print_count;
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; status = &lt;span class=&quot;dv&quot;&gt;12345&lt;/span&gt;;
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid_child;

  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (pid)
  {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
      perror(&lt;span class=&quot;st&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;);
      exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;child process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;parent process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(pid) {
    pid_child = wait(&amp;amp;status);
  }
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;print_count &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; print_count--) puts(buf);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pid)
    {

      printf(&lt;span class=&quot;st&quot;&gt;&quot;pid = %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, pid);
      printf(&lt;span class=&quot;st&quot;&gt;&quot;pid_child = %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, pid_child);
      printf(&lt;span class=&quot;st&quot;&gt;&quot;status = %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, status);
    }
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;frank@under:~/tmp$ ./a.out 
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
child process: pid = 0
parent process: pid = 842
parent process: pid = 842
parent process: pid = 842
parent process: pid = 842
parent process: pid = 842
pid = 842
pid_child = 842
status = 0
frank@under:~/tmp$ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，status被改变为0，&lt;code&gt;wait()&lt;/code&gt;返回的值就是子进程的&lt;strong&gt;PID&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;exit-库函数调用-_exit-系统调用&quot;&gt;exit() 库函数调用 / _exit() 系统调用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;exit(status)&lt;/code&gt;库函数是用来终止进程的，同时使得进程占用的所有资源（内存，打开的文件描述符等待）释放掉，被内核进行再分配处理，以便被别的进程所使用。传入的status参数决定了这个进程结束时候的状态，这个状态是可以被&lt;code&gt;wait()&lt;/code&gt;所捕获的。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;exit()&lt;/code&gt;是&lt;code&gt;_exit()&lt;/code&gt;系统调用的抽象......在&lt;code&gt;fork()&lt;/code&gt;之后，通常情况下只有一个父进程的子进程会通过&lt;code&gt;exit()&lt;/code&gt;终止掉，其余的进程应该使用&lt;code&gt;_exit()&lt;/code&gt; 。” — The Linux Programming Interface&lt;/p&gt;
&lt;p&gt;译者：参考 &quot;Linux Programmer's Manual&quot; :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The function _exit() terminates the calling process &quot;immediately&quot;.  Any open file descriptors belonging to the process are closed; any children of the process are inherited by process 1, init, and the process's parent is sent a SIGCHLD signal.

The  value  status  is  returned to the parent process as the process's exit status, and can be collected using one of the  wait(2)  family  of calls.

The function _Exit() is equivalent to _exit().&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;僵尸进程&quot;&gt;僵尸进程&lt;/h4&gt;
&lt;p&gt;父进程和子进程的存活时间一般都不相同：要么父进程活得长要么相反。&lt;/p&gt;
&lt;p&gt;那么，如果子进程在父进程还没有调用&lt;code&gt;wait()&lt;/code&gt;之前终止了会怎么样？事实是，即使子进程已经终止了，父进程应该还是允许调用&lt;code&gt;wait()&lt;/code&gt;查看这个子进程的终止状态。内核通过将子进程变为一个僵尸进程来处理这样的情况。这意味着大多数子进程占用的资源都被释放掉以便系统再分配利用。&lt;/p&gt;
&lt;p&gt;事实上，当一个进程终止后，它不会立即从内存中消失——它的&lt;strong&gt;进程描述符&lt;/strong&gt; （译者注：进程描述符我以后会在另一篇定义进程状态的文章中列出的）还会驻留在内存中（这只会占用很少内存）。进程的状态会变为 &lt;strong&gt;EXIT_ZOMBIE&lt;/strong&gt; 并且通过信号 &lt;strong&gt;SIGCHLD&lt;/strong&gt; 告知其父进程它已经“死亡”了。父进程应该通过调用&lt;code&gt;wait()&lt;/code&gt;来读取这个僵尸进程的退出状态和其他信息。在&lt;code&gt;wait()&lt;/code&gt;调用之后，这个僵尸进程就会完全从内存中消失掉。&lt;/p&gt;
&lt;p&gt;这通常发生的非常快，所以你不会看到僵尸进程在你的电脑上不断增加。然而，如果一个父进程从来不调用&lt;code&gt;wait()&lt;/code&gt; ，它产生的僵尸进程就会在程序结束前一直驻留内存。 -来自 &lt;a href=&quot;http://www.howtogeek.com/119815/htg-explains-what-is-a-zombie-process-on-linux/&quot;&gt;what-is-a-zombie-process-on-linux&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// file - zombie.c&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//译者注：少了#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 150&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pid = fork();
  &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[BUF_SIZE];
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; print_count;

  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (pid)
  {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
      perror(&lt;span class=&quot;st&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;);
      exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;child process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
      print_count = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
      sprintf(buf,&lt;span class=&quot;st&quot;&gt;&quot;parent process: pid = %d&quot;&lt;/span&gt;, pid);
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
  }
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(;print_count &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; print_count--) {
      puts(buf);
      sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
  }
  exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你运行以上代码，子进程会在父进程结束前结束，并且会变成一个僵尸进程直到父进程结束。如下所示：&lt;/p&gt;
&lt;p&gt;译者注（&lt;strong&gt;PID&lt;/strong&gt;为25351，&lt;strong&gt;S&lt;/strong&gt;为Z，CMD为&amp;lt;defunct&amp;gt;）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ ./zombie
$ ps -la
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S   601 25350 12377  0  75   0 -   381 -      pts/0    00:00:00 zombie
1 Z   601 25351 25350  0  78   0 -     0 exit   pts/0    00:00:00 zomb &amp;lt;defunct&amp;gt;
0 R   601 25352 12377  0  77   0 -  1054 -      pts/0    00:00:00 ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下描述来自于 &lt;a href=&quot;http://www.howtogeek.com/119815/htg-explains-what-is-a-zombie-process-on-linux/&quot;&gt;what-is-a-zombie-process-on-linux&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;僵尸进程不会消耗任何系统资源&lt;/strong&gt;（事实上，每一个僵尸进程只会使用一丁点内存来保存进程描述符）。然而，&lt;strong&gt;每一个僵尸进程还是会保留它的PID&lt;/strong&gt;。Linux在32位系统上有一个固定的PID范围：32767。如果僵尸进程以很快的速度累计——例如，一个编写错误的服务程序，那么很快就将&lt;strong&gt;没有剩余的PID可以使用，其他正常的进程也启动不了了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，少部分僵尸进程还是无伤大雅的，虽然在一定程度上反映了其父进程存在一些bug。&lt;/p&gt;
&lt;p&gt;如果父进程非正常终止，它的子进程会变成init的子进程。僵尸进程会驻留在内存中直到init将其释放。虽然只是一小段时间，它们也会再释放前占用PID。&lt;/p&gt;
&lt;p&gt;我们不能像终止正常进程那样使用 &lt;strong&gt;SIGKILL&lt;/strong&gt; 信号终止一个僵尸进程。对于僵尸进程，UNIX像电影中的那样——它不能被信号终止，甚至是(silver bullet，译者注：&lt;strong&gt;银色子弹&lt;/strong&gt;是指一种鸡尾酒。援引自西方的魔幻故事中驱魔的&lt;strong&gt;银色子弹&lt;/strong&gt;，在魔幻故事中有驱魔效果。) &lt;strong&gt;SIGKILL&lt;/strong&gt; 都不行。事实上，这是一个故意为之的特性，为了确保父进程总是可以最终调用&lt;code&gt;wait()&lt;/code&gt; 。记住，我们不需要为一小撮僵尸进程担忧，除非它们快速累计起来了。但是，还是有一些方法拜托僵尸进程的。&lt;/p&gt;
&lt;p&gt;其中的一种方法就是像僵尸进程的父进程发送&lt;strong&gt;SIGCHLD&lt;/strong&gt; 信号。这个信号告诉父进程执行&lt;code&gt;wait()&lt;/code&gt;然后清除僵尸子进程。可以使用kill命令发送这个信号：（其中的pid是父进程的&lt;strong&gt;PID&lt;/strong&gt; ）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kill -s SIGCHLD pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，如果父进程没有正确处理&lt;strong&gt;SIGCHLD&lt;/strong&gt;信号，这就不会有效果。我们必须终止父进程——这些剩下的僵尸子进程的父进程会变成&lt;strong&gt;init&lt;/strong&gt;，而init会定期执行&lt;code&gt;wait()&lt;/code&gt; 系统调用去清理僵尸子进程，所以&lt;strong&gt;init&lt;/strong&gt;会使得僵尸进程不那么“嚣张”。&lt;/p&gt;
&lt;p&gt;如果父进程持续创造僵尸进程，我们就必须debug它了，让它正确的调用&lt;code&gt;wait()&lt;/code&gt;来回收它的僵尸子进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;僵尸进程并不同于孤儿进程&lt;/strong&gt;（orphan process）。孤儿进程是指一个&lt;strong&gt;持续运行的程序&lt;/strong&gt;，但是它的&lt;strong&gt;父进程已经终止了&lt;/strong&gt;。它们不是僵尸——它们会被&lt;strong&gt;init&lt;/strong&gt;收养。（译者：哈哈，生动形象）&lt;br/&gt;换句话说，在父进程终止后，对子进程调用&lt;strong&gt;getppid()&lt;/strong&gt; 会得到1（&lt;strong&gt;init&lt;/strong&gt; ）。这可以用来判断一个进程的父进程是否已经终止。（假设这个子进程不是一开始就是&lt;strong&gt;init&lt;/strong&gt;创建的）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;译者：下面的信号部分明天翻译；）&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;signals&quot;&gt;Signals&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Signal&lt;/strong&gt; is a notification, a message sent by either operating system or some application to our program. Signals are a mechanism for one-way asynchronous notifications. A signal may be sent from the kernel to a process, from a process to another process, or from a process to itself. Signal typically alert a process to some event, such as a segmentation fault, or the user pressing Ctrl-C.&lt;/p&gt;
&lt;p&gt;Linux kernel implements about 30 signals. Each signal identified by a number, from 1 to 31. Signals don't carry any argument and their names are mostly self explanatory. For instance &lt;strong&gt;SIGKILL&lt;/strong&gt; or signal number &lt;strong&gt;9&lt;/strong&gt; tells the program that someone tries to kill it, and &lt;strong&gt;SIGHUP&lt;/strong&gt; used to signal that a terminal hangup has occurred, and it has a value of &lt;strong&gt;1&lt;/strong&gt; on the i386 architecture.&lt;/p&gt;
&lt;p&gt;With the exception of &lt;strong&gt;SIGKILL&lt;/strong&gt; and &lt;strong&gt;SIGSTOP&lt;/strong&gt; which always terminates the process or stops the process, respectively, processes may control what happens when they receive a signal. They can&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;accept the default action, which may be to terminate the process, terminate and coredump the process, stop the process, or do nothing, depending on the signal.&lt;/li&gt;
&lt;li&gt;Or, processes can elect to explicitly ignore or handle signals.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ignored signals&lt;/strong&gt; are silently dropped.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Handled signals&lt;/strong&gt; cause the execution of a user-supplied &lt;strong&gt;signal handler&lt;/strong&gt; function. The program jumps to this function as soon as the signal is received, and the control of the program resumes at the previously interrupted instructions.&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;25&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGHUP&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Hangup (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Terminal interrupt (ANSI)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGQUIT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Terminal quit (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGILL&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Illegal instruction (ANSI)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGTRAP&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Trace trap (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SIGIOT&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;IOT Trap (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGBUS&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;BUS error (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGFPE&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;Floating point exception (ANSI)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Kill(can't be caught or ignored) (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGUSR1&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;User defined signal 1 (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGSEGV&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Invalid memory segment access (ANSI)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGUSR2&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;User defined signal 2 (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGPIPE&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Write on a pipe with no reader, Broken pipe (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SIGALRM&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;Alarm clock (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGTERM&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;Termination (ANSI)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SIGSTKFLT&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;Stack fault&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGCHLD&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;Child process has stopped or exited, changed (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGCONTv&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;Continue executing, if stopped (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGSTOP&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;Stop executing(can't be caught or ignored) (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTSTP&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;Terminal stop signal (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGTTIN&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;Background process trying to read, from TTY (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGTTOU&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;Background process trying to write, to TTY (POSIX)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGURG&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;Urgent condition on socket (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGXCPU&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;CPU limit exceeded (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGXFSZ&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;File size limit exceeded (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGVTALRM&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;Virtual alarm clock (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGPROF&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;Profiling alarm clock (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGWINCH&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;Window size change (4.3 BSD, Sun)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGIO&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;I/O now possible (4.2 BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGPWR&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;Power failure restart (System V)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;The term &lt;strong&gt;raise&lt;/strong&gt; is used to indicate the generation of a signal, and the term &lt;strong&gt;catch&lt;/strong&gt; is used to indicate the receipt of a signal.&lt;/p&gt;
&lt;p&gt;Signals are raised by error conditions, and they are generated by the shell and terminal handlers to cause interrupts and can also be sent from one process to another to pass information or to modify the behavior.&lt;/p&gt;
&lt;p&gt;Signals can be:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Raised&lt;/li&gt;
&lt;li&gt;Caught&lt;/li&gt;
&lt;li&gt;Acted upon&lt;/li&gt;
&lt;li&gt;Ignored&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;If a process receives signals such as &lt;strong&gt;SIGFPE&lt;/strong&gt;, &lt;strong&gt;SIGKILL&lt;/strong&gt;, etc., the process will be terminated immediately, and a &lt;strong&gt;core dump&lt;/strong&gt; file is created. The &lt;strong&gt;core&lt;/strong&gt; file is an image of the process, and we can use it to debug.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/www.bogotobogo.com/Linux/debugging_gdb.php&quot;&gt;coredump debugging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here is an example of the common situation when we use a signal: when we type the &lt;strong&gt;interrupt character (Ctrl+C)&lt;/strong&gt;, the &lt;strong&gt;ISGINT&lt;/strong&gt; signal will be sent to the &lt;strong&gt;foreground process&lt;/strong&gt; (the program currently running). This will cause the program to terminate unless it has some arrangement for catching the signal.&lt;/p&gt;
&lt;p&gt;The command &lt;strong&gt;kill&lt;/strong&gt; can be used to send a signal to a process other than the current foreground process. To send a &lt;strong&gt;hangup&lt;/strong&gt; signal to a shell running on a different terminal, we can use the following command:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kill -HUP pid_number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;There is another useful variant of &lt;strong&gt;kill&lt;/strong&gt; is &lt;strong&gt;killall&lt;/strong&gt;. This allows us to send a signal to all processes running a specified command. For example, to send a &lt;strong&gt;reread&lt;/strong&gt; signal to the &lt;strong&gt;inetd&lt;/strong&gt; program:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   $ killall -HUP inetd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The command causes the &lt;strong&gt;inetd&lt;/strong&gt; program to reread its configuration options.&lt;/p&gt;
&lt;p&gt;In the following example, the program will reacts to the Ctrl+C rather than terminating foreground task. But if we hit the Ctrl+C again, it will do what it usually does, terminating the program.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;signal.h&amp;gt;

    void my_signal_interrupt(int sig)
    {
      printf(&quot;I got signal %d\n&quot;, sig);
      (void) signal(SIGINT, SIG_DFL);
    }

    int main()
    {
      (void) signal(SIGINT,my_signal_interrupt);

      while(1) {
          printf(&quot;Waiting for interruption...\n&quot;);
          sleep(1);
      }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Output from the run when we typed Ctrl+C two times:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    I got signal 2
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...
    Waiting for interruption...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;strong&gt;my_signal_interrupt()&lt;/strong&gt; is called when we give &lt;strong&gt;SIGINT&lt;/strong&gt; signal by typing Ctrl+C. After the interrupt function &lt;strong&gt;my_signal_interrupt()&lt;/strong&gt;has completed, the program moves on, but the signal action is restored to the default. So, when it gets a second &lt;strong&gt;SIGINT&lt;/strong&gt; signal, the program takes the default action, which is terminating the program.&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 14:58:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/7689667.html</dc:identifier>
</item>
<item>
<title>对着java并发包写.net并发包之原子类型实现 - 华然</title>
<link>http://www.cnblogs.com/Huaran1chendu/p/7689484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Huaran1chendu/p/7689484.html</guid>
<description>&lt;p&gt;众所周知，java1.5并发包通过volatile+CAS原理提供了优雅的并发支持。今天仔细想想.net也有volatile关键字保证内存的可见性，同时也有Interlocked提供了CAS的API，因此突发奇想——对着java并发包写一下.net并发包。第一步就是原子类型的实现（.NET目前还没有原子类型）&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/FanHuaRan/Dotnet.Concurrent&lt;/p&gt;
&lt;h2&gt;一.原子int&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 原子int 基于CAS+自旋无锁化编程实现，核心Interlocked
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2017/10/18 fhr
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicInteger
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缺省默认值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITAL_VALUE=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 被包装的int值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 比较并设置新值 成功返回true 失败返回false
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expect&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;update&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CompareAndSet(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; expect == Interlocked.CompareExchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value, update, expect);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置新值，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;newValue&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetAndSet(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value, newValue);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自增1，返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; IncrementAndGet()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Increment(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自增1，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetAndIncrement()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Increment(&lt;span&gt;ref&lt;/span&gt; value)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自减一，返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; DecrementAndGet()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Decrement(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自减一，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetAndDecrement()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Decrement(&lt;span&gt;ref&lt;/span&gt; value)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加上add,返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetAndAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; add)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; ; )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; next=current+&lt;span&gt;add;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CompareAndSet(current,next))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加上add,返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddAndGet(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; add)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; ; )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; next = current +&lt;span&gt; add;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CompareAndSet(current, next))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
                }
            }
        }
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicInteger(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; inital)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; inital;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicInteger()
            : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(DEFAULT_INITAL_VALUE)
        {

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; value getter&amp;amp;setter
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Value
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value; }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写hashcode value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCode()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写equals value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;is&lt;/span&gt; AtomicInteger&amp;amp;&amp;amp;obj!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                AtomicInteger atoObj &lt;/span&gt;= obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; AtomicInteger;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (atoObj.Value ==&lt;span&gt; Value)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; toString
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.ToString();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二.原子long&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 原子long 基于CAS+自旋无锁化编程实现，核心Interlocked
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2017/10/18 fhr
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicLong
    {
         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缺省默认值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; DEFAULT_LONG_VALUE=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 被包装的long值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 比较并设置新值 成功返回true 失败返回false
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expect&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;update&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CompareAndSet(&lt;span&gt;long&lt;/span&gt; expect, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; update)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; expect == Interlocked.CompareExchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value, update, expect);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置新值，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;newValue&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; GetAndSet(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; newValue)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value, newValue);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自增1，返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; IncrementAndGet()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Increment(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自增1，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetAndIncrement()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Increment(&lt;span&gt;ref&lt;/span&gt; value)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自减一，返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; DecrementAndGet()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Decrement(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自减一，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetAndDecrement()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Decrement(&lt;span&gt;ref&lt;/span&gt; value)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加上add,返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; GetAndAdd(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; add)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; ; )
            {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; current =&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; next=current+&lt;span&gt;add;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CompareAndSet(current,next))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加上add,返回新值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; AddAndGet(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; add)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (; ; )
            {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; current =&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; next = current +&lt;span&gt; add;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CompareAndSet(current, next))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
                }
            }
        }
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicLong(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; inital)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; inital;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicLong()
            : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(DEFAULT_LONG_VALUE)
        {

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; value getter&amp;amp;setter
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; Value
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value; }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写hashcode value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetHashCode()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写equals value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;is&lt;/span&gt; AtomicLong&amp;amp;&amp;amp;obj!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                AtomicLong atoObj &lt;/span&gt;= obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; AtomicLong;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (atoObj.Value ==&lt;span&gt; Value)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; toString
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.ToString();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三.原子bool&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 原子Boolean 基于CAS+自旋无锁化编程实现，核心Interlocked
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2017/10/18 fhr
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AtomicBoolean
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TRUE_INT = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FALSE_INT = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 被包装的boolean值 int表示 0为false 1为真
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 比较并设置新值 成功返回true 失败返回false
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expect&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;update&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CompareAndSet(&lt;span&gt;bool&lt;/span&gt; expect, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; update)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; e = expect ?&lt;span&gt; TRUE_INT : FALSE_INT;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; u = update ?&lt;span&gt; TRUE_INT : FALSE_INT;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e == Interlocked.CompareExchange(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; value, u, e);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置新值，返回旧值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;newValue&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; GetAndSet(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; newValue)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = newValue ?&lt;span&gt; TRUE_INT : FALSE_INT;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt; value, n) ==&lt;span&gt; TRUE_INT;
        }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicBoolean(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; inital)
        {
            Value &lt;/span&gt;=&lt;span&gt; inital;
         }

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicBoolean()
            : &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; value getter&amp;amp;setter
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Value
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; value==&lt;span&gt;TRUE_INT; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = value==&lt;span&gt;true&lt;/span&gt;?&lt;span&gt;TRUE_INT:FALSE_INT;
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写hashcode value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetHashCode()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.GetHashCode();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写equals value相关
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;is&lt;/span&gt; AtomicBoolean &amp;amp;&amp;amp; obj != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                AtomicBoolean atoObj &lt;/span&gt;= obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; AtomicBoolean;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (atoObj.Value ==&lt;span&gt; Value)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; toString
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.ToString();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;剩下完成原子引用+原子数组+AQS及同步器&lt;/p&gt;
&lt;p&gt;有志同道合的朋友一起参与哦&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;github:https://github.com/FanHuaRan/Dotnet.Concurrent&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 14:27:00 +0000</pubDate>
<dc:creator>华然</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Huaran1chendu/p/7689484.html</dc:identifier>
</item>
</channel>
</rss>