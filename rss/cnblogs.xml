<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[翻译] 使用 Visual Studio 2019 来提高每个开发人员的工作效率 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/making-every-developer-more-productive-with-visual-studio-2019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/making-every-developer-more-productive-with-visual-studio-2019.html</guid>
<description>&lt;p&gt;原文: &lt;a href=&quot;https://blogs.msdn.microsoft.com/visualstudio/2018/12/04/making-every-developer-more-productive-with-visual-studio-2019/&quot;&gt;Making every developer more productive with Visual Studio 2019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，在 &lt;a href=&quot;https://aka.ms/connectevent&quot;&gt;Microsoft Connect(); 2018&lt;/a&gt; 的主题演讲中，Scott Guthrie 宣布推出 Visual Studio 2019 Preview 1。这是 Visual Studio 下一个主要版本的首次预览。在本预览版中，我们专注于几个关键领域，例如使其更快地打开在 git 库中的项目、使用人工智能改进 IntelliSense（这个功能我们称之为 Visual Studio IntelliCode），以及通过集成 Live Share ，您可以更轻松地与团队成员进行协作。通过每一次预览版，我们将逐步添加功能，提高性能并改善用户体验，我们非常希望得到您的反馈。&lt;/p&gt;
&lt;p&gt;有关新功能的快速概述，您可以继续阅读此博客，或者如果您想要观看视频，请查看我们的团队成员 Allison 对 &lt;a href=&quot;https://youtu.be/9XE8kOI5JTk&quot;&gt;Visual Studio 2019 的介绍&lt;/a&gt;。但在您观看之前，请先下载 &lt;a href=&quot;https://aka.ms/vs-preview&quot;&gt;Visual Studio 2019 Preview 1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使您能够专注于您的工作&quot;&gt;使您能够专注于您的工作&lt;/h2&gt;
&lt;p&gt;马上，您会注意到 Visual Studio 2019 在启动时打开了一个&lt;strong&gt;新的启动窗口&lt;/strong&gt;，这种体验更适合与今天的Git 库一起使用 - 无论是本地存储库还是 GitHub、Azure 库或其他地方的在线 Git 库。当然，您仍然可以打开现有项目、解决方案、创建新项目或解决方案。（Visual Studio 2019 for Mac 也即将推出）下周我们将在新的开始窗口体验中发布更详细的博客文章，也会涉及此次改造的一些研究。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-start-500x342.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2019 启动窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs4mac-start-500x322.png&quot;/&gt;&lt;br/&gt;Visual Studio 2019 for Mac 启动窗口&lt;/p&gt;
&lt;p&gt;进入 IDE 后，您会注意到 Visual Studio 2019 的 UI 和 UX 发生了一些变化。Jamie Young 最近发布了一篇&lt;a href=&quot;https://blogs.msdn.microsoft.com/visualstudio/2018/11/12/a-preview-of-ux-and-ui-changes-in-visual-studio-2019/&quot;&gt;博文&lt;/a&gt;，其中详细介绍了这些变化，我们来回顾一下，它们包括一个新的产品图标、一个新鲜的蓝色主题、在 UI 上进行小的更改以创建更清晰的界面、以及更紧凑的标题和菜单栏 - 我们已经听到您的反馈，并正在努力进一步优化。&lt;/p&gt;
&lt;p&gt;除了 Jamie 提到的增强功能之外，今天我们将在 Visual Studio 2019 中分享新的搜索体验，它取代了现有的“快速启动”框。您现在可以搜索设置、命令和安装选项。新的搜索体验也更加智能，因为它支持模糊字符串搜索，即使拼写错误也能帮助找到您要查找的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-search.png&quot;/&gt;&lt;br/&gt;Visual Studio 2019 中新的搜索体验&lt;/p&gt;
&lt;p&gt;在编写代码时，Visual Studio 2019 可以让您更快地完成工作。我们首先关注此预览版中的代码可维护性和一致性体验。我们添加了新的重构功能 - 例如将 for 循环更改为 LINQ 查询，将元组转换为命名的结构 - 以便更容易的使代码保持良好状态。借助新的文档健康指示器和代码清理功能，您现在可以通过单击按钮轻松识别和修复警告和建议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-health.gif&quot;/&gt;&lt;br/&gt;文档健康指示器和代码清理命令&lt;/p&gt;
&lt;p&gt;常见的调试任务也变得更容易。您会看到单步调试的性能得到改善，从而实现更顺畅的调试体验。我们还为 Autos，Locals 和 Watch 窗口添加了搜索功能，帮助您跟踪对象和值。未来会有博客文章，深入讲解 Visual Studio 2019 中的调试器改进，包括新的针对托管代码功能的 Time Travel 调试器（即将发布）、更新的 Snapshot 调试器以定位 Azure Kubernetes 服务和 Virtual Machine Scale Sets（VMSS）、调试大型 C++ 项目时更好的性能; 多亏了 out-of-process 64-bit 调试器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-watch-500x179.png&quot;/&gt;&lt;br/&gt;在 Watch 窗口中搜索&lt;/p&gt;
&lt;h2 id=&quot;帮助您的团队一起工作&quot;&gt;帮助您的团队一起工作&lt;/h2&gt;
&lt;p&gt;基于我们在 Visual Studio 2017 中开始的工作，我们正在改进 &lt;a href=&quot;https://visualstudio.microsoft.com/services/intellicode/&quot;&gt;Visual Studio IntelliCode&lt;/a&gt;，我们的上下文感知和 AI 驱动的 IntelliSense，您可以在您自己的代码库上对其进行 AI 训练，并与您的团队分享结果。IntelliCode 减少了您需要的击键次数，因为完成列表优先考虑该 API 的最常见编码模式以及现有项目中代码的上下文。我们将在本周晚些时候发布关于IntelliCode 所有改进的博客文章，包括从代码中学习的更多细节，以及为 Visual Studio 2019 添加的 C++ 和 XAML 支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/intellicode-500x130.png&quot;/&gt;&lt;br/&gt;Visual Studio IntelliCode 使用了一个训练模型&lt;/p&gt;
&lt;p&gt;今年早些时候，我们介绍了 Visual Studio Live Share，以帮助您使用 Visual Studio 或Visual Studio Code 与全球任何人进行实时协作。默认情况下，Visual Studio 2019 会安装 Live Share，因此您可以立即邀请您的队友加入您的会话以修复 bug 或帮助修改。您还会发现，现在启动一个会话会更容易，并且可以在右上角查看到参与的人员。我们还将在接下来的几天内深入介绍 Visual Studio Live Share 的改进，包括对其他项目、应用类型和语言的支持，访客的解决方案视图以及对更多协作方案的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/liveshare-500x128.png&quot;/&gt;&lt;br/&gt;Visual Studio Live Share 集成在 Visual Studio 2019 中&lt;/p&gt;
&lt;p&gt;最后，我们在 Visual Studio 2019 中引入了全新的 pull request（PR）体验，使您无需离开IDE 即可查看、运行甚至调试团队的 pull request。我们现在支持 Azure 库中的代码，但将很快支持 GitHub 并改善整体体验。马上开始，您可以从 Visual Studio Marketplace 下载 &lt;a href=&quot;https://aka.ms/pr4vs&quot;&gt;Pull Requests 扩展&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-pull.gif&quot;/&gt;&lt;br/&gt;Visual Studio 2019 中心的 pull request 体验&lt;/p&gt;
&lt;h2 id=&quot;net-core-3-preview-1&quot;&gt;.NET Core 3 Preview 1&lt;/h2&gt;
&lt;p&gt;我们今天还发布了 &lt;a href=&quot;http://aka.ms/netcore3preview1&quot;&gt;.NET Core 3 Preview 1&lt;/a&gt;，Visual Studio 2019 将是支持为任何平台构建 .NET Core 3 应用程序的版本。当然，我们还将继续支持和改进跨平台的 C++ 开发，以及使用Xamarin 的 iOS 和 Android 的 .NET 移动开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://msdnshared.blob.core.windows.net/media/2018/12/vs2019-dotnetcore-500x333.png&quot;/&gt;&lt;br/&gt;Visual Studio 2019 中的 .NET Core 3.0 开发&lt;/p&gt;
&lt;h2 id=&quot;帮助我们构建最好的-visual-studio&quot;&gt;帮助我们构建最好的 Visual Studio&lt;/h2&gt;
&lt;p&gt;我们非常感谢拥有这样一个活跃的社区，并且迫不及待地想听听您对 Visual Studio 2019 的看法。请通过使用&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio-2017?view=vs-2017&quot;&gt;报告问题工具&lt;/a&gt;告诉我们您遇到的任何问题，帮助我们将其打造成最佳的 Visual Studio。您还可以访问 Visual Studio 开发人员社区来跟踪您的问题，或者提出更好地建议，并从其他人那里寻找答案。&lt;/p&gt;
&lt;p&gt;随着我们发布更多预览版，我们将在未来几个月内分享有关 Visual Studio 2019 的完整功能集和SKU lineup 的更多信息。 Visual Studio 2019 可以与 Visual Studio 2017 同时安装，或者如果您想在不安装它的情况下进行尝试，请查看 Azure 上的 &lt;a href=&quot;https://docs.microsoft.com/visualstudio/install/using-visual-studio-vm&quot;&gt;Visual Studio 镜像&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我还想花一点时间来感谢我们充满活力的扩展生态系统，它已经为 Visual Studio 2019 preview 1 提供了 400 多个扩展，并且每天都有更多扩展。您可以在 Visual Studio Marketplace 上找到这些扩展。&lt;/p&gt;
&lt;p&gt;微软一直是一家以开发人员为核心的公司 - 我们感到受宠若惊的是，Visual Studio 家族的用户群已经超过了 1200 万。我们的目标是让您每一秒钟的编码都更有成效和充满愉快。请继续分享您对 Visual Studio 2019 预览版的反馈，以帮助指导产品的未来发展方向，使其成为您最喜爱的工具。谢谢！&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 17:45:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>今天，在 [Microsoft Connect(); 2018](https://aka.ms/connectevent) 的主题演讲中，Scott Guthrie 宣布推出 Visual Studi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rwing/p/making-every-developer-more-productive-with-visual-studio-2019.html</dc:identifier>
</item>
<item>
<title>快应用脚手架，为优雅而生 - 云轩奕鹤</title>
<link>http://www.cnblogs.com/jadeboy/p/10068532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jadeboy/p/10068532.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt;是基于手机硬件平台的新型应用形态，标准是由主流手机厂商组成的&lt;code&gt;快应用联盟&lt;/code&gt;联合制定。其标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt;具备传统 APP 完整的应用体验，&lt;code&gt;无需安装、即点即用&lt;/code&gt;；&lt;code&gt;覆盖 10 亿设备&lt;/code&gt;，&lt;code&gt;与操作系统深度集成，探索新型应用场景&lt;/code&gt;。&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt; ── &lt;strong&gt;复杂生活的简单答案，让生活更顺畅&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/jpg/nice-links-007.jpg&quot; alt=&quot;快应用脚手架模板&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;目标与哲学&quot;&gt;目标与哲学&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt;是一种新型的应用形态，由国内九大手机厂商基于硬件平台共同推出；秒开即点即用，更易于应用的传播和留存，可以为用户提供更高效的服务。在可预见的未来，其将有不错的应用场景和发展空间。此 &lt;a href=&quot;https://github.com/nicejade/quickapp-boilerplate-template&quot;&gt;quickapp-boilerplate-template&lt;/a&gt; 仓库的建立，旨在探索如何更为优雅的开发&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt;，为广大&lt;code&gt;快应用开发者&lt;/code&gt;提供便利和参考，尽可能提升开发效率、优化开发体验，使得可以在更短时间内，塑造出更为优质的&lt;code&gt;快应用&lt;/code&gt;。关于&lt;a href=&quot;https://nicelinks.site/post/5b5fb5bc615bf842b609105f&quot;&gt;快应用&lt;/a&gt;开发更详细资料，可参见&lt;a href=&quot;https://github.com/nicejade/nice-front-end-tutorial/blob/master/tutorial/quickapp-tutorial.md&quot;&gt;快应用教程资源列表&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;组织结构&quot;&gt;组织结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;├── sign                # 存储 rpk 包签名模块;
│   ├── debug           # 调试环境证书/私钥文件
│   └── release         # 正式环境证书/私钥文件
└── src
│   ├── assets          # 公用的资源(images/styles/字体...)
│   │   ├──images       # 存储 png/jpg/svg 等公共图片资源
│   │   ├──js           # 存储公共 javaScript 代码资源
│   │   └──styles       # 存放 less/css/sass 等公共样式资源
│   ├── helper          # 项目自定义辅助各类工具
│   │   ├──apis         # 存储与后台请求接口相关(已封装好)
│   │   ├──ajax.js      # 对系统提供的 fetch api 进行链式封装
│   │   └──utils        # 存放项目所封装的工具类方法
│   ├── pages           # 统一存放项目页面级代码
│   ├── app.ux          # 应用程序代码的人口文件
│   └── manifest.json   # 配置快应用基本信息
└── package.json        # 定义项目需要的各种模块及配置信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git clone https://github.com/nicejade/quickapp-boilerplate-template.git
cd quickapp-boilerplate-template &amp;amp;&amp;amp; yarn
yarn start # 推荐 ✅✅

# 或者运行以下命令
yarn server &amp;amp; yarn watch

# 或者在终端一 Tab 下运行：
yarn server
# 在终端另一 Tab 下运行：
yarn watch

# ✨ 新增「快应用」页面
yarn gen YourPageName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用一台 &lt;code&gt;Android&lt;/code&gt; 手机，下载安装&lt;a href=&quot;https://www.quickapp.cn/docCenter/post/69&quot;&gt;「快应用」调试器&lt;/a&gt;，打开后操作&lt;code&gt;扫码安装&lt;/code&gt;，扫描如上命令生成的二维码，即可看到效果；更多讯息，请参见&lt;a href=&quot;https://nice.lovejade.cn/zh/article/develop-quick-app-experience-notes.html#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA&quot;&gt;快应用环境搭建&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;改进优势&quot;&gt;改进优势&lt;/h2&gt;
&lt;p&gt;有必要谈及的是，此项目秉承在&lt;a href=&quot;https://nice.lovejade.cn/zh/article/vue-webpack-boilerplate-template.html&quot;&gt;高效开发 Web 单页应用解决方案&lt;/a&gt;中所传递的理念：为&lt;strong&gt;高效开发&lt;/strong&gt;而设计；相比于其内置简陋而凌乱的 Demo，这份脚手架做了以下诸多改进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;✔️ &lt;strong&gt;对项目结构进行优化&lt;/strong&gt;；如上组织结构所示，将各资源模块，更专业的分门别类，使之可以便捷的去编写、维护、查找，同时也是基于前端开发既定共识去设计，更容易为初接触者所理解 &amp;amp; 上手；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;更优雅的处理数据请求&lt;/strong&gt;；采用 &lt;code&gt;Promise&lt;/code&gt; 对系统内置请求 &lt;code&gt;@system.fetch&lt;/code&gt; 进行封装，并抛出至全局，使得可以极简的进行链式调用，同时便捷地处理返回数据；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;内置了样式处理方案&lt;/strong&gt;；「快应用」支持 &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;sass&lt;/code&gt; 的预编译；这里采取 &lt;code&gt;less&lt;/code&gt; 方案，并内置了部分变量，以及常用混合方法，使得可以轻松开启样式编写、复用、修改等；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;封装了常用方法&lt;/strong&gt;；在 &lt;code&gt;helper/utils&lt;/code&gt; 路径下，有对日期、字符串、系统等常用方法，分别进行封装，统一暴露给 &lt;code&gt;global.$utils&lt;/code&gt;，使得维护方式更加合理且健壮，同时又可以便捷的使用，高效开发；当然，你也可以根据需要自行增删、抑或扩展；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;简化开始开发流程&lt;/strong&gt;； 注入 &lt;a href=&quot;https://github.com/kimmobrunfeldt/concurrently&quot;&gt;Concurrently&lt;/a&gt; 插件，使可以运行 &lt;code&gt;yarn start&lt;/code&gt; 即可开始开发，而无需更多命令，从而简洁开发流程；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;优化本地开发端口设定&lt;/strong&gt;；「快应用」默认端口为 &lt;code&gt;12306&lt;/code&gt;，虽说可自定义端口，但使用体验却不够友好；此处参考 &lt;code&gt;creat-react-app&lt;/code&gt; 设定，对本地开发地址端口使用进行优化：如果 🈯️ 定端口(默认: &lt;code&gt;8080&lt;/code&gt;)被占用，则向上递增寻找新的可用端口(如：8081 / 8082 / … )；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;浏览器打开调试主页二维码&lt;/strong&gt;；运行 &lt;code&gt;yarn start&lt;/code&gt;，会启动 HTTP 调试服务器，并将该地址在&lt;strong&gt;命令行终端&lt;/strong&gt;显示，手机端用快应用调试器扫码，即可下载并运行 rpk 包；当终端积累的信息流多了，就造成扫码不便；故增设在浏览器打开调试主页二维码；如想不使用此功能，在 &lt;em&gt;command/server.js&lt;/em&gt; 文件中，将 &lt;strong&gt;autoOpenBrowser&lt;/strong&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 即可；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;集成轻粒子统计分析&lt;/strong&gt;； &lt;a href=&quot;https://nicelinks.site/post/5bdfa8ba9fa22b1b40974f63&quot;&gt;轻粒子&lt;/a&gt;作为官方推荐统计方案，此脚手架已做接入；使用时只需修改 &lt;a href=&quot;https://github.com/nicejade/quickapp-boilerplate-template/blob/master/src/assets/js/statistics.config.js&quot;&gt;statistics.config.js&lt;/a&gt; 中的 &lt;code&gt;app_key&lt;/code&gt;，为在&lt;a href=&quot;http://www.qinglizi.cn/&quot;&gt;轻粒子&lt;/a&gt;所申请的快应用 KEY 即可；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;新增快捷命令脚本&lt;/strong&gt;；使得可以一键生成新页面，只需运行：&lt;code&gt;yarn gen YourPageName&lt;/code&gt; （命名推荐统一为大驼峰，将会在 &lt;code&gt;pages&lt;/code&gt; 路径下新建该页面文件夹）命令即可，当然，也可以根据需要，自行定定制模板：&lt;em&gt;/command/gen/template.ux&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;✔️ &lt;strong&gt;集成 &lt;a href=&quot;https://prettier.io/&quot;&gt;Prettier&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://eslint.org/&quot;&gt;Eslint&lt;/a&gt;&lt;/strong&gt;；在检测代码中潜在问题的同时，统一团队代码规范、风格（&lt;code&gt;js&lt;/code&gt;，&lt;code&gt;less&lt;/code&gt;，&lt;code&gt;scss&lt;/code&gt;等），从而促使写出高质量代码，以提升工作效率(尤其针对团队开发)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写 &lt;a href=&quot;https://github.com/nicejade/prettier-plugin-quickapp&quot;&gt;prettier-plugin-quickapp&lt;/a&gt; 插件&lt;/strong&gt;；为快应用编写 &lt;code&gt;prettier&lt;/code&gt; 插件，使其可以针对 &lt;code&gt;.ux&lt;/code&gt;/&lt;code&gt;.mix&lt;/code&gt; 文件也能很好地工作，从而进一步完善代码风格及规范。&lt;/li&gt;
&lt;li&gt;... ...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;相关链接&quot;&gt;相关链接&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;😉 静晴轩&lt;/td&gt;
&lt;td&gt;✨ 大前端联盟&lt;/td&gt;
&lt;td&gt;🎉 倾城之链&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://image.nicelinks.site/qrcode_jqx.jpg&quot; alt=&quot;静晴轩&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://image.nicelinks.site/wqycx-weixin.png?ver=1&quot; alt=&quot;倾城之链&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://image.nicelinks.site/nice-links.png&quot; width=&quot;300px&quot; alt=&quot;倾城之链&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;1.890243902439&quot;&gt;
&lt;p&gt;原文出处：&lt;a href=&quot;https://nice.lovejade.cn/&quot;&gt;静晴轩别苑&lt;/a&gt;&lt;br/&gt;原文首发：&lt;a href=&quot;https://nice.lovejade.cn/zh/article/quickapp-boilerplate-template.html&quot;&gt;快应用脚手架，为优雅而生&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@2018-11-11 于深圳.福田 Last Modify：2018-12-05&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;同类型文章&quot;&gt;同类型文章&lt;/h3&gt;
</description>
<pubDate>Tue, 04 Dec 2018 16:35:00 +0000</pubDate>
<dc:creator>云轩奕鹤</dc:creator>
<og:description>快应用脚手架模板，旨在探索如何更为优雅的开发快应用，为广大快应用开发者提供便利和参考，尽可能提升开发效率、优化开发体验，使得可以在更短时间内，塑造出更为优质的快应用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jadeboy/p/10068532.html</dc:identifier>
</item>
<item>
<title>ffmpeg简易播放器的实现-音频播放 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/10068490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/10068490.html</guid>
<description>&lt;p&gt;基于FFmpeg和SDL实现的简易视频播放器，主要分为读取视频文件解码和调用SDL显示两大部分。详细流程可参考代码注释。&lt;br/&gt;本篇实验笔记主要参考如下两篇文章：&lt;br/&gt;[1]. &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;最简单的基于FFMPEG+SDL的视频播放器ver2(采用SDL2.0)&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;An ffmpeg and SDL Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;视频播放器基本原理&quot;&gt;1. 视频播放器基本原理&lt;/h2&gt;
&lt;p&gt;下图引用自“&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;雷霄骅，视音频编解码技术零基础学习方法&lt;/a&gt;”，因原图太小，看不太清楚，故重新制作了一张图片。&lt;br/&gt;&lt;img src=&quot;https://leihl.github.io/img/ffmpeg_player/01_player_flow.jpg&quot; title=&quot;播放器基本原理示意图&quot; alt=&quot;播放器基本原理示意图&quot;/&gt;&lt;br/&gt;如下内容引用自“&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;雷霄骅，视音频编解码技术零基础学习方法&lt;/a&gt;”：&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;解协议&lt;/strong&gt;&lt;br/&gt;将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解封装&lt;/strong&gt;&lt;br/&gt;将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;&lt;br/&gt;将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;音视频同步&lt;/strong&gt;&lt;br/&gt;根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简易播放器的实现-音频播放&quot;&gt;2. 简易播放器的实现-音频播放&lt;/h2&gt;
&lt;h3 id=&quot;实验平台&quot;&gt;2.1 实验平台&lt;/h3&gt;
&lt;p&gt;实验平台：openSUSE Leap 42.3&lt;br/&gt;FFmpeg版本：4.1&lt;br/&gt;SDL版本：2.0.9&lt;br/&gt;FFmpeg开发环境搭建可参考“&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10035365.html&quot;&gt;ffmpeg开发环境构建&lt;/a&gt;”&lt;/p&gt;
&lt;h3 id=&quot;源码流程分析&quot;&gt;2.2 源码流程分析&lt;/h3&gt;
&lt;p&gt;本实验仅播放视频文件中的声音，而不显示图像。源码流程参考如下：&lt;br/&gt;&lt;img src=&quot;https://leihl.github.io/img/ffmpeg_player/02_player_audio_flow.jpg&quot; title=&quot;FFmpeg简易播放器-音频播放流程图&quot; alt=&quot;FFmpeg简易播放器-音频播放流程图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关键函数&quot;&gt;2.3 关键函数&lt;/h3&gt;
&lt;p&gt;几个关键函数的说明直接写在代码注释里：&lt;/p&gt;
&lt;h4 id=&quot;开启音频处理子线程&quot;&gt;2.3.1 开启音频处理子线程&lt;/h4&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 打开音频设备并创建音频处理线程。期望的参数是wanted_spec，实际得到的硬件参数是actual_spec
// 1) SDL提供两种使音频设备取得音频数据方法：
//    a. push，SDL以特定的频率调用回调函数，在回调函数中取得音频数据
//    b. pull，用户程序以特定的频率调用SDL_QueueAudio()，向音频设备提供数据。此种情况wanted_spec.callback=NULL
// 2) 音频设备打开后播放静音，不启动回调，调用SDL_PauseAudio(0)后启动回调，开始正常播放音频
SDL_AudioSpec wanted_spec;
SDL_AudioSpec actual_spec;
wanted_spec.freq = p_codec_ctx-&amp;gt;sample_rate;    // 采样率
wanted_spec.format = AUDIO_S16SYS;              // S表带符号，16是采样深度，SYS表采用系统字节序
wanted_spec.channels = p_codec_ctx-&amp;gt;channels;   // 声音通道数
wanted_spec.silence = 0;                        // 静音值
wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;    // SDL声音缓冲区尺寸，单位是单声道采样点尺寸x通道数
wanted_spec.callback = audio_callback;          // 回调函数，若为NULL，则应使用SDL_QueueAudio()机制
wanted_spec.userdata = p_codec_ctx;             // 提供给回调函数的参数
SDL_OpenAudio(&amp;amp;wanted_spec, &amp;amp;actual_spec);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;启动音频回调机制&quot;&gt;2.3.2 启动音频回调机制&lt;/h4&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 暂停/继续音频回调处理。参数1表暂停，0表继续。
// 打开音频设备后默认未启动回调处理，通过调用SDL_PauseAudio(0)来启动回调处理。
// 这样就可以在打开音频设备后先为回调函数安全初始化数据，一切就绪后再启动音频回调。
// 在暂停期间，会将静音值往音频设备写。
SDL_PauseAudio(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;音频回调函数&quot;&gt;2.3.3 音频回调函数&lt;/h4&gt;
&lt;p&gt;用户实现的函数，由SDL音频处理子线程回调&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 音频处理回调函数。读队列获取音频包，解码，播放
// 此函数被SDL按需调用，此函数不在用户主线程中，因此数据需要保护
// \param[in]  userdata用户在注册回调函数时指定的参数
// \param[out] stream 音频数据缓冲区地址，将解码后的音频数据填入此缓冲区
// \param[out] len    音频数据缓冲区大小，单位字节
// 回调函数返回后，stream指向的音频缓冲区将变为无效
// 双声道采样点的顺序为LRLRLR
void audio_callback(void *userdata, uint8_t *stream, int len)
{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;音频包队列读写函数&quot;&gt;2.3.4 音频包队列读写函数&lt;/h4&gt;
&lt;p&gt;用户实现的函数，主线程向队列尾部写音频包，SDL音频处理子线程(回调函数处理)从队列头部取出音频包&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 写队列尾部
int packet_queue_push(packet_queue_t *q, AVPacket *pkt)
{
    ...
}

// 读队列头部
int packet_queue_pop(packet_queue_t *q, AVPacket *pkt, int block)
{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;音频解码&quot;&gt;2.3.5 音频解码&lt;/h4&gt;
&lt;p&gt;音频解码功能封装为一个函数，将一个音频packet解码后得到的声音数据传递给输出缓冲区。此处的输出缓冲区audio_buf会由上一级调用函数audio_callback()在返回时将缓冲区数据提供给音频设备。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int audio_decode_frame(AVCodecContext *p_codec_ctx, AVPacket *p_packet, uint8_t *audio_buf, int buf_size)
{
    AVFrame *p_frame = av_frame_alloc();
    
    int frm_size = 0;
    int ret_size = 0;
    int ret;

    // 1 向解码器喂数据，每次喂一个packet
    ret = avcodec_send_packet(p_codec_ctx, p_packet);
    if (ret != 0)
    {
        printf(&quot;avcodec_send_packet() failed %d\n&quot;, ret);
        av_packet_unref(p_packet);
        return -1;
    }

    ret_size = 0;
    while (1)
    {
        // 2 接收解码器输出的数据，每次接收一个frame
        ret = avcodec_receive_frame(p_codec_ctx, p_frame);
        if (ret != 0)
        {
            if (ret == AVERROR_EOF)
            {
                printf(&quot;audio avcodec_receive_frame(): the decoder has been fully flushed\n&quot;);
                return 0;
            }
            else if (ret == AVERROR(EAGAIN))
            {
                printf(&quot;audio avcodec_receive_frame(): output is not available in this state - &quot;
                       &quot;user must try to send new input\n&quot;);
                break;
            }
            else if (ret == AVERROR(EINVAL))
            {
                printf(&quot;audio avcodec_receive_frame(): codec not opened, or it is an encoder\n&quot;);
            }
            else
            {
                printf(&quot;audio avcodec_receive_frame(): legitimate decoding errors\n&quot;);
            }
        }

        // 3. 根据相应音频参数，获得所需缓冲区大小
        frm_size = av_samples_get_buffer_size(
                NULL, 
                p_codec_ctx-&amp;gt;channels,
                p_frame-&amp;gt;nb_samples,
                p_codec_ctx-&amp;gt;sample_fmt,
                1);

        printf(&quot;frame size %d, buffer size %d\n&quot;, frm_size, buf_size);
        assert(frm_size &amp;lt;= buf_size);
        
        // 4. 将音频帧拷贝到函数输出参数audio_buf
        memcpy(audio_buf, p_frame-&amp;gt;data[0], frm_size);
        
        if (frm_size &amp;gt; 0)
        {
            ret_size += frm_size;
        }
    }

    av_frame_unref(p_frame);
    
    return ret_size;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;br/&gt;[1]. 一个音频packet中含有多个完整的音频帧，因此一次avcodec_send_packet()后，会多次调用avcodec_receive_frame()来将这一个packet解码后的数据接收完。&lt;br/&gt;[2]. 解码器内部会有缓冲机制，会缓存一定量的音频帧，不冲洗(flush)解码器的话，缓存帧是取不出来的，未冲洗(flush)解码器情况下，avcodec_receive_frame()返回AVERROR(EAGAIN)，表示解码器中改取的帧已取完了(当然缓存帧还是在的)，需要用avcodec_send_packet()向解码器提供新数据。&lt;br/&gt;[3]. 文件播放完毕时，应冲洗(flush)解码器。冲洗(flush)解码器的方法就是调用avcodec_send_packet(..., NULL)，然后按之前同样的方式多次调用avcodec_receive_frame()将缓存帧取尽。缓存帧取完后，avcodec_receive_frame()返回AVERROR_EOF。&lt;/p&gt;
&lt;h3 id=&quot;源码清单&quot;&gt;2.4 源码清单&lt;/h3&gt;
&lt;p&gt;代码已经变得挺长了，不贴完整源码了，源码参考：&lt;br/&gt;&lt;a href=&quot;https://github.com/leihl/leihl.github.io/blob/master/source/ffmpeg/player_audio/ffplayer.c&quot; class=&quot;uri&quot;&gt;https://github.com/leihl/leihl.github.io/blob/master/source/ffmpeg/player_audio/ffplayer.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码清单中涉及的一些概念简述如下：&lt;br/&gt;&lt;strong&gt;container:&lt;/strong&gt;&lt;br/&gt;对应数据结构AVFormatContext&lt;br/&gt;封装器，将流数据封装为指定格式的文件，文件格式如AVI、MP4等。&lt;br/&gt;FFmpeg可识别五种流类型：视频video(v)、音频audio(a)、attachment(t)、数据data(d)、字幕subtitle。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec:&lt;/strong&gt;&lt;br/&gt;对应数据结构AVCodec&lt;br/&gt;编解码器。编码器将未压缩的原始图像或音频数据编码为压缩数据。解码器与之相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec context&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVCodecContext&lt;br/&gt;编解码器上下文。此为非常重要的一个数据结构，后文分析。各API大量使用AVCodecContext来引用编解码器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec par&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVCodecParameters&lt;br/&gt;编解码器参数。新版本增加的字段。新版本建议使用AVStream-&amp;gt;codepar替代AVStream-&amp;gt;codec。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;packet&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVPacket&lt;br/&gt;经过编码的数据。通过av_read_frame()从媒体文件中获取得到的一个packet可能包含多个(整数个)音频帧或单个&lt;br/&gt;视频帧，或者其他类型的流数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;frame&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVFrame&lt;br/&gt;解码后的原始数据。解码器将packet解码后生成frame。&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;2.3 编译&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;gcc -o ffplayer ffplayer.c -lavutil -lavformat -lavcodec -lavutil -lswscale -lSDL2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;2.4 测试&lt;/h3&gt;
&lt;p&gt;选用clock_320.avi测试文件，此文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ffprobe clock_320.avi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印视频文件信息如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[avi @ 0x9286c0] non-interleaved AVI
Input #0, avi, from 'clock_320.avi':
  Duration: 00:00:12.00, start: 0.000000, bitrate: 42 kb/s
    Stream #0:0: Video: msrle ([1][0][0][0] / 0x0001), pal8, 320x320, 1 fps, 1 tbr, 1 tbn, 1 tbc
    Stream #0:1: Audio: truespeech ([34][0][0][0] / 0x0022), 8000 Hz, mono, s16, 8 kb/s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./ffplayer clock_320.avi &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以听到每隔1秒播放一次“嘀”声，播放12次后播放结束。播放过程只有声音，没有图像窗口。播放正常。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;3. 参考资料&lt;/h2&gt;
&lt;p&gt;[1] 雷霄骅，&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;视音频编解码技术零基础学习方法&lt;/a&gt;&lt;br/&gt;[2] 雷霄骅，&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;最简单的基于FFMPEG+SDL的视频播放器ver2(采用SDL2.0)&lt;/a&gt;&lt;br/&gt;[3] SDL WIKI, &lt;a href=&quot;https://wiki.libsdl.org/&quot; class=&quot;uri&quot;&gt;https://wiki.libsdl.org/&lt;/a&gt;&lt;br/&gt;[4] Martin Bohme, &lt;a href=&quot;http://dranger.com/ffmpeg/ffmpegtutorial_all.html#tutorial03.html&quot;&gt;An ffmpeg and SDL Tutorial, Tutorial 03: Playing Sound&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改记录&quot;&gt;4. 修改记录&lt;/h2&gt;
&lt;p&gt;2018-12-04 V1.0 初稿&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 16:15:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>基于FFmpeg和SDL实现的简易视频播放器，主要分为读取视频文件解码和调用SDL显示两大部分。详细流程可参考代码注释。 本篇实验笔记主要参考如下两篇文章：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leisure_chn/p/10068490.html</dc:identifier>
</item>
<item>
<title>环境搭建文档——Windows下的Python3环境搭建 - dremeue</title>
<link>http://www.cnblogs.com/fengzongming/p/10068454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengzongming/p/10068454.html</guid>
<description>&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;背景介绍:&lt;/strong&gt; 自己用Python开发了一些安卓性能自动化测试的脚本, 但是想要运行这些脚本的话, 本地需要Python的环境.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　 测试组的同事基本都没有安装Python环境, 于是乎, 我就想直接在网上找一篇Python环境搭建的文章, 但是没有找到让我觉得简洁又满意的搭建文档,&lt;/span&gt;&lt;span&gt;所以我就直接用虚拟机的环境去记录一次Python环境的搭建文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;说明:&lt;/strong&gt; 此次搭建的是Windows下的Python3的环境, Python2的环境应该也可以参照这篇文章(建议大家使用Python3的环境, Python3应该是以后的主流版本)&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1. 下载Python3的安装包&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1). 访问python官网的下载页面 https://www.python.org/downloads/, 选择Python3的下载版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　 (这里我们可以直接下载最新版本, 这里最新版本是Python3.7.1, 所以我们就直接下载Python3.7.1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204232955611-892808541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　2). 版本确定后, 我们需要选择具体的安装包, 这里我们选择的是 &lt;a href=&quot;https://www.python.org/ftp/python/3.7.1/python-3.7.1-amd64.exe&quot;&gt;Windows x86-64 executable installer&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204233416674-533662664.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　3). 下载完成后, 我们会得到一个.exe的安装包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204233721597-197850975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2. 安装Python&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1). 双击安装包, 开始安装Python环境&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　a. 勾选&quot;Add Python 3.7 to PATH&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　b. 选择自定义安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204234232280-1579331717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　2). 直接下一步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204234255823-1813024069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　3). 安装选择&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　a. 勾选上&quot;Install for all users&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　b. 修改安装位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204234735623-437260979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;4). 等待安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204235129415-1524430407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　5). 安装成功后, 点击关闭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204235300455-43472080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3. 检验Python环境安装是否成功&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1). 启动一个命令行窗口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2). 直接在命令行中输入python&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3). 输入完成后, 如果大家可以看到Python的版本号, 则说明python环境安装成功, 恭喜你啦~!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254651/201812/1254651-20181204235602173-180705992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 04 Dec 2018 16:01:00 +0000</pubDate>
<dc:creator>dremeue</dc:creator>
<og:description>前言 背景介绍: 自己用Python开发了一些安卓性能自动化测试的脚本, 但是想要运行这些脚本的话, 本地需要Python的环境. 测试组的同事基本都没有安装Python环境, 于是乎, 我就想直接在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengzongming/p/10068454.html</dc:identifier>
</item>
<item>
<title>Java的JNI - Mr.Bit</title>
<link>http://www.cnblogs.com/zhizaixingzou/p/10068405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhizaixingzou/p/10068405.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540149/201812/1540149-20181204234312581-1236652208.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;1.1. &lt;strong&gt;JNI&lt;span&gt;技术的使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java Native Interface&lt;span&gt;（&lt;/span&gt;&lt;span&gt;JNI&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;Java&lt;span&gt;本地接口）是&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言的本地编程接口&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;java&lt;span&gt;程序中，我们可以通过&lt;/span&gt;&lt;span&gt;JNI&lt;/span&gt;&lt;span&gt;实现一些用&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;语言不便实现的功能&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;如下&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;标准的&lt;/span&gt;java&lt;span&gt;类库没有提供你的应用程序所需要的功能，通常这些&lt;/span&gt;&lt;span&gt;功能是平台相关的&lt;/span&gt;&lt;span&gt;（只能由其他语言编写）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;你希望&lt;/span&gt;&lt;span&gt;使用一些已经有的类库&lt;/span&gt;&lt;span&gt;或者应用程序，而&lt;/span&gt;&lt;span&gt;他们并非用&lt;/span&gt;java&lt;span&gt;语言编写的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;程序的某些部分&lt;/span&gt;&lt;span&gt;对速度要求比较苛刻&lt;/span&gt;&lt;span&gt;，你&lt;/span&gt;&lt;span&gt;选择用汇编或者&lt;/span&gt;c&lt;span&gt;语言来实现并在&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;语言中调用他们&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）&lt;/span&gt;&lt;span&gt;为了应用的安全性，会将一些&lt;/span&gt;&lt;span&gt;复杂的逻辑和算法通过本地代码（&lt;/span&gt;C&lt;span&gt;或&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;）来实现&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;本地代码比字节码难以破解&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;不到万不得已不要使用&lt;/span&gt;JNI&lt;span&gt;技术&lt;/span&gt;&lt;span&gt;，一方面它&lt;/span&gt;&lt;span&gt;需要你掌握更多的知识才可以驾驭&lt;/span&gt;&lt;span&gt;，一方面&lt;/span&gt;&lt;span&gt;使用了&lt;/span&gt;JNI&lt;span&gt;你的程序就会丧失可移植性&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;C/C++&lt;span&gt;是非跨平台的）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.2. &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;JNI&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/xyang81/article/details/41777471&quot;&gt;&lt;span&gt;http://blog.csdn.net/xyang81/article/details/41777471&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;编写&lt;/span&gt;java&lt;span&gt;代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在硬盘上建立一个&lt;/span&gt;hello&lt;span&gt;目录作为我们的工作目录，首先我们需要&lt;/span&gt;&lt;span&gt;编写自己的&lt;/span&gt;java&lt;span&gt;代码，在&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;代码中我们会声明&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;方法，代码非常简单&lt;/span&gt;&lt;span&gt;（称为&lt;/span&gt;JNI&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;它实现的&lt;/span&gt;JNI&lt;span&gt;规范&lt;/span&gt;&lt;span&gt;，是&lt;/span&gt;JVM&lt;span&gt;规范的一部分，所以可以运行于&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;。如下所示&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;class HelloWorld&lt;br/&gt;{&lt;br/&gt;    public native void displayHelloWorld();&lt;br/&gt;    static {&lt;br/&gt;        System.loadLibrary(&quot;hello&quot;);&lt;br/&gt;    }&lt;br/&gt;   &lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        new HelloWorld().displayHelloWorld();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;注意我们的&lt;/span&gt;displayHelloWorld()&lt;span&gt;方法的声明，它有一个关键字&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;，表明这个方法使用&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;以外的语言实现。方法不包括实现，因为我们要用&lt;/span&gt;&lt;span&gt;c/c++&lt;/span&gt;&lt;span&gt;语言实现它。注意&lt;/span&gt;System.loadLibrary(&quot;hello&quot;)&lt;span&gt;这句代码，它是在静态初始化块中定义的，系统用来装载&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;库，这就是我们在后面生成的&lt;/span&gt;&lt;span&gt;hello.dll&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;System.loadLibrary(&quot;HelloWorld&quot;);  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要指定动态库的名字即可，不需要加&lt;/span&gt;lib&lt;span&gt;前缀，也不要加&lt;/span&gt;&lt;span&gt;.so&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;.dll&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;.jnilib&lt;/span&gt;&lt;span&gt;后缀&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;java&lt;span&gt;会去&lt;/span&gt;&lt;span&gt;java.library.path&lt;/span&gt;&lt;span&gt;系统属性指定的目录下查找动态库文件，如果没有找到会抛出&lt;/span&gt;&lt;span&gt;java.lang.UnsatisfiedLinkError&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540149/201812/1540149-20181204234208593-315174217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;System.load(&quot;/Users/yangxin/Desktop/libHelloWorld.jnilib&quot;);  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;指定动态库的绝对路径名，需要加上前缀和后缀&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2）&lt;span&gt;创建&lt;/span&gt;.h&lt;span&gt;文件&lt;/span&gt;&lt;br/&gt;javac HelloWorld.java&lt;span&gt;，&lt;/span&gt;&lt;span&gt;生成&lt;/span&gt;HelloWorld.class&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;javah HelloWorld&lt;span&gt;。这样我们可以看到在相同目录下生成了一个&lt;/span&gt;&lt;span&gt;HelloWorld.h&lt;/span&gt;&lt;span&gt;文件，文件内容如下&lt;/span&gt;&lt;span&gt;：&lt;/span&gt; &lt;br/&gt;/* DO NOT EDIT THIS FILE - it is machine generated */&lt;br/&gt;#include &amp;lt;jni.h&amp;gt;&lt;br/&gt;/* Header for class HelloWorld */&lt;br/&gt;#ifndef _Included_HelloWorld&lt;br/&gt;#define _Included_HelloWorld&lt;br/&gt;#ifdef __cplusplus&lt;br/&gt;extern &quot;C&quot; {&lt;br/&gt;#endif&lt;br/&gt;/*&lt;br/&gt; * Class:     HelloWorld&lt;br/&gt; * Method:    displayHelloWorld&lt;br/&gt; * Signature: ()V&lt;br/&gt; */&lt;br/&gt;JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld&lt;br/&gt;  (JNIEnv *, jobject);&lt;br/&gt;#ifdef __cplusplus&lt;br/&gt;}&lt;br/&gt;#endif&lt;br/&gt;#endif&lt;/p&gt;

&lt;p&gt;3）&lt;span&gt;编写本地实现代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在这部分我们要用&lt;/span&gt;C/C++&lt;span&gt;语言实现&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;中定义的方法&lt;/span&gt;&lt;span&gt;，我们在&lt;/span&gt;VC++&lt;span&gt;中新建一个&lt;/span&gt;&lt;span&gt;Project,&lt;/span&gt;&lt;span&gt;然后创建一个&lt;/span&gt;HelloWorldImpl.cpp&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;，内容如下&lt;/span&gt;&lt;br/&gt;#include &amp;lt;jni.h&amp;gt;&lt;br/&gt;#include &quot;HelloWorld.h&quot;&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;&lt;p&gt;JNIEXPORT void JNICALL&lt;br/&gt;Java_HelloWorld_displayHelloWorld(JNIEnv *env, jobject obj)&lt;br/&gt;{&lt;br/&gt;    printf(&quot;Hello world!/n&quot;);&lt;br/&gt;    return;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;注意我们这里&lt;/span&gt;include&lt;span&gt;了&lt;/span&gt; &lt;span&gt;jni.h&lt;/span&gt;&lt;span&gt;和刚才得到的&lt;/span&gt;&lt;span&gt;HelloWorld.h&lt;/span&gt;&lt;span&gt;文件。因此你要在&lt;/span&gt;&lt;span&gt;VC++&lt;/span&gt;&lt;span&gt;里面设置好，&lt;/span&gt;jni.h&lt;span&gt;在&lt;/span&gt;&lt;span&gt;JAVA_HOME/include&lt;/span&gt;&lt;span&gt;里面&lt;/span&gt;&lt;span&gt;。编译通过后再&lt;/span&gt;&lt;span&gt;生成&lt;/span&gt;hello.dll&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;4&lt;span&gt;）&lt;/span&gt;&lt;span&gt;运行&lt;/span&gt;java&lt;span&gt;程序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;把上面生成的&lt;/span&gt;hello.dll&lt;span&gt;文件复制到我们的工作目录，这时候我们的目录中包括&lt;/span&gt;&lt;span&gt;HelloWorld.java&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;HelloWorld.class&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;hello.dll&lt;/span&gt;&lt;span&gt;文件。运行&lt;/span&gt;&lt;span&gt;java HelloWorld&lt;/span&gt;&lt;span&gt;命令，则可在控制台看到&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;!&lt;span&gt;的输出了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.3. &lt;strong&gt;JNI&lt;span&gt;技术使用总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JNI&lt;span&gt;开发流程主要分为以下&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、编写声明了&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;方法的&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、将&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;源代码编译成&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;字节码文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、用&lt;/span&gt;&lt;span&gt;javah -jni&lt;/span&gt;&lt;span&gt;命令生成&lt;/span&gt;&lt;span&gt;.h&lt;/span&gt;&lt;span&gt;头文件（&lt;/span&gt;&lt;span&gt;javah&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;自带的一个命令，&lt;/span&gt;&lt;span&gt;-jni&lt;/span&gt;&lt;span&gt;参数表示将&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;中用&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;声明的函数生成&lt;/span&gt;&lt;span&gt;jni&lt;/span&gt;&lt;span&gt;规则的函数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;、用本地代码实现&lt;/span&gt;&lt;span&gt;.h&lt;/span&gt;&lt;span&gt;头文件中的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5&lt;span&gt;、将本地代码编译成动态库（&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;*.dll&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;linux/unix&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;*.so&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;mac os x&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;*.jnilib&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6&lt;span&gt;、拷贝动态库至&lt;/span&gt;&lt;span&gt; java.library.path&lt;/span&gt; &lt;span&gt;本地库搜索目录下，并运行&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.4. &lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/xyang81/article/details/41777471&quot;&gt;&lt;span&gt;http://blog.csdn.net/xyang81/article/details/41777471&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/mingjava/article/details/180946&quot;&gt;http://blog.csdn.net/mingjava/article/details/180946&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 15:44:00 +0000</pubDate>
<dc:creator>Mr.Bit</dc:creator>
<og:description>目录 1. JNI 1.1. JNI技术的使用场景 Java Native Interface（JNI，Java本地接口）是Java语言的本地编程接口。在java程序中，我们可以通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhizaixingzou/p/10068405.html</dc:identifier>
</item>
<item>
<title>ES6系列_10之Symbol在对象中的作用 - 吴封斌技术博客</title>
<link>http://www.cnblogs.com/bfwbfw/p/10068369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/10068369.html</guid>
<description>&lt;p&gt;在ES5中 对象属性名都是字符串，这容易造成属性名的冲突，比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突，于是 ES6 引入了&lt;code&gt;Symbol。Symbol是一种新的原始数据类型，表示独一无二的值。它是继&lt;/code&gt;undefined、&lt;code&gt;null&lt;/code&gt;、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）六种数据类型之后的第七种数据类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.声明Symbol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt;函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f= Symbol();//&lt;code class=&quot; language-javascript&quot;/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f= Symbol('foo');//&lt;code class=&quot; language-javascript&quot;/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有参数的情况&lt;/span&gt;
let s1 =&lt;span&gt; Symbol();
let s2 &lt;/span&gt;=&lt;span&gt; Symbol();

s1 &lt;/span&gt;=== s2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有参数的情况&lt;/span&gt;
let s1 = Symbol('foo'&lt;span&gt;);
let s2 &lt;/span&gt;= Symbol('foo'&lt;span&gt;);

s1 &lt;/span&gt;=== s2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，&lt;code&gt;Symbol&lt;/code&gt;函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的&lt;code&gt;Symbol&lt;/code&gt;函数的返回值是不相等的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s1&lt;/code&gt;和&lt;code&gt;s2&lt;/code&gt;都是&lt;code&gt;Symbol&lt;/code&gt;函数的返回值，而且参数相同，但是它们是不相等的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Symbol在对象中的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;作为属性名的-Symbol&quot; class=&quot;作为属性名的-Symbol&quot;&gt;&lt;strong&gt;Symbol&lt;/strong&gt;作为属性名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let mySymbol =&lt;span&gt; Symbol();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种写法&lt;/span&gt;
let a =&lt;span&gt; {};
a[mySymbol] &lt;/span&gt;= 'Hello!'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种写法&lt;/span&gt;
let a =&lt;span&gt; {
  [mySymbol]: &lt;/span&gt;'Hello!'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三种写法&lt;/span&gt;
let a =&lt;span&gt; {};
Object.defineProperty(a, mySymbol, { value: &lt;/span&gt;'Hello!'&lt;span&gt; });

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以上写法都得到同样结果&lt;/span&gt;
a[mySymbol] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;Hello!&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;赋值-括号形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
a[mySymbol]='web';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.Symbol对象元素的保护作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。&lt;/p&gt;
&lt;p&gt;没有进行保护的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj={name:'小明',skill:'web',age:18&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
    console.log(obj[item]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我不想别人知道我的年龄，这时候我就可以使用Symbol来进行循环保护。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let obj={name:'小明',skill:'web'&lt;span&gt;};
let age&lt;/span&gt;=&lt;span&gt;Symbol();
obj[age]&lt;/span&gt;=18&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
    console.log(obj[item]);//小明、web
} 
console.log(obj[age]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 待续.....&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>吴封斌技术博客</dc:creator>
<og:description>在ES5中 对象属性名都是字符串，这容易造成属性名的冲突，比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突，于是 E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/10068369.html</dc:identifier>
</item>
<item>
<title>HTML5和CSS3的新特性 - linwene</title>
<link>http://www.cnblogs.com/linwene/p/10068290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linwene/p/10068290.html</guid>
<description>&lt;h2 id=&quot;html5的新特性&quot;&gt;html5的新特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;添加了用于媒介回放的 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 元素&lt;/li&gt;
&lt;li&gt;添加了语义标签譬如 &lt;code&gt;header&lt;/code&gt;、&lt;code&gt;footer&lt;/code&gt;、&lt;code&gt;nav&lt;/code&gt; 等等元素&lt;/li&gt;
&lt;li&gt;添加了用于绘画的 canvas 元素和svg绘图&lt;/li&gt;
&lt;li&gt;扩充了input的输入类型，如下&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;主要用于选取颜色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;从一个日期选择器选择一个日期&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;选择一个日期（UTC 时间）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;datetime-local&lt;/td&gt;
&lt;td&gt;选择一个日期和时间 (无时区)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;email&lt;/td&gt;
&lt;td&gt;包含 e-mail 地址的输入域&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;month&lt;/td&gt;
&lt;td&gt;选择一个月份&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;数值的输入域&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;一定范围内数字值的输入域&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;search&lt;/td&gt;
&lt;td&gt;用于搜索域&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;tel&lt;/td&gt;
&lt;td&gt;定义输入电话号码字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;time&lt;/td&gt;
&lt;td&gt;选择一个时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;URL 地址的输入域&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;week&lt;/td&gt;
&lt;td&gt;选择周和年&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;添加了地理位置定位功能Geolocation（地理定位）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;window.navigator.geolocation {
    getCurrentPosition:  fn  用于获取当前的位置数据
    watchPosition: fn  监视用户位置的改变
    clearWatch: fn  清除定位监视
}　&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是获取用户定位信息示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;navigator.geolocation.getCurrentPosition(
    function(pos){
　　　　console.log('用户定位数据获取成功')
      　　　　//console.log(arguments);
      　　　　console.log('定位时间：',pos.timestamp)
      　　　　console.log('经度：',pos.coords.longitude)
      　　　　console.log('纬度：',pos.coords.latitude)
      　　　　console.log('海拔：',pos.coords.altitude)
      　　　　console.log('速度：',pos.coords.speed)
},    //定位成功的回调
function(err){ 
 　　　　console.log('用户定位数据获取失败')
      　　　　//console.log(arguments);
}        //定位失败的回调
)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.49497767857143&quot;&gt;&lt;li&gt;添加了web存储功能，&lt;code&gt;localStorage&lt;/code&gt;和&lt;code&gt;sessionStorage&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;1.4673913043478&quot;&gt;
&lt;p&gt;使用 HTML5，通过创建&lt;code&gt;cache manifest&lt;/code&gt;文件，可以轻松地创建 web 应用的离线版本&lt;/p&gt;
&lt;blockquote readability=&quot;7.7721518987342&quot;&gt;
&lt;p&gt;manifest 文件可分为三个部分：&lt;br/&gt;&lt;em&gt;CACHE MANIFEST&lt;/em&gt; - 在此标题下列出的文件将在首次下载后进行缓存&lt;br/&gt;&lt;em&gt;NETWORK&lt;/em&gt; - 在此标题下列出的文件需要与&lt;a href=&quot;https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pc_csdn&quot;&gt;服务器&lt;/a&gt;的连接，且不会被缓存&lt;br/&gt;&lt;em&gt;FALLBACK&lt;/em&gt; - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;web worker&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行（相当于实现多线程并发）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务端事件推送，所有主流浏览器均支持服务器发送事件，除了 Internet Explorer&lt;br/&gt;EventSource 对象用于接收服务器发送事件通知：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var source=newEventSource(&quot;demo_sse.php&quot;);
source.onmessage=function(event)
{
document.getElementById(&quot;result&quot;).innerHTML+=event.data +&quot;&amp;lt;br&amp;gt;&quot;;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让上面的例子可以运行，您还需要能够发送数据更新的服务器（比如 PHP 和 ASP）。&lt;/p&gt;
&lt;pre class=&quot;&amp;lt;?php&quot;&gt;
&lt;code&gt;header('Content-Type: text/event-stream');
header('Cache-Control: no-cache');
$time = date('r');
echo &quot;data: The server time is: {$time}nn&quot;;
flush();
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;css3的新特性&quot;&gt;CSS3的新特性&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;媒体查询&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。清单 1 展示了一个示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;清单 1. 使用媒体类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;site.css&quot;media=&quot;screen&quot;/&amp;gt;
&amp;lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;print.css&quot;media=&quot;print&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清单 2. 媒体查询规则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@media all and(min-width:800px){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。&lt;br/&gt;(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。&lt;/p&gt;
&lt;p&gt;清单 3. and 条件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@media(min-width:800px)and(max-width:1200px)and(orientation:portrait){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清单 4. or 关键词&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@media(min-width:800px)or(orientation:portrait){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清单 5. 使用 not&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@media(not min-width:800px){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;选择器&lt;/li&gt;
&lt;li&gt;transform，transition，translate,scale,skelw，rotate等相关动画效果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;div
{
transition-property: width;
transition-duration:1s;
transition-timing-function: linear;
transition-delay:2s;
/* Safari */
-webkit-transition-property:width;
-webkit-transition-duration:1s;
-webkit-transition-timing-function:linear;
-webkit-transition-delay:2s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;box-shadow,text-shadow等特效&lt;/li&gt;
&lt;li&gt;添加了border-radius，border-image等属性&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.4587628865979&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.5789473684211&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.runoob.com/cssref/css3-pr-border-image.html&quot;&gt;border-image&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;设置所有边框图像的速记属性。&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;1.6867469879518&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.runoob.com/cssref/css3-pr-border-radius.html&quot;&gt;border-radius&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一个用于设置所有四个边框- *-半径属性的速记属性&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.6153846153846&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.runoob.com/cssref/css3-pr-box-shadow.html&quot;&gt;box-shadow&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;附加一个或多个下拉框的阴影&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 04 Dec 2018 15:15:00 +0000</pubDate>
<dc:creator>linwene</dc:creator>
<og:description>html5的新特性 添加了用于媒介回放的 元素 添加了语义标签譬如 、`footer nav` 等等元素 添加了用于绘画的 canvas 元素和svg绘图 扩充了input的输入类型，如下 输入类型|</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linwene/p/10068290.html</dc:identifier>
</item>
<item>
<title>基于sentry的前端错误监控日志系统(部署sentry服务器/前端项目部署)-让前端最快的定位到生产问题 - 小结巴巴吧</title>
<link>http://www.cnblogs.com/jiebba/p/10049938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiebba/p/10049938.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;　　在这越来越发达的网络时代，web应用也是越来越复杂，尤其是前端的开发，也是越来越受重视。&lt;/p&gt;
&lt;p&gt;　　所以在我们前端开发完成后，会有一些列的web应用的上线验证，如自测、QA测试、code review 等，以确保&lt;/p&gt;
&lt;p&gt;应用能在生产上没有事故。&lt;/p&gt;
&lt;p&gt;　　但是事以愿违，很多时候我们都会接受的客户的一些线上问题，这些问题有时候可能你是自己开发的原因本身存&lt;/p&gt;
&lt;p&gt;在的问题，这样的问题一般能够在测试环境重现，我们很快的能定位到问题关键位置。但是，很多时候有一些问题，&lt;/p&gt;
&lt;p&gt;我们在测试中并未发现，可是在线上却有部分人出现了，问题确确实实存在的，这个时候我们测试环境又不能重现，&lt;/p&gt;
&lt;p&gt;还有一些偶现的生产的偶现问题，这些都是难以定位到问题的原因，让我们前端工程师头疼不已。&lt;/p&gt;
&lt;p&gt;　　这时候，我们不得不借助一些功能来解决这一些列的头疼问题。&lt;/p&gt;

&lt;h4&gt;　　前端错误监控日志系统　　&lt;/h4&gt;
&lt;p&gt;　　当前端代码在生产运行中出现错误的时候，第一时间传递给监控系统，从而第一时间定位并且解决问题。&lt;/p&gt;
&lt;p&gt;　　保证前端代码的稳定和安全，是项目可以健康的运行。&lt;/p&gt;

&lt;h2&gt;监控系统搭建方案&lt;/h2&gt;

&lt;p&gt;　　1、自行可以规划定义一套完善的监控系统。需要人力重新开发&lt;/p&gt;
&lt;p&gt;　　2、借助第三方插件( 阿里ARMS、fundebug、BadJS，sentry 等 )&lt;/p&gt;
&lt;p&gt;　　阿里ARMS ：是阿里的一个前端数据监控的服务，似乎是收费的&lt;/p&gt;
&lt;p&gt;　　fundebug ：挺完善的前端错误日志服务，也是收费的&lt;/p&gt;
&lt;p&gt;　　BadJS ：腾讯团队的一个开源项目，没看过，应该很不错的&lt;/p&gt;
&lt;p&gt;　　sentry ：github 上面的一个开源项目，支持各端的错误监控 ( 本文就是基于 sentry 搭建的错误监控系统 )&lt;/p&gt;

&lt;h2&gt;系统的搭建与使用&lt;/h2&gt;

&lt;h3&gt;　　sentry 简介&lt;/h3&gt;
&lt;p&gt;　　sentry 是一个开源的实时错误监控的项目，它支持很多端的配置，包括 web 前端、服务器端、移动端及其游戏端。&lt;/p&gt;
&lt;p&gt;支持各种语言，例如 python、oc、java、node、javascript 等。也可以应用到各种不同的框架上面，如前端框架中的&lt;/p&gt;
&lt;p&gt;vue 、angular 、react 等最流行的前端框架。&lt;/p&gt;
&lt;p&gt;　　提供了github、slack、trello 的常见的开发工具的集成。可以自己安装并且搭建 sentry 应用。&lt;/p&gt;

&lt;p&gt;支持的语言：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201214518931-2073144099.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;　　sentry 的部署&lt;/h3&gt;
&lt;p&gt;　　官网提供了两种部署方案：&lt;/p&gt;
&lt;p&gt;　　docker&lt;/p&gt;
&lt;p&gt;　　python&lt;/p&gt;
&lt;p&gt;　　docker 是我第一次使用，看了下文档，感觉挺容易明白。&lt;/p&gt;
&lt;p&gt;　　在这里为了操作方便考虑，我们选择使用docker来部署搭建 sentry。&lt;/p&gt;
&lt;p&gt;　　这种方法的话需要安装 docker 和 docker - compose 。&lt;/p&gt;

&lt;h3&gt;1、docker 的部署 (mac版)&lt;/h3&gt;
&lt;p&gt;　　安装的话，可以直接去看看 docker 安装文档&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.runoob.com/docker/macos-docker-install.html&quot; target=&quot;_blank&quot;&gt;docker 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　mac 版的安装，docker-compose 已经一起安装好了。&lt;/p&gt;

&lt;h3&gt;2、部署 sentry&lt;/h3&gt;
&lt;h4&gt;　　获取 sentry 代码&lt;/h4&gt;
&lt;p&gt;　　从 github 上面可以获取到最新的 sentry 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
git clone https://github.com/getsentry/onpremise.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取到本地之后，进入项目的目录。&lt;/p&gt;
&lt;p&gt;　　按照项目的 readme.md 开始依照步骤搭建。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
docker-compose run --rm web config generate-secret-key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里是生产密钥，SENTRY_SECRET_KEY 这个需要添加到 docker-compose.yml 中。&lt;/p&gt;

&lt;p&gt;　　最后一步：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　至此，我们监控系统的后端服务器已经跑起来了，访问本地的9000端口。&lt;/p&gt;
&lt;p&gt;　　使用中途创建的 邮箱和密码登陆 我们的服务后端。&lt;/p&gt;


&lt;h3&gt;3、创建项目&lt;/h3&gt;
&lt;p&gt;　　登陆后我们会进入我们的监控项目的界面，如：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201221820666-777264825.png&quot; alt=&quot;&quot; width=&quot;896&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点击右上角的  add new project ，我们可以创建一个新的项目&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201221957556-1359107585.png&quot; alt=&quot;&quot; width=&quot;903&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里可以选择项目的配置，语言以及框架，选择自己的项目类型&lt;/p&gt;
&lt;p&gt;　　输入项目名称，点击 create project 。确定创建新项目。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201222256321-1065704305.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　点击红框框的，创建一个简单的日志。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201222441227-1202025170.png&quot; alt=&quot;&quot; width=&quot;1083&quot; height=&quot;526&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　错误信息页面，可以自行到官网上面去了解更多信息。&lt;/p&gt;


&lt;h3&gt;4、前端部署，注入监控代码 &lt;/h3&gt;

&lt;h4&gt;　　获取项目的链接：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201222948994-569865814.png&quot; alt=&quot;&quot; width=&quot;883&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在项目的首页点击 install 会进入当前图示页面&lt;/p&gt;
&lt;p&gt;　　我们复制 sentry DSN 到我们前端配置中&lt;/p&gt;

&lt;h4&gt;　　引用 sentry ，注入配置到我们的应用中：&lt;/h4&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181201222812448-834895737.png&quot; alt=&quot;&quot; width=&quot;922&quot; height=&quot;953&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　这里是以 react 为例，我们在 react 的根组建的 componentDidCatch 上面捕获错误，并且上传到我们监控系统中。&lt;/p&gt;
&lt;p&gt;　　这里的我们用 sentry DSN 配置我们的 sentry 并且初始化 sentry 项目。&lt;/p&gt;

&lt;h4&gt;　　到这里我们基本，已经完成了我们的前端错误监控日志系统了。&lt;/h4&gt;


&lt;h2&gt;sentry 操作界面介绍&lt;/h2&gt;

&lt;p&gt;　　项目操作页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203153324477-1905999066.png&quot; alt=&quot;&quot; width=&quot;1220&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1、项目的查看选项&lt;/p&gt;
&lt;p&gt;　　Issue ： 问题列表&lt;/p&gt;
&lt;p&gt;　　overview ： 概况纵览&lt;/p&gt;
&lt;p&gt;　　userfeedback ： 用户反馈&lt;/p&gt;
&lt;p&gt;　　Resleases ： 版本列表信息&lt;/p&gt;
&lt;p&gt;　　setting ： 项目设置&lt;/p&gt;

&lt;p&gt;　　2、问题筛选&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203153636266-1419518618.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　包括 ： 指派自己的 、 标记列表 、需要分类的 、 今天的 、 未处理的&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203153859973-611073663.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;78&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　设置为 解决 、 忽略 、 合并 、标记 、实时监控&lt;/p&gt;







&lt;h2&gt;sentry 的api介绍和使用&lt;/h2&gt;

&lt;h3&gt;　　1、javascript SDK 引用与配置&lt;/h3&gt;

&lt;p&gt;　　现在有两种方法引用 sentry SDK :&lt;/p&gt;

&lt;h4&gt;　　直接引用：&lt;/h4&gt;
&lt;p&gt;　　最快的方法就是通过 script 标签引用我们的 sdk &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script src=&quot;https://browser.sentry-cdn.com/4.4.1/bundle.min.js&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　然后就是配置了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.init({ dsn: 'https://&amp;lt;key&amp;gt;@sentry.io/&amp;lt;project&amp;gt;' });
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　npm 包引用：&lt;/h4&gt;
&lt;p&gt;　　首先是用添加包 @sentry/browser@4.4.1&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
yarn add @sentry/browser@4.4.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　引用到项目中，并且配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import * as Sentry from '@sentry/browser';

Sentry.init({ dsn: 'https://&amp;lt;key&amp;gt;@sentry.io/&amp;lt;project&amp;gt;' });
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;　　2、捕获事件&lt;/h3&gt;

&lt;h4&gt;　　主动捕获错误或者异常&lt;/h4&gt;
&lt;p&gt;　　sentry 常见的是错误捕获，可以根据平台的不同来捕获错误，并且可以传递不同的错误信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
try {
    aFunctionThatMightFail();
} catch (err) {
    Sentry.captureException(err);
}&lt;br/&gt;Sentry.captureException(new Error('test'))
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;　　捕获消息&lt;/h4&gt;
&lt;p&gt;　　另一种常见操作是捕获裸信息。消息只是应该发送给Sentry的一些文本信息。　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.captureMessage('Something went wrong');
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;　　3、初始化配置&lt;/h3&gt;

&lt;p&gt;　　sentry SDK 可以通过很多方式进行配置。&lt;/p&gt;
&lt;p&gt;　　主要配置初始化配置的函数为 init() 方法，通过向 init() 方法传递参数对象;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.init({
  dsn: 'https://&amp;lt;key&amp;gt;@sentry.io/&amp;lt;project&amp;gt;',
  maxBreadcrumbs: 50,
  debug: true,
})
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　常用参数：&lt;/h4&gt;
&lt;p&gt;　　DSN ：项目的地址，用于收集错误信息的 sentry 分配的地址&lt;/p&gt;
&lt;p&gt;　　debug ：是否开启 debug 模式，开启debug，就会把信息打印到控制台上面&lt;/p&gt;
&lt;h4&gt;　　release ： 代码的版本号&lt;/h4&gt;
&lt;p&gt;　　　　release 版本号，可以确定当前的错误/异常属于哪一个发布的版本&lt;/p&gt;
&lt;p&gt;　　　　可以应用到  sourcemaps 来映射源码&lt;/p&gt;
&lt;p&gt;　　environment : 环境名称&lt;/p&gt;
&lt;p&gt;　　sampleRate : 是否开启随机发送事件给 sentry ，1为100%，0.1 为 10%几率发送事件&lt;/p&gt;
&lt;p&gt;　　attachStacktrace ： 是否开启堆栈跟踪，开启后跟着消息一起收集&lt;/p&gt;
&lt;p&gt;　　beforeSend : 发送前操作&lt;/p&gt;

&lt;h3&gt;　　4、sentry 的api&lt;/h3&gt;

&lt;p&gt;　　captureException(exception) : 捕获一个 js 异常，传入一个 exception 对象或者类对象。&lt;/p&gt;
&lt;p&gt;　　captureMessage(message,level) : 捕获一条信息，传入信息内容和信息级别&lt;/p&gt;
&lt;p&gt;　　captureEvent(sentryEvent) : 捕获一个事件，sentryEvent 是手动创建的，自定义的&lt;/p&gt;
&lt;p&gt;　　addBreadcrumb(Breadcrumb) ： 添加一个面包屑，以供接下里的捕获&lt;/p&gt;
&lt;p&gt;　　configureScope((scope)=&amp;gt;{}) : 设置 context 信息到 scope 上面&lt;/p&gt;
&lt;p&gt;　　withScope((scope)=&amp;gt;{}) : 设置一个零时的 scope 信息到 context 上面&lt;/p&gt;

&lt;h3&gt;　　5、context 上下文信息&lt;/h3&gt;

&lt;p&gt;　　上下文信息包括 ：user 、 tags 、 level 、fingerprint 、 extra data&lt;/p&gt;
&lt;p&gt;　　这些信息我们可以通过在 scope 上面设置来定义。&lt;/p&gt;
&lt;p&gt;　　其中可以通过两种方法得到 scope 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 将 scope 配置到 context 上面
Sentry.configureScope((scope) =&amp;gt; { }); &lt;br/&gt;// 创建一个零时到 scope ，配置到 context 上面
Sentry.withScope((scope) =&amp;gt; { });
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;　　User&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 scope.setUser({
        id:'1',
        username:'xiao',
        ip_address:'127.0.0.1',
        email: 'test.doe@example.com' ,
      });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过 setUser 来设置 User 信息。&lt;/p&gt;
&lt;p&gt;　　其中 user 可以设置的信息包括 id 、 username 、 ip_address 、email&lt;/p&gt;

&lt;h3&gt;　　Tags&lt;/h3&gt;
&lt;p&gt; 　　tags 是给事件定义不同的键/值对，可以在查找的时候更容易。&lt;/p&gt;
&lt;p&gt;　　 后台查找的时候，查找选项会多出来一个选项，就是通过 tags 来设置的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
scope.setTag(&quot;page_local&quot;, &quot;de-at&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过 setTag 来设置了一个page_local 的标签。&lt;/p&gt;
&lt;p&gt;　　后台会多一个 page_local 选项。包括 de-at&lt;/p&gt;

&lt;h3&gt;　　level&lt;/h3&gt;
&lt;p&gt;　　通过这个来设置事件的严重性。&lt;/p&gt;
&lt;p&gt;　　包括：fatal 、error 、 warning 、 info 、 debug 。( fatal : 严重，error 错误，error 为默认 )&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
scope.setLevel('warning');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过 setLevel 来设置。&lt;/p&gt;

&lt;h3&gt;　　Fingerprint &lt;/h3&gt;
&lt;p&gt;　　指纹，通过指纹把信息分到不同的组中 　　&lt;/p&gt;

&lt;h3&gt; 　　Extra Data&lt;/h3&gt;
&lt;p&gt;　　传入额外的信息。并不会创建索引(也就是不可以提供来检索)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
scope.setExtra(&quot;character_name&quot;, &quot;Mighty Fighter&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过 setExtra 来设置。&lt;/p&gt;


&lt;h3&gt;　　6、Breadcurumbs 面包屑　　&lt;/h3&gt;
&lt;p&gt; 　　面包屑用于记录一系列当行为，当下一次发生错误事件上传当时候会随着一起上报。&lt;/p&gt;
&lt;p&gt;　　 浏览器 javascript sdk 将自动记录所有当位置更改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.addBreadcrumb({
  category: 'auth',
  message: 'Authenticated user ' + user.email,
  level: 'info'
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以通过 addBreadcrumb 来添加一次行为记录。&lt;/p&gt;

&lt;h3&gt;　　7、user Feedback&lt;/h3&gt;
&lt;p&gt;　　用户反馈，sentry 提供了一个客户反馈当窗口。&lt;/p&gt;
&lt;p&gt;　　当错误发生当时候，可以弹出窗口收集一些信息，例如：&lt;/p&gt;
&lt;p&gt;　　用户名&lt;/p&gt;
&lt;p&gt;　　用户当邮件地址&lt;/p&gt;
&lt;p&gt;　　发生的问题的描述等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.showReportDialog();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过 showReportDialog 来实现框架的弹出。&lt;/p&gt;







&lt;h2&gt;sentry实现预警并且邮件提醒&lt;/h2&gt;

&lt;p&gt;　　邮件预警和邮件提醒是在生产环境中不可缺少的一部分，只有有效的提醒来能让我们最快的解决问题。&lt;/p&gt;
&lt;p&gt;　　在项目中选择 setting --&amp;gt;  alerts  进入邮件预警设置页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203161458830-1282045237.png&quot; alt=&quot;&quot; width=&quot;1143&quot; height=&quot;787&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　这里都是基本的邮件规则。&lt;/p&gt;
&lt;p&gt;　　在 tabs 中的 rule 可以自定规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203161619374-1584941646.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　规则设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181203161729502-2029293521.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　An event is seen ： 一个事件发生的时候&lt;/p&gt;
&lt;p&gt;　　An issue is first seen ： 第一个发生错误的时候&lt;/p&gt;
&lt;p&gt;　　An issue changes state from resolved to unresolved ：问题从解决到未解决的时候&lt;/p&gt;
&lt;p&gt;　　An event's tags match {key} {match} {value}  ： 匹配到 tags 的键值对的时候发送&lt;/p&gt;
&lt;p&gt;　　An issue is seen more than {value} times in {interval} ：在固定时间内出现次数匹配的时候&lt;/p&gt;
&lt;p&gt;　　An issue is seen by more than {value} users in {interval} ：在固定时间内出现用户的次数匹配的时候&lt;/p&gt;
&lt;p&gt;　　An event's {attribute} value {match} {value} ： 匹配到某一个事件的时候&lt;/p&gt;
&lt;p&gt;　　An event's level is {match} {level} ： 事件级别匹配的时候&lt;/p&gt;




&lt;h2&gt;sentry 生产的 sourcemap 配置 &lt;/h2&gt;

&lt;h3&gt;　　介绍&lt;/h3&gt;

&lt;p&gt;　　现在开发很多时候，我们的代码都会利用构建工具对代码合并、压缩、混淆等。&lt;/p&gt;
&lt;p&gt;　　在产生这些生产代码的时候，为了利于我们开发调试、bug修复会产生一个 sourcemap 。&lt;/p&gt;
&lt;p&gt;　　sourecmap 的主要作用就是将我们的打包的代码前后最了一个关联。&lt;/p&gt;
&lt;p&gt;　　这里，sentry 对生产的 sourcemap 有很好的处理，它可以很快的让我们确定代码的错误位置。&lt;/p&gt;

&lt;h3&gt;　　准备工作&lt;/h3&gt;

&lt;p&gt;　　首先我们需要添加 sentry 的命令行的管理工具 sentry-cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm i -g @sentry/cli&lt;br/&gt;// 上面的不行就用下面的
npm install -g @sentry/cli --unsafe-perm
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　获取认证的 token &lt;/h3&gt;

&lt;p&gt;　　选择API后就可以生成token，记得勾选 project:write 权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117885/201812/1117885-20181204152642663-1464453006.png&quot; alt=&quot;&quot; width=&quot;962&quot; height=&quot;418&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里的 token 是用于登陆的。&lt;/p&gt;

&lt;h3&gt;　　登陆&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
sentry-cli --url myserver  login
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回车后输入上一步获得的 token 即可&lt;/p&gt;

&lt;h3&gt;　　创建版本 &lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
sentry-cli releases -o 组织 -p 项目 new release@1.1.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-o : 组织，可以在我们的 Organization Settings 中找到&lt;/p&gt;
&lt;p&gt;　　-p : 项目名称 ， 可以在 projuct 中找到&lt;/p&gt;
&lt;p&gt;　　release@1.1.0 : 发布的版本号，可以自定义，这个后需要在应用配置的时候传入&lt;/p&gt;

&lt;p&gt;　配置 release 到应用　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.init({
  dsn: 'http://18ac34902da74aa29a4328879a58fb0d@localhost:9000/2',
  release: 'release@1.1.0',
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　上传 sourcemap 文件&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
sentry-cli releases -o 组织 -p 项目 files release@1.1.0 upload-sourcemaps jspath文件所在目录 --url-prefix 线上资源URI
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　-o , -p : 和上文一样&lt;/p&gt;
&lt;p&gt;　　jspath : js 文件的位置&lt;/p&gt;
&lt;p&gt;　　uri : js 文件相对于域名的位置&lt;/p&gt;
&lt;h4&gt;　　特殊说明 url-prefix&lt;/h4&gt;
&lt;p&gt;　　这里是必须传的，不传找不到 map 文件，例如：&lt;/p&gt;
&lt;p&gt;　　你的 js 线上的地址为 ：https://test.com/static/js/test.js&lt;/p&gt;
&lt;p&gt;　　这个时候 url-prefix 应该为 ： '~/static/js/'&lt;/p&gt;
&lt;h2&gt;   &lt;/h2&gt;
&lt;h2&gt;    完成！！！！&lt;/h2&gt;

&lt;p&gt;　　配置文件，在命令行操作的时候，sentry 支持配置文件。&lt;/p&gt;
&lt;p&gt;　　配置文件默认文命令的目录。&lt;/p&gt;
&lt;p&gt;　　配置文件 .sentryclirc&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[auth]
token=1a59c94sdfsdfs33b5588b27bd3628c98ff2837c054b4503be089ad623620527

[defaults]
url=http://localhost:9000
project=react-test
org=test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置之后就不需要在输入项目名称和地址了。&lt;/p&gt;


&lt;h2&gt;总结步骤：&lt;/h2&gt;
&lt;h4&gt;　　1、注册账号 、创建项目 &lt;/h4&gt;
&lt;p&gt;　　 直接登陆 sentry 官网，注册账号，并且创建一个项目&lt;/p&gt;

&lt;h4&gt;　　2、在项目中配置 sentry &lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Sentry.init({
  dsn: 'http://18ac34902da74aa29a4328879a58fb0d@localhost:9000/2',
  release: RELEASE_VERSION,
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　3、打包时候上传 sourcemap 文件&lt;/h4&gt;

&lt;h4&gt;　　4、配置邮件预警&lt;/h4&gt;


&lt;p&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 基于sentry的前端错误监控日志系统(部署sentry服务器/前端项目部署)-让前端最快的定位到生产问题&quot; href=&quot;https://www.cnblogs.com/jiebba/p/10049938.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jiebba/p/10049938.html&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;   我的博客 ： &lt;a href=&quot;https://gilea.cn/index&quot; target=&quot;_blank&quot;&gt; XiaoLong's Blog&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;   &lt;a href=&quot;https://www.cnblogs.com/jiebba&quot; target=&quot;_blank&quot;&gt;博客园小结巴巴： https://www.cnblogs.com/jiebba&lt;/a&gt;&lt;/h3&gt;


</description>
<pubDate>Tue, 04 Dec 2018 14:59:00 +0000</pubDate>
<dc:creator>小结巴巴吧</dc:creator>
<og:description>背景 在这越来越发达的网络时代，web应用也是越来越复杂，尤其是前端的开发，也是越来越受重视。 所以在我们前端开发完成后，会有一些列的web应用的上线验证，如自测、QA测试、code review 等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiebba/p/10049938.html</dc:identifier>
</item>
<item>
<title>DirectX11--HLSL编译着色器的三种方法 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10066282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10066282.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本教程不考虑Effects11(FX11)，而是基于原始的HLSL。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前编译与加载着色器的方法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用Visual Studio中的HLSL编译器，随项目编译期间一同编译，并生成&lt;code&gt;.cso&lt;/code&gt;(Compiled Shader Object)对象文件，在运行期间加载该文件以读取字节码。&lt;/li&gt;
&lt;li&gt;使用Visual Studio中的HLSL编译器，随项目编译期间一同编译，并生成&lt;code&gt;.inc&lt;/code&gt;或&lt;code&gt;.h&lt;/code&gt;的头文件，着色器字节码在编译期间就可以确定。&lt;/li&gt;
&lt;li&gt;在程序运行期间编译着色器代码，并读取生成的字节码。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在个人的DX11项目中，使用的是方法1(优先)和方法3的混合形式。尽管方法2是最近了解到的，但个人目前并不考虑更换为该方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了符合微软的约定，需要为你的着色器代码使用下面的扩展名(有所修改)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;扩展名为&lt;code&gt;.hlsl&lt;/code&gt;的文件用于编写HLSL的源代码，参与编译&lt;/li&gt;
&lt;li&gt;扩展名为&lt;code&gt;.hlsli&lt;/code&gt;的文件作为HLSL的标头文件，不参与编译&lt;/li&gt;
&lt;li&gt;扩展名为&lt;code&gt;.cso&lt;/code&gt;的文件作为已编译的着色器对象(Compiled Shader Object)&lt;/li&gt;
&lt;li&gt;扩展名为&lt;code&gt;.inc&lt;/code&gt;或&lt;code&gt;.h&lt;/code&gt;的文件是C++的头文件，但它的内部包含了着色器的字节码，使用&lt;code&gt;BYTE&lt;/code&gt;数组来记录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在以Rendering a Triangle项目为例，现在我们已经编写好的着色器文件有&lt;code&gt;Triangle.hlsli&lt;/code&gt;, &lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;, &lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;这三个，可以将它拉进项目当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204185753974-381761738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;Triangle.hlsli&lt;/code&gt;作为HLSL的头文件默认不参与项目的编译过程。&lt;/p&gt;
&lt;p&gt;而对于&lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;和&lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;，则在项目属性要这样设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204190422570-1879878932.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204190253001-1235721971.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成项目后，需要留意在输出窗口(生成)中是否出现了下面的内容：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204222348751-969630600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有出现了上述内容，才说明成功编译出对象文件，否则说明没有被编译出来。&lt;/strong&gt;如果你之前已经编译出对象文件，再编译时没有出现该输出结果，可能需要先删除之前编译出来的对象文件再试一次。&lt;/p&gt;
&lt;h2 id=&quot;d3dreadfiletoblob函数--读取编译好的着色器二进制信息&quot;&gt;D3DReadFileToBlob函数--读取编译好的着色器二进制信息&lt;/h2&gt;
&lt;p&gt;对着色器代码或文件的相关操作位于头文件&lt;code&gt;d3dcompiler.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们使用下面的函数来读取编译好的着色器二进制信息：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT D3DReadFileToBlob(LPCWSTR pFileName,    // [In].cso文件名
                  ID3DBlob** ppContents);       // [Out]获取二进制大数据块&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：如果你的项目中不存在该函数，说明你可能预先包含了DX SDK，然而该教程使用的是Windows SDK，该函数位于D3DCompiler &amp;gt;= 46的版本，因此你需要剔除DX SDK的包含路径和库路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用方式也十分简单(以创建顶点着色器和顶点布局为例)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ComPtr&amp;lt;ID3DBlob&amp;gt; blob;
HR(D3DReadFileToBlob(L&quot;HLSL\\Triangle_VS.cso&quot;, blob.GetAddressOf()));
HR(md3dDevice-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mVertexShader.GetAddressOf()));
// 创建顶点布局
HR(md3dDevice-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout),
    blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), mVertexLayout.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以拿获取到的&lt;code&gt;ID3DBlob&lt;/code&gt;来创建着色器了。创建着色器和顶点布局的部分在本文不进行讨论，请回到教程02继续查看。&lt;/p&gt;
&lt;p&gt;该方法的特点是会在你的项目文件夹中产生编译好的着色器二进制文件，并且需要你在程序运行的时候直接读进来。&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;和&lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;，在项目属性要这样设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204211303433-1295523096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204211206978-1417874000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里关于头文件的名称以及内部的全局变量名可以自行决定。&lt;/p&gt;
&lt;p&gt;头文件 经过编译后会在HLSL文件夹产生&lt;code&gt;Triangle_VS.inc&lt;/code&gt;和&lt;code&gt;Triangle_PS.inc&lt;/code&gt;两个文件，观察里面的代码你可以发现里面有汇编部分(不会包含进代码中)和一个全局变量，在&lt;code&gt;Triangle_VS.inc&lt;/code&gt;中产生的是全局变量&lt;code&gt;gTriangle_VS&lt;/code&gt;，而在&lt;code&gt;Triangle_PS.inc&lt;/code&gt;中产生的是全局变量&lt;code&gt;gTriangle_PS&lt;/code&gt;。这两个变量都是&lt;code&gt;BYTE&lt;/code&gt;数组，里面的内容正是编译好的字节码。&lt;/p&gt;
&lt;p&gt;现在需要在你需要编写创建着色器相关代码的源文件上面包含这两个头文件：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;HLSL/Triangle_VS.inc&quot;
#include &quot;HLSL/Triangle_PS.inc&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建顶点着色器和顶点布局的代码变成了这样：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 创建顶点着色器
HR(md3dDevice-&amp;gt;CreateVertexShader(gTriangle_VS, sizeof(gTriangle_VS), nullptr, mVertexShader.GetAddressOf()));
// 创建并绑定顶点布局
HR(md3dDevice-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout),
    gTriangle_VS, sizeof(gTriangle_VS), mVertexLayout.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就可以生成整个项目了，需要留意是否有红色部分的输出，否则可能没有成功编译出&lt;code&gt;.inc&lt;/code&gt;文件(这可能会在已有&lt;code&gt;.inc&lt;/code&gt;文件再次编译的时候导致出现问题，需要删除原来的&lt;code&gt;.inc&lt;/code&gt;文件)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201812/1172605-20181204212958311-1494507690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于上述两个头文件的产生(即着色器的编译)先于项目的编译，在没有产生这两个头文件的时候，你也可以忍着编译错误先把上述代码添加进去，然后编译的时候就一切正常了。&lt;/p&gt;
&lt;p&gt;该方法的特点是所有的过程均在编译期完成，着色器字节码镶嵌在了你的应用程序内部，可能会导致应用程序变大。&lt;/p&gt;

&lt;p&gt;现在你需要了解这些函数&lt;/p&gt;
&lt;h2 id=&quot;d3dcompilefromfile函数--运行期编译.hlsl文件&quot;&gt;D3DCompileFromFile函数--运行期编译.hlsl文件&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT D3DCompileFromFile(
    LPCWSTR pFileName,                  // [In]要编译的.hlsl文件
    CONST D3D_SHADER_MACRO* pDefines,   // [In_Opt]忽略
    ID3DInclude* pInclude,              // [In_Opt]如何应对#include宏
    LPCSTR pEntrypoint,                 // [In]入口函数名
    LPCSTR pTarget,                     // [In]使用的着色器模型
    UINT Flags1,                        // [In]D3DCOMPILE系列宏
    UINT Flags2,                        // [In]D3DCOMPILE_FLAGS2系列宏
    ID3DBlob** ppCode,                  // [Out]获得着色器的二进制块
    ID3DBlob** ppErrorMsgs);            // [Out]可能会获得错误信息的二进制块&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再次注意：如果你的项目中不存在该函数，说明你可能预先包含了DX SDK，然而该教程使用的是Windows SDK，该函数位于D3DCompiler &amp;gt;= 46的版本，因此你需要剔除DX SDK的包含路径和库路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;pInclude&lt;/code&gt;用于决定如何处理包含文件。如果设为&lt;code&gt;nullptr&lt;/code&gt;，则编译的着色器代码包含&lt;code&gt;#include&lt;/code&gt;时会引发编译器报错。如果你需要使用&lt;code&gt;#include&lt;/code&gt;，可以传递&lt;code&gt;D3D_COMPILE_STANDARD_FILE_INCLUDE&lt;/code&gt;宏，这是一个默认的包含句柄，可以按该着色器代码所处的相对路径去搜索对应的头文件并包含进来。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define D3D_COMPILE_STANDARD_FILE_INCLUDE ((ID3DInclude*)(UINT_PTR)1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;d3dwriteblobtofile函数--将编译好的着色器二进制信息写入文件&quot;&gt;D3DWriteBlobToFile函数--将编译好的着色器二进制信息写入文件&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT D3DWriteBlobToFile(
    ID3DBlob* pBlob,    // [In]编译好的着色器二进制块
    LPCWSTR pFileName,  // [In]输出文件名
    BOOL bOverwrite);   // [In]是否允许覆盖&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;bOverwrite&lt;/code&gt;来说，无论是&lt;code&gt;TRUE&lt;/code&gt;还是&lt;code&gt;FALSE&lt;/code&gt;都无关紧要，因为我们只有在检测到没有编译好的着色器文件时才会启动运行期编译，然后再保存到文件。&lt;/p&gt;
&lt;p&gt;具体用法已经集成在下面的&lt;code&gt;CreateShaderFromFile&lt;/code&gt;函数中了&lt;/p&gt;

&lt;p&gt;下面是&lt;code&gt;CreateShaderFromFile&lt;/code&gt;函数的实现，&lt;strong&gt;现在该函数已经放到了d3dUtil.h中&lt;/strong&gt;，需要依赖&lt;code&gt;dxerr&lt;/code&gt;和标准库的&lt;code&gt;filesystem&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 该函数需要包含filesystem头文件，并using namespace std::experimental;(C++11/14)

// ------------------------------
// CreateShaderFromFile函数
// ------------------------------
// [In]objFileNameInOut 编译好的着色器二进制文件(.cso)，若有指定则优先寻找该文件并读取
// [In]hlslFileName     着色器代码，若未找到着色器二进制文件则编译着色器代码
// [In]entryPoint       入口点(指定开始的函数)
// [In]shaderModel      着色器模型，格式为&quot;*s_5_0&quot;，*可以为c,d,g,h,p,v之一
// [Out]ppBlobOut       输出着色器二进制信息
HRESULT CreateShaderFromFile(const WCHAR * objFileNameInOut, const WCHAR * hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob ** ppBlobOut)
{
    HRESULT hr = S_OK;

    // 寻找是否有已经编译好的顶点着色器
    if (objFileNameInOut &amp;amp;&amp;amp; filesystem::exists(objFileNameInOut))
    {
        HR(D3DReadFileToBlob(objFileNameInOut, ppBlobOut));
    }
    else
    {
        DWORD dwShaderFlags = D3DCOMPILE_ENABLE_STRICTNESS;
#ifdef _DEBUG
        // 设置 D3DCOMPILE_DEBUG 标志用于获取着色器调试信息。该标志可以提升调试体验，
        // 但仍然允许着色器进行优化操作
        dwShaderFlags |= D3DCOMPILE_DEBUG;

        // 在Debug环境下禁用优化以避免出现一些不合理的情况
        dwShaderFlags |= D3DCOMPILE_SKIP_OPTIMIZATION;
#endif
        ComPtr&amp;lt;ID3DBlob&amp;gt; errorBlob = nullptr;
        hr = D3DCompileFromFile(hlslFileName, nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint, shaderModel,
            dwShaderFlags, 0, ppBlobOut, errorBlob.GetAddressOf());
        if (FAILED(hr))
        {
            if (errorBlob != nullptr)
            {
                OutputDebugStringA(reinterpret_cast&amp;lt;const char*&amp;gt;(errorBlob-&amp;gt;GetBufferPointer()));
            }
            return hr;
        }

        // 若指定了输出文件名，则将着色器二进制信息输出
        if (objFileNameInOut)
        {
            HR(D3DWriteBlobToFile(*ppBlobOut, objFileNameInOut, FALSE));
        }
    }

    return hr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 创建顶点着色器
HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_VS.cso&quot;, L&quot;HLSL\\Triangle_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
HR(md3dDevice-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mVertexShader.GetAddressOf()));
// 创建并绑定顶点布局
HR(md3dDevice-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout),
    blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), mVertexLayout.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/desktop/direct3dhlsl/dx-graphics-hlsl-part1#compiling-with-d3dcompilefromfile&quot;&gt;Compiling Shaders&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/desktop/direct3d11/how-to--compile-a-shader&quot;&gt;How To: Compile a Shader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 本教程不考虑Effects11(FX11)，而是基于原始的HLSL。 目前编译与加载着色器的方法如下： 1. 使用Visual Studio中的HLSL编译器，随项目编译期间一同编译，并生成 (</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10066282.html</dc:identifier>
</item>
<item>
<title>HBase之Table.put客户端流程(续) - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10067904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10067904.html</guid>
<description>&lt;p&gt;　　上篇博文中已经谈到，有两个流程没有讲到。一个是MetaTableAccessor.getRegionLocations，另外一个是ConnectionImplementation.cacheLocation。这一节，就让我们单独来介绍这两个流程。&lt;/p&gt;
&lt;p&gt;　　首先让我们来到MetaTableAccessor.getRegionLocations。&lt;/p&gt;
&lt;p&gt;　　1.调用MetaTableAccessor.getRegionInfo，获取返回结果集中指定的列信息(info:regioninfo)的值。在这个方法的调用过程中，有一个知识点需要大家关注——Result.binarySearch。我将放在后面讲解。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.然后调用了Result.getNoVersionMap。在这里，完成了对返回结果集的含version版本信息的封装与不含version版本信息的封装，同样，我将放在后面讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204223820961-150749780.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　首先让我们来到Result.binarySearch。大家可以看到这里使用的kvs[0]的rowKey，然后使用了传入的family(info)与qualifier(regioninfo)。大家可能比较迷惑，为什么这里的逻辑是这样的。原因很简单，因为这里传入的Cell数组的rowKey都是一样的，要利用Arrays.binarySearch搜索指定family:qualifier。因此首先使用这些信息构造了一个封装了以上信息的FirstOnRowColCell。这里需要注意的是，新建的cell.getTimestamp返回值为HConstants.LATEST_TIMESTAMP = Long.MAX_VALUE。这里，大家可能会对Arrays.binarySearch的返回值比较新奇，为什么结果是负值包括后面为什么有表达式(pos = (pos+1) * -1)。大家感兴趣的可以追一下源码，我只简单说一下结论。在调用Arrays.binarySearch方法时，如果所要搜索的数组中包含键，则返回键在该数组的位置，然而，如果数组中不包含键，那么就返回-(insertion point) - 1。这里的insertion point就是该数组中第一个元素大于键的索引位置(the index of the first element greater than the key)。如果大家还是不懂，在网上搜一下就明白了，我在这里就不详述了。后面通过表达式(pos = (pos+1) * -1)也就获取的Arrays.binarySearch后的insertion point。看到这里大家可能还有点迷惑，不过，相信我在介绍完CellComparatorImpl后，大家可能就恍然大悟了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204223853384-1361404919.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来让我们来到CellComparatorImpl.compare方法。这里主要调用了compareRows与compareWithoutRow。compareRows比较简单，就是比较传入Cell的rowKey。真正重要的是compareWithoutRow。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204223907721-2086323227.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　接下来让我们来到CellComparatorImpl.compareWithoutRow方法。这里比较容易误会的是compareTimestamps。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204223939115-1571425592.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到CellComparatorImpl.compareTimestamps。正如截图中注释所说，交换顺序以实现将相同的family:qualifier按照时间戳的降序来排列(family与qualifier都是按照升序来排列的)。看到这里，相信大家就能够明白为什么构建的Cell时间戳为Long.MAX_VALUE。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　不过，我还是在这里再简单介绍一下。上面我已经提到Arrays.binarySearch中insertion point是该数组中第一个元素大于键的索引位置(the index of the first element greater than the key)。假如，如果说这里的CellComparatorImpl.compareTimestamps为升序排列，那么，上面构造的key的insertion point为数组中相同family:qualifier的index + 1。而这里改为降序之后，构造的key的insertion point为数组中相同family:qualifier的index。而这个结果正是我们需要的。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204223957432-1752560056.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，大家可能就明白了Result.getColumnLatestCell方法的含义——获取指定family:qualifier中时间戳最接近Long.MAX_VALUE的cell。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　接下来我插入一个知识点——Result.getMap与Result.getNoVersionMap。这里获取的是含version信息的列。通过其中的versionMap.put方法我们就可以知道，这里将不同version的value值保存在map中了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224026204-1253860976.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　然后来到Result.getNoVersionMap。在这里获取的是不含version的列。由于上面在构造versionMap时传入的Comparator为倒序排序，因此，这里通过qualifierEntry.getValue().firstKey()获得的是最新版本的value。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224041150-1448746812.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来，让我们来到本节中另外一个也是最后一个重要的方法ConnectionImplementation.cacheLocation。由于其主要调用了MetaCache.getCachedLocation，因此，我在这里贴出MetaCache.getCachedLocation源码，如下图所示。其中比较重要的方法是MetaCache.getTableLocations。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224059593-879995886.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来让我们来到MetaCache.getTableLocations，如下图所示。如果看过我的上篇博文《HBase之Table.put客户端流程》，大家可能知道，我埋了一个伏笔，也就是这里的最后一个入参。上一篇中的与这里的入参类型不同，但是方法的调用流程是一样的，我就在这里详细讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224119571-103100170.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;　　上图中最后一个入参是java.util.function.Supplier。如下图所示。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224134350-934548216.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;　　上图中的最后一个入参类型是Runnable。看到这里，大家可能就明白了。如果在MetaCache.cachedRegionLocations中并没有相应的key,value对，那么就会调用supplier.get方法，也就是getTableLocations的最后一个入参，重新构建一个CopyOnWriteArrayMap，并且将内部的比较器设置为Bytes.BYTES_COMPARATOR。然后将其放到MetaCache.cachedRegionLocations。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181204224157739-1993533866.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到此为止，完整的《HBase之Table.put客户端流程》就结束了。大家如果有什么疑问或者大数据相关的问题可以发送至我的邮箱15935152719@163. com。&lt;/p&gt;
&lt;p&gt;　　从下一节起，也就是本周末，我将为大家带来HBase的第二章内容——Hbase之Client协议。届时，Client协议中的服务端与客户端的完整流程将为大家一一奉上。如果比较关注其中的内容可以关注我，或者成为我的粉丝，都是就可以及时收到更新啦。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 14:46:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>上篇博文中已经谈到，有两个流程没有讲到。一个是MetaTableAccessor.getRegionLocations，另外一个是ConnectionImplementation.cacheLocat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10067904.html</dc:identifier>
</item>
</channel>
</rss>