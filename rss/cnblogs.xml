<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>视频目标处理涉及的目标分割、目标识别、目标检测和目标跟踪都是指什么？ - 在海一方美猴王</title>
<link>http://www.cnblogs.com/liuyihai/p/8338393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyihai/p/8338393.html</guid>
<description>&lt;div class=&quot;RichContent RichContent--unescapable&quot; data-reactid=&quot;238&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot; readability=&quot;40&quot;&gt;
&lt;p&gt;&lt;span&gt;      （1）目标分割，应该是Target Segmentation，应该是data/image segmentation的一种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这里假定数据是图像，就如楼上说的，任务是把目标对应的部分分割出来。对于一般的光学图像而言，分割像素是一个比较常见的目标，就是要提取哪一些像素是用于表述已知目标的。这种Segmentation可以是一个分类（classificatio）问题，就是把每一个pixel做labeling，提出感兴趣的那一类label的像素。也可以是clustering的问题，即是不知道label，但需要满足一些optimality，比如要cluster之间的correlation最小之类的。当然，答主也见过一些针对其他数据的目标分割，比如hyperspectral data，也需要分割哪些频率或者通道对应的是目标。比如视频流，那段时间对应是目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        下面是一个Target Segmentation的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/5a767c0f13b253eedb23199b7454d0b4_hd.jpg&quot; alt=&quot;&quot; width=&quot;602&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;337&quot; data-original=&quot;https://pic3.zhimg.com/5a767c0f13b253eedb23199b7454d0b4_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/5a767c0f13b253eedb23199b7454d0b4_hd.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;      （2）目标识别，应该是Target Recognition。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        这是一个基于分类（Classification）的识别（Recognition）问题，即是在所有的给定数据中，分类出哪一些sample是目标，哪一些不是。还是拿图片作为数据举例，这个分类的层面往往不是pixel，给定的一些segment，或者定义的对象（Object），或者图片本身。&lt;br/&gt;       下面是一个Target Recognition的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/7b2f4dcc46920adfef0594343dfce0c3_hd.jpg&quot; alt=&quot;&quot; width=&quot;1024&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;317&quot; data-original=&quot;https://pic4.zhimg.com/7b2f4dcc46920adfef0594343dfce0c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/50/7b2f4dcc46920adfef0594343dfce0c3_hd.jpg&quot;/&gt;&lt;br/&gt;       （3）目标检测，应该是Target Detection。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        最早的detection system应该是搞雷达的人首先提出并且heavily study的，最简单的任务就是从看似随机（random）又充满干扰（interference）和噪音（noise）的信号中，抓取到有信息的特征（information-bearing pattern）。最简单的一个栗子，就是当你拿到一段随机的雷达回波，可以设置一个threshold，当高于这个threshold，就认为是探测到了高速大面积飞行器之类的高回波的目标。当然，这里面的threshold该怎么设计，涉及到False Alarm和Miss Detection之间的平衡。人们往往需要寻找最佳的transform或者domain去对信号进行分析。&lt;br/&gt;        下面是一个Target Detection的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/ba971eab1ba26ac432f78ccbfb37388b_hd.jpg&quot; alt=&quot;&quot; width=&quot;1045&quot; data-rawwidth=&quot;1045&quot; data-rawheight=&quot;1035&quot; data-original=&quot;https://pic3.zhimg.com/ba971eab1ba26ac432f78ccbfb37388b_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/ba971eab1ba26ac432f78ccbfb37388b_hd.jpg&quot;/&gt;&lt;br/&gt;      （4）目标追踪，应该是Target Tracking。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        这个任务很重要的第一点是目标定位（Target Locating），而且这个任务设计到的数据一般具有时间序列（Temporal Data）。常见的情况是首先Target被Identify以后，算法或者系统需要在接下来时序的数据中，快速并高效地对给定目标进行再定位。任务需要区别类似目标，需要避免不要的重复计算，充分利用好时序相关性（Temporal Correlation），并且需要对一些简单的变化Robust，必须旋转，遮盖，缩小放大，Motion Blur之类的线性或者非线性变化。&lt;br/&gt;        下面是一个Target Detection的栗子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/cd89972dcddad9f7e7a9b760d71d7d57_hd.jpg&quot; alt=&quot;&quot; width=&quot;480&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;360&quot; data-original=&quot;https://pic2.zhimg.com/cd89972dcddad9f7e7a9b760d71d7d57_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/50/cd89972dcddad9f7e7a9b760d71d7d57_hd.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;本文摘录自：https://www.zhihu.com/question/36500536&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 23 Jan 2018 15:41:00 +0000</pubDate>
<dc:creator>在海一方美猴王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyihai/p/8338393.html</dc:identifier>
</item>
<item>
<title>20165233 我期望的师生关系 - minchan0624</title>
<link>http://www.cnblogs.com/minchan0624/p/8338384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minchan0624/p/8338384.html</guid>
<description>[unable to retrieve full-text content]老师能提供的帮助 我印象最深刻的老师应该是中学时的老师。 初中时的班主任是一名语文老师，她文学功底很深厚，但是一个十分活泼的老师。我记得她的脾气还是挺大的，尤其是在我们在语文学习中犯一些低级错误，或者她强调多遍的问题还是出错的时候。有时候还是挺怕她的。但是她也会经常因为我们哭，她觉得我们像她的孩子一</description>
<pubDate>Tue, 23 Jan 2018 15:38:00 +0000</pubDate>
<dc:creator>minchan0624</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minchan0624/p/8338384.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET OAuth、jwt、OpenID Connect - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/8184904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/8184904.html</guid>
<description>&lt;p&gt;　　上一篇文章介绍了OAuth2.0以及如何使用.Net来实现基于OAuth的身份验证，本文是对上一篇文章的补充，主要是介绍OAuth与Jwt以及OpenID Connect之间的关系与区别。&lt;/p&gt;
&lt;p&gt;　　本文主要内容有：&lt;br/&gt;　　● Jwt简介&lt;br/&gt;　　● .Net的Jwt实现&lt;br/&gt;　　● OAuth与Jwt&lt;br/&gt;　　● .Net中使用Jwt Bearer Token实现OAuth身份验证&lt;br/&gt;　　● OAuth与OpenID Connect&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：本章内容源码下载：&lt;/span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/selimsong/OAuth2Demo_jwt.zip&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/selimsong/OAuth2Demo_jwt.zip&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Jwt简介&lt;/h2&gt;
&lt;p&gt;　　Jwt(Json Web Token)它是一种基于Json用于安全的信息传输标准，Jwt具有以下几个特点：&lt;br/&gt;　　● 紧凑：Jwt由于是为Web准备的，所以就需要让数据尽可能小，能够在Url、Post参数或者Http Header中携带Jwt，同时由于数据小，所以也增加了数据传输的速度。&lt;br/&gt;　　● 自包含：在Jwt的playload部分包含了所有应该包含的信息，特别是在Jwt用于身份验证时playload中包含了用户必要的身份信息(注：不应该包含敏感信息)，这样在进行身份验证时就无需去数据库中查询用户信息。&lt;br/&gt;　　● 可信：Jwt是带有数字签名的，可以知道Jwt在传输过程中是否被篡改，保证数据是完整的，可用的签名算法有RS256(RSA+SHA-256)、HS256(HMAC+SHA-256)等。&lt;/p&gt;
&lt;p&gt;　　Jwt有两个用途，其一是&lt;span&gt;用于数据交互&lt;/span&gt;，因为Jwt是被签名的，可以保证数据的完整性。另外就是用来携带用户信息&lt;span&gt;进行身份验证&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　Jwt包含三个部分：&lt;br/&gt;　　● Header：包含了签名算法以及令牌类型(默认为JWT)。如：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103164047878-1487377639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：alg以及typ均是缩写，其目的就是为了减小jwt的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　● Playload：包含Jwt所携带的信息内容，Playload中包含了3种类型的Claim(声明)定义，分别是标准的，如iss(issuer，Jwt的发行者)、sub(subject，Jwt所代表的用户)、aud(audience，Jwt的接收者)、exp(expiration time,Jwt的过期时间)，还有一些是公共约定的如： &lt;a href=&quot;http://www.iana.org/assignments/jwt/jwt.xhtml&quot; target=&quot;_blank&quot;&gt;http://www.iana.org/assignments/jwt/jwt.xhtml&lt;/a&gt;，另外就是私有自定义的，这些用来存放具体的信息。&lt;br/&gt;　　Playload的结构如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103164139456-950354605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　● Signature：包含了Header以及Playload的base64Url编码后的签名结果，其计算过程如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103164221487-1268429351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最终三个部分均使用Base64Url的方式进行编码后使用符号“.”进行分隔，以下是一个完整Jwt的例子：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103164319049-1051848282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：Jwt中的数据是透明的，既任何人拿到数据都能Base64Url反编码的形式看到内容，签名仅仅是保证内容不被纂改，所以不能在Jwt中包含敏感数据。以上例子均来自&lt;a href=&quot;https://jwt.io/introduction/&quot; target=&quot;_blank&quot;&gt;https://jwt.io/introduction/&lt;/a&gt;&lt;/span&gt;&lt;em&gt;　&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;.Net的Jwt实现&lt;/h2&gt;
&lt;p&gt;　　Jwt是一个标准，在&lt;a href=&quot;https://jwt.io/&quot; target=&quot;_blank&quot;&gt;https://jwt.io/&lt;/a&gt;上可以看到很多不同语言对Jwt的实现，而.Net的其中一个实现是System.IdentityModel.Tokens.Jwt组件，该组件是由微软实现的，它有两个重要的类型分别是：&lt;br/&gt;　　&lt;span&gt;注：从名称(IdentityModel)都可以看出，微软的这个实现主要是用于身份验证的，如果使用Jwt的目的不是身份验证可以选择其它的组件或自定义实现。&lt;/span&gt;&lt;br/&gt;　　● JwtSecurityToken：这个类型是Jwt的一个封装，它除了包含Jwt的三个要素(Header、Playload、Signature)外，还拓展了一些如Subject、Iusser、Audiences、有效期、签名算法、签名密钥等重要属性。&lt;br/&gt;　　下图是JwtSecurityToken的部分定义：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103172344487-1663188210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　● JwtSecurityTokenHandler：该对象用来对Jwt进行操作，如Jwt的创建、验证( 包含发布者、接收者、签名等验证)、Jwt的序列化与反序列化(字符串形式与对象形式之间的转换)&lt;br/&gt;　　下图是JwtSecurityTokenHandler的部分定义：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103172608565-1236548175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;OAuth与Jwt&lt;/h2&gt;
&lt;p&gt;　　OAuth与Jwt前者是一个授权协议后者是一个信息安全传输标准，看起来它们之间并没有什么关系，但其实OAuth的Access Token有一种实现方式就是Jwt。&lt;br/&gt;为什么要使用Jwt来作为OAuth的Access Token?首先来看一下上一篇文章中生成的Access Token：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180103172727034-1139389209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它是一个加密后的字符串，该字符串包含了用户的相关信息，但是该字符串&lt;span&gt;只能够被使用Microsoft.Owin.Security.OAuth组件的应用程序解密&lt;/span&gt;(不包括参照源码的实现)，并且还要保证加解密的密钥是相同的。但是OAuth很多时候是用于一些分布式的场景中，甚至还会使用不同语言来编写不同的应用、服务。这样的话上面这种Token的实现方式就无法满足需求。&lt;br/&gt;　　所以需要使用Jwt Bearer Token来&lt;span&gt;解决不同应用中的Token识别问题&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;.Net中使用Jwt Bearer Token实现OAuth身份验证&lt;/h2&gt;
&lt;p&gt;　　在上一篇文章中提到了Microsoft.Owin.Security.OAuth组件中Access Token的生成实际上是对一个AuthenticationTicket对象序列化并加密后的字符串，而Access Token的验证则是对加密后的字符串解密并反序列化获得AuthenticationTicket对象的过程。&lt;br/&gt;　　而对于Access Token来说无论是Microsoft.Owin.Security.OAuth组件的实现方式还是Jwt，甚至是自定义格式，它的&lt;span&gt;核心都在于如何将用户信息包含到一个字符串令牌中，并且能够通过这个字符串令牌还原出正确的用户信息&lt;/span&gt;。对于这一个过程在.Net的Owin身份验证解决方案中将其抽象为一个ISecureDataFormat&amp;lt;TData&amp;gt;接口，其中身份验证的泛型TData类型为AuthenticationTicket。下图是ISecureDataFormat接口的定义，它的两个方法就是用于进行字符串加密令牌与用户信息对象之间的转换，可参考《&lt;a id=&quot;post_title_link_7771875&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7771875.html&quot;&gt;ASP.NET没有魔法——ASP.NET Identity的加密与解密&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180104143721299-1333408888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上一篇文章中也给出了Microsoft.Owin.Security.OAuth组件中，默认对Access Token加解密对象是TicketDataFormat，该对象实际上就是一个实现了ISecureDataFormat接口的类型，用于通过数据保护器来完成数据对象的序列化与加解密的工作，可参考《&lt;a id=&quot;post_title_link_7771875&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7771875.html&quot;&gt;ASP.NET没有魔法——ASP.NET Identity的加密与解密&lt;/a&gt;》：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180104145230393-17509091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以这样理解要在.Net中实现基于Jwt Bearer Token的OAuth身份验证，仅需要在Microsoft.Owin.Security.OAuth组件的基础上&lt;span&gt;自定义一个ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;类型即可&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Jwt主要属性的说明&lt;/p&gt;
&lt;p&gt;　　实现之前再次对Jwt的一些重要属性进行说明：&lt;br/&gt;　　● Issuer：发布者，Jwt里面包含并且会进行验证的信息，Token的发布者，该发布者实际上就是身份验证服务器本身。&lt;br/&gt;　　● Audience：观众，发布者生成一个Token是根据观众来生成的，因为整个验证体系是以发布者为中心的分布式的包含多种应用的，为了保证数据安全一个Token只应该针对其中一个应用有效，所以在验证Jwt时还要对Audience进行验证。&lt;br/&gt;　　● Subject：主题，在身份验证中一般用于保存用户信息，如用户名。&lt;/p&gt;
&lt;p&gt;　　它们三的关系如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123163156506-860474717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　User代表的就是Subject，在OAuth中有Client的概念，OAuth的Client就相当于Audience。之前已经实现了Client的管理，现在为每一个Client添加一个用来数字签名的密钥，该密钥是一个32位byte数组的Base64编码字符串。另外这里是使用HMAC算法来完成对Token的摘要计算。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123163700397-680786023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现一个基于Jwt的ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;&lt;/h2&gt;
&lt;p&gt;　　下面就开始介绍如何来实现这个ISecureDataFormat：&lt;br/&gt;　　1. 通过Nuget安装Microsoft.Owin.Security.Jwt组件：&lt;br/&gt;&lt;span&gt;　　注：微软实现了一个用于解析Jwt Bearer Token的组件，但是该组件只实现了Unprotect方法，使用这个组件开发可以减少一些工作量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123163801006-1032683169.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2. 了解Microsoft.Owin.Security.Jwt中JwtFormat类型：&lt;br/&gt;　　Microsoft.Owin.Security.Jwt中实现了一个JwtFormat的对象，该对象正好实现了需要的ISecureDataFormat接口：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123164155584-789068063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但是从源码中得知该对象没有实现Protect方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123164222709-1244289761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而它的UnProtect方法的实现主要工作如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123164356069-435479166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　● 对发布者以及Token的签名、过期时间等进行验证(&lt;span&gt;注：验证操作是由System.IdentityModel.Tokens.Jwt组件中的JwtSecurityTokenHandler类型提供的&lt;/span&gt;)。&lt;br/&gt;　　● 验证成功后获取Token中包含的用户信息。&lt;/p&gt;
&lt;p&gt;　　3. 实现Jwt的Protect方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123164514975-292437238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('69e194c8-a599-47ac-bfe0-4213970b4f52')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_69e194c8-a599-47ac-bfe0-4213970b4f52&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_69e194c8-a599-47ac-bfe0-4213970b4f52&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('69e194c8-a599-47ac-bfe0-4213970b4f52',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_69e194c8-a599-47ac-bfe0-4213970b4f52&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyJwtFormat :  ISecureDataFormat&amp;lt;AuthenticationTicket&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于从AuthenticationTicket中获取Audience信息&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AudiencePropertyKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _issuer = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Jwt的发布者和用于数字签名的密钥&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; MyJwtFormat(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; issuer)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             _issuer =&lt;span&gt; issuer;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Protect(AuthenticationTicket data)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (data == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Audience名称及其信息&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; audienceId = data.Properties.Dictionary.ContainsKey(AudiencePropertyKey) ?
&lt;span&gt;21&lt;/span&gt;                 data.Properties.Dictionary[AudiencePropertyKey] : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(audienceId)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationTicket.Properties does not include audience&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; audience = ClientRepository.Clients.Where(c =&amp;gt; c.Id ==&lt;span&gt; audienceId).FirstOrDefault();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (audience == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Audience invalid.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据密钥创建用于数字签名的SigningCredentials，该对象在JwtSecurityToken中使用&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; keyByteArray =&lt;span&gt; TextEncodings.Base64Url.Decode(audience.Secret);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; signingKey = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InMemorySymmetricSecurityKey(keyByteArray);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; signingCredentials = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(signingKey,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                SecurityAlgorithms.HmacSha256Signature, SecurityAlgorithms.Sha256Digest);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取发布时间和过期时间&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; issued =&lt;span&gt; data.Properties.IssuedUtc;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; expires =&lt;span&gt; data.Properties.ExpiresUtc;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建JwtToken对象&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(_issuer,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                audienceId, 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                data.Identity.Claims,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                issued.Value.UtcDateTime,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                expires.Value.UtcDateTime,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                signingCredentials);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用JwtSecurityTokenHandler将Token对象序列化成字符串&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; jwt =&lt;span&gt; handler.WriteToken(token);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jwt;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; AuthenticationTicket Unprotect(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; protectedText)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;　&lt;/div&gt;
&lt;p&gt;　　上面代码做了以下几件事：&lt;br/&gt;　　● 从AuthenticationTicket中获取Audience信息(注：AuthenticationTicket是.Net中用来&lt;span&gt;保存用户信息的对象&lt;/span&gt;，它除了用户信息，如用户名以及用户Claims之外还携带了身份验证的有效期等&lt;span&gt;附加信息&lt;/span&gt;，见下图。AuthenticationTicket的创建方式有两种，&lt;span&gt;其一是登录时&lt;/span&gt;，在判断登录信息无误后，&lt;span&gt;从数据库中获取&lt;/span&gt;相应的用户信息以及从配置(或者默认)获取身份验证信息，如有效期等。另外就是&lt;span&gt;通过反序列化身份Token获取&lt;/span&gt;。这里的Protect方法实际上就是序列化Token的方法，所以它得到的AuthenticationTicket是通过第一总方式创建的)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123165002740-1201091785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　● 创建用于数字签名的SignatureCredentials对象，该对象代表了用于&lt;span&gt;数字签名的算法&lt;/span&gt;及其&lt;span&gt;密钥&lt;/span&gt;，创建该对象的原因仅仅是JwtSecurityToken对象需要它来完成Token创建。&lt;br/&gt;　　● 通过JwtSecurityToken对象创建Token，该对象的创建需要发布者(issuer)、观众(audience)、用户Claims信息、发布时间、有效期以及数字签名需要的算法及密钥等。&lt;br/&gt;　　● 通过JwtSecurityTokenHandler完成对Token的序列化。&lt;/p&gt;
&lt;p&gt;　　3. 在AuthenticationTicket中加入Audience信息。&lt;br/&gt;　　上面在创建Token时提到了需要Audience信息，而Token是通过AuthenticationTicket创建的，所以需要在创建AuthenticationTicket时加入Audience信息，另外上面也提到AuthenticationTicket的两种创建方法，这里使用的方法就是在“登录”时创建的，而OAuth的“登录”是通过不同类型的“授权”方式实现的，所以要加入Audience信息，只需要在相应方式的授权代码中添加即可(以基于用户名、密码的模式为例，其它方法复制代码即可)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123165411303-1330504267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 为Audience(Client)添加用于解析Token的JwtBearerAuthentication中间件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123165540131-78182820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Audience或者说Client包含了受限制的资源，当要访问这些资源时就需要解析Token完成身份验证。而Audience之间或者是Client之间是相对独立的，所以它应该限制可访问的Audience以及拥有自己的加密密钥，甚至还需要验证发布者以确定token的安全性。(&lt;span&gt;注：本例将身份验证服务器和Client都包含在同一个应用中，实际应用可将其分开，这样就是一个简单的单点登录系统&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;　　5. 运行程序&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123165840381-1493772670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用该Token能够正常访问受限资源：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123170000069-1302906340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是将Token Base64解码后的结果，可以看到Jwt包含的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123170222740-17325062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果使用test2这个Client获取的Token，将无法访问test1保护的资源：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123170024959-1842446132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　身份验证失败，跳转登录页面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201801/640251-20180123170046240-1552509717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;OAuth与OpenID Connect&lt;/h2&gt;
&lt;p&gt;　　OAuth与OpenID Connect是经常一起出现的两个名词，前者在本系列文章中已经进行过介绍，OAuth是一个授权协议，但是有点矛盾的就是身份验证和授权实际上是两个概念，前面文章也提到过的，身份验证的目的是知道“你”是谁，而授权则是判断“你”是否有权限访问资源。但是从上一篇文章开始介绍的OAuth相关的内容都是用来做身份验证。授权协议用来做身份验证，所以说是矛盾的。&lt;br/&gt;　　OpenID Connect就是为了弥补OAuth协议的缺陷，而在OAuth协议基础上进行补充拓展的一个身份验证协议。它包含了如发现服务、动态注册、Session管理、注销机制等新的高级特性。&lt;br/&gt;　　使用OAuth来做身份验证，只是因为OAuth相对简单，适合小型项目，这个与OAuth是授权协议还是身份验证协议无关，它&lt;span&gt;关注的是能否满足需求&lt;/span&gt;，包括app.UseOAuthBearerAuthentication方法名称都是Authentication而不是Authorization，通过添加OAuth Bearer身份验证中间件来实现身份验证。OpenID Connect更适合于大型项目，在这里就不再深入介绍。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本章介绍了Jwt以及Jwt在.Net中的实现，并介绍了在.Net中如何使用Jwt Token实现基于OAuth的身份验证。使用Jwt Token最主要的是为了解决不同应用的Token识别问题。&lt;br/&gt;　　最后简单的说明了OAuth与OpenID Connect的区别，它们取舍的关键点在于需求，对于小型应用来说OAuth就能够满足，而由于OpenID Connect非常复杂，如果有需求时也可以先考虑使用如IdentityServer这些开源组件。&lt;/p&gt;

&lt;p&gt;　　与身份验证相关的内容暂时到此，关于.Net安全相关内容可以参考下面的博客，非常全面包含了身份验证以及.Net中的加解密等内容：&lt;a href=&quot;https://dotnetcodr.com/security-and-cryptography/%20&quot; target=&quot;_blank&quot;&gt;https://dotnetcodr.com/security-and-cryptography/ &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://dzone.com/articles/whats-better-oauth-access-tokens-or-json-web-token&quot; target=&quot;_blank&quot;&gt;https://dzone.com/articles/whats-better-oauth-access-tokens-or-json-web-token&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/32964774/oauth-or-jwt-which-one-to-use-and-why&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/32964774/oauth-or-jwt-which-one-to-use-and-why&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://openid.net/specs/draft-jones-oauth-jwt-bearer-03.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/draft-jones-oauth-jwt-bearer-03.html&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://tools.ietf.org/html/rfc7523&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc7523&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://auth0.com/learn/json-web-tokens/&quot; target=&quot;_blank&quot;&gt;https://auth0.com/learn/json-web-tokens/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/18677837/decoding-and-verifying-jwt-token-using-system-identitymodel-tokens-jwt&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/18677837/decoding-and-verifying-jwt-token-using-system-identitymodel-tokens-jwt&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://www.c-sharpcorner.com/UploadFile/4b0136/openid-connect-availability-in-owin-security-components/&quot; target=&quot;_blank&quot;&gt;http://www.c-sharpcorner.com/UploadFile/4b0136/openid-connect-availability-in-owin-security-components/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://security.stackexchange.com/questions/94995/oauth-2-vs-openid-connect-to-secure-api&quot; target=&quot;_blank&quot;&gt;https://security.stackexchange.com/questions/94995/oauth-2-vs-openid-connect-to-secure-api&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.cnblogs.com/linianhui/archive/2017/05/30/openid-connect-core.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linianhui/archive/2017/05/30/openid-connect-core.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET OAuth、jwt、OpenID Connect&quot; href=&quot;http://www.cnblogs.com/selimsong/p/8184904.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/8184904.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/8184904.html</dc:identifier>
</item>
<item>
<title>Oracle实战笔记（第三天） - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/8331825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/8331825.html</guid>
<description>&lt;h2&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;今天的主要内容有：java连接Oracle、事务、Oracle中的事务处理、Oracle函数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Java连接Oracle的两种方式&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　第一种：桥连接（JDBC_ODBC）（不推荐）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;1、准备工作：桥连接需要&lt;strong&gt;配置ODBC数据源&lt;/strong&gt;，本机必须有安装了Oracle数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤：打开控制面板  &amp;gt;  管理工具   &amp;gt;   ODBC数据源   &amp;gt;   添加   &amp;gt;    选择你安装的Oracle驱动程序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180122212231944-1985650835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;测试一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180122212424522-2009123278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果用户名和密码没有错误，就会出现连接成功的标志！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180122212818928-1609913711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2、使用java代码连接Oracle数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这些步骤几乎都是固定的，具体看代码即可：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.sql.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 使用JDBC_ODBC桥连接Oracle数据库。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestJDBC_ODBC {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、加载驱动(注意：jdk1.8版本已经删除了这个驱动，如果要运行需要切换到其他版本)&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             Class.forName(&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、获得连接(其中myOracle是数据源的名称，scott和tiger分别是要连接的账户和密码)&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             Connection conn = DriverManager.getConnection(&quot;jdbc:odbc:myOracle&quot;, &quot;scott&quot;, &quot;tiger&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面就是使用conn这个连接对象来操作数据库
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得sql语句执行对象&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             Statement sm =&lt;span&gt; conn.createStatement();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql语句并返回到结果集对象ResulSet中&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             ResultSet rs = sm.executeQuery(&quot;select * from emp&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询emp表
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理结果集：打印到控制台&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()){  
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 System.out.println(&quot;员工姓名：&quot;+rs.getString(2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　第二种：使用JDBC直接连接（推荐）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;1、准备工作：&lt;strong&gt;导包&lt;/strong&gt;。这种方式不需要配置数据源而是使用商家提供的jar包进行连接，而且支持远程连接，就是说本机不安装数据库也能连接到远程的数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Oracle不同的版本有不同的jar包，我们可以上网搜索，或者更简单的办法，打开安装目录就能找到相应jar包：（比如我的安装目录）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180122224701334-787653492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2、java代码连接数据库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; import java.sql.&lt;span&gt;*&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用jdbc连接Oracle
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; class Testjdbc {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;@Test&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; void test(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、加载驱动
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、获得连接(注：&lt;span&gt;@后面写连接的ip地址&lt;/span&gt;&lt;span&gt;，后面分别是Oracle默认端口号1521:数据库名称,账户名和密码)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             Connection conn &lt;span&gt;=&lt;/span&gt; DriverManager.getConnection(&quot;jdbc:oracle:thin:&lt;span&gt;@192&lt;/span&gt;.&lt;span&gt;168.183&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1521&lt;/span&gt;&lt;span&gt;:ORCL&quot;, &quot;scott&quot;, &quot;tiger&quot;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、获得sql语句执行对象
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Statement st &lt;span&gt;=&lt;/span&gt;&lt;span&gt; conn.createStatement();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、书写sql语句
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             String sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询emp表
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、执行sql并将结果保存到结果集ResultSet中
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             ResultSet rs &lt;span&gt;=&lt;/span&gt;&lt;span&gt; st.executeQuery(sql);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;、处理结果集
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(rs.&lt;span&gt;next&lt;/span&gt;&lt;span&gt;()){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 System.out.println(&quot;员工姓名：&quot;&lt;span&gt;+&lt;/span&gt;rs.getString(&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;、关闭资源
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             rs.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             st.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180122224332569-1038478451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;：很明显，jdbc的连接方式更好，而桥连接不仅不支持远程连接，就连更新后的jdk1.8都删掉有odbc驱动包，所以尽量使用jdbc以减少不必要的麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、子查询：补充内容&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、使用子查询插入数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;昨天的内容中我们使用子查询创建了新表，即：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;使用子查询创建新表&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; emp(eid,ename,sal) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; empno,ename,sal &lt;span&gt;from&lt;/span&gt; emp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这样的创表方式会将旧表中对应字段所有数据都更新到新表中，如果我们只需要工资大于2000的员工数据，除了删除数据我们还可以用子查询查入需要的数据：（相当于values()用select语句替换了）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;清空emp2表&lt;/span&gt;
trancate &lt;span&gt;table&lt;/span&gt;&lt;span&gt; emp2;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;使用子查询插入数据&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp2(eid,ename,sal) &lt;span&gt;select&lt;/span&gt; empno,ename,sal &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; sal&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、使用子查询更新数据&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;同样的，除了插入数据，也能更新数据：（修改语句为：update 表名 set column1=value1,...where...，同样的我们将Value部分用select语句替代即可）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;将BLAKE的job、sal和comm改为和SMITH一样&lt;/span&gt;
&lt;span&gt;update&lt;/span&gt; emp &lt;span&gt;set&lt;/span&gt; (job,sal,comm) &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; job,sal,comm &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; ename&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SMITH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; ename&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BLAKE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;三、Oracle事务（Transaction）&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　1、事务的概念&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;事务机制是为了保证数据的一致性，由一组DML（数据操作语言）语句组成，在一个事务中，这些语句要么全部失败，要么全部成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　转账就是一个很典型的事务管理机制。比如张三给李四转账1000大洋，银行的转账业务处理过程大概可以分为两个步骤：1、从张三的账户减1000大洋；2、然后再往李四的账户加1000大洋。这两个过程对于数据库就相当于两句DML语句，一句是update张三的账户金额，另一句是update李四的账户金额。如果转账的时候顺顺利利是没什么问题的，关键在于如果在转账这一过程中出现了问题，比如李四的账号输错，变成了不存在的账号，那么张三的账户会扣掉1000大洋而李四的账户并不会收到转账，最终这1000大洋不翼而飞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　总而言之，为了保证数据的一致性（好比转账的这1000大洋），我们通常使用事务来管理数据库。上面的转账例子中，如果使用了事务，我们知道DML语句要么失败、要么成功 ，所以当无法转账到李四账户时第二条update语句失败，就会导致整个转账失败，进而之前的一切操作都变为无效。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、事务的4个特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;原子性&lt;/strong&gt;：说的是在一个事务内是不可分割的，要么成功，要么失败。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一致性&lt;/strong&gt;：事务的前后数据的变化的一致性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：是指事务之间互不干扰和影响，即并发执行事务时&lt;strong&gt;应当&lt;/strong&gt;按照是连续地执行、互不干扰地执行(一个接一个)。（数据库可设置隔离级别，见下文）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;持久性&lt;/strong&gt;：简单说就是事务一旦执行成功就持久化到数据库中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　3、事务的隔离级别&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;事务的隔离级别从低到高有：（不同的隔离级别涉及不同的并发访问问题）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Read Uncommitted（读未提交）&lt;/strong&gt;：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都可能会发生。　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Read Committed（读已提交）   &lt;/strong&gt; ：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Repeated Read（可重复读）    &lt;/strong&gt;   ：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Serialization（串行化）              &lt;/strong&gt;  ：理想的真正的事务隔离性，事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 　　4、隔离级导致的并发访问问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;脏读&lt;/strong&gt;(Drity Read)：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;(Non-repeatable read) : 在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这导致锁竞争加剧，影响性能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;幻读（虚读）&lt;/strong&gt;(Phantom Read) : 在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读仅指由于并发事务增加记录导致的问题，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180123001608381-330744238.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;四、Oracle中的事务处理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　1、相关概念&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;回滚&lt;/strong&gt;：发送异常时，使数据恢复到事务开启前的状态，即整个事务执行失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;strong&gt;提交&lt;/strong&gt;：事务执行成功，数据会持久化到数据库。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、基本演示&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;Oracle中的事务默认是关闭的，所以需要手动开启事务，并设置回滚和提交的位置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; void test(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Oracle事务案例：
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Connection conn &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    try {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接数据库
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         conn &lt;span&gt;=&lt;/span&gt; DriverManager.getConnection(&quot;jdbc:oracle:thin:&lt;span&gt;@192&lt;/span&gt;.&lt;span&gt;168.183&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1521&lt;/span&gt;&lt;span&gt;:ORCL&quot;, &quot;scott&quot;, &quot;tiger&quot;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----[开启事务]：我们在执行sql前开启事务&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        conn.setAutoCommit(false);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql语句
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Statement st &lt;span&gt;=&lt;/span&gt;&lt;span&gt; conn.createStatement();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         String sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;update&lt;/span&gt; emp &lt;span&gt;set&lt;/span&gt; sal&lt;span&gt;=&lt;/span&gt;sal&lt;span&gt;-&lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; ename&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SMITH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将smith的工资降低500
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        st.executeUpdate(sql);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;update&lt;/span&gt; emp &lt;span&gt;set&lt;/span&gt; sal&lt;span&gt;=&lt;/span&gt;sal&lt;span&gt;+&lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; ename&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BLAKE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将blake的工资涨500
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        st.executeUpdate(sql);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------[回滚]：如果发生异常，说明事务执行失败，需要回滚&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             conn.&lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        } catch (SQLException e1) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }finally{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----------[提交事务]：如果程序执行到最后，说明一切顺利，需要提交事务来持久化数据&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             conn.&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             conn.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        } catch (SQLException e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;ps：在命令行中：我们也可以通过设置保存点savepoint达到开启事务的效果，用法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180123010023990-560937577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;3、只读事务：read only&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;说明：只读事务处理顾名思义，就是只能让用户进行读取（查询）操作。只读事务不只是限制作用，使用只读事务能确保用户读取某个时间点的数据，比如购票系统管理员需要每天18时开始统计售票情况，但可能在18时的时候任然有人在进行购票或退票的操作，这样统计出来的数据就不够准确，所以管理员可以在18时这个时间点设置只读事务，那么管理员就可以读取这个时间点的数据而不受其他并发操作的影响。所以只读事务常用于&lt;strong&gt;某个时间点的信息统计&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;设置&lt;/strong&gt;：sql &amp;gt; set transaction read only ;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;五、Oracle函数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;1、字符函数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;lower(char)&lt;/strong&gt;        ：将字符串转化为小写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;upper(char) &lt;/strong&gt;       ：将字符串转化为大写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;length(char) &lt;/strong&gt;      ：获得字符串的长度&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;&lt;strong&gt;substr(char,m,n)&lt;/strong&gt;：截取字符串（从1标号）角标为[m,n]的子串。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;将员工姓名首字母大写，其余小写&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;upper&lt;/span&gt;(substr(ename,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;||&lt;/span&gt; &lt;span&gt;lower&lt;/span&gt;(substr(ename,&lt;span&gt;2&lt;/span&gt;,length(ename))) &lt;span&gt;from&lt;/span&gt; emp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;strong&gt;replace(char,search_str,replace_str)&lt;/strong&gt;：字符串替换。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;假设员工名中的字母S需要用*和谐后才显示&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;replace&lt;/span&gt;(ename,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; emp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;strong&gt;instr(char1,char2,[,n[,m]])&lt;/strong&gt;：返回字符串char2在char1中首次出现的的位置。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;返回S在员工名字中首次出现的位置&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; instr(ename,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; emp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　2、数学函数&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;数学函数的参数和返回值都是数字类型，数学函数包括：cos、cosh、exp、In、log、sin、sinh、sqrt、tan、tanh、acos、atan、asin、round等，我们掌握常用的即可：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;round(n [,m])：&lt;/strong&gt;四舍五入数字n：如果省略m，那么四舍五入为整数；如果m是整数，则四舍五入到小数点后m位（相当于保留m位小数）；如果m是负数，则四舍五入到小数点前-m位。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;trunc(n  [,m])：&lt;/strong&gt; 截取数字n：如果省略m，那么就截取整数部分，即保留整数部分；如果m是整数，则截取到小数点后m位（相当于保留m位小数）；如果m是负数，则截取到小数点前-m位。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;mod(m,n)    ：&lt;/strong&gt;取模。（取模运算和取余运算的数值是相同的，区别在于符号不同：取模运算结果的符号和除数的符号一致，而取余运算的符号和被除数的符号一致,比如：10 模 -3 = -1；10 余 -3 = 1;）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;floor(n)        ：&lt;/strong&gt;floor是地板的意思，  所以返回 ≤ n的最大整数（向下取整）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;ceil(n)          ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;ceil是天花板的意思，所以返回 ≥ n的最小整数（向上取整）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;abs(n)          ：&lt;/strong&gt;返回绝对值。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　3、日期函数&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;默认的date格式为：yy-mon-dd即18-1月-23的形式。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;sysdate&lt;/strong&gt;：返回系统时间&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;strong&gt;add_months(d,n)&lt;/strong&gt;：返回当前时间增加n个月后的时间。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;查找入职满3年的员工姓名&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; ename &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; sysdate&lt;span&gt;&amp;gt;=&lt;/span&gt;add_months(hiredate,&lt;span&gt;12&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;返回员工加入公司的天数（保留整数）&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; ename,ceil(sysdate&lt;span&gt;-&lt;/span&gt;hiredate) &quot;入职天数&quot; &lt;span&gt;from&lt;/span&gt; emp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;strong&gt;last_day(d)&lt;/strong&gt;：返回指定日期所在月份的最后一天。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询入职月刚好最后一天入职的员工姓名和入职时间&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; ename,hiredate &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; hiredate &lt;span&gt;=&lt;/span&gt;&lt;span&gt; last_day(hiredate);
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询入职月倒数前5天的员工姓名&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; ename,hiredate &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; hiredate &lt;span&gt;&amp;gt;=&lt;/span&gt; last_day(hiredate)&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　4、转换函数&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;转换函数是Oracle用来进行数据类型转换的函数，比如number = 9527，就能转换为char类型。注意这个现象：比如我们往emp表中插入数据时，ename即员工姓名是vachar2类型，但是如果我们插入时输入的值是数字，那么这个语句不会报错，因为Oracle在插入数据时会尝试将不匹配的数据类型进行转换，如果成功就继续插入，这就是Oracle隐含转换的一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  有的转换函数需要指定转换后的格式，Oracle格式符号规定如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;strong&gt;to_char(data [,str_form])&lt;/strong&gt;：将数据转换为char类型，第二个可选参数为格式。注意：对于数字格式如果输入错误会返回若干#，代表转换失败。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询1980年入职的员工&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; ename,hiredate &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; to_char(hiredate,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yyyy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1980&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;to_date(str,form)&lt;/strong&gt;：将字符串为对应格式的日期。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;to_number(date)&lt;/strong&gt;：将数据转换为number类型。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　5、用户环境函数&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;userenv()即用户环境函数，是UserEnvironment的缩写，用法：&lt;span&gt;userenv('参数名')&lt;/span&gt;：返回用户所属环境的指定参数的参数值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如select userenv('language') from emp;就会返回emp表的环境语言。但userenv是一个遗留功能，这些功能是保留向后兼容性。甲骨文建议您使用SYS_CONTEXT函数使用内建的USERENV命名空间的当前功能。所以，我们尽量&lt;strong&gt;使用&lt;span&gt;sys_context('usernev','参数名')&lt;/span&gt;来代替userenv函数&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;参数名&lt;/strong&gt;是固定可选的，常用的有以下几种参数名：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;terminal            ：当前会话客户所对应的终端标识符。比如我的就是：LenovoPC。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;language          ：语言。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;db_name          ：数据库名。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;nls_date_format：当前会话客户对应的日期格式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;session_user    ：当前会话客户对应的数据用户名。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;current_schema：当前会话客户对应的默认方案名。（其实就是用户名，注意，一个用户对应一个方案，方案存储了很多数据对象）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;host      　　      ：返回数据库所在主机的名称。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 23 Jan 2018 14:18:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/8331825.html</dc:identifier>
</item>
<item>
<title>【Java提高】---枚举的应用 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8337514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8337514.html</guid>
<description>&lt;p&gt;    &lt;strong&gt;&lt;span&gt;一.枚举和静态常量区别                &lt;/span&gt;&lt;/strong&gt;       &lt;/p&gt;
&lt;p&gt;       讲到枚举我们首先思考，它和public static final String 修饰的常量有什么不同。&lt;/p&gt;
&lt;p&gt;        我举枚举的两个优点：&lt;/p&gt;
&lt;p&gt;     1. 保证了类型安全：调用者无法随意传一个 int或者String 等值；&lt;/p&gt;
&lt;p&gt;     2.代码可读性非常高；&lt;/p&gt;
&lt;p&gt;     举个例子：&lt;/p&gt;
&lt;p&gt;      在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。例如春夏秋冬四个数据元素组成了四季的“数据集”。&lt;br/&gt;你写了方法get(String season)，输入的类型只能是String类型，同时要String只能是（春、夏。秋。冬）。&lt;/p&gt;
&lt;p&gt;这个时候。你写四个字符串常量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Common {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SPRING=&quot;春&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SEASON=&quot;夏&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUMMER=&quot;秋&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String AUTUMN=&quot;冬&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     在get方法里放入get(Common.SEASON),确实是把&quot;春&quot;，放进去了，但是这个时候你会发现这里面有一个隐患,你get(String season),毕竟放入的是String类型的，如果新同事或者不知情的同事，不知道这个方法里只能放“春、夏、秋、冬”，它放了个其期它字符串比如get(&quot;小小“)，这个时候，在编译期它是不会报错的，只有运行之后，才发现错了。&lt;/p&gt;
&lt;p&gt;   为了防止上面的隐患，枚举出现了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Season {
        SPRING(&lt;/span&gt;&quot;春&quot;&lt;span&gt;),
        SUMMER(&lt;/span&gt;&quot;夏&quot;&lt;span&gt;),
        AUTUMN(&lt;/span&gt;&quot;秋&quot;&lt;span&gt;),
        WINTER(&lt;/span&gt;&quot;冬&quot;&lt;span&gt;);
   .....
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这个时候，我们修改get方法的传参，改成get(Season   season)   这个时候加入get(Season.SPRING),这就能保证传入的参数只能是这几个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.理解枚举                                    &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        首要我们要明确，其实枚举也是个class类，我写个枚举来理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们把枚举当做一个普通类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Season {
    SPRING(&lt;/span&gt;1,&quot;春&quot;&lt;span&gt;),
    SUMMER(&lt;/span&gt;2,&quot;夏&quot;&lt;span&gt; ),
    AUTUMN(&lt;/span&gt;3,&quot;秋&quot;&lt;span&gt; ),
    WINTER(&lt;/span&gt;4,&quot;冬&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里最后一个一定要分号，否则报错&lt;/span&gt;
    
    &lt;span&gt;/*我们可以理解成&lt;/span&gt;&lt;span&gt;
     *public static final Season SPRING = new Season(1,春); 
     *public static final Season SUMMER = new Season(2,夏); 
     *public static final Season AUTUMN = new Season(3,秋); 
     *public static final Season WINTER = new Season(4,冬); 
     *既然是对象，那下面就很好理解了
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 1.上面对象里放了两个参数，那下面就肯定要有这个类型的构造函数
     * 2.这里是private，因为不能在被new对象了
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Season(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code,String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象的属性&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; code;

    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象属性的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过code获得对象，我们就可以获得对象的其它属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Season decode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code) {
        Season season &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Season type : Season.values()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type.code==&lt;span&gt;code) {
                season &lt;/span&gt;=&lt;span&gt; type;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; season;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新toString方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      上面这个例子，就很好解释了枚举，它和普通类没什么区别，只是用另一种写法创建了几个有属性的对象，这也必须写这样有属性的构造函数，仅此而已。&lt;/p&gt;
&lt;p&gt;这里顺便列举下枚举的一些特点：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;  &lt;span&gt;&lt;span&gt;1&lt;/span&gt;．它不能有public的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;2&lt;/span&gt;.  枚举不能在继承其它类了，因为它默认继承了java.lang.Enum&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;3&lt;/span&gt;.  常量值地址唯一,可以用==直接对比,性能会有提高.&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;4&lt;/span&gt;．Enum还提供了values方法，这个方法使你能够方便的遍历所有的枚举值。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;5&lt;/span&gt;．Enum还有一个oridinal的方法，这个方法返回枚举值在枚举类种的顺序，这个顺序根据枚举值声明的顺序而定。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三.枚举的常见用法                           &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一种：switch运用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先建一个枚举：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Common {

    INSERT,
    MODIFY,
    DELETE
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为这里是无参的对象，所以可以用系统默认的构造函数。也不用写属性和方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在写实现代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonUtils {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getType(Common common){
        Common c&lt;/span&gt;=&lt;span&gt;common;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(c)
        {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; INSERT:
            System.out.println(&lt;/span&gt;&quot;进行插入操作&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MODIFY:
            System.out.println(&lt;/span&gt;&quot;进行修改操作&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DELETE:
            System.out.println(&lt;/span&gt;&quot;进行删除操作&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }    
        
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        getType(Common.DELETE);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台输出：进行删除操作&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二种用法，通过key值获得value值获取其它值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  枚举类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Season {
    SPRING(&lt;/span&gt;1,&quot;春&quot;,&quot;春天放风筝&quot;&lt;span&gt;),
    SUMMER(&lt;/span&gt;2,&quot;夏&quot;,&quot;夏天去游泳&quot;&lt;span&gt;),
    AUTUMN(&lt;/span&gt;3,&quot;秋&quot;,&quot;秋天去秋游&quot;&lt;span&gt;),
    WINTER(&lt;/span&gt;4,&quot;冬&quot;,&quot;冬天吃火锅&quot;&lt;span&gt;);  
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Season(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code,String name,String bz) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bz=&lt;span&gt;bz;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; code;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String bz;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Season decode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code) {
        Season season &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Season type : Season.values()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type.code==&lt;span&gt;code) {
                season &lt;/span&gt;=&lt;span&gt; type;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; season;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBz() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bz;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1090617/201801/1090617-20180123220446162-2092561451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，就写这么多，以后有需要会更深入了解。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【18】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jan 2018 14:17:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8337514.html</dc:identifier>
</item>
<item>
<title>Generator函数异步应用 - unclekeith</title>
<link>http://www.cnblogs.com/unclekeith/p/8335279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/unclekeith/p/8335279.html</guid>
<description>&lt;p&gt;转载请注明出处: &lt;a href=&quot;http://www.cnblogs.com/unclekeith/p/8335279.html&quot;&gt;Generator函数异步应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章详细的介绍了Generator函数的语法，这篇文章来说一下如何使用Generator函数来实现异步编程。&lt;/p&gt;
&lt;p&gt;或许用Generator函数来实现异步会很少见，因为ECMAScript 2016的async函数对Generator函数的流程控制做了一层封装，使得异步方案使用更加方便。&lt;/p&gt;
&lt;p&gt;但是呢，我个人认为学习async函数之前，有必要了解一下Generator如何实现异步，这样对于async函数的学习或许能给予一些帮助。&lt;/p&gt;
&lt;h2 id=&quot;文章目录&quot;&gt;文章目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;知识点简单回顾&lt;/li&gt;
&lt;li&gt;异步任务的封装&lt;/li&gt;
&lt;li&gt;thunk函数实现流程控制&lt;/li&gt;
&lt;li&gt;Generator函数的自动流程控制&lt;/li&gt;
&lt;li&gt;co模块的自动流程控制&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;知识点简单回顾&quot;&gt;知识点简单回顾&lt;/h3&gt;
&lt;p&gt;在Generator函数语法解析篇的文章中有说到，Generator函数可以定义多个内部状态，同时也是遍历器对象生成函数。yield表达式可以定义多个内部状态，同时还具有暂停函数执行的功能。调用Generator函数的时候，不会立即执行，而是返回遍历器对象。&lt;/p&gt;
&lt;p&gt;遍历器对象的原型对象上具有next方法，可以通过next方法恢复函数的执行。每次调用next方法，都会在遇到yield表达式时停下来，再次调用的时候，会在停下的位置继续执行。调用next方法会返回具有value和done属性的对象，value属性表示当前的内部状态，可能的值有yield表达式后面的值、return语句后面的值和undefined；done属性表示遍历是否结束。&lt;/p&gt;
&lt;p&gt;yield表达式默认是没有返回值的，或者说，返回值为undefined。因此，想要获得yield表达式的返回值，就需要给next方法传递参数。next方法的参数表示上一个yield表达式的返回值。因此在调用第一个next方法时可以不传递参数(即使传递参数也不会起作用)，此时表示启动遍历器对象。所以next方法会比yield表达式的使用要多一次。&lt;/p&gt;
&lt;p&gt;更加详细的语法可以参考这篇文章。传送门：&lt;a href=&quot;http://www.cnblogs.com/unclekeith/p/8325465.html&quot;&gt;Generator函数语法解析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;异步任务的封装&quot;&gt;异步任务的封装&lt;/h3&gt;
&lt;p&gt;yield表达式可以暂停函数执行，next方法可以恢复函数执行。这使得Generator函数非常适合将异步任务同步化。接下来会使用setTimeout来模拟异步任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = sex =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    window.setTimeout(() =&amp;gt; {
      const data = {
        sex,
        name: 'keith',
        height: 180
      }
      resolve(data)
    }, 1000)
  })
}
function *gen () {
  const data = yield person('boy')
  console.log(data)
}
const g = gen()
const next1 = g.next() // {value: Promise, done: false}
next1.value.then(data =&amp;gt; {
  g.next(data)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出，第一次调用next方法时，启动了遍历器对象，此时返回了包含value和done属性的对象，由于value属性值是promise对象，因此可以使用then方法获取到resolve传递过来的值，再使用带有data参数的next方法给上一个yield表达式传递返回值。&lt;/p&gt;
&lt;p&gt;此时在&lt;code&gt;const data = yield person()&lt;/code&gt;这句语句中，就可以得到异步任务传递的参数值了，实现了异步任务的同步化。&lt;/p&gt;
&lt;p&gt;但是上面的代码会有问题。每次获取异步的值时，都要手动执行以下步骤&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const g = gen()
const next1 = g.next() {value: Promise, done: false}
next1.value.then(data =&amp;gt; {
  g.next(data)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码实质上就是每次都会重复使用value属性值和next方法，所以每次使用Generator实现异步都会涉及到流程控制的问题。每次都手动实现流程控制会显得麻烦，有没有什么办法可以实现自动流程控制呢？实际上是有的: )&lt;/p&gt;
&lt;h3 id=&quot;thunk函数实现流程控制&quot;&gt;thunk函数实现流程控制&lt;/h3&gt;
&lt;p&gt;thunk函数实际上有些类似于JavaScript函数柯里化，会将某个函数作为参数传递到另一个函数中，然后通过闭包的方式为参数(函数)传递参数进而实现求值。&lt;/p&gt;
&lt;p&gt;函数柯里化实现的过程如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function curry (fn) {
  const args1 = Array.prototype.slice.call(arguments, 1)
  return function () {
    const args2 = Array.from(arguments)
    const arr = args1.concat(args2)
    return fn.apply(this, arr)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用curry函数来举一个例子: )&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 需要柯里化的sum函数
const sum = (a, b) =&amp;gt; {
  return a + b
}
curry(sum, 1)(2)   // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而thunk函数简单的实现思路如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// ES5实现
const thunk = fn =&amp;gt; {
  return function () {
    const args = Array.from(arguments)
    return function (callback) {
      args.push(callback)
      return fn.apply(this, args)
    }
  }
}

// ES6实现
const thunk = fn =&amp;gt; {
  return function (...args) {
    return function (callback) {
      return fn.call(this, ...args, callback)
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面thunk函数中，会发现，thunk函数比函数curry化多用了一层闭包来封装函数作用域。&lt;/p&gt;
&lt;p&gt;使用上面的thunk函数，可以生成&lt;code&gt;fs.readFile&lt;/code&gt;的thunk函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const fs = require('fs')
const readFileThunk = thunk(fs.readFile)
readFileThunk(fileA)(callback)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用thunk函数将&lt;code&gt;fs.readFile&lt;/code&gt;包装成&lt;code&gt;readFileThunk&lt;/code&gt;函数，然后在通过&lt;code&gt;fileA&lt;/code&gt;传入文件路径，&lt;code&gt;callback&lt;/code&gt;参数则为&lt;code&gt;fs.readFile&lt;/code&gt;的回调函数。&lt;/p&gt;
&lt;p&gt;当然，还有一个thunk函数的升级版本thunkify函数，可以使得回调函数只执行一次。原理和上面的thunk函数非常像，只不过多了一个flag参数用于限制回调函数的执行次数。下面我对thunkify函数做了一些修改。源码地址: &lt;a href=&quot;https://github.com/tj/node-thunkify&quot;&gt;node-thunkify&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const thunkify = fn =&amp;gt; {
  return function () {
    const args = Array.from(arguments)
    return function (callback) {
      let called = false
      // called变量限制callback的执行次数
      args.push(function () {
        if (called) return
        called = true
        callback.apply(this, arguments)
      })
      try {
        fn.apply(this, args)
      } catch (err) {
        callback(err)
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举个例子看看: )&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function sum (a, b, callback) {
  const total = a + b
  console.log(total)
  console.log(total)
}

// 如果使用thunkify函数
const sumThunkify = thunkify(sum)
sumThunkify(1, 2)(console.log)
// 打印出3

// 如果使用thunk函数
const sumThunk = thunk(sum)
sumThunk(1, 2)(console.log)
// 打印出 3, 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看一个使用setTimeout模拟异步并且使用thunkify模块来完成异步任务同步化的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = (sex, fn) =&amp;gt; {
  window.setTimeout(() =&amp;gt; {
    const data = {
      sex,
      name: 'keith',
      height: 180
    }
    fn(data)
  }, 1000)
}
const personThunk = thunkify(person)
function *gen () {
  const data = yield personThunk('boy')
  console.log(data)
}
const g = gen()
const next = g.next()
next.value(data =&amp;gt; {
  g.next(data)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出，value属性实际上就是thunkify函数的回调函数(也是person的第二个参数)，而'boy'则是person的第一个参数。&lt;/p&gt;
&lt;h3 id=&quot;generator函数的自动流程控制&quot;&gt;Generator函数的自动流程控制&lt;/h3&gt;
&lt;p&gt;在上面的代码中，我们可以将调用遍历器对象生成函数，返回遍历器和手动执行next方法以恢复函数执行的过程封装起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const run = gen =&amp;gt; {
  const g = gen()
  const next = data =&amp;gt; {
    let result = g.next(data)
    if (result.done) return result.value
    result.value(next)
  }
  next()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用run函数封装起来之后，run内部的next函数实际上就是thunk(thunkify)函数的回调函数了。因此，调用run即可实现Generator的自动流程控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = (sex, fn) =&amp;gt; {
  window.setTimeout(() =&amp;gt; {
    const data = {
      sex,
      name: 'keith',
      height: 180
    }
    fn(data)
  }, 1000)
}
const personThunk = thunkify(person)
function *gen () {
  const data = yield personThunk('boy')
  console.log(data)
}
run(gen)
// {sex: 'boy', name: 'keith', height: 180}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个执行器，执行Generator函数就方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是thunk(thunkify)函数。也就是说，跟在yield表达式后面的必须是thunk(thunkify)函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const gen = function *gen () {
  const f1 = yield personThunk('boy') // 跟在yield表达式后面的异步行为必须使用thunk(thunkify)函数封装
  const f2 = yield personThunk('boy')
  // ...
  const fn = yield personThunk('boy')
}
run(gen)  // run函数的自动流程控制&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，函数gen封装了n个异步行为，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。&lt;/p&gt;
&lt;h3 id=&quot;co模块的自动流程控制&quot;&gt;co模块的自动流程控制&lt;/h3&gt;
&lt;p&gt;在上面的例子说过，表达式后面的值必须是thunk(thunkify)函数，这样才能实现Generator函数的自动流程控制。thunk函数的实现是基于回调函数的，而co模块则更进一步，可以兼容thunk函数和Promise对象。先来看看co模块的基本用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const co = require('co')
const gen = function *gen () {
  const f1 = yield person('boy') // 调用person，返回一个promise对象
  const f2 = yield person('boy')
}
co(gen)   // 将thunk(thunkify)函数和run函数封装成了co模块，yield表达式后面可以是thunk(thunkify)函数或者Promise对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;co模块可以不用编写Generator函数的执行器，因为它已经封装好了。将Generator函数co模块中，函数就会自动执行。&lt;/p&gt;
&lt;p&gt;co函数返回一个Promise对象，因此可以用then方法添加回调函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;co(gen).then(function (){
  console.log('Generator 函数执行完成')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;co模块原理&lt;/strong&gt;；co模块其实就是将两种自动执行器(thunk(thunkify)函数和Promise对象)，包装成一个模块。使用co模块的前提条件是，Generator函数的yield表达式后面，只能是thunk(thunkify)或者Promise对象，如果是数组或对象的成员全部都是promise对象，也可以使用co模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于Promise对象的自动执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是使用上面例子，不过这次是将回调函数改成Promise对象来实现自动流程控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = (sex, fn) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    window.setTimeout(() =&amp;gt; {
      const data = {
        name: 'keith',
        height: 180
      }
      resolve(data)
    }, 1000)
  })
}
function *gen () {
  const data = yield person('boy')
  console.log(data)   // {name: 'keith', height: 180}
}
const g = gen()
g.next().value.then(data =&amp;gt; {
  g.next(data)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手动执行实际上就是层层使用then方法和next方法。根据这个可以写出自动执行器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const run = gen =&amp;gt; {
  const g = gen()
  const next = data =&amp;gt; {
    let result = g.next(data)
    if (result.done) return result.value
    result.value.then(data =&amp;gt; {
      next(data)
    })
  }
  next()
}
run(gen)  // {name: 'keith', height: 180}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对co模块感兴趣的朋友，可以阅读一下它的源码。传送门：&lt;a href=&quot;https://github.com/tj/co/blob/master/index.js&quot;&gt;co&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Generator异步应用的相关知识也就差不多了，现在稍微总结一下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于yield表达式可以暂停执行，next方法可以恢复执行，这使得Generator函数很适合用来将异步任务同步化。&lt;/li&gt;
&lt;li&gt;但是Generator函数的流程控制会稍显麻烦，因为每次都需要手动执行next方法来恢复函数执行，并且向next方法传递参数以输出上一个yiled表达式的返回值。&lt;/li&gt;
&lt;li&gt;于是就有了thunk(thunkify)函数和co模块来实现Generator函数的自动流程控制。&lt;/li&gt;
&lt;li&gt;通过thunk(thunkify)函数分离参数，以闭包的形式将参数逐一传入，再通过apply或者call方法调用，然后配合使用run函数可以做到自动流程控制。&lt;/li&gt;
&lt;li&gt;通过co模块，实际上就是将run函数和thunk(thunkify)函数进行了封装，并且yield表达式同时支持thunk(thunkify)函数和Promise对象两种形式，使得自动流程控制更加的方便。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/generator-async&quot;&gt;Generator 函数的异步应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tj/node-thunkify&quot;&gt;node-thunkify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tj/co&quot;&gt;co&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 23 Jan 2018 14:03:00 +0000</pubDate>
<dc:creator>unclekeith</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/unclekeith/p/8335279.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（十二）——2-3-4树 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8032648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8032648.html</guid>
<description>&lt;p&gt;　　通过前面的介绍，我们知道在二叉树中，每个节点只有一个数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树。本篇博客我们将介绍的——2-3-4树，它是一种多叉树，它的每个节点最多有四个子节点和三个数据项。&lt;/p&gt;
&lt;h3&gt;1、2-3-4 树介绍&lt;/h3&gt;
&lt;p&gt; 　　2-3-4树每个节点最多有四个字节点和三个数据项，名字中 2,3,4 的数字含义是指一个节点可能含有的子节点的个数。对于非叶节点有三种可能的情况：&lt;/p&gt;
&lt;p&gt;　　①、有一个数据项的节点总是有两个子节点；&lt;/p&gt;
&lt;p&gt;　　②、有二个数据项的节点总是有三个子节点；&lt;/p&gt;
&lt;p&gt;　　③、有三个数据项的节点总是有四个子节点；&lt;/p&gt;
&lt;p&gt;　　简而言之，非叶节点的子节点数总是比它含有的数据项多1。如果子节点个数为L，数据项个数为D，那么：L = D + 1&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226112102197-1039452950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　叶节点（上图最下面的一排）是没有子节点的，然而它可能含有一个、两个或三个数据项。空节点是不会存在的。&lt;/p&gt;
&lt;p&gt;　　树结构中很重要的一点就是节点之间关键字值大小的关系。在二叉树中，所有关键字值比某个节点值小的节点都在这个节点左子节点为根的子树上；所有关键字值比某个节点值大的节点都在这个节点右子节点为根的子树上。2-3-4 树规则也是一样，并且还加上以下几点：&lt;/p&gt;
&lt;p&gt;　　为了方便描述，用从0到2的数字给数据项编号，用0到3的数字给子节点编号，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226113026775-477236747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　①、根是child0的子树的所有子节点的关键字值小于key0；&lt;/p&gt;
&lt;p&gt;　　②、根是child1的子树的所有子节点的关键字值大于key0并且小于key1；&lt;/p&gt;
&lt;p&gt;　　③、根是child2的子树的所有子节点的关键字值大于key1并且小于key2；&lt;/p&gt;
&lt;p&gt;　　④、根是child3的子树的所有子节点的关键字值大于key2。&lt;/p&gt;
&lt;p&gt;　　简化关系如下图，由于2-3-4树中一般不允许出现重复关键值，所以不用考虑比较关键值相同的情况。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226113240119-1311134781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、搜索2-3-4树&lt;/h3&gt;
&lt;p&gt;　　查找特定关键字值的数据项和在二叉树中的搜索类似。从根节点开始搜索，除非查找的关键字值就是根，否则选择关键字值所在的合适范围，转向那个方向，直到找到为止。&lt;/p&gt;
&lt;p&gt;　　比如对于下面这幅图，我们需要查找关键字值为 64 的数据项。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226112102197-1039452950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先从根节点开始，根节点只有一个数据项50，没有找到，而且因为64比50大，那么转到根节点的子节点child1。60|70|80 也没有找到，而且60&amp;lt;64&amp;lt;70，所以我们还是找该节点的child1,62|64|66，我们发现其第二个数据项正好是64，于是找到了。&lt;/p&gt;
&lt;h3&gt;3、插入&lt;/h3&gt;
&lt;p&gt;　　新的数据项一般要插在叶节点里，在树的最底层。如果你插入到有子节点的节点里，那么子节点的编号就要发生变化来维持树的结构，因为在2-3-4树中节点的子节点要比数据项多1。&lt;/p&gt;
&lt;p&gt;　　插入操作有时比较简单，有时却很复杂。&lt;/p&gt;
&lt;p&gt;　　①、当插入没有满数据项的节点时是很简单的，找到合适的位置，只需要把新数据项插入就可以了，插入可能会涉及到在一个节点中移动一个或其他两个数据项，这样在新的数据项插入后关键字值仍保持正确的顺序。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226153619135-1719277702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②、如果往下寻找插入位置的途中，节点已经满了，那么插入就变得复杂了。发生这种情况时，节点必须分裂，分裂能保证2-3-4树的平衡。&lt;/p&gt;
&lt;p&gt;　　ps：这里讨论的是自顶向下的2-3-4树，因为是在向下找到插入点的路途中节点发生了分裂。把要分裂的数据项设为A,B,C，下面是节点分裂的情况（假设分裂的节点不是根节点）：&lt;/p&gt;
&lt;h4&gt;　　1、节点分裂&lt;/h4&gt;
&lt;p&gt;　　一、创建一个新的空节点，它是要分裂节点的兄弟，在要分裂节点的右边；&lt;/p&gt;
&lt;p&gt;　　二、数据项C移到新节点中；&lt;/p&gt;
&lt;p&gt;　　三、数据项B移到要分裂节点的父节点中；&lt;/p&gt;
&lt;p&gt;　　四、数据项A保留在原来的位置；&lt;/p&gt;
&lt;p&gt;　　五、最右边的两个子节点从要分裂处断开，连到新节点上。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226154534666-1244516576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图描述了节点分裂的例子，另一种描述节点分裂的说法是4-节点变成了两个 2- 节点。节点分裂是把数据向上和向右移动，从而保持了数的平衡。一般插入只需要分裂一个节点，除非插入路径上存在不止一个满节点时，这种情况就需要多重分裂。&lt;/p&gt;
&lt;h4&gt;　　2、根的分裂&lt;/h4&gt;
&lt;p&gt;　　如果一开始查找插入节点时就碰到满的根节点，那么插入过程更复杂：&lt;/p&gt;
&lt;p&gt;　　①、创建新的根节点，它是要分裂节点的父节点。&lt;/p&gt;
&lt;p&gt;　　②、创建第二个新的节点，它是要分裂节点的兄弟节点；&lt;/p&gt;
&lt;p&gt;　　③、数据项C移到新的兄弟节点中；&lt;/p&gt;
&lt;p&gt;　　④、数据项B移到新的根节点中；&lt;/p&gt;
&lt;p&gt;　　⑤、数据项A保留在原来的位置；&lt;/p&gt;
&lt;p&gt;　　⑥、要分裂节点最右边的两个子节点断开连接，连到新的兄弟节点中。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226155720729-1494054063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图便是根分裂的情况，分裂完成之后，整个树的高度加1。另外一种描述根分裂的方法是说4-节点变成三个2-节点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：插入时，碰到没有满的节点时，要继续向下寻找其子节点进行插入。如果直接插入该节点，那么还要进行子节点的增加，因为在2-3-4树中节点的子节点个数要比数据项多1；如果插入的节点满了，那么就要进行节点分裂。下图是一系列插入过程，有4个节点分裂了，两个是根，两个是叶节点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171226161252198-1864158666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4、完整源码实现&lt;/h3&gt;
&lt;p&gt;　　分为节点类Node,表示每个节点的数据项类DataItem,以及最后的2-3-4树类Tree234.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.tree.twothreefour;

public class Tree234 {
        private Node root = new Node() ;
        /*public Tree234(){
                root = new Node();
        }*/
        //查找关键字值
        public int find(long key){
                Node curNode = root;
                int childNumber ;
                while(true){
                        if((childNumber = curNode.findItem(key))!=-1){
                                return childNumber;
                        }else if(curNode.isLeaf()){//节点是叶节点
                                return -1;
                        }else{
                                curNode = getNextChild(curNode,key);
                        }
                }
        }
        
        public Node getNextChild(Node theNode,long theValue){
                int j;
                int numItems = theNode.getNumItems();
                for(j = 0 ; j &amp;lt; numItems ; j++){
                        if(theValue &amp;lt; theNode.getItem(j).dData){
                                return theNode.getChild(j);
                        }
                }
                return theNode.getChild(j);
        }
        
        //插入数据项
        public void insert(long dValue){
                Node curNode = root;
                DataItem tempItem = new DataItem(dValue);
                while(true){
                        if(curNode.isFull()){//如果节点满数据项了，则分裂节点
                                split(curNode);
                                curNode = curNode.getParent();
                                curNode = getNextChild(curNode, dValue);
                        }else if(curNode.isLeaf()){//当前节点是叶节点
                                break;
                        }else{
                                curNode = getNextChild(curNode, dValue);
                        }
                }//end while
                curNode.insertItem(tempItem);
        }
        
        public void split(Node thisNode){
                DataItem itemB,itemC;
                Node parent,child2,child3;
                int itemIndex;
                itemC = thisNode.removeItem();
                itemB = thisNode.removeItem();
                child2 = thisNode.disconnectChild(2);
                child3 = thisNode.disconnectChild(3);
                Node newRight = new Node();
                if(thisNode == root){//如果当前节点是根节点，执行根分裂
                        root = new Node();
                        parent = root;
                        root.connectChild(0, thisNode);
                }else{
                        parent = thisNode.getParent();
                }
                //处理父节点
                itemIndex = parent.insertItem(itemB);
                int n = parent.getNumItems();
                for(int j = n-1; j &amp;gt; itemIndex ; j--){
                        Node temp = parent.disconnectChild(j);
                        parent.connectChild(j+1, temp);
                }
                parent.connectChild(itemIndex+1, newRight);
                
                //处理新建的右节点
                newRight.insertItem(itemC);
                newRight.connectChild(0, child2);
                newRight.connectChild(1, child3);
        }
        
        //打印树节点
        public void displayTree(){
                recDisplayTree(root,0,0);
        }
        private void recDisplayTree(Node thisNode,int level,int childNumber){
                System.out.println(&quot;levle=&quot;+level+&quot; child=&quot;+childNumber+&quot; &quot;);
                thisNode.displayNode();
                int numItems = thisNode.getNumItems();
                for(int j = 0; j &amp;lt; numItems+1 ; j++){
                        Node nextNode = thisNode.getChild(j);
                        if(nextNode != null){
                                recDisplayTree(nextNode, level+1, j);
                        }else{
                                return;
                        }
                }
        }

        //数据项
        class DataItem{
                public long dData;
                public DataItem(long dData){
                        this.dData = dData;
                }
                public void displayItem(){
                        System.out.println(&quot;/&quot;+dData);
                }
        }
        
        //节点
        class Node{
                private static final int ORDER = 4;
                private int numItems;//表示该节点有多少个数据项
                private Node parent;//父节点
                private Node childArray[] = new Node[ORDER];//存储子节点的数组，最多有4个子节点
                private DataItem itemArray[] = new DataItem[ORDER-1];//存放数据项的数组，一个节点最多有三个数据项
                
                //连接子节点
                public void connectChild(int childNum,Node child){
                        childArray[childNum] = child;
                        if(child != null){
                                child.parent = this;
                        }
                }
                //断开与子节点的连接，并返回该子节点
                public Node disconnectChild(int childNum){
                        Node tempNode = childArray[childNum];
                        childArray[childNum] = null;
                        return tempNode;
                }
                //得到节点的某个子节点
                public Node getChild(int childNum){
                        return childArray[childNum];
                }
                //得到父节点
                public Node getParent(){
                        return parent;
                }
                //判断是否是叶节点
                public boolean isLeaf(){
                        return (childArray[0] == null)?true:false;
                }
                //得到节点数据项的个数
                public int getNumItems(){
                        return numItems;
                }
                //得到节点的某个数据项
                public DataItem getItem(int index){
                        return itemArray[index];
                }
                //判断节点的数据项是否满了（最多3个）
                public boolean isFull(){
                        return (numItems == ORDER-1) ? true:false;
                }
                
                //找到数据项在节点中的位置
                public int findItem(long key){
                        for(int j = 0 ; j &amp;lt; ORDER-1 ; j++){
                                if(itemArray[j]==null){
                                        break;
                                }else if(itemArray[j].dData == key){
                                        return j;
                                }
                        }
                        return -1;
                }
                
                //将数据项插入到节点
                public int insertItem(DataItem newItem){
                        numItems++;
                        long newKey = newItem.dData;
                        for(int j = ORDER-2 ; j &amp;gt;= 0 ; j--){
                                if(itemArray[j] == null){//如果为空，继续向前循环
                                        continue;
                                }else{
                                        long itsKey = itemArray[j].dData;//保存节点某个位置的数据项
                                        if(newKey &amp;lt; itsKey){//如果比新插入的数据项大
                                                itemArray[j+1] = itemArray[j];//将大数据项向后移动一位
                                        }else{
                                                itemArray[j+1] = newItem;//如果比新插入的数据项小，则直接插入
                                                return j+1;
                                        }
                                }
                        }
                        //如果都为空，或者都比待插入的数据项大，则将待插入的数据项放在节点第一个位置
                        itemArray[0] = newItem;
                        return 0;
                }
                //移除节点的数据项
                public DataItem removeItem(){
                        DataItem temp = itemArray[numItems-1];
                        itemArray[numItems-1] = null;
                        numItems--;
                        return temp;
                }
                //打印节点的所有数据项
                public void displayNode(){
                        for(int j = 0 ; j &amp;lt; numItems ; j++){
                                itemArray[j].displayItem();
                        }
                        System.out.println(&quot;/&quot;);
                }
        }

        
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、2-3-4树和红黑树　　&lt;/h3&gt;
&lt;p&gt;　　2-3-4树是多叉树，而红黑树是二叉树，看上去可能完全不同，但是，在某种意义上它们又是完全相同的，一个可以通过应用一些简单的规则变成另一个，而且使他们保持平衡的操作也是一样，数学上称他们为同构。&lt;/p&gt;
&lt;h4&gt;　　①、对应规则&lt;/h4&gt;
&lt;p&gt;　　应用如下三条规则可以将2-3-4树转化为红黑树：&lt;/p&gt;
&lt;p&gt;　　一、把2-3-4树中的每个2-节点转化为红-黑树的黑色节点。&lt;/p&gt;
&lt;p&gt;　　二、把每个3-节点转化为一个子节点和一个父节点，子节点有两个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色。&lt;/p&gt;
&lt;p&gt;　　三、把每个4-节点转化为一个父节点和两个子节点。第一个子节点有它自己的子节点W和X；第二个子节点拥有子节点Y和Z。和前面一样，子节点涂成红色，父节点涂成黑色。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201712/1120165-20171226202359370-2100678305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图是一颗2-3-4树转化成对应的红-黑树。虚线环绕的子树是由3-节点和4-节点变成的。转化后符合红-黑树的规则，根节点为红色，两个红色节点不会相连，每条从根到叶节点的路径上的黑节点个数是一样的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201712/1120165-20171226202651479-1456140480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　②、操作等价&lt;/h4&gt;
&lt;p&gt;　　不仅红-黑树的结构与2-3-4树对应，而且两种树操作也一样。2-3-4树用节点分裂保持平衡，红-黑树用颜色变换和旋转保持平衡。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201712/1120165-20171226204053651-1868267222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图是4-节点分裂。虚线环绕的部分等价于4-节点。颜色变换之后，40,60节点都为黑色的，50节点是红色的。因此，节点 50 和它的父节点70 对于3-节点，如上图虚线所示。&lt;/p&gt;
&lt;h3&gt;6、2-3-4 树的效率&lt;/h3&gt;
&lt;p&gt;　　分析2-3-4树我们可以和红黑树作比较分析。红-黑树的层数（平衡二叉树）大约是log&lt;sub&gt;2&lt;/sub&gt;(N+1)，而2-3-4树每个节点可以最多有4个数据项，如果节点都是满的，那么高度和log&lt;sub&gt;4&lt;/sub&gt;N。因此在所有节点都满的情况下，2-3-4树的高度大致是红-黑树的一半。不过他们不可能都是满的，所以2-3-4树的高度大致在log&lt;sub&gt;2&lt;/sub&gt;(N+1)和log&lt;sub&gt;2&lt;/sub&gt;(N+1)/2。减少2-3-4树的高度可以使它的查找时间比红-黑树的短一些。&lt;/p&gt;
&lt;p&gt;　　但是另一方面，每个节点要查看的数据项就多了，这会增加查找时间。因为节点中用线性搜索来查看数据项，使得查找时间的倍数和M成正比，即每个节点数据项的平均数量。总的查找时间和M*log&lt;sub&gt;4&lt;/sub&gt;N成正比。&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jan 2018 13:08:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8032648.html</dc:identifier>
</item>
<item>
<title>1.移植3.4内核-分析内核启动过程,重新分区,烧写jffs2文件系统 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8337453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8337453.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.在&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/8316591.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;上章-移植uboot&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;里.我们来分析下uboot是如何进入到内核的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先,uboot启动内核是通过&lt;span&gt;bootcmd&lt;/span&gt;命令行实现的,在我们之前移植的bootcmd命令行如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
bootcmd=nand read  &lt;span&gt;0x30000000&lt;/span&gt; kernel; bootm &lt;span&gt;0x30000000&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootm:从0x30000000处启动内核&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1然后我们进入cmd_bootm.c,找到对应的bootm命令对应的&lt;span&gt;do_bootm()&lt;/span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; do_bootm(cmd_tbl_t *cmdtp, &lt;span&gt;int&lt;/span&gt; flag, &lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; * &lt;span&gt;const&lt;/span&gt;&lt;span&gt; argv[])
{
boot_os_fn &lt;/span&gt;*boot_fn;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;boot_fn是个数组函数&lt;/span&gt;&lt;span&gt;
 ... ..

boot_fn(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, argc, argv, &amp;amp;images); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用数组函数&lt;/span&gt;&lt;span&gt;
 ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的boot_os_fn是个typedef型,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191753397-1035655191.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;112&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2由于定义了宏CONFIG_BOOTM_LINUX,最终会跳转到do_bootm -&amp;gt;&lt;span&gt;do_bootm_linux()&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; do_bootm_linux(&lt;span&gt;int&lt;/span&gt; flag, &lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *argv[], bootm_headers_t *&lt;span&gt;images)
{
         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No need for those on ARM &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (flag &amp;amp; BOOTM_STATE_OS_BD_T || flag &amp;amp;&lt;span&gt; BOOTM_STATE_OS_CMDLINE)
                   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flag &amp;amp;&lt;span&gt; BOOTM_STATE_OS_PREP) {
                   boot_prep_linux(images);
                   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flag &amp;amp;&lt;span&gt; BOOTM_STATE_OS_GO) {
                   boot_jump_linux(images);
                   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
         }

 
         boot_prep_linux(images);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会将各个tag参数保存在指定位置,比如:内存tag、bootargs环境变量tag、串口tag等&lt;/span&gt;&lt;span&gt;
         boot_jump_linux(images);      &lt;/span&gt;&lt;span&gt;//该函数&lt;/span&gt;&lt;span&gt;会跳转到内核起始地址&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3最终跳转到do_bootm -&amp;gt;do_bootm_linux-&amp;gt; &lt;span&gt;boot_jump_linux()&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; boot_jump_linux(bootm_headers_t *&lt;span&gt;images)
{
         unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; machid = gd-&amp;gt;bd-&amp;gt;bi_arch_number;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取机器ID&lt;/span&gt;
         &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;s;
         &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*kernel_entry)(&lt;span&gt;int&lt;/span&gt; zero, &lt;span&gt;int&lt;/span&gt; arch, &lt;span&gt;uint&lt;/span&gt; &lt;span&gt;params&lt;/span&gt;&lt;span&gt;);
         unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; r2;
         kernel_entry &lt;/span&gt;= (&lt;span&gt;void&lt;/span&gt; (*)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;uint&lt;/span&gt;))images-&amp;gt;ep;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置kernel_entry()的地址为0x30000000&lt;/span&gt;&lt;span&gt;
         s &lt;/span&gt;= getenv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;machid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断环境变量machid是否设置,若设置则使用环境变量里的值   &lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s) {       
                   strict_strtoul(s, &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;, &amp;amp;machid);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新获取机器ID&lt;/span&gt;&lt;span&gt;
                   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using machid 0x%lx from environment\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, machid);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用环境变量的machid&lt;/span&gt;&lt;span&gt;
         }&lt;br/&gt;　　　　　... ...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        r2 &lt;/span&gt;= gd-&amp;gt;bd-&amp;gt;bi_boot_params;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取tag参数地址, gd-&amp;gt;bd-&amp;gt;bi_boot_params在setup_start_tag()函数里被设置&lt;/span&gt;&lt;span&gt; 
        kernel_entry(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, machid, r2);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到0x30000000,r0=0,r1=机器ID,r2=tag参数地址&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;上面的machid默认值为MACH_TYPE_SMDK2410(也就是&lt;span&gt;193&lt;/span&gt;),我们也可以在环境变量里设置machid变量&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4最终,便跳到内核执行代码,步骤如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1)根据&lt;span&gt;R1(机器ID)&lt;/span&gt;,来判断内核是否支持该机器,若支持则初始化机器相关函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2)&lt;span&gt;解析TAG参数&lt;/span&gt;,初始化串口,设置内存等&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)&lt;span&gt;挂载&lt;/span&gt;根文件系统,并执行应用程序&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.接下来便从网上下载3.4.2内核来移植.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1修改Makefile,修改配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar xjf linux-&lt;span&gt;3.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.tar.bz2 
cd linux&lt;/span&gt;-&lt;span&gt;3.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;
vi Makefile &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;找到下面这句话：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ARCH            ?=&lt;span&gt; $(SUBARCH)
CROSS_COMPILE   &lt;/span&gt;?= $(CONFIG_CROSS_COMPILE:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=%)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;改为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ARCH            ?=&lt;span&gt; arm
CROSS_COMPILE   &lt;/span&gt;?= arm-linux-
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;(PS:我使用的是&lt;strong&gt;4.3.2&lt;/strong&gt;,若交叉编译工具版本太低,可能无法编译)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 配置编译&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
cd arch/arm/configs                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于我们板子是arm板,进入该目录&lt;/span&gt;&lt;span&gt;
ls  &lt;/span&gt;*&lt;span&gt;2440&lt;/span&gt;*                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到有mini2440_defconfig、&lt;/span&gt;&lt;span&gt;
ls  &lt;/span&gt;*&lt;span&gt;2410&lt;/span&gt;*                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到有s3c2410_defconfig&lt;/span&gt;&lt;span&gt;
make s3c2410_defconfig                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置2410, 更新.config配置文件 &lt;/span&gt;&lt;span&gt;
make uImage                          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译,生成uImage&lt;/span&gt;&lt;span&gt;
cp uImage &lt;/span&gt;/work/nfs_root/ uImage_new           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用nfs下载&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3进入uboot烧写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nfs &lt;span&gt;32000000&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.106&lt;/span&gt;:/work/nfs_root/&lt;span&gt;uImage_new
bootm &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示,发现串口输出乱码:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191815975-769344685.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;149&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出现这个问题,可以先看看&lt;span&gt;bootargs命令行&lt;/span&gt;的串口设置是否正确、uboot传递的&lt;span&gt;机器ID&lt;/span&gt;是否正确.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1找到bootargs命令行的串口没有设置波特率,修改bootargs:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; bootargs root=/dev/mtdblock3 console=ttySAC0,&lt;span&gt;115200&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 测试机器ID是否正确&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们1.3小节代码分析里,讲到过uboot传递进来的机器ID可以通过环境变量&lt;span&gt;machid&lt;/span&gt;来设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以任意设置一个ID,这样再次启动内核时,内核识别不出来,就会打印出所有设备对应的机器ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入uboot,输入:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; machid &lt;span&gt;33333&lt;/span&gt;&lt;span&gt;
tftp &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt;&lt;span&gt; uImage
bootm &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示,由于内核不支持这个机器ID,所以打印出内核能支持的ID表:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191827600-1981327933.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;335&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们板子是2440,所以测试&lt;span&gt;7cf(mini2440)&lt;/span&gt;以及&lt;span&gt;16a(smdk2440)&lt;/span&gt;这两个机器ID,是否支持我们开发板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现只有&lt;span&gt;7cf(mini2440)&lt;/span&gt;这个ID,有串口输出正常.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来看看16a(smdk2440)为什么串口乱码,进入&lt;span&gt;mach-smdk2440.c&lt;/span&gt;( 位于arch/arm/mach-s3c24xx)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到问题出在&lt;span&gt;smdk2440_map_io():&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __init smdk2440_map_io(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
         s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc));
         s3c24xx_init_clocks(&lt;/span&gt;&lt;span&gt;16934400&lt;/span&gt;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化时钟clock&lt;/span&gt;&lt;span&gt;
         s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于我们板子上的晶振是&lt;span&gt;12Mhz,&lt;/span&gt;而mdk2440_map_io()里,初始化的时钟是基于16934400hz的晶振.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以将:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s3c24xx_init_clocks(&lt;span&gt;16934400&lt;/span&gt;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化时钟clock&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;改为:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s3c24xx_init_clocks(&lt;span&gt;12000000&lt;/span&gt;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化时钟clock&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后重新编译uImage:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
make  s3c2410_defconfig             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将mach-s3c2440.c配置进内核&lt;/span&gt;&lt;span&gt;
make  uImage
cp uImage &lt;/span&gt;/work/nfs_root/ uImage_new
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进入uboot,输入:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt;&lt;span&gt; machid 16a
nfs &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.106&lt;/span&gt;:/work/nfs_root/&lt;span&gt;uImage_new
boom &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;启动内核,打印如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191838365-1789287827.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;163&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示,内核创建了&lt;span&gt;8&lt;/span&gt;个分区,而我们移植的uboot只有&lt;span&gt;4&lt;/span&gt;个分区,代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x00000000&lt;/span&gt;-&lt;span&gt;0x00040000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放uboot&lt;/span&gt;
&lt;span&gt;0x00040000&lt;/span&gt;-&lt;span&gt;0x00060000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放环境变量&lt;/span&gt;
&lt;span&gt;0x00060000&lt;/span&gt;-&lt;span&gt;0x00260000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kernel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放内核&lt;/span&gt;
&lt;span&gt;0x00260000&lt;/span&gt;-&lt;span&gt;0x10000000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rootfs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放文件系统&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;uboot传递的文件系统路径&lt;span&gt;root=/dev/mtdblock3&lt;/span&gt;,所以内核便卡死在启动文件系统上&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;4.所以接下来我们来修改内核分区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1在si里搜索上图出现的”S3C2410 flash partition”字段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191851662-867304518.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到位于common-smdk.c中,里面有个数组&lt;span&gt;smdk_default_nand_part[]&lt;/span&gt;,内容如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191901881-295925955.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;236&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2接下来便修改smdk_default_nand_part[]数组(位于arch/arm/mach-s3c24xx/common-smdk.c)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改为:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_partition smdk_default_nand_part[] =&lt;span&gt; {
         [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; {
                   .name         &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x00000000-0x00040000  &lt;/span&gt;&lt;span&gt;
                   .size  &lt;/span&gt;=&lt;span&gt; SZ_256K,                      
                   .offset         &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         },

         [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; {
                   .name         &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x00040000-0x00060000&lt;/span&gt;&lt;span&gt;
                   .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND, 
                   .size  &lt;/span&gt;=&lt;span&gt; SZ_128K,
         },

         [&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
                   .name         &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kernel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x00060000-0x00260000&lt;/span&gt;&lt;span&gt;
                   .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
                   .size  &lt;/span&gt;=&lt;span&gt; SZ_2M,
         },

         [&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] =&lt;span&gt; {
                   .name         &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rootfs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x00260000-0x10000000&lt;/span&gt;&lt;span&gt;
                   .offset         &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
                   .size  &lt;/span&gt;=&lt;span&gt; MTDPART_SIZ_FULL,
         }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面部分宏的定义,如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;MTDPART_OFS_RETAIN:    &lt;/span&gt;填在&lt;span&gt;offset&lt;/span&gt;里,表示先后保留多少size空间大小&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;MTDPART_OFS_NXTBLK:&lt;/span&gt;   填在&lt;span&gt;offset&lt;/span&gt;里,表示从下一个块开始&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;MTDPART_OFS_APPEND:&lt;/span&gt;  填在&lt;span&gt;offset&lt;/span&gt;里,表示该分区位置附加在上个分区结束的地址上&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;MTDPART_SIZ_FULL:         &lt;/span&gt;填在&lt;span&gt;size&lt;/span&gt;里,表示剩下的内存size都归于该分区&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3若需要mini2440的机器ID,则还需要修改mini2440单板对应的mach-mini2440.c&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为该单板的mtd分区也不对,将里面的mini2440_default_nand_part[]内容改为和上面一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4改好后,重启内核,发现内核还是启动不了以前的yaffs文件系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191914615-1012889162.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示不支持该内核不支持yaffs文件系统,然后尝试使用&lt;span&gt;ext3 ext2 cramfs vfat msdos iso9660&lt;/span&gt;等来挂载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.5 尝试使用以前的jffs2文件系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新烧写jffs2,设置uboot环境变量,启动内核,打印如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123192001756-1363546216.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;81&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图,表示jffs2已挂载,但是找不到init程序,因为这个文件系统的glibc库是交叉编译3.4版本的,由于3.4内核的交叉编译是4.3版本,所以不支持,接下来我们便&lt;span&gt;重新制作文件系统&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.构造根文件系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.1首先编译安装busybox(参考以前的busybox安装章节)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入&lt;a href=&quot;https://busybox.net/oldnews.html%E4%B8%8B%E8%BD%BDbusybox%201.20.0&quot;&gt;https://busybox.net/oldnews.html&lt;/a&gt;下载&lt;span&gt;busybox 1.20.0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xjf busybox-&lt;span&gt;1.20&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.bz2
cd busybox&lt;/span&gt;-&lt;span&gt;1.20&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
make menuconfig          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置交叉编译前缀&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进入Busybox Settings ---&amp;gt;Build Options ---&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;() Cross Compiler prefix&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在弹出的对话框里面写入：&lt;strong&gt;&lt;span&gt;arm-linux-&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
make          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译&lt;/span&gt;&lt;span&gt;
mkdir   &lt;/span&gt;/work/nfs_root/fs_mini_mdev_new            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建要安装的文件系统目录      &lt;/span&gt;&lt;span&gt;
make install CONFIG_PREFIX&lt;/span&gt;=/work/nfs_root/fs_mini_mdev_new   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定安装位置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2 安装glibc库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;span&gt;$PATH&lt;/span&gt;找到交叉编译位于/work/tools/arm-linux-gcc-4.3.2/usr/local/arm/4.3.2位置,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;span&gt;find -name lib&lt;/span&gt;,找到有以下几个lib&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123191946631-1899213363.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于ARM9属于ARMv4T架构,所以拷贝上面&lt;span&gt;两条红线处&lt;/span&gt;的lib到fs_mini_mdev_new里&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mkdir /work/nfs_root/fs_mini_mdev_new/&lt;span&gt;lib
mkdir &lt;/span&gt;/work/nfs_root/fs_mini_mdev_new/usr/lib -&lt;span&gt;p  
cp arm&lt;/span&gt;-none-linux-gnueabi/libc/armv4t/usr/lib&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.so* /work/nfs_root/fs_mini_mdev_new/usr/lib -d           /* -d:保持链接 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
cp arm&lt;/span&gt;-none-linux-gnueabi/libc/armv4t/lib&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.so* /work/nfs_root/fs_mini_mdev_new/lib -d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.3 构造etc目录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在etc目录下,需要构造以下3个文件&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;etc/inittab&lt;/span&gt;     : init进程会根据inittab文件里,来创建其它子进程,比如&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;etc/init.d/rcS&lt;/span&gt;:脚本文件,里面用来执行命令,比如设置网卡,使用mount -a来装载/etc/fstab中的文件系统&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;etc/fstab      &lt;/span&gt;:里面保存要被挂载的哪个文件系统,比如proc、sysfs、tmpfs、devpts等系统&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;构造/etc/inittab&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd  cd /work/nfs_root/fs_mini_mdev_new/&lt;span&gt;
mkdir etc&lt;/span&gt;/&lt;span&gt;
vi etc&lt;/span&gt;/inittab
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加以下几句:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
::sysinit:/etc/init.d/rcS    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内核启动时,执行/etc/init.d/rcS&lt;/span&gt;&lt;span&gt;
console::askfirst:&lt;/span&gt;-/bin/sh  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动console对应的-/bin/sh进程之前,等待用户按enter键&lt;/span&gt;&lt;span&gt;
::ctrlaltdel:&lt;/span&gt;/sbin/reboot   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下ctrl+alt+del组合键时,启动reboot命令&lt;/span&gt;&lt;span&gt;
::shutdown:&lt;/span&gt;/bin/umount -a -r  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统关机前,卸载所有文件系统&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)构造etc/init.d/rcS&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir etc/init.d/&lt;span&gt;   
vi  etc&lt;/span&gt;/init.d/rcS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加以下几句:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mount -a               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;装载/etc/fstab中的文件系统&lt;/span&gt;&lt;span&gt;
echo &lt;/span&gt;/sbin/mdev &amp;gt; /proc/sys/kernel/hotplug  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使/sbin/medv指向hotplug,从而支持热拔插&lt;/span&gt;&lt;span&gt;
mdev &lt;/span&gt;-s                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用medv命令自动创建/dev下的所有设备节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)构造etc/fstab&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS:使用mdev命令需要sysfs、tmpfs、devpts这3个文件系统的支持&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mkdir proc/                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建proc要挂载的目录&lt;/span&gt;&lt;span&gt;
mkdir sys&lt;/span&gt;/                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建sysfs要挂载的目录,&lt;/span&gt;&lt;span&gt;
mkdir dev&lt;/span&gt;/pts -p              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建devpts要挂载的目录&lt;/span&gt;&lt;span&gt;
vi  etc&lt;/span&gt;/fstab
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加以下几句&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# device     mount-&lt;span&gt;point    type     options      dump  fsck order
proc           &lt;/span&gt;/proc        proc     defaults      &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
tmpfs          &lt;/span&gt;/tmp         tmpfs    defaults      &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
sysfs          &lt;/span&gt;/sys         sysfs    defaults      &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
devpts         &lt;/span&gt;/dev/pts     devpts   defaults      &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.4构造其它文件/目录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)创建终端文件(dev/console和dev/null)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo mknod –m &lt;span&gt;660&lt;/span&gt;  dev/console c &lt;span&gt;5&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
sudo mknod –m &lt;/span&gt;&lt;span&gt;660&lt;/span&gt; dev/&lt;span&gt;null&lt;/span&gt; c &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)创建其它目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir mnt tmp root
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.制作jffs2映像文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于mkfs.jffs2工具之前已经安装好了,所以直接使用&lt;span&gt;mkfs.jffs2&lt;/span&gt;命令:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
cd /work/nfs_root/                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回到上个目录&lt;/span&gt;&lt;span&gt;
mkfs.jffs2 &lt;/span&gt;-n  -s &lt;span&gt;2048&lt;/span&gt;  -e 128KiB  -d fs_mini_mdev_new  -&lt;span&gt;o fs_mini_mdev_new.jffs2
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-n:表示每块不添加清除标记,-s:NAND的每页为2k,-e: NAND的每块为128kb
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-d fs_mini_mdev_new:表示要制作的根文件系统文件
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-o fs_mini_mdev_new.jffs2:表示生成的映像文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.烧写jffs2,启动内核&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nfs &lt;span&gt;30000000&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.106&lt;/span&gt;:/work/nfs_root/&lt;span&gt;fs_mini_mdev_new.jffs2
nand erase.part rootfs
nand write.jffs2 &lt;/span&gt;&lt;span&gt;30000000&lt;/span&gt; &lt;span&gt;260000&lt;/span&gt;&lt;span&gt;  $filesize
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; bootargs console=ttySAC0,&lt;span&gt;115200&lt;/span&gt; root=/dev/mtdblock3 rootfstype=&lt;span&gt;jffs2
nfs &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.106&lt;/span&gt;:/work/nfs_root/&lt;span&gt;uImage_new
bootm &lt;/span&gt;&lt;span&gt;32000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.1启动内核&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180123192025490-111027744.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入si,搜索exitcode,找到0x00000004对应的宏定义是&lt;span&gt;&lt;strong&gt;SIGILL&lt;/strong&gt;&lt;/span&gt;,表示非法指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是因为arm-linux-gcc-4.3.2是使用的&lt;span&gt;EABI&lt;/span&gt;接口,内核由于未配置,所以出现非法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.2 配置内核支持&lt;span&gt;EABI&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;输入make menuconfig,搜索EABI,找到位于:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kernel feature-&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[*] Use the ARM EABI to compile the kernel         &lt;/span&gt;&lt;br/&gt;&lt;span&gt;make uImage&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新编译烧写内核就没问题了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;未完待续,下章学习如何使内核支持yaffs系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 11:17:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8337453.html</dc:identifier>
</item>
<item>
<title>在 .NET中，一种更方便操作配置项的方法 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/config_setting.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/config_setting.html</guid>
<description>&lt;p&gt;在应用程序的开发过程中，我们往往会为软件提供一些配置项，以允许软件根据配置项灵活来做事情，比如配置日志文件路径等，此外，我们还可以用配置项来为用户存储其偏好设置等。&lt;/p&gt;
&lt;p&gt;.NET 为我们默认提供了配置机制以及配置文件，项目中的 app.config 或者 web.config 文件（如果没有，可以添加）就是 .NET 为我们提供的配置文件。在这个配置文件中的根节点 configuration 下，创建 appSettings 节点，在此节点中，我们可以添加自定义的配置项。同时，ConfigurationManager 类提供了访问及操作此配置文件（由 Configuration 类代表）中配置的方法。需要注意的是，这个类在 System.Configuration.dll 文件中，需要将它添加到项目的引用中，才能使用。&lt;/p&gt;
&lt;p&gt;本文主要介绍一种更为便利的方式来访问/存储配置项，当然，它本质上是使用 ConfigurationManager 类完成的。它主要的特点是&lt;strong&gt;以面向对象的方式来解决此问题&lt;/strong&gt;，更具体地说，我们创建一个类，类中包括一些属性用以表示配置项，通过访问或设置这些属性，即可得到或更新对应的配置项。&lt;/p&gt;
&lt;h2&gt;一、实现&lt;/h2&gt;
&lt;p&gt;首先，我们为 Configuration 类添加一个扩展方法 AddOrUpdateAppSettingItem，如下 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 向配置的 AppSetings 节添加（如果不存在）或更新（如果已存在）给定的 key 和 value
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddOrUpdateAppSettingItem(&lt;span&gt;this&lt;/span&gt; Configuration config, &lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.AppSettings.Settings.AllKeys.Contains(key))
            {
                config.AppSettings.Settings[key].Value &lt;/span&gt;=&lt;span&gt; value;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                config.AppSettings.Settings.Add(key, value);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法主要实现了向 appSettings 节点添加（配置项不存在）或更新（配置项已存在）配置，接下来我们会用到这个方法。&lt;/p&gt;
&lt;p&gt;接着，我们定义抽象基类 ConfigSetting，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigSetting
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置类
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;configuration&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigSetting(Configuration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前配置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Configuration Configuration
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取当前程序配置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Configuration GetCurrentConfiguration()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回指定的配置项的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetSettingValue([CallerMemberName] &lt;span&gt;string&lt;/span&gt; settingKey = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Configuration?.AppSettings?.Settings[settingKey]?&lt;span&gt;.Value;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回指定的配置项的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;值类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; T GetSettingValue&amp;lt;T&amp;gt;([CallerMemberName] &lt;span&gt;string&lt;/span&gt; settingKey = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; GetSettingValue(settingKey);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(value))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T)Convert.ChangeType(value, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T));
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 为指定的配置项设置值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSettingValue(&lt;span&gt;object&lt;/span&gt; value, [CallerMemberName] &lt;span&gt;string&lt;/span&gt; settingKey = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            Configuration.AddOrUpdateAppSettingItem(settingKey, value&lt;/span&gt;?&lt;span&gt;.ToString());
            Configuration.Save();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中主要包括了一个静态方法和三个受保护的 virtual 方法，说明：&lt;/p&gt;
&lt;p&gt;1. 静态方法 GetCurrentConfiguration 返回当前应用的配置类；&lt;br/&gt;2. GetSettingValue 和 SetSettingValue 方法则分别负责读取、设置指定配置项的值；&lt;br/&gt;3. GetSettingValue 有两个重载，其中一个用于支持泛型；&lt;br/&gt;4. 在它们的方法签名中包括 CallerMemberName 特性，通过这个属性可以得到调用此访问的方法或属性的名称。&lt;/p&gt;
&lt;p&gt;然后，创建一个名为 AppConfigSetting 的类，这个类将会包括一些代表配置项的属性，并且它要继承自 ConfigSetting，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppConfigSetting : ConfigSetting
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AppConfigSetting(Configuration configuration) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(configuration)
        {
            
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DateTime InstallDateTime
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; GetSettingValue&amp;lt;DateTime&amp;gt;&lt;span&gt;(); }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetSettingValue(value); }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; LogFileName
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetSettingValue(); }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetSettingValue(value); }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ReadBlockSize
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; GetSettingValue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(); }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetSettingValue(value); }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;1. 可以看到我们在其中增加了三个属性。而在它们的 get 与 set 段中，调用了基类中的对应的两个方法，其中，对于非 string 类型的配置项，我们调用的是 GetSettingValue&amp;lt;T&amp;gt;。&lt;br/&gt;2. 通过我们前面提到的 CallerMemberName 特性，就可以得到这里的属性名，并得到相应的配置项，这样我们就无需硬编码。所以，这个属性名，本质上就是配置项的名称。&lt;/p&gt;
&lt;p&gt;这样，我们将所有要用到的配置项作为属性放到 AppConfigSetting 类中，再用操作这些属性就可以完成所有对配置项的操作了。 &lt;/p&gt;
&lt;h2&gt;二、如何使用&lt;/h2&gt;
&lt;p&gt;使用它，也非常简单，代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; ConfigSetting.GetCurrentConfiguration();
            AppConfigSetting setting &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppConfigSetting(config);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未设置时&lt;/span&gt;
            MessageBox.Show($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogFileName: {setting.LogFileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置后，再读取&lt;/span&gt;
            setting.LogFileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogFileName: {setting.LogFileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 三、补充&lt;/h2&gt;
&lt;p&gt;为了满足在不向 AppConfigSetting 添加配置项属性，但却又要访问/存储指定配置项的需要，我们可以在基类 ConfigSetting 中添加以下三个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回指定的配置项的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetSettingValueByKey(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; settingKey)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetSettingValue(settingKey);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回指定的配置项的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; T GetSettingValueByKey&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; settingKey)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; GetSettingValue&amp;lt;T&amp;gt;&lt;span&gt;(settingKey);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 为指定的配置项设置值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;settingKey&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetSettingValueByKey(&lt;span&gt;string&lt;/span&gt; settingKey, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            SetSettingValue(value, settingKey);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这几个方法，可以自由地访问/存储配置项，不同于上面增加属性方式的是，它需要自己传递配置项 key 作参数。&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未设置时&lt;/span&gt;
            MessageBox.Show($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel: {setting.GetSettingValueByKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;LogLevel&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置后，再读取&lt;/span&gt;
            setting.SetSettingValueByKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel: {setting.GetSettingValueByKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;LogLevel&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 总结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了一种访问应用程序配置更为便利的方式，其主要思想是通过基类中 GetSettingValue/SetSettingValue 两个方法借助于 CallerMemberName 特性而得到派生类中属性的名称而操作对应的配置项。当然，这里不仅提供了一种方法，更是提供一种思路，基于此，你还可以根据实际需要来调整、扩展以满足你的实际需要。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/wpinfo/ConfigurationTest.zip&quot; target=&quot;_blank&quot;&gt;源码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 09:17:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/config_setting.html</dc:identifier>
</item>
<item>
<title>毕业五年回顾 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8336778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8336778.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　今天，阳光明媚，蓝天白云。这样好的天气，看着都叫人心情舒畅，即使不做什么，发呆也是极好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不知不觉，毕业已经5年了。曾经，刚出来工作的时候，看那些工作5年、10年的人，觉得都好厉害，也觉得5年离我好遥远。现在再看，不过弹指一挥间。参加工作以后，经历了很多事情，也明白了很多道理。那些道理曾经我也听过，也许做了很多规划，但走着走着好像都忘记了。能教会你成长的永远是事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2013年6月，大学毕业，直奔北京。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一次出远门是去武汉读大学，那时候对选的专业还没什么概念，一时糊涂选择了计算机专业，现在想想可能当时的想法就是想学电脑。工作以后，才深深体会到那句“现在流的汗都是当初填志愿时脑子里进的水”，多么痛的领悟啊！！！其实，我们计算机专业的同学毕业以后真正从事这一行的很少，我算其中一个佼佼者。在校期间没学到什么东西，没有实习过，快毕业了就天天跑招聘会。本校的招聘会一般是不去的，一般都是去华科晃，第一份工作也是在华科的一场招聘会上找到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　印象中，北漂是很苦的那种，住地下室。但是，并没有，也没有见过地下室长什么样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一份工作在东大桥，住常营。那时跟我一届的好多实习生，有Java的，有数据库的，我是搞Java的。刚来，什么都觉得很新鲜，每天要写日报，要做工作计划，早上来开站立会议，要开发，要测试，要改bug。技术主要是SpringMVC、MyBatis、jBPM4、Oracle、jQuery、ExtJS、JSP等等。工作不是很复杂，所有几乎每天都不用加班，周末也不用。但我始终坚持每周都写一篇总结，用word写，也不是什么很有技术含量的东西，就平时工作中遇到的一些问题，印象中最令我鸡冻的是有一次看懂了SpringMVC的事务的源代码，还有次为了学习Lucene竟然跑到甜水园那边的一个书店去买了一本关于Lucene的书，现在想想，当时一定是脑子被门挤了。没找对学习的方法，想着买一些书看下，结果就买了一堆书，有技术类的也有非技术类的，到现在还是新的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在学校学的好多东西都没有用到，比如Hibernate、Struts2之类的，工作这么久我也从来没用过它们。一年以后，有同事陆陆续续离开了，有些不舍，再后来又有新人进来了，这个大家庭又热闹起来了，但我隐约感觉得自己是个老人了，萌生了离职的念头。当时，有几个想法，一个是搞分布式开发，另一个是进入到一家互联网公司。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2015年，告别了朝九晚五的生活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　非常感谢当时带我的项目经理赵哥（PS：北京人，特会聊天……）、一起工作的同事们，还有给我们做饭的厨师。从那以后，我学会了有些事不必太认真，有些事认真你就输了，也看淡了离职。在第一家公司，我从一个小白成长为一个初级程序猿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来，去了外包公司。当时，不知道外包是个什么概念，只觉得工资开得蛮高。工作了一段时间以后才知道外包是怎么一会事儿。从此，也对诸如中软国际、软通动力、腾信软创这样的外包公司产生一种抵触。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过，在这里，我认识了很多外派过来的同事，有来自好几个公司的。工作内容都是些很基础的工作，核心的代码根本接触不到，反正有活儿就得干，每个月还要甲方的负责人签字反馈我们这一个月的工作表现以及考勤，然后由我们公司发工资，老实讲，我都不知道公司总部在哪里。有一次，来了几个实习生，那待遇比我们这些外派过来的不知道好到哪里去了，我们这些人都不乐意了，关键是这边负责项目的领导还很SB，仗着自己是IBM出来的对我们呼来唤去，说这简单，那简单，架构师也辣鸡。没过多久，我离开了那里。因为，我觉得在那里呆着简直是浪费时间。这一段经历让我对外包深恶痛绝，说得再天花乱坠，从今以后决不去外包公司。不过，在那里毕竟让我接触到了一些不一样的技术，比如RabbitMQ、Nginx，还有阿里云的一些云计算产品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一晃两年过去了，感觉技术确实有所提升，但还是感觉像个心智未成熟的小孩子一样。整个城市对我好像也没有什么吸引力，没啥目标。那段时间住在租的隔断间里，夏天很热，没有空调，没有窗户，还很吵，半夜不是有人吵架就是有小孩儿哭闹，搞得觉都睡不好，暗暗发誓，我一定要离开这个鬼地方。生活虽然很艰辛，但我依然没有忘记学习。那时晚上回来先跑步，跑完步回来顺便买点儿水果干粮什么的凑合一顿。没有网，自己提前下好视频，回来边吃饭边开视频学习，偶尔看看动漫。那段时间还拿到了驾照。现在回想起来，自己都会被感动，曾经那么努力的自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　终于，我对这份工作失望至极。我意识到总这么混下去也不是办法，想到千里之外的爸爸妈妈，想到大年三十还在路上，想到这些年的经历，想到…… 繁华的大都市，只有我一人，不免心生凄凉，遂决定回武汉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　临走的时候，见了一些以前的同事，还有赵哥。他给我分享了很多经验和经历，非常感谢！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果说前两年是在混时间的话，接下来这两年就是在赶时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　回到武汉以后，进入一家互联网公司工作，地址在光谷软件园。那时候，还是很迷茫，不知道什么是互联网公司，不知道什么是创业公司，就这样跟着公司一起成长，反正，往前走，这一走便是两年。经历过以后，才明白，原来互联网创业公司就是这样的。公司有自己的产品，我们的产品是面向用户的。公司人不是很多，组织结构很精简，因为我们是来做事情的。这段时间，加班是常态，印象中大部分时间都在加班，经常一上线就搞到十二点，上线从最开始的几周一次变成一周几次。有几次明显感觉到身体快扛不住了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当你感觉很痛苦，走得很艰辛的时候，那么恭喜你，你在走上坡路；当你感觉很轻松，毫无压力的时候，那么要小心了，你可能是在走下坡路。越是困难，越是痛苦，对人的历练越大，个人的成长和收获也越大。我很赞同这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这家公司，我学到的不仅仅是技术，还有很多为人处世的经验，很多经历是很宝贵的。首先，技术上，微信公众平台开发、小程序开发、微信/支付宝支付、Redis、分布式、Spring等等，还有很多特定场景的解决方案；其次，我知道了软件开发的流程到底是什么样子的，怎么从最开始的需求落地成产品的，公司的运作模式是怎样的；最后，也是最重要的，我遇到了令我心动女孩子，第一次有一见钟情的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　改变，从不习惯开始。这是我学到的很重要的一句话。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在武汉的这段时间，报了培训班学习人际沟通、心里素质等，坚持跑步（PS：最喜欢其民族大学跑），坚持读完了5本书，学会喝酒。也开始第一次参加同学的婚礼，还有被父母催结婚。关于相亲这个事情，真的很无奈，毕竟是亲戚朋友们出于关心给我介绍对象，所以，往往女方代表的不仅仅是她自己，还有给我介绍的亲戚们，由于是长辈，不好拒绝，也不能怠慢，稍有不慎就会得罪人。一方面，欠人家人情，再者，再小的问题都会被放大，到最后都成了我的不是，我眼光高看不上人家，我没诚意，我还能说什么呢。。。父母也苦口婆心的教育我，我自个儿也很苦恼，其中苦涩，只有经历过的人才明白。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2017年，此时，离开北京已有两年，毕业已经四年了。万万没想到，我又去了北京。放弃了很多东西，不顾一切的去了北京。这一次是为了爱情。无论如何我都想要争取我心中渴望的爱情。若要问我为什么，我只能说，因为是她。都说“当兵后悔两年，不当兵后悔一辈子”，同样，我想说：“不来，我会后悔一辈子”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　四年的成长，让我成熟了许多。曾经的汗水和泪水，已经不记得了，或许其实已经融入我的血液中了。特别喜欢一句话：“你现在的气质里，隐藏着你读过的书，走过的路，爱过的人”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这次在五道口上班，没错，就在清华旁边。虽然离我住的地方比较远，但是每天下班以后可以看到她。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　新公司人很多，办公室很乱，很吵，空间很小，这儿一堆人，那儿一堆人，这跟以前一个人占两个工位的安静的环境差别太大了。不过，一线城市的互联网公司用到的技术确认很靠前，在这里，我接触到了SpringBoot、SpringCloud、Git、Jenkins等等。我花了好长一段时间才把这些技术，以及之前的技术都捡起来，不然真的找不到工作。一线城市的资源真的不是二三线城市能比的，看看望京、西二旗、中关村，好多知名的大公司，机会很多，挑战也很大。后来，因为个人原因，我从这家公司离职了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我失业了，第一次待业这么长时间，第一次意识到失业真的很可怕，内心的孤独和彷徨与日俱增，唯一支撑我到现在的是那个令我朝思暮想一见钟情的女孩儿。但我是一个自学能力很强的人，在失业这段时间里我多次调整，学习了很多技术。以前想转大数据开发，不知道怎么学，后来静下心来自己钻研，发现其实也没那么难。我发现，对于很多技术我更喜欢看官方的英文文档，喜欢翻译出来，不然总感觉心里没谱。一次又一次的更新简历，期待明年能找到一份满意的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　五年的工作让我真正体会到：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;心若没有栖息的地方，到哪里都是在流浪&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;心稳了，手也就稳了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;静下心来，用心做一件事情，一定可以做好&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　五年说长不长，说短也不短，一辈子能有多少个五年？现在的我，技术比以前好，性格比以前好，内心比以前强大。回顾往昔，时间真的过得太快了，还没好好的感受，就这么过来了。一路走来，看淡了很多事情，也坚定了很多事情，能够分得清什么是重要的，什么是没有意义的。遗憾比失败更可怕，趁现在，想到什么就去行动吧！喜欢就去做，爱就大声说出来！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说到写博客这件事情，现在回想起来真的很有意思。以前看了那么多东西，现在都不记得了，之前做的笔记也找不到了。如果从一开始就养成写博客的习惯并且坚持下来那该多好啊。&lt;/span&gt;&lt;span&gt;最开始在网易博客上写了几篇，后来又转到51CTO写博客，现在觉得博客园挺好的。第一次注册博客园账号是因为，我看到一篇文章，作者说他之前在上海，后来回到西安，我读完以后真的感同身受，当时眼泪就下来了，有点儿后悔当初离开北京，他的经历跟我很相似，我想加作者为好友，于是注册了一个账号。现在，我觉得，博客真的是个好东西，以后会坚持下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　人生没有白走的路，每一步，都算数。&lt;/span&gt;&lt;span&gt;马上就要过年了，有很多事情要面对，渴望能够和她修成正果，期待明天会更好！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;愿得一人心，白首不分离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结发为夫妻，恩爱两不疑。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 09:06:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8336778.html</dc:identifier>
</item>
</channel>
</rss>