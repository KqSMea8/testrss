<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ViewPager使用记录2——展示动态数据 - ChardLau</title>
<link>http://www.cnblogs.com/developerdaily/p/7723958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/developerdaily/p/7723958.html</guid>
<description>&lt;p&gt;ViewPager是v4支持库中的一个控件，相信几乎所有接触Android开发的人都对它不陌生。之所以还要在这里翻旧账，是因为我在最近的项目中有多个需求用到了它，觉得自己对它的认识不够深刻。我计划从最简单的使用场景出发，记录我到目前为止所对ViewPager的使用情况以及有关它的一些知识点。&lt;/p&gt;
&lt;p&gt;这个系列的代码将存放在&lt;a href=&quot;https://github.com/chardlau/viewpager-usage&quot;&gt;Github仓库&lt;/a&gt;中，每篇文章对应一个分支。&lt;/p&gt;
&lt;p&gt;这是第一篇文章，讲述关于ViewPager展示动态数据的方法与相关知识点。ViewPager展示动态数据的方法有好几种，汇总到一起都离不开PagerAdapter的一个方法getItemPosition。下面讨论一下具体方法。&lt;/p&gt;
&lt;h5 id=&quot;&quot;&gt;错误的示例&lt;/h5&gt;
&lt;p&gt;上一篇文章介绍了如何展示静态数据。代码中的自定义的PagerAdapter中有一个setTexts方法，它的内容是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public synchronized void setTexts(List&amp;lt;String&amp;gt; texts) {  
    this.texts.clear();
    if (texts != null &amp;amp;&amp;amp; texts.size() &amp;gt; 0) {
        this.texts.addAll(texts);
    }
    notifyDataSetChanged();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的作用就是清除适配器列表中原有的数据，然后把外部传递进来的数据复制进列表，最后通知适配器更新。&lt;/p&gt;
&lt;p&gt;外部数据变更时，直接调用该方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
adapter.setTexts(randomData());  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来好像很合理，毕竟ListView等组件的适配器就是这么用的。&lt;/p&gt;
&lt;p&gt;但是如果你真的运行起来就会发现ViewPager的展示的数据并不是如你所愿的更新了。数据变多时，前面的数据不更新；数据变少时，在页面展示最后一项的情况下还可以向左滑动看到部分旧数据；甚至出现白屏的情况。&lt;/p&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/02-dynamic-data-bad-practice&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那怎么正确更新？&lt;/p&gt;

&lt;p&gt;这是最简单的修改数据的方法，适合在整个数据源都发生变化的场景下使用。&lt;/p&gt;
&lt;p&gt;在初始化ViewPager的使用我们使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
adapter = new DynamicDataSetAdapter();  
adapter.setTexts(randomData());

viewPager = (ViewPager) findViewById(R.id.vp_viewpager_update);  
viewPager.setAdapter(adapter);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当需要让ViewPager展示的数据改变时，我们可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 可以选择创建新的PagerAdapter对象或使用已有的对象
// adapter = new DynamicDataSetAdapter();
adapter.setTexts(randomData());  
viewPager.setAdapter(adapter); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/02-dynamic-data-by-set-adapter&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为什么使用notifyDatasetChanged无法正确更新数据，而setAdapter可以？这要求我们了解一下ViewPager的更新原理。&lt;/p&gt;

&lt;p&gt;看ViewPager的源码会发现它拥有两个成员变量，分别是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
PagerAdapter mAdapter;  
private PagerObserver mObserver;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PagerObserver是在ViewPager内部定义的私有类，也就是说它默认持有了ViewPager的引用，因此可以调用ViewPager的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private class PagerObserver extends DataSetObserver {  
    PagerObserver() {
    }
    @Override
    public void onChanged() {
        dataSetChanged();
    }
    @Override
    public void onInvalidated() {
        dataSetChanged();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实看PagerObserver的名字就知道这是一个观察者。PagerAdapter以PagerObserver为通道告知ViewPager调用dataSetChanged方法更新数据。&lt;/p&gt;
&lt;p&gt;看dataSetChanged方法的源码，关键在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
...
for (int i = 0; i &amp;lt; mItems.size(); i++) {  
    final ItemInfo ii = mItems.get(i);
    final int newPos = mAdapter.getItemPosition(ii.object);

    if (newPos == PagerAdapter.POSITION_UNCHANGED) {
        continue;
    }

    ...
}
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到dataSetChanged方法调用了PagerAdapter的getItemPosition方法了。一旦该方法返回了 PagerAdapter.POSITION_UNCHANGED就不刷新这个页面了。&lt;/p&gt;
&lt;p&gt;由于我们使用了默认的getItemPosition方法，而默认的getItemPosition方法的实现恰好就返回了这个值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public int getItemPosition(Object object) {  
    return POSITION_UNCHANGED;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里我们就明白了为什么修改数据后只调用notifyDataSetChanged不会刷新页面了。&lt;/p&gt;
&lt;p&gt;接下来看一下setAdapter方法的源码。关键在于该方法的前面几行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
if (mAdapter != null) {  
    mAdapter.setViewPagerObserver(null);
    mAdapter.startUpdate(this);
    for (int i = 0; i &amp;lt; mItems.size(); i++) {
        final ItemInfo ii = mItems.get(i);
        mAdapter.destroyItem(this, ii.position, ii.object);
    }
    mAdapter.finishUpdate(this);
    mItems.clear();
    removeNonDecorViews();
    mCurItem = 0;
    scrollTo(0, 0);
}
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到一旦就的数据适配器不为null，ViewPager就会销毁所有原来与数据相关的ItemInfo，并且逐一调用适配器的destroyItem方法销毁视图。&lt;/p&gt;
&lt;p&gt;setAdapter之后的代码就不用看了，跟初始化流程一样生成ItemInfo列表与相关数据。&lt;/p&gt;
&lt;p&gt;这就是为什么调用setAdapter可以更新数据的原因。&lt;/p&gt;
&lt;h5 id=&quot;getitemposition&quot;&gt;重写getItemPosition实现更高效的数据更新&lt;/h5&gt;
&lt;p&gt;既然知道了getItemPosition决定了数据更新的规则，我们只要重写这个方法就可以了。&lt;/p&gt;
&lt;p&gt;最暴力的方法当然是直接让这个方法返回POSITION_NONE，在效果上这跟使用setAdapter没什么区别了，只要调用了PagerAdapter的notifyDatasetChanged就会导致销毁原有的数据并重建。&lt;/p&gt;
&lt;p&gt;更稳妥一点的方法是配合应用的实际业务数据进行该方法的定制。下面提供一个仅供参考的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private static class DynamicDataSetAdapter extends PagerAdapter {  
    private List&amp;lt;String&amp;gt; texts;

    public DynamicDataSetAdapter() {
        texts = new ArrayList&amp;lt;&amp;gt;();
    }

    @Override
    public int getCount() {
        return texts.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {
        return object.equals(view);
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        String text = texts.get(position);

        TextView textView = new TextView(container.getContext());
        textView.setTag(text);
        textView.setText(text);

        container.addView(textView);
        return textView;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        container.removeView((View) object);
    }

    @Override
    public int getItemPosition(Object object) {
        View view = (View) object;
        String text = (String) view.getTag();
        if (text == null) {
            return PagerAdapter.POSITION_NONE;
        }

        int index = this.texts.indexOf(text);
        if (index == -1) {
            return PagerAdapter.POSITION_NONE;
        }

        return index;
    }

    public synchronized void setTexts(List&amp;lt;String&amp;gt; texts) {
        this.texts.clear();
        if (texts != null &amp;amp;&amp;amp; texts.size() &amp;gt; 0) {
            this.texts.addAll(texts);
        }
        notifyDataSetChanged();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/02-dynamic-data&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文来自作者同步&lt;a href=&quot;http://www.chardlau.com/2017/10/24/display-dynamic-data/&quot; target=&quot;_blank&quot;&gt;博客 &lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 07:47:00 +0000</pubDate>
<dc:creator>ChardLau</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/developerdaily/p/7723958.html</dc:identifier>
</item>
<item>
<title>【微信小程序开发】秒懂，架构及框架 - 程序媛鼓励师</title>
<link>http://www.cnblogs.com/xjxz/p/7723946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjxz/p/7723946.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0UQ3oBt4Xmr4gCOWhVtZlcqptyPvC1RJZs5MFHaV8Csj3y0SIPvVHGQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0UQ3oBt4Xmr4gCOWhVtZlcqptyPvC1RJZs5MFHaV8Csj3y0SIPvVHGQ/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3803339517625232&quot; data-w=&quot;539&quot; data-backw=&quot;539&quot; data-backh=&quot;205&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        今天的文章是讲微信小程序开发的，按理解把架构与框架说说。有不对之处请大神指点……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        微信小程序与web应用很像，但是原理不同，微信小程序是运行在微信应用内的，不是运行在浏览器上，所以JS的一些DOM操作在这里不适用。小程序有自己的一套标记语言（wxml），样式语言(wxss)，与web开发的html和css思想是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;首先，说说微信小程序架构。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        架构分为视图层，逻辑层，组件，API几个部分。视图层负责页面结构、样式和数据展示，用wxml、wxss语言编写。逻辑层负责业务逻辑，调用API等，由js编写。视图层和逻辑层类似MVVM模式，逻辑层只需对数据对象更新，就可以改变视图层的数据显示，这个很像vue，不知道底层是不是vue! 组件是视图层封装好的基础组件，如按钮、输入框等！API提供了访问手机设备、网络、服务器、微信平台接口等能力。如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0WfVrw9XrIicvAz3QlNQnUXSRibv7S6bFymC4ENTHvM3SSe0BO5wjZYOg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0WfVrw9XrIicvAz3QlNQnUXSRibv7S6bFymC4ENTHvM3SSe0BO5wjZYOg/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9155251141552512&quot; data-w=&quot;438&quot; data-fail=&quot;0&quot;/&gt;架构图：（按自己理解画的，仅供参考）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;span&gt; 其次，在说说开发框架。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        每个小程序在微信里是个应用(App)，App中又包含了多个页面(Page)。App有属于他的生命周期和目录结构，Page也有属于他的生命周期和目录结构。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0LGeJIb9H6zvcFlVqEU1iaSJVrhoaDiaNuVJibIuiaorZdetgBr3tJciaNYQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/IQvzL9uuA8vOndwYht5hbZJrFCejG7n0LGeJIb9H6zvcFlVqEU1iaSJVrhoaDiaNuVJibIuiaorZdetgBr3tJciaNYQ/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8215297450424929&quot; data-w=&quot;706&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;框架图（看开发文档的总结）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;更详细资料请查看微信小程序开发文档：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://mp.weixin.qq.com/debug/wxadoc/dev/framework/MINA.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要把框架结构搞懂！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;End&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IQvzL9uuA8toDE78bvE0gN6ZcrW1nDIEsyZPGXQticPepbFfnre76Y2Y431CeQ2dL9woLlVKzyFfkncffyVoicMw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IQvzL9uuA8toDE78bvE0gN6ZcrW1nDIEsyZPGXQticPepbFfnre76Y2Y431CeQ2dL9woLlVKzyFfkncffyVoicMw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9947643979057592&quot; data-w=&quot;382&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有用就关注，转发！转发！转发！&lt;/p&gt;

</description>
<pubDate>Tue, 24 Oct 2017 07:46:00 +0000</pubDate>
<dc:creator>程序媛鼓励师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjxz/p/7723946.html</dc:identifier>
</item>
<item>
<title>sharepoint 创建个人网站 - 鳄鱼的眼泪</title>
<link>http://www.cnblogs.com/olay/p/7723902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/olay/p/7723902.html</guid>
<description>&lt;p&gt;One of the SharePoint 2013 puzzle pieces which got some major improvements are My Sites, User Profiles and news feeds. This article describes step-by-step process of setting up the my site infrastructure in the SharePoint Farm.&lt;/p&gt;

&lt;p&gt;Prerequisite for setting up My Sites is having user profiles import or sync up and running. You can read more on &lt;a href=&quot;http://blog.sharedove.com/adisjugo/index.php/2012/07/23/setting-user-profile-synchronization-service-in-sharepoint-2013/&quot;&gt;&lt;span&gt;user profiles sync in my previous article&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When this has been configured, we can start configuring my sites:&lt;/p&gt;
&lt;p&gt;The first step us to go create (according to the best practices) own web application for hosting my sites. Go to the central administration, Application management, “Manage web applications”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/011.png&quot;&gt;&lt;img title=&quot;01&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/01_thumb1.png&quot; alt=&quot;01&quot; width=&quot;435&quot; height=&quot;378&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And create a dedicated web application (sd2013:101 in my example here)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/02.png&quot;&gt;&lt;img title=&quot;02&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/02_thumb.png&quot; alt=&quot;02&quot; width=&quot;427&quot; height=&quot;180&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, the next step would be to create a site collection in the root of the newly created web application. You can of course create it inside some other managed path other than root, but since we have dedicated Web Application, root seems like an obvious choice.&lt;/p&gt;
&lt;p&gt;Site Collection must have “2013” experience and use “My Site Host” template.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/031.png&quot;&gt;&lt;img title=&quot;03&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/03_thumb1.png&quot; alt=&quot;03&quot; width=&quot;427&quot; height=&quot;497&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After Site Collection has been created, click on the “Managed Paths”  in the web application that you created to host My Sites.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/041.png&quot;&gt;&lt;img title=&quot;04&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/04_thumb1.png&quot; alt=&quot;04&quot; width=&quot;429&quot; height=&quot;272&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Add a new managed path with wildcard inclusion. I prefer to use “my” as the My Site managed path, but you can of course pick up anything else.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/051.png&quot;&gt;&lt;img title=&quot;05&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/05_thumb1.png&quot; alt=&quot;05&quot; width=&quot;432&quot; height=&quot;352&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The next thing is to check service connections for the Web Application which will host my sites. Click on the “Service Connections” button to…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/061.png&quot;&gt;&lt;img title=&quot;06&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/06_thumb1.png&quot; alt=&quot;06&quot; width=&quot;450&quot; height=&quot;259&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;..see if right service applications are set up.&lt;/p&gt;
&lt;p&gt;If you choose “Custom” (instead of the “Default”) in the Edit the following group of connections drop down, select any service applications to which you want to connect the web application. The most important ones re User Profile service application, the managed metadata service application, and the Search service application.&lt;/p&gt;
&lt;p&gt;In my case, I’ll just proceed with “default”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/071.png&quot;&gt;&lt;img title=&quot;07&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/07_thumb1.png&quot; alt=&quot;07&quot; width=&quot;444&quot; height=&quot;475&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now it’s time to set up the self service site creation. Go back to the Web application management, chose the application that you created to host My Sites, and click on the “Self Service Site Creation” button.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/081.png&quot;&gt;&lt;img title=&quot;08&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/08_thumb1.png&quot; alt=&quot;08&quot; width=&quot;450&quot; height=&quot;352&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click “On” in the “Site Collections” radio box, and enter your managed path in the “Start a Site” field (with “Prompt users to create a team site under” chosen)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/091.png&quot;&gt;&lt;img title=&quot;09&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/09_thumb1.png&quot; alt=&quot;09&quot; width=&quot;436&quot; height=&quot;477&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, the next step is to grant users permission to create new site collections (for my sites). Click on the “Permission Policy” button in the Web Application management, with the web application which hosts the my sites selected.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/101.png&quot;&gt;&lt;img title=&quot;10&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/10_thumb1.png&quot; alt=&quot;10&quot; width=&quot;420&quot; height=&quot;460&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the”Manage Permission Policy Levels”, click on the “Add Permission Policy Level”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/111.png&quot;&gt;&lt;img title=&quot;11&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/11_thumb1.png&quot; alt=&quot;11&quot; width=&quot;434&quot; height=&quot;233&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Call it however you want (“MySite Subsite Creation” in my case), and grant the “Create Subsites” permission.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/121.png&quot;&gt;&lt;img title=&quot;12&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/12_thumb1.png&quot; alt=&quot;12&quot; width=&quot;180&quot; height=&quot;468&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, the new permission policy level should appear among other policy levels…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/131.png&quot;&gt;&lt;img title=&quot;13&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/13_thumb1.png&quot; alt=&quot;13&quot; width=&quot;410&quot; height=&quot;229&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And we need to grant that policy level to the users. Click on the “Users Policy” button in the Web Application management, with the web application that you created to host My Sites selected…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/141.png&quot;&gt;&lt;img title=&quot;14&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/14_thumb1.png&quot; alt=&quot;14&quot; width=&quot;443&quot; height=&quot;373&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click on the “Add users” link…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/151.png&quot;&gt;&lt;img title=&quot;15&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/15_thumb1.png&quot; alt=&quot;15&quot; width=&quot;448&quot; height=&quot;287&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From all zones…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/161.png&quot;&gt;&lt;img title=&quot;16&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/16_thumb1.png&quot; alt=&quot;16&quot; width=&quot;446&quot; height=&quot;210&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And select the users which you want to have rights to create my sites. On my case, it will be “Everyone”.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/17.png&quot;&gt;&lt;img title=&quot;17&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/17_thumb.png&quot; alt=&quot;17&quot; width=&quot;427&quot; height=&quot;533&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/18.png&quot;&gt;&lt;img title=&quot;18&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/18_thumb.png&quot; alt=&quot;18&quot; width=&quot;428&quot; height=&quot;387&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Select your newly created policy level…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/19.png&quot;&gt;&lt;img title=&quot;19&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/19_thumb.png&quot; alt=&quot;19&quot; width=&quot;352&quot; height=&quot;444&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And now you should see “Everyone” with the new policy selected.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/20.png&quot;&gt;&lt;img title=&quot;20&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/20_thumb.png&quot; alt=&quot;20&quot; width=&quot;380&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OK, everything has been set up and prepared so far. Now, finally, let’s set up the my sites. Go to the Central Administration –&amp;gt; Application Management, and select “Manage service applications”.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/21.png&quot;&gt;&lt;img title=&quot;21&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/21_thumb.png&quot; alt=&quot;21&quot; width=&quot;445&quot; height=&quot;276&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Then select the “User Profile Service Application”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/22.png&quot;&gt;&lt;img title=&quot;22&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/22_thumb.png&quot; alt=&quot;22&quot; width=&quot;439&quot; height=&quot;44&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the “User Profile Service Application”, click on “Setup My Sites”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/23.png&quot;&gt;&lt;img title=&quot;23&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/23_thumb.png&quot; alt=&quot;23&quot; width=&quot;440&quot; height=&quot;284&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is where you need to set up the search center, my host location (in my case – root site collection of the Web Application that serves as the host) and personal site location (managed path within the host web application – “my” in my case). Take a look at the screenshot for all the other fields (which I have used in my case):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/24.png&quot;&gt;&lt;img title=&quot;24&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/24_thumb.png&quot; alt=&quot;24&quot; width=&quot;252&quot; height=&quot;559&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The only remaining thing would be to set up the timer job for activity feed. Go to the Central Administration –&amp;gt; Monitoring –&amp;gt;Timer Job –&amp;gt; Review job definitions&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/25.png&quot;&gt;&lt;img title=&quot;25&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/25_thumb.png&quot; alt=&quot;25&quot; width=&quot;410&quot; height=&quot;359&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Find the “User Profile Service Application – Activity Feed Job”, and set up the activity feed sync timer according to your needs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/26.png&quot;&gt;&lt;img title=&quot;26&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/26_thumb.png&quot; alt=&quot;26&quot; width=&quot;410&quot; height=&quot;72&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/timer.png&quot;&gt;&lt;img title=&quot;timer&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/timer_thumb.png&quot; alt=&quot;timer&quot; width=&quot;412&quot; height=&quot;354&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And, that’s it.&lt;/p&gt;
&lt;p&gt;Go to the my site now, and you will be notified of my site creation for your self. Take care of your profile, follow people. Upload you private documents, share documents, follow documents – enjoy being social! &lt;img class=&quot;wlEmoticon wlEmoticon-smile&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/wlEmoticon-smile1.png&quot; alt=&quot;Smile&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/27.png&quot;&gt;&lt;img title=&quot;27&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/27_thumb.png&quot; alt=&quot;27&quot; width=&quot;391&quot; height=&quot;196&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/28.png&quot;&gt;&lt;img title=&quot;28&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/28_thumb.png&quot; alt=&quot;28&quot; width=&quot;398&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/29.png&quot;&gt;&lt;img title=&quot;29&quot; src=&quot;http://blog.sharedove.com/adisjugo/wp-content/uploads/2012/07/29_thumb.png&quot; alt=&quot;29&quot; width=&quot;395&quot; height=&quot;328&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 07:41:00 +0000</pubDate>
<dc:creator>鳄鱼的眼泪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/olay/p/7723902.html</dc:identifier>
</item>
<item>
<title>开始Java8之旅(六) -- 使用lambda实现Java的尾递归 - 祈求者-</title>
<link>http://www.cnblogs.com/invoker-/p/7723420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/invoker-/p/7723420.html</guid>
<description>&lt;p&gt;本篇介绍的不是什么新知识，而是对前面讲解的一些知识的综合运用。众所周知，递归是解决复杂问题的一个很有效的方式，也是函数式语言的核心，在一些函数式语言中，是没有迭代与while这种概念的，因为此类的循环通通可以用递归来实现，这类语言的编译器都对递归的尾递归形式进行了优化，而Java的编译器并没有这样的优化，本篇就要完成这样一个对于尾递归的优化。&lt;/p&gt;

&lt;p&gt;本篇将使用递归中最简单的阶乘计算来作为例子&lt;/p&gt;
&lt;h2 id=&quot;递归实现&quot;&gt;递归实现&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 阶乘计算 -- 递归解决&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param number &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;当前阶乘需要计算的数值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;number!&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialRecursion&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (number == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; number;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; number * &lt;span class=&quot;fu&quot;&gt;factorialRecursion&lt;/span&gt;(number - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法计算阶乘比较大的数很容易就栈溢出了，原因是每次调用下一轮递归的时候在栈中都需要保存之前的变量，所以整个栈结构类似是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5
  4
    3
      2
        1
-------------------&amp;gt; 
      栈的深度&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在没有递归到底之前，那些中间变量会一直保存着，因此每一次递归都需要开辟一个新的栈空间&lt;/p&gt;
&lt;h2 id=&quot;尾递归实现&quot;&gt;尾递归实现&lt;/h2&gt;
&lt;p&gt;任何递归的尾递归版本都十分简单，分析上面栈溢出的原因就是在每次return的时候都会附带一个变量，因此只需要在return的时候不附带这个变量即可。说起来简单，该怎么做呢?其实也很容易，我们使用一个参数来保存上一轮递归的结果，这样就可以了，因此尾递归的阶乘实现应该是这样的代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 阶乘计算 -- 尾递归解决&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param factorial &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;上一轮递归保存的值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param number &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   当前阶乘需要计算的数值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;number!&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; factorial, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (number == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; factorial;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(factorial * number, number - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用一个factorial变量保存上一轮阶乘计算出的数值,这样return的时候就无需保存变量,整个的计算过程是&lt;br/&gt;&lt;code&gt;(5*4)20 -&amp;gt; (20*3) 60 -&amp;gt; (60*2) 120 -&amp;gt; return 120&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这样子通过每轮递归结束后刷新当前的栈空间，复用了栈，就克服了递归的栈溢出问题，像这样的&lt;code&gt;return&lt;/code&gt;后面不附带任何变量的递归写法，也就是递归发生在函数最尾部,我们称之为'尾递归'。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很显然，如果事情这么简单的话，这篇文章也就结束了，和lambda也没啥关系 :) 然而当你调用上文的尾递归写法之后，发现并没有什么作用，该栈溢出的还是会栈溢出，其实原因我在开头就已经说了，尾递归这样的写法本身并不会有什么用，依赖的是编译器对尾递归写法的优化，在很多语言中编译器都对尾递归有优化，然而这些语言中并不包括java，因此在这里我们使用lambda的懒加载(惰性求值)机制来延迟递归的调用，从而实现栈帧的复用。&lt;/p&gt;
&lt;h2 id=&quot;设计尾递归的接口&quot;&gt;设计尾递归的接口&lt;/h2&gt;
&lt;p&gt;因此我们需要设计一个这样的函数接口来代替递归中的栈帧，通过apply这个函数方法(取名叫apply是因为该方法的参数是一个栈帧，返回值也是一个栈帧,类比function接口的apply)完成每个栈帧之间的连接，除此之外，我们栈帧还需要定义几个方法来丰富这个尾递归的接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;apply（连接栈帧，惰性求值）&lt;/li&gt;
&lt;li&gt;判断递归是否结束&lt;/li&gt;
&lt;li&gt;得到递归最后的结果&lt;/li&gt;
&lt;li&gt;执行递归(及早求值)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上面的几条定义,设计出如下的尾递归接口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 尾递归函数接口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;: martrix&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; TailRecursion&amp;lt;T&amp;gt; {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 用于递归栈帧之间的连接,惰性求值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;下一个递归栈帧&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    TailRecursion&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 判断当前递归是否结束&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;默认为false,因为正常的递归过程中都还未结束&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isFinished&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 获得递归结果,只有在递归结束才能调用,这里默认给出异常,通过工具类的重写来获得值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;递归最终结果&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;getResult&lt;/span&gt;()  {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;递归还没有结束,调用获得结果异常!&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 及早求值,执行者一系列的递归,因为栈帧只有一个,所以使用findFirst获得最终的栈帧,接着调用getResult方法获得最终递归值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;及早求值,获得最终递归结果&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Stream.&lt;span class=&quot;fu&quot;&gt;iterate&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, TailRecursion::apply)
                .&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;(TailRecursion::isFinished)
                .&lt;span class=&quot;fu&quot;&gt;findFirst&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;getResult&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;设计对外统一的尾递归包装类&quot;&gt;设计对外统一的尾递归包装类&lt;/h2&gt;
&lt;p&gt;为了达到可以复用的效果,这里设计一个尾递归的包装类,目的是用于对外统一方法,使得需要尾递归的调用同样的方法即可完成尾递归,不需要考虑内部实现细节，因为所有的递归方法无法只有2类类型的方法,一个是调用下次递归,另外一个是递归的技术，因此包装方法设计为以下两个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用下次递归&lt;/li&gt;
&lt;li&gt;结束本轮递归&lt;br/&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 使用尾递归的类,目的是对外统一方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;: Matrix&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TailInvoke {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 统一结构的方法,获得当前递归的下一个递归&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param nextFrame &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;下一个递归&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param &amp;lt;T&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;      T&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;下一个递归&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; TailRecursion&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; TailRecursion&amp;lt;T&amp;gt; nextFrame) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; nextFrame;
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 结束当前递归，重写对应的默认方法的值,完成状态改为true,设置最终返回结果,设置非法递归调用&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param value &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;最终递归值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param &amp;lt;T&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;  T&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;一个isFinished状态true的尾递归, 外部通过调用接口的invoke方法及早求值, 启动递归求值。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; TailRecursion&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;done&lt;/span&gt;(T value) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TailRecursion&amp;lt;T&amp;gt;() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TailRecursion&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;递归已经结束,非法调用apply方法&quot;&lt;/span&gt;);
            }

            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isFinished&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }

            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;getResult&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value;
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;完成阶乘的尾递归函数&quot;&gt;完成阶乘的尾递归函数&lt;/h2&gt;
&lt;p&gt;通过使用上面的尾递归接口与包装类,只需要调用包装了call与done就可以很轻易的写出尾递归函数,代码如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 阶乘计算 -- 使用尾递归接口完成&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param factorial &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;当前递归栈的结果值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param number &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;下一个递归需要计算的值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;尾递归接口,调用invoke启动及早求值获得结果&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; TailRecursion&amp;lt;Integer&amp;gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; factorial, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (number == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; TailInvoke.&lt;span class=&quot;fu&quot;&gt;done&lt;/span&gt;(factorial);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; TailInvoke.&lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;(() -&amp;gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(factorial + number, number - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过观察发现,和原先预想的尾递归方法几乎一模一样,只是使用包装类的call与done方法来表示递归的调用与结束&lt;br/&gt;预想的尾递归&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 阶乘计算 -- 尾递归解决&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param factorial &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;上一轮递归保存的值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param number &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;   当前阶乘需要计算的数值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;number!&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; factorial, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (number == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; factorial;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(factorial * number, number - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试尾递归函数&quot;&gt;测试尾递归函数&lt;/h2&gt;
&lt;p&gt;这里作一个说明,因为阶乘的计算如果要计算到栈溢出一般情况下Java的数据类型需要使用BigInteger来包装,为了简化代码，这里的测试仅仅是是测试栈会不会溢出的问题,因此我们将操作符的&lt;code&gt;*&lt;/code&gt;改成&lt;code&gt;+&lt;/code&gt;这样修改的结果仅仅是结果变小了,但是栈的深度却没有改变。测试代码如下&lt;br/&gt;首先测试 深度为10W的普通递归&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testRec&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;factorialRecursion&lt;/span&gt;(100_000));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;理所当然的栈溢出了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.StackOverflowError
    at test.Factorial.factorialRecursion(Factorial.java:20)
    at test.Factorial.factorialRecursion(Factorial.java:20)
    at test.Factorial.factorialRecursion(Factorial.java:20)
    at test.Factorial.factorialRecursion(Factorial.java:20)
    at test.Factorial.factorialRecursion(Factorial.java:20)
    
Process finished with exit code -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们测试1000W栈帧的尾递归&lt;br/&gt;尾递归代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; TailRecursion&amp;lt;Long&amp;gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; factorial, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (number == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; TailInvoke.&lt;span class=&quot;fu&quot;&gt;done&lt;/span&gt;(factorial);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; TailInvoke.&lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;(() -&amp;gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(factorial + number, number - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testTailRec&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,10_000_000).&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现结果运转良好&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;50000005000000

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于阶乘的计算一般初始值都为1,所以再进一步包装一下,将初始值设置为1&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorial&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; number) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;factorialTailRecursion&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, number).&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终调用代码如下,完全屏蔽了尾递归的实现细节&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testTailRec&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;factorial&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)); &lt;span class=&quot;co&quot;&gt;//结果为 3628800&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文讲解了利用lambda懒加载的特性完成了递归中栈帧的复用,实现了函数式语言编译器的'尾递归'优化,虽然上面的例子很简单，但是设计的接口和包装类都是通用的，可以说任何需要使用尾递归的都可以使用上面的代码来实现尾递归的优化，这也算是为编译器帮了点忙吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/invoker-/p/7709411.html&quot;&gt;上一篇:开始Java8之旅（五） -- Java8中的排序&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 06:38:00 +0000</pubDate>
<dc:creator>祈求者-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/invoker-/p/7723420.html</dc:identifier>
</item>
<item>
<title>ELK系列~Nxlog日志收集加转发(解决log4日志换行导致json转换失败问题) - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/7723243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/7723243.html</guid>
<description>&lt;pre&gt;
## This &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a sample configuration file. See the nxlog reference manual about the
## configuration options. It should be installed locally and &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; also available
## online at http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nxlog.org/docs/&lt;/span&gt;
&lt;span&gt;
## Please &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; the ROOT to the folder your nxlog was installed into,
## otherwise it will not start.

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; ROOT C:\Program Files\nxlog&lt;span&gt;
define ROOT C:\Program Files (x86)\nxlog

Moduledir &lt;/span&gt;%ROOT%&lt;span&gt;\modules
CacheDir &lt;/span&gt;%ROOT%&lt;span&gt;\data
Pidfile &lt;/span&gt;%ROOT%&lt;span&gt;\data\nxlog.pid
SpoolDir &lt;/span&gt;%ROOT%&lt;span&gt;\data
LogFile &lt;/span&gt;%ROOT%&lt;span&gt;\data\nxlog.log


 &lt;/span&gt;&amp;lt;Extension json&amp;gt;&lt;span&gt;
    Module      xm_json
&lt;/span&gt;&amp;lt;/Extension&amp;gt;
&amp;lt;Extension _syslog&amp;gt;&lt;span&gt;
    Module      xm_syslog
&lt;/span&gt;&amp;lt;/Extension&amp;gt;

&amp;lt;Input &lt;span&gt;in&lt;/span&gt;&amp;gt;&lt;span&gt;
    Module    im_file
    File    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c:\dotnet\20*.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0DA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Exec $raw_event &lt;/span&gt;= replace($raw_event, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x0D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 &lt;/span&gt;&amp;lt;/Input&amp;gt;
&amp;lt;Output &lt;span&gt;out&lt;/span&gt;&amp;gt;&lt;span&gt;
    Module      om_tcp
    Host        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.214&lt;/span&gt;&lt;span&gt;
    Port        &lt;/span&gt;&lt;span&gt;24224&lt;/span&gt;&lt;span&gt;
    Exec $raw_event &lt;/span&gt;=$raw_event + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&amp;lt;/Output&amp;gt;

&amp;lt;Route &lt;span&gt;1&lt;/span&gt;&amp;gt;&lt;span&gt; 
    Path        &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; =&amp;gt; &lt;span&gt;out&lt;/span&gt;
&amp;lt;/Route&amp;gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 24 Oct 2017 06:09:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/7723243.html</dc:identifier>
</item>
<item>
<title>C#设计模式之九装饰模式（Decorator）【结构型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/7723225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/7723225.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们要讲【结构型】设计模式的第三个模式，该模式是【装饰模式】。我第一次看到这个名称想到的是另外一个词语“装修”，我就说说我对“装修”的理解吧，大家一定要看清楚，是“装修”,不是“装饰”。我们长大了，就要结婚，要结婚就涉及到要买房子，买的精装修或者简单装修就可以住的，暂时不谈。我们就谈谈我们购买的是毛坯房。如果我想要房子的内饰是大理石风格的，我们只要在毛坯房的基础之上用大理石风格的材料装修就可以，我们当然不可能为了要一个装修风格，就把刚刚盖好的房子拆了在重新来过。房子装修好了，我们就住了进来，很开心。过了段时间，我们发现我们的房子在冬季比较冷，于是我就想给我们的房子增加保暖的功能，装修好的房子我们可以继续居住，我们只是在房子外面加一层保护层就可以了。又过了一段时间，总是有陌生人光顾，所以我们想让房子更安全，于是我们在外墙和房顶加装安全摄像头，同时门窗也增加安全系统。随着时间的流逝，我们可能会根据我们的需求增加相应的功能，期间，我们的房子可以正常使用，加上什么设施就有了相应的功能。从这一方面来讲，“装修”和“装饰”有类似的概念，接下来就让我们看看装饰模式具体是什么吧！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、装饰模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在房子装修的过程中，各种功能可以相互组合，来增加房子的功用。类似的，如果我们在软件系统中，要给某个类型或者对象增加功能，如果使用“继承”的方案来写代码，就会出现子类暴涨的情况。比如：IMarbleStyle是大理石风格的一个功能，IKeepWarm是保温的一个接口定义，IHouseSecurity是房子安全的一个接口，就三个接口来说，House是我们房子，我们的房子要什么功能就实现什么接口，如果房子要的是复合功能，接口不同的组合就有不同的结果，这样就导致我们子类膨胀严重，如果需要在增加功能，子类会成指数增长。这个问题的根源在于我们“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质（所谓静态特质，就是说如果想要某种功能，我们必须在编译的时候就要定义这个类，这也是强类型语言的特点。静态，就是指在编译的时候要确定的东西；动态，是指运行时确定的东西），使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。如何使“对象功能的扩展”能够根据需要来动态（即运行时）地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响降为最低？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。　　       ——  《设计模式》GoF&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201710/1048776-20171024135829098-1962348959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    在装饰模式中的各个角色有：&lt;/p&gt;&lt;p&gt;　　. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。&lt;/p&gt;&lt;p&gt;　　. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。&lt;/p&gt;&lt;p&gt;　　. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。&lt;/p&gt;&lt;p&gt;　　. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5 、装饰模式的具体实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   刚开始一看这个“装饰模式”是有点不太好理解，既然这个模式是面向对象的设计模式，那在现实生活中一定有事例和其对应，其实这种例子也不少，大家好好的挖掘吧，也可以提高我们对面向对象的理解。我继续拿盖房子来说事吧。&lt;br/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 装饰模式的实现
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该抽象类就是房子抽象接口的定义，该类型就相当于是Component类型，是饺子馅，需要装饰的，需要包装的
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; House
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;房子的装修方法--该操作相当于Component类型的Operation方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Renovation();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该抽象类就是装饰接口的定义，该类型就相当于是Decorator类型，如果需要具体的功能，可以子类化该类型
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DecorationStrategy:House &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键点之二，体现关系为Is-a，有这这个关系，装饰的类也可以继续装饰了&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过组合方式引用Decorator类型，该类型实施具体功能的增加
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是关键点之一，包含关系，体现为Has-a&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; House _house;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造器注入，初始化平台实现&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Database(House house)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;.__house=&lt;span&gt;house;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法就相当于Decorator类型的Operation方法&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; PatrickLiu的房子，我要按我的要求做房子，相当于ConcreteComponent类型，这就是我们具体的饺子馅，我个人比较喜欢韭菜馅
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PatrickLiuHouse:House
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Renovation()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PatrickLiu的房子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 具有安全功能的设备，可以提供监视和报警功能，相当于ConcreteDecoratorA类型
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HouseSecurityDecorator:DecorationStrategy
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;增加安全系统&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;  
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 具有保温接口的材料，提供保温功能，相当于ConcreteDecoratorB类型
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KeepWarmDecorator:DecorationStrategy
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;增加保温的功能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;       &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这就是我们的饺子馅，需要装饰的房子&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;          House myselfHouse=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PatrickLiuHouse();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;          DecorationStrategy securityHouse=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HouseSecurityDecorator(myselfHouse);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;         securityHouse.Process();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;房子就有了安全系统了
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我既要安全系统又要保暖呢，继续装饰就行&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;          DecorationStrategy securityAndWarmHouse=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HouseSecurityDecorator(securityHouse);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;         securityAndWarmHouse.Process();
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;    写了很多备注，大家好好体会一下，里面有两个关键点，仔细把握。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、装饰模式的实现要点：&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    1、通过采用组合、而非继承的手法，Decorator模式实现了在&lt;span&gt;运行时动态&lt;/span&gt;地扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了单独使用继承带来的“灵活性差”和“多子类衍生问题”。&lt;/p&gt;&lt;p&gt;    2、Component类在Decorator模式中充当抽象接口的角色，不应该去实现具体的行为。而且Decorator类对于Component类应该透明——换言之Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能。&lt;/p&gt;&lt;p&gt;    3、Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。我们可以使用一个或者多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。&lt;/p&gt;&lt;p&gt;    4、Decorator模式并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 中装饰模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    在Net框架中，有一个类型很明显的使用了“装饰模式”，这个类型就是Stream。Stream类型是一个抽象接口，它在System.IO命名空间里面，它其实就是Component。FileStream、NetworkStream、MemoryStream都是实体类ConcreteComponent。右边的BufferedStream、CryptoStream是装饰对象，它们都是继承了Stream接口的。&lt;/p&gt;
&lt;p&gt;   如图：&lt;br/&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201710/1048776-20171024140116910-1771095830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    Stream就相当于Component，定义装饰的对象，FileStream就是要装饰的对象，BufferedStream是装饰对象。我们看看BufferedStream的定义，部分定义了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BufferedStream : Stream
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _DefaultBufferSize = &lt;span&gt;4096&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Stream _stream;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结构很简单，对比结构图看吧，没什么可说的了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     今天的文章就写到这里了，总结一下我对这个模式的看法，这个模式有点像包饺子，ConcreteComponent其实是饺子馅，Decorator就像饺子皮一样，包什么皮就有什么的样子，皮和皮也可以嵌套，当然我们生活中的饺子只是包一层。其实手机也是一个装饰模式使用的好例子，以前我们的手机只是接打电话，然后可以发短信和彩信，我在装饰一个就可以拍照了。我们现在的手机功能很丰富，其结果也类似装饰的结果。随着社会的进步，技术发展，模块化的手机也出现了，其设计原理也和“装饰模式”就更接近了。不光手机，还有我们身边其他很多家用电器也有类似的发展经历，我们努力发现生活中的真理吧，然后再在软件环境中慢慢体会吧。&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 06:07:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/7723225.html</dc:identifier>
</item>
<item>
<title>尾递归是个什么鬼 - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/7722541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/7722541.html</guid>
<description>&lt;p&gt;了解尾递归之前，先了解一下尾调用。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在计算机科学里，&lt;span&gt;尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形&lt;/span&gt;。这种情形下该调用位置为尾位置。&lt;span&gt;（摘自维基百科）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的解释来自维基百科。介绍了什么叫尾调用。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function foo(data) {
    a(data);
    return b(data);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的a(data)和b(data)都是函数调用，但是b(data)是函数返回前的最后运行的东西，所以也是所谓的尾位置。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function foo1(data) {
    return a(data) + 1;
}
function foo2(data) {
    var ret = a(data);
    return ret;
}
function foo3(data) {
    var ret = a(data);
    return (ret === 0) ? 1 : ret;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种就不是尾调用，对于foo1,最后一个动作是+1操作，并非是直接函数调用；对于foo3,是经过计算返回的结果，也不是尾调用。，foo2也不是尾调用&lt;/p&gt;
&lt;p&gt;尾调用很重要的特性就是它可以不在调用栈上面添加一个新的堆栈帧，而是更新它。&lt;/p&gt;
&lt;p&gt;接下来说一下什么是尾递归：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;若一个函数在尾位置调用本身（或是一个尾调用本身的其他函数等），则称这种情况为尾递归，是递归的一种特殊情形。而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。这里注意：尾调用不一定是递归调用，但是尾递归一定是尾调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来通过斐波那契数列和阶乘来进一步理解尾递归的含义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 常规的斐波那契数列算法可能是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
int fib(int n) {

    if (n &amp;lt;= 2) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的这种递归计算最终的return操作是加法操作。所以不是尾递归。&lt;/p&gt;
&lt;p&gt;如果用尾递归就是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
 计算第n位斐波那契数列的值
 
 @param n 第n个数
 @param acc1 第n个数
 @param acc2 第n与第n+1个数的和
 @return 返回斐波那契数列值
 */
int tailfib(int n,int acc1,int acc2) {
    if (n &amp;lt; 2) {
        return acc1;
    }
    
    return tailfib(n-1,acc2,acc1 + acc2); 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比如我们想计算第10位斐波那契数列的值，只需要fib(5，1，1)即可。&lt;/p&gt;
&lt;p&gt;看一下测试效果，测试程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
int main(int argc, const char * argv[]) {
    clock_t start,finish;
   
    start = clock();
    printf(&quot;计算结果：%d\n&quot;, fib(45));
    finish = clock();
    printf(&quot;花费时间--------%lu\n&quot;,finish - start);

    
    start = clock();
    printf(&quot;计算结果：%d\n&quot;, tailfib(45,1,1));
    finish = clock();
    
    printf(&quot;花费时间--------%lu\n&quot;,finish - start);
    return 0;
    
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;计算结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
计算结果：1134903170
花费时间--------5540692
计算结果：1134903170
花费时间--------4
Program ended with exit code: 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效率可想而知。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阶乘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规的计算阶乘的方法可能是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
int fac(int n) {
    if (n == 1) {
        return 1;
    }
    return fac(n-1) * n;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复杂度为O(n)&lt;/p&gt;
&lt;p&gt;尾递归的算法是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
int tailfac(int n,int sum) {
    if (n == 1) {
        return sum;
    }
    return fac(n-1, n * sum);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 复杂度为O(1)&lt;/p&gt;
&lt;p&gt;测试一下效率,测试程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
int main(int argc, const char * argv[]) {
    clock_t start,finish;
   
    start = clock();
    printf(&quot;计算结果：%d\n&quot;, fac(16));
    finish = clock();
    printf(&quot;花费时间--------%lu\n&quot;,finish - start);

    
    start = clock();
    printf(&quot;计算结果：%d\n&quot;, tailfac(16,1));
    finish = clock();
    
    printf(&quot;花费时间--------%lu\n&quot;,finish - start);
    return 0;
    
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
计算结果：2004189184
花费时间--------31
计算结果：2004189184
花费时间--------2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;尾递归效率比较高，但是个人觉得有尾递归算法理解起来会比较困难，你需要标注一下每个传入参数的作用，否则刚接触不一定会用这个算法。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/04/tail-call.html&quot; target=&quot;_blank&quot;&gt;阮一峰的网络日志&lt;/a&gt; &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8&quot; target=&quot;_blank&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请标注来源：&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/7722541.html&quot;&gt;http://www.cnblogs.com/zhanggui/p/7722541.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 05:56:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/7722541.html</dc:identifier>
</item>
<item>
<title>简单理解下内存的几大区域 - 沉江小鱼</title>
<link>http://www.cnblogs.com/chenjiangxiaoyu/p/7723154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjiangxiaoyu/p/7723154.html</guid>
<description>&lt;p&gt;1.栈区&lt;/p&gt;
&lt;p&gt;栈区(stack)由编译器自动分配并释放，存放的是函数的参数值，局部变量等，方法调用的实参也是保存在栈区的。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。由编译器自动分配释放。&lt;/p&gt;
&lt;p&gt;2.堆区&lt;/p&gt;
&lt;p&gt;由程序员分配和释放，如果程序员不释放，可能会出现内存泄露，程序结束的时候，可能会由操作系统回收，比如iOS中alloc都是存放在堆中，优点是灵活方便，数据适应面广泛，但是效率有一定降低，堆空间的分配总是动态的，不同堆分配的内存无法互相操作。虽然程序结束的时候所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。&lt;/p&gt;
&lt;p&gt;3.全局区(静态区)&lt;/p&gt;
&lt;p&gt;全局变量和静态变量是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。&lt;/p&gt;
&lt;p&gt;注意：全局区又可分为未初始化全局区：.bss段和初始化全局区：data段。&lt;/p&gt;
&lt;p&gt;举例：int a；为初始化的 int a = 10 ；已初始化的。&lt;/p&gt;
&lt;p&gt;4.文字常量区 &lt;/p&gt;
&lt;p&gt;存放常量字符串，程序结束后由系统释放。&lt;/p&gt;
&lt;p&gt;5.代码区&lt;/p&gt;
&lt;p&gt;存放函数的二进制代码&lt;/p&gt;
&lt;p&gt;大致如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1031687/201710/1031687-20171024133035769-249237665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1031687/201710/1031687-20171024133212535-985895451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;例子代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
int a = 10; // 全局初始化区
char *p; //    全局未初始化区

main{
   int b; // 栈区
   char s[] = &quot;abc&quot; // 栈区
   char *p1; //    栈区
   char *p2 = &quot;123456&quot; 123456 在常量区，p2在栈上
   static int c = 0; // 全局(静态)初始化区
   
   w1 = (char *)malloc(10);
   w2 = (char *)malloc(20);
   分配得来的10和20字节的区域就在堆区。
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 申请后的系统是如何响应的？&lt;/h2&gt;
&lt;p&gt;1.栈&lt;/p&gt;
&lt;p&gt;存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。&lt;/p&gt;
&lt;p&gt;注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。&lt;/p&gt;
&lt;p&gt;2.堆&lt;/p&gt;
&lt;p&gt;首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 5&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;18.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;32&quot;&gt;
&lt;h2&gt;3.申请 的限制是怎样的? &lt;/h2&gt;
&lt;p&gt;栈：&lt;/p&gt;
&lt;p&gt;栈是向地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M(也有的说是1M,总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow，因此，能从栈获取的空间较小。&lt;/p&gt;
&lt;p&gt;堆:&lt;/p&gt;
&lt;p&gt;堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统使用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存，由此可见，堆获得的空间比较灵活，也比较大。&lt;/p&gt;
&lt;p&gt;低地址 ------------------&amp;gt; 高地址&lt;/p&gt;
&lt;p&gt;代码区 - 常量区 - 全局区 - 堆区 - 栈区&lt;/p&gt;
&lt;p&gt;栈：由系统自动分配，速度较快，不会产生内存碎片。&lt;/p&gt;
&lt;p&gt;堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过使用起来最方便。&lt;/p&gt;
&lt;p&gt;打个比喻来说：&lt;/p&gt;
&lt;p&gt;使用栈就像去饭馆里吃饭，只管点菜(发出申请)、付钱、和吃(使用)，吃完了就走，不用理会切菜，洗菜等准备工作和洗完、刷锅等扫尾工作。他的好处是快捷，但是自由度比较小。&lt;/p&gt;
&lt;p&gt;使用堆就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 24 Oct 2017 05:53:00 +0000</pubDate>
<dc:creator>沉江小鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjiangxiaoyu/p/7723154.html</dc:identifier>
</item>
<item>
<title>积极响应呼唤，从我们做起：2018年起，程序员节(10月24日)不上班 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/7722462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/7722462.html</guid>
<description>&lt;p&gt;今天是程序员节，祝大家节日快乐！&lt;/p&gt;
&lt;p&gt;2010年，我们在园子里倡议了一个节日——&lt;a href=&quot;http://www.cnblogs.com/cmt/archive/2010/10/12/1848613.html&quot; target=&quot;_blank&quot;&gt;程序员节(10月24日)&lt;/a&gt;，如今这个节日被得到越来越多的认可。但是7年了，只是被越来越多的程序员知道，只是被越来越多的宣传材料提到，但还没有程序员真正享受到这个节日。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/cyq1162/&quot; target=&quot;_blank&quot;&gt;路过秋天&lt;/a&gt; 呼吁 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/cyq1162/p/7717868.html&quot; target=&quot;_blank&quot;&gt;站在宇宙中心呼唤爱：程序员节(10月24日)今年不加班，明年不上班！&lt;/a&gt; 道出了很多程序员的心声，让“程序员节”成为程序员可以休息的真正的节假日。&lt;/p&gt;
&lt;p&gt;为了不让程序员节只是一个名义上的节日，为了不让程序员节沦落为只是为商家搞活动增添了一个题材，作为一家互联网公司，我们积极响应 &lt;a href=&quot;http://www.cnblogs.com/cyq1162/&quot;&gt;路过秋天&lt;/a&gt; 的呼唤，决定从明年(2018年)起，将程序员节(10月24日)作为每年的节假日，放假1天。&lt;/p&gt;
&lt;p&gt;期待更多公司能够给公司里的程序员朋友提供这样一个福利，让程序员过上一个真正属于自己的节日。&lt;/p&gt;

</description>
<pubDate>Tue, 24 Oct 2017 05:39:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/7722462.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET MVC 直连路由(特性路由) - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7722988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7722988.html</guid>
<description>&lt;p&gt;　　之前对Controller创建的分析中，知道了Controller的创建是有两个步骤组成，分别是Controller的&lt;span&gt;类型查找&lt;/span&gt;以及根据类型&lt;span&gt;创建Controller实例&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　在查询Controller的类型时，实际上是通过RouteData中的&lt;span&gt;Controller名称&lt;/span&gt;和&lt;span&gt;命名空间&lt;/span&gt;来完成匹配和查找的，而Controller的名称就根据路由对象中的&lt;span&gt;url模板来获取&lt;/span&gt;，如默认的url模板：&quot;{controller}/{action}/{id}&quot;。以下是根据ControllerName查找Controller类型的方法，需要注意的是，在通过Controller名称查找之前还有一个判断，当RouteData不为空且被匹配&lt;span&gt;为直连路由时&lt;/span&gt;，会通过另外的逻辑使用RouteData获取一个Controller类型。代码如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024104358316-1803556604.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　DirectRoute是什么？本章将从以下几点介绍直连路由相关内容：&lt;br/&gt;　　● 什么是直连路由&lt;br/&gt;　　● 如何在MVC中使用直连路由&lt;br/&gt;　　● 直连路由与约定路由的区别&lt;br/&gt;　　● 为什么使用直连路由&lt;/p&gt;
&lt;h2&gt;什么是直连路由&lt;/h2&gt;
&lt;p&gt;　　直连路由又称为特性路由(Attribute Routing)，因为它是通过特性的方式将路由的匹配模板直接应用到Action方法上。如下图代码中的action需要使用http://XXX/dr/test才能够正常访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024104848285-216139453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中Route特性的定义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024124901223-372372372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从其定义可以看出Route特性可以应用在Controller以及Action上。通过Route特性可以直接为action指定路由。&lt;/p&gt;
&lt;p&gt;　　那么&lt;span&gt;对于程序来说&lt;/span&gt;什么是直连路由呢？从最初给出的代码来看，代码层面是通过RouteData.HasDirectRouteMatch方法来判断的，下图是判断逻辑，非常简单仅仅判断Value中是否包含名称为“MS_DirectRouteMatches”的Key值。换句话说，RouteData中包含“MS_DirectRouteMatches”这个Key值的就是直连路由。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024125427004-894287010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;如何在MVC中使用直连路由&lt;/h2&gt;
&lt;p&gt;　　ASP.NET MVC中有一个对路由表的拓展对象RouteCollectionAttributeRoutingExtensions，其定义如下图所示，它的功能就是&lt;span&gt;将当前应用中使用特性定义的路由注册到路由表中&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024125804363-1290456990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以在注册路由时加入以下代码即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024125846301-217088517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在项目中添加以下测试代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024125930316-2047812425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行程序后可以看到dr/test以及dr/test2均被添加到路由表中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024125958473-658438811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并且在对应的路由信息中包含了Controller和action的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024130051566-1120916418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　注：此处添加了三条路由信息，其中一条它的值是一个RouteCollectionRoute类型，就是说该路由表又包含了一个路由表，被包含的这个路由表中的路由信息是该程序中所有&lt;span&gt;被Route特性标记的Action生成&lt;/span&gt;的，另外的两个LinkGenerationRoute也是通过特性生成的路由。换句话说&lt;span&gt;一个特性标记会生成两条路由信息&lt;/span&gt;，但为什么一个特性标记会在两个路由表中都插入路由对象本章节不再深入分析。&lt;br/&gt;　　关于如何在直连路由中使用默认值、路由前缀、默认路由、路由约束、直连路由的Area等功能可参考这篇文章：&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2013/10/17/attribute-routing-in-asp-net-mvc-5/&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/webdev/2013/10/17/attribute-routing-in-asp-net-mvc-5/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;直连路由与约定路由的区别&lt;/h2&gt;
&lt;p&gt;　　相对于直连路由来说，使用Controller和Action匹配的路由被称为&lt;span&gt;基于约定的路由&lt;/span&gt;，因为&lt;span&gt;请求url&lt;/span&gt;中携带了约定好的Controller和Action的名称。它们的区别主要有以下几点：&lt;br/&gt;　　1. 直连路由与约定路由，&lt;span&gt;路由的注册方式不同&lt;/span&gt;，前者通过查找所有Controller类型中是否使用Route特性来创建路由。后者通过在配置文件中自行添加。&lt;br/&gt;　　2. 直连路由在&lt;span&gt;注册时&lt;/span&gt;将对应的Controller和Action的信息包含到了Route对象中，而约定的路由是在&lt;span&gt;解析时&lt;/span&gt;通过url模板匹配获得Controller和Action信息。&lt;br/&gt;　　3. 当Action被Route特性标记后，Controller的类型查找不再会通过基于约定的路由的Controller类型查找逻辑。&lt;br/&gt;　　4. 当Action被Route特性标记后并且项目中使用了基于约定的路由，那么使用基于约定的路由方法是&lt;span&gt;访问不到&lt;/span&gt;被标记的action的，因为查找Action的逻辑中它们两种路由是分开的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024130301285-762998400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5. 直连路由请求中的RouteData自动添加了MS_DirectRoute相关的值，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171024130348629-1531918464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;为什么使用直连路由&lt;/h2&gt;
&lt;p&gt;　　直连路由最主要的特性就是路由与实际代码在&lt;span&gt;同一个文件&lt;/span&gt;里，这样在代码阅读时更容易将&lt;span&gt;路由与实际的Action进行匹配&lt;/span&gt;，另外使用直连路由可以根据实际的需求来“创造”一个更符合需求的url“新约定”，同时也可以避免基于约定的路由对代码内部实现的暴露。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本章通过在MVC的源码中发现两种不同的Controller、Action处理方式引出了直连路由的概念，实际上这是MVC5中加入的新特性，可以使用特性的方式指定对应的action的路由模板。但要注意的是尽量避免两种路由方式的混用造成代码混乱。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2013/10/17/attribute-routing-in-asp-net-mvc-5/&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/webdev/2013/10/17/attribute-routing-in-asp-net-mvc-5/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET MVC 直连路由(特性路由)&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7722988.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7722988.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;link_post_title&quot; class=&quot;link-post-title&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Oct 2017 05:35:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7722988.html</dc:identifier>
</item>
</channel>
</rss>