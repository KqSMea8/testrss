<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>KVM 初探 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8167539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8167539.html</guid>
<description>&lt;p&gt;KVM 是业界最为流行的 Hypervisor，全称是 Kernel-based Virtual Machine。它是作为 Linux kernel 中的一个内核模块而存在，模块名为 kvm.ko，也可以看作是一个进程，被内核调度并管理，从 Linux 2.6.20 版本开始被完全正式加入到内核的主干开发和正式发布代码中。 KVM 主要用于管理 CPU 和内存的虚拟化，IO 设备的虚拟化则是由 Qemu 来完成。为什么会有这样的分工，请继续往下看。&lt;/p&gt;
&lt;h2 id=&quot;kvm-与-qemu-的前世今生&quot;&gt;KVM 与 Qemu 的前世今生&lt;/h2&gt;
&lt;p&gt;Qemu 是一个纯软件实现的开源「模拟」软件，它能够模拟整套虚拟机的实现，包括 CPU、内存、各种 IO 设备、鼠标、键盘、USB 、网卡、声卡等等，基本上没有它不能模拟的。有人可能会比较疑惑它跟 KVM 之间到底有何关系，我们可以把它们看成是合作关系，好基友，谁都离不开彼此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVM 离不开 Qemu&lt;/strong&gt;。KVM 实现初期，为了简化开发和代码重用，在 Qemu 的基础上进行了修改，主要是将比较耗性能的 CPU 虚拟化和内存虚拟化部分移到了内核中实现，保留 IO 虚拟化模块在用户空间实现。这样的做法主要是考虑到性能的原因，CPU 和 内存虚拟化是非常复杂的虚拟化模块，而且使用非常频繁，如果实现在用户空间的话，用户态和内核态的频繁切换势必会对性能造成很大的影响。那为什么要单独保留 IO 虚拟化在用户空间呢，这个也是权衡之下的结果，首先 IO 设备太多了，其次 IO 虚拟化相对其他两个模块使用不是很频繁，开销会小一些，所以，为了尽可能保持内核的纯净性，才有了这样的分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qemu 离不开 KVM&lt;/strong&gt;。上面也说了，Qemu 是一个纯软件的实现，运行在用户空间，性能非常低下，所以，从 Qemu 的角度，可以说是 Qemu 使用了 KVM 的虚拟化功能，为自身虚拟机提供加速。&lt;/p&gt;
&lt;p&gt;早期两者还没有区分（没有同居），KVM 修改的模块叫 qemu-kvm，到 Qemu1.3 版本之后，两者就合二为一了（同居啦），如果我们在用 Qemu 创建虚拟机时，要加载 KVM 模块，需要为其指定参数 --enable-kvm。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180101150420284-1946220647.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;kvm-架构&quot;&gt;KVM 架构&lt;/h2&gt;
&lt;p&gt;KVM 是基于硬件虚拟化（Intel VT 或 AMD-V）实现的一套虚拟化解决方案，通过以上一个与 Qemu 关系的分析，我们基本上知道它在虚拟化领域处在一个什么样的地位。它其实只负责 CPU 和内存的虚拟化，不负责任何设备的模拟，而是提供接口给用户空间的 Qemu 来模拟。这个接口是 /dev/kvm，&lt;br/&gt;Qemu 通过 /dev/kvm 接口设置一个虚拟机的地址空间，然后向它提供模拟好的 I/O 设备，并将相关的设备回显操作映射到宿主机，完成整个 I/O 设备的虚拟化操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180101150434534-796729814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;/dev/kvm 接口是 Qemu 和 KVM 交互的“桥梁”，基本的原理是：/dev/kvm 本身是一个设备文件，这就意味着可以通过 ioctl 函数来对该文件进行控制和管理，从而可以完成用户空间与内核空间的数据交互。在 KVM 与 Qemu 的通信过程主要就是一系列针对该设备文件的 ioctl 调用。&lt;/p&gt;
&lt;p&gt;我就拿创建虚拟机举个例子，虚拟机本质上是宿主机的一个进程，包括用户态数据结构和内核态数据结构，用户态部分由 Qemu 创建并初始化，内核态部分则由 KVM 来完成，完成后会返回一个文件句柄来代表所创建的虚拟机，针对该文件句柄的 ioctl 调用就可以对虚拟机进行相应的管理，比如建立虚拟机地址空间和宿主机地址空间的映射关系，创建多个线程（虚拟处理器，vCPU）来供虚拟机使用等，对于创建出的 vCPU，也会生成相应的文件句柄，同样，对 vCPU 的文件句柄的 ioctl 调用就可以对 vCPU 进行管理。&lt;/p&gt;
&lt;p&gt;关于这块的具体细节，后面会有文章来专门讨论。&lt;/p&gt;
&lt;h2 id=&quot;vmm-管理工具-libvirt&quot;&gt;VMM 管理工具 —— libvirt&lt;/h2&gt;
&lt;p&gt;目前，虚拟化这个领域可以说是百花齐放，针对不同的场景提出了很多的虚拟化解决方案，KVM、Xen、VMware、VirtualBox、Hyper-V 等等，具体的这些方案有什么特点，可以看前文「虚拟化技术总览」。这么多方案势必有很多通用的模块，不同之处可能在于，与不同硬件厂商的适配上，为了支持更多厂商，以及应用更多的领域，有很多 IaaS 解决方案需要融合多种虚拟化技术。这个时候如果有一个平台类的管理工具就会非常方便，libvirt 就是这样一个工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180101150450503-1747651158.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;libvirt 除了能够支持多种虚拟化方案之外，还支持 OpenVZ、LXC 等容器虚拟化系统。它提供一套完善的虚拟机管理工具，支持 GUI 和命令行的形式，如 virsh、virt-install、virt-manager。由于它的通用性和易管理，很多云计算框架平台都在底层使用 libvirt 的 API 来管理虚拟机，比如 OpenStack、OpenNebula、Eucalyptus 等。这个工具我们仅仅提一下，有兴趣的可以装个玩玩。&lt;/p&gt;
&lt;p&gt;下面给出 KVM 和 Qemu 的 git 路径，有兴趣的可以把源码下下来研究下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kvm.git：
git clone git://git.kernel.org/pub/scm/virt/kvm/kvm.git
qemu.git（包括了 kvm）:
git clone git://git.qemu-project.org/qemu.git&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180101150607065-1576678883.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 07:08:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8167539.html</dc:identifier>
</item>
<item>
<title>JDK动态代理[1]----代理模式实现方式的概要介绍 - 劳夫子</title>
<link>http://www.cnblogs.com/liuyun1995/p/8144628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyun1995/p/8144628.html</guid>
<description>&lt;p&gt;日常工作中经常会接触到代理模式，但一直没有对其进行深究。代理模式一直就像一团迷雾一样存在我心里，什么是代理模式？为什么要使用代理？代理模式有哪些实现？它的底层机制是怎样的？这些问题促使着我迫切想要揭开代理模式的神秘面纱。&lt;/p&gt;
&lt;p&gt;1. 什么是代理模式？&lt;/p&gt;
&lt;p&gt;日常生活中我们经常会碰到代理模式，例如我们找房产中介帮我们介绍房子，找婚姻中介帮我们介绍对象，找保洁帮我们打理房间，找律师帮我们进行诉讼等。我们在无形中运用到了代理模式，却不知道它的存在。&lt;/p&gt;
&lt;p&gt;2. 为什么要使用代理？&lt;/p&gt;
&lt;p&gt;运用代理可以使我们的生活更加便利，有了代理，我们不需要自己去找房子，不需要自己去找对象，不需要自己去打理房间，不需要自己去诉讼。当然，你也可以选择一切都自己来干，但是存在前提条件，一是你是否都具备这样的资源和能力来做这些事情，二是你是否愿意花费这么多精力和时间来做这些事情。总之，代理模式使我们各专其事，我们可以将时间浪费在美好的事情上，而不用天天被一些琐事所羁绊。&lt;/p&gt;
&lt;p&gt;3. 代理模式有哪些实现？&lt;/p&gt;
&lt;p&gt;Java中的代理有静态代理和动态代理，下面我会分别用一个简单的例子来介绍一下静态代理和动态代理代码实现。&lt;/p&gt;
&lt;p&gt;3.1 静态代理&lt;/p&gt;
&lt;p&gt;代理接口：UserDao.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目标对象：UserDaoImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;正在保存用户...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理对象：TransactionHandler.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TransactionHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标代理对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDaoImpl target;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造代理对象时传入目标对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TransactionHandler(UserDaoImpl target) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标方法前的处理&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;开启事务控制...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标对象的方法&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        target.save();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标方法后的处理&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;关闭事务控制...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：Main.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建目标对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         UserDaoImpl target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理对象, 并使用接口对其进行引用&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         UserDao userDao = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionHandler(target);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对接口进行调用&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        userDao.save();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201370/201712/1201370-20171230153901804-1878837756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;总的来说静态代理实现简单也容易理解，但是静态代理不能使一个代理类反复作用于多个目标对象，代理对象直接持有目标对象的引用，这导致代理对象和目标对象类型紧密耦合了在一起。如果UserDao接口下还有另一个实现类也需要进行事务控制，那么就要重新写一个代理类，这样就会产生许多重复的模版代码，不能达到代码复用的目的。而动态代理就可以很好的解决这样的问题。&lt;/p&gt;
&lt;p&gt;3.2 动态代理&lt;/p&gt;
&lt;p&gt;代理接口：UserDao.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目标对象：UserDaoImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;保存用户信息...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理对象：TransactionHandler.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TransactionHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要代理的目标对象
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里设计为可以为任意对象添加事务控制, 所以将目标对象声明为Object&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造TransactionHandler时传入目标对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TransactionHandler(Object target) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标方法前的处理&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;开启事务控制...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标对象的方法&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         Object result =&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用目标方法后的处理&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;关闭事务控制...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放回方法调用结果&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：Main.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建目标对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Object target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建事务处理器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         TransactionHandler handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionHandler(target);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成代理类并使用接口对其进行引用&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         UserDao userDao =&lt;span&gt; (UserDao)Proxy.newProxyInstance(target.getClass().getClassLoader(),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                                                          target.getClass().getInterfaces(),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                                                          handler);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对接口进行方法调用&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        userDao.save();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201370/201712/1201370-20171230161258929-56213780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;之前我们发现了静态代理会产生许多重复代码，不能很好的进行代码复用，而动态代理能够很好的解决这个问题，代理类TransactionHandler实现了InvocationHandler接口，并且它持有的目标对象类型是Object，因此事务控制代理类TransactionHandler能够代理任意的对象，为任意的对象添加事务控制的逻辑。因此动态代理才真正的将代码中横向切面的逻辑剥离了出来，起到代码复用的目的。但是动态代理也有缺点，一是它的实现比静态代理更加复杂也不好理解；二是它存在一定的限制，例如它要求需要代理的对象必须实现了某个接口；三是它不够灵活，动态代理会为接口中的声明的所有方法添加上相同的代理逻辑。当然，这只是JDK动态代理所存在的一些缺陷，动态代理还有另外的实现如使用CGLIB库，在本文不做介绍，读者可以自行去了解。&lt;/p&gt;
&lt;p&gt;全文总结：&lt;/p&gt;
&lt;p&gt;本文从概念上为大家介绍了什么是代理模式，为什么要使用代理以及代理模式有哪些实现，并使用简单的例子为大家介绍静态代理和JDK动态代理的实现，分析了静态代理和动态代理各自的优缺点，使大家对代理模式有了一些大致的了解。不过到这里相信读者对于JDK动态代理还是会感到困惑，想要进一步了解代理类是怎样产生的。后续章节笔者会深入源码为大家呈现整个代理类的产生过程。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 07:01:00 +0000</pubDate>
<dc:creator>劳夫子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyun1995/p/8144628.html</dc:identifier>
</item>
<item>
<title>springboot学习（三）————使用HttpMessageConverter进行http序列化和反序列化 - 十二页</title>
<link>http://www.cnblogs.com/page12/p/8166935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/page12/p/8166935.html</guid>
<description>&lt;p&gt;以下内容，如有问题，烦请指出，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对象的序列化/反序列化大家应该都比较熟悉：序列化就是将object转化为可以传输的二进制，反序列化就是将二进制转化为程序内部的对象。序列化/反序列化主要体现在程序I/O这个过程中，包括网络I/O和磁盘I/O。&lt;/p&gt;
&lt;p&gt;那么什么是http序列化和反序列化呢？&lt;/p&gt;
&lt;p&gt;在使用springmvc时，我们经常会这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserController {
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; UserService userService;

    &lt;span class=&quot;fu&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/{id}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;fu&quot;&gt;getUserById&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@PathVariable&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; id) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; userService.&lt;span class=&quot;fu&quot;&gt;getUserById&lt;/span&gt;(id);
    }

    &lt;span class=&quot;fu&quot;&gt;@PostMapping&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;fu&quot;&gt;createUser&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@RequestBody&lt;/span&gt; User user) {
        System.&lt;span class=&quot;fu&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;create an user: &quot;&lt;/span&gt; + user);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; user;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@&lt;a href=&quot;mailto:RestController中有@responsebody&quot;&gt;RestController中有@ResponseBody&lt;/a&gt;，可以帮我们把User序列化到resp.body中。@RequestBody可以帮我们把req.body的内容转化为User对象。如果是开发Web应用，一般这两个注解对应的就是Json序列化和反序列化的操作。这里实际上已经体现了Http序列化/反序列化这个过程，只不过和普通的对象序列化有些不一样，Http序列化/反序列化的层次更高，属于一种Object2Object之间的转换。&lt;/p&gt;
&lt;p&gt;有过Netty使用经验的对这个应该比较了解，Netty中的Decoder和Encoder就有两种基本层次，层次低的一种是Byte &amp;lt;---&amp;gt; Message，二进制与程序内部消息对象之间的转换，就是常见的序列化/反序列化；另外一种是 Message &amp;lt;---&amp;gt; Message，程序内部对象之间的转换，比较高层次的序列化/反序列化。&lt;/p&gt;
&lt;p&gt;Http协议的处理过程，TCP字节流 &amp;lt;---&amp;gt; HttpRequest/HttpResponse &amp;lt;---&amp;gt; 内部对象，就涉及这两种序列化。在springmvc中第一步已经由Servlet容器（tomcat等等）帮我们处理了，第二步则主要由框架帮我们处理。上面所说的Http序列化/反序列化就是指的这第二个步骤，它是controller层框架的核心功能之一，有了这个功能，就能大大减少代码量，让controller的逻辑更简洁清晰，就像上面示意的代码那样，方法中只有一行代码。&lt;/p&gt;
&lt;p&gt;spirngmvc进行第二步操作，也就是Http序列化和反序列化的核心是HttpMessageConverter。用过老版本springmvc的可能有些印象，那时候需要在xml配置文件中注入MappingJackson2HttpMessageConverter这个类型的bean，告诉springmvc我们需要进行Json格式的转换，它就是HttpMessageConverter的一种实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E7%BB%98%E5%9B%BE1.png&quot; alt=&quot;springmvc消息转换过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Web开发中我们经常使用Json相关框架来进行第二步操作，这是因为Web应用中主要开发语言是js，对Json支持非常好。但是Json也有很大的缺点，大多数Json框架对循环引用支持不够好，并且Json报文体积通常比较大，相比一些二进制序列化更耗费流量。很多移动应用也使用Http进行通信，因为这是在手机app中，Json格式报文并没有什么特别的优势。这种情况下我们可能会需要一些性能更好，体积更小的序列化框架，比如Protobuf等等。&lt;/p&gt;
&lt;p&gt;当前的SpringMVC 4.3版本已经集成了Protobuf的Converter，org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter，使用这个类可以进行Protobuf中的Message类和http报文之间的转换。使用方式很简单，先依赖Protobuf相关的jar，&lt;a href=&quot;mailto:代码中直接@bean就行&quot;&gt;代码中直接@Bean就行&lt;/a&gt;，像下面这样，springboot会自动注入并添加这种Converter。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ProtobufHttpMessageConverter &lt;span class=&quot;fu&quot;&gt;protobufHttpMessageConverter&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProtobufHttpMessageConverter&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就不演示protobuf相关的内容了。&lt;/p&gt;
&lt;p&gt;另外有很重要的一点需要说明一下，springmvc可以同时配置多个Converter，根据一定的规则（主要是Content-type、Accept、controller方法的consumes/produces、Converter.mediaType以及Converter的排列顺序这四个属性）来选择到底是使用哪一个，这使得springmvc能够一个接口支持多种报文格式。这个规则的具体内容，下一篇再详细说明。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面重点说下如何自定义一个HttpMessageConverter，就用Java原生序列化为例，叫作JavaSerializationConverter，基本仿照ProtobufHttpMessageConverter来写。&lt;/p&gt;
&lt;p&gt;首先继承AbstractHttpMessageConverter，泛型类这里有几种方式可以选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最广的可以选择Object，不过Object并不都是可以序列化的，但是可以在覆盖的supports方法中进一步控制，因此选择Object是可以的&lt;/li&gt;
&lt;li&gt;最符合的是Serializable，既完美满足泛型定义，本身也是个Java序列化/反序列化的充要条件&lt;/li&gt;
&lt;li&gt;自定义的基类Bean，有些技术规范要求自己代码中的所有bean都继承自同一个自定义的基类BaseBean，这样可以在Serializable的基础上再进一步控制，满足自己的业务要求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里选择Serializable作为泛型基类。&lt;/p&gt;
&lt;p&gt;其次是选择一个MediaType，使得springmvc能够根据Accept和Content-type唯一确定是要使用JavaSerializationConverter，所以这个MediaType不能是通用的text/plain、application/json、*/*这种，得特殊一点，这里就用application/x-java-serialization;charset=UTF-8。因为Java序列化是二进制数据，charset不是必须的，但是MediaType的构造方法中需要指定一个charset，这里就用UTF-8。&lt;/p&gt;
&lt;p&gt;最后，二进制在电脑上不是可以直接拷贝的内容，为了方便测试，使用Base64再处理一遍，这样就显示成正常文本了，便于测试。&lt;/p&gt;
&lt;p&gt;整个代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pr.study.springboot.configure.mvc.converter;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.ByteArrayInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ByteArrayOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.Serializable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.nio.charset.Charset;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Base64;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.slf4j.Logger;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.LoggerFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.HttpInputMessage;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.HttpOutputMessage;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.MediaType;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.converter.AbstractHttpMessageConverter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.converter.HttpMessageNotReadableException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.http.converter.HttpMessageNotWritableException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.StreamUtils;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JavaSerializationConverter &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractHttpMessageConverter&amp;lt;Serializable&amp;gt; {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Logger LOGGER = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(JavaSerializationConverter.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JavaSerializationConverter&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// 构造方法中指明consumes（req）和produces（resp）的类型，指明这个类型才会使用这个converter&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MediaType&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;application&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;x-java-serialization&quot;&lt;/span&gt;, Charset.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;)));
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;supports&lt;/span&gt;(Class&amp;lt;?&amp;gt; clazz) {
        &lt;span class=&quot;co&quot;&gt;// 使用Serializable，这里可以直接返回true&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 使用object，这里还要加上Serializable接口实现类判断&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 根据自己的业务需求加上其他判断&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Serializable &lt;span class=&quot;fu&quot;&gt;readInternal&lt;/span&gt;(Class&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Serializable&amp;gt; clazz, HttpInputMessage inputMessage)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotReadableException {
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = StreamUtils.&lt;span class=&quot;fu&quot;&gt;copyToByteArray&lt;/span&gt;(inputMessage.&lt;span class=&quot;fu&quot;&gt;getBody&lt;/span&gt;());
        &lt;span class=&quot;co&quot;&gt;// base64使得二进制数据可视化，便于测试&lt;/span&gt;
        ByteArrayInputStream bytesInput = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(Base64.&lt;span class=&quot;fu&quot;&gt;getDecoder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;decode&lt;/span&gt;(bytes));
        ObjectInputStream objectInput = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectInputStream(bytesInput);
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Serializable) objectInput.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) {
            LOGGER.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;exception when java deserialize, the input is:{}&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(bytes, &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;), e);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeInternal&lt;/span&gt;(Serializable t, HttpOutputMessage outputMessage)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotWritableException {
        ByteArrayOutputStream bytesOutput = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();
        ObjectOutputStream objectOutput = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectOutputStream(bytesOutput);
        objectOutput.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(t);
        &lt;span class=&quot;co&quot;&gt;// base64使得二进制数据可视化，便于测试&lt;/span&gt;
        outputMessage.&lt;span class=&quot;fu&quot;&gt;getBody&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(Base64.&lt;span class=&quot;fu&quot;&gt;getEncoder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;encode&lt;/span&gt;(bytesOutput.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;()));
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加一个converter的方式有三种，代码以及说明如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 添加converter的第一种方式，代码很简单，也是推荐的方式&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 这样做springboot会把我们自定义的converter放在顺序上的最高优先级（List的头部）&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 即有多个converter都满足Accpet/ContentType/MediaType的规则时，优先使用我们这个&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; JavaSerializationConverter &lt;span class=&quot;fu&quot;&gt;javaSerializationConverter&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JavaSerializationConverter&lt;/span&gt;();
    }

    &lt;span class=&quot;co&quot;&gt;// 添加converter的第二种方式&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 通常在只有一个自定义WebMvcConfigurerAdapter时，会把这个方法里面添加的converter(s)依次放在最高优先级（List的头部）&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 虽然第一种方式的代码先执行，但是bean的添加比这种方式晚，所以方式二的优先级 大于 方式一&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configureMessageConverters&lt;/span&gt;(List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converters) {
        &lt;span class=&quot;co&quot;&gt;// add方法可以指定顺序，有多个自定义的WebMvcConfigurerAdapter时，可以改变相互之间的顺序&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 但是都在springmvc内置的converter前面&lt;/span&gt;
        converters.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JavaSerializationConverter&lt;/span&gt;());
    }

    &lt;span class=&quot;co&quot;&gt;// 添加converter的第三种方式&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 同一个WebMvcConfigurerAdapter中的configureMessageConverters方法先于extendMessageConverters方法执行&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 可以理解为是三种方式中最后执行的一种，不过这里可以通过add指定顺序来调整优先级，也可以使用remove/clear来删除converter，功能强大&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 使用converters.add(xxx)会放在最低优先级（List的尾部）&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 使用converters.add(0,xxx)会放在最高优先级（List的头部）&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;extendMessageConverters&lt;/span&gt;(List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converters) {
        converters.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JavaSerializationConverter&lt;/span&gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用下面的数据演示：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;// java序列化
rO0ABXNyAB1wci5zdHVkeS5zcHJpbmdib290LmJlYW4uVXNlcrt1879rvWjlAgAESgACaWRMAApjcmVhdGVUaW1ldAAQTGphdmEvdXRpbC9EYXRlO0wABWVtYWlsdAASTGphdmEvbGFuZy9TdHJpbmc7TAAEbmFtZXEAfgACeHIAIXByLnN0dWR5LnNwcmluZ2Jvb3QuYmVhbi5CYXNlQmVhbklx6Fsr8RKpAgAAeHAAAAAAAAAAe3NyAA5qYXZhLnV0aWwuRGF0ZWhqgQFLWXQZAwAAeHB3CAAAAWCs8ufxeHQAEGhlbGxvd29ybGRAZy5jb210AApoZWxsb3dvcmxk

// json
{&quot;id&quot;:123,&quot;name&quot;:&quot;helloworld&quot;,&quot;email&quot;:&quot;helloworld@g.com&quot;,&quot;createTime&quot;:&quot;2017-12-31 22:21:28&quot;}

// 对应的user.toString()
User[id=123, name=helloworld, email=helloworld@g.com, createTime=Sun Dec 31 22:21:28 CST 2017]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;演示结果如下，包含了一个接口多种报文格式支持的演示：&lt;/p&gt;
&lt;p&gt;1、请求是 GET + Accept: application/x-java-serialization，返回的是 Content-Type: application/x-java-serialization;charset=UTF-8 的Java序列化格式的报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、请求是 GET + Accept: application/json，返回的是 Content-Type: application/json;charset=UTF-8 的json格式报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222401.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、请求是 POST + Accept: application/x-java-serialization + Content-Type: application/x-java-serialization，返回的是 Content-Type: application/x-java-serialization;charset=UTF-8的Java序列化格式的报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、请求是 POST + Accept: application/json + Content-Type: application/x-java-serialization，返回的是 Content-Type: application/json;charset=UTF-8 的json格式报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222625.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、请求是 POST + Accept: application/json + Content-Type: application/json，返回的是 Content-Type: application/json;charset=UTF-8 的json格式报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、请求是 POST + Accept: application/x-java-serialization + Content-Type: application/json，返回的是 Content-Type: application/x-java-serialization;charset=UTF-8的Java序列化格式的报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231222747.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面再说些其他的有关Http序列化/反序列化的内容.&lt;br/&gt;1、jackson配置&lt;br/&gt;使用Jackson时，一般我们都会配置下ObjectMapper，常见的两个是时间序列化格式，以及是否序列化null值。使用springboot时，因为Jackson是内置加载的，那么如何配置我们想要的的Jackson属性呢？最贱的的方式，那就是自己注入一个ObjectMapper实例，这样spring内所有通过依赖注入使用ObjectMapper的地方，都会优先使用我们自己注入的那个，JacksonConverter也不例外。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * jackson的核心是ObjectMapper，在这里配置ObjectMapper来控制springboot使用的jackson的某些功能&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyObjectMpper {

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ObjectMapper &lt;span class=&quot;fu&quot;&gt;getObjectMapper&lt;/span&gt;() {
        ObjectMapper mapper = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ObjectMapper&lt;/span&gt;();
        mapper.&lt;span class=&quot;fu&quot;&gt;setSerializationInclusion&lt;/span&gt;(Include.&lt;span class=&quot;fu&quot;&gt;NON_NULL&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 不序列化null的属性&lt;/span&gt;
        mapper.&lt;span class=&quot;fu&quot;&gt;setDateFormat&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;)); &lt;span class=&quot;co&quot;&gt;// 默认的时间序列化格式&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; mapper;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、控制Json中某些属性的序列化方式&lt;br/&gt;官方文档中说了个&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/htmlsingle/#boot-features-json-components&quot;&gt;Custom JSON Serializers and Deserializers&lt;/a&gt;，我也没想到怎么用这个，后来网上发现了个比较好的例子，说的是rgb颜色的序列化。web页面需要的是css格式的rgb颜色，服务的提供的可能是三个独立的byte型数字，这时候就需要改变颜色属性的json序列化/反序列化方式。具体可以看看&lt;a href=&quot;http://www.baeldung.com/spring-boot-jsoncomponent&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;3、FastJson配置&lt;br/&gt;可能某些时候需要使用FastJson，这时候该如何配置呢？基本上和springmvc xml配置差不多，注入一个FastJsonHttpMessageConverter就行了。最简单的就是上面的配置JavaSerializationConverter的方式一，方式二和方式三也都行。&lt;br/&gt;不过会有奇怪的问题出现（&lt;a href=&quot;mailto:使用@jsonfield&quot;&gt;使用@JSONField&lt;/a&gt;(serialize=false, deserialize=false)注解createTime，用以区分FastJson和Jackson）：&lt;br/&gt;假如你把FastJson配置为优先级最高的，并且同时配置上JavaSerializationConverter，你会发现JavaSerializationConverter不管用了，请求是 GET + Accept: application/x-java-serialization，返回是 Content-Type: application/x-java-serialization;charset=UTF-8；，但是实际内容是json格式的，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xod87.com1.z0.glb.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171231234336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如你把FastJson配置为优先级最低的，别的不管，你以为得到会是Jackson序列化后的结果。但实际上，你用浏览器直接敲得到的是FastJson的，用上面的 GET 的 fiddler结果是jackson的；&lt;/p&gt;
&lt;p&gt;详细原因在下一篇讲解converter匹配规则时说。&lt;/p&gt;
&lt;p&gt;这里说下原因中重要且值得吐槽的一点，那就是FastJsonHttpMessageConverter默认注册的MediaType的 */*，然后就有了上面的 请求是 GET + Accept: application/x-java-serialization，返回是 Content-Type: application/x-java-serialization;charset=UTF-8；，但是实际内容是json格式的，这种挂羊头卖狗肉的行为，明着违反HTTP协议的规范。&lt;/p&gt;
&lt;p&gt;这个代码设计真是差，json框架就该只管json，这样霸道，什么格式都要管，为哪般！？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;相关代码：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/page12/study-springboot/tree/springboot-3&quot; class=&quot;uri&quot;&gt;https://gitee.com/page12/study-springboot/tree/springboot-3&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/page12/study-springboot/tree/springboot-3&quot; class=&quot;uri&quot;&gt;https://github.com/page12/study-springboot/tree/springboot-3&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 05:33:00 +0000</pubDate>
<dc:creator>十二页</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/page12/p/8166935.html</dc:identifier>
</item>
<item>
<title>Python 项目实践二（下载数据）第四篇 - GodChao</title>
<link>http://www.cnblogs.com/majianchao/p/8150200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/majianchao/p/8150200.html</guid>
<description>&lt;p&gt;接着上节继续学习，在本节中，你将下载JSON格式的人口数据，并使用json模块来处理它们。Pygal提供了一个适合初学者使用的地图创建工具，你将使用它来对人口数据进行可视化，以探索全球人口的分布情况。&lt;/p&gt;
&lt;p&gt;一 制作世界人口地图&lt;/p&gt;
&lt;p&gt;1 下载世界人口数据和提取相关的数据&lt;/p&gt;
&lt;p&gt;可以去（http://data.okfn.org/）下载population_data.json，来研究一下population_data.json，看看如何着手处理这个文件中的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[
  {
    &quot;Country Name&quot;: &quot;Arab World&quot;,
    &quot;Country Code&quot;: &quot;ARB&quot;,
    &quot;Year&quot;: &quot;1960&quot;,
    &quot;Value&quot;: &quot;96388069&quot;
  },
  {
    &quot;Country Name&quot;: &quot;Arab World&quot;,
    &quot;Country Code&quot;: &quot;ARB&quot;,
    &quot;Year&quot;: &quot;1961&quot;,
    &quot;Value&quot;: &quot;98882541.4&quot;
  },
省略。。。。
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件实际上就是一个很长的Python列表，其中每个元素都是一个包含四个键的字典：国家名、国别码、年份以及表示人口数量的值。我们只关心每个国家2010年的人口数量，因此我们首先编写一个打印这些信息的程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import json

#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)

for pop_dic in pop_data :
     if pop_dic[&quot;Year&quot;] == '2010' :
         country_name= pop_dic['Country Name']
         population = pop_dic['Value']
         print(country_name + &quot;:&quot; + population)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230141510351-526599780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 将字符串转换为数字值&lt;/p&gt;
&lt;p&gt;population_data.json中的每个键和值都是字符串。为处理这些人口数据，我们需要将表示人口数量的字符串转换为数字值，为此我们使用函数int()：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 population = int(pop_dic['Value'])
 print(country_name + &quot;:&quot; + str(population))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，对于有些值，这种转换会导致错误，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
===== RESTART: D:/study/python/code/world_population/world_population.py =====
Arab World:357868000
Caribbean small states:6880000
East Asia &amp;amp; Pacific (all income levels):2201536674
East Asia &amp;amp; Pacific (developing only):1961558757
Euro area:331766000
Europe &amp;amp; Central Asia (all income levels):890424544
Europe &amp;amp; Central Asia (developing only):405204000
European Union:502125000
Heavily indebted poor countries (HIPC):635663000
Traceback (most recent call last):
  File &quot;D:/study/python/code/world_population/world_population.py&quot;, line 12, in &amp;lt;module&amp;gt;
    population = int(pop_dic['Value'])
ValueError: invalid literal for int() with base 10: '1127437398.85751'
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导致上述错误的原因是，Python不能直接将包含小数点的字符串'1127437398.85751'转换为整数（这个小数值可能是人口数据缺失时通过插值得到的）。为消除这种错误，我们先将字符串转换为浮点数，再将浮点数转换为整数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
population = int(float(pop_dict['Value']))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数float()将字符串转换为小数，而函数int()丢弃小数部分，返回一个整数。每个字符串都成功地转换成了浮点数，再转换为整数。以数字格式存储人口数量值后，就可以使用它们来制作世界人口地图了。&lt;/p&gt;
&lt;p&gt;三 获取两个字母的国别码&lt;/p&gt;
&lt;p&gt;制作地图前，还需要解决数据存在的最后一个问题。Pygal中的地图制作工具要求数据为特定的格式：用国别码表示国家，以及用数字表示人口数量。处理地理政治数据时，经常需要用到几个标准化国别码集。population_data.json中包含的是三个字母的国别码，但Pygal使用两个字母的国别码。我们需要想办法根据国家名获取两个字母的国别码。Pygal使用的国别码存储在模块i18n（internationalization的缩写）中。字典COUNTRIES包含的键和值分别为两个字母的国别码和国家名。要查看这些国别码，可从模块i18n中导入这个字典，并打印其键和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
from pygal.i18n import COUNTRIES
 for country_code in sorted(COUNTRIES.keys()):
    print(country_code, COUNTRIES[country_code])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
======== RESTART: D:/study/python/code/world_population/countries.py ========
Traceback (most recent call last):
  File &quot;D:/study/python/code/world_population/countries.py&quot;, line 1, in &amp;lt;module&amp;gt;
    from pygal.i18n import COUNTRIES
ModuleNotFoundError: No module named 'pygal.i18n'
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因和解决方案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
The i18n module was removed in pygal-2.0.0, however, it can now be found in the pygal_maps_world plugin.
You can install that with pip install pygal_maps_world. Then you can access COUNTRIES as pygal.maps.world.COUNTRIES:
from pygal.maps.world import COUNTRIES
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按上面的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230144201023-203939981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
from pygal.maps.world import COUNTRIES

for country_code in sorted(COUNTRIES.keys()):
    print(country_code, COUNTRIES[country_code])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230144316882-934251942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为获取国别码，我们将编写一个函数，它在COUNTRIES中查找并返回国别码。我们将这个函数放在一个名为country_codes的模块中，以便能够在可视化程序中导入它：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
from pygal.maps.world import COUNTRIES

def get_country_code(country_name):
    #根据指定的国家，返回Pygal使用的两个字母的国别码
    for code,name in COUNTRIES.items():
        if name == country_name :
            return code
    # 如果没有找到指定的国家，就返回None
    return None

print(get_country_code('Andorra'))
print(get_country_code('United Arab Emirates'))
print(get_country_code('Afghanistan'))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
======= RESTART: D:/study/python/code/world_population/contry_codes.py =======
ad
ae
af
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，在world_population.py中导入get_country_code：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import json
from country_codes import get_country_code

#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)

# 打印每个国家2010年的人口数量
for pop_dic in pop_data :
     if pop_dic[&quot;Year&quot;] == '2010' :
         country_name= pop_dic['Country Name']
         population = int(float(pop_dic['Value']))
         code =get_country_code(country_name)

         if code :
             print(code + &quot;:&quot; + str(population))
         else :
             print(&quot;ERROR -&quot; + country_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230145712960-1391172830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导致显示错误消息的原因有两个。首先，并非所有人口数量对应的都是国家，有些人口数量对应的是地区（阿拉伯世界）和经济类群（所有收入水平）。其次，有些统计数据使用了不同的完整国家名（如Yemen, Rep.，而不是Yemen）。当前，我们将忽略导致错误的数据，看看根据成功恢复了的数据制作出的地图是什么样的。&lt;br/&gt;3 绘制世界地图&lt;/p&gt;
&lt;p&gt;有了国别码后，制作世界地图易如反掌。Pygal提供了图表类型Worldmap，可帮助你制作呈现各国数据的世界地图。为演示如何使用Worldmap，我们来创建一个突出北美、中美和南美的简单地图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import pygal
#此处书中的代码已过时，请用最新的。
wm = pygal.maps.world.World()
wm.title = 'North, Central, and South America'
wm.add('North America', ['ca', 'mx', 'us'])
wm.add('Central America', ['bz', 'cr', 'gt', 'hn', 'ni', 'pa', 'sv'])
wm.add('South America', ['ar', 'bo', 'br', 'cl', 'co', 'ec', 'gf',
'gy', 'pe', 'py', 'sr', 'uy', 've'])

wm.render_to_file('americas.svg')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（1）我们创建了一个Worldmap实例，并设置了该地图的的title属性&lt;/p&gt;
&lt;p&gt;（2）了方法add()，它接受一个标签和一个列表，其中后者包含我们要突出的国家的国别码。每次调用add()都将为指定的国家选择一种新颜色，并在图表左边显示该颜色和指定的标签。我们要以同一种颜色显示整个北美地区，因此第一次调用add()时，在传递给它的列表中包含'ca'、'mx'和'us'，以同时突出加拿大、墨西哥和美国。接下来，对中美和南美国家做同样的处理。&lt;/p&gt;
&lt;p&gt;（3）方法render_to_file()创建一个包含该图表的.svg文件，你可以在浏览器中打开它。输出是一幅以不同颜色突出北美、中美和南美的地图，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230150755523-487976682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4 绘制完整的世界人口地图&lt;/p&gt;
&lt;p&gt;要呈现其他国家的人口数量，需要将前面处理的数据转换为Pygal要求的字典格式：键为两个字母的国别码，值为人口数量。为此，在world_population.py中添加如下代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import json
from country_codes import get_country_code
import pygal
#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)
    
cc_populations ={}
for pop_dict in pop_data :
    if pop_dict['Year'] == '2010' :
        country_name= pop_dict['Country Name']
        population = int(float(pop_dict['Value']))
        code =get_country_code(country_name)

        if code :
            cc_populations[code] = population

wm = pygal.maps.world.World()
wm.title=&quot;World Population in 2010,by Country&quot;
wm.add('2010',cc_populations)

wm.render_to_file(&quot;world_population.svg&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230152413695-1182289174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5根据人口数量将国家分组&lt;/p&gt;
&lt;p&gt;印度和中国的人口比其他国家多得多，但在当前的地图中，它们的颜色与其他国家差别较小。中国和印度的人口都超过了10亿，接下来人口最多的国家是美国，但只有大约3亿。下面不将所有国家都作为一个编组，而是根据人口数量分成三组——少于1000万的、介于1000万和10亿之间的以及超过10亿的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import json
from country_codes import get_country_code
import pygal
#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)
    
cc_populations ={}
for pop_dict in pop_data :
    if pop_dict['Year'] == '2010' :
        country_name= pop_dict['Country Name']
        population = int(float(pop_dict['Value']))
        code =get_country_code(country_name)

        if code :
            cc_populations[code] = population


# 根据人口数量将所有的国家分成三组
cc_pops_1, cc_pops_2, cc_pops_3 = {}, {}, {}

for cc, pop in cc_populations.items():
    if pop &amp;lt; 10000000:
        cc_pops_1[cc] = pop
    elif pop &amp;lt; 1000000000:
        cc_pops_2[cc] = pop
    else:
        cc_pops_3[cc] = pop
# 看看每组分别包含多少个国家
print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))

wm = pygal.maps.world.World()
wm.title=&quot;World Population in 2010,by Country&quot;
#wm.add('2010',cc_populations)
wm.add('0-10m', cc_pops_1)
wm.add('10m-1bn', cc_pops_2)
wm.add('&amp;gt;1bn', cc_pops_3)

wm.render_to_file(&quot;world_population.svg&quot;)
             
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230153411117-954847319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在使用了三种不同的颜色，让我们能够看出人口数量上的差别。在每组中，各个国家都按人口从少到多着以从浅到深的颜色。&lt;/p&gt;
&lt;p&gt; 6 使用Pygal设置世界地图的样式&lt;/p&gt;
&lt;p&gt;在这个地图中，根据人口将国家分组虽然很有效，但默认的颜色设置很难看。例如，在这里，Pygal选择了鲜艳的粉色和绿色基色。下面使用Pygal样式设置指令来调整颜色。我们也让Pygal使用一种基色，但将指定该基色，并让三个分组的颜色差别更大：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import json
from country_codes import get_country_code
import pygal
from pygal.style import RotateStyle
#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)
    
cc_populations ={}
for pop_dict in pop_data :
    if pop_dict['Year'] == '2010' :
        country_name= pop_dict['Country Name']
        population = int(float(pop_dict['Value']))
        code =get_country_code(country_name)

        if code :
            cc_populations[code] = population


# 根据人口数量将所有的国家分成三组
cc_pops_1, cc_pops_2, cc_pops_3 = {}, {}, {}

for cc, pop in cc_populations.items():
    if pop &amp;lt; 10000000:
        cc_pops_1[cc] = pop
    elif pop &amp;lt; 1000000000:
        cc_pops_2[cc] = pop
    else:
        cc_pops_3[cc] = pop
# 看看每组分别包含多少个国家
print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))
wm_style=RotateStyle('#336699')
wm = pygal.maps.world.World(style=wm_style)
wm.title=&quot;World Population in 2010,by Country&quot;
#wm.add('2010',cc_populations)
wm.add('0-10m', cc_pops_1)
wm.add('10m-1bn', cc_pops_2)
wm.add('&amp;gt;1bn', cc_pops_3)

wm.render_to_file(&quot;world_population.svg&quot;)
             
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pygal样式存储在模块style中，我们从这个模块中导入了样式RotateStyle。创建这个类的实例时，需要提供一个实参——十六进制的RGB颜色；Pygal将根据指定的颜色为每组选择颜色。十六进制格式的RGB颜色是一个以井号（#）打头的字符串，后面跟着6个字符，其中前两个字符表示红色分量，接下来的两个表示绿色分量，最后两个表示蓝色分量。每个分量的取值范围为00（没有相应的颜色）~FF（包含最多的相应颜色）。如果你在线搜索hex color chooser（十六进制颜色选择器），可找到让你能够尝试选择不同的颜色并显示其RGB值的工具。这里使用的颜色值（#336699）混合了少量的红色（33）、多一些的绿色（66）和更多一些的蓝色（99），它为RotateStyle提供了一种淡蓝色基色。&lt;/p&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230160605492-2114486495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7 加亮颜色主题&lt;/p&gt;
&lt;p&gt;Pygal通常默认使用较暗的颜色主题。为方便印刷，我使用LightColorizedStyle加亮了地图的颜色。这个类修改整个图表的主题，包括背景色、标签以及各个国家的颜色。要使用这个样式，先导入它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from pygal.style import LightColorizedStyle, RotateStyle
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再使用RotateStyle创建一种样式，并传入另一个实参base_style：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
wm_style = RotateStyle('#336699', base_style=LightColorizedStyle)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的代码和效果图如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import json
from country_codes import get_country_code
import pygal
from pygal.style import RotateStyle,LightColorizedStyle

#将数据加载到一个列表中
filename= 'population_data.json'

with open(filename) as f :
    pop_data = json.load(f)
    
cc_populations ={}
for pop_dict in pop_data :
    if pop_dict['Year'] == '2010' :
        country_name= pop_dict['Country Name']
        population = int(float(pop_dict['Value']))
        code =get_country_code(country_name)

        if code :
            cc_populations[code] = population


# 根据人口数量将所有的国家分成三组
cc_pops_1, cc_pops_2, cc_pops_3 = {}, {}, {}

for cc, pop in cc_populations.items():
    if pop &amp;lt; 10000000:
        cc_pops_1[cc] = pop
    elif pop &amp;lt; 1000000000:
        cc_pops_2[cc] = pop
    else:
        cc_pops_3[cc] = pop
# 看看每组分别包含多少个国家
print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))
wm_style=RotateStyle('#336699',base_style=LightColorizedStyle)
wm = pygal.maps.world.World(style=wm_style)
wm.title=&quot;World Population in 2010,by Country&quot;
#wm.add('2010',cc_populations)
wm.add('0-10m', cc_pops_1)
wm.add('10m-1bn', cc_pops_2)
wm.add('&amp;gt;1bn', cc_pops_3)

wm.render_to_file(&quot;world_population.svg&quot;)
             
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201712/1080659-20171230161320445-1467956424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未完待续，今天是元旦节第二天，加油！&lt;/p&gt;

</description>
<pubDate>Mon, 01 Jan 2018 04:27:00 +0000</pubDate>
<dc:creator>GodChao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/majianchao/p/8150200.html</dc:identifier>
</item>
<item>
<title>DeepLearning.ai学习笔记（四）卷积神经网络 -- week1 卷积神经网络基础知识介绍 - marsggbo</title>
<link>http://www.cnblogs.com/marsggbo/p/8166487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsggbo/p/8166487.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/19749648.jpg&quot;/&gt;&lt;br/&gt;如图示，之前课程中介绍的都是64* 64 &lt;em&gt;3的图像，而一旦图像质量增加，例如变成1000&lt;/em&gt; 1000 * 3的时候那么此时的神经网络的计算量会巨大，显然这不现实。所以需要引入其他的方法来解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/82201775.jpg&quot;/&gt;&lt;br/&gt;边缘检测可以是垂直边缘检测，也可以是水平边缘检测，如上图所示。&lt;/p&gt;
&lt;p&gt;至于算法如何实现，下面举一个比较直观的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/64579265.jpg&quot;/&gt;&lt;br/&gt;可以很明显的看出原来6 * 6的矩阵有明显的垂直边缘，通过3 * 3的过滤器(也叫做 &lt;strong&gt;“核”&lt;/strong&gt;)卷积之后，仍然保留了原来的垂直边缘特征，虽然这个边缘貌似有点大，这是因为数据不够大的原因，如果输入数据很大的话这个不是很明显了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/88868490.jpg&quot;/&gt;&lt;br/&gt;除了上面的垂直，水平边缘检测，其实也可以检测初颜色过度变化，例如是亮变暗，还是暗变亮？&lt;/p&gt;
&lt;p&gt;下面是一些常见的过滤器，第二个是&lt;strong&gt;Sobel filter&lt;/strong&gt;，具有较强的鲁棒性，第三个是&lt;strong&gt;Schoss filter&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实过滤器的9个参数也可以通过学习的方式获得，虽然比较费劲，但是可能会学到很多其他除了垂直，水平的边缘特征，例如45°，70°等各种特征。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/68953479.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么要用padding&quot;&gt;&lt;strong&gt;1.为什么要用padding&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;之所以运用Padding(填充)主要是为了解决如下两个缺点：&lt;/p&gt;
&lt;p&gt;1.由前面的例子可以看到，每经过一次卷积计算，原数据都会减小，但有的时候我们并不希望这样。举个比较极端的例子：假设原数据是30 * 30的一只猫的图像，经过10次卷积(过滤器是3 * 3)后，最后图像只剩下了10 * 10了，此时不就剩下马赛克了吗23333&lt;/p&gt;
&lt;p&gt;2.由卷积的计算方法可以知道，图像边缘特征计算次数显然少于图像中间位置的像素点，如下图示(绿色的位置明显是冷宫)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/3232199.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以为了解决上=上面两个问题，引入了padding，一般是padding=1，填充的数据是0。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-26/27448501.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来的6 * 6填充后变成了8 * 8，此时在经过一次卷积得到的仍旧是6 * 6的矩阵。&lt;/p&gt;
&lt;p&gt;下面总结一下卷积之后得到矩阵大小的计算方法，假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原数据是 n * n&lt;/li&gt;
&lt;li&gt;过滤器是 f * f&lt;/li&gt;
&lt;li&gt;padding p * p&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;得到的矩阵大小是 (n+2p-f+1)*(n+2p-f+1)&lt;/p&gt;
&lt;p&gt;对于第二个缺点，虽然边缘像素点仍旧计算的比较少，但是这个缺点至少一定程度上被削弱了。&lt;/p&gt;
&lt;h2 id=&quot;如何padding的大小&quot;&gt;&lt;strong&gt;2.如何padding的大小&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;两种选择：&lt;strong&gt;Valid 卷积&lt;/strong&gt;和&lt;strong&gt;Same 卷积&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;valid 卷积&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即不添加padding。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Same 卷积&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即保持原图像矩阵的大小。满足 (n+2p-f+1) = n ,即 &lt;span class=&quot;math inline&quot;&gt;\(p=\frac{f-1}{2}\)&lt;/span&gt;&lt;br/&gt;为了满足上式，f一般奇数。&lt;/p&gt;

&lt;p&gt;过滤器纵向，横向都需要按步长S来移动，如图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-27/6875046.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合之前的内容，输出矩阵大小计算公式方法为，假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原数据是 : n * n&lt;/li&gt;
&lt;li&gt;过滤器是 : f * f&lt;/li&gt;
&lt;li&gt;padding : p * p&lt;/li&gt;
&lt;li&gt;步长Stride: s * s&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;得到的矩阵大小是 ⌊&lt;span class=&quot;math inline&quot;&gt;\(\frac{n+2p-f}{s}\)&lt;/span&gt;+1⌋*⌊&lt;span class=&quot;math inline&quot;&gt;\(\frac{n+2p-f}{s}\)&lt;/span&gt;+1⌋&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⌊⌋&lt;/strong&gt;: 向下取整符号 ⌊59/60⌋=0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⌈⌉&lt;/strong&gt;：向上取整符号 ⌈59/60⌉=1&lt;/p&gt;

&lt;p&gt;这一节用立体卷积来解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-27/86674563.jpg&quot;/&gt;&lt;br/&gt;如图示，输入矩阵是 6 * 6 * 3(height * width * channels),过滤器是3 * 3 * 3，计算方法是一一对应相乘相加，最后得到4 * 4的二维矩阵。&lt;/p&gt;
&lt;p&gt;有时可能需要检测横向边缘和纵向边缘，或者其他特征，所以我们可以使用多个过滤器。&lt;br/&gt;上图则使用了两个过滤器，得到的特征矩阵大小为 4 * 4 * 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-31/5235528.jpg&quot;/&gt;&lt;br/&gt;如图示得到4 * 4的矩阵后还需要加上一个变差&lt;span class=&quot;math inline&quot;&gt;\(b_n\)&lt;/span&gt;，之后还要进行非线性转换，即用ReLU函数。因此假如在某一卷积层中使用了10个3 * 3的过滤器，那么一共有&lt;span class=&quot;math inline&quot;&gt;\((3*3+1)*10=280\)&lt;/span&gt;个参数。&lt;/p&gt;
&lt;p&gt;下面总结了各项参数的大小和表示方法：&lt;/p&gt;
&lt;p&gt;输出层与输入层计算公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(n_{H/W}^{[l]}=[\frac{n_{H/W}^{[l-1]}+2p^{[l]}-f^{[l]}}{s^{[l]}}+1]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/17-12-31/3480481.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/7758292.jpg&quot;/&gt;&lt;br/&gt;上图简单介绍了卷积网络的计算过程，需要再介绍的一点是最后一层的全连接层，即将7 * 7 * 40的输出矩阵展开，得到1960个节点，然后再采用逻辑回归或Softmax来进行预测。&lt;/p&gt;
&lt;p&gt;另外从上面的例子还可以看到，在一般的卷积神经网络中，每一层的矩阵的height和width是逐渐减小的，而channel则是增加的。&lt;/p&gt;
&lt;p&gt;卷积神经网络中常见的三中类型的layer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Convolution (Conv 卷积层)&lt;/li&gt;
&lt;li&gt;Pooling (Pool 池化层)&lt;/li&gt;
&lt;li&gt;Fully connected (FC 全连接层)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pooling layer(池化层)的作用是压缩数据，加速运算，同时提高所提取特征的鲁棒性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Max Pooling&lt;br/&gt;即选取最大的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/27069145.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Average Pooling&lt;br/&gt;即计算平均值，但是这个用的不多，因为这个会加入更多的计算量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/74565400.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：一般来说池化层是不需要Padding的，所以p都会置为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：在吴大大的视频中将 &lt;strong&gt;Conv layer&lt;/strong&gt;和 &lt;strong&gt;Pooling layer&lt;/strong&gt;合并在一起视为一层，因为池化层没有参数(因为池化层的过滤器的无参数，而且其大小可以事先确定好)。 但是在其他文献中可能会把池化层算成单独的层，所以具体视情况而定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/90324496.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;卷积相比于全连接的好处最直观的就是使用的参数更少：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/34463177.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图示，加入我们有一个32 * 32 * 3的图片，经过6个5 * 5的过滤器后可以得到28 * 28 * 6的矩阵，此时我们只需要 &lt;span class=&quot;math inline&quot;&gt;\(5*5*6=150\)&lt;/span&gt;个参数就可以了。而如果不用卷积呢？&lt;/p&gt;
&lt;p&gt;首先32 * 32 &lt;em&gt;3 = 3072，假如输出矩阵也要是28&lt;/em&gt; 28 * 6，即4704个节点，如果全连接的话那么就需要4704 * 3072个权&lt;br/&gt;重参数，所以这个对比还是很明显的了。&lt;/p&gt;
&lt;p&gt;至于为什么可以保证参数少的同时也保证了有效性，是因为如下两个原因&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数共享(Parameter sharing)&lt;/li&gt;
&lt;li&gt;稀疏连接(Sparsity of connections)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://opn1dyhml.bkt.clouddn.com/18-1-1/21648538.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数共享：例如我们希望获取图像的竖向特征，那么我们只需加入一个可以检测竖向特征的过滤器就够了。&lt;br/&gt;稀疏连接：如上图所示，输出矩阵左上角的0只与输入矩阵左上角的9个元素有关，其他的值不会干扰。输出矩阵其他位置也一样。所以这就是为什么卷积网络也可以捕捉到图像平移的特征，例如将图片中的猫向左平移几个像素点后，依然能够识别正确。&lt;/p&gt;
&lt;footer&gt;&lt;br/&gt;&lt;h3 id=&quot;autoid-2-0-0&quot;&gt;&lt;br/&gt;&lt;strong&gt;MARSGGBO&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;♥&lt;/span&gt;原创&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;2018-01-01&lt;/strong&gt;
&lt;/p&gt;
&lt;br/&gt;&lt;/footer&gt;</description>
<pubDate>Mon, 01 Jan 2018 04:16:00 +0000</pubDate>
<dc:creator>marsggbo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/marsggbo/p/8166487.html</dc:identifier>
</item>
<item>
<title>2017工作总结 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/7998777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/7998777.html</guid>
<description>&lt;p&gt;     静儿总结自己的职业生涯分为三个阶段。第一个阶段为期十年，是纯技术阶段，是人生的积累期。第二个阶段是管理阶段，是综合能力整合期。第三个阶段是突破阶段，打造自己独特的核心竞争力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　刚毕业的同学可能会觉得技术高大上，技术好了最傲娇。但是技术分成纯基础建设型和业务型。纯技术建设型基本需要做到JAVA之父那样，可以做出全球公认的都在用的底层技术或者框架。但是这种技术终归是一个产品，设计比实现重要。因为只要能把这个产品的市场前景说清楚，拉到投资的问题不大，有钱的话找技术不错的开发者问题也不大。&lt;/p&gt;
&lt;p&gt;　　业务型就更不用说了。设计很重要。如果这个设计足够大，各个模块之间要有清晰的边界，设计模块要根据人员、硬件资源等外部资源做合理的划分。项目管理的价值就此体现。&lt;/p&gt;
&lt;p&gt;　　总结就是：纯技术能发挥的价值要比设计和管理低很多。&lt;/p&gt;
&lt;p&gt;　　那么我为什么要花十年做这个技术积累，而且积累的结果是刚工作一年多的人，你跟他谈技术，他会非常不屑，他觉得自己技术很牛逼，觉得自己那么聪明。我还不能跟他说要是你这活儿我自己做我用你三分之一的时间，能够做出来一个维护性更好，架构更合理，更符合未来演进的代码。因为我的事情太多，要去完成太多更加重要的事情，我没时间自己去做写代码这种谁都能做的事情。&lt;/p&gt;
&lt;p&gt;　　我刚工作的时候，也是觉得自己技术很牛逼，自己那么聪明。现在觉得那时候那么傻。刚工作的时候，觉得自己谁的心思都能猜的破。什么比赛只要我参加，大奖肯定是我的，因为我擅长找诀窍。我现在声称自己那时候是专业的翻译，无技术可言。是，刚毕业由于日语比赛得了大奖，从此工作就是给大家上日语课、参加电视会议当翻译、陪鬼子吃饭K歌。但是那时候为了给我去日本的机会，我参加一个开发的项目。我一个人干了他们6个人的活儿，还比他们干的快。记得有次因为什么问题，我们领导是个技术大白痴，我们下面的人发生了分歧。组里其他人都说我错了，因为老师不是这么讲的，技术大白痴的领导就说大家说我错了我就是错了，我们打赌一顿饭，结果找来权威。权威说我是对的，他们太教条了。领导输给我一顿饭，我们组的人机灵，就说一起吃饭，其他人AA，我不用出。但是领导还是很怀恨的，所以最后把大BOSS给我要来的出差名额给了组里干活儿最慢最少的那个女孩。就是想证明别的都不重要，听话最重要。最后大BOSS去鬼子那边又要了一个名额给我，我是翻译啊，和鬼子关系好啊，他们愿意为我争取权益的。&lt;/p&gt;
&lt;p&gt;　　刚工作，我在我们整个事业部相当有名气，各种刊物啦啥的全都是我。无人不知无人不晓的。1年能从零过国际日语1级的天才。我参加的考试都甩出第二名几十分。最大的缺点是骄傲，最大的优点是傲娇。现在看只能说明自己站的低，眼光很低。技术是男孩子天生擅长的东西，就好像语言是女孩子天生擅长的东西。干自己擅长的东西很顺利，但是其实对自己整体软素质的提高没有多大用处。所以我离开了第一个工作，专心做技术，一做十年，因为我不擅长这个。&lt;/p&gt;
&lt;p&gt;　　完成需求是最容易的。刚工作的人代码中类名、方法名看上去就像产品给出的需求文档的翻译，慢慢的命名有了自己的领域模型概念，可以体现出自己的设计模式。&lt;/p&gt;
&lt;p&gt;　　这十年因为我在写代码，所以我可以做很多的事情，因为写代码太不费脑子了。最近胖了十斤，我短期也不打算再减下去了。因为我要把自己的精力收敛。之前做个写代码的，我一天写一个专利跟玩儿似的，还自己接着私活、创着业、画个画、写个博客、维护着公众号、时不时去知名网站发表个文章、学个外语、写个框架。关键是还减着肥。因为减肥要少吃饭，脑力是不够用的。能一边减肥的最大关键是做的事情都不怎么费脑子。&lt;/p&gt;
&lt;p&gt;　　所以这编程的这十年不仅是技术在积累的过程。而是我想要比别人走的更远，就要比别人更能忍，不贪心不着急，踩足够多的坑，收敛好可能会占用精力的事情。所以很多女孩子总结想要几年后像我一样最重要的一条是：要有个像我一样的好老公。确实是：我在家除了做做瑜伽、普拉提、画个画、练个字，基本都不做啥。如果我不工作，真的会憋出病来。工作和生活不能做很好的平衡的话，刚工作的时候可能进步很快，终究会被搁置的事情所拖累，工作中也会有很低的天花板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这是目前在经历的阶段。我上面的领导都是我特别敬佩的人。其实他们觉得我并不胜任现在的工作，只是愿意给我机会。不胜任的原因主要有两个：第一是我的做事风格，很多事情我都自己做了，觉得会让手下的人没有锻炼出来。我还特别累，没有更多的时间去思考。第二是手下有人不服我。如果再加上一点，那就是我需要是一个金融的领域专家。额，我之前是做社交网络和视频的。基本是面向C端，现在是面向B端的。&lt;/p&gt;
&lt;p&gt;　　第一是为什么很多事情我要自己做，现在其实自己做的少了，因为现在带两个团队，人手多了些。之前确实是缺人，其他人手里活儿更多。关键是作为一个管理者需要自上而下和自下而上两种思维方式。我初来乍到，如果自己不动手做一些事情，做出的决定很可能是基于自己之前的经验，未必符合实际情况。很多潜在的问题看不到，消息来源只是依赖于别人的汇报。&lt;/p&gt;

&lt;p&gt;　　第二是手下有人不服我。我刚来，人家确实在部门呆的时间比较长了，原来是直接向我领导汇报的，现在向我汇报，心里多少有些不痛快。跨级汇报确实是禁忌，我上面提到自己刚工作的事情，为什么大BOSS给我要来的出差机会，领导要给别人。最根本的原因是原来领导一直说要我好好干，让我出差。他手里一直没有机会。我就跨过他找了大BOSS。所以人家要给我点颜色看看的。&lt;/p&gt;
&lt;p&gt;　　之前在乐视和我家微微一笑很倾城的男神老大聊天，谈到怎样考察一个人的管理能力。男神老大说一个方面是有没有开过人。我说招聘来的肯定是符合自己要求的，再说人都是可塑的嘛。男神老大摇摇头。现在想来确实是：我现在带的人还少，还有些精力培养人。但是如果一个人给大家带来的负面影响影响整个团队的凝聚力、价值观，其实让他走代价要小很多。好在我们团队还没有负面影响这么大的同事。&lt;/p&gt;
&lt;p&gt;　　我本身是倾向给人机会的。特别是情商和智商不匹配的人，是有潜力的。如果情商高，但是自信心不足，导致能力低，那么是没有风险的，他会一点点越来越好。智商高，情商低主要有两种可能。一种悟性特别好，及时纠正自己情商上的问题，以后发展的非常好。华盛顿总统之前也是欺负过黑奴的，也有个黑人儿子；零丁洋里叹零丁的文天祥当初也是一霸；曹雪芹家道中落之前也是个纨绔子弟。还有一种，最后也没完全接受自己的问题，影响的不仅是事业，还有生活，未来。所以为了大家的将来，对于这些能力不对称型的孩子，反而要投入更多个关注。&lt;/p&gt;
&lt;p&gt;　　但是这是一步险棋。对我自己有更高的要求。首先我需要所说的话都想好，最不应该的是当着大BOSS的面聊准备不好的天。被大BOSS听见手下对我说“不明白我的意思”，大BOSS只会觉得我能力不足。而人家不明白我的意思是怎么回事呢。首先我初来乍到，不了解这边很多相关的术语，就是说我们本来就操着不同的语言。然后上次我说大家都说用消息队列，你试试看是不是用异步会更好一些呢。其实我的意思是有现成的异步框架，这种异步框架不是中央集群控制的，减少了对外部的依赖，减小了风险。但是我没说清。&lt;/p&gt;
&lt;p&gt;　　而且现在的孩子容易觉得自己很牛逼。用这个工具那个工具什么事情都很容易搞定。我用过吗？我没用过。我那时候都是自己用socket编程来自己写zookeeper框架的。我只是知道这是一个外部依赖，依赖坏掉，自己心跳不到了，会不会自动熔断，还是会把系统拖死。其实对一个外部框架了解多少没有那么重要。它对系统的影响是可以判定的。&lt;/p&gt;
&lt;p&gt;　　初来乍到来说，作为女孩子来说，锋芒毕露是不太明智的。太厉害的女孩子没人帮，要不就很让人佩服，要不就死的很惨。多暴露一点缺点没关系，一步一步越来越好。&lt;/p&gt;

&lt;p&gt;　　还有就是要成为金融领域专家。现在项目都讲究理解领域、拆分领域、细化领域。核心模块要确保轻薄、稳定。越纯粹越好，边界要清晰。当然除了领域，容量规划、架构设计、数据库设计、缓存设计、框架选型、发布方案、数据迁移和同步方案、高并发方案、旁路方案、性能压测方案、监控报警方案都是要考虑的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　过得很滋润的日子都在和语言打交道。踏踏实实做技术，语言会成为我周期性反复发作的病。未来做什么，我现在不是很确定。我现在只是处于第二阶段的开始。路还很长、不贪心、不着急、不放弃，一步一步走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;现在我身边的朋友都说我比较能说。然而我最好的兄弟们都是那种有事儿吱一声，没事儿各忙各的。上次给我家微微一笑很倾城的男神老大微信聊天，感觉有些凄凉。我说现在公司里好了很多、一切都开始走上正轨了。然后我们就各忙各的了。只有有事需要帮忙的时候，才会话多。这实在要比需要的时候不在，只会在取得成绩的时候过来祝贺好太多。但是实在不想因为时间而生疏。&lt;/p&gt;
&lt;p&gt; 　　记得有次去参加一个技术大会。中午休息的时候，我在盯着鱼池看。我看到里面的鳖，花纹光鲜有秩。红色的金鱼和黑色的金鱼们。所有的金鱼都由一条金鱼引领着游来游去。还有阳光下闪耀的波纹……，然后过来一个男孩，面目清秀，面相是个很有趣的人。问我在看什么。我就告诉他你看这些鱼，其实是群起而动的。他就问：那哪个是群主呢？我只是笑笑，然后转身离开鱼池进了一家咖啡店。因为这是周末了，来参加技术会议已经很苦逼了，我干嘛还要费力气和别人说话交朋友。&lt;/p&gt;
&lt;p&gt;　　我有闺蜜、我有很多朋友，看电影啦想干什么都不愁没人陪。然后突然有一天会发现全世界的人站在我面前，我也只想和一个人说话，后来那个小人就住在我心里，每天和他说话。有一天我告诉那个小人说我放你走，你去看外面的世界吧。然后我的整个世界都清净了。我只想每天练练瑜伽，画个画，做自己想做的事情。这才符合我的本心，从小的梦想在外面无所不能，做个神偷怪盗。到家里却能安静的看看书，直到在书桌前睡着了，然后爱人下班回家给我带回一杯热奶茶，看到我睡着了，便给我披上大衣。现在确实也是，上班风风火火，下班安安静静。此生别无所求。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 04:13:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/7998777.html</dc:identifier>
</item>
<item>
<title>Java并发编程之ThreadLocal源码分析 - 四度空间的平面</title>
<link>http://www.cnblogs.com/cfyrwang/p/8166369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cfyrwang/p/8166369.html</guid>
<description>&lt;h2 id=&quot;一句话概括threadlocal&quot;&gt;1 一句话概括ThreadLocal&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  什么是ThreadLocal？顾名思义：线程本地变量，它为每个使用该对象的线程创建了一个独立的变量副本。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocal使用场景&quot;&gt;2 ThreadLocal使用场景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  用一句话总结ThreadLocal真的实在是太苍白无力了！我们通过一个简单的例子入手。比如现在有A和B两台服务器需要通过http请求传递数据，但又希望数据安全性有一定保障，因此发送方A决定用AES算法对传输数据加密后再发送给B。接受方B收到数据后，通过密钥解密数据并进行后续的业务处理。&lt;br/&gt;  对数据进行AES解密，接收方B可选择JAVA提供的Cipher类来实现。我们在调用Cipher类进行解密时时，需要获取Cipher对象的实例，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  接着我们调用该实例就可以进行数据解密工作。但很不幸的是，Cipher类存在线程安全问题，它无法工作于多线程场景下。简单来说就是单个Cipher实例无法同时解密多条数据。&lt;br/&gt;  那怎么办呢？&lt;br/&gt;有没有什么办法能让每个线程拥有相同的instance实例，且彼此互不干扰呢？这个时候我们可以借助ThreadLocal类来实现特定功能，ThreadLocal能够为每个使用该对象的线程创建独立的变量的副本。这样就满足了我们的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  后续篇幅我们会深入到ThreadLocal的源码层来探讨它的实现机制，在看ThreadLocal类的几个基本方法前，让我们先看一下ThreadLocal中静态类ThreadLocalMap的实现，它对于我们理解ThreadLocal有着举足轻重的作用！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocalmap源码分析&quot;&gt;3 ThreadLocalMap源码分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  ThreadLocalMap是ThreadLocal类中的一个静态类，它拥有一个Entry数组类型的成员变量，名为table。这个Entry是啥？我们来看看。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Entry &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
&lt;span class=&quot;co&quot;&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;
Object value;

&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(k);
value = v;
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  Entry类是ThreadLocalMap中的一个静态类，它继承了WeakReference类，同时拥有一个类型为Object的value成员变量。当我们创建Entry对象后，调用Entry.get()方法，获取到的实际上是ThreadLocal对象的弱引用。而这个设计则保证了Entry对象中保存的ThreadLocal弱引用是易被回收的。网上有很多关于ThreadLocal对象是否会引发内存泄漏的文章，这里的内存泄漏通常指的不是entry的key，也就是ThreadLocal的弱引用。而是这里的value对象。实际上ThreadLocalMap自身提供了一套回收无用Entry节点的机制。在后面我们会聊到它的实现。关于ThreadLocal是否会引发内存泄漏，这里暂时不做探讨。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;threadlocalmap.set方法&quot;&gt;3.1 ThreadLocalMap.set()方法&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {
&lt;span class=&quot;co&quot;&gt;// We don't use a fast path as with get() because it is at&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// least as common to use set() to create new entries as&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// it is to replace existing ones, in which case, a fast&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// path would fail more often than not.&lt;/span&gt;

Entry[] tab = table;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = key.&lt;span class=&quot;fu&quot;&gt;threadLocalHashCode&lt;/span&gt; &amp;amp; (len&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;);

&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Entry e = tab[i];
e != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
e = tab[i = &lt;span class=&quot;fu&quot;&gt;nextIndex&lt;/span&gt;(i, len)]) {
ThreadLocal&amp;lt;?&amp;gt; k = e.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (k == key) {
e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (k == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
&lt;span class=&quot;fu&quot;&gt;replaceStaleEntry&lt;/span&gt;(key, value, i);
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}
}

tab[i] = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;(key, value);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sz = ++size;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;cleanSomeSlots&lt;/span&gt;(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
&lt;span class=&quot;fu&quot;&gt;rehash&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  ThreadLocalMap类持有一个Entry数组，名为table。当我们调用ThreadLocalMap的set()方法时，其实就是更新table中某个Entry，或往table中插入一个Entry。set()方法其实是根据threadLocal对象的threadLocalHashCode来计算当前Entry节点应落入什么位置。当然存在多个entry落入位置发生冲突的情况，在ThreadLocal中使用了线性探测法来解决冲突。知道了这一点，那set方法的实现思路就很清晰了。就是找一个位置让我放节点嘛！如果已经有现成的了，更新一下value就行。要是找不到，那我就按线性探测法来找落入位置就好了嘛。值得注意的是replaceStaleEntry()方法！当entry节点不为空，而key为null时会调用这个方法。这个方法看名字好像是用来替换过时的Entry节点的？我们来看一下它到底是干嘛的？&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void replaceStaleEntry(ThreadLocal&amp;lt;?&amp;gt; key, Object value, int staleSlot) {
Entry[] tab = table;
int len = tab.length;
Entry e;

// Back up to check for prior stale entry in current run.
// We clean out whole runs at a time to avoid continual
// incremental rehashing due to garbage collector freeing
// up refs in bunches (i.e., whenever the collector runs).
int slotToExpunge = staleSlot;
for (int i = prevIndex(staleSlot, len);
(e = tab[i]) != null;
i = prevIndex(i, len))
if (e.get() == null)
slotToExpunge = i;

// Find either the key or trailing null slot of run, whichever
// occurs first
for (int i = nextIndex(staleSlot, len);
(e = tab[i]) != null;
i = nextIndex(i, len)) {
ThreadLocal&amp;lt;?&amp;gt; k = e.get();

// If we find key, then we need to swap it
// with the stale entry to maintain hash table order.
// The newly stale slot, or any other stale slot
// encountered above it, can then be sent to expungeStaleEntry
// to remove or rehash all of the other entries in run.
if (k == key) {
e.value = value;

tab[i] = tab[staleSlot];
tab[staleSlot] = e;

// Start expunge at preceding stale entry if it exists
if (slotToExpunge == staleSlot)
slotToExpunge = i;
cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
return;
}

// If we didn't find stale entry on backward scan, the
// first stale entry seen while scanning for key is the
// first still present in the run.
if (k == null &amp;amp;&amp;amp; slotToExpunge == staleSlot)
slotToExpunge = i;
}

// If key not found, put new entry in stale slot
tab[staleSlot].value = null;
tab[staleSlot] = new Entry(key, value);

// If there are any other stale entries in run, expunge them
if (slotToExpunge != staleSlot)
cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  这个方法好像还挺长的，上面我们已经猜测过它的用途了，现在我们就来揭开它的庐山真面目。&lt;br/&gt;  首先关注一个这个方法的参数：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;private void replaceStaleEntry(ThreadLocal&amp;lt;?&amp;gt; key, Object value, int staleSlot)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  第一个参数就是我们的key，估摸着还是用来计算hash值找位置的；第二个就是要放的value了；第三个staleSlot呢？我们上面好像是找到了一个key为null的entry节点吧？没错，这个staleSlot就是这个节点在tab中的位置了。然后从这个staleSlot节点开始往前找，如果发现某个entry不为空，但key等于null，用slotToExpunge记录下它的位置，直到往前找到一个entry为null的节点停止。这个slotToExpunge是用来干嘛的呢？后面会提到。&lt;br/&gt;  我们接着看。往前找完之后，我们又从staleSlot的下一个节点开始往后找，如果发现了某个节点的键值等于我们的key。我们是不是应该用我们的value替换掉这个位置原先的值呢？好像是应该替换。但是别忘记了前面还有个key为null的entry节点呢！由于之前key为null的节点和当前节点计算出来hash值其实是一样的。这里我们将e节点的值更新为最新的value后，互换tab[i]和entry的位置。这一步的目的是什么呢？&lt;span&gt;我猜大概是这样的，因为ThreadLocalMap是根据线性探测法来解决冲突的，因此可能会出现key的哈希值相同但散落位置不连续的情况。为了在一定程度上提高查找哈希值相同entry节点的效率，交换一下位置会是更好的选择。&lt;/span&gt;同时接下来会执行cleanSomeSlots()方法。我们上面的for循环会一直往后找，直到发现一个null节点为止。如果找到了null节点，那就说明按照线性探测法找不到这个节点了啊！那咋办呢？staleSlot节点不是空着呢么。直接塞进去不就完事了。。&lt;br/&gt;  最后一句又调用了cleanSomeSlots()方法。下面就轮到它了。。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;expungeStaleEntry&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; staleSlot) {
Entry[] tab = table;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;// expunge entry at staleSlot&lt;/span&gt;
tab[staleSlot].&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
tab[staleSlot] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
size--;

&lt;span class=&quot;co&quot;&gt;// Rehash until we encounter null&lt;/span&gt;
Entry e;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;fu&quot;&gt;nextIndex&lt;/span&gt;(staleSlot, len);
(e = tab[i]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
i = &lt;span class=&quot;fu&quot;&gt;nextIndex&lt;/span&gt;(i, len)) {
ThreadLocal&amp;lt;?&amp;gt; k = e.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (k == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
tab[i] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
size--;
} &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h = k.&lt;span class=&quot;fu&quot;&gt;threadLocalHashCode&lt;/span&gt; &amp;amp; (len - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h != i) {
tab[i] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;// Unlike Knuth 6.4 Algorithm R, we must scan until&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// null because multiple entries could have been stale.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (tab[h] != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
h = &lt;span class=&quot;fu&quot;&gt;nextIndex&lt;/span&gt;(h, len);
tab[h] = e;
}
}
}
&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  在看cleanSomeSlots()方法前，还得看expungeStaleEntry()。有时候不得不说，好的java命名规范，真的是很重要啊！看到这个方法的名字就知道它大概是用来清理过期节点的。回想一下，有什么节点是需要我们的清理的吗？好像有。。前面是不是有找到过key为null的entry节点啊？这个key为null的节点好像没啥用啊！&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  还记得这个slotToExpunge吗？不记得了的话往前翻一翻。这个slotToExpunge位置指向了一个key为null的entry节点。既然知道这个节点是没用的，那它就应该被回收。这里就很直接粗暴了，直接把它直接null以待后面垃圾回收器清理。清理完之后，又是一个for循环。如果key为null，将该entry置为null。如果不为null，重新计算一下hash值，如果位置与当前位置不同，需要重新找一个位置放该节点。当然也是利用线性探测法了，找到连续位置后面第一个为null的节点放置。&lt;br/&gt;  最后返回的节点为从slotToExpunge往后的第一个值为null的entry节点。&lt;br/&gt;  再看看cleanSomeSlots方法主体。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;private boolean cleanSomeSlots(int i, int n) {
boolean removed = false;
Entry[] tab = table;
int len = tab.length;
do {
i = nextIndex(i, len);
Entry e = tab[i];
if (e != null &amp;amp;&amp;amp; e.get() == null) {
n = len;
removed = true;
i = expungeStaleEntry(i);
}
} while ( (n &amp;gt;&amp;gt;&amp;gt;= 1) != 0);
return removed;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  这个方法顾名思义是用来清理某些节点的。清理啥节点呢？还是那些不为null但是key为null的节点。参数n决定了for循环要执行的次数。&amp;gt;&amp;gt;&amp;gt;在java中是无符号位移的意思，也就是说如果每次循环tab[i]均不需要清理，最多会执行logn次。如果有需要清理的节点，就会调用expungeStaleEntry()方法去回收这个节点。&lt;br/&gt;  上面说了这么一大堆，终于把ThreadLocalMap的set()方法说完了。下面接着来看getEntry()方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;threadlocalmap.getentry方法&quot;&gt;&lt;span&gt;3.2 ThreadLocalMap.getEntry()方法&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;private Entry getEntry(ThreadLocal&amp;lt;?&amp;gt; key) {
int i = key.threadLocalHashCode &amp;amp; (table.length - 1);
Entry e = table[i];
if (e != null &amp;amp;&amp;amp; e.get() == key)
return e;
else
return getEntryAfterMiss(key, i, e);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  getEntry()方法比较简单。先根据key值计算出对应在table中的位置，如果table[i]的key值和我们的参数key相同，直接返回table[i];反之，调用getEntryAfterMiss()方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;private Entry getEntryAfterMiss(ThreadLocal&amp;lt;?&amp;gt; key, int i, Entry e) {
Entry[] tab = table;
int len = tab.length;

while (e != null) {
ThreadLocal&amp;lt;?&amp;gt; k = e.get();
if (k == key)
return e;
if (k == null)
expungeStaleEntry(i);
else
i = nextIndex(i, len);
e = tab[i];
}
return null;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  进入到这个方法的情况可能如下三种：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;entry节点为null&lt;br/&gt;如果entry节点为null，直接返回null。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entry节点不为null，但是key为null&lt;br/&gt;执行expungeStaleEntry()方法回收该节点，回收完之后，tab[i]节点也就变成了null，直接返回null。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entry节点不为null，entry节点的key和参数key不同&lt;br/&gt;从i节点开始往后找，如果有key值相同的节点，也就是我们找到了我们需要的节点，返回entry即可。如果找不到，从i节点往后找，遇到key为null的回收一下该节点后返回null，遇到entry为null的直接返回null;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;  getEntry()方法会被ThreadLocal的get()方法调用，我们会在稍后的ThreadLocal源码的讲解中再谈。&lt;br/&gt;  介绍ThreadLocalMap用了不少的篇幅啊！下面就来看看我们ThreadLocal啦！关于ThreadLocal的方法网上已经有太多太多的文章介绍了。不过这里我们还是简单的结合我们上面所说的ThreadLocalMap来总结一下！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocal源码分析&quot;&gt;&lt;span&gt;4 ThreadLocal源码分析&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;threadlocal.set方法&quot;&gt;&lt;span&gt;4.1 ThreadLocal.Set()方法&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;public void set(T value) {
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
map.set(this, value);
else
createMap(t, value);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  当我们调用ThreadLocal对象的set方法时，程序会获取当前线程，并将其作为作为参数传递给getMap()方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;Thread.java
ThreadLocal.ThreadLocalMap threadLocals = null;

ThreadLocal.java
ThreadLocal.ThreadLocalMap threadLocals = null;

ThreadLocalMap getMap(Thread t) {
return t.threadLocals;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  查看Thread类源码可以发现，Thread类中包含了一个ThreadLocalMap对象，这个家伙我们上面已经花了很大的篇幅来说了，简单的说它的key为ThreadLocal的弱引用，而value为待保存的对象。至于为什么是弱引用，大家自己去google下。&lt;br/&gt;  继续说getMap()方法。getMap()方法很简单：返回当前线程中的ThreadLocalMap对象。&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;&lt;span&gt;获取到ThreadLocalMap对象后，如果它不为空。则往该对象里面塞入一个键值对，key为ThreadLocal对象的弱引用，vaule为需要保存的对象。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;如果ThreadLocalMap对象为null，则调用createMap()方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;void createMap(Thread t, T firstValue) {
t.threadLocals = new ThreadLocalMap(this, firstValue);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  createMap()方法在这里不细说。它会初始化当前线程的ThreadLocalMap对象，并将当前需要保存的对象放入ThreadLocalMap中，key值为当前线程的弱引用对象。&lt;br/&gt;  小结一下：ThreadLocal的set方法会获取当前线程的ThreadLocalMap对象，如果TreadLocalMap对象不为空，则将当前线程的弱引用作用key，待保存对象作为value保存起来；若ThreadLocalMap对象为null，则会先初始化，再放入键值对。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;threadlocal.get方法&quot;&gt;&lt;span&gt;4.2 ThreadLocal.Get()方法&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;public T get() {
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null) {
ThreadLocalMap.Entry e = map.getEntry(this);
if (e != null)
return (T)e.value;
}
return setInitialValue();
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  知道了怎么放，接下来聊一聊怎么取。眼尖的朋友们肯定已经发现了，这里又出现了ThreadLocalMap对象。那是自然，因为我们上面不就是往ThreadLocalMap里面放的吗！还记得ThreadLocalMap里面存了啥不？不记得的往上翻一翻。&lt;br/&gt;  如果ThreadLocalMap对象不为空，当前线程作为key值，从ThreadLocalMap中取出来了一个ThreadLocalMap.Entry对象。这个getEntry()方法我们在上面已经已经介绍过了，可能再返回去看看。当然了，肯定有人要问！我们刚才放的时候放的明明不是ThreadLocalMap.Entry对象！这咋回事呢？&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;ThreadLocalMap.java
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
/** The value associated with this ThreadLocal. */
Object value;

Entry(ThreadLocal k, Object v) {
super(k);
value = v;
}
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  实际上，在ThreadLocalMap中有一个静态类，它名叫Entry，继承了WeakReference类。再看看Entry的构造方法。如果调用Entry的get方法，实际上拿到的是ThreadLocal对象的弱引用对象。是不是很熟悉？上面的set方法有聊到过。&lt;br/&gt;  继续说上面的get()方法。当我们拿到了Entry对象后，如果Entry对象不为空，直接返回Entry对象的value值，即我们想要的值。&lt;br/&gt;那么如果ThreadLocalMap为空呢？则会执行setInitialValue()方法。光看名字，你肯定觉得它无非执行了两步操作：1.初始化对象；2. 将初始化后的对象塞入ThreadLocalMap对象中；3. 返回初始化后的对象。那我们来看看我们的猜想对不对呢？&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;private T setInitialValue() {
T value = initialValue();
Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
map.set(this, value);
else
createMap(t, value);
return value;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  除了第一句代码，后面的是不是好像都在哪里见过啊？可不是！不就是上面的set()方法吗？这个方法我们只需要关注initialValue()方法...而这个initialValue()方法是需要我们自己重写的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  小结一下：如果ThreadLocalMap中有ThreadLocal对应的值，取Entry对象的value值；如果ThreadLocalMap为null，三步走！初始化，将初始化后的对象放入ThreadLocalMap中，返回初始化后的对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocal总结&quot;&gt;5 ThreadLocal总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  很感谢您能耐心的看到这里，我们最后再总结一下ThreadLoacl的实现机制。&lt;br/&gt;  在Thread类中存在一个ThreaLocalMap变量，ThreadLocalMap中又有一个Entry类型的数组，而这个Entry对象则以ThreadLocal的弱引用为key。当我们调用ThreadLocal的get()方法时，会先获取当前线程的ThreadLocalMap对象，并将当前ThreadLocal对象作为key（实际上key为ThreadLocal的弱引用），去它的Entry数组中寻找我们需要的value。就这是我们说ThreadLocal为每个线程创建了一个变量副本的意思，线程对自己ThreadLocalMap中的值进行操作时，并不会对其它线程造成影响。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 03:28:00 +0000</pubDate>
<dc:creator>四度空间的平面</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cfyrwang/p/8166369.html</dc:identifier>
</item>
<item>
<title>async和enterproxy控制并发数量 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/8166302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/8166302.html</guid>
<description>&lt;p&gt;并发我们经常提及之，不管是web server，app并发无处不在，操作系统中，指一个时间段中几个程序处于已经启动运行到完毕之间，且这几个程序都是在同一处理机上运行，并且任一个时间点只有一个程序在处理机上运行。很多网站都有并发连接数量的限制，所以当请求发送太快的时候会导致返回值为空或报错。更有甚者，有些网站可能因为你发出的并发连接数量过多而当你是在恶意请求，封掉你的ip。&lt;/p&gt;
&lt;p&gt;相对于并发，并行可能陌生了不少，并行指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生），通过增加cpu核心来实现多个程序(任务)的同时进行。没错，并行做到了多任务的同时进行&lt;/p&gt;

&lt;p&gt;enterproxy是朴灵大大为主要贡献的工具，带来一种事件式编程的思维变化，利用事件机制解耦复杂业务逻辑，解决了回调函数耦合性的诟病，将串行等待变成并行等待，提升多异步协作场景下的执行效率&lt;/p&gt;
&lt;p&gt;我们如何使用enterproxy控制并发数量？通常如果我们不使用enterproxy和自制的计数器，我们如果抓取三个源：&lt;/p&gt;
&lt;p&gt;这种深层嵌套，串行的方式&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; render &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (template&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;template&lt;/span&gt;(template&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;template&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (template) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// something&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// something&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;l10n&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (l10n) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// something&lt;/span&gt;
      &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;(template&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; l10n)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除去这种过去深层嵌套的方法，我们常规的写法的自己维护一个计数器&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; count &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; result  &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;
    
    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'template'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data1&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        count&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;handle&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        count&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;handle&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'l10n'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data3&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        count&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;handle&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;handle&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(count &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; html &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fuck&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data3&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;(html)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，enterproxy就可以起到这个计数器的作用，它帮你管理这些异步操作是否完成，完成之后，他会自动调用你提供的处理函数，并将抓取到数据当做参数传递过来&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ep &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;enterproxy&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;all&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data_event1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'data_event2'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'data_event3'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data2&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data3)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; html &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fuck&lt;/span&gt;(data1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data2&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data3)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;(html)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http:example1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data_event1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http:example2'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data_event2'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http:example3'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data_event3'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enterproxy还提供了其他不少场景所需的API，可以自行学习下这个API &lt;a href=&quot;https://github.com/JacksonTian/eventproxy&quot;&gt;enterproxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;假如我们有40个请求需要发出，很多网站可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的IP封掉。&lt;br/&gt;所以我们总是需要控制并发数量，然后慢慢抓取完这40个链接。&lt;/p&gt;
&lt;p&gt;使用async中mapLimit控制一次性并发数量为5，一次性只抓取5个链接。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;va&quot;&gt;async&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mapLimit&lt;/span&gt;(arr&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// something&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (error&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; result) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;result: &quot;&lt;/span&gt;)
      &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(result)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们首先应该知道什么是&lt;code&gt;并发&lt;/code&gt;，为什么需要限制并发数量，都有哪些处理方案。然后就可以去文档具体看一下API如何使用。&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async文档&lt;/a&gt;可以很好的学习这些语法。&lt;/p&gt;
&lt;p&gt;模拟一组数据，这里返回的数据是假的，返回的延时是随机的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; concurreyCount &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fetchUrl &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;callback)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// delay 的值在 2000 以内，是个随机的整数 模拟延时&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; delay &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;at&quot;&gt;parseInt&lt;/span&gt;((&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;random&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10000000&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    concurreyCount&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'现在并发数是 '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; concurreyCount &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' 正在抓取的是'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' 耗时'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; delay &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'毫秒'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        concurreyCount&lt;span class=&quot;op&quot;&gt;--;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;url &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' html content'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;delay)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; urls &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;urls&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http://datasource_'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; i)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们使用&lt;code&gt;async.mapLimit&lt;/code&gt;来并发抓取，并获取结果。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;async&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mapLimit&lt;/span&gt;(urls&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;callback)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fetchUrl&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;callbcak)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;result)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'result: '&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(result)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模拟摘自&lt;a href=&quot;https://github.com/alsotang/node-lessons/tree/master/lesson5&quot;&gt;alsotang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行输出后得到以下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenqaq.com/assets/images/concurrency1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，并发数从1开始增长，但是增长到5时，就不在增加。然有任务时就继续抓取，并发连接数量始终控制在5个。&lt;/p&gt;

&lt;p&gt;因为alsotang前辈的&lt;a href=&quot;https://github.com/alsotang/node-lessons&quot;&gt;《node包教不包会》&lt;/a&gt;教程例子中使用的eventproxy控制的并发数量，我们就来完成一个使用async控制并发数量的node简易爬虫。&lt;/p&gt;
&lt;p&gt;爬取的目标就是&lt;a href=&quot;http://www.chenqaq.com&quot;&gt;本站首页&lt;/a&gt;（手动护脸）&lt;/p&gt;
&lt;p&gt;第一步，首先我们需要用到以下的模块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenqaq.com/assets/images/concurrency2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，通过require引入依赖模块，确定爬取对象URL：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; async &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;async&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; cheerio &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cheerio&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; superagent &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;superagent&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; baseUrl &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'http://www.chenqaq.com'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步：使用superagent请求目标URL，并使用cheerio处理baseUrl得到目标内容url，并保存在数组arr中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;superagent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(baseUrl)
  .&lt;span class=&quot;at&quot;&gt;end&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (err) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;error&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; $ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;cheerio&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;text&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 下面和jQuery操作是一样一样的..&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.post-list .post-title-link&quot;&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (idx&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; element) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      $element &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(element)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; _url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;url&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(baseUrl&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;$element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;attr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;href&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(_url)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 验证得到的所有文章链接集合&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;output&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 第四步：接下来遍历arr，解析每一个页面需要的信息&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要一个函数验证抓取的url对象，很简单我们只需要一个函数遍历arr并打印出来就可以：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;output&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr[i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四步：我们需要遍历得到的URL对象，解析每一个页面需要的信息。&lt;/p&gt;
&lt;p&gt;这里就需要用到&lt;code&gt;async&lt;/code&gt;控制并发数量，如果你上一步获取了一个庞大的arr数组，有多个url需要请求，如果同时发出多个请求，一些网站就可能会把你的行为当做恶意请求而封掉你的ip&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;async&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mapLimit&lt;/span&gt;(arr&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;callback)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;superagent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(url)
        .&lt;span class=&quot;at&quot;&gt;end&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;mes)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;error&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'message info '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stringify&lt;/span&gt;(mes))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'「fetch」'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' successful！'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; $ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;cheerio&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;mes&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;text&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; jsonData &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.post-card-title'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;text&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;trim&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;jsonData)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(error&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;results)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'results '&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(results)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到上一步保存url地址的数组arr，限制最大并发数量为3，然后用一个回调函数处理 「该回调函数比较特殊，在iteratee方法中一定要调用该回调函数，有三种方式」&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;callback(null)&lt;/code&gt; 调用成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback(null，data)&lt;/code&gt; 调用成功，并且返回数据data追加到results&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback(data)&lt;/code&gt; 调用失败，不会再继续循环，直接到最后的callback&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，到这里我们的node简易的小爬虫就完成了，来看看效果吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenqaq.com/assets/images/concurrency3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗨呀，首页数据好少，但是成功了呢。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alsotang/node-lessons&quot;&gt;Node.js 包教不包会 - alsotang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JacksonTian/eventproxy&quot;&gt;enterproxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/caolan/async&quot;&gt;async&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async Documentation&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 03:00:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/8166302.html</dc:identifier>
</item>
<item>
<title>BGP网络学习总结 - Anker's Blog</title>
<link>http://www.cnblogs.com/Anker/p/8166294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Anker/p/8166294.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　    &lt;span&gt;云计算在中国发展越来越快，企业逐步开始将业务迁移到公有云中，方便运维，节省成本。公有云最复杂的地方是网络，客户对网络的需求千奇百怪，造成网络环境极其复杂，稍有不慎，就会出现网络连通性问题。因此大部分云计算厂商机房网络类型的运营商接入均为 BGP 多线路，保证线路质量。公有云中网络安全也是非常重要，例如DDos攻击，域名未备案封堵系统。我在工作中接触到了BGP高仿和域名未备案封堵系统，今天总结一下自己对BGP网络的理解，涉及的内容有什么是BGP，BGP用来解决什么问题，云计算厂商中BGP机房有啥优势，BGP高防如何做到引流和回注，域名未备案系统是怎么实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、BGP网络介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;目前中国境内主要分为网通、电信、移动、联通、教育网、科技网、卫通等网络，由于这些公司独立运作，造成国内长久以来整个互联网处于无法快速互联互通的局面，如何将各个AS自制系统连通起来，就需要搭建BGP网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在介绍BGP协议之前，先介绍几个概念：&lt;/p&gt;
&lt;p&gt;　　（1） AS（Autonomous system）：自治系统，指在一个（有时是多个）组织管辖下的所有IP网络和路由器的全体，它们对互联网执行共同的路由策略。也就是说，对于互联网来说，一个AS是一个独立的整体网络。而BGP实现的网络自治也是指各个AS自治。每个AS有自己唯一的编号。&lt;/p&gt;
&lt;p&gt;　　（2）IGP（Interior Gateway Protocol）：内部网关协议，在一个AS内部所使用的一种路由协议。一个AS内部也可以有多个路由器管理多个网络。各个路由器之间需要路由信息以知道子网络的可达信息。IGP就是用来管理这些路由。代表的实现有RIP和OSPF。&lt;/p&gt;
&lt;p&gt;       （3）EGP（Exterior Gateway Protocol）：外部网关协议，在多个AS之间使用的一种路由协议，现在已经淘汰，被BGP取而代之。&lt;/p&gt;
&lt;p&gt;       BGP(Border Gateway Protocol)主要用于互联网AS(自治系统)之间的互联，BGP的最主要功能在于控制路由的传播和选择最佳路径。全国各大网络运营商多数都是通过BGP协议与自身的AS号来实现多线互联的。使用BGP协议互联后，网络运营商的所有骨干路由设备将会判断到IDC机房IP段的最佳路由，以保证不同网络运营商用户的高速访问。&lt;/p&gt;
&lt;p&gt;　　动态BGP多线网络，路由表项是通过相互连接的路由器之间交换彼此路由信息，然后按照一定的算法优化出来的，而这些路由信息是在一定时间间隙里不断更新，以适应不断变化的网络，以随时获得最优的寻路效果。为了实现IP分组的高效寻路，IETF制定了多种寻路协议。也就是说，当静态BGP中的网络结构发生变化，运营商是无法在第一时间自动调整网络设置以保障用户的体验度。而动态BGP可根据设定的寻路协议第一时间自动优化网络结构，以保持客户使用的网络持续稳定、高效。所以，动态BGP网络被称为真正意义上的BGP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/305504/201801/305504-20180101104709799-14007529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知乎上有一个非常=通俗易懂的例子讲解为什么需要BGP网络，&lt;a title=&quot;BGP网络&quot; href=&quot;https://zhuanlan.zhihu.com/p/25433049&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/25433049&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、BGP流量引流和回注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;云计算厂商需要保证客户网络的正常，通常会为单个公网IP提供数G的防护能力，当超过默认的阈值，公网IP备迁移到黑洞中，进行封堵。这样导致用户的服务不可访问了，客户为了正常访问服务，就需要接入BGP高防，防护能力高达数百G，来保护服务正常。高防的费用是非常高的，通常云厂商自己搭建高防系统，通过BGP协议将流量引流到高防清洗系统，将异常流量清洗掉，将正常流量回注给客户。参考华为的DDos防护系统&lt;/span&gt;：&lt;a title=&quot;华为DDos&quot; href=&quot;http://forum.huawei.com/enterprise/thread-388785-1-1.html&quot; target=&quot;_blank&quot;&gt;http://forum.huawei.com/enterprise/thread-388785-1-1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/305504/201801/305504-20180101111501362-438719399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、搭建BGP引流和回注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用Linux下开源的Quagga开源搭建基于BGP协议的路由器，Quagga守护进程负责BGP的服务叫bgpd。关于如何使用Quagga搭建一个BGP路由器，可以参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://linux.cn/article-4609-1.html&quot; target=&quot;_blank&quot;&gt;https://linux.cn/article-4609-1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/305504/201801/305504-20180101112514346-625988389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路由器A和路由器B使用100.100.0.0/30子网来连接到对方。&lt;/p&gt;
&lt;p&gt;　　技术实现目前可以使用Intel开源的DPDK网络开发包快速开发，使用KNI新建一个虚拟网卡，配置好与上层交互机建立BGP，然后通过虚拟网络将流量引入，分析流量过后，使用回注口将报文使用二层MAC送回到交换机。关于DPDK的介绍可以参考：&lt;a href=&quot;https://www.jianshu.com/p/0ff8cb4deaef&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/0ff8cb4deaef&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jan 2018 02:56:00 +0000</pubDate>
<dc:creator>Anker&amp;#39;s Blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Anker/p/8166294.html</dc:identifier>
</item>
<item>
<title>【算法】论平衡二叉树（AVL）的正确种植方法 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/8166133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/8166133.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《算法（java）》                           — — Robert Sedgewick， Kevin Wayne&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《数据结构》                                  — — 严蔚敏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;近日， 为了响应市政府“全市绿化”的号召&lt;/strong&gt;， 身为共青团员的我决定&lt;strong&gt;在家里的后院挖坑种二叉树&lt;/strong&gt;，以支援政府实现节能减排的伟大目标，并进一步为实现共同富裕和民族复兴打下坚实的基础....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咳咳， 不好意思，扯远了。 额， 就是我上次不是种二叉查找树嘛（见上面的链接），&lt;strong&gt;发现大多数二叉树都长的比较好，但总有那么那么几颗长势很不如人意，我对此感到很疑惑&lt;/strong&gt;（大家思考一下这是为什么）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直到——  看门的李大爷给我送过来了一包树种，神秘兮兮地跟我说&lt;strong&gt;这是能自动吸收氮磷钾，犹如金坷垃般神奇的树种， 它叫    ——   “平衡二叉树”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;正文开始&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;平衡二叉树的由来&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;普通二叉搜索树的缺陷&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;普通二叉搜索树的动态方法可能是“有缺陷”的， 或者说： 可能会带来不良的副作用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通二叉搜索树的API分为两种： &lt;span&gt;&lt;strong&gt;静态方法&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;&lt;span&gt;动态方法&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态方法不会对二叉树做修改，而仅仅是获取相关的信息，例如：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;get(根据key获取val)
max(获取最大key),
min(获取最小key)
floor（对key向下取整）
ceiling(对key向上取整)
rank（获取给定key的排名）
select（根据排名获得给定key）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;而动态方法则会修改树中结点， 并进一步影响二叉树的结构&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;put (插入键值对)
delete(删除键值对)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;BST的动态方法可能会修改二叉树的结构， 使其结点分布不均匀，使得在下一步的操作中， 静态方法和动态方法都变得更为低效。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;插入的顺序影响二叉搜索树的构造&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的数据集合， 插入二叉搜素树中的顺序的不同，树的形状和结构也是不同的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以put方法为例，我们重复调用它， 用key为1, 2, 3, 4的结点构造一颗二叉搜索树。那么这颗二叉搜索树的形状取决于不同的key的插入顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能在你眼里，构造的树可能是比较“均匀”的。但让我们看看， &lt;strong&gt;&lt;span&gt;如果按照完全正序或者逆序输入， 二叉搜索树的形状就会走向一个不好的极端：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果按照 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 的顺序插入， 那么这颗二叉树在形状上会变得像一颗单链表！&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093327440-391795266.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/ae24a56a603442f8acbd4cdfab5ea755/5go%257Bxxey%25602%2560h7%2528ppvkucki7.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;3D08E9F7FADF4539BA65ED9B9682C9E1&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样，如果按照4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt;1 的顺序插入， 它在形状上会变成一颗向左倾斜的链表&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093401534-1808842232.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/9fbb8152a1074e288ca390ca9bc5287a/_%257Bvq%257B4kcha9a3y3n%25244ja9k8.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;47E3AC79A17F49039C0376C68BAD95AA&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;为什么二叉搜索树会变得低效？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;二叉搜索树查找的原理和二分查找类似，就是&lt;strong&gt;&lt;span&gt;借助于它本身的结构，在遍历查找的过程中跳过一些不必要的结点的比较，从而实现高效的查找。&lt;/span&gt;&lt;/strong&gt; BST的其他API也是借助了这一优势实现性能的飞跃。&lt;strong&gt;&lt;span&gt;但是，在这种情况下&lt;/span&gt;&lt;/strong&gt;， 查找一个结点将要像链表一样遍历它经过的所有结点， &lt;strong&gt;&lt;span&gt;二叉搜索树的高效之源已经丧失了&lt;/span&gt;&lt;/strong&gt;。 这就是最坏的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;插入和删除操作都可能降低未来操作的性能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面我只讲述了插入操作对二叉树形状和操作性能的影响， 但让我们反向思考一下就会发现，删除操作的效果也有类似之处： 可能使得原来分布得比较均匀的结点， 在删除部分结点之后，整体的分布变得不均匀了，并影响到未来操作的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我先先入为主地灌输一个关于“平衡”的概念： “二叉搜索树各结点分布均匀、各种操作都较为高效的状态”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;什么是平衡二叉树&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;综上所述，我们希望&lt;strong&gt;&lt;span&gt;在进行动态操作（插入和删除）之后，能够通过一些指标，对二叉树的形状变化进行监督， 当发现树的形状开始变得不平衡的时候， 立即修正二叉树的形状。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过这种方式， &lt;strong&gt;&lt;span&gt;不断地使得二叉树的形状和构造维持着一个“平衡”的状态， 添加了这种维护机制的二叉搜索树， 就是平衡二叉树&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上个图，对比一下普通的二叉搜索树和平衡二叉树的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;普通的二叉搜索树（BST）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093424924-1528289744.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/d34ccffe9c40476a971bafa3f6d45f74/xc%255Bf2_0h9y5%252504s_%25297%257Ebksg.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;D660B92D2FBD4D1CBE46F407AED2BD3F&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;平衡二叉树（AVL）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093432081-566287437.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/4cf7042225b14192958bb09392559d25/jpa0f%255Bhwxo%257B%2524fn9nmqbj78g.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;D9FA14F5E0D04BA4A2DFFBFA597DFCA5&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这还不够？ 再来个动图看一看！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（图中key的大小关系：按字母排序，A最小，Z最大）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093456596-607740582.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/be7d62ea9cc3413e8deacced763001df/avl_tree_example.gif&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;670599558D144DFFB0C0F6650C59D6BC&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里我们可以很明显地看到&lt;strong&gt;&lt;span&gt;平衡二叉树的优势&lt;/span&gt;&lt;/strong&gt;所在： &lt;strong&gt;&lt;span&gt;使得查找的平均深度降低， 优化各个API的性能开销&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;AVL和普通BST区别在于动态方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平衡二叉树和普通二叉查找树区别主要在于动态方法&lt;/span&gt;&lt;/strong&gt;！(put,delete) 。它们的静态方法基本是相同的！ （get,min,max,floor,ceiling, rank,select）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以本文编写的主要API就只有两个: put和delete&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;平衡二叉树的监督机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们前面提到了平衡二叉树有它的监督机制&lt;strong&gt;&lt;span&gt;，既然说到“监督”， 那必然就有一个用于判断当前二叉树平不平衡的指标， 这个监督的指标， 就是平衡因子&lt;/span&gt;&lt;/strong&gt;（Balance Factor）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在二叉树中， 我们为每个结点定义了平衡因子这个属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;平衡因子：&lt;/strong&gt; 某个结点的&lt;strong&gt;&lt;span&gt;左子树的高度减去右子树的高度&lt;/span&gt;&lt;/strong&gt;得到的差值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;（AVL）： 所有结点的平衡因子的绝对值都不超过1。即对平衡二叉树每个结点来说，其左子树的高度 - 右子树高度得到的差值&lt;span&gt;&lt;strong&gt;只能为 1， 0 ， -1 这三个值&lt;/strong&gt;&lt;/span&gt;。 取得小于 -1或者大于1的值，都被视为打破了二叉树的平衡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;图解平衡因子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对根结点A而言， 它左子树高度为2， 右子树高度为1， 那么它的平衡因子BF = 2 - 1 = 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对结点B而言， 它左子树高度为1， 没有右子树（高度视为0），BF = 1 - 0 = 1；&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093549565-1780536291.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/67f8d2693e614d7693569eedb52d7f22/4q5z@f1__iwp%25289co@blmg%257D6.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;09EA70CE3E064DBD90B7AFA0C96DFDF3&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图解平衡二叉树&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示， 图a的两颗是平衡二叉树， 图b的两颗则是非平衡二叉树&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093619940-780207194.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/32529bad610d471da786fdbef4de7b85/v6%25281zyqg%255Bd%255Bi%257Bl2un%257B3%255Dwfj.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;1F4F3E2AEBEC401C9F31D068BB67B9DD&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以， 只有所有结点都符合“平衡因子的绝对值都不超过1” 这一条件的二叉树， 才是平衡二叉树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有一个结点不符合条件， 那么这颗二叉树就不是平衡二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面我们说到， 在动态操作（插入/删除）的过程中，我们需要平衡因子作为“指标”， 去监督当前这颗二叉树的构造是否符合预期， 即——是否是一颗平衡二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而平衡因子BF的计算需要用到该节点的孩子结点的高度属性， 这也就意味着， 我们要从Node类的实例变量入手，为每个结点设置height属性， 并在二叉树结构发生变化时， 更新并维护height的正确性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;为每个结点设置并维护height属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;height属性的设置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;啊， 终于可以开始写代码了。 如下，我们在Node类中写入了实例变量height,并初始化为1&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 10:35 2017/12/29
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AVL {
  Node root; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根结点&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key,val;
    Node left,right;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height = 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个结点的高度属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编写API方法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;height属性的维护和更新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们思考一下， &lt;strong&gt;结点height属性在什么时候会发生变化：&lt;/strong&gt; 当然是在二叉树结构发生变化的时候， 具体表现为：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在插入结点时（put）， 沿插入的路径更新结点的高度值&lt;/span&gt;&lt;/strong&gt;（不一定会加1 ！只是要重新计算）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;在删除结点时（delete）,沿删除的路径更新结点的高度值&lt;/strong&gt;&lt;/span&gt;（不一定减1！ 只是要重新计算）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;在发现二叉树变得不平衡的时候， 通过“旋转”使其平衡， 这时候要更新相关结点的高度值&lt;/strong&gt;&lt;/span&gt;（具体的我下面会详细讲）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的代码是更新结点高度的示范例子：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  /**&lt;/span&gt;&lt;span&gt;
   * @description: 返回两个数中的最大值
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max (&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a&amp;gt;b ?&lt;span&gt; a : b;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 获得当前结点的高度
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x.height;
  }
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的insert方法是简化后的代码&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; Node insert (Node x, &lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    其他代码 。。。。
    insert(x.left, key, val); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行递归的插入&lt;/span&gt;
    &lt;span&gt;x.height = max(height(x.left),height(x.right)) + 1;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新结点的height属性（沿着递归路径）&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最关键的是&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  x.height = max(height(x.left),height(x.right)) + 1;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这一句代码， 因为在递归的插入或删除之后，沿着递归路径上方的结点的height都有可能会改变， &lt;strong&gt;&lt;span&gt;所以要通过依次调用这一段代码， 沿着递归路径自下而上地更新沿途结点的height属性值。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;计算BF以监督平衡二叉树的状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;只要我们能正确地维护每个结点的height， 我们就能对动态操作中受影响的结点，准确计算其平衡因子（BF）， 从而判断当前的平衡二叉树的状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算某个结点平衡因子的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 获得平衡因子
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getBalance (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; height(x.left) -&lt;span&gt; height(x.right);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;平衡二叉树的修正机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当我们计算出某个结点的平衡因子的绝对值超过1时， 我们就要对其进行修正， 即通过平衡化的处理，使得不平衡的二叉树重新变得平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;左旋和右旋&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;二叉树的平衡化有两大基础操作： 左旋和右旋&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 左旋，即是逆时针旋转；右旋， 即是顺时针旋转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 这种旋转在整个平衡化过程中可能进行一次或多次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.且是从失去平衡的最小子树根结点开始的(即离插入结点最近的、平衡因子超过1的祖先结点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;右旋操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右旋操作过程：使结点3位置“下沉”，而结点2位置“上浮”， 反转当前结点和它左儿子的父子关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093648159-375323042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/681c85b213dd4b77a9e599ce931c80ad/40nfof%255B%25299_yed7a5%257Dog%2528lbg.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;A12A7CFD9C954C97B243696D4A7BDEC2&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是， 让我们思考地再全面一些： 如果上图中的结点2有右儿子的话， 情况会变得怎样？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;这时候结点2将保持有3条链接， 如果在这种情况下旋转， 结点二需要抛弃一条链接。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的处理方式是： &lt;strong&gt;&lt;span&gt;抛弃结点2的右儿子， 将其和旋转后的结点3连接，成为结点3的左儿子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我将上面的这种假设的结点戏称为“拖油瓶”结点，&lt;/strong&gt;  如下图中的黄色结点&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093719878-1956547658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/88b417c1aedb4b8da95a643a1208a471/0h%2525t3%257D5%2524%257Ej%257Bm%255D%255B8sl0s%257Eq%2560q.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;F617AC207C63444292FD8AC8D4A1427B&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;紧接上图， 我们需要先断开4结点和3结点间的链接， 然后把它转接到旋转后的结点5上：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093743612-1300077526.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/c23f2d93a0c24ab9b7cbe30bc8f9fe87/0%2529c%255B%2525rl%2560fsj_r8ts1%257B%257B%2524al3.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;FD9FD3FF9C8F4ABBBBEDB7D477CDFF36&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然， 有的时候我们假设的这个“拖油瓶”结点（黄色结点）可能是空的，但是这并不影响我们的编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好嘞！ 让我们来编写右旋的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 右旋方法
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node rotateRight (Node x) {
    Node y &lt;/span&gt;= x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得x的左儿子&lt;/span&gt;
    x.left = y.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x左儿子的右儿子（&quot;拖油瓶&quot;结点）链接到旋转后的x的左链接中&lt;/span&gt;
    y.right = x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调转x和它左儿子的父子关系，使x成为它原左儿子的右子树&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点的height&lt;/span&gt;
    y.height = max(height(y.left),height(y.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点的height&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将y返回&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;左旋操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左旋操作的过程和右旋一样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如下面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 结点2位置“下沉”， 而结点4位置上浮，反转当前结点和它右儿子的父子关系（2和4）， 使2结点变成4结点的左儿子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 同时断裂结点3和结点4间的链接， 转接到结点2中（处理拖油瓶结点）&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093804799-1855123132.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/d40fb0a42ec84180be6338ea731cc75b/qs%257Et%252963sdtfdsmtz862yqso.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;A5D1026E17844174A71A7A4BD62C0E27&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左旋方法代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 左旋方法
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  Node rotateLeft (Node x) {
    Node y &lt;/span&gt;= x.right;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得x的右儿子&lt;/span&gt;
    x.right = y.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x右儿子的左儿子（&quot;拖油瓶&quot;结点）链接到旋转后的x的右链接中&lt;/span&gt;
    y.left = x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调转x和它右儿子的父子关系，使x成为它原右儿子的左子树&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点的height&lt;/span&gt;
    y.height = max(height(y.left),height(y.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点的height&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将y返回&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;平衡化操作的四种情况&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以左旋操作和右旋操作为基础， 构成了平衡化操作的四种情况&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;假设由于在二叉排序树上插入结点而失去平衡的最小子树的根结点为a (即a是离插入结点最近的、平衡因子超过1的祖先结点)&lt;/span&gt;&lt;/strong&gt;，&lt;/span&gt; 则失去平衡后的调整操作分为以下4种情况:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 单次右旋：&lt;/strong&gt; 由于在a的左子树的根结点的左子树上插入结点（LL），使a的平衡因子由1变成2， 导致以a为根的子树失去平衡， 则需进行一次的向右的顺时针旋转操作&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/129547764fcd4eb5b46cb6e76999f2ae/ha1ddh119jk54a8%255D%257Dm0j3qf.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;9A97D9537AD149A7A000B3897E0AF38D&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093828065-888803260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 单次左旋：&lt;/strong&gt; 由于在a的右子树根结点的右子树上插入结点（RR），a的平衡因子由-1变成-2，导致以a为根结点的子树失去平衡，则需要进行一次向左的逆时针旋转操作&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093846799-633100964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/12ac5555b2fd45a2b04f0bccacf76b3f/_wt0hn%257Bd1ft%2525%2524zfed7l%257D43v.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;B1AEFBDF707641E09DC73FAE9C24C602&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 两次旋转、先左旋后右旋：&lt;/strong&gt; 由于在a的左子树根结点的右子树上插入结点（LR）， 导致a的平衡因子由1变成2，导致以a为根结点的子树失去平衡，需要进行两次旋转， 先左旋后右旋&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/c422988295f543ed82c4672fbb7b150d/y1j3q%2529%2529i%255B%25282bwe%257B3%2529%2529sf0od.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;04E7D2C8661C4BA98A27B8A6385A43E9&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093854831-1405594002.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.两次旋转， 先右旋后左旋：&lt;/strong&gt; 由于在a的右子树根结点的左子树上插入结点（RL）， a的平衡因子由-1变成-2，导致以a为根结点的子树失去平衡， 则需要进行两次旋转，先右旋后左旋&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/47ec8b31c5124cc4a038dca6adbed9bf/0a7%255Bn3ti05_f7htkwd52q63.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;BB587E9237344249896A5C154FE24A9B&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093908409-600718594.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那么问题来了，怎么分别判断LL， RR，LR，RL这四种破环平衡的场景呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以&lt;strong&gt;&lt;span&gt;根据当前破坏平衡的结点的平衡因子， 以及其孩子结点的平衡因子来判断&lt;/span&gt;&lt;/strong&gt;，具体如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101093952424-30855754.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（BF表示平衡因子， 最下方的那个结点是新插入的结点）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/71bd28391b6d4c7899d6e94876c2cc4f/tiqz%257Blae%2528xay%255Dsagcnj0r%257Bq.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;7BA8D21831A44C42B27DDB8D25CC5F0F&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;编写平衡化代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有了以上的知识基础， 让我们来编写下我们的平衡化代码&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 获得平衡因子
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getBalance (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; height(x.left) -&lt;span&gt; height(x.right);
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 平衡化操作：  检测当前结点是否失衡，若失衡则进行平衡化
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node reBalance (Node x) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; balanceFactor =&lt;span&gt; getBalance(x);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;gt; 1&amp;amp;&amp;amp;getBalance(x.left)&amp;gt;0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LL型，进行单次右旋&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateRight(x);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;gt; 1&amp;amp;&amp;amp;getBalance(x.left)&amp;lt;=0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LR型 先左旋再右旋&lt;/span&gt;
      Node t =&lt;span&gt; rotateLeft(x);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateRight(t);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;lt; -1&amp;amp;&amp;amp;getBalance(x.right)&amp;lt;=0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RR型， 进行单次左旋&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateLeft(x);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;lt; -1&amp;amp;&amp;amp;getBalance(x.right)&amp;gt;0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RL型，先右旋再左旋&lt;/span&gt;
      Node t =&lt;span&gt; rotateRight(x);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateLeft(t);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;&lt;span&gt; AVL类的API编码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面我将展示平衡二叉树的put方法和delete方法的代码， 而这两个方法绝大部分的代码还是基于二叉查找树的put方法和delete方法的， 所以还不太了解BST的同学可以看一看我上篇文章对BSTput方法和delete方法的解析：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;插入方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在看代码前可以先看下对二叉查找树中put方法的解析&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平衡查找树的put方法&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 插入结点（键值对）
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node put (Node x, &lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Node(key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入键值对&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;     (key&amp;lt;x.key) x.left  = put(x.left, key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树递归插入&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key&amp;gt;x.key) x.right = put(x.right,key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向右子树递归插入&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; x.val = val; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key已存在， 替换val&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下至上更新结点height属性&lt;/span&gt;
    x = reBalance(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下往上, 检测当前结点是否失衡，若失衡则进行平衡化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;删除方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;删除方法比较复杂，在看代码前可以先看下对二叉查找树中put方法的解析&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平衡查找树的delete方法&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 返回最小键
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node min (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x.left == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左儿子为空，则当前结点键为最小值，返回&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; min(x.left);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左儿子不为空，则继续向左递归&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; min () {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(root).key;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 删除最小键的结点
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node deleteMin (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x.left==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前结点左儿子空，则将右儿子返回给上一层递归的x.left&lt;/span&gt;
    x.left = deleteMin(x.left);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树递归， 同时重置搜索路径上每个父结点指向左儿子的链接&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前结点不是min&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteMin () {
    root &lt;/span&gt;=&lt;span&gt; deleteMin(root);
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 删除给定key的键值对
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key,Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;      (key&amp;lt;x.key) x.left  = delete(key,x.left); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树查找键为key的结点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key&amp;gt;x.key) x.right = delete(key,x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向右子树查找键为key的结点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结点已经被找到，就是当前的x&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(x.left==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左子树为空，则将右子树赋给父节点的链接&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(x.right==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果右子树为空，则将左子树赋给父节点的链接&lt;/span&gt;
      Node inherit = min(x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得结点x的继承结点&lt;/span&gt;
      inherit.right = deleteMin(x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将继承结点从原来位置删除，并重置继承结点右链接&lt;/span&gt;
      inherit.left = x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置继承结点左链接&lt;/span&gt;
      x = inherit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x替换为继承结点&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    x.height &lt;/span&gt;= max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下至上更新结点height属性&lt;/span&gt;
    x = reBalance(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下往上, 检测当前结点是否失衡，若失衡则进行平衡化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    root &lt;/span&gt;=&lt;span&gt; delete(key, root);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;测试AVL和BST的动态操作对二叉树结构的影响&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面我们用层序遍历的方式进行测试：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 二叉树层序遍历
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelIterator () {
    LinkedList &lt;/span&gt;&amp;lt;Node&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList &amp;lt;Node&amp;gt;&lt;span&gt;();
    Node current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childSize = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parentSize = 1&lt;span&gt;;
    queue.offer(root);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty()) {
      current &lt;/span&gt;= queue.poll();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队队头元素并访问&lt;/span&gt;
      System.out.print(current.val +&quot; &quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(current.left != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前节点的左节点不为空入队&lt;/span&gt;
&lt;span&gt;      {
        queue.offer(current.left);
        childSize&lt;/span&gt;++&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(current.right != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前节点的右节点不为空，把右节点入队&lt;/span&gt;
&lt;span&gt;      {
        queue.offer(current.right);
        childSize&lt;/span&gt;++&lt;span&gt;;
      }
      parentSize&lt;/span&gt;--&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parentSize == 0&lt;span&gt;)
      {
        parentSize &lt;/span&gt;=&lt;span&gt; childSize;
        childSize &lt;/span&gt;= 0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试普通BST&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args) {
    BST bst &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BST();
    bst.put(&lt;/span&gt;1,11&lt;span&gt;);
    bst.put(&lt;/span&gt;2,22&lt;span&gt;);
    bst.put(&lt;/span&gt;3,33&lt;span&gt;);
    bst.put(&lt;/span&gt;4,44&lt;span&gt;);
    bst.put(&lt;/span&gt;5,55&lt;span&gt;);
    bst.put(&lt;/span&gt;6,66&lt;span&gt;);
    bst.levelIterator();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(6层！！！)&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
11
22
33
44
55
66
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试AVL：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    AVL avl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AVL();
    avl.put(&lt;/span&gt;1,11&lt;span&gt;);
    avl.put(&lt;/span&gt;2,22&lt;span&gt;);
    avl.put(&lt;/span&gt;3,33&lt;span&gt;);
    avl.put(&lt;/span&gt;4,44&lt;span&gt;);
    avl.put(&lt;/span&gt;5,55&lt;span&gt;);
    avl.put(&lt;/span&gt;6,66&lt;span&gt;);
    avl.levelIterator();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(只有3层！)&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
44
22 55
11 33 66
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;全部代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* @Author: HuWan Peng
* @Date Created in 10:35 2017/12/29
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AVL {
  Node root; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根结点&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key,val;
    Node left,right;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height = 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个结点的高度属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
    }
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 返回两个数中的最大值
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max (&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a&amp;gt;b ?&lt;span&gt; a : b;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 获得当前结点的高度
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x.height;
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 获得平衡因子
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getBalance (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; height(x.left) -&lt;span&gt; height(x.right);
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 右旋方法
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node rotateRight (Node x) {
    Node y &lt;/span&gt;= x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得x的左儿子&lt;/span&gt;
    x.left = y.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x左儿子的右儿子（&quot;拖油瓶&quot;结点）链接到旋转后的x的左链接中&lt;/span&gt;
    y.right = x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调转x和它左儿子的父子关系，使x成为它原左儿子的右子树&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点&lt;/span&gt;
    y.height = max(height(y.left),height(y.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将y返回&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 左旋方法
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  Node rotateLeft (Node x) {
    Node y &lt;/span&gt;= x.right;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得x的右儿子&lt;/span&gt;
    x.right = y.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x右儿子的左儿子（&quot;拖油瓶&quot;结点）链接到旋转后的x的右链接中&lt;/span&gt;
    y.left = x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调转x和它右儿子的父子关系，使x成为它原右儿子的左子树&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点&lt;/span&gt;
    y.height = max(height(y.left),height(y.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新并维护受影响结点&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; y; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将y返回&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 平衡化操作
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node reBalance (Node x) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; balanceFactor =&lt;span&gt; getBalance(x);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;gt; 1&amp;amp;&amp;amp;getBalance(x.left)&amp;gt;0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LL型，进行单次右旋&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateRight(x);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;gt; 1&amp;amp;&amp;amp;getBalance(x.left)&amp;lt;=0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LR型 先左旋再右旋&lt;/span&gt;
      Node t =&lt;span&gt; rotateLeft(x);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateRight(t);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;lt; -1&amp;amp;&amp;amp;getBalance(x.right)&amp;lt;=0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RR型， 进行单次左旋&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateLeft(x);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(balanceFactor &amp;lt; -1&amp;amp;&amp;amp;getBalance(x.right)&amp;gt;0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RL型，先右旋再左旋&lt;/span&gt;
      Node t =&lt;span&gt; rotateRight(x);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotateLeft(t);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 插入结点（键值对）
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node put (Node x, &lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Node(key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入键值对&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;     (key&amp;lt;x.key) x.left  = put(x.left, key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树递归插入&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key&amp;gt;x.key) x.right = put(x.right,key, val); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向右子树递归插入&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; x.val = val; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key已存在， 替换val&lt;/span&gt;
    x.height = max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下至上更新结点height属性&lt;/span&gt;
    x = reBalance(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下往上, 检测当前结点是否失衡，若失衡则进行平衡化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    root &lt;/span&gt;=&lt;span&gt; put(root,key,val);
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 返回最小键
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node min (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x.left == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左儿子为空，则当前结点键为最小值，返回&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; min(x.left);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左儿子不为空，则继续向左递归&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; min () {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(root).key;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 删除最小键的结点
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node deleteMin (Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x.left==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前结点左儿子空，则将右儿子返回给上一层递归的x.left&lt;/span&gt;
    x.left = deleteMin(x.left);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树递归， 同时重置搜索路径上每个父结点指向左儿子的链接&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前结点不是min&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteMin () {
    root &lt;/span&gt;=&lt;span&gt; deleteMin(root);
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 删除给定key的键值对
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key,Node x) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;      (key&amp;lt;x.key) x.left  = delete(key,x.left); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向左子树查找键为key的结点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key&amp;gt;x.key) x.right = delete(key,x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向右子树查找键为key的结点&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结点已经被找到，就是当前的x&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(x.left==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左子树为空，则将右子树赋给父节点的链接&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(x.right==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果右子树为空，则将左子树赋给父节点的链接&lt;/span&gt;
      Node inherit = min(x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得结点x的继承结点&lt;/span&gt;
      inherit.right = deleteMin(x.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将继承结点从原来位置删除，并重置继承结点右链接&lt;/span&gt;
      inherit.left = x.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置继承结点左链接&lt;/span&gt;
      x = inherit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将x替换为继承结点&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    x.height &lt;/span&gt;= max(height(x.left),height(x.right)) + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下至上更新结点height属性&lt;/span&gt;
    x = reBalance(x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 沿递归路径从下往上, 检测当前结点是否失衡，若失衡则进行平衡化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    root &lt;/span&gt;=&lt;span&gt; delete(key, root);
  }
 
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelIterator () {
    LinkedList &lt;/span&gt;&amp;lt;Node&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList &amp;lt;Node&amp;gt;&lt;span&gt;();
    Node current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childSize = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parentSize = 1&lt;span&gt;;
    queue.offer(root);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty()) {
      current &lt;/span&gt;= queue.poll();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队队头元素并访问&lt;/span&gt;
      System.out.print(current.val +&quot;--&amp;gt;&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(current.left != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前节点的左节点不为空入队&lt;/span&gt;
&lt;span&gt;      {
        queue.offer(current.left);
        childSize&lt;/span&gt;++&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(current.right != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前节点的右节点不为空，把右节点入队&lt;/span&gt;
&lt;span&gt;      {
        queue.offer(current.right);
        childSize&lt;/span&gt;++&lt;span&gt;;
      }
      parentSize&lt;/span&gt;--&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parentSize == 0&lt;span&gt;)
      {
        parentSize &lt;/span&gt;=&lt;span&gt; childSize;
        childSize &lt;/span&gt;= 0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
      }
    }
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    AVL avl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AVL();
    avl.put(&lt;/span&gt;1,11&lt;span&gt;);
    avl.put(&lt;/span&gt;2,22&lt;span&gt;);
    avl.put(&lt;/span&gt;3,33&lt;span&gt;);
    avl.put(&lt;/span&gt;4,44&lt;span&gt;);
    avl.put(&lt;/span&gt;5,55&lt;span&gt;);
    avl.put(&lt;/span&gt;6,66&lt;span&gt;);
    avl.levelIterator();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180101095531034-884145310.jpg&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 01 Jan 2018 01:50:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghuwan/p/8166133.html</dc:identifier>
</item>
</channel>
</rss>