<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>瀑布流知识的延伸 - 决起而飞</title>
<link>http://www.cnblogs.com/iDouble/p/8449072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iDouble/p/8449072.html</guid>
<description>&lt;p&gt;瀑布流，很常见了，淘宝，网易云音乐等等都有，实现原理，咱先放着一遍，先将涉及到的知识点拓展开来&lt;/p&gt;
&lt;h2&gt;一、Math的方法&lt;/h2&gt;
&lt;p&gt;Math求最小值、最大值，&lt;/p&gt;
&lt;p&gt;对于一般的数字直接求，Math.min  Math.max &lt;/p&gt;
&lt;p&gt;但是求数组呢，一个方法，三种形式，js高程书中利用apply的回调函数，将this指向window，直接将所求的数组作为参数传入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装函数的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装一个getMin的函数直接调用获得&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; numbers=[23,435,45,34&lt;span&gt;]
          &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getMin(arr){               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装一个方法&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; min=Math.min.apply(&lt;span&gt;null&lt;/span&gt;,arr)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用apply的回调函数,将作用域this指向window，将数组作为参数传入&lt;/span&gt;
&lt;span&gt;          }
          console.log(getMin(numbers))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原型对象的方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学过原型对象，直接在Array的原型上添加min方法，让Array拥有min的方法，不推荐，产品化的程序不推荐在基本包装类型添加多余的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
          Array.prototype.min=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array){     //直接在原型上添加，传递参数
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.min.apply(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,array)
          }
          alert(numbers.min(numbers))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原型对象的方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用Object.defineProperty方法，这个具体说说&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
          Object.defineProperty(Array.prototype,'max'&lt;span&gt;,{
                   writable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                   enumerable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                   configurable:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                   value:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max.apply(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,numbers)  
                   }
          })
          console.log(numbers.max())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;拓展之Object.defineProperty方法&lt;/h3&gt;
&lt;p&gt;object.defineProperty()方法直接在对象上定义个新属性或者修改一个对象的现有属性，并返回这个对象&lt;/p&gt;
&lt;p&gt;接受三个参数&lt;/p&gt;
&lt;p&gt;obj：要在其上定义属性的对象，可以是引用类型Math，也可以是自定义的，或者原型对象&lt;/p&gt;
&lt;p&gt;prop：要定义或修改属性的名称(方法名)&lt;/p&gt;
&lt;p&gt;descriptor：将被定义或修改属性的描述符&lt;/p&gt;
&lt;p&gt;默认情况下使用此方法添加的属性是不可改变的，但是可以设置一些特性使其可以改变，for in 遍历的到等等&lt;/p&gt;
&lt;p&gt;对属性添加特性描述有数据描述和存取器描述两种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;writable：值是否可以重写&lt;/p&gt;
&lt;p&gt;enumerable:目标属性是否可以被枚举&lt;/p&gt;
&lt;p&gt;value：设置属性的值，可以为任意的数据类型或函数&lt;/p&gt;
&lt;p&gt;configurable：目标属性是否可以被删除或修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在String原型对象上添加方法&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; str='hello'&lt;span&gt;
          Object.defineProperty(String.prototype,&lt;/span&gt;'newword'&lt;span&gt;,{
                 value:&lt;/span&gt;'world'&lt;span&gt;
          })
          alert(str.newword)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单独给某个对象添加方法&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                   value:&lt;/span&gt;'world'&lt;span&gt;
          })
          alert(obj.newword)
          
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完整的特性例子&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                    value:&lt;/span&gt;'world'&lt;span&gt;,      
                    writable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否重写&lt;/span&gt;
                    enumerable:&lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for in 遍历&lt;/span&gt;
                  configurable:&lt;span&gt;true&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否可以删除属性  是否可以再次修改特性&lt;/span&gt;
&lt;span&gt;          })
          alert(obj.newword)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;
          obj.newword='hello'     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;writable为false 所以无效&lt;/span&gt;
          alert(obj.newword)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;word&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
               console.log(i)       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newword enumerable是true可以遍历 &lt;/span&gt;
&lt;span&gt;          }
          &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; obj.newword
          alert(obj.newword)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined 因为删除了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;存取器描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;p&gt;getter方法 获得属性值&lt;/p&gt;
&lt;p&gt;setter方法 设置属性值&lt;/p&gt;
&lt;p&gt;当使用getter或setter就不允许使用writable和value这两个属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; initValue='hello'&lt;span&gt;
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                  get:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){             
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; initValue     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到属性值&lt;/span&gt;
&lt;span&gt;                  },
                  set:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value){     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置属性值&lt;/span&gt;
                      initValue=&lt;span&gt;value
                  }
          })
          console.log(obj.newword)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IE8只能在DOM对象上使用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有趣的东西&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.min 和 Math.max 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; max=&lt;span&gt;Math.max()
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min=&lt;span&gt;Math.min()
          console.log(max&lt;/span&gt;&amp;gt;min)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里min反而是大于max呢？&lt;/p&gt;
&lt;p&gt;MDN里解释对于&lt;/p&gt;
&lt;p&gt;Math.min()如果没有参数，则返回Infinity&lt;/p&gt;
&lt;p&gt;Math.max()如果没有参数，则返回-Infinity&lt;/p&gt;
&lt;p&gt;任意参数不能转换为数值，则返回NaN&lt;/p&gt;
&lt;h2&gt;二、获取指定class的元素&lt;/h2&gt;
&lt;p&gt;早期的浏览器中不兼容getElementsByClassName 为了获取指定的class元素集合，常常封装一个方法，返回数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得指定class的元素&lt;/span&gt;
          &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getByClass(parent,name){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lists=parent.getElementsByTagName('*'&lt;span&gt;)
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=&lt;span&gt;[]
                 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;lists.length;i++&lt;span&gt;){
                           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lists[i].className==&lt;span&gt;name){
                                  arr.push(lists[i])
                           }
                 }
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、访问元素的样式&lt;/h2&gt;
&lt;p&gt;普通的访问简单，直接，DOM2级为style设置一些属性和方法，比如CSSText，可以直接访问到css元素属性，为元素应用多项变化最快捷的方式，一次性应用所有的&lt;/p&gt;
&lt;p&gt;下面的代码，分别是设置CSSText   移除removeProperty   length属性帮忙遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问元素的样式&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DOM2级中规定 CSSText访问style里的代码&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; myDiv=document.getElementById('myDiv'&lt;span&gt;)
          myDiv.style.cssText&lt;/span&gt;='width:200px;height:200px;background:#fee;color:red;'
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除某个css属性&lt;/span&gt;
          myDiv.style.removeProperty('color'&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历css属性  length和item的结合  getPropertyValue方法返回的是css属性值的字符串&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;myDiv.style.length;i++&lt;span&gt;){
                   console.log(myDiv.style[i])
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里补充个非行间样式的获取方法，直接获取非行间样式是不可读的，返回“” &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取非行间样式&lt;/span&gt;
          &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getStyle(obj,attr){
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(obj.currentStyle){
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.currentStyle[attr]         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE是属性&lt;/span&gt;
                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getComputedStyle(obj,&lt;span&gt;false&lt;/span&gt;)[attr]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他为方法&lt;/span&gt;
&lt;span&gt;                 }
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：如果是CSSText设置的，普通访问还是访问的到的，否则还是用封装函数的方法&lt;/p&gt;
&lt;h2&gt;四、json的遍历问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;json是一种轻量级的文本数据交换格式，是一种数据格式，支持多种编程语言，具有自我描述性，容易理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSON: &lt;strong&gt;J&lt;/strong&gt;ava&lt;strong&gt;S&lt;/strong&gt;cript &lt;strong&gt;O&lt;/strong&gt;bject &lt;strong&gt;N&lt;/strong&gt;otation(JavaScript 对象表示法)&lt;/p&gt;
&lt;p&gt;JSON 是存储和交换文本信息的语法。类似 XML。&lt;/p&gt;
&lt;p&gt;JSON 比 XML 更小、更快，更易解析。&lt;/p&gt;
&lt;p&gt;下面是简单的json格式和遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; json=&lt;span&gt;{
                 &lt;/span&gt;'name':'double'&lt;span&gt;,
                 &lt;/span&gt;'age':34&lt;span&gt;,
                 &lt;/span&gt;'sex':'man'&lt;span&gt;
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于json格式，一般用for in 遍历其中的元素&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json){
                console.log(i)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到name age sex  获得的是属性&lt;/span&gt;
&lt;span&gt;          }
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json){
                  console.log(json[j])  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到double 34 man  获得的是属性值&lt;/span&gt;
          }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嵌套的json遍历，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;嵌套的json格式  &lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; json=&lt;span&gt;{
                 &lt;/span&gt;'name':'double'&lt;span&gt;,
                 &lt;/span&gt;'age':34&lt;span&gt;,
                 &lt;/span&gt;'sex'&lt;span&gt;:{
                           &lt;/span&gt;'man':'one'&lt;span&gt;,
                           &lt;/span&gt;'woman':'two'&lt;span&gt;
                 }
          }

          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; json['sex']){         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历嵌套的json格式&lt;/span&gt;
                  console.log(i)               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性&lt;/span&gt;
                  console.log(json['sex'][i])  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性值&lt;/span&gt;
          }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、关于offsetWidth clientHeight scrollTop相关的总结&lt;/h2&gt;
&lt;p&gt;明天再续写&lt;/p&gt;
&lt;h2&gt;六、瀑布流的思路&lt;/h2&gt;
&lt;p&gt;好吧，现在正式说一说瀑布流的问题，前面都是我在瀑布流中遇到的重要的知识点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面总结一下思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;瀑布流，两步走&lt;/p&gt;
&lt;p&gt;第一步，图片大大小小都对齐，不要溢出，不要塌陷&lt;/p&gt;
&lt;p&gt;第二部，滚动鼠标，图片源源不断的来，永远滚不到底&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决第一步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;计算页面中的列数，利用列数求出container的宽度&lt;/p&gt;
&lt;p&gt;计算最小图片的高度和索引，让次行的第一张图片到达最小图片的下面，且使得那一行的高度增加&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决第二步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;计算鼠标滚动的距离，相比较最后一张图片的scrollHeight&lt;/p&gt;
&lt;p&gt;为新加载的图片创建节点，添加到页面上&lt;/p&gt;

&lt;p&gt;附上源码，注释标的挺清楚的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      waterFall(&lt;/span&gt;'container','wrap')              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里获取的是整个的wrap,box则不对,因为padding&lt;/span&gt;

      &lt;span&gt;var&lt;/span&gt; dataInt={'data':[{'src':'50.jpg'},{'src':'51.jpg'},{'src':'52.jpg'}]} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库中的图片,以json的格式传入&lt;/span&gt;
      window.onscroll=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(checkScrollSlide()){
                  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oParent=document.getElementById('container'&lt;span&gt;)
                     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;dataInt.data.length;i++){            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数据库中的图片&lt;/span&gt;
                             &lt;span&gt;var&lt;/span&gt; oWrap=document.createElement('div')    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加新节点到原来的HTML中&lt;/span&gt;
                        oWrap.className='wrap'&lt;span&gt;
                        oParent.appendChild(oWrap)
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oBox=document.createElement('div'&lt;span&gt;)
                        oBox.className&lt;/span&gt;='box'&lt;span&gt;
                        oWrap.appendChild(oBox)
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oImg=document.createElement('img'&lt;span&gt;)
                        oImg.src&lt;/span&gt;='images/'+&lt;span&gt;dataInt.data[i].src
                        oBox.appendChild(oImg)
                     }
                     waterFall(&lt;/span&gt;'container','wrap')                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次的排序&lt;/span&gt;
&lt;span&gt;             }
      }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序,让图片大小一致的排序&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; waterFall(parent,child){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iParent=&lt;span&gt;document.getElementById(parent)
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aLists=getByClass(iParent,child)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得class为wrap的图片块&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得列数&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; pageWidth=document.documentElement.clientWidth||&lt;span&gt;document.body.clientWidth
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boxWidth=aLists[0&lt;span&gt;].offsetWidth
      cols&lt;/span&gt;=Math.floor(pageWidth/boxWidth)       //整个页面/&lt;span&gt;单个宽
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据列数计算contianer宽度&lt;/span&gt;
      iParent.style.cssText='width:'+cols*boxWidth+'px;margin:0 auto;'
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放每一行的高度&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; colHeight=&lt;span&gt;[]
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;aLists.length;i++&lt;span&gt;){
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;cols){
                     colHeight.push(aLists[i].offsetHeight)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将第一行高度纳入&lt;/span&gt;
             }&lt;span&gt;else&lt;/span&gt;{                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其余行  &lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; minH=Math.min.apply(&lt;span&gt;null&lt;/span&gt;,colHeight)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用Math.min查找数组高度最小&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; index=colHeight.indexOf(minH)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得最小的索引&lt;/span&gt;
                aLists[i].style.position='absolute'        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为移动,所以设置position/top/left&lt;/span&gt;
                aLists[i].style.top=minH+'px'&lt;span&gt;
                aLists[i].style.left&lt;/span&gt;=boxWidth*index+'px'&lt;span&gt;
                colHeight[index]&lt;/span&gt;+=aLists[i].offsetHeight   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小的高度+接下来的高度,使第二小成为最小,然后依次&lt;/span&gt;
&lt;span&gt;             }
      }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取class为box的元素 传递两个参数parent className&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getByClass(parent,name){
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list=parent.getElementsByTagName('*'&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=&lt;span&gt;[]
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;list.length;i++&lt;span&gt;){
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list[i].className==&lt;span&gt;name){
                  arr.push(list[i])
           }
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  arr
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测浏览器是否scroll&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkScrollSlide(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oParent=document.getElementById('container'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aWrap=getByClass(oParent,'wrap'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastWrap=aWrap[aWrap.length-1].offsetTop+Math.floor(aWrap[aWrap.length-1].offsetHeight/2)  //获得最后一张图片的距离的高度
    &lt;span&gt;var&lt;/span&gt; scrollTop=document.documentElement.scrollTop||document.body.scrollTop             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scrollTop&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; clientHeight=document.documentElement.clientHeight||document.body.clientHeight    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;clientHeight&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(lastWrap&amp;lt;scrollTop+clientHeight){                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断&lt;/span&gt;
             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但凡有错，直接指出，相互进步，就马上也过年了，祝大家新年大吉吧！&lt;/p&gt;
</description>
<pubDate>Wed, 14 Feb 2018 15:15:00 +0000</pubDate>
<dc:creator>决起而飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iDouble/p/8449072.html</dc:identifier>
</item>
<item>
<title>cmd 与 bash 基础命令入门 - 卷柏的花期</title>
<link>http://www.cnblogs.com/HCJJ/p/8448964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HCJJ/p/8448964.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;身为一个程序员会用命令行来进行一些简单的操作，不是显得很装逼嘛！？嘿嘿~ ヾ(&lt;em&gt;&amp;gt;∀＜&lt;/em&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;cmd 与 bash 基础命令入门&lt;/strong&gt;&lt;br/&gt;      简介&lt;br/&gt;      CMD 基础命令&lt;br/&gt;            目录操作&lt;br/&gt;                  切换目录&lt;br/&gt;                  列出文件与子目录&lt;br/&gt;                  创建目录&lt;br/&gt;                  删除目录&lt;br/&gt;                  复制目录&lt;br/&gt;                  移动目录&lt;br/&gt;                  重命名目录&lt;br/&gt;                  显示树形目录&lt;br/&gt;            文件操作&lt;br/&gt;                  新建文件&lt;br/&gt;                  删除文件&lt;br/&gt;                  复制文件&lt;br/&gt;                  移动文件&lt;br/&gt;                  重命名文件&lt;br/&gt;                  文件内容比较&lt;br/&gt;                  打印文件&lt;br/&gt;                  查找文件&lt;br/&gt;                  根据内容查找文件&lt;br/&gt;            环境变量&lt;br/&gt;                  设置环境变量&lt;br/&gt;                  使用环境变量&lt;br/&gt;            辅助命令&lt;br/&gt;      BASH 基础命令&lt;br/&gt;            目录操作&lt;br/&gt;                  切换目录&lt;br/&gt;                  列出文件与子目录&lt;br/&gt;                  创建目录&lt;br/&gt;                  删除目录&lt;br/&gt;                  复制目录&lt;br/&gt;                  移动目录&lt;br/&gt;                  重命名目录&lt;br/&gt;                  显示树形目录&lt;br/&gt;            常用目录说明&lt;br/&gt;            文件操作&lt;br/&gt;                  新建文件&lt;br/&gt;                  删除文件&lt;br/&gt;                  复制文件&lt;br/&gt;                  移动文件&lt;br/&gt;                  重命名文件&lt;br/&gt;                  文件内容比较&lt;br/&gt;                  打印文件&lt;br/&gt;                  查找文件&lt;br/&gt;                  根据内容查找文件&lt;br/&gt;                  压缩与解压&lt;br/&gt;                  打包与解包&lt;br/&gt;            vi编辑器初探&lt;br/&gt;            常用快捷键&lt;br/&gt;            环境变量&lt;br/&gt;                  设置环境变量&lt;br/&gt;                  使用环境变量&lt;br/&gt;            其它常用命令&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在学习 &lt;code&gt;cmd&lt;/code&gt; 与 &lt;code&gt;bash&lt;/code&gt; 之前，让我们先了解它们的相关背景，从而更好的认识以及学习它们。&lt;/p&gt;
&lt;p&gt;首先，在说 &lt;code&gt;cmd&lt;/code&gt; 之前，我们要先说一个操作系统 “DOS(Disk Operating System)”即“磁盘操作系统”。 &lt;code&gt;DOS&lt;/code&gt;是基于命令方式来进行工作的，从 1981年到 1995年这15年多的时间内在个人计算机操作系统中，可谓风靡一时，并占据着非常大的市场空间，也衍生了很多其它种类的 &lt;code&gt;DOS&lt;/code&gt;系统，但由于其基于命令的工作模式，对于使用者往往有着很高的专业要求，当 &lt;code&gt;window&lt;/code&gt;,&lt;code&gt;Macos&lt;/code&gt; 等基于图形化界面的操作系统开始普及后，以其简单易用的操作模式， &lt;code&gt;DOS&lt;/code&gt; 开始被迅速淘汰，虽然 &lt;code&gt;DOS&lt;/code&gt; 已经被淘汰，但也并未完全消失，至今哪怕最新版的“window 10” 在其内部都依然保留着 &lt;code&gt;DOS&lt;/code&gt; 。 只是这种被保留的&lt;code&gt;DOS&lt;/code&gt; 是以一种独立的应用程序形式存在着，并且在功能上也被进行了精简，而这个应用程序也就是我们要学习的 “cmd”（命令提示符）,在 &lt;code&gt;cmd&lt;/code&gt; 中，通过执行特定的 &lt;code&gt;DOS&lt;/code&gt; 命令，便可以让我们在 &lt;code&gt;window&lt;/code&gt; 简单的使用场景中减少对鼠标以及图形化窗口的依赖。&lt;/p&gt;
&lt;p&gt;而说到 &lt;code&gt;bash&lt;/code&gt; ，则不得不提 &lt;code&gt;shell&lt;/code&gt; ，shell是使用C语言编写的一个应用程序，它是用户使用 Unix/Linux 的桥梁，负责把用户的指令传递给内核并且把执行结果回显给用户。 &lt;code&gt;shell&lt;/code&gt; 定义了一套自己的“命令集”，这些命令既可以在交互式的场景下等待用户输入命令然后解释执行，也可以在批处理的场景下，用户事先写一个“Shell脚本”(shell Script，通过很多的 shell命令组合成需要的功能)然后让 Shell一次性把这些命令执行完，而不必一条一条地敲命令。&lt;/p&gt;
&lt;p&gt;说到这里，让我们重新梳理对 &lt;code&gt;shell&lt;/code&gt; 认识的三个重点，首先 shell是一种应用程序，其次 shell中定义了一套 “shell命令集”，最后 shell命令是通过“shell解释器”解释执行，而重点中的重点就在于“shell解释器”，我们知道 shell 的种类有很多，比如 bash、csh、ksh 等等，那么是什么造成了如此多的种类差异呢？其根本原因就在于使用的解释器不同。而解释器的不同，则源于对功能的需要求不同，有的需求场景中需要很轻的解释器，而有的场景则需要更复杂的解释器。通常而言，在 Unix中默认的 shell是 &lt;code&gt;sh&lt;/code&gt;，在 linux中默认的 shell是 &lt;code&gt;bash&lt;/code&gt;，&lt;code&gt;bash&lt;/code&gt; 是基于 Bourne shell，并吸收了 C shell和 K shell的一些特性。&lt;code&gt;bash&lt;/code&gt; 完全兼容 &lt;code&gt;sh&lt;/code&gt;，也就是说，用 &lt;code&gt;sh&lt;/code&gt; 写的脚本可以不加修改的在 &lt;code&gt;bash&lt;/code&gt; 中执行。如果想知道你当前的 shell是哪一种的？可以在你的控制台执行这条命令 &lt;code&gt;echo $SHELL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不论是 &lt;code&gt;bash&lt;/code&gt; 还是 &lt;code&gt;cmd&lt;/code&gt; ，我们也通常称它们为“命令行工具”或者是“命令行界面(CLI)”。&lt;/p&gt;
&lt;p&gt;最后，为什么我们要学习它们？因为学习它们，(cmd)可以让我们可以在 &lt;code&gt;windows&lt;/code&gt; 或者 (bash)&lt;code&gt;linux&lt;/code&gt; 等简单使用场景中，脱离对鼠标与用户界面的依赖，从而提高编码效率。&lt;/p&gt;
&lt;p&gt;当然！“装逼”也是根本原因嘛~&lt;/p&gt;
&lt;h2 id=&quot;cmd-基础命令&quot;&gt;CMD 基础命令&lt;/h2&gt;
&lt;h3 id=&quot;目录操作&quot;&gt;目录操作&lt;/h3&gt;
&lt;h4 id=&quot;切换目录&quot;&gt;切换目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cd ：进入指定的目录或者是显示当前的目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd             #C:\Users\gt\Desktop
cd dir/sub-dir # 进入到dir中的sub-dir目录。
d:             # 直接进入d盘
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;列出文件与子目录&quot;&gt;列出文件与子目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;dir ：列出当前目录中的文件以及子目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 除了能默认显示当前目录的文件以及子目录，还可以显示指定目录下的文件以及子目录，同时也会统计目录下的文件以及目录的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir d:\fornt    #显示D盘font目录中的资源&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 默认不显示一些特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 &lt;code&gt;/a&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是想显示具有特定属性的文件，可以为 &lt;code&gt;/a&lt;/code&gt; 参数附加对应的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /a [d|r|h|s] #显示具有指定属性的文件
dir /ad          #只显示目录
dir /ar          #只显示只读文件
dir /ah          #只显示隐藏文件
dir /as          #只显示系统文件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 还有一个 &lt;code&gt;/o&lt;/code&gt; 的参数也会比较常用，使用它可以分类显示文件以及目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /o [n | s | e | d]
dir /on   #按名称(字母)显示
dir /os   #按大小(从小到大)
dir /oe   #按扩展名(字母顺序)
dir /od   #按日期/时间(从先到后)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建目录&quot;&gt;创建目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mkdir | md ：新建目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir dir               # 新建一个dir目录
mkdir dir1\dir2\dir3    # 连续新建三个目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除目录&quot;&gt;删除目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rmdir | rd ：删除指定目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;md dirname
rd dirname
md dir1\dir2\dir3
rd dir1\dir2\&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*如果目录中含有其它目录或者是文件，单纯使用 &lt;code&gt;rd&lt;/code&gt; 将无法删除，必须要结合一些特殊的参数，例如 &lt;code&gt;/s&lt;/code&gt; 强制删除&lt;code&gt;/q&lt;/code&gt; 安静模式（不会询问）。&lt;/p&gt;
&lt;h4 id=&quot;复制目录&quot;&gt;复制目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;xcopy ：将目录复制到指定的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xcopy dir e:dir1 #将dir目录复制到 E盘，并重命名为dir1。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*使用这种方式复制目录，只能将目录以及目录中的文件复制到新的位置，但是并不能将目录中的子目录以及子目录中的所有文件也复制过去。&lt;br/&gt;但可以通过附加一个参数 &lt;code&gt;/e&lt;/code&gt; 从而实现将整个目录（所有的子目录以及文件）都复制到新的位置中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xcopy dir e:dir1 /e&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动目录&quot;&gt;移动目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;move ：将指定的目录移动到新的目录中&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;move C:\Users\gt\Desktop\test distDir #将指定的目录移动到新的目录中
move dir1 dir2                        #将dir1目录移动到dir2目录中&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名目录&quot;&gt;重命名目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rename | ren ：重命名文件或目录名。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ren dirName newDirName &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;显示树形目录&quot;&gt;显示树形目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tree ： 显示目录的树形图。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree                          #当前目录的树形图
tree C:\Users\gt\Desktop\     #指定目录的树形图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形结构。&lt;/p&gt;
&lt;h3 id=&quot;文件操作&quot;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&quot;新建文件&quot;&gt;新建文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;notepad : 打开window的记事本程序新建文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;notepad filename.ext
notepad 1.txt
notepad index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*notepad 是调用window中的记事本程序来新建文件。&lt;/p&gt;
&lt;h4 id=&quot;删除文件&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;del ：删除指定的文件或者是清空指定目录中的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del filename #删除指定的文件
del file1 file2 .. #删除多个文件
del dir #清空指定目录下的所有文件
del dir1 dir2 dir3 .. #清空多个目录下的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用 &lt;code&gt;del&lt;/code&gt; 清空指定目录下的所有文件时，默认会有一个询问，如果想忽略询问，只需要加一个参数&lt;code&gt;/q&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del dir /q&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出此之外，使用 &lt;code&gt;del&lt;/code&gt; 还可以删除特定属性的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del /AR #可以删除只读文件
del /AH #可以删除隐藏文件
del /AS #可以删除系统文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，&lt;code&gt;del&lt;/code&gt; 还可以结合通配符来删除匹配到文件。&lt;/p&gt;
&lt;h4 id=&quot;复制文件&quot;&gt;复制文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;copy ：复制一个或者是多个文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;copy file.txt file_copy.txt    #在当前目录由file.txt 复制为一个名为file_copy.txt的新文件。
copy C:\Users\Admin\Desktop\index.js index_copy.js #将桌面上的index.js文件复制到当前目录，并命名为index_copy.js
copy file1 dir\file2 #相对目录进行复制。
copy file1+file2 dir\file3 #将当前目录的file1与file2文件复制到dir目录中并合成一个新的file3文件。
copy C:\Users\Admin\Desktop\ #将桌面上的所有文件复制到当前目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; 命令还具有两个不是太常用的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;copy file /A #复制一个ASCII文件。
copy file /B #复制一个二进制文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; 命令只能复制指定目录中的文件，而不能复制指定目录中的子目录和文件。&lt;br/&gt;如果想复制目标目录下的所有文件和文件夹，可以使用 &lt;code&gt;xcopy&lt;/code&gt; 命令，它相当于 &lt;code&gt;copy&lt;/code&gt; 命令的扩展版。&lt;/p&gt;
&lt;h4 id=&quot;移动文件&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;move ：将指定的文件移动到新的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;move file.txt dir/file.txt    #将指定的文件移动到指定的目录中。
move file.txt dir/newfile.txt #移动的同时，重新命名。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名文件&quot;&gt;重命名文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ren ：重命名文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ren oldfilename newfilename&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;文件内容比较&quot;&gt;文件内容比较&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;fc ：在指定的文件集中比较文件的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fc file1 file2 file3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打印文件&quot;&gt;打印文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;type ：在命令行工具中打印文件内容。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type file      #打印文件file的内容。
type dir\file  #打印指定目录中file文件的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 命令还可以结合通配符一起使用，打印多个文件的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type dir\*     #打印指定目录dir中所有文件的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查找文件&quot;&gt;查找文件&lt;/h4&gt;
&lt;p&gt;我们知道 &lt;code&gt;dir&lt;/code&gt; 是用于列出指定目录中所有的文件或子目录，实际上 &lt;code&gt;dir&lt;/code&gt; 后面还可以跟上文件名目录名或者是通配符来设置只列出匹配到的文件以及目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir index.js    #列出该目录下的index.js
dir *.js        #列出该目录下扩展名为js的所有文件。
dir *           #列出所有文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与查找文件相同，&lt;code&gt;dir&lt;/code&gt; 也可以查找指定的目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据内容查找文件&quot;&gt;根据内容查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;find ：根据文件内容查找文件，不确定文件名称或者是扩展名时可结合通配符使用。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find &quot;function handle&quot; index.js #确定文件查找
find &quot;function handle&quot; *.js     #根据文件名模糊查找
find &quot;function handle&quot; ?.js     #查找文件名只有一个字符的js文件。
find &quot;function handle&quot; /*       #查找所有文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 命令还具有一些其它有用的参数：&lt;code&gt;/i&lt;/code&gt; 忽略大小写 , &lt;code&gt;/v&lt;/code&gt; 只显示匹配到的文件，&lt;code&gt;/n&lt;/code&gt; 显示行号。&lt;/p&gt;
&lt;h3 id=&quot;环境变量&quot;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;注意，如果想在window中设置永久的环境变量，只能通过 “我的电脑” - “属性” - “高级” - “环境变量”。&lt;br/&gt;使用命令行来设置环境变量只对当前窗口有效，窗口关闭时，将会自动失效。&lt;/p&gt;
&lt;h4 id=&quot;设置环境变量&quot;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;set : 通过&lt;code&gt;set&lt;/code&gt;命令我们即可以查看指定的环境变量，也可以设置一个新的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set               #查看当前的所有环境变量
set PATH          #查看环境变量PATH的值。
set key = value   #设置一个新的环境变量并赋值。
set key = value2  #重新对指定的环境变量赋值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*path这个环境变量是用于设置可执行文件（程序）的搜索路径，是非常常用的一个环境变量。&lt;/p&gt;
&lt;h4 id=&quot;使用环境变量&quot;&gt;使用环境变量&lt;/h4&gt;
&lt;p&gt;在CMD中，如果想引用某个环境变量，则使用 &lt;code&gt;%env%&lt;/code&gt; 的格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo %PATH%

set name=usrname
echo %name%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们通过一个非常小的例子来理解通过命令设置环境变量 &lt;code&gt;PATH&lt;/code&gt; 值的作用。&lt;br/&gt;假设我们有一个可执行的程序，名字叫做 &lt;code&gt;main.exe&lt;/code&gt; 保存在 &lt;code&gt;D:\install\main&lt;/code&gt;目录中。 一般，我们想执行某个程序的方法有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为可执行文件建立快捷方式到桌面&lt;/li&gt;
&lt;li&gt;进入目录，双击执行可执行程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而上面的方法，不论哪一种，都无法解决在命令行窗口中，输入 &lt;code&gt;main&lt;/code&gt; 便可以执行 &lt;code&gt;main.exe&lt;/code&gt;的需求。&lt;br/&gt;然而通过设置环境变量 &lt;code&gt;PATH&lt;/code&gt; 的值便可以做到这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set main_exc=D:\install\main
set PATH=%PATH%;%main_exc%
main                           #执行main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实设置环境变量&lt;code&gt;PATH&lt;/code&gt;的值，可以直接使用 &lt;code&gt;path&lt;/code&gt;命令，而无需通过 &lt;code&gt;set&lt;/code&gt; 来声明要修改的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path %PATH%;%main_exc%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，在环境变量 &lt;code&gt;PATH&lt;/code&gt; 中如果设置多个值，每个值之间使用 &lt;code&gt;;&lt;/code&gt; 分号隔开。&lt;/p&gt;
&lt;h3 id=&quot;辅助命令&quot;&gt;辅助命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cls        #清除屏幕。
cmd        #进入MS-DOS
echo       #显示消息，或将命令回显打开或关闭。
exit       #退出 CMD.EXE 程序(命令解释程序)。
start      #启动单独的窗口以运行指定的程序或命令。
calc       #启动计算器
explorer   #打开资源管理器
notepad    #打开记事本
dxdiag     #检查DirectX信息
regedt32   #注册表编辑器
Msconfig   #系统配置实用程序
taskmgr    #打开任务管理器
help       #查看MS-DOS命令帮助。
command /? #查看指定命令详细帮助文档。
wmic       #进入wmic（Windows Management Instrumentation），它是windows管理工具命令行版，使用wmic我们可以对整个系统进行管理，例如远程连接、硬件管理、进程管理、账号管理、服务管理、目录管理、共享管理等等，可说它是一个增强版的CMD。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bash-基础命令&quot;&gt;BASH 基础命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bash&lt;/code&gt; 有些命令与 &lt;code&gt;cmd&lt;/code&gt;中非常相像，比如 &lt;code&gt;cd&lt;/code&gt;，再比如 &lt;code&gt;mkdir&lt;/code&gt;等。因此学会了 &lt;code&gt;cmd&lt;/code&gt; 对于学习 &lt;code&gt;bash&lt;/code&gt; 也非常有帮助。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;bash&lt;/code&gt;与&lt;code&gt;cmd&lt;/code&gt;的区别，我个人认为最大的不同有两点，一是目录路径的表示上， &lt;code&gt;bash&lt;/code&gt;使用我们常见的斜杠 &lt;code&gt;cd dir1/dir2/dir3&lt;/code&gt;，而 &lt;code&gt;cmd&lt;/code&gt;则使用反斜杠 &lt;code&gt;cd dir1\dir2\dir3&lt;/code&gt;，虽然 &lt;code&gt;cmd&lt;/code&gt; 也可以使用斜杠，但是在某些情况下使用斜杠将会行不通，例如 &lt;code&gt;copy&lt;/code&gt; 命令，所以我们建议对 &lt;code&gt;cmd&lt;/code&gt; 保持统一的目录风格，即“反斜杠”。最后一点则在于命令的附加参数，&lt;code&gt;cmd&lt;/code&gt;中是通过斜杠来附加参数 &lt;code&gt;/params&lt;/code&gt; 而 &lt;code&gt;bash&lt;/code&gt;则是通过横杠 &lt;code&gt;-params&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;目录操作-1&quot;&gt;目录操作&lt;/h3&gt;
&lt;h4 id=&quot;切换目录-1&quot;&gt;切换目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cd ：进入指定的目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd   #进入个人目录
cd / #进入根目录
cd - #返回上次的目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不确定自己当前的目录位置，可以结合 &lt;code&gt;pwd&lt;/code&gt; 命令，便会在命令行中打印出当前目录路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pwd &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;列出文件与子目录-1&quot;&gt;列出文件与子目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ls ：列出当前目录中的文件以及子目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 除了能默认显示当前目录的资源以及子目录，还可以显示指定目录下的文件以及子目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls ../   #列出上级目录下的资源和子目录
ls /     #列出根目录下的资源和子目录。
ls /home #列出home目录下的资源和子目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 默认不显示具有特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 &lt;code&gt;-a&lt;/code&gt; 参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要查看资源或目录更详细的信息，可以附加 &lt;code&gt;-l&lt;/code&gt;属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建目录-1&quot;&gt;创建目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mkdir ：创建目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir dir                 #创建一个目录dir
mkdir dir1 dir2 dir3..    #同时创建多个同级目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想创建一个目录树，可以附加一个 &lt;code&gt;-p&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p a/b/c/d&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除目录-1&quot;&gt;删除目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rmdir ：删除空目录&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;rm -rf ：强制删除目录(包括非空目录)。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rmdir emptyDir #删除一个空目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想删除一个非空目录，则需要使用 &lt;code&gt;rm&lt;/code&gt; 命令，并使用 &lt;code&gt;-rf&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -rf dir                  #删除一个非空目录。
rm -rf dir1 dir2 dir3       #同时删除多个非空目录。
rm -rf pattern              #删除按照特定模式匹配到的目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;复制目录-1&quot;&gt;复制目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cp -a ：复制目录到指定的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -a dir ../dir  #将当期目录复制一份到上级目录中。
cp -a dir dir2    #复制目录并重命名。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动目录-1&quot;&gt;移动目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mv ：移动目录到指定位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file file2                         #同级移动，相当于重命名目录file为file2
mv file ../file2                      #将目录移动到上级目录中并重命名。
sudo mv /home/user/file /home/        #将指定位置的目录移动到指定位置中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，&lt;code&gt;mv&lt;/code&gt; 也可以结合通配符进行使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv * ../   #将所有的目录与文件都复制到上级目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名目录-1&quot;&gt;重命名目录&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;mv&lt;/code&gt; 命令同级移动功能，并结合重命名的特点，就可以做到目录的重命名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file newfile2                         #同级移动，相当于重命名目录file为newfile2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;显示树形目录-1&quot;&gt;显示树形目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tree ：显示目录的树形图。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree       #当前目录的树形图
tree /     #根目录下的树形图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形图。&lt;/p&gt;
&lt;h4 id=&quot;常用目录说明&quot;&gt;常用目录说明&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/     #根目录
/bin  #命令保存目录
/boot #启动目录
/dev  #设备文件命令
/etc  #配置文件保存目录
/home #家目录
/lib  #系统库保存命令
/mnt  #系统挂载目录&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件操作-1&quot;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&quot;新建文件-1&quot;&gt;新建文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;touch ：新建文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;touch filename             #新建一个文件。
touch file1 file2 file3... #同时新建多个文件。
touch dir/file             #在指定的位置中新建一个文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果终端已经附加了 &lt;code&gt;vi&lt;/code&gt; 编辑器，也可以使用 &lt;code&gt;vi filename&lt;/code&gt; 的形式来创建文件，与 &lt;code&gt;cmd&lt;/code&gt; 中的 &lt;code&gt;notepad&lt;/code&gt; 命令功能类似。&lt;/p&gt;
&lt;h4 id=&quot;删除文件-1&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rm ：删除文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm file      #删除文件
rm dir/file  #删除指定目录中的文件
rm dir/*     #删除指定目录中的所有文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;复制文件-1&quot;&gt;复制文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cp ：复制文件到指定的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp file file1    #将文件复制一份并重新命名。
cp file ../      #将文件复制一份到上级目录中。
sudo cp file /   #将文件复制到根目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cp&lt;/code&gt; 还可以结合通配符一起使用，将匹配到的文件复制到指定的位置中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp dir/*  ./  #指定目录中的所有文件复制到当前目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动文件-1&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mv ：移动文件到指定的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file ../       #将文件移动到上级目录中。
mv ../file ./     #将上级的文件移动到当前目录中。
sudo mv file /    #将文件移动到根目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt; 不仅可以移动文件，还可以在移动后重命名文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv filename1 ../filename2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt;还可以结合通配符使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv na?.txt ../nbc.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名文件-1&quot;&gt;重命名文件&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;mv&lt;/code&gt; 命令同级移动的功能再结合其可以重命名的特点，从而实现文件的重命名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file file2                         #同级移动，相当于重命名文件file为file2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;文件内容比较-1&quot;&gt;文件内容比较&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;diff ：比较多个文件内容的不同&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;diff file1 file2 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打印文件-1&quot;&gt;打印文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cat ：在命令行工具中打印文件的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat filename    #打印指定文件的内容
cat file1 file2 #同时打印多个文件的内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 命令除了能打印文件的内容，还可以合并多个文件的内容保存到一个新的文件中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat file1 file2 &amp;gt; newfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，还可以结合通配符来打印匹配到的所有文件内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat a*
cat *.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果查看的文件内容很多，还可以使用 &lt;code&gt;less&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;less file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;space&lt;/code&gt; 便可以向下一页一页的翻动，或者 &lt;code&gt;pgup&lt;/code&gt; 向上翻页 , &lt;code&gt;pgdn&lt;/code&gt; 向下翻页，&lt;code&gt;q&lt;/code&gt; 则可以退出 &lt;code&gt;less&lt;/code&gt;命令。&lt;/p&gt;
&lt;h4 id=&quot;查找文件-1&quot;&gt;查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;find ：可以根绝名称、大小、修改时间来查找指定的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find -name httpd.conf #在当前目录下查找httpd.conf文件。
find -name *.js       #在当前目录下查找所有js文件。
find -empty           #查找所有为空的目录。
find -size -1000      #查找小于1000KB的文件。
find -size +1000      #查找大于1000KB的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令默认在当前目录进行查找，你也可以指定一个目录进行查找。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find / -name *.txt          #在根目录下查找所有的txt文件。
find /etc -name httpd.conf  #在etc目录下查找httpd.conf文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与根据文件名查找文件相同，也可以使用 &lt;code&gt;find&lt;/code&gt; 按照目录名来查找目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find -name dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据内容查找文件-1&quot;&gt;根据内容查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;grep ：可以根据指定的内容来查找含有这些内容的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grep pattern *  #查找当前目录含有指定匹配模式的文件。pattren可以是一个正则表达式。
grep c *        #查找当前目录含有单词c的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想忽略内容的大小写可以附加一个 &lt;code&gt;-i&lt;/code&gt;的参数。&lt;br/&gt;显示匹配行及行号附加 &lt;code&gt;-n&lt;/code&gt;&lt;br/&gt;如果只显示文件名，不显示具体匹配到的内容，则附加 &lt;code&gt;-l&lt;/code&gt; 参数&lt;/p&gt;
&lt;h4 id=&quot;压缩与解压&quot;&gt;压缩与解压&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;gzip ：单独压缩指定的文件，压缩后删除被压缩文件，只保留压缩后的文件，并且不能压缩目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip file                   #压缩指定的文件
gzip file1 file2 file3...   #同时压缩多个文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;gzip&lt;/code&gt; 还可以与通配符结合使用，压缩匹配到的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip *.*
gzip ?.?.*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若想列出某个 &lt;code&gt;.gz&lt;/code&gt; 压缩文件中的内容，可以附加一个 &lt;code&gt;-l&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip -l file.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压某个&lt;code&gt;.gz&lt;/code&gt; 文件，则使用 &lt;code&gt;gunzip&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gunzip file.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;zip ：与 &lt;code&gt;gzip&lt;/code&gt; 相比 &lt;code&gt;zip&lt;/code&gt; 可以压缩目录还可以将多个文件压缩在一起，并保留被压缩的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip file1 file2 ...   #将指定的文件压缩到一个新创建的压缩文件中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; 也可以结合通配符使用，压缩匹配到的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip *.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更强的是 &lt;code&gt;zip&lt;/code&gt; 还可以一次性压缩一个目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip dir&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，若想列出某个 &lt;code&gt;.zip&lt;/code&gt; 压缩文件中的内容，可以附加一个 &lt;code&gt;-l&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip -l filename.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压某个&lt;code&gt;.zip&lt;/code&gt; 文件，则使用 &lt;code&gt;unzip&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip file.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打包与解包&quot;&gt;打包与解包&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tar ：它是linux下的一个打包命令，它可以将一大堆松散的文件或者是目录打包在一起，从而保证资源的完整性。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -cvf package.tar file1 file2 file3 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要打包一个目录，则指定目录名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -cvf package.tar dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想解包，则附加 &lt;code&gt;-xvf&lt;/code&gt; 的参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xvf package.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是想列出某个包中含有的文件或目录,则附加 &lt;code&gt;-tvf&lt;/code&gt; 参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar tvf package.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 命令只能打包，而不能压缩，而 &lt;code&gt;gzip&lt;/code&gt; 虽然可以压缩但是只能对文件进行单独压缩，并且只保留压缩后的文件，而不保留被压缩的文件，所以将 &lt;code&gt;tar&lt;/code&gt; + &lt;code&gt;gzip&lt;/code&gt; 结合使用，将会互补其短，产生更大的功效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar package.tar file1 file2 file3 ... #将多个文件打包在package.tar包文件中。
gzip package.tar.gz package.tar       #将通过tar打包的文件再进行压缩。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压缩解包也要依次进行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gunzip package.tar.gz #解压缩
tar -xvf package.tar  #解包&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以通过附加参数的方式一次性的打包压缩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zcvf package.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后一次性的解压缩解包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf package.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vi编辑器初探&quot;&gt;vi编辑器初探&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vi&lt;/code&gt; 是 Unix及 Linux系统下标准的文本编辑器，由美国加州大学伯克利分校的 Bill Joy所创立。&lt;br/&gt;我们可以在支持 vi 编辑器的命令行工具中，直接调用“vi编辑器”来编辑文件。&lt;br/&gt;&lt;code&gt;vi&lt;/code&gt; 有三种模式，分别是“命令模式(Comand Mode)”、“插入模式(Inset Mode)””、“底行模式(last line mode)”。默认的模式则是“命令模式”。&lt;br/&gt;在“命令模式”下我们可以移动光标，删除字符，单词，行，复制字符，单词，行等。通过按字母 &lt;code&gt;a&lt;/code&gt; 便可以进入到“插入模式”，而通过 &lt;code&gt;shift+;&lt;/code&gt;组合键(目的是输入冒号:)则进入到“底行模式”。&lt;br/&gt;在“插入模式”下才可以编辑文字，按 &lt;code&gt;esc&lt;/code&gt; 键则可以返回“命令模式”。&lt;br/&gt;在“底行模式”则可以执行一些命令动作，例如保存文件，设置编辑器环境，查找字符等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式(Command Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;i、a、o&lt;/code&gt; 进入到“插入模式”。&lt;code&gt;i&lt;/code&gt;会在光标的当前位置输入，&lt;code&gt;a&lt;/code&gt; 则会在光标所在的下一个位置输入，&lt;code&gt;o&lt;/code&gt;会插入新的一行，并从行首开始输入文字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift+;&lt;/code&gt; 进入到“底行模式”&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | h&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向左移动一个字符，如果结合数字键，则向左移动指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | l&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向右移动一个字符，如果结合数字键，则向右移动指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | j&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向上移动一行，如果结合数字键，则向上移动指定数量的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | k&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向下移动一行，如果结合数字键，则向下移动指定数量的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | x&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向后删除当前光标所在的字符，类似于DEL键，结合数字键则向后删除指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向前删除当前光标所在的字符，类似于BackSpace键，结合数字键则向前删除指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移动到行首&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移动到行尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;dd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;删除光标所在行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;yy&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;复制当前行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;J&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;合并行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;p&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将已复制的数据在光标下一行贴上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;P&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将已复制的数据在光标上一行贴上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;yyp&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;复制光标所在的行再插入到下一行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;H&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;光标移至屏幕顶行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;L&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;光标移至屏幕最后行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;num + G&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;跳转到指定的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[ctrl] + f&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;屏幕『向下』移动一页，相当于 [Page Down]按键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[ctrl] + b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;屏幕『向上』移动一页，相当于 [Page Up] 按键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;r[w]&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将当前光标所在的字符替换为指定的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;~&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;该表当前光标所在字符的大小写转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;/word&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;?word&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向光标之上寻找一个字符串名称为 word 的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;n&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据搜索结果继续向下查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据搜索结果继续向上查询&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;插入模式(Inset Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;esc&lt;/code&gt; 进入到“命令模式”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该模式下用于输入以及编辑内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底行模式(Last Line Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;esc&lt;/code&gt; 进入到“命令模式”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;底行模式又可以称之为“指令模式”，在这个模式下，可以通过输入制定来让“vi编辑器”完成特定的功能。&lt;br/&gt;| 命令 | 功能 |&lt;br/&gt;|:---|:---:|&lt;br/&gt;|:w|保存文件|&lt;br/&gt;|:q|退出vi编辑器|&lt;br/&gt;|:wq|退出并保存|&lt;br/&gt;|:q!|退出vi编辑器，并不保存内容|&lt;br/&gt;|:set nu|显示行号|&lt;br/&gt;|:set nonu|隐藏行号|&lt;/p&gt;
&lt;h3 id=&quot;常用快捷键&quot;&gt;常用快捷键&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ctr+c  #终止当前命令
ctr+l  ##清屏  相当于 clear
ctr+a  #光标移到行首
ctr+e  #光标移到行尾
ctr+u  #把光标所在位置删除到行首
ctr+d  #删除光标前面的字符，一旦内容全部删除再按则会退出窗口。
ctr+h  #删除光标后面的字符，&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境变量-1&quot;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;与 &lt;code&gt;window&lt;/code&gt; 相同 &lt;code&gt;linux&lt;/code&gt; 中通过命令行修改或者是创建的环境变量只对当前的命令窗口有效，关闭窗口则会消失。&lt;br/&gt;如果想在 &lt;code&gt;linux&lt;/code&gt; 设置永久的环境变量，如果是系统级的环境变量请使用“vi编辑器”编辑 &lt;code&gt;/etc/profile&lt;/code&gt; 文件，如果是用户级别的环境变量，则进入到对应的用户目录修改 &lt;code&gt;.profile&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h4 id=&quot;设置环境变量-1&quot;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;命令可以查看系统级以及用户级的所有环境变量，使用 &lt;code&gt;env&lt;/code&gt;则查看当前用户的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set #查看所有环境变量
env #查看与当前用户有关的环境变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想设置一个环境变量，则使用 &lt;code&gt;export&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export key=value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，如果想修改某个环境变量的值，再次执行上面的命令即可。&lt;/p&gt;
&lt;h4 id=&quot;使用环境变量-1&quot;&gt;使用环境变量&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt;中引用一个环境变量，则为环境变量附加 &lt;code&gt;$&lt;/code&gt;符，其形式如：&lt;code&gt;$env&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$PATH   #引用环境变量PATH。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;环境变量如果存在多个值，则通过使用 &lt;code&gt;:&lt;/code&gt; 冒号进行分割。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export app=/home/app
export PATH=$PATH:%app&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它常用命令&quot;&gt;其它常用命令&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;clear&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;#清除屏幕。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#显示消息，或将命令回显打开或关闭。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;whoami&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;#返回当前登录用户名。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;passwd&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;#允许当前登录的用户更改其密码。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;file&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#尝试判断指定文件的类型。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;exit&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#退出命令行工具&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;users&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;#显示当前登录系统地用户&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;last&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#查看用户的登录日志&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;cammand&lt;/span&gt; --help  &lt;span class=&quot;co&quot;&gt;#查看相关命令的帮助文档。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ping&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#查看网络状态&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;如果觉得本文对您有帮助或者您心情好~可以支付宝(左)或微信(右)支持一下，就当给作者赞助杯咖啡钱了&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191659177-1498594594.png&quot; alt=&quot;&quot;/&gt; ~~：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191025865-224171467.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191032912-1350098481.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 14 Feb 2018 14:19:00 +0000</pubDate>
<dc:creator>卷柏的花期</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HCJJ/p/8448964.html</dc:identifier>
</item>
<item>
<title>MessagePack简析 - 孙振超</title>
<link>http://www.cnblogs.com/sunzhenchao/p/8448929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunzhenchao/p/8448929.html</guid>
<description>&lt;p data-type=&quot;p&quot;&gt;先看官方的定义：MessagePack是一种高效的二进制序列化格式。它允许您像JSON一样在多个语言之间交换数据。但是，它更快并且更小。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;从官方定义中，可以有如下的结论：&lt;/p&gt;
&lt;ol start=&quot;1&quot; data-type=&quot;unordered-list&quot; readability=&quot;0.5&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;MessagePack是一个二进制序列化格式，因而它序列化的结果可以在多个语言间进行数据的交换。&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;从性能上讲，它要比json的序列化格式要好。&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;从结果大小上讲，它要比json的序列化结果要小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;但是官方并没有提MessagePack和google pb的对比，实际上从空间和时间两个方面对比，pb均要优于MessagePack，但pb相对MessagePack 的缺点是支持的语言种类比较少，需要编写专门的 .proto文件，使用上没有MessagePack方便。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;


&lt;h2 id=&quot;2.1-type-system&quot; data-type=&quot;h&quot;&gt;2.1 type system&lt;/h2&gt;
&lt;p&gt;类型体系是MessagePack的基础，也是MessagePack在序列化后比json占用空间小的关键。当前包含的type有如下几类：&lt;/p&gt;
&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;3.5&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Integer represents an integer&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;
&lt;p&gt;Nil represents nil&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Boolean represents true or false&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Float represents a IEEE 754 double precision floating point number including NaN and Infinity&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;
&lt;p&gt;Raw&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Array represents a sequence of objects&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Map represents key-value pairs of objects&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;Extension represents a tuple of type information and a byte array where type information is an integer whose meaning is defined by applications or MessagePack specification&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个类型体系将我们在代码开发中用到的数据格式进行了映射，并且通过Extension这个类型给使用者留出了自由扩充的空间，但由于表示形式的限制，当前Extension最多有127个。&lt;/p&gt;

&lt;p&gt;每一种类型能够表示的范围可以查看MessagePack规范中的Limitation部分和Extension types部分。&lt;/p&gt;

&lt;h2 id=&quot;2.2-formats&quot; data-type=&quot;h&quot;&gt;2.2 formats&lt;/h2&gt;
&lt;p&gt;在MessagePack中一个value的组成格式是这样的：类型[长度][data]。下面列出几个示例，详细完整的描述请看附录中的MessagePack规范。&lt;/p&gt;

&lt;h3 id=&quot;2.2.1常量型&quot; data-type=&quot;h&quot;&gt;2.2.1常量型&lt;/h3&gt;
&lt;p&gt;比如对于null、true、false这三个值，在MessagePack会被固定的映射为如下的值。&lt;/p&gt;
&lt;div id=&quot;doc-sheets-0&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;format name&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;first byte (in binary)&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;first byte (in hex)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000000&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000010&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000011&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;2.2.2-int型（包含有符号整数和无符号整数）&quot; data-type=&quot;h&quot;&gt;2.2.2 int型（包含有符号整数和无符号整数）&lt;/h3&gt;

&lt;p&gt;示例如下&lt;/p&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;3&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xcc表示当前的值的类型是无符号整数并且长度不超过8个bit，具体的值内容需要通过后续8个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xcd表示当前的值的类型是无符号整数并且长度不超过16个bit，具体的值内容需要通过后续16个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xd0表示当前的值的类型是有符号整数并且长度不超过8个bit，具体的值内容需要通过后续8个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xd1表示当前的值的类型是有符号整数并且长度不超过16个bit，具体的值内容需要通过后续16个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div data-type=&quot;p&quot; readability=&quot;7.5&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
uint 8 stores a 8-bit unsigned integer  
+--------+--------+
|  0xcc  |ZZZZZZZZ|
+--------+--------+

uint 16 stores a 16-bit big-endian unsigned integer
+--------+--------+--------+
|  0xcd  |ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+

int 8 stores a 8-bit signed integer
+--------+--------+
|  0xd0  |ZZZZZZZZ|
+--------+--------+

int 16 stores a 16-bit big-endian signed integer
+--------+--------+--------+
|  0xd1  |ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;2.2.3-字符串&quot; data-type=&quot;h&quot;&gt;2.2.3 字符串&lt;/h3&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xd9表示当前的值的类型是字符串并且长度不超过(2^8)-1个bytes ，具体的长度需要通过后续8个bit位的内容来计算，字符串的具体内容是后续长度的byte所表示的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xda表示当前的值的类型是字符串并且长度不超过(2^16)-1个bytes ，具体的长度需要通过后续16个bit位的内容来计算，字符串的具体内容是后续长度的byte所表示的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
str 8 stores a byte array whose length is upto (2^8)-1 bytes:
+--------+--------+========+
|  0xd9  |YYYYYYYY|  data  |
+--------+--------+========+

str 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
+--------+--------+--------+========+
 
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;2.2.4-数组&quot; data-type=&quot;h&quot;&gt;2.2.4 数组&lt;/h3&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xdc表示当前的值的类型是数组并且长度不超过(2^16)-1个元素 ，具体的长度需要通过后续16个bit位（两个byte）的内容来计算，计算出来的值就是数组元素的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xdd表示当前的值的类型是数组并且长度不超过(2^32)-1个元素 ，具体的长度需要通过后续32个bit位（4个byte）的内容来计算，计算出来的值就是数组元素的个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
array 16 stores an array whose length is upto (2^16)-1 elements:
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+

array 32 stores an array whose length is upto (2^32)-1 elements:
+--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdd  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|    N objects    |
+--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;2.2.5-小结&quot; data-type=&quot;h&quot;&gt;2.2.5 小结&lt;/h3&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/41821ead-faea-4a48-8adf-77a9178f7ff3/2018/png/ee3e9ba0-2d43-4c21-853e-dc9beebc03c7.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/41821ead-faea-4a48-8adf-77a9178f7ff3/2018/png/ee3e9ba0-2d43-4c21-853e-dc9beebc03c7.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a95fb844-4e4d-410b-843f-6c8098539d65/2018/png/1976f29a-b8db-4d8e-b620-ccfc823e643d.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a95fb844-4e4d-410b-843f-6c8098539d65/2018/png/1976f29a-b8db-4d8e-b620-ccfc823e643d.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;2.3-serialization：type-to-format-conversion&quot; data-type=&quot;h&quot;&gt;2.3 Serialization：type to format conversion&lt;/h2&gt;

&lt;div id=&quot;doc-sheets-1&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;source types&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;output format&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;Integer&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;int format family (positive fixint, negative fixint, int 8/16/32/64 or uint 8/16/32/64)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Boolean&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;bool format family (false or true)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Float&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;float format family (float 32/64)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;str format family (fixstr or str 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Binary&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;bin format family (bin 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Array&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;array format family (fixarray or array 16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;map format family (fixmap or map 16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Extension&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;ext format family (fixext or ext 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;If an object can be represented in multiple possible output formats, serializers SHOULD use the format which represents the data in the smallest number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;2.4-deserialization:-format-to-type-conversion&quot; data-type=&quot;h&quot;&gt;2.4 Deserialization: format to type conversion&lt;/h2&gt;
&lt;div id=&quot;doc-sheets-2&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;source formats&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;output type&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;positive fixint, negative fixint, int 8/16/32/64 and uint 8/16/32/64&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Integer&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Nil&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;false and true&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Boolean&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;float 32/64&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Float&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixstr and str 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;bin 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Binary&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixarray and array 16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Array&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixmap map 16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixext and ext 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Extension&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;h2 id=&quot;3.1-直观对比&quot; data-type=&quot;h&quot;&gt;3.1 直观对比&lt;/h2&gt;
&lt;p&gt;可以通过下图的两张图简单进行下对比，第一张图是同一个数据类型的内容用json和messagepack序列化的结果。&lt;/p&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/29a613cd-22c3-4df1-858f-abbc8aee78e0/2018/png/9feb3876-44ec-491b-8046-0240cdc7b08b.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/29a613cd-22c3-4df1-858f-abbc8aee78e0/2018/png/9feb3876-44ec-491b-8046-0240cdc7b08b.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;


&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a9d71806-1cfe-49da-885f-a320ca76e235/2018/png/a9a38832-393e-467e-8561-56c015e2655b.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a9d71806-1cfe-49da-885f-a320ca76e235/2018/png/a9a38832-393e-467e-8561-56c015e2655b.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从第二张图可以明显看到messagepack要比json占用的空间更少。&lt;/p&gt;

&lt;h2 id=&quot;3.2-序列化结果只有value且value进行了专属映射&quot; data-type=&quot;h&quot;&gt;3.2 序列化结果只有value且value进行了专属映射&lt;/h2&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a67881d3-38db-4ff7-8472-4354150fffd7/2018/png/a31f7b74-5ae2-4417-88d2-de9eb458b9f1.png&quot; data-width=&quot;615&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a67881d3-38db-4ff7-8472-4354150fffd7/2018/png/a31f7b74-5ae2-4417-88d2-de9eb458b9f1.png&quot; alt=&quot;&quot; width=&quot;615&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这张图是MessagePack官网上的，用来进行json和MessagePack序列化结果的对比，实际情况是否确实如此呢？&lt;/p&gt;
&lt;p&gt;我本地使用的msgpack-0.6.12版本。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MessagePackSerializationCompareJson {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public int schema;
        
        public  String toString() {
            return &quot;compact:&quot;+compact+&quot;;schema:&quot;+schema;
        }

    }
    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
      //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.schema=0;
        
      //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);
        System.out.println(&quot;msgpack result length:&quot;+bytes.length);
        
        //利用json进行序列化
        String jsonResult = JSONObject.toJSON(src).toString();
        System.out.println(&quot;json result length:&quot;+jsonResult.getBytes().length);
        
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
json result length:27
msgpack result length:3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;json序列化的结果是27，和官网图片中的结果相同。但MessagePack的序列化结果是3，要比官网中的数字小很多。&lt;/p&gt;
&lt;p&gt;按照上面图片的解释应当是：&lt;/p&gt;
&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第一个byte是82，表示序列化后的结果有两个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第二个byte是c3，表示第一个元素的值是true&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第三个byte是00，表示第二个元素的值是0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了验证我们的推测，我们可以在MyMessage类中再添加一个boolean类型的属性，但不给这个属性赋值，按照java的规范，这个属性的值就是false，按照MessagePack的规范，就会被转为一个byte的c2，这样msgpack序列化后的长度值就是4.  而json序列化的增加值要增加不少，是属性名称的长度+5（false的长度）+4（要增加两个双引号，一个逗号，一个冒号），如果属性名称长度是4，则一共会增加13个byte，总长度就是40.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MessagePackSerializationCompareJson {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public int schema;
        public boolean link;
        
        
        public  String toString() {
            return &quot;compact:&quot;+compact+&quot;;schema:&quot;+schema+&quot;;link:&quot;+link;
        }

    }
    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
      //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.schema=0;
        
      //利用json进行序列化
        String jsonResult = JSONObject.toJSON(src).toString();
        System.out.println(&quot;json result length:&quot;+jsonResult.getBytes().length);
        
      //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);
        System.out.println(&quot;msgpack result length:&quot;+bytes.length);
        
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot; language-java&quot; data-syntax=&quot;java&quot;&gt;
 
&lt;/pre&gt;
&lt;p&gt;上面代码的执行的结果也符合猜测：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
json result length:40
msgpack result length:4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个数字上看，MessagePack明显优于json，特别是在属性多的情况下差距会更大。即使json中把key去掉，序列化后的结果也要比MessagePack占用的空间大。&lt;/p&gt;

&lt;h2 id=&quot;3.2-序列化对象的属性顺序不能变动&quot; data-type=&quot;h&quot;&gt;3.2 序列化对象的属性顺序不能变动&lt;/h2&gt;
&lt;p&gt;3.1分析了MessagePack序列化的结果中只包含了value，而不包含key。因而在进行反序列化需要保证类中属性的顺序必须保证完全一致，否则就会出错：&lt;/p&gt;
&lt;p&gt;如果两个属性的类型一致，可以反序列化，但是值发生错乱。&lt;/p&gt;
&lt;p&gt;如果两个属性的类型不一致，会抛出类型不匹配异常。&lt;/p&gt;

&lt;h3 id=&quot;3.2.1-顺序不同，类型相同&quot; data-type=&quot;h&quot;&gt;3.2.1 顺序不同，类型相同&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SimpleMessagePackPractice {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public boolean link;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    @Message // Annotation
    public static class MyMessage2 {
        // public fields are serialized.
        public boolean link;
        public boolean compact;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {

        //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.link = false;

        //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);

        //利用MessagePack进行反序列化
        MyMessage2 dst = msgpack.read(bytes, MyMessage2.class);
        System.out.println(&quot;msgpack 原始数据:&quot; + src);
        System.out.println(&quot;msgpack 反序列化:&quot; + dst);
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的执行结果如下：&lt;/p&gt;
&lt;pre class=&quot; language-plain&quot; data-syntax=&quot;plain&quot;&gt;
&lt;code class=&quot; language-plain&quot;&gt;msgpack 原始数据:link:false;compact:true
msgpack 反序列化:link:true;compact:false&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;3.2.1-顺序不同，类型不同&quot; data-type=&quot;h&quot;&gt;3.2.1 顺序不同，类型不同&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SimpleMessagePackPractice {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public String link;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    @Message // Annotation
    public static class MyMessage2 {
        // public fields are serialized.
        public String link;
        public boolean compact;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {

        //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.link = &quot;www.baidu.com&quot;;

        //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);

        //利用MessagePack进行反序列化
        MyMessage2 dst = msgpack.read(bytes, MyMessage2.class);
        System.out.println(&quot;msgpack 原始数据:&quot; + src);
        System.out.println(&quot;msgpack 反序列化:&quot; + dst);
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot; language-java&quot; data-syntax=&quot;java&quot;&gt;
 
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Exception in thread &quot;main&quot; org.msgpack.MessageTypeException: Expected raw value, but got boolean
        at org.msgpack.unpacker.Accept.acceptBoolean(Accept.java:33)
        at org.msgpack.unpacker.MessagePackUnpacker.readOneWithoutStackLarge(MessagePackUnpacker.java:154)
        at org.msgpack.unpacker.MessagePackUnpacker.readOneWithoutStack(MessagePackUnpacker.java:139)
        at org.msgpack.unpacker.MessagePackUnpacker.readOne(MessagePackUnpacker.java:73)
        at org.msgpack.unpacker.MessagePackUnpacker.readString(MessagePackUnpacker.java:502)
        at org.msgpack.template.StringTemplate.read(StringTemplate.java:46)
        at org.msgpack.template.StringTemplate.read(StringTemplate.java:25)
        at org.msgpack.template.AbstractTemplate.read(AbstractTemplate.java:31)
        at com.my.msgpack.SimpleMessagePackPractice$MyMessage2_$$_Template_1305193908_1.read(SimpleMessagePackPractice$MyMessage2_$$_Template_1305193908_1.java)
        at org.msgpack.template.AbstractTemplate.read(AbstractTemplate.java:31)
        at org.msgpack.MessagePack.read(MessagePack.java:388)
        at org.msgpack.MessagePack.read(MessagePack.java:371)
        at com.my.msgpack.SimpleMessagePackPractice.main(SimpleMessagePackPractice.java:61)
&lt;/pre&gt;&lt;/div&gt;



&lt;ol start=&quot;1&quot; data-type=&quot;unordered-list&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-0.56521739130435&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 14 Feb 2018 13:31:00 +0000</pubDate>
<dc:creator>孙振超</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunzhenchao/p/8448929.html</dc:identifier>
</item>
<item>
<title>AJAX面试题都在这里 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8448921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8448921.html</guid>
<description>&lt;h2 id=&quot;什么是ajax为什么要使用ajax&quot;&gt;什么是AJAX，为什么要使用Ajax&lt;/h2&gt;
&lt;p&gt;AJAX是“Asynchronous JavaScript and XML”的缩写。他是指一种&lt;strong&gt;创建交互式网页应用的网页开发技术&lt;/strong&gt;。、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;ajax应用和传统web应用有什么不同&quot;&gt;AJAX应用和传统Web应用有什么不同？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;AJAX应用和传统Web应用有什么不同？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;传统的web前端与后端的交互中，浏览器直接访问Tomcat的Servlet来获取数据。&lt;strong&gt;Servlet通过转发把数据发送给浏览器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当我们使用AJAX之后&lt;/strong&gt;，浏览器是先把请求发送到XMLHttpRequest异步对象之中，异步对象对请求进行封装，然后再与发送给服务器。&lt;strong&gt;服务器并不是以转发的方式响应，而是以流的方式把数据返回给浏览器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;XMLHttpRequest异步对象会不停监听服务器状态的变化，得到服务器返回的数据，就写到浏览器上【因为不是转发的方式，所以是无刷新就能够获取服务器端的数据】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170517180715420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;请介绍一下xmlhttprequest对象&quot;&gt;请介绍一下XMLhttprequest对象&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请介绍一下XMLhttprequest对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，&lt;strong&gt;XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍一下xmlhttprequest对象的常用方法和属性&quot;&gt;介绍一下XMLHttpRequest对象的常用方法和属性&lt;/h2&gt;
&lt;h3 id=&quot;方法&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;open()&lt;/strong&gt;(&lt;strong&gt;String method,String url,boolean asynch&lt;/strong&gt;,String username,String password)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;send(content)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setRequestHeader(String header,String value)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;getAllResponseHeaders()&lt;/li&gt;
&lt;li&gt;getResponseHeader(String header)&lt;/li&gt;
&lt;li&gt;abort()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;常用的方法就是黑色粗体的前三个&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;open()：该方法创建http请求&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一个参数是指定提交方式(post、get)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二个参数是指定要提交的地址是哪&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三个参数是指定是异步还是同步(true表示异步，false表示同步)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第四和第五参数在http认证的时候会用到。是可选的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setRequestHeader(String header,String value)：设置消息头（使用post方式才会使用到，get方法并不需要调用该方法）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;send(content)：发送请求给服务器&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如果是get方式，并不需要填写参数，或填写null&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果是post方式，把要提交的参数写上去&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;onreadystatechange：请求状态改变的事件触发器（readyState变化时会调用此方法），一般用于指定回调函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readyState：请求状态readyState一改变，回调函数被调用，它有5个状态&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;0：未初始化&lt;/li&gt;
&lt;li&gt;1：open方法成功调用以后&lt;/li&gt;
&lt;li&gt;2：服务器已经应答客户端的请求&lt;/li&gt;
&lt;li&gt;3：交互中。Http头信息已经接收，响应数据尚未接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4：完成。数据接收完成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170517181407343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;responseText：服务器返回的文本内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;responseXML：服务器返回的兼容DOM的XML内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;status：服务器返回的状态码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;statusText：服务器返回状态码的文本信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面有两个地方都提及了回调函数，回调函数是什么？？&lt;/p&gt;
&lt;p&gt;回调函数就是&lt;strong&gt;接收服务器返回的内容！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170517181326031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ajax的实现流程是怎样的&quot;&gt;Ajax的实现流程是怎样的？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ajax的实现流程是怎样的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.&lt;/li&gt;
&lt;li&gt;(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.&lt;/li&gt;
&lt;li&gt;(3)设置响应HTTP请求状态变化的函数.&lt;/li&gt;
&lt;li&gt;(4)发送HTTP请求.&lt;/li&gt;
&lt;li&gt;(5)获取异步调用返回的数据.&lt;/li&gt;
&lt;li&gt;(6)使用JavaScript和DOM实现局部刷新.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;


    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; httpRequest&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;checkUsername&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;XMLHttpRequest&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

                &lt;span class=&quot;co&quot;&gt;//在IE6以上的版本以及其他内核的浏览器(Mozilla)等&lt;/span&gt;
                httpRequest &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;XMLHttpRequest&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ActiveXObject&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

                &lt;span class=&quot;co&quot;&gt;//在IE6以下的版本&lt;/span&gt;
                httpRequest &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ActiveXObject&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;


            &lt;span class=&quot;co&quot;&gt;//创建http请求&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Servlet1&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//因为我使用的是post方式，所以需要设置消息头&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setRequestHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Content-type&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;application/x-www-form-urlencoded&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//指定回调函数&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; response22&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//得到文本框的数据&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//发送http请求，把要检测的用户名传递进去&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username=&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;response22&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//判断请求状态码是否是4【数据接收完成】&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readyState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

                &lt;span class=&quot;co&quot;&gt;//再判断状态码是否为200【200是成功的】&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

                    &lt;span class=&quot;co&quot;&gt;//得到服务端返回的文本数据&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;httpRequest&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;responseText&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

                    &lt;span class=&quot;co&quot;&gt;//把服务端返回的数据写在div上&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;result&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;div&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; text&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;ajax请求总共有多少种callback&quot;&gt;AJAX请求总共有多少种CALLBACK&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;AJAX请求总共有多少种CALLBACK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ajax请求总共有&lt;strong&gt;八种&lt;/strong&gt;Callback&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onSuccess&lt;/li&gt;
&lt;li&gt;onFailure&lt;/li&gt;
&lt;li&gt;onUninitialized&lt;/li&gt;
&lt;li&gt;onLoading&lt;/li&gt;
&lt;li&gt;onLoaded&lt;/li&gt;
&lt;li&gt;onInteractive&lt;/li&gt;
&lt;li&gt;onComplete&lt;/li&gt;
&lt;li&gt;onException&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;xmlhttprequest对象在ie和firefox中创建方式有没有不同&quot;&gt;XMLHttpRequest对象在IE和Firefox中创建方式有没有不同。&lt;/h2&gt;
&lt;p&gt;有，IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;当然了，我们一般使用jquery封装好的ajax方法，那就没有那么麻烦了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ajax有哪些有点和缺点&quot;&gt;AJAX有哪些有点和缺点？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;AJAX有哪些有点和缺点？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、最大的一点是页面无刷新，用户的体验非常好。&lt;/li&gt;
&lt;li&gt;2、使用异步方式与服务器通信，具有更加迅速的响应能力。&lt;/li&gt;
&lt;li&gt;3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。&lt;/li&gt;
&lt;li&gt;4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、ajax不支持浏览器back按钮。&lt;/li&gt;
&lt;li&gt;2、安全问题 AJAX暴露了与服务器交互的细节。&lt;/li&gt;
&lt;li&gt;3、对搜索引擎的支持比较弱。&lt;/li&gt;
&lt;li&gt;4、破坏了程序的异常机制。&lt;/li&gt;
&lt;li&gt;5、不容易调试。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;请解释一下-javascript-的同源策略&quot;&gt;请解释一下 JavaScript 的同源策略。&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请解释一下 JavaScript 的同源策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，&lt;strong&gt;同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;阐述一下异步加载js&quot;&gt;阐述一下异步加载JS。&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阐述一下异步加载JS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;异步加载的方案： 动态插入 script 标签&lt;/li&gt;
&lt;li&gt;通过 ajax 去获取 js 代码，然后通过 eval 执行&lt;/li&gt;
&lt;li&gt;script 标签上添加 defer 或者 async 属性&lt;/li&gt;
&lt;li&gt;创建并插入 iframe，让它异步执行 js&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;如何解决跨域问题&quot;&gt;如何解决跨域问题?&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如何解决跨域问题?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，&lt;strong&gt;【JSONP】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在后端上配置可跨域&lt;strong&gt;【CORS方式】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;前端ajax请求的是本地接口，本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端&lt;strong&gt;【代理方式】&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AJAX跨域的问题可参考：&lt;/p&gt;
&lt;h2 id=&quot;ajax-解决浏览器缓存问题&quot;&gt;Ajax 解决浏览器缓存问题？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ajax 解决浏览器缓存问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。&lt;/li&gt;
&lt;li&gt;2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。&lt;/li&gt;
&lt;li&gt;3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。&lt;/li&gt;
&lt;li&gt;4、在URL后面加上时间戳：&quot;nowtime=&quot; + new Date().getTime();。&lt;/li&gt;
&lt;li&gt;5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。&lt;strong&gt;习惯在微信看技术文章的同学，可以关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 14 Feb 2018 13:18:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8448921.html</dc:identifier>
</item>
<item>
<title>goroutine - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8448903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8448903.html</guid>
<description>&lt;h2 id=&quot;进程和线程&quot;&gt;进程和线程&lt;/h2&gt;
&lt;p&gt;进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。&lt;/p&gt;
&lt;p&gt;线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。&lt;/p&gt;
&lt;p&gt;一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行.&lt;/p&gt;
&lt;h2 id=&quot;并发和并行&quot;&gt;并发和并行&lt;/h2&gt;
&lt;p&gt;多线程程序在一个核的cpu上运行，就是并发&lt;/p&gt;
&lt;p&gt;多线程程序在多个核的cpu上运行，就是并行&lt;/p&gt;
&lt;h2 id=&quot;协程和线程&quot;&gt;协程和线程&lt;/h2&gt;
&lt;p&gt;协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的&lt;/p&gt;
&lt;p&gt;线程：一个线程上可以跑多个协程，协程是轻量级的线程。&lt;/p&gt;
&lt;h2 id=&quot;goroutine调度模型&quot;&gt;goroutine调度模型&lt;/h2&gt;
&lt;p&gt;简单的例子&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; test() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      fmt.Println(i)
      time.Sleep(time.Second*&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
      i++
   }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; test()
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;i' running in main&quot;&lt;/span&gt;)
      time.Sleep(time.Second)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;设置golang运行的cpu核数&quot;&gt;设置golang运行的cpu核数&lt;/h2&gt;
&lt;p&gt;go1.8版本以上默认设置了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;runtime&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    num := runtime.NumCPU()
    runtime.GOMAXPROCS(num)
    fmt.Println(num)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;不同goroutine之间通讯&quot;&gt;不同goroutine之间通讯&lt;/h2&gt;
&lt;p&gt;全局变量和锁同步&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;sync&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; (
   m = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;dt&quot;&gt;uint64&lt;/span&gt;)
   lock sync.Mutex
)

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; task &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
   n &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; calc(t *task) {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; sum &lt;span class=&quot;dt&quot;&gt;uint64&lt;/span&gt;
   sum = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i:=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;i&amp;lt;t.n;i++{
      sum *= &lt;span class=&quot;dt&quot;&gt;uint64&lt;/span&gt;(i)
   }
   fmt.Println(t.n,sum)
   lock.Lock()
   m[t.n] = sum
   lock.Unlock()
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i :=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;;i++{
      t := &amp;amp;task{n:i}
      &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; calc(t)
   }
   time.Sleep(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; * time.Second)
   &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   lock.Lock()&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   for k,v := range m{&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      fmt.Printf(&quot;%d!=%v\n&quot;,k,v)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   lock.Unlock()*/&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Channel&lt;/p&gt;
&lt;h2 id=&quot;channel&quot;&gt;channel&lt;/h2&gt;
&lt;p&gt;a. 类似unix中管道（pipe）&lt;/p&gt;
&lt;p&gt;b. 先进先出&lt;/p&gt;
&lt;p&gt;c. 线程安全，多个goroutine同时访问，不需要加锁&lt;/p&gt;
&lt;p&gt;d. channel是有类型的，一个整数的channel只能存放整数&lt;/p&gt;
&lt;p&gt;var 变量名 chan 类型&lt;/p&gt;
&lt;p&gt;var test chan int&lt;/p&gt;
&lt;p&gt;var test chan string&lt;/p&gt;
&lt;p&gt;var test chan map[string]string&lt;/p&gt;
&lt;p&gt;var test chan stu&lt;/p&gt;
&lt;p&gt;var test chan *stu&lt;/p&gt;
&lt;h2 id=&quot;channel初始化&quot;&gt;channel初始化&lt;/h2&gt;
&lt;p&gt;使用make进行初始化，比如：&lt;/p&gt;
&lt;p&gt;var test chan int&lt;/p&gt;
&lt;p&gt;test = make(chan int, 10)&lt;/p&gt;
&lt;p&gt;var test chan string&lt;/p&gt;
&lt;p&gt;test = make(chan string, 10)&lt;/p&gt;
&lt;p&gt;从channel读取数据&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; testChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
testChan = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
a = &amp;lt;- testChan&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向channel写入数据&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; testChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
testChan = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;  = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
testChan &amp;lt;- a&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;goroutine和channel相结合&quot;&gt;goroutine和channel相结合&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; write(ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;; i++ {
      ch &amp;lt;- i
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;put data:&quot;&lt;/span&gt;, i)
   }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; read(ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
      b = &amp;lt;-ch
      fmt.Println(b)
      time.Sleep(time.Second)
   }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   intChan := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;//testChan是带缓冲区的chan，一次可以放10个元素&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; write(intChan)
   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; read(intChan)&lt;span class=&quot;co&quot;&gt;//不读的话会引发阻塞&lt;/span&gt;
   time.Sleep(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; * time.Second)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;chan之间的同步&quot;&gt;chan之间的同步&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; send(ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, exitChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{}) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++ {
        ch &amp;lt;- i
    }
    &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(ch)
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{}
    exitChan &amp;lt;- a
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; recv(ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, exitChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{}) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
        v, ok := &amp;lt;-ch
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; !ok {
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
        }
        fmt.Println(v)
    }
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{}
    exitChan &amp;lt;- a
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
    ch = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
    exitChan := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{}, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)

    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; send(ch, exitChan)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; recv(ch, exitChan)

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; total = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; _ = &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; exitChan {
        total++
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; total == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)
&lt;span class=&quot;co&quot;&gt;//计算1000以内的素数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; calc(taskChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, resChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, exitChan &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;) {
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; v := &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; taskChan {
      flag := &lt;span class=&quot;ot&quot;&gt;true&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;; i &amp;lt; v; i++ {
         &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; v%i == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; {
            flag = &lt;span class=&quot;ot&quot;&gt;false&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
         }
      }
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; flag {
         resChan &amp;lt;- v
      }
   }
   fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;exit&quot;&lt;/span&gt;)
   exitChan &amp;lt;- &lt;span class=&quot;ot&quot;&gt;true&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   intChan := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
   resultChan := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
   exitChan := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)

   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() {
      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;; i++ {
         intChan &amp;lt;- i
      }
      &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(intChan)
   }()

   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;; i++ {
      &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; calc(intChan, resultChan, exitChan)
   }

   &lt;span class=&quot;co&quot;&gt;//等待所有计算的goroutine全部退出&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() {
      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;; i++ {
         &amp;lt;-exitChan
         fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;wait goroute &quot;&lt;/span&gt;, i, &lt;span class=&quot;st&quot;&gt;&quot; exited&quot;&lt;/span&gt;)
      }
      &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(resultChan)
   }()

   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; v := &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; resultChan {
      &lt;span class=&quot;co&quot;&gt;//fmt.Println(v)&lt;/span&gt;
      _ = v
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;chan的关闭&quot;&gt;chan的关闭&lt;/h2&gt;
&lt;p&gt;1.使用内置函数close进行关闭，chan关闭之后，for range遍历chan中已经存在的元素后结束&lt;/p&gt;
&lt;p&gt;2.使用内置函数close进行关闭，chan关闭之后，没有使用for range的写法需要使用，v, ok := &amp;lt;- ch进行判断chan是否关闭&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   ch = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++ {
      ch &amp;lt;- i
   }

   &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(ch)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
      b,ok := &amp;lt;-ch
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ok == &lt;span class=&quot;ot&quot;&gt;false&lt;/span&gt; {
         fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;chan is close&quot;&lt;/span&gt;)
         &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
      }
      fmt.Println(b) &lt;span class=&quot;co&quot;&gt;//谨防死循环&lt;/span&gt;
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;for-range遍历chan&quot;&gt;for range遍历chan&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   ch = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;; i++ {
      ch &amp;lt;- i
   }

   &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(ch)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; v := &lt;span class=&quot;kw&quot;&gt;range&lt;/span&gt; ch {
      fmt.Println(v)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;chan的只读和只写&quot;&gt;chan的只读和只写&lt;/h2&gt;
&lt;p&gt;a. 只读chan的声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Var 变量的名字 &amp;lt;-chan int
Var readChan &amp;lt;- chan int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b. 只写chan的声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Var 变量的名字 chan&amp;lt;- int
Var writeChan chan&amp;lt;- int&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对chan进行select操作&quot;&gt;对chan进行select操作&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; {
     &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; u := &amp;lt;- ch1:
     &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e := &amp;lt;- ch2:
     &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:   
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是死锁了，阻塞了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   ch = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i :=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;i++{
      ch &amp;lt;- i
   }
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
      b = &amp;lt;-ch
      fmt.Println(b)
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;select解决阻塞&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;co&quot;&gt;//@Time  : 2018/2/1 22:14&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//@Author: ningxin&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main()  {
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   ch = &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i :=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;i++{
      ch &amp;lt;- i
   }
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;{
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; v:= &amp;lt;-ch:
         fmt.Println(v)
      &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
         fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;get data timeout&quot;&lt;/span&gt;)
         time.Sleep(time.Second)
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;定时器的使用&quot;&gt;定时器的使用&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)
&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; queryDb(ch &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {

    time.Sleep(time.Second)
    ch &amp;lt;- &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
}
&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    ch := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; queryDb(ch)
    t := time.NewTicker(time.Second)

    &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; v := &amp;lt;-ch:
        fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;result&quot;&lt;/span&gt;, v)
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &amp;lt;-t.C:
        fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;timeout&quot;&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超时控制&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;runtime&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   num := runtime.NumCPU()
   runtime.GOMAXPROCS(num - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;; i++ {
      &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() {
         &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
            t := time.NewTicker(time.Second)
            &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &amp;lt;-t.C:
               fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;timeout&quot;&lt;/span&gt;)
            }
            t.Stop()
         }
      }()
   }

   time.Sleep(time.Second * &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;goroutine中使用recover&quot;&gt;goroutine中使用recover&lt;/h2&gt;
&lt;p&gt;应用场景，如果某个goroutine panic了，而且这个goroutine里面没有捕获(recover)，那么整个进程就会挂掉。所以，好的习惯是每当go产生一个goroutine，就需要写下recover&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
   &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;runtime&quot;&lt;/span&gt;
   &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; test() {
   &lt;span class=&quot;kw&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() {
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; err := &lt;span class=&quot;fu&quot;&gt;recover&lt;/span&gt;(); err != &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt; {
         fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;panic:&quot;&lt;/span&gt;, err)
      }
   }()
   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; m &lt;span class=&quot;kw&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
   m[&lt;span class=&quot;st&quot;&gt;&quot;stu&quot;&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; calc() {
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {
      fmt.Println(&lt;span class=&quot;st&quot;&gt;&quot;i'm calc&quot;&lt;/span&gt;)
      time.Sleep(time.Second)
   }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
   num := runtime.NumCPU()
   runtime.GOMAXPROCS(num - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; test()
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;; i++ {
      &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; calc()
   }
   time.Sleep(time.Second * &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 14 Feb 2018 13:07:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8448903.html</dc:identifier>
</item>
<item>
<title>RESTful API - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/8448639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/8448639.html</guid>
<description>&lt;ul&gt;&lt;li&gt;REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“&lt;strong&gt;表征状态转移&lt;/strong&gt;”&lt;/li&gt;
&lt;li&gt;REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态&lt;/li&gt;
&lt;li&gt;所有的数据，不管是通过网络获取的还是操作数据库获得（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性&lt;/li&gt;
&lt;li&gt;对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：&lt;strong&gt;面向资源架构&lt;/strong&gt;（ROA：Resource Oriented Architecture）
&lt;ul&gt;&lt;li&gt;对互联网上的任意东西都视为资源，他认为一个url就是一个资源 比如：http://www.xxx.com/get_user/&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、什么是API？&lt;/p&gt;
&lt;p&gt;答：API就是接口，提供的url。接口有两个用途：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;- 为别人提供服务&lt;/li&gt;
&lt;li&gt;- 前后端分离，一个写vue，一个写后端，他们之间都是通过ajax请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。&lt;/p&gt;
&lt;p&gt;因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现&lt;a href=&quot;http://www.google.com.hk/search?q=API+first&quot; target=&quot;_blank&quot;&gt;&quot;API First&quot;&lt;/a&gt;的设计思想。&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot; target=&quot;_blank&quot;&gt;RESTful API&lt;/a&gt;是目前比较成熟的一套互联网应用程序的API设计理论。&lt;/p&gt;
&lt;p&gt;那么先来简单了解一下&lt;/p&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;1、协议&lt;/h2&gt;
&lt;p&gt;API与用户的通信协议，总是使用&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot; target=&quot;_blank&quot;&gt;HTTPs协议&lt;/a&gt;。&lt;/p&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;2、域名&lt;/h2&gt;
&lt;p&gt;有两种方式&lt;/p&gt;
&lt;p&gt;方式一： 尽量将API部署在专用域名（会存在跨域问题）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
https://api.example.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式二：如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
https://example.org/api/
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;3、版本（Versioning）&lt;/h2&gt;
&lt;p&gt;应该将API的版本号放入URL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://api.example.com/v1/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。&lt;a href=&quot;https://developer.github.com/v3/media/#request-specific-version&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;采用这种做法。&lt;/p&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;4、路径（Endpoint）&lt;/h2&gt;
&lt;p&gt;路径又称&quot;终点&quot;（endpoint），表示API的具体网址。&lt;/p&gt;
&lt;p&gt;在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的&quot;集合&quot;（collection），所以API中的名词也应该使用复数。&lt;/p&gt;
&lt;p&gt;举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;5、HTTP动词&lt;/h2&gt;
&lt;p&gt;对于资源的具体操作类型，由HTTP动词表示。&lt;/p&gt;
&lt;p&gt;常用的HTTP动词有下面五个（括号里是对应的SQL命令）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
GET（SELECT）：从服务器取出资源（一项或多项）。即获取数据
POST（CREATE）：在服务器新建一个资源。 即添加数据
PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。即更新数据
PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。即更新数据
DELETE（DELETE）：从服务器删除资源  。即删除数据
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有两个不常用的HTTP动词。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HEAD：获取资源的元数据。
OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一些例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;6、过滤信息（Filtering）&lt;/h2&gt;
&lt;p&gt;如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。&lt;/p&gt;
&lt;p&gt;下面是一些常见的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&amp;amp;per_page=100：指定第几页，以及每页的记录数。
?sortby=name&amp;amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。&lt;/p&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;7、状态码（status codes）&lt;/h2&gt;
&lt;p&gt;服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;状态码的完全列表参见&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;8、错误处理（Error handling）&lt;/h2&gt;
&lt;p&gt;如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{
    error: &quot;Invalid API key&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;9、返回结果&lt;/h2&gt;
&lt;p&gt;针对不同操作，服务器向用户返回的结果应该符合以下规范&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
GET /collection：返回资源对象的列表（数组）
GET /collection/resource：返回单个资源对象
POST /collection：返回新生成的资源对象
PUT /collection/resource：返回完整的资源对象
PATCH /collection/resource：返回完整的资源对象
DELETE /collection/resource：返回一个空文档
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;10、Hypermedia API  超媒体API&lt;/h2&gt;
&lt;p&gt;RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。&lt;/p&gt;
&lt;p&gt;比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;collection https://www.example.com/zoos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;表示这个API与当前网址的关系（collection关系，并给出该collection的网址）&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.example.com/zoos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;API路径&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List of zoos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;API的标题&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/vnd.yourformat+json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回类型&lt;/span&gt;
}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hypermedia API的设计被称为&lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot; target=&quot;_blank&quot;&gt;HATEOAS&lt;/a&gt;。Github的API就是这种设计，访问&lt;a href=&quot;https://api.github.com/&quot; target=&quot;_blank&quot;&gt;api.github.com&lt;/a&gt;会得到一个所有可用API的网址列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;current_user_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.github.com/user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorizations_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.github.com/authorizations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;//&lt;span&gt; ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到，如果想获取当前用户的信息，应该去访问&lt;a href=&quot;https://api.github.com/user&quot; target=&quot;_blank&quot;&gt;api.github.com/user&lt;/a&gt;，然后就得到了下面结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Requires authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;documentation_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://developer.github.com/v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;title&quot;&gt;方式一：FBV模式：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4b814e26-d1eb-4c33-8de8-7380a20e4cd2')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_4b814e26-d1eb-4c33-8de8-7380a20e4cd2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4b814e26-d1eb-4c33-8de8-7380a20e4cd2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4b814e26-d1eb-4c33-8de8-7380a20e4cd2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4b814e26-d1eb-4c33-8de8-7380a20e4cd2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url, include
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app02 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; path('hosts/',views.HostView.as_view()),&lt;/span&gt;
    url(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app02/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, include(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app02.urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;全局url&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8bf6597f-f15a-4515-b466-2810ba567e16')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_8bf6597f-f15a-4515-b466-2810ba567e16&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8bf6597f-f15a-4515-b466-2810ba567e16&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8bf6597f-f15a-4515-b466-2810ba567e16',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8bf6597f-f15a-4515-b466-2810ba567e16&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; app02 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url
urlpatterns &lt;/span&gt;=&lt;span&gt; [
    url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.users),
    url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^user/(\d+)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.user),

    url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.UsersView.as_view()),
    url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^user/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.UserView.as_view()),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app02/url&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8c95bc7a-b05c-452e-a6a2-0b8003644c2c')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_8c95bc7a-b05c-452e-a6a2-0b8003644c2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c95bc7a-b05c-452e-a6a2-0b8003644c2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8c95bc7a-b05c-452e-a6a2-0b8003644c2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c95bc7a-b05c-452e-a6a2-0b8003644c2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your views here.&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; users(request):
    response &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1000,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:None}  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;code用来表示状态，比如1000代表成功，1001代表&lt;/span&gt;
    response[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; [
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haiyan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:22&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haidong&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:10&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haixiyu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:11&lt;span&gt;},
    ]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps(response))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回多条数据&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; user(request,pk):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haiyan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:11}))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回一条数据&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; request.method ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1111}))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回一条数据&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; request.method ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; request.method ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;views&lt;/span&gt;&lt;/div&gt;
&lt;h2 class=&quot;secondtitle&quot;&gt;方式二：CBV模式&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7e0f2e3c-87fe-4406-bf57-f44f1d805cf5')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_7e0f2e3c-87fe-4406-bf57-f44f1d805cf5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7e0f2e3c-87fe-4406-bf57-f44f1d805cf5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7e0f2e3c-87fe-4406-bf57-f44f1d805cf5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7e0f2e3c-87fe-4406-bf57-f44f1d805cf5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;from&lt;/span&gt; app02 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url
 urlpatterns &lt;/span&gt;=&lt;span&gt; [
     url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.UsersView.as_view()),
     url(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^user/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.UserView.as_view()),
 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app02/urls&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f76cd705-e625-4686-8d8c-7abdb6f3eedc')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_f76cd705-e625-4686-8d8c-7abdb6f3eedc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f76cd705-e625-4686-8d8c-7abdb6f3eedc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f76cd705-e625-4686-8d8c-7abdb6f3eedc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f76cd705-e625-4686-8d8c-7abdb6f3eedc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; View
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsersView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        response &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1000,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None}
        response[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; [
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;haiyan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22&lt;span&gt;},
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;haidong&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 10&lt;span&gt;},
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;haixiyu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 11&lt;span&gt;},
        ]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps(response),stutas=200&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request,pk):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haiyan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:11}))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回一条数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self,request,pk):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1111}))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回一条数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; put(self,request,pk):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete(self,request,pk):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;views&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基于django实现的API许多功能都需要我们自己开发，这时候djangorestframework就给我们提供了方便，直接基于它来返回数据，总之原理都是一样的，就是给一个接口也就是url，让前端的人去请求这个url去获取数据，在页面上显示出来。这样也就达到了前后端分离的效果。下面我们来看看基于Django Rest Framework框架实现&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1、自定义认证规则 &lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;http://www.cnblogs.com/huchong/p/8448695.html&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAuthtication(BasicAuthentication):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        token &lt;/span&gt;= request.query_params.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意是没有GET的，用query_params表示&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; token == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zxxzzxzc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uuuuuu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;afsdsgdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回user，auth&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; APIException(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;认证错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(APIView):
    authentication_classes &lt;/span&gt;=&lt;span&gt; [MyAuthtication,]
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.user)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.auth)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、应用：&lt;/h2&gt;
&lt;p&gt;主要是做Token验证  url中as_view里面调用了dispatch方法。&lt;/p&gt;
&lt;p&gt;可以有两种方式&lt;/p&gt;
&lt;h3&gt;局部使用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('45b99cfd-edd4-4d93-8b8c-93bcda957c2d')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_45b99cfd-edd4-4d93-8b8c-93bcda957c2d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_45b99cfd-edd4-4d93-8b8c-93bcda957c2d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('45b99cfd-edd4-4d93-8b8c-93bcda957c2d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_45b99cfd-edd4-4d93-8b8c-93bcda957c2d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url
urlpatterns &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; django rest framework&lt;/span&gt;
    url(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^hosts/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.HostView.as_view()),
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^auth/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.AuthView.as_view()),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;urls.py&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ff3aa406-0247-4ef9-8103-05f059fb51aa')&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_ff3aa406-0247-4ef9-8103-05f059fb51aa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ff3aa406-0247-4ef9-8103-05f059fb51aa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ff3aa406-0247-4ef9-8103-05f059fb51aa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ff3aa406-0247-4ef9-8103-05f059fb51aa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your views here.&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Request
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.authentication &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SessionAuthentication
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.authentication &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BaseAuthentication, BasicAuthentication
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.parsers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JSONParser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.negotiation &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  DefaultContentNegotiation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIException
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.response &lt;span&gt;import&lt;/span&gt; Response  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;友好的显示返回结果&lt;/span&gt;



&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthView(APIView):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;auth登录页面不需要验证，可设置&lt;/span&gt;
    authentication_classes = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;登录页面不需要认证&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        接收用户名和密码
        :param request:
        :return:
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ret &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1000,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None}
        user &lt;/span&gt;= request.query_params.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        pwd &lt;/span&gt;= request.query_params.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(user,pwd)
        obj &lt;/span&gt;= models.UserInfo.objects.filter(username=user,password=&lt;span&gt;pwd).first()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; obj :
            ret[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 1001&lt;span&gt;
            ret[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名或者密码错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ret)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建随机字符串&lt;/span&gt;
        &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
        &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
        ctime &lt;/span&gt;=&lt;span&gt; time.time()
        key &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s|%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(user,ctime)
        m &lt;/span&gt;=&lt;span&gt; hashlib.md5()
        m.update(key.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        token &lt;/span&gt;=&lt;span&gt; m.hexdigest()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存数据&lt;/span&gt;
        obj.token =&lt;span&gt; token
        obj.save()

        ret[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; token
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ret)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostView(APIView):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; dispatch(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super().dispatch(request, *args, **&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; authentication_classes = [MyAuthtication]&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(request.user,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dddddddddddffffff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(request.auth,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dddddddddd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;原来的request，django.core.handlers.wsgi.WSGIRequest&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;现在的request ,rest_framework.request.Request&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(request)&lt;/span&gt;
        authentication_classes =&lt;span&gt; [SessionAuthentication,BaseAuthentication]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(self.authentication_classes)  # [&amp;lt;class 'rest_framework.authentication.SessionAuthentication'&amp;gt;,&lt;/span&gt;
                                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  &amp;lt;class 'rest_framework.authentication.BasicAuthentication'&amp;gt;]&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET请求的响应内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; post(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; try:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     try :&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         current_page = request.POST.get(&quot;page&quot;)&lt;/span&gt;
        &lt;span&gt;#
&lt;/span&gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         current_page = int(current_page)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         int(&quot;asd&quot;)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     except ValueError as e:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         print(e)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         raise #如果有raise说明自己处理不了了，就交给下面的一个去捕捉了&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; except Exception as e:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print(&quot;OK&quot;)&lt;/span&gt;


        &lt;span&gt;return&lt;/span&gt;  HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post请求的响应内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; put(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;put请求的响应内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Views.py&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;全局使用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2cac620d-3646-4878-a737-4e1b4596601d')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_2cac620d-3646-4878-a737-4e1b4596601d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2cac620d-3646-4878-a737-4e1b4596601d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2cac620d-3646-4878-a737-4e1b4596601d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2cac620d-3646-4878-a737-4e1b4596601d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注册认证类&lt;/span&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UNAUTHENTICATED_USER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UNAUTHENTICATED_TOKEN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将匿名用户设置为None&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app01.utils.MyAuthentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    ],
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;settings&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('35b15fc9-83d0-40aa-822d-272c82458d17')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_35b15fc9-83d0-40aa-822d-272c82458d17&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35b15fc9-83d0-40aa-822d-272c82458d17&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('35b15fc9-83d0-40aa-822d-272c82458d17',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35b15fc9-83d0-40aa-822d-272c82458d17&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;  rest_framework.authentication &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BaseAuthentication
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIException
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app02 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAuthentication(BaseAuthentication):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; authenticate(self, request):
        token&lt;/span&gt;=request.query_params.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(token)
        obj&lt;/span&gt;=models.UserInfo.objects.filter(token=&lt;span&gt;token).first()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; obj:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (obj.username,obj)
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;  APIException(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;没有通过验证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;全局验证&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注：rest_framewor是一个app需要settings里面设置。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Feb 2018 10:52:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/8448639.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（十五）——无权无向图 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8032659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8032659.html</guid>
<description>&lt;p&gt;　　前面我们介绍了树这种数据结构，树是由n（n&amp;gt;0）个有限&lt;strong&gt;节点&lt;/strong&gt;通过连接它们的&lt;strong&gt;边&lt;/strong&gt;组成一个具有层次关系的集合，把它叫做“树”是因为它看起来像一棵倒挂的树，包括二叉树、红黑树、2-3-4树、堆等各种不同的树，有对这几种树不了解的可以参考我前面几篇博客。而本篇博客我们将介绍另外一种数据结构——图，图也是计算机程序设计中最常用的数据结构之一，从数学意义上讲，树是图的一种，大家可以对比着学习。&lt;/p&gt;
&lt;h3&gt;1、图的定义&lt;/h3&gt;
&lt;p&gt;　　我们知道，前面讨论的数据结构都有一个框架，而这个框架是由相应的算法实现的，比如二叉树搜索树，左子树上所有结点的值均小于它的根结点的值，右子树所有结点的值均大于它的根节点的值，类似这种形状使得它容易搜索数据和插入数据，树的边表示了从一个节点到另一个节点的快捷方式。&lt;/p&gt;
&lt;p&gt;　　而图通常有个固定的形状，这是由物理或抽象的问题所决定的。比如图中节点表示城市，而边可能表示城市间的班机航线。如下图是美国加利福利亚简化的高速公路网：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209213532810-1976605857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　①、邻接：&lt;/h4&gt;
&lt;p&gt;　　如果两个顶点被同一条边连接，就称这两个顶点是邻接的，如上图 I 和 G 就是邻接的，而 I 和 F 就不是。有时候也将和某个指定顶点邻接的顶点叫做它的邻居，比如顶点 G 的邻居是 I、H、F。&lt;/p&gt;
&lt;h4&gt;　　②、路径：&lt;/h4&gt;
&lt;p&gt;　　路径是边的序列，比如从顶点B到顶点J的路径为 BAEJ，当然还有别的路径 BCDJ，BACDJ等等。&lt;/p&gt;
&lt;h4&gt;　　③、连通图和非连通图：&lt;/h4&gt;
&lt;p&gt;　　如果至少有一条路径可以连接起所有的顶点，那么这个图称作连通的；如果假如存在从某个顶点不能到达另外一个顶点，则称为非联通的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209214423326-603786123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　④、有向图和无向图：&lt;/h4&gt;
&lt;p&gt;　　如果图中的边没有方向，可以从任意一边到达另一边，则称为无向图；比如双向高速公路，A城市到B城市可以开车从A驶向B，也可以开车从B城市驶向A城市。但是如果只能从A城市驶向B城市的图，那么则称为有向图。&lt;/p&gt;
&lt;h4&gt;　　⑤、有权图和无权图：&lt;/h4&gt;
&lt;p&gt;　　图中的边被赋予一个权值，权值是一个数字，它能代表两个顶点间的物理距离，或者从一个顶点到另一个顶点的时间，这种图被称为有权图；反之边没有赋值的则称为无权图。&lt;/p&gt;
&lt;p&gt;　　本篇博客我们讨论的是无权无向图。&lt;/p&gt;
&lt;h3&gt;2、在程序中表示图&lt;/h3&gt;
&lt;p&gt;　　我们知道图是由顶点和边组成，那么在计算机中，怎么来模拟顶点和边？&lt;/p&gt;
&lt;h4&gt;　　①、顶点：&lt;/h4&gt;
&lt;p&gt;　　在大多数情况下，顶点表示某个真实世界的对象，这个对象必须用数据项来描述。比如在一个飞机航线模拟程序中，顶点表示城市，那么它需要存储城市的名字、海拔高度、地理位置和其它相关信息，因此通常用一个顶点类的对象来表示一个顶点，这里我们仅仅在顶点中存储了一个字母来标识顶点，同时还有一个标志位，用来判断该顶点有没有被访问过（用于后面的搜索）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/**
 * 顶点类
 * @author vae
 */
public class Vertex {
        public char label;
        public boolean wasVisited;
        
        public Vertex(char label){
                this.label = label;
                wasVisited = false;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　顶点对象能放在数组中，然后用下标指示，也可以放在链表或其它数据结构中，不论使用什么结构，存储只是为了使用方便，这与边如何连接点是没有关系的。&lt;/p&gt;
&lt;h4&gt;　　②、边：&lt;/h4&gt;
&lt;p&gt;　　在前面讲解各种树的数据结构时，大多数树都是每个节点包含它的子节点的引用，比如红黑树、二叉树。也有用数组表示树，树组中节点的位置决定了它和其它节点的关系，比如堆就是用数组表示。&lt;/p&gt;
&lt;p&gt;　　然而图并不像树，图没有固定的结构，图的每个顶点可以与任意多个顶点相连，为了模拟这种自由形式的组织结构，用如下两种方式表示图：邻接矩阵和邻接表（如果一条边连接两个顶点，那么这两个顶点就是邻接的）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209221659888-720670354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;邻接矩阵：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。上图用邻接矩阵表示如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209221722904-1549384558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1表示有边，0表示没有边，也可以用布尔变量true和false来表示。顶点与自身相连用 0 表示，所以这个矩阵从左上角到右上角的对角线全是 0 。&lt;/p&gt;
&lt;p&gt;　　注意：这个矩阵的上三角是下三角的镜像，两个三角包含了相同的信息，这个冗余信息看似低效，但是在大多数计算机中，创造一个三角形数组比较困难，所以只好接受这个冗余，这也要求在程序处理中，当我们增加一条边时，比如更新邻接矩阵的两部分，而不是一部分。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;邻接表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209222328123-1963427649.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;h3&gt;3、搜索 &lt;/h3&gt;
&lt;p&gt;　　在图中实现最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点，比如从武汉出发的高铁可以到达哪些城市，一些城市可以直达，一些城市不能直达。现在有一份全国高铁模拟图，要从某个城市（顶点）开始，沿着铁轨（边）移动到其他城市（顶点），有两种方法可以用来搜索图：深度优先搜索（DFS）和广度优先搜索（BFS）。它们最终都会到达所有连通的顶点，深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现，不同的实现机制导致不同的搜索方式。&lt;/p&gt;
&lt;h4&gt;　　①、深度优先搜索（DFS）&lt;/h4&gt;
&lt;p&gt;　　深度优先搜索算法有如下规则：&lt;/p&gt;
&lt;p&gt;　　规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。&lt;/p&gt;
&lt;p&gt;　　规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。&lt;/p&gt;
&lt;p&gt;　　规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209225344107-1667286888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于上图，应用深度优先搜索如下：假设选取 A 顶点为起始点，并且按照字母优先顺序进行访问，那么应用规则 1 ，接下来访问顶点 B，然后标记它，并将它放入栈中；再次应用规则 1，接下来访问顶点 F，再次应用规则 1，访问顶点 H。我们这时候发现，没有 H 顶点的邻接点了，这时候应用规则 2，从栈中弹出 H，这时候回到了顶点 F，但是我们发现 F 也除了 H 也没有与之邻接且未访问的顶点了，那么再弹出 F，这时候回到顶点 B，同理规则 1 应用不了，应用规则 2，弹出 B，这时候栈中只有顶点 A了，然后 A 还有未访问的邻接点，所有接下来访问顶点 C，但是 C又是这条线的终点，所以从栈中弹出它，再次回到 A，接着访问 D,G,I，最后也回到了 A，然后访问 E，但是最后又回到了顶点 A，这时候我们发现 A没有未访问的邻接点了，所以也把它弹出栈。现在栈中已无顶点，于是应用规则 3，完成了整个搜索过程。&lt;/p&gt;
&lt;p&gt;　　深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。这里以邻接矩阵为例，找到顶点所在的行，从第一列开始向后寻找值为1的列；列号是邻接顶点的号码，检查这个顶点是否未访问过，如果是这样，那么这就是要访问的下一个顶点，如果该行没有顶点既等于1（邻接）且又是未访问的，那么与指定点相邻接的顶点就全部访问过了（后面会用算法实现）。&lt;/p&gt;
&lt;h4&gt;　　②、广度优先搜索（BFS）&lt;/h4&gt;
&lt;p&gt;　　深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。&lt;/p&gt;
&lt;p&gt;　　规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。&lt;/p&gt;
&lt;p&gt;　　规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。&lt;/p&gt;
&lt;p&gt;　　规则3：如果因为队列为空而不能执行规则 2，则搜索结束。&lt;/p&gt;
&lt;p&gt;　　对于上面的图，应用广度优先搜索：以A为起始点，首先访问所有与 A 相邻的顶点，并在访问的同时将其插入队列中，现在已经访问了 A,B,C,D和E。这时队列（从头到尾）包含 BCDE，已经没有未访问的且与顶点 A 邻接的顶点了，所以从队列中取出B，寻找与B邻接的顶点，这时找到F，所以把F插入到队列中。已经没有未访问且与B邻接的顶点了，所以从队列列头取出C，它没有未访问的邻接点。因此取出 D 并访问 G，D也没有未访问的邻接点了，所以取出E，现在队列中有 FG，在取出 F，访问 H，然后取出 G，访问 I，现在队列中有 HI，当取出他们时，发现没有其它为访问的顶点了，这时队列为空，搜索结束。&lt;/p&gt;
&lt;h4&gt;　　③、程序实现&lt;/h4&gt;
&lt;p&gt;　　实现深度优先搜索的栈 StackX.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.graph;

public class StackX {
        private final int SIZE = 20;
        private int[] st;
        private int top;
        
        public StackX(){
                st = new int[SIZE];
                top = -1;
        }
        
        public void push(int j){
                st[++top] = j;
        }
        
        public int pop(){
                return st[top--];
        }
        
        public int peek(){
                return st[top];
        }
        
        public boolean isEmpty(){
                return (top == -1);
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现广度优先搜索的队列Queue.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.graph;

public class Queue {
        private final int SIZE = 20;
        private int[] queArray;
        private int front;
        private int rear;
        
        public Queue(){
                queArray = new int[SIZE];
                front = 0;
                rear = -1;
        }
        
        public void insert(int j) {
                if(rear == SIZE-1) {
                        rear = -1;
                }
                queArray[++rear] = j;
        }
        
        public int remove()     {
                int temp = queArray[front++];
                if(front == SIZE) {
                        front = 0;
                }
                return temp;
        }
        
        public boolean isEmpty() {
                return (rear+1 == front || front+SIZE-1 == rear);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　图代码 Graph.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.graph;

public class Graph {
        private final int MAX_VERTS = 20;//表示顶点的个数
        private Vertex vertexList[];//用来存储顶点的数组
        private int adjMat[][];//用邻接矩阵来存储 边,数组元素0表示没有边界，1表示有边界
        private int nVerts;//顶点个数
        private StackX theStack;//用栈实现深度优先搜索
        private Queue queue;//用队列实现广度优先搜索
        /**
         * 顶点类
         * @author vae
         */
        class Vertex {
                public char label;
                public boolean wasVisited;
                
                public Vertex(char label){
                        this.label = label;
                        wasVisited = false;
                }
        }
        
        public Graph(){
                vertexList = new Vertex[MAX_VERTS];
                adjMat = new int[MAX_VERTS][MAX_VERTS];
                nVerts = 0;//初始化顶点个数为0
                //初始化邻接矩阵所有元素都为0，即所有顶点都没有边
                for(int i = 0; i &amp;lt; MAX_VERTS; i++) {
                        for(int j = 0; j &amp;lt; MAX_VERTS; j++) {
                                adjMat[i][j] = 0;
                        }
                }
                theStack = new StackX();
                queue = new Queue();
        }
        
        //将顶点添加到数组中，是否访问标志置为wasVisited=false(未访问)
        public void addVertex(char lab) {
                vertexList[nVerts++] = new Vertex(lab);
        }
        
        //注意用邻接矩阵表示边，是对称的，两部分都要赋值
        public void addEdge(int start, int end) {
                adjMat[start][end] = 1;
                adjMat[end][start] = 1;
        }
        
        //打印某个顶点表示的值
        public void displayVertex(int v) {
                System.out.print(vertexList[v].label);
        }
        /**深度优先搜索算法:
         * 1、用peek()方法检查栈顶的顶点
         * 2、用getAdjUnvisitedVertex()方法找到当前栈顶点邻接且未被访问的顶点
         * 3、第二步方法返回值不等于-1则找到下一个未访问的邻接顶点，访问这个顶点，并入栈
         *        如果第二步方法返回值等于 -1，则没有找到，出栈
         */
        public void depthFirstSearch() {
                //从第一个顶点开始访问
                vertexList[0].wasVisited = true; //访问之后标记为true
                displayVertex(0);//打印访问的第一个顶点
                theStack.push(0);//将第一个顶点放入栈中
                
                while(!theStack.isEmpty()) {
                        //找到栈当前顶点邻接且未被访问的顶点
                        int v = getAdjUnvisitedVertex(theStack.peek());
                        if(v == -1) {   //如果当前顶点值为-1，则表示没有邻接且未被访问顶点，那么出栈顶点
                                theStack.pop();
                        }else { //否则访问下一个邻接顶点
                                vertexList[v].wasVisited = true;
                                displayVertex(v);
                                theStack.push(v);
                        }
                }
                
                //栈访问完毕，重置所有标记位wasVisited=false
                for(int i = 0; i &amp;lt; nVerts; i++) {
                        vertexList[i].wasVisited = false;
                }
        }
        
        //找到与某一顶点邻接且未被访问的顶点
        public int getAdjUnvisitedVertex(int v) {
                for(int i = 0; i &amp;lt; nVerts; i++) {
                        //v顶点与i顶点相邻（邻接矩阵值为1）且未被访问 wasVisited==false
                        if(adjMat[v][i] == 1 &amp;amp;&amp;amp; vertexList[i].wasVisited == false) {
                                return i;
                        }
                }
                return -1;
        }
        
        /**
         * 广度优先搜索算法：
         * 1、用remove()方法检查栈顶的顶点
         * 2、试图找到这个顶点还未访问的邻节点
         * 3、 如果没有找到，该顶点出列
         * 4、 如果找到这样的顶点，访问这个顶点，并把它放入队列中
         */
        public void breadthFirstSearch(){
                vertexList[0].wasVisited = true;
                displayVertex(0);
                queue.insert(0);
                int v2;
                
                while(!queue.isEmpty()) {
                        int v1 = queue.remove();
                        while((v2 = getAdjUnvisitedVertex(v1)) != -1) {
                                vertexList[v2].wasVisited = true;
                                displayVertex(v2);
                                queue.insert(v2);
                        }
                }
                
                //搜索完毕，初始化，以便于下次搜索
                for(int i = 0; i &amp;lt; nVerts; i++) {
                        vertexList[i].wasVisited = false;
                }
        }
        
        public static void main(String[] args) {
                Graph graph = new Graph();
                graph.addVertex('A');
                graph.addVertex('B');
                graph.addVertex('C');
                graph.addVertex('D');
                graph.addVertex('E');
                
                graph.addEdge(0, 1);//AB
                graph.addEdge(1, 2);//BC
                graph.addEdge(0, 3);//AD
                graph.addEdge(3, 4);//DE
                
                System.out.println(&quot;深度优先搜索算法 :&quot;);
                graph.depthFirstSearch();//ABCDE
                
                System.out.println();
                System.out.println(&quot;----------------------&quot;);
                
                System.out.println(&quot;广度优先搜索算法 :&quot;);
                graph.breadthFirstSearch();//ABDCE
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180210123821185-1975637828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、最小生成树&lt;/h3&gt;
&lt;p&gt; 　　对于图的操作，还有一个最常用的就是找到最小生成树，最小生成树就是用最少的边连接所有顶点。对于给定的一组顶点，可能有很多种最小生成树，但是最小生成树的边的数量 E 总是比顶点 V 的数量小1，即：&lt;/p&gt;
&lt;p&gt;　　V = E + 1&lt;/p&gt;
&lt;p&gt;　　这里不用关心边的长度，不是找最短的路径（会在带权图中讲解），而是找最少数量的边，可以基于深度优先搜索和广度优先搜索来实现。&lt;/p&gt;
&lt;p&gt;　　比如基于深度优先搜索，我们记录走过的边，就可以创建一个最小生成树。因为DFS 访问所有顶点，但只访问一次，它绝对不会两次访问同一个顶点，但她看到某条边将到达一个已访问的顶点，它就不会走这条边，它从来不遍历那些不可能的边，因此，DFS 算法走过整个图的路径必定是最小生成树。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
//基于深度优先搜索找到最小生成树
public void mst(){
        vertexList[0].wasVisited = true;
        theStack.push(0);
        
        while(!theStack.isEmpty()){
                int currentVertex = theStack.peek();
                int v = getAdjUnvisitedVertex(currentVertex);
                if(v == -1){
                        theStack.pop();
                }else{
                        vertexList[v].wasVisited = true;
                        theStack.push(v);
                        
                        displayVertex(currentVertex);
                        displayVertex(v);
                        System.out.print(&quot; &quot;);
                }
        }
        
        //搜索完毕，初始化，以便于下次搜索
        for(int i = 0; i &amp;lt; nVerts; i++) {
                vertexList[i].wasVisited = false;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、总结&lt;/h3&gt;
&lt;p&gt;　　图是由边连接的顶点组成，图可以表示许多真实的世界情况，包括飞机航线、电子线路等等。搜索算法以一种系统的方式访问图中的每个顶点，主要通过深度优先搜索（DFS）和广度优先搜索（BFS），深度优先搜索通过栈来实现，广度优先搜索通过队列来实现。最后需要知道最小生成树是包含连接图中所有顶点所需要的最少数量的边。&lt;/p&gt;

</description>
<pubDate>Wed, 14 Feb 2018 09:56:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8032659.html</dc:identifier>
</item>
<item>
<title>2018/2/14 设计模式学习笔记(一) 自己实现ArrayList,LinkedList和Iterator，以及在此过程中对于面向对象，面向接口，还有抽象类的一些思考感悟 - yangfeiORfeiyang</title>
<link>http://www.cnblogs.com/yangfeiORfeiyang/p/8448430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangfeiORfeiyang/p/8448430.html</guid>
<description>&lt;p&gt;因为本人目前为止学习编程不过七个月，所以后面的感悟对于一些大神来说可能嗤之以鼻，但对于一些刚刚入门的萌新来说在理解面向对象的思想上，以及抽象类和接口应该怎么设计等方面应该还是会有所帮助的&lt;/p&gt;
&lt;p&gt;首先我们定义一个自己的Collection接口:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214135909984-1772513186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建自己的ArrayList类并实现此接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140032702-1259085665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再创建自己的LinkedList类并实现MyCollection接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140114437-995373772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140122890-1623334890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在两个类都创建好了，我们开始定义Iterator接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140347421-480004877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在MyArrayList里创建一个内部类实现Iterator并封装，同时开放一个接口让别人获取此内部类的对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140505015-203432564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyLinkedList相同&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214140535702-1598783445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打完收工；其实ArrayList和LinkedList源码的Iterator都是直接对底层的数组和链表做操作，不过我怕麻烦，所以直接把当前对象传了进去；&lt;/p&gt;
&lt;p&gt;Iterator在设计模式里叫做迭代器模式，其主要定义为，提供一种可以访问容器种各个的方式，但又不暴露该容器的内部细节。这里内部细节的意思就是因为每个容器本身的数据结构不同，如ArrayList底层是一个数组，LinkedList底层则是链表，访问ArrayList的时候你可以使用for，但是如果需要遍历LinkedList则只能使用while。(我代码中之所以都是调用了get，单纯是因为怕麻烦，源码都是直接对数组和链表做的操作)&lt;/p&gt;
&lt;p&gt;而Iterator给我们定义了一个访问容器内元素的一个规范，具体要怎么实现就看你自己，这样一来在别人访问某个容器中元素的时候就不必再先去了解一下此容器的内部细节，直接获得此容器的迭代器对象就行；这也是面向对象编程中让对象帮我们去做事情这种思想的直接体现；&lt;/p&gt;
&lt;p&gt;在此次学习中，我学习到了两个点，一个便是统一规范的重要性，二个便是面向对象思想的更深入了解，也懂得了为什么说面向接口基于面向对象但高于面向对象；&lt;/p&gt;

&lt;p&gt;下面是我在通过Iterator设计模式的学习上举一反三的发散式思考，抛却智商因素，这也是我感觉自己不管学什么都比别人更深更快，同样一个点我能看到面而很多人只能看到点的原因之一；&lt;/p&gt;
&lt;p&gt;首先接口是一个规范，是对一个体某些行为的定义。而与接口的概念最容易混淆的便是抽象类，同样可以定义抽象方法，同样不能有实例，只是抽象类可以实现方法体，并且也拥有构造函数，它与子类的关系也是继承，但他们的区别难道仅仅在于代码级别的体现吗？&lt;/p&gt;
&lt;p&gt;这里说下我的理解，所谓抽象类，应该是一个我们能想到的某个事物，只是它太笼统，抽象，不够具体，但我们知道它能大概干什么，具体怎么干。举一个例子，比如交通工具，这就很抽象了，交通工具可以是汽车，可以是飞机，但是它们都有一个共同点，那就是可以运送我们从一个地方到另一个地方。这个时候这种运送就是交通工具的共同行为，我们就可以将其、&lt;/p&gt;
&lt;p&gt;抽象为一个接口，这个接口的功能就是运送能力。但是汽车是在地上跑的。飞机是在天上跑的，而且汽车和飞机还是太抽象了，汽车可能是大卡车，也可能是小轿车，而飞机也有可能是客机，也可能是直升飞机，它们的启动方式和本身的构造都不相同，所以汽车和飞机虽然我们知道它们的运送行为是一个在地上跑，一个在天上飞。但是它们的&lt;/p&gt;
&lt;p&gt;底下的种类分支太多，所以汽车和飞机都只能定义为抽象类。在这个时候我们可以在抽象类中实现它们一个在地上跑，一个是在天上飞的方法，但具体怎么跑，怎么飞我们则要将其定义为抽象方法，然后让具体的卡车或者汽车或者直升机对象实现它，甚至我们可以在其中定义一些公有属性；这样一来我们就不用去关心每个具体的对象它们怎么跑怎么飞的内部细节，只需要创建具体交通工具对象的人去实现它，我们直接调用即可；下面是代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154030421-2100071900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154113171-768873045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154123906-587284958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154133702-1137453407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154144515-128316940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313797/201802/1313797-20180214154153640-214893821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Feb 2018 07:42:00 +0000</pubDate>
<dc:creator>yangfeiORfeiyang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangfeiORfeiyang/p/8448430.html</dc:identifier>
</item>
<item>
<title>程序猿年终总结：我看了我的这7年 - 小八路</title>
<link>http://www.cnblogs.com/tonymu/p/my-past-seven-years.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tonymu/p/my-past-seven-years.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.迷茫了7年&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　春节放假休息中，收到来自公司大卫张“iChange创变研习会”公众号推送的文章“2017，我看了我的这一年”。文中从四个维度Fact、Feeling、Finding、Future回顾了他作为公司CTO的2017年经历和对来年的展望。在我看来，他大概表达了上半年的迷茫、无助和下半年的柳暗花明、“小成就”。迷茫在于独自（注意：不是犊子）做“大事情”的寂寞、收效甚微，如：公司整体业务推进、行业发展趋势、推动公司团队认知升级和成长等；柳暗花明在于和团队成员一起持续做“小事情”的可操作性、成果明显，如：专注产品和运营细节，专注于拿到小结果；同时强调了小改变、关心细节和做小事的重要性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　相对于老张2017年上半年的迷茫，我就“厉害”多了，自2010年参加工作到2017年这7年中，几乎长期处于迷茫状态。在3家曾经就职过的企业一直重复着增删改查或者稍微更复杂一点的编程工作，大部分时间里从事着基于完成岗位任务的工作。一直以来忽略了自己存在的价值：为什么要编程？能不能更好地编程？所以也就忽略了业务关注、架构设计、高效生产力、高效沟通、优化知识体系等方面的进步。如果去掉这几年积累的一些解决技术问题的经验，我在思维上、认知上其实和一个刚参加工作2到3年的普通人没太大本质的差别，换句话说我后面4年停止了成长。所以，忽然意识到是时候自我分析一下现状、找找原因、设定一些“小目标”（比如先挣它1个亿）、寻求一些“小改变”了，也是时候面对自己存在价值的问题了。希望通过及时矫正自己的成长轨迹，也发现柳暗花明之路并持续取得“小成就”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.递归：学习“如何学习”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;　　刚才讲了自己7年职业之路中后4年停止成长这一事实，但我是一个积极的人，夸大点甚至算得上工作狂，我工作也努力，从未放弃学习。为什么就停止了成长呢？从外因来看，有可能是那几年的工作环境没有对自己提出更高的要求，也有可能是缺乏导师引导。但更重的需要从内因找，我认为是自己的学习方法出了问题，虽然时常学习但是效果却大打折扣。2017年，我有幸加入龚老师（公司架构师）的团队。他给我分享了一些学习方法，举个关键的例子，他给我澄清了什么是知识以及如何学习知识：知识是经过自己反复验证的经验，能在大脑中形成长期记忆，学以致用才是好的学习方法。现在回头看，我最近4年中，“学到的知识”大部分没有在实际工作中投入使用，也就不能形成长期的深层记忆，时间久了就淡忘了，不能做到信手拈来，例如：某日早晨我坐在地铁1号线上，看到某技术社区分享的某篇文章介绍了某种技术，看的津津入味，但由于没有将它与具体工作结合起来，所以也就没有成为“自己的知识”，对我而言，那篇文章就像一篇娱乐新闻，只是接受到的一条信息而已，时间久了就忘了。当然，在我意识到学习方法出了问题后，我在网上检索关于如何学习的信息，偶然看到大卫张几年前的一片文章&lt;a href=&quot;http://blog.51cto.com/davidzhang33/1129749&quot; target=&quot;_blank&quot;&gt;《大卫张谈学习》&lt;/a&gt;，里面的前三年效应、刻意训练、为未来学习等观点恰好解答了我的一些疑惑。有意思的是文中的“刻意训练”观点和龚老师介绍的知识的含义是不谋而合的。感谢两位大牛，通过他们的影响，我突然豁然开朗，明白了原来自己之所以和4年前差别不大是因为学习方法不对，觉得自己有很多事情可以去做。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.主动思考：少则是多，慢则是快&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在导师的影响下，我逐渐开始改变为了编程而编程的理念和习惯，渐渐接触架构思维训练。意识到良好的架构设计，对软件系统而言，在稳定性、可维护性、扩展性上的重要。因为7年的重复练习，我写代码速度很快，拿到需求后，高效地完成了任务。一开始他们说我是快枪手，我以为这是夸奖我，但是到后来我才发现，其实代码不是写的越快越好，而是经过一段时间的前期思考、设计，架构先行，很多宏观的思路理清了，特别是领域模型分析清楚了，追求系统的单一性，再配合一些设计原则和技巧，写出来的代码才有可能是高质量的代码，我理解的高质量代码是指模块设计合理，逻辑清晰，相对精简、抽象的代码。当然，2017年只是有了架构意识，未来还有很长的路要走，需要不断主动思考，需要不断面对挑战以及根据反馈不断持续训练架构思维。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.主动承担与推进&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在之前的经历中，我一直认为上班努力工作，完成好工作任务，就是一名合格的员工。但是最近这个观念发生了改变，特别公司的岗位职级公布后，我明白了完成好任务不一定会成为年终奖高的员工，只有完成好任务的同时继而达成了业务目标，才算得上优秀员工。所以，应该去考虑用户诉求，考虑业务场景，还需要关注外部资源，特别是需要跨团队协作才能达成业务目标时。要做到这一些，需要有足够的责任心去主动承担，以及良好的沟通协调能力和良好的业务推进能力去主动推动业务完成。这些观念在前几年是没有体现在工作中的，若4年前就开始修炼，也许现在的境界早已不同（当然也有可能然并卵），争取以后的工作中，能做到主动承担与推进，除了在工作中贡献自己的“上班时间”，还应贡献自己的激情和创造力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　见贤思齐，天道酬勤，有感于老张的“iChange创变”思想，希望通过对自己现状的分析，对自己有客观的认识，然后用正确的方式去持续学习，持续重构自己的思维和认知，成为更优秀的自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本来本文是一篇笔记，但考虑到有很多朋友可能和我有类似的心境，便发布到博客，愿能帮助到更多的人。祝大家狗年汪汪汪！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Feb 2018 07:39:00 +0000</pubDate>
<dc:creator>小八路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tonymu/p/my-past-seven-years.html</dc:identifier>
</item>
<item>
<title>Windows Azure Virtual Network (12) 虚拟网络之间点对点连接VNet Peering - Lei Zhang的博客</title>
<link>http://www.cnblogs.com/threestone/p/8448127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/threestone/p/8448127.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/threestone/archive/2012/01/06/2382322.html&quot;&gt;Windows Azure Platform 系列文章目录&lt;/a&gt;》&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在有些时候，我们需要通过VNet Peering，把两个虚拟网络&lt;strong&gt;通过内网&lt;/strong&gt;互通互联。比如：&lt;/p&gt;
&lt;p&gt;　　1.在订阅A里的Virtual Network，部署了CRM系统&lt;/p&gt;
&lt;p&gt;　　2.在订阅B里的Virtual Network，部署了Order系统&lt;/p&gt;
&lt;p&gt;　　3.需要通过CRM系统，通过内网传输，获取到Order系统里面的订单信息&lt;/p&gt;

&lt;p&gt;　　如果没有VNet Peering的话，我们只能把Order系统里面的虚拟机，设置公网地址，然后通过设置网络安全组(NSG)的IPV4访问白名单，允许CRM系统的公网IP&lt;/p&gt;
&lt;p&gt;　　但是这样的代价也太大了。&lt;/p&gt;

&lt;p&gt;　　通过使用Azure VNet Peering，我们可以：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.把同一个订阅里面的两个不同的Virtual Network，通过内网互通互联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.在同一个企业合同(EA)下，把不同订阅的Virtual Network，通过内网互通互联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.跨企业合同(EA)下，把不同订阅的Virtual Network，通过内网互通互联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.请注意：两个需要Peering的Virtual Network，IP Range不能重叠&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　在这里笔者介绍Azure Virtual Network Peering的两种使用场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.不同订阅的Virtual Network之间，内网互通互联。如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214115531999-1860312416.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.一边是Virtual Network，一边是Virtual Network和Express Route Gateway&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Project B通过ER Gateway网关，链接到IDC内网的应用。如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214120003031-52873717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来开始演示内容：　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　一.不同订阅的Virtual Network之间，内网互通互联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214115531999-1860312416.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们先准备以下内容：&lt;/p&gt;
&lt;p&gt;　　1.在A订阅里面，创建Virtual Network, 名称为A-VNet，IP Rang为172.0.0.0/24。图略&lt;/p&gt;
&lt;p&gt;　　2.在B订阅里面，创建Virtual Network, 名称为B-VNet，IP Rang为172.0.1.0/24。图略&lt;/p&gt;
&lt;p&gt;　　3.在上面2个VNet里面，分别创建2台Windows VM。这两台VM的IP分别为172.0.0.4和172.0.1.4。图略&lt;/p&gt;
&lt;p&gt;　　4.我们首先通过远程桌面连接RDP到这2台VM，关闭Windows防火墙。然后分别通过ping命令，ping对方的内网IP地址。肯定是ping不通的。&lt;/p&gt;
&lt;p&gt;　　5.我们首先需要设置，从A-VNet (172.0.0.0/24) 到 B-VNet (172.0.1.0/24)的Peering。&lt;/p&gt;
&lt;p&gt;　　在A-VNet里面，选择Peerings，然后点击下图的Add按钮&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214142351249-1538954414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6.界面跳转，我们设置如下内容：&lt;/p&gt;
&lt;p&gt;　　Name设置Peering的名称，为AtoB-Peering&lt;/p&gt;
&lt;p&gt;　　在Subscription里面选择订阅&lt;/p&gt;
&lt;p&gt;　　在Virtual Network选择需要链接的虚拟网络&lt;/p&gt;
&lt;p&gt;　　在Configuration里面，勾选Allow Forwarded Traffic&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214142629281-1775395176.png&quot; alt=&quot;&quot; width=&quot;744&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　请注意上图中，因为我们是在同一个EA下面的2个订阅，所以可以通过Subscription下拉框选择到相应的订阅&lt;/p&gt;
&lt;p&gt;　　如果我们想跨EA设置VNet Peering。我们可以手动输入需要链接的Virtual Network的资源ID。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214142956702-931671432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　7.设置完毕后，从A-VNet到B-VNet的Peering设置成功了。我们还需要设置从B-VNet到A-VNet的Peering。　　&lt;/p&gt;
&lt;p&gt;　　我们在B-VNet里面，选择Peerings，然后点击下图的Add按钮&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214143232077-1593174801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　8.界面跳转，我们设置如下内容：&lt;/p&gt;
&lt;p&gt;　　Name设置Peering的名称，为BtoA-Peering&lt;/p&gt;
&lt;p&gt;　　在Subscription里面选择订阅&lt;/p&gt;
&lt;p&gt;　　在Virtual Network选择需要链接的虚拟网络&lt;/p&gt;
&lt;p&gt;　　在Configuration里面，勾选Allow Forwarded Traffic&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214143610031-1283843874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　9.设置成功后，我们查看两台VM的Ping命令。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214143647015-1376550353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，已经可以从A VM (192.168.0.4)，ping到B VM(192.168.1.4)。就实现了这2个Virtual Network之间的内网互通互联。&lt;/p&gt;


&lt;p&gt;　　然后我们开始第二部分：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一边是Virtual Network，一边是Virtual Network和Express Route Gateway&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Project B通过ER Gateway网关，链接到IDC内网的应用。如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214120003031-52873717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在Project B订阅里面：&lt;/p&gt;
&lt;p&gt;　　1.创建一个Virtual Network，&lt;strong&gt;我们命名为A-VNet&lt;/strong&gt;，和一台VM&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2.请注意：这个订阅里面，不包含Express Route Gateway网关，或者其他VPN网关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在Shared Gateway订阅里面：&lt;/p&gt;
&lt;p&gt;　　1.创建Virtual Network, &lt;strong&gt;我们命名为ER-VNet&lt;/strong&gt;，Gateway Subnet，Express Route Gateway&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.请注意：在这个订阅里面，包含Express Route Gateway网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　1.我们在Project B的订阅里面，选择Peerings，然后点击Add按钮。图略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　2.从Project B到Express Route Gateway的Peering，请按照下图设置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Allow Forwarded Traffic，允许从Project B到&lt;/strong&gt;Express Route Gateway的流量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;　　Use Remote Gateways，设置Project B使用远端Express Route的Gateway&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214150548374-2073504025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.然后我们在Express Route的订阅里，选择Peerings，然后点击Add按钮。图略&lt;/p&gt;
&lt;p&gt;　　4.从Express Route，到Project B的Peering，请按照下图设置&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Allow Forwarded Traffic，允许从&lt;/strong&gt;Express Route Gateway到&lt;strong&gt;Project B&lt;/strong&gt;的流量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Allow Gateway Transit，允许&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;Project B的流量，从Express Route Gateway穿透&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/127213/201802/127213-20180214151319671-1198094407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Feb 2018 07:14:00 +0000</pubDate>
<dc:creator>Lei Zhang的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/threestone/p/8448127.html</dc:identifier>
</item>
</channel>
</rss>