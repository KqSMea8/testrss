<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从.git文件夹探析git实现原理 - Ant°</title>
<link>http://www.cnblogs.com/gscienty/p/7904518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gscienty/p/7904518.html</guid>
<description>&lt;p&gt;git是一款分布式代码版本管理工具，通过git能够更加高效地协同编程。了解git的工作原理将有助于我们使用git工具更好地管理项目。通过了解.git文件夹中的文件组成，我们可以从一个角度去窥探git的实现原理。我们知道，在开始开发一个项目或加入一个项目时，需要创建一个新的仓库&lt;code&gt;git init [options]&lt;/code&gt;，或从远端克隆一个已经存在的仓库&lt;code&gt;git clone [uri]&lt;/code&gt;，除使用&lt;code&gt;git init --bare&lt;/code&gt;创建一个“裸”仓库以外，所有创建的本地仓库都包含有一个.git文件夹，需要了解的是，“裸”仓库的内容就是.git文件夹中的内容。讨论“裸”仓库与实际仓库作用的异同不是我们现在讨论的重点，如需了解可翻阅相关文档。由此，git系统当中的的所有数据都存在于.git文件夹之中。&lt;/p&gt;
&lt;h2 id=&quot;git文件夹中的内容及作用&quot;&gt;.git文件夹中的内容及作用&lt;/h2&gt;
&lt;p&gt;打开.git文件夹后，通常有五个文件夹：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hooks文件夹，用于存储shell脚本，当执行某些git指令后，会触发存储在该文件夹下指定的shell脚本&lt;/li&gt;
&lt;li&gt;info文件夹，用于存储该项目仓库的相关信息&lt;/li&gt;
&lt;li&gt;logs文件夹，用于记录分支提交记录&lt;/li&gt;
&lt;li&gt;objects文件夹，“key-value数据库”&lt;/li&gt;
&lt;li&gt;refs文件夹，用于记录每个分支的最新提交结点以及tags&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们需要着重关注logs文件夹、objests文件夹以及refs文件夹，通过这三个文件夹所存储的内容来分析git。在.git文件夹中，同样存在有一些文件，譬如HEAD、config、index等文件，其中HEAD文件用以记录当前仓库指向的项目提交结点，config文件中记录着仓库的配置信息，这些文件内容不是我们要讨论的重点。&lt;/p&gt;
&lt;h2 id=&quot;objects文件夹git中的key-value数据库&quot;&gt;objects文件夹，git中的“key-value数据库”&lt;/h2&gt;
&lt;p&gt;在讨论objects文件夹的内容之前，我们需要明确存在于git系统中的三个实体，即&lt;strong&gt;“提交结点”&lt;/strong&gt;、&lt;strong&gt;“节点内容”&lt;/strong&gt;、&lt;strong&gt;“文件内容”&lt;/strong&gt;。&lt;br/&gt;objects可以认为是一种“key-value数据库”，之所以将数据库打引号，是因为这个“git的数据库”不具备数据库的基本功能，而仅仅具备可以通过key值能够找到与之对应的value。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提交结点实体&lt;/strong&gt;，是整个git中的核心实体，提交节点中描述了提交节点之间的继承关系，即本次提交的内容是基于哪个或哪几个之前的提交的内容，提交结点实体之间的关系形成了一个DAG图，通过这个DAG图可以清晰地理顺整个项目的发展脉络，提交节点的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree &amp;lt;SHA1-signature&amp;gt;
[
    parent &amp;lt;SHA1-signature&amp;gt;
    ...
]
author &amp;lt;author name&amp;gt; &amp;lt;\&amp;lt;author email\&amp;gt;&amp;gt; &amp;lt;timestamp&amp;gt; &amp;lt;time zone&amp;gt;
committer &amp;lt;committer name&amp;gt; &amp;lt;\&amp;lt;committer email\&amp;gt;&amp;gt; &amp;lt;timestamp&amp;gt; &amp;lt;time zone&amp;gt;

&amp;lt;commit message&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tree&lt;/code&gt;用于指向与该提交结点实体关联的节点内容实体。&lt;code&gt;parent&lt;/code&gt;用于指向该提交节点实体所基于的之前的提交结点实体，可以看到，parent可以是多个。&lt;code&gt;author&lt;/code&gt;用于记录本次提交的作者姓名、作者邮箱、作者所添加的内容时间以及时区。&lt;code&gt;committer&lt;/code&gt;用于记录本次提交的提交者姓名、邮箱等内容。&lt;code&gt;commit message&lt;/code&gt;用于记录当前提交的消息日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点内容实体&lt;/strong&gt;，用于记录本次提交时，提交中所包含的所有文件名，以及文件名所对应的key值，值得注意的是，可能由于查询性能的缘故，并非是仅记录本次提交时修改的文件，而是记录本次提交时所有的文件。另有一点值得注意的是，即便项目仓库中的文件不变，仅改变某个或某几个文件内容的前后两次提交，生成的前后两次提交节点中的&lt;code&gt;tree&lt;/code&gt;值是不同的，换句话说，节点内容与提交节点是逻辑上的一对一关系。随着之后的讨论我们会很自然地得出这样的结论，这种一对一关系也同样是必须的，尽管在实际情况中允许两个不同的提交节点实体指向相同的节点内容实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件内容实体&lt;/strong&gt;，用于记录具体的文件内容。也就是说，在一个git仓库中，并非只有程序员们所能看到的当前项目文件夹下的代码版本，包括所有的历史代码都会在.git文件夹中有一个备份。&lt;/p&gt;
&lt;p&gt;在objects文件夹中，三种数据实体无差别的以key-value的形式进行存储。因此一次提交操作，在objects文件夹中至少生成两个文件。存储时采用deflate算法对原始文件内容进行压缩，而key值是根据原始文件内容、文件大小等数据生成的消息摘要，在当前版本的git中，消息摘要生成算法采用SHA1算法，生成过程是将文件格式与文件长度组成头部，将文件内容作为尾部，由头部和尾部拼接后作为原文，经过SHA1算法计算之后得到该文件的160位长的SHA1签名。为防止一个文件夹内的文件数量过多，将签名每四位用字符表示十六进制数，于是得到一个长度为40的字符串，将字符串的前两个字符作为文件夹，后38个字符作为文件名进行存储。&lt;/p&gt;
&lt;p&gt;观察仔细的同学可以发现，在三个实体的内容里，没有任何一个字段提供分支概念的信息。&lt;/p&gt;
&lt;h2 id=&quot;logs文件夹用于记录分支提交记录&quot;&gt;logs文件夹，用于记录分支提交记录&lt;/h2&gt;
&lt;p&gt;该文件夹下的内容是一条分支下的所有提交节点实体序列。在该文件夹下，文件内容格式是单一的，即形如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 6a0fa53d78f03abea3439b9213123d1f260f5beb author &amp;lt;mail&amp;gt; 1511776312 +0800    commit (initial): master 1
6a0fa53d78f03abea3439b9213123d1f260f5beb 75642040a2da5b324befde7ca8531b3426b32ba7 author &amp;lt;mail&amp;gt; 1511776323 +0800    commit: master 2

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一个分支创建时，无论这个分支是master还是基于某个提交结点创建的子分支，在logs文件中关于分支的时间线总是以全0的值为开始的。我们需要关注这样几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;master在初始化时是否会创建一个起始地提交结点？&lt;/li&gt;
&lt;li&gt;分支创建时的是否会创建一个新的提交节点？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过 &lt;code&gt;git init&lt;/code&gt;创建一个初始化的git仓库时，master是默认创建的，在初始化的git仓库中，.git文件夹中是不存在logs文件夹的，且在objects文件夹中不包含任何key-value键值对，甚至不存在一个实际存在的master主分支，因此所谓的master初始化并非是在git仓库初始化时进行的，而是在首次提交时进行的。在测试项目中，我在以75为开头的提交结点时创建了一个子分支，查看子分支的logs文件内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 75642040a2da5b324befde7ca8531b3426b32ba7 author &amp;lt;mail&amp;gt; 1511776334 +0800    branch: Created from HEAD

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，子分支创建时并非将主分支上分叉节点复制一下，而是从这个节点起即为一个子分支。&lt;/p&gt;
&lt;p&gt;当合并分支时，logs的日志是如何表现，事先需要明确的是，合并分支等价于一次提交（合并分支会生成一个提交结点实体）。我们需要关注这样几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在子分支上已经提交过若干次，在父分支上不提交代码，当在父分支上合并子分支时，父分支的logs记录序列是怎样的&lt;/li&gt;
&lt;li&gt;在子分支上提交若干次，在父分支上同样提交若干次，当在父分支上合并子分支时，父分支的logs记录序列是怎样的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于这两个问题，我们需要观察相关的文件。第一个实验是，首先创建了一个仓库，并在master分支上提交了一次代码，之后在master分支的最新提交结点上创建了一个子分支branch，再在branch分支上连续提交了两次代码，而后切换到mster分支后，合并branch分支，logs文档的记录如下：&lt;/p&gt;
&lt;p&gt;该文件是master分支的logs文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 79f586c23a8a169f1651411c879657406757ef92 author &amp;lt;mail&amp;gt; 1511853763 +0800    commit (initial): master 1
79f586c23a8a169f1651411c879657406757ef92 ea4fbfc8600b90555a8a4eb410a176cfbdfa48d7 author &amp;lt;mail&amp;gt; 1511853908 +0800    merge branch: Fast-forward&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文件是branch分支的logs文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 79f586c23a8a169f1651411c879657406757ef92 author &amp;lt;mail&amp;gt; 1511853776 +0800    branch: Created from master
79f586c23a8a169f1651411c879657406757ef92 2dbe03d87733bbcf5b760ba3beacd61ab3f54b58 author &amp;lt;mail&amp;gt; 1511853808 +0800    commit: branch 1
2dbe03d87733bbcf5b760ba3beacd61ab3f54b58 ea4fbfc8600b90555a8a4eb410a176cfbdfa48d7 author &amp;lt;mail&amp;gt; 1511853870 +0800    commit: branch 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在父分支没有做改动且子分支做改动的情况下，由父分支进行合并时，是直接将父分支的最新分支节点定义为子分支上的最新分支节点，ea开头的提交节点实体的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree 1247c7d74e9c28fb83e8e394910346dee104fcae
parent 2dbe03d87733bbcf5b760ba3beacd61ab3f54b58
author author &amp;lt;mail&amp;gt; 1511853870 +0800
committer author &amp;lt;mail&amp;gt; 1511853870 +0800

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个实验是在父分支上提交若干次切在子分支上提交若干次，在父分支上合并子分支时，logs的数据内容。首先创建一个仓库，且在master分支上提交一次代码。在该提交的代码基础上创建一个分支branch。分别在branch分支和在master分支上各自提交两次代码（无冲突），再在master分支上合并branch分支，观察两个分支下的文件内容：&lt;/p&gt;
&lt;p&gt;该文件是master分支的logs文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 8bf95277d6c020f0ade434896355c448fd0cac00 author &amp;lt;mail&amp;gt; 1511854786 +0800    commit (initial): 1
8bf95277d6c020f0ade434896355c448fd0cac00 368ddb7d615e5eedfe5813ff2f88547dcb66b02b author &amp;lt;mail&amp;gt; 1511854819 +0800    commit: change
368ddb7d615e5eedfe5813ff2f88547dcb66b02b 3ba031189d37d816421a019a6240e9d79a683fdd author &amp;lt;mail&amp;gt; 1511854837 +0800    commit: master add 2
3ba031189d37d816421a019a6240e9d79a683fdd 12c6263013cf467f348549337813db01044046b9 author &amp;lt;mail&amp;gt; 1511854896 +0800    merge branch: Merge made by the 'recursive' strategy.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文件是branch分支的logs文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000000000000000000000000000 8bf95277d6c020f0ade434896355c448fd0cac00 author &amp;lt;mail&amp;gt; 1511854795 +0800    branch: Created from master
8bf95277d6c020f0ade434896355c448fd0cac00 ba65e4cc73953f522f14a47088acf814e26ebc29 author &amp;lt;mail&amp;gt; 1511854859 +0800    commit: add 3
ba65e4cc73953f522f14a47088acf814e26ebc29 eccc7d8176edb5064cde7649ad651bb2e4fce0e3 author &amp;lt;mail&amp;gt; 1511854873 +0800    commit: add 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，在执行merge之后，master分支的最后一次提交结点实体是两个logs文件中都从未出现过的，并且，这个以12为开头的最新提交结点实体的前一个结点实体，是父节点的次新提交结点实体。&lt;/p&gt;
&lt;p&gt;额外关注一下以12为开头的最新提交结点实体的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree 659231fc28ddcd98c8d557e07a3fb5de4efc55b6
parent 3ba031189d37d816421a019a6240e9d79a683fdd
parent eccc7d8176edb5064cde7649ad651bb2e4fce0e3
author author &amp;lt;mail&amp;gt; 1511854896 +0800
committer author &amp;lt;mail&amp;gt; 1511854896 +0800&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 28 Nov 2017 07:54:00 +0000</pubDate>
<dc:creator>Ant&amp;#176;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gscienty/p/7904518.html</dc:identifier>
</item>
<item>
<title>OPENGLES 绘制纹理带黑圈pre-multiplying - 闵天</title>
<link>http://www.cnblogs.com/checkway/p/7910183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/checkway/p/7910183.html</guid>
<description>&lt;p&gt;       在进行 OpenGL 纹理混合的过程中，遇到一个诡异的现象，两个纹理混合的效果出人所料: 将一个ALPHA渐变的【胡须】加在另一张图片上，这个 【胡须】是由外向里逐渐增加透明度的，也就是最外围的透明度为0，而中心的透明度接近 1，也就是完全不透明，实心。那么预期的效果希望是在底图上加一个朦胧的效果，然而实际得到的效果很让人意外，出现一片淡淡的黑色！（如下图中的胡须旁边的黑色。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/74155/201711/74155-20171128150854737-320685599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;shader：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
vec4 main_color = texture(rgbTexture, v_TexCoord);
vec4 huxu_color = texture(huxu_texture, v_TexCoord);
vec4 color_out = mix(main_color, huxu_color, huxu_color.a);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为【胡须】图片是带有透明度，根据其透明度与原图进行混合，理应能够得到我们想要的结果。在 debug 过程中我尝试不进行混合，直接将【胡须】绘制在图片上，发现【胡须】还是有渐变效果，发现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【胡须】的 RGB 数据和原始图片的 RGB 不同&lt;/strong&gt; 此处存在 &lt;strong&gt;&lt;span&gt;pre-multiplying.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pre-multiplying：Android 平台在加载一张位图的时候，会自动做一个操作，将 RGB 的值乘上 alpha 值，重新保存。用公式表示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
If you use OpenGL ES 2.0, pre-multiplying the output of your fragment shader is extremely simple:
color.rgb *= color.a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回头再看我的混合的方式，在 RGB 数据已经被做过一次 pre-multiplying 的情况下，再乘一个 alpha: &lt;code&gt;RGB_new = RGB * alpha * alpha&lt;/code&gt; 然后再和底图的颜色加起来，自然就出错了。比如在白色的透明度为0.5的地方，原来的 RGB 为255，这种奇怪的算法得到的结果就是 63.75，接近黑色。这就是出现黑色的原因。&lt;/p&gt;


&lt;p&gt;解决思路有2个&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
不做 pre-multiplying
混合時考虑到前面的情况，不再乘上 alpha
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一种方案：&lt;/p&gt;
&lt;p&gt;android 加载方法：加载图片时 设置 &lt;code&gt;BitmapFactory.Options.&lt;/code&gt;&lt;code&gt;inPremultiplied&lt;/code&gt;  = false;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot; readability=&quot;5&quot;&gt;
inPremultiplied
added in API level 19
boolean inPremultiplied

If true (which is the default), the resulting bitmap will have its color channels pre-multipled by the alpha channel.
This should NOT be set to false for images to be directly drawn by the view system or through a Canvas. The view system and Canvas assume all drawn images are pre-multiplied to simplify draw-time blending, and will throw a RuntimeException when un-premultiplied are drawn.
This is likely only useful if you want to manipulate raw encoded image data, e.g. with RenderScript or custom OpenGL.
This does not affect bitmaps without an alpha channel.
Setting this flag to false while setting inScaled to true may result in incorrect colors.&lt;p&gt;See also:&lt;br/&gt;hasAlpha() &lt;br/&gt;isPremultiplied() &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;inScaled&lt;/span&gt;&lt;br/&gt;　　
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IOS 上木有这种接口。&lt;/p&gt;

&lt;p&gt;第二种方案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
vec4 main_color = texture(rgbTexture, v_TexCoord);
vec4 huxu_color = texture(huxu_texture, v_TexCoord);
vec4 color_out = main_color * (1.0f - huxu_color.a) + huxu_color;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和原来的相比，用OpenGL 的表述方式，原来做法是：&lt;code&gt;(SRC_ALPHA, ONE_MINUS_SRC_ALPHA)&lt;/code&gt; 考虑pre-multiplying的话：&lt;code&gt;(ONE, ONE_MINUS_SRC_ALPHA)&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://plus.google.com/+ChetHaase/posts/ef6Deey6xKA&quot; target=&quot;_blank&quot;&gt;https://plus.google.com/+ChetHaase/posts/ef6Deey6xKA&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 07:24:00 +0000</pubDate>
<dc:creator>闵天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/checkway/p/7910183.html</dc:identifier>
</item>
<item>
<title>需加装饰——装饰模式 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/decorate.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/decorate.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类图分析&quot;&gt;类图分析&lt;/h3&gt;
&lt;p&gt;我们先假设一个业务场景，有三种房子需要装修，分别是公寓，木屋和别墅，装修的方式有刷墙和摆满鲜花。那么应用装饰模式以后的类图结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/evsward/mainbase/blob/master/resource/image/patterns/Decorate/Decorate.png?raw=true&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个结构似乎与&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/Composite.html&quot;&gt;组合模式&lt;/a&gt;非常像，然而内部却大有不同。截止到Decorate部分，左上部分完全与组合模式相同，Decorate类是装饰类的核心类。&lt;/p&gt;
&lt;h3 id=&quot;代码展示&quot;&gt;代码展示&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package pattern.decorate;

/**
 * 装饰类基类，注意要继承构建类基类，同时关联一个基类对象
 * 
 * @author Evsward
 *
 */
public class Decorate extends House {
    protected House house;

    public Decorate() {
        // 给出一个默认值，防止house空值异常。
        this.house = new Cabin();
    }

    public Decorate(House house) {
        this.house = house;
    }

    @Override
    public void show() {
        house.show();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面关键点为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Decorate类也继承了House抽象基类。&lt;/li&gt;
&lt;li&gt;同时它还包含一个House对象的成员属性。&lt;/li&gt;
&lt;li&gt;该属性在构造器中被初始化。&lt;/li&gt;
&lt;li&gt;其复写的抽象方法并未实现任何具体内容，而是直接调用House对象的show方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后请看Decorate的子类的实现方式，他们是如何具体的扩展构建类的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package pattern.decorate;

public class GreenWallHouse extends Decorate {

    public GreenWallHouse(House h) {
        super(h);
    }

    private void painGreenOnWall() {
        logger.info(&quot;The wall is green now.&quot;);
    }

    @Override
    public void show() {
        super.show();
        painGreenOnWall();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FlowerHouse也是同理。它们的关键点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;必须创建构造函数，将House对象传入。&lt;/li&gt;
&lt;li&gt;在实现抽象方法时，直接调用House对象的show方法，同时加入自己的“装饰”内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;角色分析&quot;&gt;角色分析&lt;/h3&gt;
&lt;p&gt;装饰模式中重要的角色主要有两个，正是上面代码展示部分的那两个，他们可以总结为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Decorate类，它继承自构建基类，并不作任何具体动作，却是架构中重要的一环。&lt;/li&gt;
&lt;li&gt;ConcreteDecorate类，继承自Decorate类，作具体的扩展功能。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;优势&quot;&gt;优势&lt;/h3&gt;
&lt;p&gt;装饰模式的架构平淡无奇，但是却可以不断套用，我们来看客户端的调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package pattern.decorate;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.Test;

public class Client {
    public final static Logger logger = LogManager.getLogger();

    @Test
    public void testDecorate() {
        House a = new Apartment();
        a.show();
        logger.info(&quot;---------------&quot;);
        House aPlus = new GreenWallHouse(a);
        aPlus.show();
        logger.info(&quot;---------------&quot;);
        /**
         * 因为他们都继承了House，是同一个基类，所以可以无限套用装饰类去循环。
         */
        House aPPlus = new GreenWallHouse(new FlowerHouse(a));
        aPPlus.show();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;14:38:45[show]: This is my apartment, which is on the high floor.
14:38:45[testDecorate]: ---------------
14:38:45[show]: This is my apartment, which is on the high floor.
14:38:45[painGreenOnWall]: The wall is green now.
14:38:45[testDecorate]: ---------------
14:38:45[show]: This is my apartment, which is on the high floor.
14:38:45[decorateFlowerAround]: The room is full of flowers now.
14:38:45[painGreenOnWall]: The wall is green now.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于装饰模式中所有新增的类都是构建类的子类，并且他们每个类都声明了以构建类对象为参数的构造函数，因此，具体装饰类可以直接套用拓展，正如以上代码所示。&lt;/p&gt;
&lt;p&gt;装饰模式，符合了面向对象设计原则“对修改关闭，对拓展开放”的原则。在原有代码完全不改动的情况下，可以有效拓展系统功能。并且通过不断的套用构造函数的方式，使得原始构建类得到了多层的功能拓展，这有效地代替了多继承。在JavaIO中，装饰模式得到了广泛使用。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 07:20:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/decorate.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(六)图元组件 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/7909578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/7909578.html</guid>
<description>&lt;div&gt;
&lt;p class=&quot;PublishStatus&quot;&gt;&lt;span&gt;&lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;图元概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;图元是构成人机界面的基本单元。如一个个的电机、设备、数据显示、仪表盘，都是图元。构建人机界面的过程就是铺排、挪移、定位图元的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图元设计是绘图和编码的结合。因为图元不仅有显示和动画，还有背后操纵动画的控制逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个好的图元设计框架，应该最大限度提高设计的效率和专业程度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为你找到一个会做美工的码农，和会写代码的美工，都很困难，但是单独找码农和绘图员却一抓一大把。所以专业性意味着用人的灵活性，和省钱。&lt;/span&gt;&lt;span&gt;而你招来一个美工，一个码农，合作完成一个图元组件，必须考虑减少两人的交互，最好埋头各干各的。并行作业，才有最高效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过以下手段提高界面开发效率：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;前后端分离&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;前后端分离的设计模式有很多优点。前后端对设计者的要求是不同的。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前端设计者需要考虑的是界面更直观、美观、清晰、大气，可以熟练使用绘图工具（例如Blend），可以不会编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后端设计者要考虑的是业务逻辑，如何有条不紊、准确执行。可以不会画图，但一般必然熟练编码，使用设计工具（如Visual Studio）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前后端分离便于设计者术业有专攻，前后端分工协作，互不干扰，并行工作，提高效率。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;专业的前端设计工具&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于绘图员或美工，一个简单易用、同时又有强大功能的趁手设计器是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绘图板、动画、整合、调色板，美工的全套装备必须齐全；网格定位、缩放、旋转、保存、撤销，常规的设计器功能必须应有尽有。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;尽可能少的编码&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;很多行业都有庞大的图元库。各种设备、开关、构件，各种非标组件，不断会有新的图元入库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，力求用最少的代码实现尽可能多的功能，最大限度提升开发效率。一个强大的基类和一个方便的继承是必要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;前后端分离的设计模式&lt;/span&gt;式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;通过&lt;/strong&gt;&lt;strong&gt;WPF&lt;/strong&gt;&lt;strong&gt;实现前后端分离&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;看看百度百科对WPF的介绍：WPF（Windows Presentation Foundation）是微软推出的基于Windows 的用户界面框架，属于.NET Framework 3.0的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它提供了统一的编程模型、语言和框架，真正做到了分离界面设计人员与开发人员的工作；同时它提供了全新的多媒体交互用户图形界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WPF通过一种MVVM（Model-View-ViewMode）的设计模式实现界面与编码解耦。界面元素的颜色、动画、形状，可以方便的与代码类的属性绑定（Binding）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绑定的便利在于，后台类的某属性变化，马上会自动反映到界面的变化，无需编写代码；界面元素的变化，也马上会触发属性值的改变，这种方式天然适合人机界面的前后端分离设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，WPF提供XAML文件，是一种声明式编程方式，类似于Android的界面文件、HTML，界面设计者与代码编写者只需要通过XAML文件交互，进一步达成前后端分离并行作业的目的。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;strong&gt;前后端交互的内容&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;绘图员的工作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用Blend绘图，使用故事板（&lt;span&gt;Storyboard&lt;/span&gt;）制作动画，定义动画的视图状态（&lt;span&gt;VisualState&lt;/span&gt;），&lt;/span&gt;&lt;span&gt;绑定属性如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding BinName, RelativeSource={RelativeSource TemplatedParent}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;码农的工作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个&lt;span&gt;CustomControl&lt;/span&gt;。继承&lt;span&gt;HMIControlBase&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义依赖项属性如Running：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty RunningProperty =&lt;span&gt; DependencyProperty.Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;bool&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Elevator),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FrameworkPropertyMetadata(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, FrameworkPropertyMetadataOptions.AffectsRender,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PropertyChangedCallback(OnValueChanged)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;属性变化事件切换视图状态如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
VisualStateManager.GoToState(&lt;span&gt;this&lt;/span&gt;, _funcRun () ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就这么简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;绘图与动画&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;强大的设计工具：&lt;/strong&gt;&lt;strong&gt;Blend&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Blend是VS2010起微软提供的专业设计工具。早期曾经有三贱客（Blend,Design, Encoder ），后两者已经合并入Blend。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Expression Blend 中，可以在美工板上绘制形状、路径和控件，然后修改其外观和行为，从而直观地设计界面元素。可以导入图像、视频和声音，还可以导入和更改三维对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以创建&lt;span&gt;Storyboard&lt;/span&gt;实现帧动画，定义状态（&lt;span&gt;VisualState&lt;/span&gt;），并设计触发器（&lt;span&gt;Trigger&lt;/span&gt;）触发动画。还可以定义样式（&lt;span&gt;Style&lt;/span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Blend对美工人员是简单易上手的。按我的经验，对于习惯AutoCAD工具的绘图工程师，熟练掌握Blend一般在两周内，就可以绘制复杂的动画图形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的图元组件均为&lt;span&gt;CustomControl&lt;/span&gt;类型，这样编辑好的图元文件会自动加入到Generic.xaml文件。相应的图元模板可在Blend内重新编辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201711/43917-20171128143543581-571968289.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;用代码实现动画&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果不用Blend，也可以用代码直接实现动画。部分对性能要求高、使用频繁的图元组件如Guage，LinkLine，可以继承&lt;span&gt;Control&lt;/span&gt;的OnRender方法并使用&lt;span&gt;StreamGeometry&lt;/span&gt;这类的底层API绘图，以达到最佳的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;StreamGeometry&lt;/span&gt;的优点是调用底层绘图API，不生成多余的对象，而Blend在生成图形过程中有大量冗余元素和对象，复杂的层次结构，在对性能要求较高的场合略显笨重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;强大的图元基类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了尽可能减少编码，需要在图元基类（&lt;span&gt;HMIControlBase&lt;/span&gt;） 中实现尽可能多的功能；但又不能包办一切，牺牲图元自身的“个性”。要实现简洁、强大、可扩展。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，我在图元基类实现了所有界面元素共有的几个基本功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了实现方便的连线，需要能自行设置图元的锚点，作为拖放连线的连接点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201711/43917-20171128143349972-610075151.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继承GetLinkPositions方法，锚点分上下左右四个，每个锚点用一个&lt;span&gt;Point&lt;/span&gt;确定相对位置。如果只有一个锚点，就返回单一的&lt;span&gt;LinkPosition&lt;/span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; LinkPosition[] GetLinkPositions()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LinkPosition[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
                { 
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;  LinkPosition(&lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;0.75&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;),ConnectOrientation.Top),
                };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;绑定变量表达式。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;只要继承基类，就可以弹出变量组态界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201711/43917-20171128143233597-1590798402.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以自行定义左边的属性树。即继承GetActions方法。注意这个树状结构支持嵌套，如某设备带两个电机（&lt;span&gt;Motor&lt;/span&gt;），则电机的属性列表会作为树的子节点显示。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] GetActions()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] { TagActions.VISIBLE, TagActions.CAPTION, TagActions.RUN, TagActions.ALARM, TagActions.DEVICENAME };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;动画显示。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;继承SetTagReader方法，只要相关Tag变化，就会触发动画脚本。如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Action SetTagReader(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, Delegate tagChanged)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (key)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TagActions.RUN:
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _funcInRun = tagChanged &lt;span&gt;as&lt;/span&gt; Func&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_funcInRun != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; { VisualStateManager.GoToState(&lt;span&gt;this&lt;/span&gt;, _funcInRun() ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NotRunning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;); };
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.SetTagReader(key, tagChanged);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;VisualStateManager.GoToState方法根据不同的状态字，触发了在Blend里定义的故事板动画。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、  &lt;/strong&gt; &lt;strong&gt;如何实现：增加新图元&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图元设计流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201711/43917-20171128142412503-1472800462.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;646&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网关层接口概述&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下位机通讯原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何实现一个设备驱动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何设计图元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VS插件模块及原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归档模块及文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何进行功能扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组态变量表达式实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。QQ群：102486275&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 06:58:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/7909578.html</dc:identifier>
</item>
<item>
<title>Java URL类踩坑指南 - 戎码半生</title>
<link>http://www.cnblogs.com/zhaoyu1995/p/7909849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoyu1995/p/7909849.html</guid>
<description>&lt;p&gt;最近再做一个RSS阅读工具给自己用，其中一个环节是从服务器端获取一个包含了RSS源列表的json文件，再根据这个json文件下载、解析RSS内容。核心代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PresenterImpl&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; context: Context, &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; activity: MainActivity) : IPresenter {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; URL_API = &lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io/others/rssreader/RSS.json&quot;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;getRssResource&lt;/span&gt;(): RssSource {
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; gson = &lt;span class=&quot;fu&quot;&gt;GsonBuilder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;()
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; gson.&lt;span class=&quot;fu&quot;&gt;fromJson&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getFromNet&lt;/span&gt;(URL_API), RssSource::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;)
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;getFromNet&lt;/span&gt;(url: String): String {
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; result = URL(url).&lt;span class=&quot;fu&quot;&gt;readText&lt;/span&gt;()
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result
    }

    ......
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前一直执行地很好，直到前两天我购买了一个&lt;code&gt;vimerzhao.top&lt;/code&gt;的域名，并将原来的域名&lt;code&gt;vimerzhao.github.io&lt;/code&gt;重定向到了&lt;code&gt;vimerzhao.top&lt;/code&gt;。这个工具就无法使用了，但在浏览器输入&lt;code&gt;URL_API&lt;/code&gt;却能得到数据：&lt;br/&gt;&lt;img src=&quot;http://ond7j4cnz.bkt.clouddn.com/2017-11-26java_url_01.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那为什么&lt;code&gt;URL.readText()&lt;/code&gt;没有拿到数据呢？&lt;/p&gt;

&lt;p&gt;可以通过下面代码测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestRedirect {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            URL url1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io/others/rssreader/RSS.json&quot;&lt;/span&gt;);
            URL url2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;http://vimerzhao.top/others/rssreader/RSS.json&quot;&lt;/span&gt;);
            &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(url1);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;=--------------------------------=&quot;&lt;/span&gt;);
            &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(url2);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(URL url) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(
                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(url.&lt;span class=&quot;fu&quot;&gt;openStream&lt;/span&gt;()));

            String inputLine;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((inputLine = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(inputLine);
            }
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;301 Moved Permanently&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body bgcolor=&quot;white&quot;&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;301 Moved Permanently&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
=--------------------------------=
{&quot;theme&quot;:&quot;tech&quot;,&quot;author&quot;:&quot;zhaoyu&quot;,&quot;email&quot;:&quot;dutzhaoyu@gmail.com&quot;,&quot;version&quot;:&quot;0.01&quot;,&quot;contents&quot;:[{&quot;category&quot;:&quot;综合版块&quot;,&quot;websites&quot;:[{&quot;tag&quot;:&quot;门户网站&quot;,&quot;url&quot;:[&quot;http://geek.csdn.net/admin/news_service/rss&quot;,&quot;http://blog.jobbole.com/feed/&quot;,&quot;http://feed.cnblogs.com/blog/sitehome/rss&quot;,&quot;https://segmentfault.com/feeds&quot;,&quot;http://www.codeceo.com/article/category/pick/feed&quot;]},{&quot;tag&quot;:&quot;知名社区&quot;,&quot;url&quot;:[&quot;https://stackoverflow.com/feeds&quot;,&quot;https://www.v2ex.com/index.xml&quot;]},{&quot;tag&quot;:&quot;官方博客&quot;,&quot;url&quot;:[&quot;https://www.blog.google/rss/&quot;,&quot;https://blog.jetbrains.com/feed/&quot;]},{&quot;tag&quot;:&quot;个人博客-行业&quot;,&quot;url&quot;:[&quot;http://feed.williamlong.info/&quot;,&quot;https://www.liaoxuefeng.com/feed/articles&quot;]},{&quot;tag&quot;:&quot;个人博客-学术&quot;,&quot;url&quot;:[&quot;http://www.norvig.com/rss-feed.xml&quot;]}]},{&quot;category&quot;:&quot;编程语言&quot;,&quot;websites&quot;:[{&quot;tag&quot;:&quot;Kotlin&quot;,&quot;url&quot;:[&quot;https://kotliner.cn/api/rss/latest&quot;]},{&quot;tag&quot;:&quot;Python&quot;,&quot;url&quot;:[&quot;https://www.python.org/dev/peps/peps.rss/&quot;]},{&quot;tag&quot;:&quot;Java&quot;,&quot;url&quot;:[&quot;http://www.codeceo.com/article/category/develop/java/feed&quot;]}]},{&quot;category&quot;:&quot;行业动态&quot;,&quot;websites&quot;:[{&quot;tag&quot;:&quot;Android&quot;,&quot;url&quot;:[&quot;http://www.codeceo.com/article/category/develop/android/feed&quot;]}]},{&quot;category&quot;:&quot;乱七八遭&quot;,&quot;websites&quot;:[{&quot;tag&quot;:&quot;Linux-综合&quot;,&quot;url&quot;:[&quot;https://linux.cn/rss.xml&quot;,&quot;http://www.linuxidc.com/rssFeed.aspx&quot;,&quot;http://www.codeceo.com/article/tag/linux/feed&quot;]},{&quot;tag&quot;:&quot;Linux-发行版&quot;,&quot;url&quot;:[&quot;https://blog.linuxmint.com/?feed=rss2&quot;,&quot;https://manjaro.github.io/feed.xml&quot;]}]}]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP返回码301，即发生了重定向。可在浏览器上这个过程太快以至于我们看不到这个301界面的出现。这里需要说明的是&lt;code&gt;URL.readText()&lt;/code&gt;是Kotlin中一个&lt;code&gt;扩展函数&lt;/code&gt;，本质还是调用了&lt;code&gt;URL&lt;/code&gt;类的&lt;code&gt;openStream&lt;/code&gt;方法，部分源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;.....
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Reads the entire content of this URL as a String using UTF-8 or the specified [charset].&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * This method is not recommended on huge files.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param charset &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a character set to use.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a string with this URL entire content.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
@kotlin.&lt;span class=&quot;fu&quot;&gt;internal&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; inline fun URL.&lt;span class=&quot;fu&quot;&gt;readText&lt;/span&gt;(charset: Charset = Charsets.&lt;span class=&quot;fu&quot;&gt;UTF_8&lt;/span&gt;): String = &lt;span class=&quot;fu&quot;&gt;readBytes&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(charset)

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Reads the entire content of the URL as byte array.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * This method is not recommended on huge files.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a byte array with this URL entire content.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; fun URL.&lt;span class=&quot;fu&quot;&gt;readBytes&lt;/span&gt;(): ByteArray = &lt;span class=&quot;fu&quot;&gt;openStream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;use&lt;/span&gt; { it.&lt;span class=&quot;fu&quot;&gt;readBytes&lt;/span&gt;() }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以上面的测试代码即说明了&lt;code&gt;URL.readText()&lt;/code&gt;失败的原因。&lt;br/&gt;不过&lt;code&gt;URL&lt;/code&gt;不支持重定向是否合理？为什么不支持？还有待探究。&lt;/p&gt;

&lt;p&gt;首先看下&lt;code&gt;equals&lt;/code&gt;的说明(&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/&quot;&gt;URL (Java Platform SE 7 )&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Compares this URL for equality with another object.&lt;br/&gt;If the given object is not a URL then this method immediately returns false.&lt;br/&gt;Two URL objects are equal if they have the same protocol, reference equivalent hosts, have the same port number on the host, and the same file and fragment of the file.&lt;br/&gt;Two hosts are considered equivalent if both host names can be resolved into the same IP addresses; else if either host name can't be resolved, the host names must be equal without regard to case; or both host names equal to null.&lt;br/&gt;Since hosts comparison requires name resolution, this operation is a blocking operation.&lt;br/&gt;Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来再看一段代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestEquals {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// vimerzhao的博客主页&lt;/span&gt;
            URL url1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io/&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// zhanglanqing的博客主页&lt;/span&gt;
            URL url2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://zhanglanqing.github.io/&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// vimerzhao博客主页重定向后的域名&lt;/span&gt;
            URL url3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;http://vimerzhao.top/&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url1.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(url2));
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url1.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(url3));
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据定义输出结果是什么呢？运行之后是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能猜对了，但如果我把电脑&lt;strong&gt;断网&lt;/strong&gt;之后再次执行，结果却是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;false
false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但其实3个域名的IP地址都是相同的，可以&lt;code&gt;ping&lt;/code&gt;一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zhaoyu@Inspiron ~/Project $ ping vimezhao.github.io
PING sni.github.map.fastly.net (151.101.77.147) 56(84) bytes of data.
64 bytes from 151.101.77.147: icmp_seq=1 ttl=44 time=396 ms
^C
--- sni.github.map.fastly.net ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 396.692/396.692/396.692/0.000 ms
zhaoyu@Inspiron ~/Project $ ping zhanglanqing.github.io
PING sni.github.map.fastly.net (151.101.77.147) 56(84) bytes of data.
64 bytes from 151.101.77.147: icmp_seq=1 ttl=44 time=396 ms
^C
--- sni.github.map.fastly.net ping statistics ---
2 packets transmitted, 1 received, 50% packet loss, time 1000ms
rtt min/avg/max/mdev = 396.009/396.009/396.009/0.000 ms
zhaoyu@Inspiron ~/Project $ ping vimezhao.top
ping: unknown host vimezhao.top
zhaoyu@Inspiron ~/Project $ ping vimerzhao.top
PING sni.github.map.fastly.net (151.101.77.147) 56(84) bytes of data.
64 bytes from 151.101.77.147: icmp_seq=1 ttl=44 time=409 ms
^C
--- sni.github.map.fastly.net ping statistics ---
2 packets transmitted, 1 received, 50% packet loss, time 1001ms
rtt min/avg/max/mdev = 409.978/409.978/409.978/0.000 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看一下有网络连接的情况，&lt;code&gt;vimerzhao.github.io&lt;/code&gt;和&lt;code&gt;zhanglanqing.github.io&lt;/code&gt;是我和我同学的博客，虽然内容不一样但是指向相同的IP，协议、端口等都相同，所以相等了；而&lt;code&gt;vimerzhao.github.io&lt;/code&gt;虽然和&lt;code&gt;vimerzhao.top&lt;/code&gt;指向同一个博客，但是一个是&lt;code&gt;https&lt;/code&gt;一个是&lt;code&gt;http&lt;/code&gt;，协议不同，所以判断为不相等。&lt;strong&gt;相信这和大多数人的直觉是相背的&lt;/strong&gt;：指向不同博客的URL相等了，但指向相同博客的URL却不相等！&lt;br/&gt;再分析断网之后的结果：首先查看&lt;code&gt;URL&lt;/code&gt;的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object obj) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!(obj &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; URL))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        URL u2 = (URL)obj;

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; handler.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, u2);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看&lt;code&gt;handler&lt;/code&gt;对象的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(URL u1, URL u2) {
        String ref1 = u1.&lt;span class=&quot;fu&quot;&gt;getRef&lt;/span&gt;();
        String ref2 = u2.&lt;span class=&quot;fu&quot;&gt;getRef&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (ref1 == ref2 || (ref1 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ref1.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(ref2))) &amp;amp;&amp;amp;
               &lt;span class=&quot;fu&quot;&gt;sameFile&lt;/span&gt;(u1, u2);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;sameFile&lt;/code&gt;源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sameFile&lt;/span&gt;(URL u1, URL u2) {
        &lt;span class=&quot;co&quot;&gt;// Compare the protocols.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!((u1.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;() == u2.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;()) ||
              (u1.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
               u1.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equalsIgnoreCase&lt;/span&gt;(u2.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;()))))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// Compare the files.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!(u1.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;() == u2.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;() ||
              (u1.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; u1.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(u2.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;()))))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// Compare the ports.&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port1, port2;
        port1 = (u1.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;() != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) ? u1.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;() : u1.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getDefaultPort&lt;/span&gt;();
        port2 = (u2.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;() != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) ? u2.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;() : u2.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getDefaultPort&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (port1 != port2)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// Compare the hosts.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;hostsEqual&lt;/span&gt;(u1, u2))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;// 无网络连接时会触发这一句&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后是&lt;code&gt;hostsEqual&lt;/code&gt;的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hostsEqual&lt;/span&gt;(URL u1, URL u2) {
        InetAddress a1 = &lt;span class=&quot;fu&quot;&gt;getHostAddress&lt;/span&gt;(u1);
        InetAddress a2 = &lt;span class=&quot;fu&quot;&gt;getHostAddress&lt;/span&gt;(u2);
        &lt;span class=&quot;co&quot;&gt;// if we have internet address for both, compare them&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a1 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; a2 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; a1.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(a2);
        &lt;span class=&quot;co&quot;&gt;// else, if both have host names, compare them&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (u1.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; u2.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; u1.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equalsIgnoreCase&lt;/span&gt;(u2.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;());
         &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; u1.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;() == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; u2.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;() == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在有网络的情况下，&lt;code&gt;a1&lt;/code&gt;和&lt;code&gt;a2&lt;/code&gt;都不是&lt;code&gt;null&lt;/code&gt;所以会触发&lt;code&gt;return a1.equals(a2)&lt;/code&gt;，返回&lt;code&gt;true&lt;/code&gt;；而没有网络时则会触发&lt;code&gt;return u1.getHost().equalsIgnoreCase(u2.getHost());&lt;/code&gt;即第二个判断，显然&lt;code&gt;url1&lt;/code&gt;的&lt;code&gt;host&lt;/code&gt;（&lt;code&gt;vimerzhao.github.io&lt;/code&gt;）和&lt;code&gt;url2&lt;/code&gt;的&lt;code&gt;host&lt;/code&gt;（&lt;code&gt;zhanglanqing.github.io&lt;/code&gt;）不等，所以返回&lt;code&gt;false&lt;/code&gt;，导致&lt;code&gt;if (!hostsEqual(u1, u2))&lt;/code&gt;判断为真，&lt;code&gt;return false&lt;/code&gt;执行。&lt;br/&gt;可见，&lt;code&gt;URL&lt;/code&gt;类的&lt;code&gt;equals&lt;/code&gt;方法不仅违反直觉还缺乏一致性，在不同环境会有不同结果，十分危险！&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;equals&lt;/code&gt;还是个耗时的操作，因为在有网络的情况下需要进行DNS解析，&lt;code&gt;hashCode()&lt;/code&gt;同理，这里以&lt;code&gt;hashCode()&lt;/code&gt;为例说明。&lt;code&gt;URL&lt;/code&gt;类的&lt;code&gt;hashCode()&lt;/code&gt;源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hashCode != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; hashCode;

        hashCode = handler.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; hashCode;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;handler&lt;/code&gt;对象的&lt;code&gt;hashCode()&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;(URL u) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// Generate the protocol part.&lt;/span&gt;
        String protocol = u.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (protocol != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            h += protocol.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// Generate the host part.&lt;/span&gt;
        InetAddress addr = &lt;span class=&quot;fu&quot;&gt;getHostAddress&lt;/span&gt;(u);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (addr != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            h += addr.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            String host = u.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (host != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                h += host.&lt;span class=&quot;fu&quot;&gt;toLowerCase&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();
        }

        &lt;span class=&quot;co&quot;&gt;// Generate the file part.&lt;/span&gt;
        String file = u.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (file != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            h += file.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// Generate the port part.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (u.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;() == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            h += &lt;span class=&quot;fu&quot;&gt;getDefaultPort&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            h += u.&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// Generate the ref part.&lt;/span&gt;
        String ref = u.&lt;span class=&quot;fu&quot;&gt;getRef&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ref != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            h += ref.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;getHostAddress()&lt;/code&gt;会消耗大量时间。所以，如果在基于哈希表的容器中存储&lt;code&gt;URL&lt;/code&gt;对象，简直就是灾难。下面这段代码，对比了&lt;code&gt;URL&lt;/code&gt;和&lt;code&gt;URI&lt;/code&gt;在存储50次时的表现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestHash {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        HashSet&amp;lt;URL&amp;gt; list1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
        HashSet&amp;lt;URI&amp;gt; list2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            URL url1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io/&quot;&lt;/span&gt;);
            URI url2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URI(&lt;span class=&quot;st&quot;&gt;&quot;https://zhanglanqing.github.io/&quot;&lt;/span&gt;);
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; cur = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cnt = &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cnt; i++) {
                list1.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(url1);
            }
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - cur);
            cur = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cnt; i++) {
                list2.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(url2);
            }
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - cur);

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;271
0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，基于哈希表实现的容器最好不要用&lt;code&gt;URL&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所谓&lt;code&gt;TrailingSlash&lt;/code&gt;就是域名结尾的斜杠。比如我们在浏览器看到&lt;code&gt;vimerzhao.top&lt;/code&gt;,复制后粘贴发现是&lt;code&gt;http://vimerzhao.top/&lt;/code&gt;。首先用下面代码测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestTrailingSlash {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            URL url1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io/&quot;&lt;/span&gt;);
            URL url2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;https://vimerzhao.github.io&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url1.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(url2));
            &lt;span class=&quot;fu&quot;&gt;outputInfo&lt;/span&gt;(url1);
            &lt;span class=&quot;fu&quot;&gt;outputInfo&lt;/span&gt;(url2);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;outputInfo&lt;/span&gt;(URL url) {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------&quot;&lt;/span&gt; + url.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;----------&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url.&lt;span class=&quot;fu&quot;&gt;getRef&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url.&lt;span class=&quot;fu&quot;&gt;getFile&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(url.&lt;span class=&quot;fu&quot;&gt;getHost&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;----------------&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;false
------https://vimerzhao.github.io/----------
null
/
vimerzhao.github.io
----------------
------https://vimerzhao.github.io----------
null

vimerzhao.github.io
----------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，无论用前面的&lt;code&gt;read()&lt;/code&gt;方法读或者地址栏直接输入url，&lt;code&gt;url1&lt;/code&gt;和&lt;code&gt;url2&lt;/code&gt;的&lt;strong&gt;内容都是相同的&lt;/strong&gt;，但是加&lt;code&gt;/&lt;/code&gt;表示这是一个目录，不加表示这是一个文件，所以二者&lt;code&gt;getFile()&lt;/code&gt;的结果不同，导致&lt;code&gt;equals&lt;/code&gt;判断为&lt;code&gt;false&lt;/code&gt;。在地址栏输入时甚至不会觉察到这个&lt;code&gt;TrailingSlash&lt;/code&gt;，所返回的结果也一样，但&lt;code&gt;equals&lt;/code&gt;判断竟然为&lt;code&gt;false&lt;/code&gt;，真是防不胜防！&lt;br/&gt;这里还有一个问题就是：一个是文件，令一个是目录，为什么都能得到相同结果？&lt;br/&gt;调查一番后发现：其实再请求的时候如果有&lt;code&gt;/&lt;/code&gt;，那么就会在这个目录下找&lt;code&gt;index.html&lt;/code&gt;文件；如果没有，以&lt;code&gt;vimerzhao.top/tags&lt;/code&gt;为例，则会先找&lt;code&gt;tags&lt;/code&gt;，如果找不到就会自动在后面添加一个&lt;code&gt;/&lt;/code&gt;，再在&lt;code&gt;tags&lt;/code&gt;目录下找&lt;code&gt;index.html&lt;/code&gt;文件。如图：&lt;br/&gt;&lt;img src=&quot;http://ond7j4cnz.bkt.clouddn.com/2017-11-26java_url_02.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有一个有趣的测试，编写两段代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestTrailingSlash {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            URL urlWithSlash = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;http://vimerzhao.top/tags/&quot;&lt;/span&gt;);
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cnt = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; cur = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cnt; i++) {
                &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(urlWithSlash);
            }
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - cur);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(URL url) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(
                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(url.&lt;span class=&quot;fu&quot;&gt;openStream&lt;/span&gt;()));

            String inputLine;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((inputLine = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;//System.out.println(inputLine);&lt;/span&gt;
            }
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestWithoutTrailingSlash {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String args[]) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            URL urlWithoutSlash = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;http://vimerzhao.top/tags&quot;&lt;/span&gt;);
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cnt = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; cur = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cnt; i++) {
                &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(urlWithoutSlash);
            }
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - cur);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(URL url) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            BufferedReader in = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(
                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(url.&lt;span class=&quot;fu&quot;&gt;openStream&lt;/span&gt;()));

            String inputLine;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((inputLine = in.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;//System.out.println(inputLine);&lt;/span&gt;
            }
            in.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用如下脚本测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;i&lt;/span&gt; in &lt;span class=&quot;dt&quot;&gt;{1..20}&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;java&lt;/span&gt; TestTrailingSlash &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; out1
    &lt;span class=&quot;kw&quot;&gt;java&lt;/span&gt; TestWithoutTrailingSlash &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; out2
&lt;span class=&quot;kw&quot;&gt;done&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将输出的时间做成表格：&lt;br/&gt;&lt;img src=&quot;http://ond7j4cnz.bkt.clouddn.com/2017-11-26java_url_03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，添加了&lt;code&gt;/&lt;/code&gt;的速度更快，这是因为&lt;strong&gt;省去了查找是否有&lt;code&gt;tags&lt;/code&gt;文件的操作&lt;/strong&gt;。这也给我们启发：URL结尾的&lt;code&gt;/&lt;/code&gt;最好还是加上！&lt;/p&gt;
&lt;p&gt;以上，本周末发现的一些坑。&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 06:40:00 +0000</pubDate>
<dc:creator>戎码半生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaoyu1995/p/7909849.html</dc:identifier>
</item>
<item>
<title>redux中间件的原理——从懵逼到恍然大悟 - 钱天兵</title>
<link>http://www.cnblogs.com/wshiqtb/p/7909770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wshiqtb/p/7909770.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;react已经出来很久了，其生态圈之庞大，一锅炖不下！各种react-xx，已让我们不堪重负，github上随便一个demo，引入的模块至少都是五指之数+。看着头疼，嚼之无味……。&lt;br/&gt;在此建议新学者，可以从基础的核心模块学起，前期不要考虑那些数量繁多的马仔小弟，边学边写，个人感觉前期核心要学的流程大致如下：&lt;br/&gt;React ——&amp;gt; React + redux + React-redux ——&amp;gt; React + redux + React-redux + React-router ——&amp;gt; React + redux + React-redux + React-router ；&lt;br/&gt;其它的，看情况学习和了解，我也很菜，以上感悟都是针对初学者，希望可以减少他们在学习过程中接触过多的东西，而影响学习信心和乐趣。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://huziketang.com/books/react/&quot; target=&quot;_blank&quot;&gt;React小书&lt;/a&gt;（作者从无到有，讲述了React的起源，通俗易懂）&lt;span&gt;&lt;span&gt;Note:&lt;/span&gt; 第三阶段的文档现在开始收费查看了，不过对于搞前端的人来说不用钱也可以来个亲密接触的(大家自己想办法)&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/kenberkeley/redux-simple-tutorial&quot; target=&quot;_blank&quot;&gt;Redux莞式教程&lt;/a&gt;（抛开需求讲实用性都是耍流氓，作者扮演一位PM给我们上了生动的一课，深入浅出，简明扼要）&lt;br/&gt;&lt;a href=&quot;http://react-guide.github.io/react-router-cn/&quot; target=&quot;_blank&quot;&gt;React-Router文档&lt;/a&gt;（一部中规中矩的翻译之作）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上是整理的一些说明和文档资料，没有看过的可以去了解一下。下面将开始本文的主题：redux的中间件applyMiddleware。&lt;/p&gt;
&lt;p&gt;都说名字越长，越让学者害怕，applyMiddleware的名字看起来就挺吓人，那么为什么会出现中间件，它是做什么的？它为什么叫中间件？为什么说可以用来解决异步dispatch？经过一段时间的了解，让我渐渐明白了它的工作原理，现在让我们带问题，怀着简单，轻松的心态走进applyMiddleware大讲堂：&lt;/p&gt;

&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;17&quot;&gt;为什么会出现中间件？&lt;br/&gt;我们知道redux的核心，就是控制和管理所有的数据输入输出，因此有了dispatch，由于dispatch是一个很纯的纯函数，就是单纯的派发action来更改数据，其功能简单且固定。&lt;br/&gt;假如现在产品经理A某有个需求，要求记录每次的dispatch记录，我们怎么办呢？最简单直接的办法就是在每一个dispatch的前面加上：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log('dispatching'&lt;span&gt;, action);
dispatch(action)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 假如又来一个产品B说，我需要记录每次数据出错的原因，我们怎么办呢？然后我们又需要在对每一个dispatch做修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
  dispatch(action)    
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(err){
  console.error(&lt;/span&gt;'错误报告: '&lt;span&gt;, err)  
}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们的程序中有很多的dispatch，我们就需要添加很多的重复代码，虽然编辑器提供批量替换，但这无疑是产生了很多样板代码。&lt;br/&gt;因为所有的需求都是和dispatch息息相关，所以只要我们把日志放进dispatch函数里，不就好了吗，我们只需要更改dispatch函数，把dispatch进行一层封装。&lt;br/&gt;大概的封装就是下面这样：&lt;span&gt;&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let next =&lt;span&gt; store.dispatch
store.dispatch &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dispatchAndLog(action) {
  console.log(&lt;/span&gt;'dispatching'&lt;span&gt;, action)
  next(action)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redux把这个封装的入口写成了一个函数，就叫applyMiddleware。&lt;br/&gt;由此我们明白了applyMiddleware的功能：改造dispatch函数，产生真假dispatch，而中间件就是运行在假真（dispatchAndLog&lt;span&gt;&lt;sup&gt;假&lt;/sup&gt;&lt;/span&gt;和next&lt;span&gt;&lt;sup&gt;真&lt;/sup&gt;&lt;/span&gt;）之间的代码。&lt;br/&gt;这里我们要对applyMiddleware进行一个准确的定义，它只是一个用来加工dispatch的工厂，而要加工什么样的dispatch出来，则需要我们传入对应的中间件函数（比如上例中的dispatchAndLog），下面我们构造一个精简版的applyMiddleware：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const applyMiddleware = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(middleware){
  let next &lt;/span&gt;=&lt;span&gt; store.dispatch;
  store.dispatch &lt;/span&gt;= middleware(store)(next);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里传入store，是因为中间件中有可能会用到getState获取数据，比如打印当前用户等需求&lt;/span&gt;
&lt;span&gt;}

applyMiddleware(dispatchAndLog)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;16.5&quot;&gt;中间件的串联融合。&lt;br/&gt;中间件的功能各不相同，它们都要融入到dispatch中，在派发action的时候，按照顺序一个个的执行，这是一个费脑经的事情。&lt;br/&gt;假如现在我们有两个中间件 logger和collectError两个中间件函数，那么大概的执行顺序就是 dispatch——&amp;gt;logger改造——&amp;gt;collectError改造。这里我们能看到后面的中间件需要接收到前面改造后的dispatch，&lt;br/&gt;在前面，我们是直接修改store.dispatch，现在我们换一种写法，让每一个中间件函数，接收一个dispatch，然后返回一个改造后的dispatch，来作为下一个中间件函数的next，以此类推，用ES6的写法大概代码如下：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const logger = store =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'dispatching'&lt;span&gt;, action)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action)
}

const collectError &lt;/span&gt;= store =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action)
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
    console.error(&lt;/span&gt;'Error!'&lt;span&gt;, err)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后，我们改造一下applyMiddleware，来接收一个middlewares数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; applyMiddleware(middlewares) {
  middlewares &lt;/span&gt;=&lt;span&gt; middlewares.slice()
  middlewares.reverse()

  let dispatch &lt;/span&gt;=&lt;span&gt; store.dispatch
  middlewares.forEach(middleware &lt;/span&gt;=&amp;gt;&lt;span&gt;
    dispatch &lt;/span&gt;=&lt;span&gt; middleware(store)(dispatch)
  )
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Object.assign({}, store, { dispatch })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的middleware(store)(dispatch) 就相当于是 const logger = store =&amp;gt; next =&amp;gt; {}，这就是构造后的dispatch，继续向下传递。这里middlewares.reverse()，进行数组反转的原因，是最后构造的dispatch，实际上是最先执行的。因为在applyMiddleware串联的时候，每个中间件只是返回一个新的dispatch函数给下一个中间件，实际上这个dispatch并不会执行。只有当我们在程序中通过store.dispatch(action)，真正派发的时候，才会执行。而此时的dispatch是最后一个中间件返回的包装函数。然后依次向前递推执行。&lt;br/&gt;我们拿logger和collectError来说明：&lt;/p&gt;&lt;p&gt;构造过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let next =&lt;span&gt; store.dispatch;
let dispatch1 &lt;/span&gt;=&lt;span&gt; logger(store)(next); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这时候的console.log('dispatching', action) 是没有执行的&lt;/span&gt;
&lt;span&gt;
let dispatch2 &lt;/span&gt;=&lt;span&gt; collectError(store)(dispatch1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这时候的console.log('Error!', err) 也是没有执行的&lt;/span&gt;
&lt;span&gt;
store.dispatch &lt;/span&gt;= dispatch2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
store.dispatch(action); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假如我们程序中派发了某个action&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于是下面这样&lt;/span&gt;
dispatch2(action); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时执行了 console.log('Error', err)&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于collectError中间件中的next是接收的logger返回函数即dispatch1，所以在开始执行&lt;/span&gt;
dispatch1(action); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时执行了 console.log('dispatching', action)&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个例子不太合理，因为错误报告是先 try 的 next(action)，但是正常的流程是如此。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 未完待续……&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Tue, 28 Nov 2017 06:28:00 +0000</pubDate>
<dc:creator>钱天兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wshiqtb/p/7909770.html</dc:identifier>
</item>
<item>
<title>IT连创业系列：App产品上线后，运营怎么搞？（上） - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/7906418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/7906418.html</guid>
<description>&lt;p&gt;又是一阵一阵的时光过去了，今夜，码的不是代码，是文字，继续和大伙分享创业的这一路历程。&lt;/p&gt;
&lt;p&gt;话说，在突破技术的领域，IT连和IT恋上线后，慢慢走上运营这条路时，发现自己经常容易迷失。&lt;/p&gt;
&lt;p&gt;毕竟，做为一名技术型创业者，攻克产品第一关不是问题，但第二关运营，却不是我所长。&lt;/p&gt;
&lt;p&gt;于是乎：招人啊！！！！&lt;/p&gt;
&lt;p&gt;于是乎：没钱啊！！！！&lt;/p&gt;
&lt;p&gt;好吧，那就招几个新人吧，该花的钱还是逃不了的！！！！&lt;/p&gt;
&lt;p&gt;然后，好不容易招来一个帅哥，和他说，给你两星期，给我弄1000个美女过来，都要这么美的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127220335800-1143704863.jpg&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来的故事，在之前的文章里，有透露过 ：他是新人，很想有人带，自己搞不了事情。&lt;/p&gt;
&lt;p&gt;然后，花花花，一个多星期过去了，美女没见着几个，说好的活动，定好的方案，也没见有任何动作。&lt;/p&gt;
&lt;p&gt;最后，就只能送他去看看外面黄色夕阳的世界：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127220929362-1991973524.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人是送走了，又要开始迷之一般的思考了：&lt;/p&gt;
&lt;p&gt;招高手吧，成本太高，招新人吧，没人带，也不靠谱，这真是巧妇难为无米之炊啊！&lt;/p&gt;

&lt;p&gt;水花飘飘，那天降温了，突然灵光一闪，似乎罗汉降临〜〜〜&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127221657847-814842702.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;199&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对啊，是时候动用88位罗汉了（参与项目众筹的88位原始股东）。&lt;/p&gt;

&lt;p&gt;如何动用，这得细细思考：&lt;/p&gt;
&lt;p&gt;股东都分散在全国各个城市，如果按城市成立运营小组。&lt;/p&gt;
&lt;p&gt;一来减少成本，二来团队一下子就膨胀起来了。&lt;/p&gt;
&lt;p&gt;想想就感觉这世界很美好！！！&lt;/p&gt;

&lt;p&gt;该想的想能了，剩下的就是执行了：&lt;/p&gt;
&lt;p&gt;考虑到深圳的位置靠近广州，而且人数相对较多，于是把深圳做为试点。&lt;/p&gt;

&lt;p&gt;于是，定了个周末，去了趟深圳，组织七八个人集在一起，一个临时的运营小组就成立了。&lt;/p&gt;
&lt;p&gt;这个小组还选出一个位负责人和两个副的负责人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127222603519-1561060347.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当天的会议中，特别针对可现行，和可延后执行的计划，讲清楚了，然后，才放心的回的广州！&lt;/p&gt;
&lt;p&gt;然后过了几天，就听见深圳的负责人和我说：叫不动他们，自己也比较忙。&lt;/p&gt;
&lt;p&gt;再然后，就过了一个国庆的假了〜〜〜〜&lt;/p&gt;
&lt;p&gt;已经可以明显感觉到无法执行下去了，负责人也时不时的消失了。&lt;/p&gt;

&lt;p&gt;既然是试点，就要总结失败的原因，后来临时开了一个语音会议，约集几十个股东一起商讨。&lt;/p&gt;
&lt;p&gt;一场风暴后，总结大致如下：&lt;/p&gt;
&lt;p&gt;1：大伙都很忙，不一定有时间；&lt;/p&gt;
&lt;p&gt;2：每个人的付出不一样，渴望的回报不一样；&lt;/p&gt;
&lt;p&gt;3：没有上下级的关系，就算当了负责人，也难以调动其它人。&lt;/p&gt;
&lt;p&gt;4：运营经费问题； &lt;/p&gt;
&lt;p&gt;5：有些人并不想参与，不能强制；&lt;/p&gt;
&lt;p&gt;6：不能让股东执行过于复杂的任务；&lt;/p&gt;
&lt;p&gt;7：激情总是短暂的。&lt;/p&gt;

&lt;p&gt;另外，会议中也产生了针对这个问题的解决方案：&lt;strong&gt;积分系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，抽了几个晚上的时间，写了一个股东积分系统，大致就是发布任务，由股东接任务，领积分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127224639237-2081540025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，积分再况换一定比例的股份。&lt;/p&gt;
&lt;p&gt;方案出来了，系统也上线了，超过60%的股东开始参与了。&lt;/p&gt;
&lt;p&gt;然后，第一波激情暴发了，男性用户开始有所增长，但是缺乏美女啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201711/17408-20171127231214144-1314691089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，我们计划去一次富士康门口，拉一批美女回来（未完待续） &lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 06:12:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/7906418.html</dc:identifier>
</item>
<item>
<title>一个高性能异步socket封装库的实现思路 （c#） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/asyn_scoket.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/asyn_scoket.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;socket是软件之间通讯最常用的一种方式。c#实现socket通讯有很多中方法，其中效率最高就是异步通讯。&lt;/p&gt;
&lt;p&gt;异步通讯实际是利用windows完成端口（IOCP）来处理的，关于完成端口实现原理，大家可以参考网上文章。&lt;/p&gt;
&lt;p&gt;我这里想强调的是采用完成端口机制的异步通讯是windows下效率最高的通讯方式，没有之一！&lt;/p&gt;

&lt;p&gt;异步通讯比同步通讯处理要难很多，代码编写中会遇到许多“坑“。如果没有经验，很难完成。&lt;/p&gt;
&lt;p&gt;我搜集了大量资料，完成了对异步socket的封装。此库已用稳定高效的运行几个月。&lt;/p&gt;

&lt;p&gt;纵观网上的资料，我还没有遇到一个满意的封装库。许多文章把数据收发和协议处理杂糅在一块，代码非常难懂，也无法扩展。&lt;/p&gt;
&lt;p&gt;在编写该库时，避免以上缺陷。将逻辑处理层次化，模块化！同时实现了高可用性与高性能。&lt;/p&gt;

&lt;p&gt;为了使大家对通讯效率有初步了解，先看测试图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/245753/201711/245753-20171128153806331-394754752.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;主机配置情况&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/245753/201711/245753-20171128143403659-1133459102.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;百兆带宽基本占满，cpu占用40%，我的电脑在空闲时，cpu占用大概20%，也就是说程序占用cpu 20%左右。&lt;/p&gt;
&lt;p&gt;这个库是可扩展的，就是说即使10万个连接，收发同样的数据，cpu占用基本相同。&lt;/p&gt;

&lt;h2&gt;库的结构图 &lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/245753/201711/245753-20171128140402175-1274361274.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;即可作为服务端（监听）也可以作为客户端（主动连接）使用。&lt;/li&gt;
&lt;li&gt;可以适应任何网络协议。收发的数据针对字节流或一个完整的包。对协议内容不做处理。&lt;/li&gt;
&lt;li&gt;高可用性。将复杂的底层处理封装，对外接口非常友好。&lt;/li&gt;
&lt;li&gt;高性能。最大限度优化处理。单机可支持数万连接，收发速度可达几百兆bit。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络处理逻辑可以分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;网络监听   可以在多个端口实现监听。负责生成socket，生成的socket供后续处理。监听模块功能比较单一，如有必要，可对监听模块做进一步优化。&lt;/li&gt;
&lt;li&gt;主动连接  可以异步或同步的连接对方。连接成功后，对socket的后续处理，与监听得到的socket完全一样。注：无论是监听得到的socket，还是连接得到的socket，后续处理完全一样。&lt;/li&gt;
&lt;li&gt;Socket收发处理   每个socket对应一个收发实例，socket收发只针对字节流处理。收发时，做了优化。比如发送时，对数据做了沾包，提高发送性能；接收时，一次投递1K的数据。&lt;/li&gt;
&lt;li&gt;组包处理   一般数据包都有包长度指示；比如 报头的前俩个字节表示长度，根据这个值就可以组成一个完整的包。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt; NetListener 监听&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace IocpCore
{
    class NetListener
    {
        private Socket listenSocket;
        public ListenParam _listenParam { get; set; }
        public event Action&amp;lt;ListenParam, AsyncSocketClient&amp;gt; OnAcceptSocket;

        bool start;

        NetServer _netServer;
        public NetListener(NetServer netServer)
        {
            _netServer = netServer;
        }

        public int _acceptAsyncCount = 0;
        public bool StartListen()
        {
            try
            {
                start = true;
                IPEndPoint listenPoint = new IPEndPoint(IPAddress.Parse(&quot;0.0.0.0&quot;), _listenParam._port);
                listenSocket = new Socket(listenPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                listenSocket.Bind(listenPoint);
                listenSocket.Listen(200);

                Thread thread1 = new Thread(new ThreadStart(NetProcess));
                thread1.Start();
               
                StartAccept();
                return true;
            }
            catch (Exception ex)
            {
                NetLogger.Log(string.Format(&quot;**监听异常!{0}&quot;, ex.Message));
                return false;
            }
        }

        AutoResetEvent _acceptEvent = new AutoResetEvent(false);
        private void NetProcess()
        {
            while (start)
            {
                DealNewAccept();
                _acceptEvent.WaitOne(1000 * 10);
            }
        }

        private void DealNewAccept()
        {
            try
            {
                if(_acceptAsyncCount &amp;lt;= 10)
                {
                    StartAccept();
                }

                while (true)
                {
                    AsyncSocketClient client = _newSocketClientList.GetObj();
                    if (client == null)
                        break;

                    DealNewAccept(client);
                }
            }
            catch (Exception ex)
            {
                NetLogger.Log(string.Format(&quot;DealNewAccept 异常 {0}***{1}&quot;, ex.Message, ex.StackTrace));
            }
        }

        private void DealNewAccept(AsyncSocketClient client)
        {
            client.SendBufferByteCount = _netServer.SendBufferBytePerClient;
           OnAcceptSocket?.Invoke(_listenParam, client);
        }

        private void AcceptEventArg_Completed(object sender, SocketAsyncEventArgs acceptEventArgs)
        {
            try
            {
                Interlocked.Decrement(ref _acceptAsyncCount);
                _acceptEvent.Set();
                acceptEventArgs.Completed -= AcceptEventArg_Completed;
                ProcessAccept(acceptEventArgs);
            }
            catch (Exception ex)
            {
                NetLogger.Log(string.Format(&quot;AcceptEventArg_Completed {0}***{1}&quot;, ex.Message, ex.StackTrace));
            }
        }

        public bool StartAccept()
        {
            SocketAsyncEventArgs acceptEventArgs = new SocketAsyncEventArgs();
            acceptEventArgs.Completed += AcceptEventArg_Completed;

            bool willRaiseEvent = listenSocket.AcceptAsync(acceptEventArgs);
            Interlocked.Increment(ref _acceptAsyncCount);

            if (!willRaiseEvent)
            {
                Interlocked.Decrement(ref _acceptAsyncCount);
                _acceptEvent.Set();
                acceptEventArgs.Completed -= AcceptEventArg_Completed;
                ProcessAccept(acceptEventArgs);
            }
            return true;
        }

        ObjectPool&amp;lt;AsyncSocketClient&amp;gt; _newSocketClientList = new ObjectPool&amp;lt;AsyncSocketClient&amp;gt;();
        private void ProcessAccept(SocketAsyncEventArgs acceptEventArgs)
        {
            try
            {
                using (acceptEventArgs)
                {
                    if (acceptEventArgs.AcceptSocket != null)
                    {
                        AsyncSocketClient client = new AsyncSocketClient(acceptEventArgs.AcceptSocket);
                        client.CreateClientInfo(this);

                        _newSocketClientList.PutObj(client);
                        _acceptEvent.Set();
                    }
                }
            }
            catch (Exception ex)
            {
                NetLogger.Log(string.Format(&quot;ProcessAccept {0}***{1}&quot;, ex.Message, ex.StackTrace));
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;NetConnectManage连接处理&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_bb7a869d-90c5-4a81-851b-33176c30b2ff&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb7a869d-90c5-4a81-851b-33176c30b2ff&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb7a869d-90c5-4a81-851b-33176c30b2ff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Sockets;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; IocpCore
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NetConnectManage
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; Action&amp;lt;SocketEventParam, AsyncSocketClient&amp;gt;&lt;span&gt; OnSocketConnectEvent;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ConnectAsyn(&lt;span&gt;string&lt;/span&gt; peerIp, &lt;span&gt;int&lt;/span&gt; peerPort, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; tag)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 Socket socket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(SocketType.Stream, ProtocolType.Tcp);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 SocketAsyncEventArgs socketEventArgs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketAsyncEventArgs();
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                 socketEventArgs.RemoteEndPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IPEndPoint(IPAddress.Parse(peerIp), peerPort);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 socketEventArgs.Completed +=&lt;span&gt; SocketConnect_Completed;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;                 SocketClientInfo clientInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketClientInfo();
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 socketEventArgs.UserToken =&lt;span&gt; clientInfo;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 clientInfo.PeerIp =&lt;span&gt; peerIp;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                 clientInfo.PeerPort =&lt;span&gt; peerPort;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 clientInfo.Tag =&lt;span&gt; tag;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;bool&lt;/span&gt; willRaiseEvent =&lt;span&gt; socket.ConnectAsync(socketEventArgs);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;willRaiseEvent)
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                    Proces&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 28 Nov 2017 06:04:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/asyn_scoket.html</dc:identifier>
</item>
<item>
<title>Docker技术浅谈：私有化部署的优势以及在顶象内部的应用实践 - 顶象技术</title>
<link>http://www.cnblogs.com/dxjx/p/7909602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxjx/p/7909602.html</guid>
<description>&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;4vag6-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4vag6-0-0&quot;&gt;顶象全景式业务安全风控体系基于新一代风控体系构建，并采用Docker技术进行私有云和公有云部署。本文主要和大家分享下Docker容器技术和顶象风控系统私有化部署的优势以及Docker容器技术在顶象内部的应用实践。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;rdw-image-alignment rdw-image-center&quot;&gt;&lt;span class=&quot;rdw-image-imagewrapper&quot;&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/6a0/6a06ef2d-bab1-4ea8-99c1-810d2be5c993.jpg&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6o8ip-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;6o8ip-0-0&quot;&gt;Docker容器技术概述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;6hneb-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6hneb-0-0&quot;&gt;Docker是一个开源的容器引擎，Docke是以Docker容器为资源分割和调度的基本单位，封装软件的运行时环境，用于快速构建、发布、运行分布式应用的平台。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;1gvuv-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1gvuv-0-0&quot;&gt;Docker容器本质上是宿主机上的进程，通过namespace实现资源隔离，通过cgroups实现资源限制，通过写时复制(copy-on-write)实现高效的文件操作。容器是应用程序层的一个抽象，将代码和依赖关系打包在一起。 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为孤立进程运行。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;rdw-image-alignment rdw-image-center&quot;&gt;&lt;span class=&quot;rdw-image-imagewrapper&quot;&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/c1c/c1cc3d1a-f2bb-423b-8546-b0785064b5ad.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;rdw-center-aligned-block&quot; data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;e6s60-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e6s60-0-0&quot;&gt;图自官网&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;an5r8-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;an5r8-0-0&quot;&gt;Docker引擎包含Docker守护进程（Docker daemon，dockerd 命令）、REST API和Docker客户端(docker 命令)。Docker采用 C/S架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。 Docker客户端和守护进程可以在同一个系统上运行，也可以将Docker客户端连接到远程的Docker守护进程。 Docker客户端和守护进程使用REST API通过UNIX套接字或网络接口进行通信。Docker容器基于开放标准，可运行在所有主要Linux发行版，Microsoft Windows以及包括虚拟机，裸机和云上的任何基础架构上。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;apb7n-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;apb7n-0-0&quot;&gt;技术优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;clam8-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;clam8-0-0&quot;&gt;Docker能够将应用程序与基础架构分离，从而可以快速交付软件。使用Docker，可以像管理应用程序一样管理基础架构。宿主机不需要去关心某一个容器运行所需要的依赖，只要它可以运行Docker，那么它就可以运行所有的Docker容器，容器将软件与其周围环境隔离开来，并有助于减少在同一基础架构上运行不同软件的团队之间的冲突。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;5ha1o-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ha1o-0-0&quot;&gt;Docker容器实现了应用环境的标准化，我们可以为不同应用、及其不同的版本制作各自的镜像，实现持续集成、应用的快速交付、应用快速更新与回滚。Docker的镜像存储采用分层的形式，不同的 Docker 容器共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率，通过合理的镜像构建方式，镜像所需的存储空间并不会随着镜像的数量而线性增长。在Docker的官方镜像仓库Docker Hub上，我们能找到100,000+的镜像，经镜像仓库的统一管理，我们只需要pull其镜像，然后通过run命令就可以快速搭建起所需的环境、部署应用。而基于Docker提供的Dockerfile，我们可以在基础镜像上自由地构建自己所需的镜像。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;e4e88-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e4e88-0-0&quot;&gt;相较于以往的基于虚拟机部署，Docker容器更加轻量化并具备可移植性，并且不需要考虑外部的依赖问题，就像Java “Write once,run anywhere”的特性一样，JVM屏蔽了不同平台的差异性，而Docker所提出的 “Build once，Run anywhere，Configure once，Run anything”体现了其更加便捷、部署成本更低的特性，不仅能够有效屏蔽操作系统之间的差异，对于混合部署又能够屏蔽其他应用可能出现的影响，间接保证了应用的高可用，提高了资源的利用率。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e4e88-0-0&quot;&gt; &lt;/h2&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;496dj-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;496dj-0-0&quot;&gt;Docker容器编排与集群管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;ahmia-0-0&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ahmia-0-0&quot;&gt;当Docker容器逐渐增多，应用的依赖关系变得复杂，依赖需要多个组件时，就可以使用Docker容器的编排。编排是一个广义的概念，它是指容器调度、集群管理和可能其他主机供应配置。为此，Docker提供了容器集群快速编排的Compose与Swarm工具。Compose是定义、运行多容器、多服务和Swarm集群配置的应用编排程序（Define application stacks built using multiple containers, services, and swarm configurations.），使用YAML文件来配置应用程序的服务，然后通过命令创建并启动配置中所有服务，实现快速部署。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;58glv-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;58glv-0-0&quot;&gt;当应用被扩展到多台宿主机，管理每个宿主系统和抽象化底层平台的复杂性变得更有挑战。Swarm作为容器集群的管理工具，可以很容易地部署跨主机的容器集群服务，Compose本身不支持跨主机管理容器，因为它的实现中只能连接一个docker client。Swarm把多个主机的docker engine集群抽象成一个虚拟的Docker主机。在集群中一个应用或者组件发现其运行环境以及其它应用或组件的信息通过服务发现实现，通常是key/value存储，例如Consul、Etcd、ZooKeeper等。Docker1.12及之后的版本已内置SwarmKit，这是一个Swarm的升级项目，在SwarmKit中内置key/value存储，通过构建Swarm集群，在上面就可以把任务负载到不同的机器上。Swarm集群中，节点有两种角色，manager和worker。manager节点通过实现Raft一致性算法来管理全局的集群状态，再配合Compose YML V3的语法可以方便对所有应用的配置管理，高效实现跨主机的容器编排与集群管理。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;agm6j-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;agm6j-0-0&quot;&gt;顶象风控系统的私有部署，除了考虑业务和用户数据的安全问题，还考虑了基础设施的依赖和隔离、快速部署交付、更新等，保证所有组件和服务都可快速的弹性扩容，既满足小范围的测试与业务起步阶段，也可以动态扩容适应业务发展，实现高QPS的支撑。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;b1t25-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;b1t25-0-0&quot;&gt;Docker容器技术在顶象内部的应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;p1pk-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;p1pk-0-0&quot;&gt;目前Docker容器技术已在顶象内部大规模推行，所有应用均通过Docker容器实现部署、交付与更新。在此列举几个简单的实践例子：&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;5ourp-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ourp-0-0&quot;&gt;1. 在一个Docker容器中，通常我们只运行一个应用，当使用容器编排时，不同应用的启动时间不同，同时耗费的时间又会与机器的性能有关，在docker-compose的YML文件中， depends_on, links等参数可以控制服务的启动顺序，但是实际上并不知道容器内的应用是否完成启动，当一个服务必须要依赖另一个服务时就需要控制它们之间容器启动的时间间隔，或者在启动应用的命令中预留等待的时间，也可以对两个服务分别编排启动。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;9eoaj&quot; data-offset-key=&quot;fjohr-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fjohr-0-0&quot;&gt;2. Compose在镜像的制作上也很方便，YML中提供了build参数用于指定Dockerfile的路径，image参数指定镜像的名称，docker-compose提供了build、push、images等命令可以为所有的应用批量制作镜像，或指定service名称，为单个服务制作镜像。同时YML支持环境变量，通过Linux export命令设置环境变量可以动态地调整参数，而docker-compose config命令则可以检查YML文件的正确性、预览最终的文件内容。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Tue, 28 Nov 2017 05:59:00 +0000</pubDate>
<dc:creator>顶象技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxjx/p/7909602.html</dc:identifier>
</item>
<item>
<title>我是如何一步一步实现网页离线缓存的？ - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/7909355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/7909355.html</guid>
<description>&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;
&lt;p&gt;一个Hybrid APP，如何做离线缓存策略？也可以简单来说，你的APP只是一个壳，里面真正加载的内容是H5，如果优化加载内容的速度？&lt;/p&gt;
&lt;h4 id=&quot;先了解一下nsurlprotocol&quot;&gt;先了解一下NSURLProtocol&lt;/h4&gt;
&lt;p&gt;从字面意思看它是一个协议，但是它其实是一个类，而且继承自NSObject。它的作用是处理特定URL协议的加载。它本身是一个抽象类，提供了使用特性URL方案处理URL的基础结构。你可以自己创建NSURLProtocol的子类，来让自己的应用支持自定义的协议或者URL方案。&lt;br/&gt;应用程序永远不需要直接实例化一个NSURLProtocol子类。当一个下载开始的时候，系统创建一个合适的protoco对象来响应URL请求。你要做的就是自己定义一个你自己的protocol，然后在APP启动的时候调用registerClass:，让系统知道你的协议。&lt;br/&gt;这里需要注意：你不能在watchOS 2以及更高版本中自定义URL scheme和协议。&lt;/p&gt;
&lt;p&gt;为了支持特定的自定义请求，你最好定义NSURLRequest 或者NSMutableURLRequest。让自定义的这些对象来实现请求，这里需要使用NSURLProtocol的propertyForKey:inRequest:和setProperty:forKey:inRequest，然后你可以自定义NSURLResponse类来模拟返回信息。&lt;br/&gt;接下来就开始对UIWebView进行离线缓存处理。&lt;/p&gt;
&lt;h4 id=&quot;uiwebview的离线缓存处理&quot;&gt;UIWebView的离线缓存处理&lt;/h4&gt;
&lt;p&gt;首先，我们需要自定义一个NSURLProtocol的子类，并且在AppDelegate.m的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    [NSURLProtocol registerClass:[ZGURLProtocol class]];
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; YES;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册。接下来的所有操作就都是在我们自定义的ZGURLProtocol中操作了。先看一下registerClass的作用：&lt;br/&gt;尝试注册一个NSURLProtocol的子类，使其对&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;URL Loading System&lt;/a&gt;可见。这里的URL Loading System就是一组类和协议，允许你的应用程序访问由URL产生的内容，比如请求、接收内容和Cache等。当URL Load System开始加载一个请求的时候，每个注册的协议类都被依次去调用，以确定是否可以用指定的请求去初始化它。首先被调用的方法是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;+ (BOOL)canInitWithRequest:(NSURLRequest *)request;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该方法里面进行缓存过滤，比如你想只缓存js，那么判断request的path的后缀，如果是js，就返回YES，否则返回NO。&lt;br/&gt;如果返回YES，那么就相当于该请求被自定义的URLProtocol来处理，这里不能保证所有的注册的NSURLProtocol都能被处理到。如果你定义了多个NSProtocol子类，这些子类将会以相反的顺序调用。也就是说如果你是这样写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; [NSURLProtocol registerClass:[ZGURLProtocol class]];
 [NSURLProtocol registerClass:[ZProtocol class]];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么最先执行的是ZProtocol，如果参initWithRequest:返回的为YES，则请求由ZProtocol进行处理，且不会再走ZGURLProtocol。如果ZProtocol的initWithRequest:返回的为NO，则请求继续向下传递由其他的NSURLProtocol子类处理。&lt;br/&gt;一旦返回YES，那么请求将会由自己写的子类处理，首先会调用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是一个抽象的方法，子类必须对其实现。通常情况下，我们一般都是直接返回request，但是这里你也可以直接修改此request，包括header，hosts等。可以对指定request进行重定向操作。&lt;br/&gt;在这里，我们只是将现有的request进行返回即可。&lt;br/&gt;紧接着，便会开始请求：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)startLoading;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法的作用就是开始请求protocol指定的请求。该方法也是protocol子类必须实现的方法。在这里所做的操作就是：&lt;br/&gt;先判断是否有缓存数据，如果有，则自己创建NSURLResponse，然后将缓存数据放入，并进行client的一些操作，然后返回；如果没有缓存数据，则新建一个NSURLConnection，然后发送请求。&lt;br/&gt;先说一下有缓存的情况下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (model.data &amp;amp;&amp;amp; model.MIMEType) {
        NSURLResponse *response = [[NSURLResponse alloc] initWithURL:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.request.URL MIMEType:model.MIMEType expectedContentLength:model.data.length textEncodingName:nil];
        [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocol:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt; didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];
        [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocol:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt; didLoadData:model.data];
        [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocolDidFinishLoading:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;];
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（model是缓存数据）有缓存的情况下,直接使用缓存的数据和MIME类型，然后构建NSURLResponse，然后通过协议client调用代理方法。这里的client是一个protocol，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;@protocol&lt;/span&gt; NSURLProtocolClient &amp;lt;NSObject&amp;gt;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;

- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;

&lt;span class=&quot;kw&quot;&gt;@end&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该协议提供了NSURLProtocol子类与URL Loading System进行沟通的接口。一个APP一定不要去实现这个协议。有缓存的情况下调用回调方法，然后进行处理。&lt;br/&gt;在没有缓存的情况下：&lt;br/&gt;实例化一个connection，然后发起请求。在我们收到response的时候：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.responseData = [[NSMutableData alloc] init];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.responseMIMEType = response.MIMEType;
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocol:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt; didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着就是接收数据：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.responseData appendData:data];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocol:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt; didLoadData:data];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接收完数据之后便调用了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)connectionDidFinishLoading:(NSURLConnection *)connection {
    ZGCacheModel *model = [ZGCacheModel new];
    model.data = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.responseData;
    model.MIMEType = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.responseMIMEType;
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt; setMiType:model.MIMEType withKey:[&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.request.URL path]];&lt;span class=&quot;co&quot;&gt;//userdefault存储MIMEtype&lt;/span&gt;
    
    
    [[ZGUIWebViewCache sharedWebViewCache] setCacheWithKey:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.request.URL.absoluteString value:model];
  
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.client URLProtocolDidFinishLoading:&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法是结束家在之后的调用，我们需要在这里将请求过来的数据进行缓存。这样我们本地就有了指定URL的返回数据。&lt;br/&gt;这里还有一个重要的东西没有介绍，那就是&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;[NSURLProtocol propertyForKey:ZGURLProtocolKey inRequest:request]
[NSURLProtocol setProperty:@YES forKey:ZGURLProtocolKey inRequest:mutableRequest];&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;+ (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)setProperty:(id)value forKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作用是在指定的请求中设置与特定的键值相关联。防止多次调用一个request。&lt;br/&gt;这样，我们就完成了UIWebView的离线缓存。在这里我封装了一个&lt;a href=&quot;https://github.com/ScottZg/ZGUIWebViewCache&quot;&gt;ZGUIWebViewCache&lt;/a&gt;。感兴趣的可以看一下。&lt;/p&gt;
&lt;h4 id=&quot;wkwebview的离线缓存处理&quot;&gt;WKWebView的离线缓存处理&lt;/h4&gt;
&lt;p&gt;WKWebView离线缓存和UIWebView缓存类似，只不过使用WKWebView除了一开始调用一下NSURLProtocol的canInitWithRequest：方法之后，之后的请求似乎就和NSURLProtocol完全无关了，网上都说WKWebView的请求是在独立的进程里，所以不走NSURLProtocol。这里是通过NSURLProtocol+WKWebView类进行处理的，详情可参见：&lt;a href=&quot;https://github.com/ScottZg/ZGWKWebViewCache&quot;&gt;ZGWKWebViewCache&lt;/a&gt;。&lt;br/&gt;剩下的处理过程就和UIWebView缓存处理类似了。&lt;br/&gt;以上便是对网页离线缓存的实现。&lt;br/&gt;如有问题，欢迎留言沟通！&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/&quot;&gt;让 WKWebView 支持 NSURLProtocol&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 05:18:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/7909355.html</dc:identifier>
</item>
</channel>
</rss>