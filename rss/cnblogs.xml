<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>做你自己的大牛 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/7740211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/7740211.html</guid>
<description>&lt;p&gt;我有个习惯，从来不叫教自动化技术的帮人为“学生”，而是叫“同学”。学生的话表示我跟他们不是同一个level的，而同学的话表示咱们都是一个level的。当然，这不是纯粹套近乎，也不是我故意放低姿态，而是，有很多问题我并不比他们强。&lt;/p&gt;

&lt;p&gt;比如，前几天我就被鄙视了，原因是最近出不去，有一个同学问我怎么才能出去，我说我这几天也出不去，后来，那位同学不知哪里习得奇技淫巧出去了，我说，那你帮我下载个新版的selenium-sever吧！下完，我说再帮我下个最新的chromedriver 吧！他就不耐烦了。结果就是我就被鄙视了呗！&lt;/p&gt;

&lt;p&gt;我加了几个Selenium群，偶尔想起来了，会在里面冒个泡，马上会有人跳出来说，虫师，我是你的“粉丝”，我一般会骂回去“粉你妹去！”。你有问题我们交流问题，我有时间就鸟你，没时间（实际上是不会）就不鸟你！休想拿“粉丝”来绑架我，再说，我也不是靠脸吃饭的。&lt;/p&gt;

&lt;p&gt;我想这主要和我们从小受到的教育有关吧！当你学习成绩不好的时候，父母就会拿你和隔壁老王家的孩子比，当你学习成绩还不错的时候，父母就会说：“怎么没考满分？”“就这点成绩，尾巴不要翘的老高了！”，所以，我们骨子里是谦卑的，或者还有那么一点点自卑。总觉得做得不好，不如别人！&lt;/p&gt;

&lt;p&gt;前几天，看了陈皓（酷壳博主）的视频参访，其实，在我看来，不管从年龄和技术上，咱和人家都差得远着呢！他有一句话，给我印象很深，大概是被恭维，像他这么有天赋写代码的人少有，他说我也不认为自己写代码特别有天分。这是在故意谦虚么？我不觉得；难道你们想用一个“天分”来抹杀一个人的所有努力？&lt;/p&gt;

&lt;p&gt;他的技术实力背后是多少个日日夜夜坐在电脑面前换来的！天份固然重要，更重要的是兴趣与坚持。我不知道你们的晚上都用来干嘛了？从我2012来到深圳这个城市，差不多就保持了晚上（周一到周五）学习的习惯。所以，我是很讨厌加班的。你一个餐补才几个钱？我需要时间为自己加班，难道你希望看到我靠明年的那点加薪来提升自己的收入？那何时才能追赶上深圳的房价？&lt;/p&gt;

&lt;p&gt;我最近关注了一个公众号，他的每篇文章下面总有一个小“迷妹”留言：大牛，虽然我也不懂你在说什么，但是我会努力的。给你打赏几块钱，虽然，我挣的也不多！我心想，这人完了，这和追星有什么区别。如果有人在我的公众号下这么留言，我一定会骂回去！当然，我们也不需要打赏，你留着这点钱多买两本技术书看看吧！比看我扯淡强多了。&lt;/p&gt;

&lt;p&gt;我刚做测试时就觉得自己挺牛X的，看那些个测试大牛，觉得你丫不就是比我多干两年嘛。当我到了你这个工龄，也许比你更牛X，当然，背后是不断的学习更多的技术。虽然，后来发现许多人确实比我聪明有天分，那又怎样，还不是被我的坚持甩在了身后。所以，粉那些个技术大牛对自己一点毛用都没有。&lt;/p&gt;

&lt;p&gt;所以，你需要做自己的大牛！&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 15:39:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/7740211.html</dc:identifier>
</item>
<item>
<title>就怕别人说我努力，因为我从来没有让自己感动过 - legenecy</title>
<link>http://www.cnblogs.com/lnzcode/p/7740210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lnzcode/p/7740210.html</guid>
<description>&lt;p&gt;    你只是在别人的眼中很努力，但是对于你自己，你更要严格要求自己。不为什么，只是为了自己的人生没有白活。&lt;/p&gt;
&lt;p&gt;   为了内心更强大，让自己需要什么，就去行动，因为行动是最好的策略。&lt;/p&gt;
&lt;p&gt;早上起来，为了自己的早餐和午餐，精心起来的准备，不管有多累，即使也被叫醒，只要能听到闹钟，很困难从床上起来。&lt;/p&gt;
&lt;p&gt;今早 炒了米饭，有鸭蛋（老家养的鸭子下蛋的），卷心菜，红萝卜。放了调味料 酱油，盐，鸡精。特意百度，主要注意火候。&lt;/p&gt;
&lt;p&gt;加上一份鲜美的干贝冬瓜汤，甘甜可口。&lt;/p&gt;
&lt;p&gt;平时会为了多注意研究美食，比如大酱汤，增味汤。&lt;/p&gt;
&lt;p&gt;七点半左右，开始为了证书，多做题。&lt;/p&gt;
&lt;p&gt;到公司不到九点开始读下英语，虽然没有读书声，但是听。&lt;/p&gt;
&lt;p&gt;在工作时间，用双屏的屏幕，核对数据，开始更改数据的算法。&lt;/p&gt;
&lt;p&gt;中午边吃饭边看TED的视频 主要看些流行的价值观。&lt;/p&gt;
&lt;p&gt;下午继续努力工作，一口气没有分心做到4点多，其中还是有喝水和上厕所。&lt;/p&gt;
&lt;p&gt;晚饭在食堂的喝粥，加会班就回来开始继续苦不堪言的做题和刷题。不为什么努力。因为我不知道是不是能否考上。&lt;/p&gt;
&lt;p&gt;在晚点继续加班，周末都是要留时间陪宝宝。&lt;/p&gt;
&lt;p&gt;与各位共勉，加油。美好的一天即将过去，即将迎来新的一天。&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 15:38:00 +0000</pubDate>
<dc:creator>legenecy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lnzcode/p/7740210.html</dc:identifier>
</item>
<item>
<title>ELK系列~对fluentd参数的理解 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/7740143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/7740143.html</guid>
<description>&lt;p&gt;&lt;span&gt;这段时候一直在研究ELK框架，主要集成在对fluentd和nxlog的研究上，国内文章不多，主要看了一下官方的API，配合自己的理解，总结了一下，希望可以帮到刚入行的朋友们！&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;78zfxy1508990303881&quot;&gt;&lt;span&gt;&lt;span&gt;Fluentd（日志收集与过滤,server）&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Fluentd&lt;span&gt;是一个免费，而且完全开源的日志管理工具，简化了日志的收集、处理、和存储，你可以不需要在维护编写特殊的日志处理脚本。Fluentd&lt;span&gt;的性能已经在各领域得到了证明：目前最大的用户从5000+&lt;span&gt;服务器收集日志，每天5TB&lt;span&gt;的数据量，在高峰时间处理50,000&lt;span&gt;条信息每秒。它可以在客户端和服务端分别部署，客户端收集日志输出到服务端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;31&quot;&gt;&lt;span&gt;fluentd的工作由它的配置文件决定，我们可以设置它的类型，格式，端口，绑定主机，tag标签等。&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @type tcp
    tag pilipa
    format none
    port 24224
    bind 0.0.0.0
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;docker.**&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    type parser
    format json
    time_format %Y-%m-%dT%H:%M:%S.%L%Z
    key_name log
    reserve_data true
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;match &lt;/span&gt;&lt;span&gt;**&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @type stdout
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ROOT&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Source节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;source主要是配置一个TCP，格式为所有，端口为默认的24224，绑定主机为自己IP的服务，它对应的客户端就要是TCP的，我们的nxlog就是这种协议的，架构上说就是一个c/s结构，由nxlog负责把数据发到fluentd上面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;filter节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;filter就是过滤规则，当source.tag复合filter的规则时，就执行这个filter进行过滤行为&lt;br/&gt;match是fluentd收到数据后的处理， @type stdout是指在控制台输出，而我们生产环境把它输出到了elasticsearch上面（ @type elasticsearch），处理的格式是json，如果在进行parser.json失败后，数据就不会正常的写入指定的数据表了，当然你可以把异常的数据存储到elasticsearch的其它表里。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自己在实践中总结的地方：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;source里类型为@tcp类型时，它的tag是很重要的，我们的程序需要提供这个tag，当然如果你指定了端口，那这个tag就是当前端口的，而filter要根据这个tag去匹配自己，比如windows的tag，它会找以windows开头的fitler。&lt;br/&gt;filter里的key_name，对应客户端发送消息时的主属性名称，有的是log，有的是message，有的是msg，像nxlog这种客户端它在使用tcp时key)name是message，下面说几种情况：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 匹配了filter但没有找到key_name会有下面提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171026231453726-1384480152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 没有任务key_name,会在结尾出现\r符号，我们需要去自己在output里过滤它，否则json转换失败&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171026231602461-1433240756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3 找到了对应的key_name&lt;/span&gt;&lt;/p&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171026231541101-45221997.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;4 fluentd.conf配置注意点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/118538/201710/118538-20171026231334805-1644784197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感谢各位的阅读！&lt;/p&gt;
&lt;p&gt;希望本文章可以帮您快速的解决问题！&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 26 Oct 2017 15:18:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/7740143.html</dc:identifier>
</item>
<item>
<title>本地连接 vmware服务器 - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/7740141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/7740141.html</guid>
<description>&lt;p&gt;在本机中装载虚拟机，安装redhat.需要调试使用redhat可以与Windows进行通讯。 &lt;/p&gt;
&lt;p&gt;分为多步，在此前提下，默认你已经安装好且可以vm 和虚拟机&lt;/p&gt;
&lt;p&gt;1：点击虚拟机&amp;gt;设置&amp;gt;添加网络适配器（添加一个或多个网卡）&amp;gt;选择自定义（U）：特定虚拟网络（VMnet8（NAT模式）refer pic1）&amp;gt;点击“确定” &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602135504653&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;2：编辑虚拟网络：编辑&amp;gt;虚拟网络编辑器&amp;gt;(默认有vnet0)添加vnet8&amp;gt;配置IP地址如图refer pic2(此处vnet8 的IP地址相当Linux操作系统的DNS地址) &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602140334678&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;3：查看vnet8 的IP地址 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602140645618&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;4：根据vnet8的ＩＰ地址设置Linux操作系统的地址，两个IP地址在同一网段，并且与虚拟机的vnet8在同一网段。 &lt;/p&gt;
&lt;p&gt;&amp;gt;重启网卡systemctl restart network&amp;gt;ifconfig 查看地址是否设置成功。 &lt;/p&gt;
&lt;p&gt;5：关闭Linux的防火墙：systemctl stop firewalld &lt;br/&gt;6: 关闭Windows的防火墙&amp;gt;启动防火墙策略 &lt;br/&gt;Windows防火墙 –&amp;gt; 高级设置 –&amp;gt; 入站规则 –&amp;gt; 在列表里找到“文件和打印机共享(回显请求 - ICMPv4-In)” –&amp;gt; 右击选择启用规则，并在其属性里设置为‘允许连接’–&amp;gt; 确定。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602143137504&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;7：从 Linux ping windows &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602143326957&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;8：从 Windows ping Linux &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20150602143442709&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 15:17:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/7740141.html</dc:identifier>
</item>
<item>
<title>Cocos 2d-X Lua 游戏添加苹果内购(二) OC和Lua交互代码详解 - Zxiao..旭</title>
<link>http://www.cnblogs.com/taoxu/p/7729693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoxu/p/7729693.html</guid>
<description>&lt;p&gt;这是第二篇&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/taoxu/p/7725660.html&quot;&gt;Cocos 2d-X Lua 游戏添加苹果内购(一) 图文详解准备流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      这是前面的第一篇，详细的说明了怎样添加内购项目以及填写银行信息提交以及沙盒测试员的添加使用以及需要我们注意的东西，结果，被移除首页了！前面第一篇的内容是这篇的基础，前面那些不弄好，下面的商品信息你是请求不到的，这点需要大家特别注意...有需要前面提到的内容的孩子可以点击链接进去自己看看！！&lt;/p&gt;
&lt;p&gt;      这篇就具体的总结我们Lua和OC交互的内容以及内购具体的代码以及结果的测试说明：&lt;/p&gt;

&lt;p&gt;内购部分OC的代码实现&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      先自己总结一下整个支付的流程，下面的代码部分我们也就按照这个支付流程来解读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171025174034223-1009499202.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;654&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最开始你首先要做的就是给你的项目添加： StoreKit.framework 框架  &lt;/p&gt;
&lt;p&gt;以及在你需要写支付的类中导入： #import &amp;lt;StoreKit/StoreKit.h&amp;gt;&lt;/p&gt;
&lt;p&gt;并且你还得遵守 &amp;lt;SKPaymentTransactionObserver,SKProductsRequestDelegate &amp;gt; 两个协议，后面会实现他们相应的代理方法。&lt;/p&gt;

&lt;p&gt;接下来你初始化了你支付类需要你初始化的东西之后，就开始判断用户有没有禁止了苹果支付，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
// 在这里先判断是否可以调用支付
-(void)isPay{
    
    // 判断用户是否禁止了苹果支付
    if ([SKPaymentQueue canMakePayments]) {
        
        // 1.获取产品信息列表
        [self requestProductData:PRODUCTID];
        
    }else{
        
        self.alertTitle   = @&quot;充值失败&quot;;
        self.alertMessage = @&quot;您禁止了支付权限!&quot;;
            
#if __IPHONE_OS_VERSION_MAX_ALLOWED &amp;gt;= __IPHONE_8_0
        // 不能进行支付进行提示
        [self.viewController presentViewController:self.alertController animated:YES completion:nil];
#else
        [self.viewController.view addSubview:self.alertView];
#endif
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照我们最开始时候的流程，接下来就需要我们去创建 SKProductsRequest 向苹果服务器请求商品的信息，具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
- (void)requestProductData:(NSString *)productId{
    
    NSArray * productArray = [[NSArray alloc]initWithObjects:productId, nil];
    NSSet   * productSet = [NSSet setWithArray:productArray];
    
    // 创建支付请求
    SKProductsRequest * productRequest = [[SKProductsRequest alloc]initWithProductIdentifiers:productSet];
    productRequest.delegate = self;
    [productRequest start];
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意： 上面代码中的 productId 就是我们刚开始在开发者后台创建新的内购产品时候的产品ID，要是不理解的强烈建议先看第一篇文章，得知道什么是产品ID。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
#pragma mark -- SKRequestDelegate
// 下面的方法会接收苹果服务器返回的商品的产品信息
// Sent immediately before -requestDidFinish:
- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response {
    
    // 接收商品的信息
    NSArray * productInfo = response.products;
    if (productInfo.count ==0) {
        
        NSLog(@&quot;接收到的商品的信息为空！&quot;);
        return;
    }else{
        // 打印出商品信息  以下的信息全都是在你开发者账号下面添加了内购项目中填写
        for (SKProduct *pro in productInfo) {
                    
             NSLog(@&quot;显示名称：%@&quot;, [pro localizedTitle]);
             NSLog(@&quot;描述：%@&quot;, [pro localizedDescription]);
             NSLog(@&quot;你设置的价格单位：%@&quot;, [pro price]);              // 注意这里的单位，是用你在内购项目里面设置的定价
             NSLog(@&quot;单位：%@&quot;, [pro.priceLocale objectForKey:NSLocaleCurrencySymbol]);
             NSLog(@&quot;CNY：%@&quot;, [pro.priceLocale objectForKey:NSLocaleCurrencyCode]);
             NSLog(@&quot;测试商品ID：%@&quot;, [pro productIdentifier]);
        }
    }
        
     
    // SKProduct对象包含了在App Store上注册的商品的本地化信息。
    SKProduct *storeProduct = nil;
    for (SKProduct * pro in productInfo) {
            
        if ([pro.productIdentifier isEqualToString:PRODUCTID]) {
                
            storeProduct = pro;
        }
    }
    
    //创建一个支付对象，并放到队列中
    self.skMutablePayment = [SKMutablePayment paymentWithProduct:storeProduct];

    //设置购买的数量 具体的交易金额就是这里的  数量 * 开发者账号定价
    if (self.payParments != 0) {
        //开始调用支付    
        self.skMutablePayment.quantity = self.payParments;
        [[SKPaymentQueue defaultQueue] addPayment:self.skMutablePayment];
                
        // 开始一个内购监听
        [self startObserver];
                
    }else{
        NSLog(@&quot;没有设置购买的数量！！&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一步就走到我们接收到了商品的信息，接下来要做的事按照前面给的流程图，就需要我们开启一个内购的监听。再给大家看到你请求到的商品的基本信息，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171025180653941-782837936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体的上面的内容是什么，大家可以对比上面的输出的时候循环里面我加了它们各自的信息。&lt;/p&gt;
&lt;p&gt;可以看到我们现在是添加了一个监控，开始监控和结束监控的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
- (void)startObserver {
    if (!self.isObserver) {
            
        [[SKPaymentQueue defaultQueue] addTransactionObserver:self];
        NSLog(@&quot;开始监听 ------ 内购&quot;);
        self.isObserver = YES;
    }
}

- (void)stopObserver {
    if (self.isObserver) {
            
        [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];
        NSLog(@&quot;移除监听 ------ 内购&quot;);
        self.isObserver = NO;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面我们就开启了监听，也开始了支付，中间的怎样使用沙盒测试账号进行购买的测试，以及过程中需要注意的事项我们已经总结过了，可以看前面的文章。&lt;/p&gt;
&lt;p&gt;等支付完成之后，我们就可以收到来自苹果支付结果的回调了，具体的回调处理下面的代码中有详细的注释： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
#pragma mark -- SKPaymentTransactionObserver
//&amp;lt;SKPaymentTransactionObserver&amp;gt;千万不要忘记绑定，代码如下：
//监听购买结果
//[[SKPaymentQueue defaultQueue] addTransactionObserver:self];
- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&amp;lt;SKPaymentTransaction *&amp;gt; *)transactions
{
    
    SKPaymentTransaction *transaction = transactions.lastObject;
    switch (transaction.transactionState) {
                    
        // 购买成功
        case SKPaymentTransactionStatePurchased: {
                
            NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]];
            // 刚才交易的内购的清单
            NSString *receipt = [data base64EncodedStringWithOptions:0];
            NSLog(@&quot;刚才交易的内购的清单:%@&quot;,receipt);
            
            // 对交易结果进行二次验证
            [self verifyPruchase];
        }
            break;
        
        // 交易失败
        case SKPaymentTransactionStateFailed: {
                
            NSLog(@&quot;交易失败&quot;);
            // 交易失败也要回调服务端
            // 将交易从交易队列中删除
            [[SKPaymentQueue defaultQueue] finishTransaction:transaction];
        }
            break;
                    
        case SKPaymentTransactionStateRestored: {
                
            NSLog(@&quot;这是你已经购买过该商品！&quot;);
            [[SKPaymentQueue defaultQueue] finishTransaction:transaction];
        }
            break;
        case SKPaymentTransactionStatePurchasing: {
                
            NSLog(@&quot;商品添加进列表&quot;);
        }
            break;
        default: {
                
            NSLog(@&quot;这是什么情况啊？&quot;);
        }
            break;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来在按照流程走的话就到二次验证支付结果的，其实我觉得这个过程放在移动端问题也不大，整个过程走Https,也没有什么关键的数据怕数问题，不像支付宝和微信支付签名的过程一样那么重要，不过需要注意的是验证这个结果得地址是分开的，也就是在开发测试阶段和上线阶段的地址是不同的，发送网络POST请求，对购买凭据进行验证：&lt;/p&gt;
&lt;p&gt;测试验证地址:&lt;a href=&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;&gt;https://sandbox.itunes.apple.com/verifyReceipt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正式验证地址:&lt;a href=&quot;https://buy.itunes.apple.com/verifyReceipt&quot;&gt;https://buy.itunes.apple.com/verifyReceipt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是具体的支付结果的验证代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
#pragma mark 验证购买凭据
- (void)verifyPruchase {
    
    // 验证凭据，获取到苹果返回的交易凭据
    // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址
    NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];
    // 从沙盒中获取到购买凭据
    NSData *receiptData = [NSData dataWithContentsOfURL:receiptURL];
    
    // 发送网络POST请求，对购买凭据进行验证
    //测试验证地址:https://sandbox.itunes.apple.com/verifyReceipt
    //正式验证地址:https://buy.itunes.apple.com/verifyReceipt
    NSURL *url = [NSURL URLWithString:@&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;];
    NSMutableURLRequest *urlRequest =
    [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f];
    urlRequest.HTTPMethod = @&quot;POST&quot;;
    NSString *encodeStr   = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
    NSString *payload     = [NSString stringWithFormat:@&quot;{\&quot;receipt-data\&quot; : \&quot;%@\&quot;}&quot;, encodeStr];
    NSData   *payloadData = [payload dataUsingEncoding:NSUTF8StringEncoding];
    urlRequest.HTTPBody   = payloadData;
    
    // 提交验证请求，并获得官方的验证JSON结果 iOS9后更改了另外的一个方法
    NSData *result = [NSURLConnection sendSynchronousRequest:urlRequest returningResponse:nil error:nil];
    
    // 官方验证结果为空
    if (result == nil) {
        
        NSLog(@&quot;交易验证失败&quot;);
        return;
    }
    
    // 二次验证返回，在这里给服务端返回验证结果
    NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:result options:NSJSONReadingAllowFragments error:nil];
    if (dict != nil) {
        
        // 比对字典中以下信息基本上可以保证数据安全
        // bundle_id , application_version , product_id , transaction_id
        NSLog(@&quot;验证成功！购买的商品的信息是：%@&quot;, dict);
            
        // 在这里回调Lua文件支付的结果
        NSDictionary * receipt = dict[@&quot;receipt&quot;];
        // 在连续的交易中，会有多笔交易产生
        NSArray * in_app  = receipt[@&quot;in_app&quot;];
            
        if (in_app.count !=0) {
                    
            for (NSDictionary * dic in in_app) {
                    
                    // 订单号回调Lua
                    NSString * transaction_id = dic[@&quot;transaction_id&quot;];
                    [self toLuaFunc:self.handlerID backMsg:[transaction_id UTF8String]];
            }       
        }
    }else{
    
            // 交易不成功，回调Lua
            NSString * transaction_id = @&quot; &quot;;
            [self toLuaFunc:self.handlerID backMsg:[transaction_id UTF8String]];
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样整个支付其实已经算是完成了的，看的仔细的朋友应该看到请求到回调结果之后我们OC回调Lua了，在这里成功之后我们是回调了Lua，在Lua俩面利用Socket向服务器去发送一个支付的确定的结果，下面我们说说Lua和OC的相互调用。&lt;/p&gt;

&lt;p&gt;Lua 调用 OC&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      下面是自己在做的一个Lua文件和OC交互的一个大概的示意图，如下：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171025232516207-1234576415.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      通过上面的一个示意图，在对比下面的代码，我们一句句的分析一下整个流程：&lt;/p&gt;
&lt;p&gt;      首先是第一步： Lua 文件调用 Bridge_ios  着重看一下下面几句代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
-- 点击跳转到苹果支付界面
function Bridge_ios.presentApplePayWithParams(payParam, callback)
    
    --quantity 价格   callback回调
    local params = {quantity = payParam, scriptHandler = callback}
    local ok,ret = luaoc.callStaticMethod(BRIDGE_CLASS,&quot;presentApplePayController&quot;,params)
    if not ok then
        -- 返回值
        print(&quot;luaj error:&quot;..ret)   
    end
end
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实直接调用OC的就是  luaoc.callStaticMethod 这个方法，这个方法解释一下：&lt;/p&gt;
&lt;p&gt;      1、luaoc    local luaoc = require &quot;cocos.cocos2d.luaoc&quot;   这个Lua引入就像OC 的#import 一样！&lt;/p&gt;
&lt;p&gt;      2、BRIDGE_CLASS  这个表示你和OC的那个类进行交互。&lt;/p&gt;
&lt;p&gt;      3、&quot;presentApplePayController&quot; 接下来的这个参数，就是你OC类里面写的类方法！&lt;/p&gt;
&lt;p&gt;      4、params 顾名思义就是参数的意思，Lua 这里传过去的是以 表 的形式，相信懂Lua 的你也清楚，什么是表！ &lt;/p&gt;
&lt;p&gt; 再说说这个参数：看这一句    local params = {quantity = payParam, scriptHandler = callback}&lt;/p&gt;
&lt;p&gt;       我们把参数写成了表的形式，用OC理解牛把它当成一个字典！quantity 是键  payParam 就是你要传的值  ， scriptHandler 是键，callback是值，只不过它是函数，OC需要回调的函数，具体的用法我们下面说回调的时候再说。&lt;/p&gt;
&lt;p&gt;      在上面的调用中：BRIDGE_CLASS 就是 AppController。&lt;/p&gt;

&lt;p&gt; OC 回调 Lua &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      前面说完了Lua 调用OC，下面接着说说 OC是怎样回调Lua 的，具体的根据下面的代码解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
// Lua 回调函数
- (void) toLuaFunc: (int)funC backMsg:(std::string)msg{
#if CC_ENABLE_SCRIPT_BINDING
        int handler = funC;
        if (-1 != handler)
        {
                auto sc = cocos2d::Director::getInstance()-&amp;gt;getScheduler();
                sc-&amp;gt;performFunctionInCocosThread([handler, msg](){
                        
                    cocos2d::LuaBridge::pushLuaFunctionById(handler);
                    cocos2d::LuaStack *stack = cocos2d::LuaBridge::getStack();
                    stack-&amp;gt;pushString(msg.c_str());
                    stack-&amp;gt;executeFunction(1);
                    cocos2d::LuaBridge::releaseLuaFunctionById(handler);
              });
                
        }
#endif
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后我们一句一句的解释一下上面这个OC回调Lua的过程：&lt;/p&gt;
&lt;p&gt;LuaBridge::pushLuaFunctionById(handlerID); //压入需要调用的方法id（假设方法为XG）&lt;/p&gt;
&lt;p&gt;LuaStack *stack = LuaBridge::getStack(); //获取lua栈&lt;/p&gt;
&lt;p&gt;stack-&amp;gt;pushString(&quot;oc call lua method...&quot;); //将需要通过方法XG传递给lua的参数压入lua栈,这里也就是设置OC回调给Lua的参数&lt;/p&gt;
&lt;p&gt;stack-&amp;gt;executeFunction(1); //根据压入的方法id调用方法XG，并把XG方法参数传递给lua代码&lt;/p&gt;
&lt;p&gt;LuaBridge::releaseLuaFunctionById(handlerID); //最后记得释放一下function&lt;/p&gt;

&lt;p&gt;上面的这整个过程，再结合我们第一篇文章写得苹果内购的图文详解流程，基本上一个完整的游戏添加内购的过程就算是结束了，要是有什么问题可以在我的主页找我的QQ或者下面留言给我！！&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/taoxu/p/7725660.html&quot;&gt;Cocos 2d-X Lua 游戏添加苹果内购(一) 图文详解准备流程&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 15:13:00 +0000</pubDate>
<dc:creator>Zxiao..旭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoxu/p/7729693.html</dc:identifier>
</item>
<item>
<title>【面向对象】详解之JavaScript篇 - 卡尔西法calcifer</title>
<link>http://www.cnblogs.com/wq1994/p/7737653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wq1994/p/7737653.html</guid>
<description>&lt;p&gt;&lt;span&gt;       【&lt;span&gt;重点提前说：面向对象的思想很重要！&lt;/span&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        最近开始接触学习后台的PHP语言，在接触到PHP中的面向对象相关思想之后，突然想到之前曾接触的JS中的面向对象思想，无奈记性太差，便去翻了翻资料，花了点时间梳理下以前接触过的OOP相关知识点，也希望在PHP的学习中能相互对比，加深理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来可要进入化冰之路-PHP篇了，过几天我将会再发一篇PHP中有关OOP的相关知识点梳理学习，希望大家放平心态，面向OOP，共同进步！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;一、学习前，你该知道这些基础知识~&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; 1、&lt;span&gt;语言的分类&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;     通常情况下我么所涉及的计算机语言可大致分三类&lt;br/&gt;          ①、面向机器：汇编语言。&lt;br/&gt;          ②、面向过程：C语言&lt;br/&gt;          ③、面向对象：Java、C++、PHP等。&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;区分理解面向对象/面向过程  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     很多的初学者在刚接触到面向对象这个概念时，总是感觉其定义很笼统抽象，也比较难理解，我们可以将其和面向过程比较理解记忆。&lt;/p&gt;
&lt;p&gt;          ①、面向过程：专注于如何去解决一个问题的过程步骤，编程的特点是由一个个的函数去实现每一步的过程步骤，没有类和对象的概念。&lt;br/&gt;          ②、面向对象：专注于由哪一个对象来解决这个问题，编程特点是出现了一个个的类，从类中拿到对象，由这个对象去解决具体问题&lt;/p&gt;
&lt;p&gt;      举个可能不是很恰当的例子来理解一下吧，相信很多的园友经历过家装吧，新买的房子交付了，就要考虑着手去装修了。现在摆在我们面前的有两种方法：一是交给家装公司来做，在你信得过的情况下，只要告诉他你想要得到什么效果，剩下的让他来做即可。二是你自己多费点功夫，去做设计图，去跑家装市场，去学习下如何在短期内称为一个合格的设计师和施工人员。&lt;/p&gt;
&lt;p&gt;     我们以此类比，第一种方法中我们只需要找个一家合适的家装公司（一个对象），即面向对象。在第二种方法中我们需要考虑很多解决问题的方法（函数），即面向过程。由此可见二者的区别：   对于调用者来说，面向过程需要调用者自己去实现各种函数。 而面向对象，只需要告诉调用者对象中具体方法的功能，不需要调用者去了解方法中的实现细节。&lt;/p&gt;
&lt;p&gt; 3、&lt;span&gt;面向对象的三大特征 &lt;/span&gt;      &lt;strong&gt;继承、封装、多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      注意:&lt;/strong&gt;JS可以模拟实现继承和封装，但是不能模拟实现多态，故js是基于事件的，基于对象的语言。&lt;/p&gt;
&lt;p&gt;4、&lt;span&gt;类和对象的概念 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                  （1）、类：一类具有相同特征(属性)和行为(方法)的&lt;span&gt;集合&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                          例如：人类---&amp;gt;:     &lt;span&gt;属性&lt;/span&gt;：身高、姓名、体重&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                                                       &lt;span&gt;方法&lt;/span&gt;：吃、喝、拉、撒&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                  &lt;/span&gt; &lt;span&gt;（2）、对象：从类中拿出具有确定属性值和方法的&lt;span&gt;个体&lt;/span&gt;叫做对象：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                              例如：张三---&amp;gt;:身高：180cm 体重：70kg    方法：说话---&amp;gt;我叫张三&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                  &lt;/span&gt; &lt;span&gt;（3）、类和对象的关系：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                                类是抽象的，对象是具体的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                                &lt;span&gt;类是对象的抽象化，对象是类的具体化；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                     &lt;span&gt;当我们对人类的每一个属性都进行了具体的赋值，那么就可以说张三是由人类产生的对象.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5、&lt;span&gt;创建一个类并实例化出对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                      ①、创建一个类(构造函数):类名必须使用&lt;span&gt;大驼峰法则&lt;/span&gt;。即首字母大写；&lt;br/&gt;                          function 类名 (属性1){&lt;br/&gt;                             &lt;span&gt; this.&lt;/span&gt;属性1 = 属性1；&lt;br/&gt;                             &lt;span&gt; this.&lt;/span&gt;方法 = function(){&lt;br/&gt;                                  方法中调用自身的属性，必须使用this.属性；&lt;br/&gt;                              }&lt;br/&gt;                          }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                       ②、通过类，实例化(&lt;span&gt;new&lt;/span&gt;关键字)出一个对象：&lt;br/&gt;                        var obi = new 类名 (属性1 的实参)；&lt;br/&gt;                        &lt;span&gt;obj.属性；调用属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                        obj.方法();调用方法&lt;/span&gt;&lt;br/&gt;                                       &lt;br/&gt;                       ③、注意事项：&lt;br/&gt;                            &amp;gt;&amp;gt;&amp;gt;通过类名，new出一个对象的过程，叫做&quot;类的实例化&quot;;&lt;br/&gt;                            &amp;gt;&amp;gt;&amp;gt;类中的this会在实例化的时候，指向新new出的对象。&lt;br/&gt;                            &amp;gt;&amp;gt;&amp;gt;所以，this.属性   &lt;span&gt;this.方法 实际上是将属性和方法绑定在新new出的对象上；&lt;/span&gt;&lt;br/&gt;                            &amp;gt;&amp;gt;&amp;gt;在类中访问自身的属性，必须使用this.属性调用。如果直接使用变量名则无法访问该属性值；&lt;br/&gt;                            &amp;gt;&amp;gt;&amp;gt;类名必须使用大驼峰法则，注意与普通函数区分；           &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们通过例子来看一下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;创建一个类的步骤如下：&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;★①、创建一个类(构造函数)&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name,age) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前一个是自定义函数中的属性，后一个是调用函数的形参，可用来传递实参；&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.age = age;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在类中访问自身的属性，必须使用this.属性调用。&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.say = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  (content) {
                alert(&lt;/span&gt;&quot;我叫&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot;今年&quot;+&lt;span&gt;this&lt;/span&gt;.age+&quot;岁了!我说了一句话&quot;+&lt;span&gt;content);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ★②、类的实例化：&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; calcifer = &lt;span&gt;new&lt;/span&gt; Person(&quot;calcifer&quot;,23&lt;span&gt;);
        calcifer.say(&lt;/span&gt;&quot;哈哈哈!&quot;&lt;span&gt;);&lt;br/&gt;/*上面的也可以写成：&lt;br/&gt;var calcifer = new Person();&lt;br/&gt;calcifer.name= &quot;louver&quot;;&lt;br/&gt;calcifer.age = 14;&lt;br/&gt;calcifer.say(&quot;哈哈哈!&quot;);&lt;br/&gt;需要注意的是，赋值必须放在函数调用之前，否则结果为undefined；&lt;br/&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后页面会自动弹窗输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026172008008-358314365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt; 6、&lt;span&gt;类和对象的两个重要属性;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                       ①、&lt;span&gt;constructor：返回当前对象的构造函数；&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;calcifer&lt;/span&gt;.constructor  返回的是上面声明的类；&lt;br/&gt;                       ②、&lt;span&gt;instanceof：A instanceof B   检测一个对象(A)是不是一个类(B)的一个实例；&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;calcifer&lt;/span&gt; instanceof Person;√  louver是函数Person的实例化；&lt;br/&gt;                            &lt;span&gt;calcifer&lt;/span&gt; instanceof Object;√  所有对象都是Object的一个实例；&lt;br/&gt;                            Person instanceof Object;√  函数本身也是一个对象；&lt;/p&gt;
&lt;p&gt;7、补充：&lt;span&gt;狭义对象与广义对象&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                         ①、只有属性和方法，除此之外，没有任何其他的内容；
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj= { } &lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; object();
                         ②、广义对象：除了用字面量声明的基本数据类型之外，JS中万物皆对象。
                                        换句话说。只要是能添加属性和方法的变量，都可以称为对象。
                            
                            eg:
                        △ 使用字面量声明
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &quot;111&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是对象&lt;/span&gt;
                            s.name = &quot;aaa&quot;&lt;span&gt;;
                            console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(s))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测为string字符串类型；&lt;/span&gt;
                            console.log(s.name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined 字面量声明的字符串不是对象，不能添加属性；&lt;/span&gt;
&lt;span&gt;                            
                        △ 使用关键字声明    
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt; String();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是对象&lt;/span&gt;
                            m.name = &quot;aaa&quot;&lt;span&gt;;
                            console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(m))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测为Object类型，因为m可以添加属性及方法，而s不行。&lt;/span&gt;
                              console.log(m.name)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa 使用new声明的字符串是对象类型，可以添加属性和方法；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;二、继承与实现继承的方式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; 1、&lt;span&gt;什么叫做继承？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            使用一个子类继承另一个父类，那么子类可以自动拥有父类中的所有属性和方法，这个过程叫做继承；&lt;br/&gt;            &amp;gt;&amp;gt;&amp;gt;继承的两方，发生在两个类之间；&lt;/p&gt;
&lt;p&gt; 2、&lt;span&gt;使用call bind apply实现继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           首先我们先来了解一下&lt;span&gt;call bind apply&lt;/span&gt;这三个函数，先看一下共同点：通过函数名调用这三个函数，可以强行将函数中的this指定为某一个对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它们的区别主要在于写法的不同：接受&lt;span&gt;func的参数列表&lt;/span&gt;的形式不同，除此之外，功能上没有差别！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               ① call写法：func.call(func的this指向的obj,func参数1,func参2,....);&lt;br/&gt;               ② apply写法：func.apply(func的this指向的obj,[func参数1,func参2,....]);&lt;span&gt;//接收一个数组形式&lt;/span&gt;&lt;br/&gt;               ③ bind写法：func.bind(func的this指向的obj),(func参数1,func参2,....);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           接下来我们主要看一下如何使用这三个函数实现继承：(以call为例)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现步骤：&lt;br/&gt;               &lt;span&gt;① 定义父类&lt;/span&gt;：&lt;br/&gt;                   function Parent (name){}&lt;br/&gt;               ② &lt;span&gt;定义子类时，在子类中使用三个函数，调用父类，将父类函数中的this，指向为子类函数的this&lt;/span&gt;；&lt;br/&gt;               &lt;br/&gt;                   function Son (num,name){&lt;br/&gt;                           this.num = num;&lt;br/&gt;                      &lt;span&gt;   Person.call(this,name);&lt;/span&gt;&lt;br/&gt;                     }&lt;br/&gt;               ③ 实例化子类时，将自动继承父类属性&lt;br/&gt;                     var s = new Son(12,&quot;zhangsan&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;           function&lt;/span&gt;&lt;span&gt; Person (name,age) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt;name;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt;age;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.say = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  () {
                    alert(&lt;/span&gt;&quot;我叫&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
                }
            }
            
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.study = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  () {
                    alert(&lt;/span&gt;&quot;我叫&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot;我今年&quot;+&lt;span&gt;this&lt;/span&gt;.age+&quot;岁了！我的学号是&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.num);
                }
                Person.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name,age);
            }
            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; Student(12,&quot;calcifer&quot;,24&lt;span&gt;);
               s.say();
               s.study();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在浏览器中代码运行结果如下：&lt;/p&gt;
&lt;p&gt;第一张效果图表示子类已经继承了父类中的say()方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026185719539-820210681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二张图表示子类同时继承了父类中的属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026185904258-1748796568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、&lt;span&gt;使用for-in循环扩展Object实现继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            废话不多说，我们直奔主题，先讲一下我们这个方法实现继承的思路吧，这个方法的关键点其实在于&lt;span&gt;通过for-in循环将父类对象的所有属性和方法，全部赋给子类对象&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当然即使不扩展Object，也能通过简单的循环实现操作；下面我们详细展示下步骤：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ① 声明一个父类&lt;/span&gt;&lt;br/&gt;                   function Parent (){}&lt;br/&gt;      &lt;span&gt;声明一个子类&lt;/span&gt;&lt;br/&gt;                   function Son (){}   &lt;br/&gt;&lt;span&gt;  ② 通过prototype给Object类添加一个扩展方法&lt;/span&gt;：&lt;br/&gt;               Object.prototype.extend = function  (parent) {&lt;br/&gt;                           for(var i in parent){&lt;br/&gt;                               this[i] = parent[i];    &lt;br/&gt;                     }&lt;br/&gt;               }&lt;br/&gt;  &lt;span&gt;③ 分别拿到父类对象和子类对象:&lt;/span&gt;&lt;br/&gt;                var p = new Parent();&lt;br/&gt;                 var s = Son();&lt;br/&gt; &lt;span&gt;  ④ 用子类对象调用扩展方法，实现从继承操作：&lt;/span&gt;&lt;br/&gt;                   s.extend(p)&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.say = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                alert(&lt;/span&gt;&quot;我叫&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
            }
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(no){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.no =&lt;span&gt; no;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.study = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                alert(&lt;/span&gt;&quot;我在学习！&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,12&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; Student(&quot;1234567&quot;&lt;span&gt;); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p) {
            s[i] &lt;/span&gt;=&lt;span&gt; p[i];
        }
        console.log(s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们同样可以手写继承方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        Object.prototype.extend1 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(parent){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; parent){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[i] =&lt;span&gt; parent [i];
            }
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,12&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; Student(&quot;1234567&quot;&lt;span&gt;);
        s.extend1(p);
        console.log(s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者最终的执行效果是一样的：在控制台上的输出如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026192845820-87905002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到实例化的子类对象s中同时具有了父类对象的属性以及方法，实现了继承。&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;使用原型实现继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       使用原型实现继承其实就是 将父类对象，赋值给子类的prototype，那么父类对象的属性和方法就会出现在子类的prototype中， 那么实例化子类时，子类的prototype又会到子类的__proto__中。&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;           function&lt;/span&gt;&lt;span&gt; Person (name,age) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name,
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age,
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.say = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  () {
                    alert(&lt;/span&gt;&quot;这是&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
                }
            }
             &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student (num) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num =&lt;span&gt; num,
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.study = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  () {
                    alert(&lt;/span&gt;&quot;我在学习！&quot;&lt;span&gt;);
                }
            }
           Student.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,14&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s =  &lt;span&gt;new&lt;/span&gt; Student(&quot;1234567&quot;&lt;span&gt;);
           s.say();
           s.study();
           console.log(s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将上面代码运行，在浏览器的控制台我们可以看到被打印出来的子类对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026214816070-126454377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过观察我们可以发现，这种使用原型继承的方法的特点在于子类自身的所有属性，都是成员属性；父类继承过来的属性，都是原型属性，但是这种方法的缺点在于仍然无法通过一步实例化拿到完整的子类对象。&lt;/p&gt;
&lt;p&gt;这一种方法里面涉及到了原型思想，考虑到很多的初学者没有接触到这一概念，下面我们详细的介绍一下原型与原型链以及原型属性及方法。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;三、原型与原型链&amp;amp;&amp;amp;原型属性与原型方法方法&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;   1、prototype:函数的原型对象&lt;/span&gt;&lt;br/&gt;               ① 只有函数才有prototype，而且所有的函数必然有prototype!&lt;br/&gt;               ② prototype本身也是一个对象！&lt;br/&gt;               ③ prototype指向了当前函数所在的引用地址！&lt;br/&gt;               &lt;br/&gt;   &lt;span&gt;   2、__proto__：对象的原型&lt;/span&gt;&lt;br/&gt;               ① 只有对象才有__proto__，而且所有的对象必有__proto__；&lt;br/&gt;               ② __proto__也是一个对象，所以也有自己的__proto__，顺着这条线向上找的顺序，就是原型链。&lt;br/&gt;               ③ 数组都是对象，也都有自己的__proto__；&lt;br/&gt;      3、实例化一个类，拿到对象的原理：&lt;br/&gt;                   &lt;span&gt;实例化一个类的时候，实际上是将新对象的__proto__，指向构造函数所在的prototype&lt;/span&gt;；&lt;br/&gt;                   也就是说：zhangsan.__proto__ ==Person.prototype √&lt;br/&gt;      4、所有对象的__proto__沿着原型链向上查找都将指向Object的prototype;&lt;br/&gt;               Object的prototype的原型，指向null；&lt;br/&gt;               &lt;br/&gt;          【原型链的指向问题】&lt;br/&gt;               研究原型链的指向问题，就是要研究各种&lt;span&gt;特殊对象的__proto__的指向问题。&lt;/span&gt;&lt;br/&gt;         1、通过构造函数，new出的对象。新对象的__proto__指向构造函数的prototype；      &lt;br/&gt;         2、函数的__proto__，指向function()的prototype；&lt;br/&gt;         3、函数的prototype的__proto__指向object的prototype；&lt;br/&gt;               (直接使用{}字面声明，或使用new Object 拿到的对象的__proto__ 直接指向Object的prototype)&lt;br/&gt;         4、 Object的prototype的__proto__，指向null；&lt;br/&gt;           (Object作为一个特殊函数，它的__proto__指向function()的prototype；)&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;类中的属性与方法的声明方式&lt;br/&gt;       &lt;span&gt; 1、【成员属性和成员方法】&lt;/span&gt;&lt;br/&gt;            this.name = &quot;&quot;;  this.func = function(){};&lt;br/&gt;            &amp;gt;&amp;gt;&amp;gt;属于实例化出的新对象，使用对象.属性调用；&lt;br/&gt;       &lt;span&gt;  2、【静态属性与静态方法】&lt;/span&gt;&lt;br/&gt;            Person.name = &quot;&quot; Person.func= function(){};&lt;br/&gt;            &amp;gt;&amp;gt;&amp;gt;属于类的，用类名.属性调用；&lt;br/&gt;       &lt;span&gt; 3、【私有属性和私有方法】&lt;/span&gt;&lt;br/&gt;                在构造函数中，使用var声明的变量称为私有属性；&lt;br/&gt;                      在构造函数中，使用function声明的函数，称为私有方法；&lt;br/&gt;    &lt;span&gt;    4、【原型属性和原型方法】&lt;/span&gt;&lt;br/&gt;               Person.prototype.name = &quot;&quot;;&lt;br/&gt;                Person.prototype.func = function(){};&lt;br/&gt;                &amp;gt;&amp;gt;&amp;gt;将属性或者方法写到类的prototype上，在实例化的时候，这些属性和方法就会进入到新对象的__proto__上，就可以使用对象名调用；&lt;br/&gt;            也就是说1、4可以使用对象名访问，2使用类名访问，3只能在函数内部使用&lt;br/&gt;       5、当访问 对象的属性或者方法时，会优先使用对象自身上的成员属性和成员方法，    &lt;br/&gt;              如果没有找到就使用__proto__上面的原型属性和原型方法，如果仍然没有将继续沿着原型链查找，最后返回undefined；&lt;br/&gt;       6、我们习惯上，&lt;span&gt;将属性写成成员属性，将方法定义为原型方法&lt;/span&gt;；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明成员属性&lt;/span&gt;
&lt;span&gt;        }
        Person.prototype.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     原因：&lt;br/&gt;            ① 原型属性在定义之后不能改变，无法在实例化时进行赋值。所以属性不能使用原型属性。&lt;br/&gt;                 但是方法，写完之后基本上不用再需要进行改变，所以，方法可以使用原型方法；&lt;br/&gt;            ② 实例化出对象之后，属性全在对象上，方法全在原型上，结构清晰。&lt;br/&gt;            ③ 使用for-in遍历对象时会将属性和方法全部打印出来。&lt;br/&gt;                  而方法往往不需要展示，那么将方法写在原型上，就可以使用hasOwnProperty将原型方法过滤掉。&lt;br/&gt;            ④ 方法写在prototype上，将更加节省内存；&lt;br/&gt;            ⑤ 这是官方推荐的写法；&lt;/p&gt;
&lt;p&gt; 示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person (name) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员属性&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; num = 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;            }
            Person.cout &lt;/span&gt;= &quot;60亿&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态属性&lt;/span&gt;
            Person.prototype.age =14;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原型属性&lt;/span&gt;
            
            &lt;span&gt;var&lt;/span&gt; zhangsan = &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;&lt;span&gt;);
            console.log(zhangsan);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器控制台打印如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026221024367-1787607641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;四、JS中模拟实现封装&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;                 在上面我们讲完JS的继承以及继承实现的方式之后，接下来我们来看一下另一大特征----封装。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1、什么叫封装？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      ① &lt;span&gt;方法的封装&lt;/span&gt;： 将类内部的函数进行私有化处理，不对外提供调用接口，无法在类外部使用的方法，称为私有方法，即方法的封装。&lt;br/&gt;      ② &lt;span&gt;属性的封装&lt;/span&gt;： 将类中的属性进行私有化处理，对外不能直接使用对象名访问(私有属性)。 &lt;span&gt;同时，需要提供专门用于设置和读取私有属性的set/get方法&lt;/span&gt;，让外部使用我们提供的方法，对属性进行操作。 这就叫属性的封装。&lt;/p&gt;
&lt;p&gt;           在这里我们需要注意的地方是：封装不是拒绝访问，而是限制访问。  它要求调用者，必须使用我们提供的set/get方法进行属性的操作，而不是直接拒绝操作。因此，单纯的属性私有化，不能称为封装！必须要私有化之后，提供对应的set/get方法！！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2、如何实现封装？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            接下来我们以实例来看一下JS中如何模拟实现封装：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age1){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this.age = age;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; age = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ages){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ages&amp;gt;0 &amp;amp;&amp;amp; ages&amp;lt;=120&lt;span&gt;){
                age &lt;/span&gt;=&lt;span&gt; ages;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                alert(&lt;/span&gt;&quot;年龄赋值失败！&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当实例化类拿到对象时，可以直接通过类名的()传入年龄，设置私有属性&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(age1 != undefined) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setAge(age1);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayTime = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            alert(&lt;/span&gt;&quot;我说当前时间是&quot;+&lt;span&gt;getTime());
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.writeTime = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
            alert(&lt;/span&gt;&quot;我写了当前时间是&quot;+&lt;span&gt;getTime());
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 私有化的方法，只能在类内部被其他方法调用，而不能对外提供功能。 这就是方法的封装！
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTime(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;五、闭包&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;                 我们都知道在JS中函数存在作用域，函数外声明的变量为全局变量，而函数内声明的变量为全局变量。同时，在JS中没有块级作用域，也就是说，if/for等有{}的结构体，并不能具备自己的作用域；所以，函数外部不能访问函数内部的局部变量(私有属性)。因为函数内部的变量，在函数执行完成之后，就会被释放掉。&lt;/p&gt;
&lt;p&gt;                 但是&lt;span&gt;使用闭包，可以访问函数的私有变量！   &lt;span&gt;JS中提供了一种闭包的概念：&lt;/span&gt;在函数中，定义一个子函数，子函数可以访问父函数的私有变量， 可以在子函数中进行操作，最后将子函数通过return返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们举个栗子来说明一下闭包的概念：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                   function&lt;/span&gt;&lt;span&gt; func1 () {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num =1&lt;span&gt;;&lt;span&gt;//函数内部的局部变量
                        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func2 () {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;&lt;span&gt;//定义一个子函数，子函数可以访问父函数中声明的私有变量，并处理后返回。&lt;/span&gt;
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func2();&lt;span&gt;//返回子函数&lt;/span&gt;
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num =     func1()();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;闭包的作用&lt;/span&gt;:&lt;br/&gt;               ① 可以在函数外部访问函数的私有变量；&lt;br/&gt;               ② 让函数内部的变量，可以始终存在于内存中，不会在函数调用完成之后立即释放！&lt;/p&gt;
&lt;p&gt;接下来我们看一个典型的案例，来更好的理解闭包的作用：&lt;/p&gt;
&lt;p&gt;我们想要实现点击一个li，都会弹出其对应的数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;11111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;22223&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;33333&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;44444&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;55555&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;         var&lt;/span&gt; lis = document.getElementsByClassName(&quot;li&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;lis.length; i++&lt;span&gt;){
                lis[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    alert(i);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行上面的一段代码时，发现无论点击任何一个li都会弹出5.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026224705476-1318874728.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026224721461-2096340017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析一下错误原因在于&lt;br/&gt;              代码从上自下，执行完毕后，li的onclick还没触发，for循环已经转完。 而for循环没有自己的作用域！所以循环5次，用的是同一个全局变量i。也就是说在for循环转完以后，这个全局变量i已经变成了5. 那么再点击li的时候，无论点击第几个，i都是5。&lt;/p&gt;
&lt;p&gt;接下来我们提供了三种解决方法，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、【使用闭包解决上述问题】&lt;/span&gt;&lt;br/&gt;             解决原理：函数具有自己的作用域，在for循环转一次创建一个自执行函数，&lt;br/&gt;             在每个自执行函数中，都有自己独立的i，而不会被释放掉。&lt;br/&gt;             所以for循环转完以后，创建的5个自执行函数的作用域中，分别存储了5个&lt;br/&gt;             不同的i变量，也就解决了问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;         var&lt;/span&gt; lis = document.getElementsByClassName(&quot;li&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;lis.length; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;!function&lt;/span&gt;&lt;span&gt;&lt;span&gt;(i){&lt;/span&gt;
                    lis[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        alert(i);
                    }
               &lt;span&gt; }(i);&lt;/span&gt;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、【使用let解决】&lt;/span&gt;&lt;br/&gt;                       解决原理：let具有自己的块级作用域，所以for循环转一次会创建一个块级作用域；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;var&lt;/span&gt; lis = document.getElementsByClassName(&quot;li&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i=0; i&amp;lt;lis.length; i++&lt;span&gt;){
                    lis[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        alert(i);
                    }
                }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;3、【使用this解决原理】&lt;/span&gt;&lt;br/&gt;            出错的原因在于全局变量i在多次循环之后被污染。那么在点击事件中，就可以不使用i变量，而是使用&lt;span&gt;this代替lis[i]&lt;/span&gt;，这样不会出现错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;var&lt;/span&gt; lis = document.getElementsByClassName(&quot;li&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(var i=0; i&amp;lt;lis.length; i++&lt;span&gt;){
                    lis[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        alert(&lt;/span&gt;&lt;span&gt;&lt;span&gt;this。innerText&lt;/span&gt;&lt;/span&gt;&lt;span&gt;);
                    }
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用修改后的方法，运行文件可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201710/1209629-20171026225701851-1331080550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了，有关JS的OOP相关知识就讲这么多吧，过几天还会为大家带来PHP语言的面向对象的介绍，在PHP中面向对象更正统也更加有趣，希望大家保持关注！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共勉，谢谢！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 15:11:00 +0000</pubDate>
<dc:creator>卡尔西法calcifer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wq1994/p/7737653.html</dc:identifier>
</item>
<item>
<title>MapReduce-实践1 - shayzhang</title>
<link>http://www.cnblogs.com/shay-zhangjin/p/7739849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shay-zhangjin/p/7739849.html</guid>
<description>

&lt;h2&gt;【-file 适合场景】分发文件在本地，小文件&lt;/h2&gt;
&lt;p&gt;-file分发原理&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026220846851-1392588936.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026221541351-888858188.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;run.sh文件&lt;/strong&gt;： 通过多个-file, 将多个本地文件分发到Hadoop集群中的compute node&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HADOOP_CMD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/bin/hadoop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
STREAM_JAR_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/contrib/streaming/hadoop-streaming-1.2.1.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
INPUT_FILE_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_input/The_Man_of_Property.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OUTPUT_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$HADOOP_CMD fs &lt;/span&gt;-rmr-&lt;span&gt;skipTrash $OUTPUT_PATH
&lt;strong&gt;# job1: use &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-&lt;span&gt;file&lt;/span&gt; to distribute &lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; local file to cluster&lt;/strong&gt;
# these &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; files will bestored &lt;span&gt;in&lt;/span&gt; the same directory &lt;span&gt;in&lt;/span&gt;&lt;span&gt; each datanode
$HADOOP_CMD jar$STREAM_JAR_PATH \
    &lt;/span&gt;-&lt;span&gt;input $INPUT_FILE_PATH \
    &lt;/span&gt;-&lt;span&gt;output $OUTPUT_PATH \
    &lt;/span&gt;-mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python map.py mapper_funcwhite_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python red.pyreducer_func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;map.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;red.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./white_list
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;修改reducer个数为三个 (第一种 -jobconf)&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HADOOP_CMD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/bin/hadoop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
STREAM_JAR_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/contrib/streaming/hadoop-streaming-1.2.1.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
INPUT_FILE_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_input/The_Man_of_Property.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OUTPUT_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$HADOOP_CMD fs &lt;/span&gt;-rmr-&lt;span&gt;skipTrash $OUTPUT_PATH
&lt;strong&gt;# job1: use &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-&lt;span&gt;file&lt;/span&gt; todistribute &lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; files&lt;/strong&gt;
# these &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; files will be stored &lt;span&gt;in&lt;/span&gt; the same directory &lt;span&gt;in&lt;/span&gt;&lt;span&gt; each datanode
$HADOOP_CMD jar$STREAM_JAR_PATH \
    &lt;/span&gt;-&lt;span&gt;input $INPUT_FILE_PATH \
    &lt;/span&gt;-&lt;span&gt;output $OUTPUT_PATH \
    &lt;/span&gt;-mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python map.py mapper_funcwhite_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;    -reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pythonred.py reducer_func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;  &lt;span&gt;  -jobconf “mapred.reduce.tasks=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;” \  # deprecated option, not suggested
    &lt;/span&gt;&lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;map.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;red.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./white_list
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;修改reducer为3个（第二种  -D）&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HADOOP_CMD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/bin/hadoop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
STREAM_JAR_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/contrib/streaming/hadoop-streaming-1.2.1.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
INPUT_FILE_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_input/The_Man_of_Property.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OUTPUT_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/02_filedistribute_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$HADOOP_CMD fs &lt;/span&gt;-rmr-&lt;span&gt;skipTrash $OUTPUT_PATH
# job1: use &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; todistribute &lt;span&gt;3&lt;/span&gt;&lt;span&gt; files
# these &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; files will bestored &lt;span&gt;in&lt;/span&gt; the same directory &lt;span&gt;in&lt;/span&gt;&lt;span&gt; each datanode
$HADOOP_CMD jar$STREAM_JAR_PATH \
    &lt;/span&gt;&lt;span&gt;-D mapred.reduce.tasks=&lt;span&gt;3&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;&lt;/span&gt;-&lt;span&gt;input $INPUT_FILE_PATH \
    &lt;/span&gt;-&lt;span&gt;output $OUTPUT_PATH \
    &lt;/span&gt;-mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python map.py mapper_funcwhite_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;    -reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pythonred.py reducer_func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;map.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;red.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./white_list
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;datanode上观察分发的文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、作业专属目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作业开始后，会创建专属目录， &lt;span&gt;&lt;strong&gt;taskTracker/root/jobcache/job_xxxxxxxx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026221703648-914937981.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、分发给作业的文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被放置在同一目录，&lt;span&gt;&lt;strong&gt;taskTracker/root/jobcache/job_xxxx/jars&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026221821508-1689642667.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、每一个正在运行的mapper, reducer构建attempt目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每一个运行的mapper, reducer会构建一个attempt目录，t&lt;span&gt;&lt;strong&gt;askTracer/root/jobcache/job_xxx/attempt_yyyyy/work&lt;/strong&gt;&lt;/span&gt; ,  生成&lt;span&gt;&lt;strong&gt;符号链接文件&lt;/strong&gt;&lt;/span&gt;，指向jars中的具体文件&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026221926258-289934719.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026221945476-1865625598.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;1、将mapreduce程序运行时需要的某一个辅助文件提前上传到HDFS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如：将实践1中的white_list上传到HDFS，本地文件在上传后直接删除&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# hadoop fs -put ./white_list /&lt;span&gt;
# &lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; -rf ./white_list
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、修改run.sh, 设置-cacheFile&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HADOOP_CMD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/bin/hadoop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
STREAM_JAR_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/contrib/streaming/hadoop-streaming-1.2.1.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
INPUT_FILE_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/03_cachefiledistribute_input/The_Man_of_Property.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OUTPUT_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/03_cachefiledistribute_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$HADOOP_CMD fs &lt;/span&gt;-rmr-&lt;span&gt;skipTrash $OUTPUT_PATH
&lt;span&gt;# job2: use &lt;/span&gt;&lt;/span&gt;&lt;span&gt;-cacheFileto distribute HDFS file&lt;/span&gt;&lt;span&gt;&lt;span&gt; to compute node&lt;/span&gt;
$HADOOP_CMD jar$STREAM_JAR_PATH \
    &lt;/span&gt;-&lt;span&gt;input $INPUT_FILE_PATH \
    &lt;/span&gt;-&lt;span&gt;output $OUTPUT_PATH \
&lt;/span&gt;    -mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python map.py mapper_func WH&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;span&gt;#这里也一定要用WH符号链接，因为作业开始运行后创建的attemps目录中只能看到WH，和map.py符号链接位于同一目录
&lt;/span&gt;&lt;/span&gt;    -reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pythonred.py reducer_func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;    &lt;strong&gt;&lt;span&gt;-cacheFile “hdfs://master:9000/white_list#WH”&lt;/span&gt;&lt;/strong&gt;
   &lt;span&gt; #WH一定要，每个attemp中要生成该符号链接,指向Tasktracer/distcache中的whitelist
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;map.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;red.py&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3、运行run.sh，提交任务，观察数据节点上的文件分发&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026222336414-529862696.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;运行结束后, jobcache下的所有内容，以及distcache下的所有内容，将全部清空&lt;/p&gt;
&lt;hr/&gt;


&lt;p&gt;【使用场景】&lt;/p&gt;
&lt;p&gt; 假定有多个white_list文件，如果一个个通过-file方式上传就不太合理，可以将多个white_list文件，打包压缩为1个tar.gz文件，上传到HDFS，然后通过-cacheArchive方式，将HDFS压缩将件分发给各个compute node.  同时框架会自动将分发到各个compute node上的压缩文件进行解压&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1、将本地多个white_list文件，打包为一个压缩文件w.tar.gz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目录结构：map.py,  red.py, white_list_dir&lt;/p&gt;
&lt;p&gt;                                                            |_white_list_1&lt;/p&gt;
&lt;p&gt;                                                            |_white_list_2&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：gzip打包后的文件，上传到HDFS，通过-cacheArchive&lt;strong&gt;分发到计算节点后，会自动解压为同名文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;打包完成后的目录结构为：map.py,  red.py, white_list_dir&lt;/p&gt;
&lt;p&gt;                                                            |_white_list_1&lt;/p&gt;
&lt;p&gt;                                                            |_white_list_2&lt;/p&gt;
&lt;p&gt;                                                            |_w.tar.gz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、打包后的压缩文件上传到HDFS&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# hadoop fs –put ./&lt;span&gt;w&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz  /&lt;span&gt;
 
# hadoop fs –&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; /&lt;span&gt;
查看是否已经上传成功&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、修改run.sh，-cacheArchive选项&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
HADOOP_CMD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/bin/hadoop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
STREAM_JAR_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/hadoop-1.2.1/contrib/streaming/hadoop-streaming-1.2.1.jar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
INPUT_FILE_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/03_cachefiledistribute_input/The_Man_of_Property.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OUTPUT_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/03_cachefiledistribute_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$HADOOP_CMD fs &lt;/span&gt;-rmr-&lt;span&gt;skipTrash $OUTPUT_PATH
&lt;span&gt;# job3: use &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-cacheArchive&lt;/strong&gt; to distribute HDFS compressed file&lt;/span&gt;&lt;span&gt;&lt;span&gt; to compute node&lt;/span&gt;
$HADOOP_CMD jar$STREAM_JAR_PATH \
    &lt;/span&gt;-&lt;span&gt;input $INPUT_FILE_PATH \
    &lt;/span&gt;-&lt;span&gt;output $OUTPUT_PATH \
&lt;/span&gt;    -mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python map.py mapper_func WLDIR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;span&gt;#这里也一定要用WH.gz符号链接名，因为attemps中只能看到WH.gz
&lt;/span&gt;&lt;/span&gt;    -reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pythonred.py reducer_func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;   &lt;strong&gt;&lt;span&gt; -cacheArchive “hdfs://master:9000/w.tar.gz#WLDIR”&lt;/span&gt;&lt;/strong&gt;
    &lt;span&gt;#WLDIR一定要，每个attemp中要生成该符号链接,指向Tasktracer/distcache中已经自动解压的文件夹，文件夹中有white_list_1,white_list_2
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./&lt;span&gt;map.py \
    &lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; ./red.py
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、重大变动：修改map.py程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-mapper &quot;python map.py mapper_func WLDIR&quot; \&lt;/p&gt;

&lt;p&gt;可以看出map.py开始运行时，传入参数只能是WLDIR，表示压缩的HDFS文件分发到compute node后自动解压得到的目录&lt;/p&gt;
&lt;p&gt;因此&lt;span&gt;map.py要修改程序为遍历WLDIR字符串代表的目录，找到每个文件，然后再对每个文件做处理&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、运行run.sh，提交任务，观察数据节点上的文件分发&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/573045/201710/573045-20171026222810101-424606218.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;运行结束后, jobcache下的所有内容，以及distcache下的所有内容，将全部清空&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 14:30:00 +0000</pubDate>
<dc:creator>shayzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shay-zhangjin/p/7739849.html</dc:identifier>
</item>
<item>
<title>ArrayList源码剖析 - 波波老湿</title>
<link>http://www.cnblogs.com/bobohaohao/p/7739714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobohaohao/p/7739714.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;为List的一个实现类,List的实现类有很多,我们该选择在什么时候使用什么集合?需要对他们有一个深入的了解.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.构造方法,这里我们介绍两个常用的,第一个当属我们的空参构造方法&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;public ArrayList() {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　super();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　this.elementData = EMPTY_ELEMENTDATA;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这里,ArrayList(后续我会称之为本类)中管理了一个常量EMPTY_ELEMENTDATA,这个常量声明是这样的:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;private static final Object[] EMPTY_ELEMENTDATA = {};&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　  这是他内部管理的一个空的对象数组,而elementData的声明同样也是一个对象数组,具体如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;private transient Object[] elementData;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;这里的elementData是类中真实存放数据的一个对象数组,即后续存入数据真正是存放在此对象数组中,由于其类型为Object,所以可以存入所有类型的对象.基于此,其实我们就可以大胆猜测其实ArrayList内部就是基于对象数组实现的,(还有一个构造方法我们后边再给大家引入)那么它就具备了数组的一些特性:&lt;strong&gt;存取有序,查询方便,插入删除不便&lt;/strong&gt;.那么为什么这么说,接下来我们深入剖析一下他的增删改查方法;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　增加:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;public boolean add(E e) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ensureCapacityInternal(size + 1); // Increments modCount!!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　elementData[size++] = e;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　return true;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　&lt;/em&gt;&lt;/span&gt;　&lt;span&gt;如上添加时传入了一个参数,此处为泛型,这里就表示可以传入所有类型的参数,内部的实现如上,可能大家都比较想知道的是数组不是必须在初始化的时候就给定长度么?数组不是固定长度么?我们使用集合存入数据时是可以一直存入的昂,具体是如何实现的?此处我们需要关注一下上面的ensureCapacityInternal(size + 1)这个方法,就是他实现了数组的动态扩充,也就是数组会随着元素的添加而不断的扩充,我们去看下他的具体实现:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;private void ensureCapacityInternal(int minCapacity) {&lt;/p&gt;
&lt;p&gt;　　if (elementData == EMPTY_ELEMENTDATA) {&lt;br/&gt;　　　　minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&lt;br/&gt;　　}&lt;/p&gt;
&lt;p&gt;　　ensureExplicitCapacity(minCapacity);&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　&lt;span&gt;　上面的方法开始就做了一个简单的验证,判断真实存放数据的数组是否等于空的对象数组,如果为空,则真实存放数据的elementData长度为10.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;private static final int DEFAULT_CAPACITY = 10;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//下面是Math.max(a,b)方法的实现,目的是比较二者获取一个大值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public static int max(int a, int b) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　return (a &amp;gt;= b) ? a : b;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;接下来执行了一个&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;private void ensureExplicitCapacity(int minCapacity) {&lt;/p&gt;
&lt;p&gt;　　modCount++;&lt;/p&gt;
&lt;p&gt;　　// overflow-conscious code&lt;br/&gt;　　if (minCapacity - elementData.length &amp;gt; 0)&lt;br/&gt;　　　　grow(minCapacity);&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;根据存入数据的下标+1来表示当前数据实际存放的数量,从而来判断数据是否已经存满,需要扩充,如果存入数据数量+1减去已有数据数组长度大于零,即执行下面的grow方法&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;private void grow(int minCapacity) {&lt;/p&gt;
&lt;p&gt;　　// overflow-conscious code&lt;br/&gt;　　int oldCapacity = elementData.length;&lt;br/&gt;　　int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);&lt;br/&gt;　　if (newCapacity - minCapacity &amp;lt; 0)&lt;br/&gt;　　　　newCapacity = minCapacity;&lt;br/&gt;　　if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)&lt;br/&gt;　　　　newCapacity = hugeCapacity(minCapacity);&lt;br/&gt;　　// minCapacity is usually close to size, so this is a win:&lt;br/&gt;　　elementData = Arrays.copyOf(elementData, newCapacity);&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;如上,先获取到现在对象数组的长度,即oldCapacity,再通过算法得到新的数组长度:oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1),这里算法实现是原数组长度+原数组向右位移一位,即原数组长度乘以2,因为位移运算效率高,所以此处这么写,相当于oldCapacity +oldCapacity *2.后续两个判断是逻辑性的验证,最后利用Arrays.copyOf方法,根据原数组和传入新数组的长度来得到新的数组,并赋值给了elementData .这里我们要追进去Arrays类中去看下具体是如何实现的:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;public static &amp;lt;T&amp;gt; T[] copyOf(T[] original, int newLength) {&lt;br/&gt;　　return (T[]) copyOf(original, newLength, original.getClass());&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;public static &amp;lt;T,U&amp;gt; T[] copyOf(U[] original, int newLength, Class&amp;lt;? extends T[]&amp;gt; newType) {&lt;/p&gt;
&lt;p&gt;　　T[] copy = ((Object)newType == (Object)Object[].class)&lt;br/&gt;　　? (T[]) new Object[newLength]&lt;br/&gt;　　: (T[]) Array.newInstance(newType.getComponentType(), newLength);&lt;br/&gt;　　System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength));&lt;br/&gt;　　return copy;&lt;br/&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;span&gt;有些新手看到这可能已经被一系列的T[],U[]给整蒙了, 这里具体实现是判断利用反射对存入类型做了最后一步校验,如果不是同一类型,则以传入的新长度为长度,直接构建一个新的对象数组并返回,如果是则调用系统的arraycopy方法,将旧的数组中元素依次有序的存入新数组中,并将新数组返回.至于System.arraycopy方法,就是循环将旧数组中的元素依次存入新数组中,由于System.arraycopy方法已经封装为native方法,无法查看.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,&lt;em id=&quot;__mceDel&quot;&gt;int length);&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　到这里,已经可以看出来添加方法,其实核心是一个数组的动态扩充,即丢弃旧的数组,创建新的数组,所以如果频繁的扩充对象数组,就会制造大量垃圾,浪费内存,影响性能,此时,我们如果已知存放数据大致数量的情况下,我们即可以使用第二种构造方法:指定初始化容量,减少内存的大量消耗&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;public ArrayList(int initialCapacity) {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　super();&lt;br/&gt;　　if (initialCapacity &amp;lt; 0)&lt;br/&gt;　　throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;br/&gt;　　initialCapacity);&lt;br/&gt;　　this.elementData = new Object[initialCapacity];&lt;br/&gt;}&lt;/em&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt; 　　&lt;span&gt;后续明天再撸...&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 13:57:00 +0000</pubDate>
<dc:creator>波波老湿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobohaohao/p/7739714.html</dc:identifier>
</item>
<item>
<title>Java反射机制(Reflect)解析 - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/7738381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/7738381.html</guid>
<description>&lt;h2&gt;一、导读&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用，并在Lisp和面向对象方面取得了成绩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    概念很模糊，刚开始我们也没必要深究。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;二、对象的创建&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   “万物皆对象”。对于面向对象语言，我们的操作都要基于对象，所以对象到底是怎么创建来的呢？为了方便说明，我以下面的自定义Person类来进行说明。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_1db7a40b-1089-43ab-ae03-83dd2d5ef9ae&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1db7a40b-1089-43ab-ae03-83dd2d5ef9ae&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1db7a40b-1089-43ab-ae03-83dd2d5ef9ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; function1(){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         System.out.println(&quot;function1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; function2(){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         System.out.println(&quot;function2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function3(String s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         System.out.println(s+&quot;:::&quot;+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     @SuppressWarnings(&quot;unused&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; function4(){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         System.out.println(&quot;function4&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Person&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;      &lt;span&gt;回到上面的问题：对象的创建，当然很简单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person p1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Person p2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Lisi&quot;,20);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        这样我们就得到了p1和p2两个对象。这是我们最常用也最简单的对象创建方法：使用关键字new。但这种方法仅在开发的时候管用，考虑这样的情况：当我们的程序开发完成之后，我们突然需要使用到某个类对程序进行功能扩展(就是辣么突然哈)，这个时候我们无法再使用new，因为我们的程序已经封装好了，即不能再修改源程序的情况下进行功能扩展，那么我们需要在开发的时候就考虑到这个问题，我们开发的时候就需要对外暴露接口，而我们&lt;span&gt;只需知道被使用来扩展功能的类的类名&lt;/span&gt;就可以进行操作了，&lt;span&gt;如何实现呢？（看完可能你有句“什么玩意儿”不知当讲不当讲）。没看懂没关系，现在你只需要知道&lt;span&gt;除了使用new关键字来创建对象外&lt;/span&gt;，下面的方法也可以实现对象的创建：（也就是我们要讲的java反射）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、获取Class对象&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; String className = &quot;bean.Person&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; Class&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、使用Class对象创建该类对象：&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; Object obj = c.newInstance();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      &lt;span&gt;  &lt;span&gt;解析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;我们关键字new类创建对象其实内部在进行：1、查找并加载Person.class文件进内存，并将该文件分装成Class对象；2、根据Class对象进行类的创建；3、调用构造函数来初始化对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;         而这些步骤便是上面的两个步骤来完成的：首先使用Class类的forName()来获取Class对象，然后使用Class对象进行该类对象的创建，即调用Instance()方法，而调用该方法后会自动调用构造函数进行初始化，对象的创建完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;         总结来说就是&lt;/span&gt;&lt;span&gt;Person p = new Person();等价于Class.forName(&quot;bean.Person&quot;).newInstance();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;一些细节问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;1、forName()方法中传入的是类的名字：Person，但是我们需要在类名前写上包名，bean.Person。因为不同包中可能有相同的类名，我们需要指明包才能找到类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        2、 如果指定的类中没有空参数函数或者该类需要指定的构造函数进行初始化时，即我们需要使用到带有参数的构造函数时，就不能再使用Class对象的newInstance()来创建对象了：我们需要这样来创建对象：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c = Class.getName(&quot;bean.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、获取这个带有参数的构造器&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; Constructor&amp;lt;?&amp;gt; con = c.getConstructor(String.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、使用构造器来创建：&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; Object obj = con.newInsatnce(&quot;LiSi&quot;,20);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt; 这样等价于Person p = new Person(“LiSi”,20);&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3、Java&quot;反射包&quot;&lt;/h2&gt;
&lt;p&gt;        &lt;span&gt;正如上面讲到的对象的创建，Java专门提供了一个包：Java.lang.reflect，用于完成反射：如通过Class对象来获取类的成员、类中的方法等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026174925320-967852807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4、获取类的字段&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       假设现在我们需要访问Person类中的字段：name和age。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1、获取：我们可以使用Class对象中的getField()方法和getDeclaredField()来访问，两者的区别在于：getField()返回的是公有的字段和父类中的字段，而getDeclaredField()返回的是私有化的字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2、使用：我们获取到了字段就可以进行使用了，但在使用之前我们需要知道：1)该类对象  2）使用的字段是否有访问权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            1）使用forName()创建一个对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            2)如果使用的字段无访问权限，即公有，则可以直接使用；如果该字段私有，则我们需要使用setAccessible(true)来取消权限设置，才能进行访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        看具体实现代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ba8b568c-a9a7-4d5d-b126-1873bfb89900&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ba8b568c-a9a7-4d5d-b126-1873bfb89900&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ba8b568c-a9a7-4d5d-b126-1873bfb89900&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; reflect;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; getFieldDemo {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         String className = &quot;bean.Person&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Class&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有字段&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Field nameField = c.getDeclaredField(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Field ageField = c.getDeclaredField(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用字段（使用之前我们需要一个该类对象）&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         Object obj =&lt;span&gt; c.newInstance();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用set()方法设置字段值&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         nameField.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         ageField.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴力访问&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         nameField.set(obj, &quot;张三&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         ageField.set(obj,20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印查看效果&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot;获取到的字段：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;name:&quot;+&lt;span&gt;nameField);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         System.out.println(&quot;age:&quot;+&lt;span&gt;ageField);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         System.out.println(&quot;字段设置的值：name=&quot;+nameField.get(obj)+&quot;,age=&quot;+&lt;span&gt;ageField.get(obj));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;getFieldDemo&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;         打印结果：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026182329836-246245645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5、获取类中的方法&lt;/h2&gt;
&lt;p&gt;      &lt;span&gt;  假设我们需要获取到Person类中的4个方法：&lt;/span&gt;&lt;span&gt; 类似获取字段，我们首先要明确该方法的访问权限和是否有参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        1、获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们使用getMethods()和getDeclaredMethods()来：前者获取公有及父类中的方法，后者获取私有方法。而获取一个方法则使用getMethod&lt;/span&gt;(&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt; name,&lt;a title=&quot;java.lang 中的类&quot;&gt;Class&lt;/a&gt;&amp;lt;?&amp;gt;... parameterTypes)和getDeclaredMethod(&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt; name,&lt;a title=&quot;java.lang 中的类&quot;&gt;Class&lt;/a&gt;&amp;lt;?&amp;gt;... parameterTypes)来获取。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;   2、调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          使用Method类中的invoke(object obj,object args...)方法来调用有参数的方法的底层方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          具体实现代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_f36cb346-df95-4cda-ae12-9c88fd22b6c8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f36cb346-df95-4cda-ae12-9c88fd22b6c8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f36cb346-df95-4cda-ae12-9c88fd22b6c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; reflect;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; getMethodDemo {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         String className = &quot;bean.Person&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Class&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取公共方法：&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Method[] pubMethods =&lt;span&gt; c.getMethods();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有方法：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Method[] priMethods =&lt;span&gt; c.getDeclaredMethods();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取单个方法：按方法名和参数获取
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取单个の静态方法：function1&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         Method staMethod = c.getMethod(&quot;function1&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取单个の无参数方法：function2&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         Method nullMethod = c.getMethod(&quot;function2&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取单个の有参数方法：function3&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Method moreMethod = c.getMethod(&quot;function3&quot;,String.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取单个の私有方法：function4&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Method priMethod = c.getDeclaredMethod(&quot;function4&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印查看效果&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;[Person类的公共方法及父类方法:]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method m:pubMethods){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            System.out.println(m);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         System.out.println(&quot;[Person类的私有方法:]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method m:priMethods){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            System.out.println(m);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         System.out.println(&quot;[按方法名和参数类型获取的方法4个方法:]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        System.out.println(staMethod);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        System.out.println(nullMethod);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        System.out.println(moreMethod);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        System.out.println(priMethod);    
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;获取&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        &lt;span&gt; 打印结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026190011367-1282510120.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_0f1cd7fe-802c-4ff6-b7a6-15391fb1c5d8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0f1cd7fe-802c-4ff6-b7a6-15391fb1c5d8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0f1cd7fe-802c-4ff6-b7a6-15391fb1c5d8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; reflect;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; invokeDemo {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         String className = &quot;bean.Person&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Class&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取有参数的方法：function3&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Method moreMethod = c.getDeclaredMethod(&quot;function3&quot;,String.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用之前我们需要创建一个该类对象：&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Object obj =&lt;span&gt; c.newInstance();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         moreMethod.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置访问权限&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         Object value = moreMethod.invoke(obj,&quot;李四&quot;,20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印查看效果&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        System.out.println(value);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;         打印结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026191619273-1340028528.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6、进阶：反射机制的运用实例の我的电脑没USB&lt;/h2&gt;
&lt;p&gt;      &lt;span&gt; 我们以下面这个类：myComputer来说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 模拟一台具有开机关机功能的电脑.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; myComputer {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Running...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;Closed!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;现在假设你开发出来了一台电脑：没错就是上面myComputer(唉，别走回来)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;假设你开发的这台电脑问世的时候只能开机和关机，现在你觉得这台电脑的功能有一点单调了(一点？)，所以你希望这台电脑可以实现：鼠标和键盘的连接，并可以使用鼠标和键盘的功能。那么要怎么实现呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         我们都知道接鼠标或键盘需要有USB接口才能实现，所以我们需要myComputer具备USB接口功能：我们可以使用接口Interface实现。然后我们需要让USB接口和鼠标或键盘相匹配或者说连接起来：则我们让鼠标和键盘可以实现USB接口。然而问题的关键在于我在开发myComputer时并不知道我有什么鼠标啊键盘啊什么的，更别说拿来用了。&lt;span&gt;该如何让鼠标或键盘等外部设备为我所用呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        现在我们唯一能知道的就是鼠标啊、键盘啊等设备的名字，它们内部是什么都不清楚，怎么创建一个鼠标或键盘对象来调用它们的方法呢？如果你好好看了上面的反射，那么你应该可以实现：&lt;span&gt;我们只需要使用Class.forName(className).newInstance();就行了。&lt;span&gt;我们只需要知道className即类的名字就能创建这个类，包括获取类的字段、类的方法等等关于该类的信息，这就是反射的强大之处。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;7、进阶：反射机制的运用实例の我的电脑有USB啦啦啦&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、首先我们需要对初代myComputer就行改进：实现USB接口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; myComputer2:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 模拟一台具有开机关机功能的电脑.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; myComputer2 {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Running...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;Closed!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;升级后的2代计算机：USB功能&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useUSB(USB usb){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(usb != &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果设备连接上，则开始使用设备功能&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            usb.connection();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            usb.close();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;USB接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt; * 用于描述USB接口
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; USB {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; connection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备连接&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备断开&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设备：鼠标和键盘&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 鼠标
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mouse &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; USB {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; connection() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;鼠标正在使用...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;鼠标已断开连接！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 键盘
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; keyboard &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; USB {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; connection() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;键盘正在使用...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;键盘已断开连接！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、USB的使用测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们现在来测试一下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; reflect;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; bean.USB;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; bean.myComputer2;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         myComputer2 mc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myComputer2();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们只需要知道封装设备的类名即可&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         String className = &quot;bean.Mouse&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Class&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Object obj =&lt;span&gt; c.newInstance();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt;         USB usb =&lt;span&gt; (USB)obj;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        mc.useUSB(usb);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;test的测试结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026210740398-1843027495.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        很明显，&quot;鼠标&quot;接上myComputer2后可以正常使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、测试改进：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        对于上面的测试类test中的className的值我们是手动输入的，这不符合后来开发者的需求，因为我们开发的时候可能根本不知道有鼠标这种设备，或者说要是将来有新的设备连接我们该怎么办呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         这时候我们需要使用到&lt;span&gt;配置文件，&lt;/span&gt;&lt;span&gt;即使用IO流来对我们使用的设备进行&lt;span&gt;后台管理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;         &lt;span&gt;看具体改进代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; reflect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; bean.USB;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; bean.myComputer2;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        myComputer2 mc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myComputer2();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用IO流，使用配置文件传入类名：&lt;/span&gt;
        File config = &lt;span&gt;new&lt;/span&gt; File(&quot;tempFile\\usb.config&quot;&lt;span&gt;);
        FileInputStream fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(config);
        Properties prop &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        prop.load(fis);
        String className &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        className &lt;/span&gt;= prop.getProperty(&quot;usb&quot;&lt;span&gt;);
        
        
        Class&lt;/span&gt;&amp;lt;?&amp;gt; c =&lt;span&gt; Class.forName(className);
        Object obj &lt;/span&gt;=&lt;span&gt; c.newInstance();
        
        USB usb &lt;/span&gt;=&lt;span&gt; (USB)obj;
        mc.useUSB(usb);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在我的配置文件传入什么设备，那么这台电脑就会使用什么设备：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如我的配置文件为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026213051273-1930873659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我连接的设备是keyboard即键盘，那么运行结果会是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201710/1250367-20171026213221320-2031328553.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;没毛病O(∩_∩)O欢迎指正！ &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Oct 2017 13:34:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/7738381.html</dc:identifier>
</item>
<item>
<title>一个程序员送给大学生弟弟的那些话 - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/7736092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/7736092.html</guid>
<description>&lt;h3&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;昨天一个大学生弟娃问了我一些问题，他是想赚点钱，因为读书嘛没什么钱，又谈了恋爱，想通过一些方式赚点外快。  虽然平时也没怎么联系，但是作为大湿人，也不免多啰嗦几句，把我能想到的一些观点告诉他，希望对他能有所启发。  在博客园里，我越来越倾向于写更多“硬菜”，和技术紧密相关的文章。  但也如我博客园签名： 偶尔吟湿作对，润滑万物。  每次有弟弟妹妹（特别是大学生）和我聊起大学或者工作，我都会滔滔不绝，无数鸡汤如水坝开闸搬倾泻而出。  我知道这些想法来源于我的经历和实践后的思考，也非常希望他们有个好的未来，所以就着昨天我大堤垮掉的机会，结合我的经历谈谈大学和工作吧，也许以后我就可以不用再霹雳跨啦地给晚辈们倾泻了，他们看这篇博客足矣。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;起点也许很低：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;初高中自己成绩并不好，早早地恶性循环也丧失了兴趣，但也不是差的没底，到高中都是读的县城里最好的学校，高考没考上本科。  自己选择了一个专科学校，因为自愿填报的失误，可能选了一个各方面最差的学校，怎么个差法呢？  学校还没高中大，只有几十亩，学生只有几百人，都是200分左右的，而我当年高考是400多分。  高中同班女朋友复读（她成绩比我好，父母条件也还可以，对她要求也自然比我家里高）。  我为什么没复读呢，核心原因是我早已讨厌那些知识（兴趣来源于成就感），让我复读我感觉到恐惧，我觉得用一年去学习那些知识有点浪费青春（这话仅针对我自己，不教唆他人），再个是家里条件确实不好，会给家里很大的负担。  高考结束那个暑假无疑是痛苦的，对于很多高考失利的人来说，对未来会有恐慌，感觉还是很挫败。 &lt;/p&gt;
&lt;p&gt;这几年很多大学升为本科，本科的招生人数也一直在提升，就业竞争同样激烈，时刻看清自己的处境很重要。  起点很低，可是不能自甘堕落。大学完全可以重新开始，一切还来得及。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;抓住任何成长的机遇：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;大学里，有很多事情可以去做，社团，学生会，学习专业知识，大把的时间，能带你成长的老师或者学长。  机会和优秀的资源总会有，只要你积极，只要你抓住。&lt;/p&gt;
&lt;p&gt;大学以前，因为成绩不好，几乎没有机会当个“一官半职”的，大家都知道职位是给成绩最好的同学的。  大部分时候，得不到机会，自己就几乎慢慢选择远离了，即便还是有点羡慕。  大学大部分是学生内部选举，你有各种机会去展现自己，去和同学竞争，一官半职不是给你什么权利，而是给你更好成长的机会。  其实我本来就是个爱出风头的人，大学的我似乎爆发了，喜欢去参加各种活动和比赛，我当主持人，参加朗诵比赛、唱歌比赛、编程比赛、篮球赛、 组织音乐社、文学社， 后来还当上了学生会副主席，写学生会网站，组织运动会等等，总之很会搞事。  而这一切，并不是看起来那么完美，背后面临各种问题，辛苦、疲惫、失落，同样也有支持，老师的引导。  世界从不缺少舞台，很多时候老师和学校就把机会摆在你的面前，那是希望你成长，锻炼你。  我没有拒绝，但有时候也不是完全很爽快的接受（因为真的很累，很麻烦，耽误我玩儿的时间），慢慢到最后变成自己喜欢去做事情。&lt;/p&gt;
&lt;p&gt;学习C语言的时候，阴差阳错的被老师逼着学了一下，结果发现还挺有趣，有个辅导老师，他非常愿意私下教给我们知识，我每天下课会去他办公室玩儿和请教他。后来学校给我和几个同学专门提供了一个办公室，有好的电脑和网络，我们长期在里面玩儿游戏和学习。有很多老师愿意给学生提供机会，付出他们所能的，何不接受这些机会？&lt;/p&gt;
&lt;p&gt;这些宝贵的经验经历，对我后来的工作影响深远。  也有很多人本来有机会的，他们都拒绝了，不想让自己太累，太麻烦。或者中途被情绪所左右，半途而废了。 成长是有代价的，同样悠闲也是有代价的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;去学生会干一番事情：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;学生会是个大熔炉，淘尽英雄。  你可以去试试，不管你专业成绩好坏， 出社会后是综合能力的竞技。  很多时候，你会觉得那里面似乎有很多丑恶，我不否认，有些学生干部上梁不正，对下面进行了错误的引导，在办事的时候也很霸道，自以为高高在上。  不要因为觉得他们不对，就远离。  你应该成为一个变革者，你觉得他们做法不对，那么你想办法坐上那个位置，去实现你的想法，去做你觉得对的事情。  或者选一个好的老大，跟着他走你觉得对的路。  工作中也一样，你觉得这种方案不好，那么提出你觉得对的方案，并且去实现它，而不是否定了别人之后，就没有然后了。  站出来是一种勇气，让自己立足于同学之中，在学生会里做一个受人尊敬的干部，出社会你就可能是一个受人尊敬的领导。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;不要在意那些蝇头小利，看远一点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我的老师告诉我，不要去做兼职挣外快，你应该看长远，把技能知识学好，出去你能拿更高的工资。  他说，同届的同学读书时兼职可以挣一点点钱，在大学可以活得很滋润，看起来让人羡慕，但是当他毕业以后，他可能还是做的那些事情，而技能过关的同学出去找工作，一下就拉开了距离。  当然偶尔去体验一下兼职，也未尝不可，都根据自己的情况吧，有些家里太贫困了的，没办法也必须解决生存问题。&lt;/p&gt;
&lt;p&gt;如果你作为一个学生会干部，可能有一些机会可以获得好处，但是千万不要为了利益去损害其它同学的利益，也不要老是想办法去获取利益，你应该是把做好事情、处理好同学关系放在首位，那些利益，只是一点点激励，应该去用它们激励更多做了实事的同学。  道德的层次无限强大。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;和恋人一起奋斗更可爱：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;两个人在一起，要可持续发展，是需要很大的能力去维持，去奋斗的。  随着相处时间的拉长，一切新鲜感和激情终将变淡。  而让你们在一起的理由，更会是对对方的欣赏，能力的匹配，各方面的均衡。  拉着对方一起成长，让生活变得更好，会发现这种感情更牢固，更可爱。  这样的感情，你会更珍惜。  一个可持续稳定的感情，也会帮助你的学业和事业，让你更专注于它们。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;承担很累、很麻烦，但突飞猛进：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;无论是职场还是学校，你去承担更多的事情，都会伴随着痛苦，特别是你不擅长的知识领域，或者没做过的事情。  最初做这些事情的时候，你会很痛苦，寸步难行，一旦你经历过一两次之后，你就掌握了，你不仅学会的是一方面的知识，而是你发现，只要你去做，去折腾，你能学会，很多事情不是靠天赋，而是靠坚持和坚定。  打破自己的牢笼，需要机会，需要承担，给自己创造成长的机会，并且坚持下来，你的承受能力会越来越强。 &lt;/p&gt;
&lt;p&gt;我大学到工作这几年，我每次做完一件比较大的事情或者经历一段时间辛苦工作之后，我都发觉自己承受能力更强了。  原本一件几个小时就能做完的事情或者一项工作任务，在做之前和过程中，我都会觉得很难受，很想逃避。 到后来组织一个大型活动，做一些有挑战的工作，从心理就直接对他们并不畏惧了。  我认为，这就是成长。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;向比你强的人学习：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;别人的优点，我们都应该学习，不管你讨厌他，还是喜欢他。 客观的看待，承认别人的优点，其次才是学习。 看到牛逼的人，我们为之喝彩，既然看到别人那么牛逼，自己那么羡慕，何不给自己几年的时间，让自己也成为牛逼的人。 我初中开始很喜欢周杰伦，看到他弹钢琴的时候，真的是太帅了。 后来我坚持练琴了7-8年，直到这一两年才渐渐的摸的少了。 虽然也不是很厉害，业余水平，但是自己这么多年做到了。 包括看到写技术博客的牛人前辈们，我也向他们学习。坚持写了3年多。 &lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;职场并不同情小白：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;大学就几年时间，出社会后，大多数人感觉是一记闷棍，面临生存，面临技能不足。  不管是走自己专业的路线，还是想另寻出路，你都得提前准备好。  我老师教我的，你学编程，有很多方向，那么你选一个自己感兴趣的，去招聘网站看职位的要求，然后自己去学习。   如果你不知道以后你要做什么，你打开招聘网站，你去看每一个分类，每一个职位，你看到高待遇的岗位，你点开，你会发现要求好高，似乎达不到，你看到低待遇的岗位，你会发现要求好低，但似乎同样也不好做。  所以你慌张了吗？  你预见毕业后的自己了吗？&lt;/p&gt;
&lt;p&gt;你出去面试，你告诉面试官，我都不会，但是我愿意学，我什么都干，我不要工资。 面试官会鄙视你，你不会，读书去干什么了？ 你愿意学，怎么不早学？ 你不要工资，你能坚持多久？  而你如果告诉面试官，我大学时候就想成为xxx，我主动发掘招聘网站的要求，去学习了什么知识，并且取得了什么成绩，OK，你已经告诉了面试官，你愿意学，你有潜力了。&lt;/p&gt;
&lt;p&gt;所以现在大部分编程技术招聘，会很看重博客或者github呢，因为这是最能体现你工作各方面的证据，&lt;strong&gt;Talk is cheap. Show me the code（知乎上的解释：屁话少说，放码过来。）。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;要有自己的判别能力：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;很多时候，我们对某些领域完全不了解，我们会请教别人，可你并不知道他是否是吹牛，是否可靠。 如果你没有判断能力，你可能被坏人带进坑里，有些坑让你十年都爬不起来。 现在互联网这么发达，利用搜索引擎，把你接触到的事情，都去搜索一下，查询一下，多了解，多思考，不要尽信。  慢慢的，别人吹牛逼的时候，你一下就能看出来是真是假。  说了这么多，其实就是说如何选择是很重要的，这废话谁都知道，如果你做一个事情不能说服别人，也许你就是没有搞清楚你选择的理由。  选择一定要有理由，不能赌。  你的青春很短，你赌不起。&lt;/p&gt;
&lt;p&gt;现在编程技术框架那么多，到底什么最好，适合什么项目，作为一个架构师，如何选用技术，你都得了解它们，并得出有理由的结论。 程序不能乱写，人生亦如此。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;坚持做一件需要长时间坚持的事情：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果你坚持过做好一件事情，并且把它做得还算不错，做得深入，你更容易成为牛逼的人。  万事相通，你做任何一件其它事情，你就有好的方法论了。  你知道要做出成绩需要长时间的坚持，当有一天，你会发现你如果一段时间不学习，不提升的时候，你就心里发慌，这种感觉驱使你去学习，  那么你更不容易被社会淘汰。&lt;/p&gt;
&lt;p&gt;说实话，我学习编程的态度和一些想法，来源于我几年的练琴。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;一步步爬：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;立志高远，但也要看清自己脚下的路，也许刚工作找不到好的公司，到了一个自己都觉得很烂的公司，别气馁，先把事情做好，赚足了经验，马上走。  不能一次性到好的公司，就在更次的公司把所有事情做好，慢慢地能力达到了，你就能有机会去梦寐以求的公司。  就和游戏里打怪升级一样，一路杀到魔王殿。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;不要依赖别人：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;你唯一可以依赖的，仅仅是自己。何为依赖？你觉得谁能帮你把你自己的事情搞定；你觉得父母都能为你提供；你觉得这个事情，你不做，有人会做等等。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;结语：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;说了这么多，无非几个思想：分析自己的处境；  做适合自己的选择；  以成长为目的，担负起更多责任，打破对做事的认知； 把握机遇，去锤炼自己； 抛弃一些懒惰，多一些积极；向牛逼的人靠近，向给你提供条件帮助你学习的老师靠近。以上结合了我自己的经历，希望文章能更形象。&lt;/p&gt;
&lt;p&gt;不知道，大湿人这篇鸡汤大家可否满意。到最后，对以上，吟湿一首如何：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本来一落虫，瞧瞧低头走；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自知弱菜鸡，牛人四处有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可愿抬起头，肩担抖一抖；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回头是闲悠，前方无尽头。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Oct 2017 13:32:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1wen/p/7736092.html</dc:identifier>
</item>
</channel>
</rss>