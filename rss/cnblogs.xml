<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ubuntu命令行连接WPA/WPA2无线网线 - v5captain</title>
<link>http://www.cnblogs.com/v5captain/p/8724850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v5captain/p/8724850.html</guid>
<description>&lt;p&gt;一，连接无加密无线网络zhang：&lt;br/&gt;sudo ip link set wlan0 up&lt;br/&gt;sudo iw dev wlan0 connect zhang&lt;br/&gt;sudo dhclient wlan0&lt;/p&gt;
&lt;p&gt;二，连接WPA/WPA2加密无线网络zhang&lt;br/&gt;输入命令wpa_passphrase zhang 产生如下配置文件，zhang是无线网ssid，回车后输入密码12345678：&lt;br/&gt;$ wpa_passphrase zhang&lt;br/&gt;# reading passphrase from stdin&lt;br/&gt;12345678&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
network=&lt;span&gt;{
ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#psk&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
psk&lt;/span&gt;=&lt;span&gt;ffecda21c80fbd09e188f4b0733b0be26286204fc77c8ebbbaf40a1518f4fb12
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把以上命令的输出保存为配置文件/etc/wpa_supplicant.conf，假设无线接口为wlan0，可用下面的命令测试一下&lt;/p&gt;
&lt;p&gt;$ sudo ifconfig wlan0 up&lt;br/&gt;$ wpa_supplicant -i wlan0 -c /etc/wap_supplican.conf&lt;br/&gt;$ sudo dhclient wlan0&lt;/p&gt;
&lt;p&gt;-i参数指定无线网络接口，-c指定配置文件，参数值前不要留空格。&lt;br/&gt;查看有没有获取到IP，路由是否正常。&lt;br/&gt;ifconfig wlan0&lt;br/&gt;route -n&lt;/p&gt;
&lt;p&gt;确认电脑上有没有无线卡，没有识别出来就找找驱动，或者找个免驱的USB无线网卡&lt;br/&gt;$ iwconfig&lt;br/&gt;eth0 no wireless extensions.&lt;/p&gt;
&lt;p&gt;wlan0 IEEE 802.11abgn ESSID:&quot;zhang&quot;&lt;br/&gt;Mode:Managed Frequency:2.427 GHz Access Point: 10:48:B1:E8:7D:B2&lt;br/&gt;Bit Rate=6.5 Mb/s Tx-Power=20 dBm&lt;br/&gt;Retry short limit:7 RTS thr:off Fragment thr:off&lt;br/&gt;Power Management:off&lt;br/&gt;Link Quality=70/70 Signal level=-28 dBm&lt;br/&gt;Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0&lt;br/&gt;Tx excessive retries:12 Invalid misc:18 Missed beacon:0&lt;/p&gt;
&lt;p&gt;三，连接WEP加密网络：&lt;br/&gt;$ sudo iw dev wlan0 connect [网络 SSID] key 0:[WEP 密钥]&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 15:28:00 +0000</pubDate>
<dc:creator>v5captain</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/v5captain/p/8724850.html</dc:identifier>
</item>
<item>
<title>网络编程——客户/服务器程序设计范式 - herelsp</title>
<link>http://www.cnblogs.com/herelsp/p/8724705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/herelsp/p/8724705.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;50.5&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-eb452d9a98ebc170.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;网络编程&quot; title=&quot;网络编程&quot;/&gt;网络编程
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;我们在需要开发一个服务器程序时，有较多的的程序设计范式可供选择，不同范式有其自身的特点和实用范围，明了不同范式的特性有助于我们服务器程序的开发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端程序通常比服务器容易些，当然客户端程序也可以使用这些程序设计范式，因为它们蕴含的道理都是想通的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本文所设计的服务器主要是指基于TCP的服务器&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;迭代服务器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;迭代TCP服务器 &lt;strong&gt;总是在完全处理某个客户的请求之后才开始下一个客户的请求处理&lt;/strong&gt;。&lt;br/&gt;这样的服务器实际中比较少见。&lt;br/&gt;&lt;strong&gt;基于UDP的大多服务器却是这样实现&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;hfork&quot;&gt;&lt;span&gt;并发服务器，每个客户请求fork一个子进程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;传统并发服务器 &lt;strong&gt;调用fork派生一个子进程来处理每个客户，这使得服务器能够同时为多个客户服务，每个进程一个客户&lt;/strong&gt;。&lt;br/&gt;客户数目的唯一限制是操作系统对其能够同时拥有多少子进程的限制。&lt;br/&gt;绝大多数TCP服务器程序都是按这个范式编写。&lt;br/&gt;并发服务器的问题在于为每个客户现场fork一个子进程比较耗费CPU时间。&lt;/p&gt;
&lt;h3 id=&quot;haccept&quot;&gt;&lt;span&gt;预先派生子进程，每个子进程无保护地调用accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;不同于传统意义的并发服务器那样为每个客户现场派生一个子进程，而是 &lt;strong&gt;在启动阶段预先派生一定数量的子进程，当有客户连接到达时，这些子进程就能立即为它提供服务&lt;/strong&gt;。&lt;br/&gt;这种技术的有点在于无需引入父进程执行fork的开销就能处理新到来的客户。缺点是父进程必须在服务启动阶段猜测需要预先派生多少子进程。如果某个时刻客户数恰好等于子进程总数，那么新到的客户将被忽略，直到至少有一个子进程完成处理重新可用。&lt;/p&gt;
&lt;h3 id=&quot;haccept-1&quot;&gt;&lt;span&gt;预先派生子进程,使用文件上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在多个进程中引用同一个监听套接字的描述符上调用accept的做法在某些系统实现是不被支持的，那么解决办法是让应用进程在调用accept前后安装某种形式的锁(lock),这样任意时刻只有一个子进程阻塞在accept调用中，其他子进程则阻塞在获取保护accept的锁上。&lt;br/&gt;这里使用文件锁来保护,文件锁涉及到文件系统的操作，可能比较耗时。&lt;/p&gt;
&lt;h3 id=&quot;haccept-2&quot;&gt;&lt;span&gt;预先派生子进程,使用线程互斥锁上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比于 &lt;strong&gt;预先派生子进程,使用文件上锁保护accept&lt;/strong&gt;，使用线程锁保护accept，这种方法 &lt;strong&gt;不仅适用于同一进程内各个线程间的锁保护，而且能够用于不同进程之间的锁保护&lt;/strong&gt;。&lt;br/&gt;在不同进程间的锁保护需要注意的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;互斥锁变量必须存放在由所有进程共享的内存区中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;必须告知线程函数库这个锁是用于不同进程间共享的互斥锁&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;预先派生子进程，父进程向子进程传递套接字描述符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;只让父进程嗲用accept，然后把所接受的已经连接的套接字 &lt;strong&gt;传递&lt;/strong&gt; 给某个子进程。&lt;br/&gt;这样绕过了为所有子进程的accept调用提供上锁保护的需求，但是需要从父进程到子进程进行某种形式的描述符传递。&lt;br/&gt;这种技术会上代码比较复杂，父进程必须跟踪子进程的闲忙状态，以便于给空闲的子进程传递新的套接字。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;并发服务器，每个客户端请求创建一个线程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比于多进程模型，如果服务器主机提供支持线程，我们可以改用线程以取代进程。线程相比于进程的优势这里不再累述。&lt;/p&gt;
&lt;h3 id=&quot;haccept-3&quot;&gt;&lt;span&gt;预先创建线程服务器，使用互斥锁上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比预先派生一个子进程池快于为每个客户线程fork一个子进程池类似的道理，在有线程支持的系统上，预先创建的线程池取代为每个客户现场创建一个线程的做法有类似的性能提升。&lt;br/&gt;这种模式的基本设计是预先创建一个线程，并让每个线程各自调用accept，取代让每个线程都阻塞在accept调用中的做法，使用互斥锁保证任何时刻只有一个线程在调用accept。&lt;/p&gt;
&lt;h3 id=&quot;haccept-4&quot;&gt;&lt;span&gt;预先创建线程服务器，由主线程调用accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;程序启动阶段创建一个线程池后让主线程调用accept；&lt;br/&gt;主线程把每个客户连接传递给池中某个可用的线程，类似于进程版本的做法。&lt;br/&gt;这样的设计问题在于主线程如何将一个已连接套接字传递给线程池中某个可用线程&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们有很多实现手段，本可用如前面一样使用描述符传递，但是既然所有线程和所有描述符都在同一个进程中，那么也就没有必要把一个描述符从一个线程传递到另一个线程。接收线程只需要知道这个已连接套接字描述符的值（&lt;strong&gt;传递描述符可不只是传递这个值，事实上是需要传递这个套接字的引用，因此也将返回一个不同于原值的描述符，该套接字的引用计数也会增加&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;strong&gt;系统负载较轻时&lt;/strong&gt;，每来一个客户请求现场派生一个子进程为之服务的传统并发服务器程序模型就足够了&lt;/li&gt;
&lt;li&gt;相比传统的每个客户fork一次设计范式，&lt;strong&gt;预先创建一个子进程池或一个线程池的范式能够把进程控制CPU时间降低10倍或以上&lt;/strong&gt;。编写这些范式的程序并不会复杂，不过会有额外的工作，比如监视现在子进程数，随着所服务客户数的动态变化而增加或减少这个数目&lt;/li&gt;
&lt;li&gt;&lt;span&gt;某些实现允许多个子进程或线程阻塞在同一个accept调用中，另外的实现却要求对accept调用需要某种类型的锁加以保（文件锁或者互斥锁等）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accept并把描述符传递个子进程或线程来的简单和快捷&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于潜在select冲突的原因，让所有子进程或线程阻塞在同一accept调用中比让他们阻塞在同一个select调用中更可取。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;线程通常远快于使用进程&lt;/strong&gt;，不过选择每个客户一个子进程还是每个客户一个线程取决于操作系统提供什么支持(某些系统不提供线程支持)，还可能取决于为服务每个客户需要激活其他什么程序。例如，如果accept客户连接的服务器调用fork和exec，那么fork一个单线程的进程可能快于fork一个多线程的进程，另外还有资源等方面的综合考虑。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 05 Apr 2018 14:53:00 +0000</pubDate>
<dc:creator>herelsp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/herelsp/p/8724705.html</dc:identifier>
</item>
<item>
<title>Spring+Hibernate+Struts(SSH)框架整合 - 佳先森</title>
<link>http://www.cnblogs.com/cailijia52o/p/8724710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cailijia52o/p/8724710.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;前言：有人说，现在还是流行主流框架，SSM都出来很久了，更不要说SSH。我不以为然。现在许多公司所用的老项目还是ssh，如果改成主流框架，需要成本。再说比如金融IT这一块，数据库dao层还是推荐使用的是hibernate，因为能够快速开发上手，除非是互联网，因涉及到高并发，dao层用的是mybatis，数据交互效率较快。所以，SSH不容忽略。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一、什么是SSH&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;SSH是 struts+spring+hibernate的一个集成框架，是目前比较流行的一种Web应用程序开源框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做管理，管理struts和hibernate。具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做管理，管理struts和hibernate。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;---------百度百科&lt;/p&gt;
&lt;h2&gt;二、SSH所涉及的部分&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405194147732-378649854.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405194247033-1741358821.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、快速部署环境&lt;/h2&gt;
&lt;p&gt;这里利用保存客户的小Demo来演示整合SSH&lt;/p&gt;
&lt;h3&gt;　　1.导入所需jar包　&lt;/h3&gt;
&lt;p&gt; 　　1）. Struts2框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;         * struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar        -- Struts2需要的所有jar包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * struts2-spring-plugin-2.3.24.jar                          ---Struts2整合Spring的插件包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195041020-1959264726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;　　2）. Hibernate框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * hibernate-release-5.0.7.Final\lib\required\*.jar          -- Hibernate框架需要的jar包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * slf4j-api-1.6.1.jar                                       -- 日志接口&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * slf4j-log4j12-1.7.2.jar                                   -- 日志实现&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * mysql-connector-java-5.1.7-bin.jar                        -- MySQL的驱动包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195018418-2002571809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;　　3）. Spring框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * IOC核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * AOP核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * JDBC模板和事务核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合JUnit测试包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合Hibernate核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合Struts2核心包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195109578-488510827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、在web.xml中配置spring与struts的相关代码&lt;/h3&gt;
&lt;p&gt;　　1）配置struts2核心过滤器&lt;/p&gt;
&lt;p&gt;　　这里定义为拦截所有&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 配置核心过滤器 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）配置spring的监听器&lt;/p&gt;
&lt;p&gt;　　当服务启动时，就会先加载spring的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 配置Spring框架整合WEB的监听器 --&amp;gt;
     &amp;lt;listener&amp;gt;
           &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）配置默认加载路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&amp;gt;
    &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结：web.xml全部代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置Spring框架整合WEB的监听器 --&amp;gt;
     &amp;lt;listener&amp;gt;
           &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
    &amp;lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&amp;gt;
    &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
  &amp;lt;!-- 配置核心过滤器 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、src下编写相关配置文件&lt;/h3&gt;
&lt;p&gt;　　1)spring:applicationContext.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）hibernate:hibernate.cfg.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束，并配置数据库&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-&lt;span&gt;configuration PUBLIC
    &lt;/span&gt;&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
    
    &amp;lt;session-factory&amp;gt;
        &amp;lt;!-- 必须配置 --&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.174.130:3306/SSH&amp;lt;/property&amp;gt;&lt;/span&gt;
        &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;root&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;root&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 可选配置 --&amp;gt;
        &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 配置C3P0的连接池 --&amp;gt;
        &amp;lt;property name=&quot;connection.provider_class&quot;&amp;gt;org.hibernate.connection.C3P0ConnectionProvider&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 不能配置绑定当前的线程的操作 --&amp;gt;
        &amp;lt;!-- 映射配置文件 --&amp;gt;
        &amp;lt;mapping resource=&quot;com/clj/domain/Customer.hbm.xml&quot;/&amp;gt;
    &amp;lt;/session-factory&amp;gt;
    
&amp;lt;/hibernate-configuration&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）配置log4j.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### direct log messages to stdout ###
log4j.appender.stdout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target&lt;/span&gt;=&lt;span&gt;System.err
log4j.appender.stdout.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{1}:%L - %m%&lt;span&gt;n

### direct messages to file mylog.log ###
log4j.appender.file&lt;/span&gt;=&lt;span&gt;org.apache.log4j.FileAppender
log4j.appender.file.File&lt;/span&gt;=&lt;span&gt;c\:mylog.log
log4j.appender.file.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{1}:%L - %m%&lt;span&gt;n

### set log levels &lt;/span&gt;- &lt;span&gt;for&lt;/span&gt; more verbose logging change 'info' to 'debug'&lt;span&gt; ###

log4j.rootLogger&lt;/span&gt;=info, stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4)struts2:struts.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
    &lt;/span&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.1//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;
&amp;lt;struts&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结：src所需配置文件如图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405200824770-1891254572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3、配置dao层&lt;/h3&gt;
&lt;p&gt;　　定义一个接口和其实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        &lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、定义业务层接口和实现类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
     &lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5、定义pojo类&lt;/h3&gt;
&lt;p&gt;　　hibernate通过操作pojo类来操作数据库表，做到对象关系映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.domain;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_user_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_create_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_source;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_linkman;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_user_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_user_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_user_id(Long cust_user_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_user_id =&lt;span&gt; cust_user_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_create_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_create_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_create_id(Long cust_create_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_create_id =&lt;span&gt; cust_create_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_source() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_source;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_source(String cust_source) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_source =&lt;span&gt; cust_source;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_linkman() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_linkman;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_linkman(String cust_linkman) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_linkman =&lt;span&gt; cust_linkman;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; +&lt;span&gt; cust_name
                &lt;/span&gt;+ &quot;, cust_user_id=&quot; + cust_user_id + &quot;, cust_create_id=&quot;
                + cust_create_id + &quot;, cust_source=&quot; +&lt;span&gt; cust_source
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot;
                + cust_level + &quot;, cust_linkman=&quot; +&lt;span&gt; cust_linkman
                &lt;/span&gt;+ &quot;, cust_phone=&quot; + cust_phone + &quot;, cust_mobile=&quot; +&lt;span&gt; cust_mobile
                &lt;/span&gt;+ &quot;]&quot;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、定义Customer.hbm.xml&lt;/h3&gt;
&lt;p&gt;　　此配置文件关乎Customer这个pojo类，此文件需放在Customer pojo类同个包下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-&lt;span&gt;mapping PUBLIC 
    &lt;/span&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
    
&amp;lt;hibernate-mapping&amp;gt;
    
    &amp;lt;&lt;span&gt;class&lt;/span&gt; name=&quot;com.clj.domain.Customer&quot; table=&quot;cst_customer&quot;&amp;gt;
        &amp;lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&amp;gt;
            &amp;lt;generator &lt;span&gt;class&lt;/span&gt;=&quot;native&quot;/&amp;gt;
        &amp;lt;/id&amp;gt;
        
        &amp;lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&amp;gt;
        
    &amp;lt;/&lt;span&gt;class&lt;/span&gt;&amp;gt;
    
&amp;lt;/hibernate-mapping&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　项目构建大致图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405202819615-178460725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、demo之保存客户初步演示&lt;/h2&gt;
&lt;p&gt;　　这里先初略的定义持久层交给heibernate，业务层交个struts2，创建实例交给spring&lt;/p&gt;
&lt;h3&gt;　　1、定义一个保存客户的界面，利用form表单进行数据的提交&lt;/h3&gt;
&lt;p&gt;　　根据域名可知，这里利用的是struts2的通配符方式进行访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;FORM id=form1 name=&lt;span&gt;form1
        action&lt;/span&gt;=&quot;${pageContext.request.contextPath }/customer_add.action&quot;&lt;span&gt;
        method&lt;/span&gt;=post&amp;gt;
           &amp;lt;!--table部分省略--&amp;gt;
&amp;lt;/FORM&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、在struts.xml中配置接受请求，根据action名和方法跳转指定的action，执行指定的方法&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;spring整合struts2方式一：action由struts2框架管理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　 * 因为导入的struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml &lt;span&gt;，该配置文件中有如下代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * &amp;lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&amp;gt;   开启一个常量，如果该常量开启，那么下面的常量就可以使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        * struts.objectFactory.spring.autoWire = name，该常量是可以让Action的类来自动装配Bean对象！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
    &lt;/span&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.1//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;
&amp;lt;struts&amp;gt;
    &amp;lt;!-- 配置包结构 --&amp;gt;
        &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;crm&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot; namespace=&quot;/&quot;&amp;gt;
            &amp;lt;!-- 配置客户的Action --&amp;gt;
            &amp;lt;!--&lt;span&gt;  方式一：aciton由struts2框架管理&lt;/span&gt;--&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　&lt;/span&gt;&amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; method=&quot;{1}&quot;/&amp;gt; &lt;br/&gt;　　　　&amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、在spring的applicationContext.xml中配置相对应的bean以及事务&lt;/h3&gt;
&lt;p&gt;　　     这里利用spring中IOC(控制反转)的特性，将创建实例的任务交给spring框架管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;hibernateTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;
        &amp;lt;!-- 注入sessionFactory  --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、编写持久层实现类相关代码&lt;/h3&gt;
&lt;p&gt;　　这里利用hibernate提供的模板类，内部封转了session，从而可以调用session中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
   &lt;span&gt; private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
       &lt;/span&gt; &lt;span&gt;h&lt;/span&gt;iber&lt;span&gt;nateTemplate().save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5、编写业务层实现类相关代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、编写action相关代码&lt;/h3&gt;
&lt;p&gt;　　这里通过struts2的模板类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.web.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.struts2.ServletActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.support.WebApplicationContextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的控制层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven&amp;lt;Customer&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不要忘记手动new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Customer customer=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供service成员属性，提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    
    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerService(CustomerService customerService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerService =&lt;span&gt; customerService;
    }



    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;WEB层，保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：创建web的工厂（action由struts2创建）&lt;/span&gt;
        &lt;span&gt;WebApplicationContext context=WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext());
        CustomerService cs=(CustomerService) context.getBean(&quot;customerService&quot;);
        //调用方法
        cs.save(customer);&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、项目优化之整合&lt;/h2&gt;
&lt;h3&gt;　　1、 spring整合struts2方式二：action由spring框架管理&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;把具体的&lt;/span&gt;Action类配置文件applicatonContext.xml的配置文件中，但是注意：struts.xml需要做修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;struts&amp;gt;
    &amp;lt;!-- 配置包结构 --&amp;gt;
        &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;crm&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot; namespace=&quot;/&quot;&amp;gt;
            &amp;lt;!-- 配置客户的Action --&amp;gt;
            &amp;lt;!--&lt;span&gt;  方式一：aciton由struts2框架管理
            &lt;/span&gt;&amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; method=&quot;{1}&quot;/&amp;gt;--&amp;gt;
            &amp;lt;!-- 方式二：action由spring管理，class标签上只需要编写srping配置bean的ID值既可以--&amp;gt;
             &amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;customerAction&quot; method=&quot;{1}&quot;&amp;gt;&amp;lt;/action&amp;gt;
        &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、在applicationContext.xml中配置Action类&lt;/h3&gt;
&lt;p&gt;　　　注意：1）Spring框架默认生成CustomerAction是单例的，而Struts2框架是多例的。所以需要配置 scope=&quot;prototype&quot;&lt;/p&gt;
&lt;p&gt;　　　　　　2）此时没有struts2的自动装配，在action需要手动配置customerService属性，并在action类中生成set方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、.配置事务&lt;/h3&gt;
&lt;p&gt;　　 spring整合hibernate方式一：&lt;strong&gt;&lt;span&gt;（带有&lt;/span&gt;hibernate.cfg.xml的配置文件。强调：不能加绑定当前线程的配置）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以前玩hibernate时，hibernate.cfg.xml都是由hibernate框架管理，其配置文件能生成sessionFactory,持久层加载此配置文件获取sessionFactory，从而创建工厂生成session，进行数据的增删改成，此时其配置文件应该交给spring管理，充分利用spring的IOC特性&lt;/p&gt;

&lt;p&gt;　　Spring框架提供了一个HibernateDaoSupport的工具类，以后DAO都可以继承该类！！在引入hibernate核心配置文件之前，得让dao层继承一个父类HibernateDaoSupport，此父类内部封装了事务模板&lt;/p&gt;
&lt;p&gt;　　看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405214923738-86679128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）修改相对应的持久层实现类，让他继承HibernateDaoSupport&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）修改业务层让，开启事务注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3）修改applicationContext.xml文件&lt;/p&gt;
&lt;p&gt;　　先引入hibernate配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
    &amp;lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象--&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置平台事务管理：用来管理事务，&lt;span&gt;注意现在使用的是&lt;/span&gt;Hibernate框架，所以需要使用Hibernate框架的事务管理器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　开启事务注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　&amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　去除模板类配置，并为持久层配置sessionFactory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　全部代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
    &amp;lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象--&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    
    &amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置模板类(hibernate框架提供的，内部封装了session)，此时交给spring管理,如果持久层继承了HibernateDaoSupport，则无需配置--&amp;gt;
    &amp;lt;!-- &amp;lt;bean id=&quot;hibernateTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;&lt;span&gt;
        注入sessionFactory 
        &lt;/span&gt;&amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4）修改action类&lt;/p&gt;
&lt;p&gt;　　　　因为注入了业务层实现类，所以此时可以直接调用业务层方法，无须加载bean&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.web.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.struts2.ServletActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.support.WebApplicationContextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的控制层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven&amp;lt;Customer&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不要忘记手动new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Customer customer=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供service成员属性，提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerService(CustomerService customerService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerService =&lt;span&gt; customerService;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;WEB层，保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：创建web的工厂（action由struts2创建）&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;WebApplicationContext context=WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext());
        CustomerService cs=(CustomerService) context.getBean(&quot;customerService&quot;);
        //调用方法
        cs.save(customer);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        customerService.save(customer);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　spring整合hibernate方式二：&lt;strong&gt;&lt;span&gt;（不带有&lt;/span&gt;hibernate.cfg.xml的配置文件）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;这里准备删除hibernate的核心配置文件，在删除之前，需要将其配置文件中的相关内容配置到spring的applicatioinContext.xml文件中取&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　1、查看hibernate.cfg.xml文件中的相关内容&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;  　　&lt;span&gt;  * 数据库连接基本参数（4大参数）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;   　　 * Hibernate相关的属性&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;   　　 * 连接池&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;    　　* 映射文件&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;16&quot;&gt;&lt;span&gt;　　2、引入配置&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　引入连接池&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 先配置C3p0的连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改对应的sessionFactory:&lt;span&gt;因为已经没有了&lt;/span&gt;hibernate.cfg.xml的配置文件，所以需要修改该配置，注入连接池&lt;/p&gt;
&lt;p&gt;　　引入对象映射文件：因为已经没有了hibernate.cfg.xml的配置文件，不会扫描到该配置文件，需要注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--先加载连接池 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!-- 加载方言，加载可选项 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 引入映射的配置文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/clj/domain/Customer.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在：applicationContext.xml全部代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    
    &amp;lt;!-- 先配置C3p0的连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--先加载连接池 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!-- 加载方言，加载可选项 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 引入映射的配置文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/clj/domain/Customer.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    
    &amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
      &lt;span&gt;  &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;&lt;/span&gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置模板类(hibernate框架提供的，内部封装了session)，此时交给spring管理,如果持久层继承了HibernateDaoSupport，则无需配置--&amp;gt;
    &lt;span&gt;&amp;lt;!-- &amp;lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;
        注入sessionFactory 
        &amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;&lt;/span&gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时可以安心的删除hibernate.cfg.xml文件了&lt;/p&gt;
&lt;p&gt;　　这样SSH整合完毕&lt;/p&gt;
&lt;h2&gt;六、Hibernate模板常用方法&lt;/h2&gt;
&lt;p&gt;　　注意：以下代码省略了接口中的演示(偷了个懒，相信初学者不会看不懂)&lt;/p&gt;
&lt;p&gt;　　1）插入：&lt;/p&gt;
&lt;p&gt;　　持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.criterion.DetachedCriteria;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().update(customer);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }
&lt;/span&gt;&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        customerDao.update(customer);
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试Hiberante模板类的简单方法
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;customerService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        Customer customer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        customer.setCust_id(&lt;/span&gt;1L&lt;span&gt;);
        customer.setCust_name(&lt;/span&gt;&quot;测试&quot;&lt;span&gt;);
        customerService.update(customer);
    }&lt;/span&gt;&lt;span&gt;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）以下为指定查询、查询所有、离线查询代码&lt;/p&gt;
&lt;p&gt;　　持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.criterion.DetachedCriteria;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().save(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().update(customer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过主键查询
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getById(Long id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getHibernateTemplate().get(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, id);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAll() {
        String sql&lt;/span&gt;=&quot;from Customer&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=(List&amp;lt;Customer&amp;gt;) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().find(sql);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * QBC离线查询
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAllByQBC() {
        DetachedCriteria criteria&lt;/span&gt;=DetachedCriteria.forClass(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=(List&amp;lt;Customer&amp;gt;) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().findByCriteria(criteria);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        customerDao.update(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getById(Long id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.getById(id);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.findAll();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAllByQBC() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.findAllByQBC();
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试Hiberante模板类的简单方法
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;customerService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        Customer customer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        customer.setCust_id(&lt;/span&gt;1L&lt;span&gt;);
        customer.setCust_name(&lt;/span&gt;&quot;测试&quot;&lt;span&gt;);
        customerService.update(customer);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试查询指定的客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        Customer customer&lt;/span&gt;=customerService.getById(2L&lt;span&gt;);
        System.out.println(customer);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有的客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run3(){
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=&lt;span&gt;customerService.findAll();
        System.out.println(list);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * QBC(离线查询)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run4(){
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=&lt;span&gt;customerService.findAllByQBC();
        System.out.println(list);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;七、关于SSH延迟加载问题&lt;/h2&gt;
&lt;h3 class=&quot;16&quot;&gt;　1. 使用延迟加载的时候，再WEB层查询对象的时候程序会抛出异常！&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;    * 原因是延迟加载还没有发生SQL语句，在业务层session对象就已经销毁了，所以查询到的JavaBean对象已经变成了托管态对象！&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 注意：一定要先删除javassist-3.11.0.GA.jar包（jar包冲突了）&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;16&quot;&gt;　2. 解决办法&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;　Spring框架提供了一个过滤器，让session对象在WEB层就创建，在WEB层销毁。只需要配置该过滤器即可&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 但是：要注意需要在struts2的核心过滤器之前进行，spring监听器之后配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 解决延迟加载的问题 --&amp;gt;
         &amp;lt;filter&amp;gt;
            &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;filter-mapping&amp;gt;
            &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、演示延迟加载&lt;/h3&gt;
&lt;p&gt;　　持久层：调用load方法，此方法时延迟加载的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 延迟加载
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Customer loadById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getHibernateTemplate().load(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Customer loadById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.loadById(id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run5(){
        Customer customer&lt;/span&gt;=customerService.loadById(2L&lt;span&gt;);
        System.out.println(customer);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;











</description>
<pubDate>Thu, 05 Apr 2018 14:53:00 +0000</pubDate>
<dc:creator>佳先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cailijia52o/p/8724710.html</dc:identifier>
</item>
<item>
<title>美团点餐—listview内部按钮点击事件 - CMusketeer</title>
<link>http://www.cnblogs.com/cmusketeer/p/8724639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmusketeer/p/8724639.html</guid>
<description>&lt;p&gt;PS：长时间不写博客了，今天来写一下美团的这个点餐界面，今天先写一个加号减号的接口调用，下一篇是整体，有点菜，评价，商家，还有左边的listview和右边的展示项。进入这篇正题，像listview，GridView等这些view都有写好的一些点击监听，但有些并不是咱们想要用到的，比如说listview内部有按钮，咱们要点击，而且还要在该item项上做一些操作，比如说数字加减并显示在页面上，实时显示。这就用到了今天的内部点击事件的回调，当然这只是一种方法，也可能有其他更简单的方法。今天就主要说一下类似于美团的加减餐数量的回调。&lt;/p&gt;
&lt;p&gt;美团图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258190/201804/1258190-20180405221600680-1937130481.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图是比较好看的，今天所写的代码就不如这个了，主要是说回调&lt;/p&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主布局里面只有一个listview控件&lt;/li&gt;
&lt;li&gt;item布局样式&lt;/li&gt;
&lt;li&gt;自定义适配器的创建&lt;/li&gt;
&lt;li&gt;activity中回调方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258190/201804/1258190-20180405221743256-2135531749.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1：第一步&lt;/h2&gt;
&lt;p&gt;主布局里添加一个listview，这个就省略了。&lt;/p&gt;

&lt;h2&gt;2：item布局样式&lt;/h2&gt;
&lt;p&gt;布局也是简单的，这里的加号和减号，我没有给大家把图片给大家，随便一个图片即可，就算没有图片一个btn也是可以的&lt;/p&gt;
&lt;p&gt;这里的左边一个textview   ，左右分别是加号和减号，还有一个num（textview）显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;TextView
        android:id=&quot;@+id/id_lv_name&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;火腿&quot;
        android:layout_marginLeft=&quot;5dp&quot;
        android:layout_gravity=&quot;center|left&quot;
        android:textSize=&quot;20dp&quot;
        android:layout_weight=&quot;0.7&quot;/&amp;gt;
    &amp;lt;ImageView
        android:id=&quot;@+id/id_lv_minus&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:src=&quot;@drawable/btnminus&quot;
        android:layout_weight=&quot;0.1&quot;/&amp;gt;
    &amp;lt;TextView
        android:id=&quot;@+id/id_lv_num&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:text=&quot;1&quot;
        android:textSize=&quot;20dp&quot;
        android:gravity=&quot;center&quot;
        android:layout_weight=&quot;0.1&quot;/&amp;gt;
    &amp;lt;ImageView
        android:id=&quot;@+id/id_lv_add&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:src=&quot;@drawable/btnadd&quot;
        android:layout_weight=&quot;0.1&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3：自定义适配器的创建&lt;/h2&gt;
&lt;p&gt;这个是关键，里面需要有自定义的接口用作回调。&lt;/p&gt;
&lt;p&gt;这里面有一个类Item，就是一个实体类，里面只有name和num，和setget方法。具体看注释。&lt;/p&gt;
&lt;h3&gt;3.1首先自定义一个adapter，重写里面的一些方法即可，这里是局部代码。&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MyAdapterListView extends BaseAdapter {
    public Context context;
    public List&amp;lt;Item&amp;gt; list;
    private int num1;


    public MyAdapterListView(Context context, List&amp;lt;Item&amp;gt; list) {
        this.context = context;
        this.list = list;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　3.2　主要是getview方法，这里是又写了一个ViewHolder类。&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public View getView(final int i, View view, ViewGroup viewGroup) {
//        int num=0;
        if(view == null){
            view=LayoutInflater.from(context).inflate(R.layout.lv_item,null);
            viewHolder=new ViewHolder();
            viewHolder.name= (TextView) view.findViewById(R.id.id_lv_name);
            viewHolder.minus= (ImageView) view.findViewById(R.id.id_lv_minus);
            viewHolder.numText= (TextView) view.findViewById(R.id.id_lv_num);
            viewHolder.add= (ImageView) view.findViewById(R.id.id_lv_add);
            view.setTag(viewHolder);
        }
        viewHolder= (ViewHolder) view.getTag();
        viewHolder.name.setText(&quot;&quot;+list.get(i).getName());
        viewHolder.numText.setText(&quot;&quot;+list.get(i).getNum());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　3.3　重点来了创建接口，这里定义了一个方法，需要传入textview控件和  position，和加号（减号）改变的数据。&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//定义接口
    public interface OnMyItemClickListener{
        //ID  ， 数量
        void onBtnItemListener(TextView tv, int i, int num);
    }
    public OnMyItemClickListener onMyItemClickListener;
    public void setOnMyItemClickListener(OnMyItemClickListener onMyItemClickListener){
        this.onMyItemClickListener=onMyItemClickListener;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.4：加号和减号用法// num1 = 0; 加减号 使用接口&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot; readability=&quot;4&quot;&gt;
&lt;em id=&quot;__mceDel&quot; readability=&quot;2&quot;&gt;        viewHolder.minus.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                num1 = list.get(i).getNum();//获取到（减号）改动过的 数量
                num1 = num1 -1;
                if(num1 &amp;lt;=0){//逻辑判断，如果减为0的话，就一直为0，要不然就是符号了。
                    num1 =0;
                }
                onMyItemClickListener.onBtnItemListener(viewHolder.numText,i, num1);//使用刚才自定义的接口。

            }
        });
        viewHolder.add.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                num1 = list.get(i).getNum();//获取到（加号）改动过的 数量&lt;p&gt;　　　　　　　　　　num1++;&lt;/p&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;em id=&quot;__mceDel&quot;&gt; 　　　　　　　　viewHolder.numText.setText(num1 +&quot;&quot;); onMyItemClickListener.onBtnItemListener(viewHolder.numText,i, num1); } });&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4:activity中回调方法&lt;/h2&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
主要还是调用Adapter中创建的接口，然后使用的时候再获取改变的num值，然后通过listData.get(i).setNum(num)修改该id的数据，然后让适配器更新一下。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Item item;
        for (int i = 0; i &amp;lt; 30; i++) {
            item = new Item();
            item.setName(&quot;ceshi&quot; + i);
            item.setNum(0);
            listData.add(item);
        }
        myAdapterListView = new MyAdapterListView(this, listData);
        listview.setAdapter(myAdapterListView);//接口回调adapter中的方法，修改值以后再返回数据，更新适配器
        myAdapterListView.setOnMyItemClickListener(new MyAdapterListView.OnMyItemClickListener() {
            @Override
            public void onBtnItemListener(TextView tv, int i, int num) {
//                Toast.makeText(MainActivity.this, &quot;第：&quot;+i+&quot; 个---&quot;+num, Toast.LENGTH_SHORT).show();
                listData.get(i).setNum(num);
                myAdapterListView.notifyDataSetChanged();
            }
        });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完。　　&lt;/p&gt;


</description>
<pubDate>Thu, 05 Apr 2018 14:39:00 +0000</pubDate>
<dc:creator>CMusketeer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmusketeer/p/8724639.html</dc:identifier>
</item>
<item>
<title>【Learning】 多项式的相关计算 - RogerDTZ</title>
<link>http://www.cnblogs.com/RogerDTZ/p/8724533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RogerDTZ/p/8724533.html</guid>
<description>&lt;h2 id=&quot;约定的记号&quot;&gt;约定的记号&lt;/h2&gt;
&lt;p&gt;　　&lt;br/&gt;　　对于一个多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;，若其最高次系数不为零的项是&lt;span class=&quot;math inline&quot;&gt;\(x^k\)&lt;/span&gt;，则该多项式的&lt;strong&gt;次数&lt;/strong&gt;为&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;.&lt;br/&gt;　　&lt;br/&gt;　　记为&lt;span class=&quot;math inline&quot;&gt;\(deg(A)=k\)&lt;/span&gt;.&lt;br/&gt;　　&lt;br/&gt;　　对于&lt;span class=&quot;math inline&quot;&gt;\(x\in(k,+ \infty)\)&lt;/span&gt;，称&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;都为&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;的&lt;strong&gt;次数界&lt;/strong&gt;. 但一般地，我们都使用&lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt;作为&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;的&lt;strong&gt;次数界&lt;/strong&gt;。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;br/&gt;　　&lt;/p&gt;
&lt;h2 id=&quot;多项式求逆&quot;&gt;多项式求逆&lt;/h2&gt;
&lt;p&gt;　　&lt;br/&gt;　　给定多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;，求其在模&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;意义下的逆多项式&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;，使得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \label{eqn1} A(x)B(x)\equiv1 \pmod {x^n} \end{equation} \]&lt;/span&gt;&lt;br/&gt;　　其中，&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;的次数小于等于&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;的次数.&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　采用倍增思路向上倍增求解.&lt;br/&gt;　　&lt;br/&gt;　　当&lt;span class=&quot;math inline&quot;&gt;\(n=1\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;仅有一个常数项，且&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;的常数项为&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;常数项的逆元。多项式有无逆元也取决于这个常数是否有逆元.&lt;br/&gt;　　&lt;br/&gt;　　假设已经求得&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;在模&lt;span class=&quot;math inline&quot;&gt;\(x^{\lceil\frac n 2\rceil}\)&lt;/span&gt;意义下的逆元&lt;span class=&quot;math inline&quot;&gt;\(B'(x)\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} A(x)B'(x)=1 \pmod{x^{\lceil\frac n 2\rceil}} \end{equation} \]&lt;/span&gt;&lt;br/&gt;　　而&lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt;放在模&lt;span class=&quot;math inline&quot;&gt;\(x^{\lceil\frac n 2\rceil}\)&lt;/span&gt;意义下同样成立，有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \label{eqn2} A(x)B(x)\equiv1 \pmod {x^{\lceil\frac n 2\rceil}} \end{equation} \]&lt;/span&gt;&lt;br/&gt;​　　将&lt;span class=&quot;math inline&quot;&gt;\((3)-(2)\)&lt;/span&gt;得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ B(x)-B'(x)\equiv 0 \pmod {x^{\lceil\frac n 2\rceil}} \]&lt;/span&gt;&lt;br/&gt;　　平方得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0 \pmod {x^n} \]&lt;/span&gt;&lt;br/&gt;​　　模数同时平方的原因是：原本多项式模&lt;span class=&quot;math inline&quot;&gt;\(x^{\lceil\frac n 2\rceil}\)&lt;/span&gt;为0，说明&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;~&lt;span class=&quot;math inline&quot;&gt;\(\lceil\frac n 2\rceil-1\)&lt;/span&gt;项的系数为0，平方后由于系数相乘，这些0系数会导致0~n-1项系数为0，也即模&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;为0.&lt;br/&gt;　　&lt;br/&gt;　　两边同乘&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;，消去&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;并移项，得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ B(x) \equiv 2B'(x) - A(x)B'^2(x) \pmod {x^n} \]&lt;/span&gt;&lt;br/&gt;　　至此可以递归倍增求解，伪代码如下，忽略清零、取模操作。&lt;br/&gt;　　&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; polyInv(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *a,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *b,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n){ &lt;span class=&quot;co&quot;&gt;// a是要求逆元的多项式，b是在模x^n意义下的a的逆元&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(n==&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) 令b为一个次数为1,常数项为a[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]的逆元的多项式，返回;
    polyInv(a,b,(n&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)&amp;gt;&amp;gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    ntt_init(dega+degb+degb); &lt;span class=&quot;co&quot;&gt;//ntt长度&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; A[]=a,B[]=b; &lt;span class=&quot;co&quot;&gt;//临时数组，防止影响到传入的指针&lt;/span&gt;
    ntt(A);
    ntt(B);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;i&amp;lt;nttlen;i++)
        A[i]=&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;*B[i]-A[i]*B[i]*B[i]; &lt;span class=&quot;co&quot;&gt;//点值计算&lt;/span&gt;
    ntt(A,&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;);
    b=A;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;br/&gt;　　时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(n log n)\)&lt;/span&gt;，不过我不知道怎么证.&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　&lt;/p&gt;
&lt;h2 id=&quot;多项式除法及取模&quot;&gt;多项式除法及取模&lt;/h2&gt;
&lt;p&gt;　　&lt;br/&gt;　　给定多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;和多项式&lt;span class=&quot;math inline&quot;&gt;\(B(x)\)&lt;/span&gt;，求两个多项式&lt;span class=&quot;math inline&quot;&gt;\(D(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(R(x)\)&lt;/span&gt;，使得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \label{1} A(x)=D(x)B(x)+R(x) \end{equation} \]&lt;/span&gt;&lt;br/&gt;　　其中，&lt;span class=&quot;math inline&quot;&gt;\(deg(A)&amp;gt;=deg(B)\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(deg(D)\leq deg(A)-deg(B)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(deg(R)&amp;lt;deg(B)\)&lt;/span&gt;.&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　除法用奇妙变化解决.&lt;br/&gt;　　&lt;br/&gt;　　引入一个操作：翻转操作. 对于一个次数为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;，定义&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ A^R(x)=x^nA(\frac 1 x) \]&lt;/span&gt;&lt;br/&gt;　　会发现&lt;span class=&quot;math inline&quot;&gt;\(A^R(x)\)&lt;/span&gt;的系数相对于&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;完全&lt;span class=&quot;math inline&quot;&gt;\(reverse\)&lt;/span&gt;了一下。&lt;br/&gt;　　&lt;br/&gt;​　　将&lt;span class=&quot;math inline&quot;&gt;\((4)\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;换成&lt;span class=&quot;math inline&quot;&gt;\(\frac 1 x\)&lt;/span&gt;，并两边同乘&lt;span class=&quot;math inline&quot;&gt;\(x^n\)&lt;/span&gt;，记&lt;span class=&quot;math inline&quot;&gt;\(n=deg(A)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(m=deg(B)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(deg(D)=n-m\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(deg(R)=m-1\)&lt;/span&gt;.&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} x^nA(\frac1x)&amp;amp;=x^{n-m}D(\frac1x)x^mB(\frac1x)+x^{n-m+1}x^{m-1}R(\frac1x)\\ A^R(x)&amp;amp;=D^R(x)B^R(x)+x^{n-m+1}R^R(x) \end{aligned} \]&lt;/span&gt;&lt;br/&gt;​　　我们发现&lt;span class=&quot;math inline&quot;&gt;\(D^R(x)\)&lt;/span&gt;的次数仍然等于&lt;span class=&quot;math inline&quot;&gt;\(n-m\)&lt;/span&gt;，如果把上式放在模&lt;span class=&quot;math inline&quot;&gt;\(x^{n-m+1}\)&lt;/span&gt;意义下，我们会发现&lt;span class=&quot;math inline&quot;&gt;\(D^R(x)\)&lt;/span&gt;不会受到任何影响，而&lt;span class=&quot;math inline&quot;&gt;\(x^{n-m+1}R^R(x)\)&lt;/span&gt;被完全模掉了！&lt;br/&gt;　　&lt;br/&gt;​　　于是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} A^R(x)&amp;amp;\equiv D^R(x)B^R(x)\pmod{x^{n-m+1}}\\ D^R(x)&amp;amp;\equiv A^R(x){B^R}^{-1}(x)\pmod{x^{n-m+1}} \end{aligned} \]&lt;/span&gt;&lt;br/&gt;　　直接对&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;系数翻转，&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;系数翻转，求&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;的逆，&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;一乘，把结果的系数再次翻转，就是&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;了！&lt;br/&gt;　　&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; polyDiv(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *a,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *b,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *d){&lt;span class=&quot;co&quot;&gt;// a和b对应上文的A和B，d是上文的D，是答案&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(deg(a)&amp;lt;deg(b)) 令d为一个0多项式，返回;
    reverse(a);
    reverse(b);
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; invb[];
    polyInv(b,invb,deg(b)&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//b次数界是deg(b)+1&lt;/span&gt;
    d=a*invb;
    reverse(d);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;br/&gt;　　如果你还要求&lt;span class=&quot;math inline&quot;&gt;\(R(x)\)&lt;/span&gt;，带回最初的式子直接算就好，多项式乘法用*直接代替了。&lt;br/&gt;　　&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; polyMod(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *a,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *b,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *r){
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(deg(a)&amp;lt;deg(b)) 令r为a，返回;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; d[];
    polyDiv(a,b,d);
    r=a-d*b;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 05 Apr 2018 14:21:00 +0000</pubDate>
<dc:creator>RogerDTZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RogerDTZ/p/8724533.html</dc:identifier>
</item>
<item>
<title>简单介绍 CPU 的工作原理 - 一像素</title>
<link>http://www.cnblogs.com/onepixel/p/8724526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onepixel/p/8724526.html</guid>
<description>&lt;h3&gt;1、内部架构&lt;/h3&gt;
&lt;p&gt;CPU 的根本任务就是执行指令，对计算机来说最终都是一串由 0 和 1 组成的序列。CPU 从逻辑上可以划分成 3 个模块，分别是控制单元、运算单元和存储单元 。其内部架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201708/849589-20170822172925277-1871938563.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;【1】控制单元&lt;/h4&gt;
&lt;p&gt;控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。&lt;/p&gt;
&lt;h4&gt;【2】运算单元&lt;/h4&gt;
&lt;p&gt;运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。&lt;/p&gt;
&lt;h4&gt;【3】存储单元&lt;/h4&gt;
&lt;p&gt;存储单元包括 CPU 片内缓存和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。&lt;/p&gt;
&lt;h3&gt;2、工作原理&lt;/h3&gt;
&lt;p&gt;总的来说，CPU 从内存中一条一条地取出指令和相应的数据，按指令操作码的规定，对数据进行运算处理，直到程序执行完毕为止。具体过程可分为以下四步：&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【1】取指令&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;CPU 控制器从内存读取一条指令并放入指令寄存器。指令的格式如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201708/849589-20170823213258027-1278154922.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;操作码&lt;/strong&gt;：就是汇编语言里的 mov，add，jmp 等符号码；&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;操作数地址&lt;/strong&gt;：说明该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;【2】指令译码&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;指令寄存器中的指令经过译码，决定该指令应进行何种操作（就是指令里的操作码）、操作数在哪里（操作数的地址） 。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【3】 执行指令&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;执行指令分为两个阶段： 取操作数 和 进行运算 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt; 取操作数&lt;/strong&gt;：CPU 通过寻址操作，从内存（数据段）中读取操作数到通用寄存器中，暂存起来。&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;进行运算&lt;/strong&gt;：运算单元通过指令中的操作码，对寄存器中的操作数进行 mov，add，jmp 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;【4】 指令计数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;修改指令计数器，决定下一条指令的地址 。CPU 重复上述三步操作，处于内存代码段的指令被逐个的执行，直到程序执行完毕为止。&lt;/p&gt;
&lt;h3&gt;3、CPU 字长&lt;/h3&gt;
&lt;p&gt;CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。所以，能处理字长为 8 位数据的 CPU 通常就叫 8 位的 CPU。同理，32 位CPU 能在单位时间内处理字长为 32 位的二进制数据 。&lt;/p&gt;
&lt;p&gt;常见的 32位 CPU 和 64位 CPU 主要存在以下两个差异：&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【1】处理能力不同&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;32 位 CPU 的一个指令，最大能处理 32 位二进制数据，即一次能处理 4 个字节数据。&lt;br/&gt;64 位 CPU 的一个指令，最大能处理 64 位二进制数据，即一次能处理 8 个字节数据。&lt;br/&gt;&lt;h4&gt;&lt;strong&gt;【2】寻址空间不同&lt;/strong&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p&gt;32 位 CPU 的寻址范围是 32 位的二进制，32位二进制能表示的地址长度为2的32次方，即寻址空间最大为 4GB。&lt;br/&gt;而 64 位CPU的寻址范围是 64 位的二进制。能表示的地址长度更大，其寻址空间也会更大。&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;



</description>
<pubDate>Thu, 05 Apr 2018 14:12:00 +0000</pubDate>
<dc:creator>一像素</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onepixel/p/8724526.html</dc:identifier>
</item>
<item>
<title>【深度学习】深入理解Batch Normalization批标准化 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8724433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8724433.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这几天面试经常被问到BN层的原理，虽然回答上来了，但还是感觉答得不是很好，今天仔细研究了一下Batch Normalization的原理，以下为参考网上几篇文章总结得出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Batch Normalization作为最近一年来DL的重要成果，已经广泛被证明其有效性和重要性。虽然有些细节处理还解释不清其理论原因，但是实践证明好用才是真的好，别忘了DL从Hinton对深层网络做Pre-Train开始就是一个&lt;strong&gt;经验领先于理论分析&lt;/strong&gt;的偏经验的一门学问。本文是对论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》的导读。&lt;/p&gt;
&lt;p&gt;　　机器学习领域有个很重要的假设：&lt;span&gt;&lt;span&gt;&lt;strong&gt;IID独立同分布假设&lt;/strong&gt;&lt;/span&gt;，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障&lt;/span&gt;。那BatchNorm的作用是什么呢？&lt;strong&gt;BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来一步一步的理解什么是BN。&lt;/p&gt;
&lt;p&gt;　　为什么深度神经网络&lt;strong&gt;随着网络深度加深，训练起来越困难，收敛越来越慢？&lt;/strong&gt;这是个在DL领域很接近本质的好问题。很多论文都是解决这个问题的，比如ReLU激活函数，再比如Residual Network，BN本质上也是解释并从某个不同的角度来解决这个问题的。&lt;/p&gt;
&lt;h2&gt;一、“Internal Covariate Shift”问题&lt;/h2&gt;
&lt;p&gt;　　从论文名字可以看出，BN是用来解决“&lt;span&gt;Internal Covariate Shift&lt;/span&gt;”问题的，那么首先得理解什么是“Internal Covariate Shift”？&lt;/p&gt;
&lt;p&gt;　　论文首先&lt;span&gt;说明Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快；&lt;/span&gt;（为什么要说这些？因为BatchNorm是基于Mini-Batch SGD的，所以先夸下Mini-Batch SGD，当然也是大实话）；然后吐槽下SGD训练的缺点：超参数调起来很麻烦。（作者隐含意思是用BN就能解决很多SGD的缺点）&lt;/p&gt;
&lt;p&gt;　　接着引入&lt;span&gt;&lt;strong&gt;covariate shift的概念&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;&lt;strong&gt;如果ML系统实例集合&amp;lt;X,Y&amp;gt;中的输入值X的分布老是变，这不符合IID假设&lt;/strong&gt;&lt;/span&gt;，网络模型很难&lt;strong&gt;稳定的学规律&lt;/strong&gt;，这不得引入迁移学习才能搞定吗，我们的ML系统还得去学习怎么迎合这种分布变化啊。&lt;span&gt;对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是&lt;span&gt;&lt;strong&gt;在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　然后提出了BatchNorm的基本思想：能不能&lt;strong&gt;让每个隐层节点的&lt;span&gt;激活输入分布&lt;/span&gt;固定下来呢&lt;/strong&gt;？这样就避免了“Internal Covariate Shift”问题了。&lt;/p&gt;
&lt;p&gt;　　BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓&lt;span&gt;&lt;strong&gt;白化&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;就是对输入数据分布变换到0均值，单位方差的正态分布&lt;/strong&gt;&lt;/span&gt;——那么神经网络会较快收敛，那么BN作者就开始推论了：图像是深度神经网络的输入层，做白化能加快收敛，那么其实对于深度网络来说，其中某个隐层的神经元是下一层的输入，意思是其实深度神经网络的每一个隐层都是输入层，不过是相对下一层来说而已，那么能不能对每个隐层都做白化呢？这就是启发BN产生的原初想法，而BN也确实就是这么做的，&lt;strong&gt;可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、&lt;/strong&gt;BatchNorm的本质思想&lt;/h2&gt;
&lt;p&gt;　　BN的基本思想其实相当直观：&lt;span&gt;因为深层神经网络在做非线性变换前的&lt;span&gt;&lt;strong&gt;激活输入值&lt;/strong&gt;&lt;/span&gt;（就是那个x=WU+B，U是输入）&lt;span&gt;&lt;strong&gt;随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这&lt;span&gt;&lt;strong&gt;导致反向传播时低层神经网络的梯度消失&lt;/strong&gt;&lt;/span&gt;，这是训练深层神经网络收敛越来越慢的&lt;strong&gt;本质原因&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布&lt;/strong&gt;&lt;/span&gt;，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是&lt;strong&gt;这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　THAT’S IT。其实一句话就是：&lt;span&gt;&lt;strong&gt;对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。&lt;/strong&gt;&lt;/span&gt;因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。&lt;/p&gt;
&lt;p&gt;　　上面说得还是显得抽象，下面更形象地表达下这种调整到底代表什么含义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225246905-37854887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图1  几个正态分布&lt;/p&gt;
&lt;p&gt;　　假设某个隐层神经元原先的激活输入x取值符合正态分布，正态分布均值是-2，方差是0.5，对应上图中最左端的浅蓝色曲线，通过BN后转换为均值为0，方差是1的正态分布（对应上图中的深蓝色图形），意味着什么，意味着输入x的取值正态分布整体右移2（均值的变化），图形曲线更平缓了（方差增大的变化）。这个图的意思是，BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布。&lt;/p&gt;
&lt;p&gt;　　那么把激活输入x调整到这个正态分布有什么用？首先我们看下均值为0，方差为1的标准正态分布代表什么含义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225314624-527885612.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图2  均值为0方差为1的标准正态分布图&lt;/p&gt;

&lt;p&gt;　　这意味着在一个标准差范围内，也就是说64%的概率x其值落在[-1,1]的范围内，在两个标准差范围内，也就是说95%的概率x其值落在了[-2,2]的范围内。那么这又意味着什么？我们知道，激活值x=WU+B,U是真正的输入，x是某个神经元的激活值，假设非线性函数是sigmoid，那么看下sigmoid(x)其图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210808736&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3. Sigmoid(x)&lt;/p&gt;
&lt;p&gt;及sigmoid(x)的导数为：G’=f(x)*(1-f(x))，因为f(x)=sigmoid(x)在0到1之间，所以G’在0到0.25之间，其对应的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210831111&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;333&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4  Sigmoid(x)导数图&lt;/p&gt;
&lt;p&gt;　　假设没有经过BN调整前x的原先正态分布均值是-6，方差是1，那么意味着95%的值落在了[-8,-4]之间，那么对应的Sigmoid（x）函数的值明显接近于0，这是典型的梯度饱和区，在这个区域里梯度变化很慢，为什么是梯度饱和区？请看下sigmoid(x)如果取值接近0或者接近于1的时候对应导数函数取值，接近于0，意味着梯度变化很小甚至消失。而假设经过BN后，均值是0，方差是1，那么意味着95%的x值落在了[-2,2]区间内，很明显这一段是sigmoid(x)函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。&lt;/p&gt;
&lt;p&gt;　　从上面几个图应该看出来BN在干什么了吧？其实就是把隐层神经元激活输入x=WU+B从变化不拘一格的正态分布通过BN操作拉回到了均值为0，方差为1的正态分布，即原始正态分布中心左移或者右移到以0为均值，拉伸或者缩减形态形成以1为方差的图形。什么意思？就是说&lt;strong&gt;经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　但是很明显，看到这里，稍微了解神经网络的读者一般会提出一个疑问：如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的&lt;span&gt;&lt;strong&gt;表达能力&lt;/strong&gt;&lt;/span&gt;下降了，这也意味着深度的意义就没有了。&lt;span&gt;&lt;strong&gt;所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)&lt;/strong&gt;&lt;/span&gt;，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。&lt;span&gt;核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。&lt;/span&gt;当然，这是我的理解，论文作者并未明确这样说。但是很明显这里的scale和shift操作是会有争议的，因为按照论文作者论文里写的理想状态，就会又通过scale和shift操作把变换后的x调整回未变换的状态，那不是饶了一圈又绕回去原始的“Internal Covariate Shift”问题里去了吗，感觉论文作者并未能够清楚地解释scale和shift操作的理论原因。&lt;/p&gt;
&lt;h2&gt;三、训练阶段如何做BatchNorm&lt;/h2&gt;
&lt;p&gt;　　上面是对BN的抽象分析和解释，具体在Mini-Batch SGD下做BN怎么做？其实论文里面这块写得很清楚也容易理解。为了保证这篇文章完整性，这里简单说明下。&lt;/p&gt;
&lt;p&gt;　　假设对于一个深层神经网络来说，其中两层结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213859690-1933561230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图5  DNN其中两层&lt;/p&gt;

&lt;p&gt;　　要对每个隐层神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WU+B激活值获得之后，非线性函数变换之前，其图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213955224-1791925244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图6. BN操作&lt;/p&gt;
&lt;p&gt;　　对于Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210954533&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要注意，&lt;span&gt;这里t层某个神经元的x(k)不是指原始输入，就是说不是t-1层每个神经元的输出，而是t层这个神经元的线性激活x=WU+B，这里的U才是t-1层神经元的输出。&lt;/span&gt;变换的意思是：某个神经元对应的原始的激活x通过减去mini-Batch内m个实例获得的m个激活x求得的均值E(x)并除以求得的方差Var(x)来进行转换。&lt;/p&gt;
&lt;p&gt;　　上文说过经过这个&lt;span&gt;&lt;strong&gt;变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作，这其实是变换的反操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211016799&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　BN其具体操作流程，如论文中描述的一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211049877&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　过程非常清楚，就是上述公式的流程化描述，这里不解释了，直接应该能看懂。&lt;/p&gt;
&lt;h2&gt;四、BatchNorm的推理(Inference)过程&lt;/h2&gt;
&lt;p&gt;　　BN在训练的时候可以根据Mini-Batch里的若干训练实例进行激活数值调整，但是在推理（inference）的过程中，很明显输入就只有一个实例，看不到Mini-Batch其它实例，那么这时候怎么对输入做BN呢？因为很明显一个实例是没法算实例集合求出的均值和方差的。这可如何是好？&lt;/p&gt;
&lt;p&gt;　　既然没有从Mini-Batch数据里可以得到的统计量，那就想其它办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，只是因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。&lt;/p&gt;
&lt;p&gt;　　决定了获得统计量的数据范围，那么接下来的问题是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-Batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211109253&quot; alt=&quot;&quot; width=&quot;207&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行NB采取如下方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211128691&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个公式其实和训练时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211144175&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是等价的，通过简单的合并计算推导就可以得出这个结论。那么为啥要写成这个变换形式呢？我猜作者这么写的意思是：在实际运行的时候，按照这种变体形式可以减少计算量，为啥呢？因为对于每个隐层节点来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211201143&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都是固定值，这样这两个值可以事先算好存起来，在推理的时候直接用就行了，这样比原始的公式每一步骤都现算少了除法的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。&lt;/p&gt;
&lt;h2&gt;五、BatchNorm的好处&lt;/h2&gt;
&lt;p&gt;　　BatchNorm为什么NB呢，关键还是效果好。&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;strong&gt;不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等。&lt;/strong&gt;&lt;/span&gt;总而言之，经过这么简单的变换，带来的好处多得很，这也是为何现在BN这么快流行起来的原因。&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 13:50:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8724433.html</dc:identifier>
</item>
<item>
<title>Django rest framework源码分析（4）----版本 - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8724270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8724270.html</guid>
<description>&lt;h2&gt;版本&lt;/h2&gt;
&lt;p&gt; 新建一个工程Myproject和一个app名为api&lt;/p&gt;
&lt;p&gt;（1）api/models.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo(models.Model):
    USER_TYPE &lt;/span&gt;=&lt;span&gt; (
        (&lt;/span&gt;1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;普通用户&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;VIP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SVIP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    )

    user_type &lt;/span&gt;= models.IntegerField(choices=&lt;span&gt;USER_TYPE)
    username &lt;/span&gt;= models.CharField(max_length=32,unique=&lt;span&gt;True)
    password &lt;/span&gt;= models.CharField(max_length=64&lt;span&gt;)
    group &lt;/span&gt;= models.ForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UserGroup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,on_delete=&lt;span&gt;models.CASCADE)
    roles &lt;/span&gt;= models.ManyToManyField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserToken(models.Model):
    user &lt;/span&gt;= models.OneToOneField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UserInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,on_delete=&lt;span&gt;models.CASCADE)
    token &lt;/span&gt;= models.CharField(max_length=64&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserGroup(models.Model):
    title &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Role(models.Model):
    title &lt;/span&gt;= models.CharField(max_length=32)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）Myproject/urls.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,include

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;path('admin/', admin.site.urls),&lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,include(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api.urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) ),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）api/urls.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/urls.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserView

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, UserView.as_view()),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/views.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Request
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.versioning &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QueryParameterVersioning

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(APIView):

    versioning_class &lt;/span&gt;=&lt;span&gt; QueryParameterVersioning

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取版本&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.version)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）settings.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEFAULT_VERSION&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,               &lt;span&gt;#&lt;/span&gt;&lt;span&gt;默认的版本&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ALLOWED_VERSIONS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;允许的版本&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VERSION_PARAM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;             &lt;span&gt;#GET&lt;/span&gt;&lt;span&gt;方式url中参数的名字  ?version=xxx&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 1.url中通过GET传参&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;pre&gt;
&lt;span&gt;QueryParameterVersioning用于去GET参数中取version&lt;/span&gt;
&lt;/pre&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://127.0.0.1:8000/api/users/?version=v2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台可以看到当前的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405194829638-1401976900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果url中没有传版本参数，则显示默认的版本（&quot;DEFAULT_VERSION&quot;:'v1'）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://127.0.0.1:8000/api/users/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405195043820-714876373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果url传的版本超过settings中的允许范围则报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://127.0.0.1:8000/api/users/?version=v3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405195212785-832107855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.在URLPATH中获取&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; （1）修改api/urls.py&lt;/p&gt;
&lt;p&gt;通常情况我门应该用URLPATH的方式，而不是用前面GET()传参方式&lt;/p&gt;
&lt;p&gt;url里面通过正则表达式定义哪些版本,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/urls.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,re_path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserView

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    re_path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(?P&amp;lt;version&amp;gt;[v1|v2]+)/users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, UserView.as_view()),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）views.py&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;URLPathVersioning:去url路径里面获取版本&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/views.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Request
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.versioning &lt;span&gt;import&lt;/span&gt;&lt;span&gt; URLPathVersioning

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(APIView):

    versioning_class &lt;/span&gt;=&lt;span&gt; URLPathVersioning

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取版本&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.version)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个URLPathVersioning我们可以放到settings里面，全局配置，就不用写到views里面，每个类都要写一遍了&lt;/p&gt;
&lt;p&gt;settings.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 版本&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; REST_FRAMEWORK = {&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     &quot;DEFAULT_VERSIONING_CLASS&quot;:&quot;rest_framework.versioning.URLPathVersioning&quot;,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     &quot;DEFAULT_VERSION&quot;:'v1',               #默认的版本&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     &quot;ALLOWED_VERSIONS&quot;:['v1','v2'],       #允许的版本&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     &quot;VERSION_PARAM&quot;:'version'             #get方式url中参数的名字  ?version=xxx&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;全局&lt;/span&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEFAULT_VERSIONING_CLASS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rest_framework.versioning.URLPathVersioning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/views.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Request

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(APIView):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取版本&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.version)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 浏览器访问地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://127.0.0.1:8000/api/v1/users/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后后台拿到版本信息&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3.反向解析访问的url&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）api/urls.py&lt;/p&gt;
&lt;p&gt;添加name = 'api_user'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/urls.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,re_path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserView

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    re_path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(?P&amp;lt;version&amp;gt;[v1|v2]+)/users/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, UserView.as_view(),name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;api_user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; api/views.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIView
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Request

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserView(APIView):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self,request,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取版本&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.version)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取处理版本的对象&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.versioning_scheme)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取浏览器访问的url，reverse反向解析&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要两个参数：viewname就是url中的别名，request=request是url中要传入的参数&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;(?P&amp;lt;version&amp;gt;[v1|v2]+)/users/，这里本来需要传version的参数，但是version包含在request里面（源码里面可以看到），所有只需要request=request就可以&lt;/span&gt;
        url_path = request.versioning_scheme.reverse(viewname=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api_user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,request=&lt;span&gt;request)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(url_path)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.dispatch&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 浏览器访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://127.0.0.1:8000/api/v1/users/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台获取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405204442019-95609318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 源码流程&lt;/h2&gt;
&lt;p&gt; （1）dispatch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;def&lt;/span&gt; dispatch(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.args &lt;/span&gt;=&lt;span&gt; args
        self.kwargs &lt;/span&gt;=&lt;span&gt; kwargs
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对原始request进行加工，丰富了一些功能&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Request(&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     request,&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     parsers=self.get_parsers(),&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     authenticators=self.get_authenticators(),&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     negotiator=self.get_content_negotiator(),&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     parser_context=parser_context&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; )&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;request(原始request,[BasicAuthentications对象，])&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取原生request,request._request&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取认证类的对象，request.authticators&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.封装request&lt;/span&gt;
        request = self.initialize_request(request, *args, **&lt;span&gt;kwargs)
        self.request &lt;/span&gt;=&lt;span&gt; request
        self.headers &lt;/span&gt;= self.default_response_headers  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; deprecate?&lt;/span&gt;

        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.认证&lt;/span&gt;
            self.initial(request, *args, **&lt;span&gt;kwargs)

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Get the appropriate handler method&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; request.method.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.http_method_names:
                handler &lt;/span&gt;=&lt;span&gt; getattr(self, request.method.lower(),
                                  self.http_method_not_allowed)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                handler &lt;/span&gt;=&lt;span&gt; self.http_method_not_allowed

            response &lt;/span&gt;= handler(request, *args, **&lt;span&gt;kwargs)

        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as exc:
            response &lt;/span&gt;=&lt;span&gt; self.handle_exception(exc)

        self.response &lt;/span&gt;= self.finalize_response(request, response, *args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.response
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）initial&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; initial(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Runs anything that needs to occur prior to calling the method handler.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.format_kwarg &lt;/span&gt;= self.get_format_suffix(**&lt;span&gt;kwargs)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Perform content negotiation and store the accepted info on the request&lt;/span&gt;
        neg =&lt;span&gt; self.perform_content_negotiation(request)
        request.accepted_renderer, request.accepted_media_type &lt;/span&gt;=&lt;span&gt; neg

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Determine the API version, if versioning is in use.&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;request.version获取版本信息&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;request.versioning_scheme获取处理版本你的对象&lt;/span&gt;
        version, scheme = self.determine_version(request, *args, **&lt;span&gt;kwargs)
        request.version, request.versioning_scheme &lt;/span&gt;=&lt;span&gt; version, scheme

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ensure that the incoming request is permitted&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.实现认证&lt;/span&gt;
&lt;span&gt;        self.perform_authentication(request)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5.权限判断&lt;/span&gt;
&lt;span&gt;        self.check_permissions(request)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6.控制访问频率&lt;/span&gt;
        self.check_throttles(request)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）determine_version&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;def&lt;/span&gt; determine_version(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        If versioning is being used, then determine any API version for the
        incoming request. Returns a two-tuple of (version, versioning_scheme)
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.versioning_class &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (None, None)&lt;/span&gt;
        scheme =&lt;span&gt; self.versioning_class()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (scheme.determine_version(request, *args, **kwargs), scheme)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）versioning_class&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405205827823-1269575246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;URLPathVersioning源码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; URLPathVersioning(BaseVersioning):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    To the client this is the same style as `NamespaceVersioning`.
    The difference is in the backend - this implementation uses
    Django's URL keyword arguments to determine the version.

    An example URL conf for two views that accept two different versions.

    urlpatterns = [
        url(r'^(?P&amp;lt;version&amp;gt;[v1|v2]+)/users/$', users_list, name='users-list'),
        url(r'^(?P&amp;lt;version&amp;gt;[v1|v2]+)/users/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', users_detail, name='users-detail')
    ]

    GET /1.0/something/ HTTP/1.1
    Host: example.com
    Accept: application/json
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    invalid_version_message &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Invalid version in URL path.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; determine_version(self, request, *args, **&lt;span&gt;kwargs):
        version &lt;/span&gt;=&lt;span&gt; kwargs.get(self.version_param, self.default_version)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.is_allowed_version(version):
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; exceptions.NotFound(self.invalid_version_message)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; version

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **&lt;span&gt;extra):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.version &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
            kwargs &lt;/span&gt;= {} &lt;span&gt;if&lt;/span&gt; (kwargs &lt;span&gt;is&lt;/span&gt; None) &lt;span&gt;else&lt;/span&gt;&lt;span&gt; kwargs
            kwargs[self.version_param] &lt;/span&gt;=&lt;span&gt; request.version

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; super(URLPathVersioning, self).reverse(
            viewname, args, kwargs, request, format, &lt;/span&gt;**&lt;span&gt;extra
        )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到&lt;/p&gt;
&lt;p&gt;（1）url配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180405210159643-995225494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）determine_version&lt;/p&gt;
&lt;p&gt; 里面有个is_allowed_version，点进去可以看到一些基本参数 （继承BaseVersioning基类）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseVersioning(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;默认的版本&lt;/span&gt;
    default_version =&lt;span&gt; api_settings.DEFAULT_VERSION
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;允许的版本&lt;/span&gt;
    allowed_versions =&lt;span&gt; api_settings.ALLOWED_VERSIONS
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;默认参数（是version，比如你可以自定义为v）&lt;/span&gt;
    version_param =&lt;span&gt; api_settings.VERSION_PARAM

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; determine_version(self, request, *args, **&lt;span&gt;kwargs):
        msg &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{cls}.determine_version() must be implemented.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; NotImplementedError(msg.format(
            cls&lt;/span&gt;=self.&lt;span&gt;__class__&lt;/span&gt;.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
        ))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **&lt;span&gt;extra):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _reverse(viewname, args, kwargs, request, format, **&lt;span&gt;extra)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_allowed_version(self, version):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.allowed_versions:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((version &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; version == self.default_version) &lt;span&gt;or&lt;/span&gt;&lt;span&gt;
                (version &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; self.allowed_versions))
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 05 Apr 2018 13:06:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8724270.html</dc:identifier>
</item>
<item>
<title>流程控制语句(MySQL/MariaDB ) - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8724063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8724063.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog1&quot;&gt;&lt;span&gt;1.BEGIN...END&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog2&quot;&gt;&lt;span&gt;2.true和false&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog3&quot;&gt;&lt;span&gt;3.if结构&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog4&quot;&gt;&lt;span&gt;4.case结构&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog5&quot;&gt;&lt;span&gt;5.loop、leave和iterate&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog6&quot;&gt;&lt;span&gt;6.repeat循环&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html#blog7&quot;&gt;&lt;span&gt;7.while循环&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MySQL/MariaDB中的符合语句结构有：BEGIN...END，if，case，while，loop，repeat，&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8722244.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;cursor&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，condition，&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/zh-cn/declare-handler/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;handler&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在MySQL中，它们都只能在存储程序(procedure,function,trigger)内部使用，但在MariaDB中，从10.1.1版本之后，BEGIN...END,IF,CASE,LOOP,REPEAT,WHILE可以在存储程序的外部使用。但实际上，除了begin、case和if能正常单独定义在存储程序之外，loop、repeat、while都是鸡肋，因为无法给单独定义的结构打标签，只能无限循环而无法退出。&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[label:]&lt;/span&gt; BEGIN &lt;span class=&quot;hljs-attr_selector&quot;&gt;[NOT ATOMIC]&lt;/span&gt;
    &lt;span class=&quot;hljs-attr_selector&quot;&gt;[statement_list]&lt;/span&gt;
END &lt;span class=&quot;hljs-attr_selector&quot;&gt;[label]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;begin...end默认只能在存储程序内部使用，此时可以使用label为begin...end打上标签。可以在end处使用标签来结束begin...end。如果end后指定了label,则end处的label必须和begin前的label完全相同。&lt;/p&gt;
&lt;p&gt;可以使用NOT ATOMIC关键字让BEGIN在存储程序外部使用，但此时不能为begin...end打标签，且一定注意先修改delimiter，免得begin...end中的语句中途终止。&lt;/p&gt;
&lt;p&gt;例如，下面三个begin...end语句块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delimiter $$
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; atomic        
    &lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; a &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; a;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;$$

&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;procedure&lt;/span&gt; p1()
my_label: &lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;           
    &lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; b &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; b=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; b;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;$$                  

&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;procedure&lt;/span&gt; p2()
my_label: &lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; c &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; c=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; c;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; my_label$$         
delimiter ;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;call&lt;/span&gt; p1;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;call&lt;/span&gt; p2;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在begin...end中，除了可以写一些SQL语句，还可以使用declare定义变量、条件、处理器和游标。但它们之间有顺序要求，顺序如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DECLARE local variables;&lt;/li&gt;
&lt;li&gt;DECLARE CONDITIONs;&lt;/li&gt;
&lt;li&gt;DECLARE CURSORs;&lt;/li&gt;
&lt;li&gt;DECLARE HANDLERs;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还可以begin嵌套，内层的begin可以使用外层begin定义的变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delimiter $$
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;PROCEDURE&lt;/span&gt; t()
&lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
   &lt;span class=&quot;hljs-keyword&quot;&gt;DECLARE&lt;/span&gt; x TINYINT UNSIGNED &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
   &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;DECLARE&lt;/span&gt; x &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'02'&lt;/span&gt;;&lt;/span&gt;
       &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DECLARE&lt;/span&gt; y TINYINT UNSIGNED &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;
       &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; x, y;&lt;/span&gt;
   &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;;&lt;/span&gt;
   &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; x;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;;&lt;/span&gt;
delimiter ;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;在MySQL和MariaDB中，true和false是无条件的真、假。&lt;/p&gt;
&lt;p&gt;true和1等价，false和0等价，且它们不区分大小写。任何时候，都可以互换它们，但任何时候，它们的结果都换转换为数值的1或0。即使将数据类型定义为int，也可以为其传递true字符串。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;
+------+-------+
| TRUE | FALSE |
+------+-------+
|    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; |     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |
+------+-------+
begin not atomic 
    declare a &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; a=&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; a;
end$$
+------+
| a    |
+------+
|    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; |
+------+
&lt;/code&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; search_condition THEN statement_list
    [&lt;span class=&quot;hljs-keyword&quot;&gt;ELSEIF&lt;/span&gt; search_condition THEN statement_list] ...
    [&lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; statement_list]
END &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中search_condition是条件判断语句，statement_list是要执行的语句。&lt;/p&gt;
&lt;p&gt;在MySQL中，if语句必须作为语句块写在存储过程或函数等程序结构中。在MariaDB 10.1.1之后，可以独立使用，但注意修改delimiter。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 独立使用&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;结构
delimiter &lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; 
    select &lt;span class=&quot;hljs-string&quot;&gt;'true'&lt;/span&gt;; 
&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; 
    select &lt;span class=&quot;hljs-string&quot;&gt;'false'&lt;/span&gt;; 
&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
delimiter ;

-- 在存储过程中使用
&lt;span class=&quot;hljs-constant&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; replace &lt;span class=&quot;hljs-constant&quot;&gt;PROCEDURE&lt;/span&gt; proc1(a &lt;span class=&quot;hljs-constant&quot;&gt;INT&lt;/span&gt;,&lt;span class=&quot;hljs-constant&quot;&gt;OUT&lt;/span&gt; i &lt;span class=&quot;hljs-constant&quot;&gt;INT&lt;/span&gt;)
&lt;span class=&quot;hljs-constant&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;hljs-constant&quot;&gt;IF&lt;/span&gt; a &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;THEN&lt;/span&gt; 
        &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a1&lt;/span&gt; = a + &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; 
    &lt;span class=&quot;hljs-constant&quot;&gt;ELSEIF&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;THEN&lt;/span&gt; 
        &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a1&lt;/span&gt; = a + &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;
    &lt;span class=&quot;hljs-constant&quot;&gt;ELSE&lt;/span&gt; 
        &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a1&lt;/span&gt; = a + &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;; 
    &lt;span class=&quot;hljs-constant&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;IF&lt;/span&gt; ;
    &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;i:&lt;/span&gt;=&lt;span class=&quot;hljs-variable&quot;&gt;@a1&lt;/span&gt;;
&lt;span class=&quot;hljs-constant&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;DELIMITER&lt;/span&gt; ;

-- 测试&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;结构
&lt;span class=&quot;hljs-constant&quot;&gt;CALL&lt;/span&gt; proc1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;);
&lt;span class=&quot;hljs-constant&quot;&gt;CALL&lt;/span&gt; proc1(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@b&lt;/span&gt;);
&lt;span class=&quot;hljs-constant&quot;&gt;CALL&lt;/span&gt; proc1(-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@c&lt;/span&gt;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT &lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@b&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@c&lt;/span&gt;;
    &lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;      &lt;span class=&quot;hljs-variable&quot;&gt;@b&lt;/span&gt;      &lt;span class=&quot;hljs-variable&quot;&gt;@c&lt;/span&gt;  
------  ------  --------
   &lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;299&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，还有一个&lt;code&gt;if(expr,true_value,false_value)&lt;/code&gt;函数，如果expr为真，则返回true_value，否则返回false_value，所以这里的if函数和if流程控制语句是不同的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'true'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'false'&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a&lt;/span&gt;;
+-------+
| a     |
+-------+
| &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt; |
+-------+
MariaDB [test]&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'true'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'false'&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a&lt;/span&gt;; 
+------+
| a    |
+------+
| &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt; |
+------+
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;在MySQL中，有case表达式和case语句两种结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; help &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt;
topics:
   &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; OPERATOR
   &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; STATEMENT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们的区别有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;case表达式使用end关键字作为结束符，而case语句使用end case作为结束符；&lt;/li&gt;
&lt;li&gt;case表达式有可选项else，省略它的时候其默认值为null，case语句也有可选项else，但是省略它的时候没有默认值，且else语句中不能是null；&lt;/li&gt;
&lt;li&gt;case表达式可以在任何地方使用(例如在select中)，而case语句只能在存储过程或函数这样类型的编程结构中使用。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; help &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; operator
&lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; value WHEN [compare_value] THEN result [WHEN [compare_value] THEN
result ...] [&lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; result] END
&lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; WHEN [condition] THEN result [WHEN [condition] THEN result ...]
[&lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; result] END

Examples:
mysql&amp;gt; SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; WHEN &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; THEN &lt;span class=&quot;hljs-string&quot;&gt;'one'&lt;/span&gt;
    -&amp;gt;     WHEN &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; THEN &lt;span class=&quot;hljs-string&quot;&gt;'two'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'more'&lt;/span&gt; END;
        -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;'one'&lt;/span&gt;
mysql&amp;gt; SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; WHEN &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; THEN &lt;span class=&quot;hljs-string&quot;&gt;'true'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'false'&lt;/span&gt; END;
        -&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;'true'&lt;/span&gt;
mysql&amp;gt; SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; BINARY &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;
    -&amp;gt;     WHEN &lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt; THEN &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; WHEN &lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt; THEN &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; END;
        -&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NULL&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; help &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; statement
&lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; case_value
    WHEN when_value THEN statement_list
    [WHEN when_value THEN statement_list] ...
    [&lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; statement_list]
END &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;Or&lt;/span&gt;:

&lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt;
    WHEN search_condition THEN statement_list
    [WHEN search_condition THEN statement_list] ...
    [&lt;span class=&quot;hljs-keyword&quot;&gt;ELSE&lt;/span&gt; statement_list]
END &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然case表达式和case语句在性质上不一样，但是使用它们的思路是一样的。&lt;code&gt;CASE value WHEN...&lt;/code&gt;只能与value进行等同性检查，&lt;code&gt;case when ... then...&lt;/code&gt;则要灵活的多。&lt;/p&gt;
&lt;p&gt;case operator的使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-constant&quot;&gt;MariaDB&lt;/span&gt; [test]&amp;gt; select * from &lt;span class=&quot;hljs-constant&quot;&gt;Student&lt;/span&gt;;
+------+----------+------+--------+
| sid  | name     | age  | &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;  |&lt;/span&gt;
+------+----------+------+--------+
|    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | chenyi   |   &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Java&lt;/span&gt;   |
|    &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; | huanger  |   &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Python&lt;/span&gt; |
|    &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | zhangsan |   &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Java&lt;/span&gt;   |
|    &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; | lisi     |   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;C&lt;/span&gt;
|    &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; | wangwu   |   &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Python&lt;/span&gt; |
|    &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; | zhaoliu  |   &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Java&lt;/span&gt;   |
|    &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; | qianqi   |   &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;C&lt;/span&gt;      |
|    &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; | sunba    |   &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;C&lt;/span&gt;++    |
|    &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; | yangjiu  |   &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; | &lt;span class=&quot;hljs-constant&quot;&gt;Java&lt;/span&gt;   |
+------+----------+------+--------+

&lt;span class=&quot;hljs-constant&quot;&gt;MariaDB&lt;/span&gt; [test]&amp;gt; select name,&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; age&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'older'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'younger'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; as oy from &lt;span class=&quot;hljs-constant&quot;&gt;Student&lt;/span&gt;;     
+----------+---------+
| name     | oy      |
+----------+---------+
| chenyi   | older   |
| huanger  | older   |
| zhangsan | younger |
| lisi     | younger |
| wangwu   | younger |
| zhaoliu  | younger |
| qianqi   | older   |
| sunba    | younger |
| yangjiu  | older   |
+----------+---------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case statement的使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELIMITER $$
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;PROCEDURE&lt;/span&gt; proc1(a &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;,OUT i &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt; 
        &lt;span class=&quot;hljs-keyword&quot;&gt;WHEN&lt;/span&gt; a&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;THEN&lt;/span&gt; 
            &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; @a1=a+&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;
        WHEN a=0 THEN
            &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; @a1=a+&lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;&lt;/span&gt;
        ELSE
            &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; @a1=a+&lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;CASE&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; i=@a1;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CALL&lt;/span&gt; proc1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,@x);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CALL&lt;/span&gt; proc1(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,@y);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CALL&lt;/span&gt; proc1(-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,@z);&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; @x,@y,@z;&lt;/span&gt;
    @x      @y      @z  

   101     200       299
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;loop是循环，leave是跳出整个循环（类似于break），iterate是跳出当前循环进入下一个循环(类似于continue)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[begin_label:]&lt;/span&gt; LOOP
    statement_list
END LOOP &lt;span class=&quot;hljs-attr_selector&quot;&gt;[end_label]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在loop结构中，使用end loop关键字作为结束标记。&lt;/p&gt;
&lt;p&gt;在loop中可以使用标签来标注该循环。如果要标记loop循环，则使用&quot;begin_label:&quot;和&quot;end_label&quot;，但要求begin_label和end_label是完全相同的字符串标记(或者end不用标签直接结束也可以)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;add_num&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;loop&lt;/span&gt;
    set &lt;span class=&quot;hljs-property&quot;&gt;@a&lt;/span&gt;=&lt;span class=&quot;hljs-property&quot;&gt;@a&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
end &lt;span class=&quot;hljs-keyword&quot;&gt;loop&lt;/span&gt; add_num;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该语句由于没有跳出循环语句，所以将会死循环。&lt;/p&gt;
&lt;p&gt;因此，loop一般会配合leave来使用。leave的作用是退出指定标记的语句结构，一般用在循环中用来退出循环(不仅是用在loop循环，其他循环结构也一样)，相当于break。因为begin...end中也能使用标记，所以leave也能用在begin...end中。 例如下面的例子，计算从1加到给定的数。通过if判断退出循环的条件，达到退出条件时使用leave来退出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delimiter $$
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;procedure&lt;/span&gt; proc1(n &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;,i &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;
    loop_label: loop
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;=&lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;+i;&lt;/span&gt;
        if i=n then
            leave loop_label;
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;;&lt;/span&gt;
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; i=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; loop loop_label;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;$$
delimiter ;&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;call&lt;/span&gt; proc1(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;   
   sum  

    5050
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;iterate和leave的用法一样，只不过iterate是退出当前循环直接进入下一循环。&lt;/p&gt;
&lt;p&gt;例如下面的存储过程，它的功能是计算传入数值范围内的奇数和。当超出传入值的范围时直接退出循环，当遇到偶数时直接进入下一循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delimiter &lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
create &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; replace procedure proc2(n int)
&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;
    declare i,sum int default &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;hljs-symbol&quot;&gt;my_loop:&lt;/span&gt; loop
        set i=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i&amp;gt;n &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; 
            leave my_loop;
        elseif mod(i,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;
            iterate my_loop;
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; 
            set sum=i+sum;
        &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; loop;
    select sum;
&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
delimiter ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用存储过程来测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CALL&lt;/span&gt; proc4(&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;);&lt;/span&gt;
   sum  

      25
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然在MariaDB中，loop能单独定义在存储程序之外，但是由于定义在外面的时候无法打标签，而退出循环的leave却必须接标签才能退出loop，因此loop定义在存储程序之外完全是一个鸡肋的功能。同理，repeat和while也是一样的。&lt;/p&gt;


&lt;p&gt;loop循环结构中没有退出循环的条件，只能人为书写条件判断语句来判断何时退出循环。而repeat循环结构提供了直接定义退出循环条件的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[begin_label:]&lt;/span&gt; &lt;span class=&quot;hljs-value&quot;&gt;REPEAT&lt;/span&gt;
    statement_list
UNTIL search_condition
END &lt;span class=&quot;hljs-value&quot;&gt;REPEAT&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[end_label]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中until部分定义的是退出循环的条件。注意，until语句后面不需要结束提示符，给出了结束符反而报错。&lt;/p&gt;
&lt;p&gt;例如下面的存储过程中，当a变量等于传入参数i的时候退出循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delimiter $$
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;procedure&lt;/span&gt; proc5(i &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; a &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
    addnum: repeat
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; a=a+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
        if mod(a,2)=1 then
            &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;=&lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;+a;&lt;/span&gt;
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;;&lt;/span&gt;
    until a=i
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;repeat&lt;/span&gt; addnum;&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;sum&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;$$
delimiter ;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;call&lt;/span&gt; proc5(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;
   sum  

      25
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;while循环和repeat循环使用方法一样，但是思路不一样。repeat是满足条件时退出，而while是满足条件时才执行循环中定义的语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[begin_label:] &lt;span class=&quot;hljs-keyword&quot;&gt;WHILE&lt;/span&gt; search_condition &lt;span class=&quot;hljs-keyword&quot;&gt;DO&lt;/span&gt; 
statement_list 
END &lt;span class=&quot;hljs-keyword&quot;&gt;WHILE&lt;/span&gt; [end_label]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如下面的存储过程，仍然是计算传入值范围内的奇数和。但使用的是while循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-constant&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;EXISTS&lt;/span&gt; proc6;
&lt;span class=&quot;hljs-constant&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;PROCEDURE&lt;/span&gt; proc6(i &lt;span class=&quot;hljs-constant&quot;&gt;INT&lt;/span&gt;)
&lt;span class=&quot;hljs-constant&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;@sum&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;hljs-symbol&quot;&gt;addnum:&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;WHILE&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;&amp;lt;i &lt;span class=&quot;hljs-constant&quot;&gt;DO&lt;/span&gt;
        &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;=&lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;hljs-constant&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;MOD&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;THEN&lt;/span&gt;
            &lt;span class=&quot;hljs-constant&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@sum&lt;/span&gt;=&lt;span class=&quot;hljs-variable&quot;&gt;@a&lt;/span&gt;+&lt;span class=&quot;hljs-variable&quot;&gt;@sum&lt;/span&gt;;
        &lt;span class=&quot;hljs-constant&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;IF&lt;/span&gt;;
    &lt;span class=&quot;hljs-constant&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;WHILE&lt;/span&gt; addnum;
    &lt;span class=&quot;hljs-constant&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;@sum&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;SUM&lt;/span&gt;;
&lt;span class=&quot;hljs-constant&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$$&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;DELIMITER&lt;/span&gt; ;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8724063.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8724063.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Apr 2018 11:58:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8724063.html</dc:identifier>
</item>
<item>
<title>Java面试题(二) - Lovebugs.cn</title>
<link>http://www.cnblogs.com/Lovebugs/p/8723755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lovebugs/p/8723755.html</guid>
<description>&lt;p&gt;系统整理了一下有关Java的面试题，包括基础篇，javaweb篇，框架篇，数据库篇，多线程篇，并发篇，算法篇等等，陆续更新中。其他方面如前端后端等等的面试题也在整理中，都会有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：文末有福利！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、String s = new String(&quot;xyz&quot;);创建了几个StringObject？是否可以继承String类?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        两个或一个都有可能，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。NewString每写一遍，就创建一个新的对象，它使用常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，那么这里就不会创建”xyz”了，直接从缓冲区拿，这时创建了一个StringObject；但如果以前没有用过&quot;xyz&quot;，那么此时就会创建一个对象并放入缓冲区，这种情况它创建两个对象。至于String类是否继承，答案是否定的，因为String默认final修饰，是不可继承的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、String和StringBuffer的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、下面这条语句一共创建了多少个对象：String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String s1 = &quot;a&quot;&lt;span&gt;;

String s2 = s1 + &quot;b&quot;&lt;span&gt;;

String s3 = &quot;a&quot; + &quot;b&quot;&lt;span&gt;;

System.out.println(s2 == &quot;ab&quot;&lt;span&gt;);

System.out.println(s3 == &quot;ab&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期再去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。&lt;/p&gt;
&lt;p&gt;题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 String s =&quot;a&quot; + &quot;b&quot; +&quot;c&quot; + &quot;d&quot;&lt;span&gt;;

 System.out.println(s== &quot;abcd&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终打印的结果应该为true。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、try {}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        我们知道finally{}中的语句是一定会执行的，那么这个可能正常脱口而出就是return之前，return之后可能就出了这个方法了，鬼知道跑哪里去了，但更准确的应该是在return中间执行，请看下面程序代码的运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public&lt;span&gt; classTest {

    public static void&lt;span&gt; main(String[]args) {

       System.out.println(newTest().test());;

    }

    static int&lt;span&gt; test()

    {

       intx = 1&lt;span&gt;;

       try&lt;span&gt;

       {

          returnx;

       }

       finally&lt;span&gt;

       {

          ++&lt;span&gt;x;

       }

    }  
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;---------执行结果 ---------&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、final, finally, finalize的区别。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成final类型。&lt;/p&gt;
&lt;p&gt;        finally是异常处理语句结构的一部分，表示总是执行。&lt;/p&gt;
&lt;p&gt;        finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。但是JVM不保证此方法总被调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、运行时异常与一般异常有何异同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、error和exception有什么区别?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、简单说说Java中的异常处理机制的简单原理和应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。&lt;/p&gt;
&lt;p&gt;        Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：&lt;/p&gt;
&lt;p&gt;        Error和Exception，Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有奔溃了，例如，说内存溢出和线程死锁等系统问题。&lt;/p&gt;
&lt;p&gt;        Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常：&lt;/p&gt;
&lt;p&gt;        系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件挂掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；&lt;/p&gt;
&lt;p&gt;        普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。&lt;/p&gt;
&lt;p&gt;java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、Java 中堆和栈有什么区别？&lt;/strong&gt;&lt;br/&gt;        JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。&lt;/p&gt;
&lt;p&gt;        栈：在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。&lt;/p&gt;
&lt;p&gt;        堆：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。&lt;/p&gt;

&lt;p&gt;10、&lt;strong&gt;能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？ &lt;/strong&gt;&lt;br/&gt;        我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化，int 类型的高 24 位将会被丢弃，因为byte 类型的范围是从 -128 到 127。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;1、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？&lt;/strong&gt;&lt;br/&gt;        hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;2、字节流与字符流的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       要把一段二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。&lt;/p&gt;
&lt;p&gt;       计算机中的一切最终都是二进制的字节形式存在。对于经常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，Java专门提供了字符流包装类。&lt;/p&gt;
&lt;p&gt;      底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。&lt;/p&gt;
&lt;p&gt;      字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;3、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输。&lt;/p&gt;
&lt;p&gt;        但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是为了标注该对象是可被序列化的。&lt;/p&gt;
&lt;p&gt;        例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现Serializable接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;4、描述一下JVM加载class文件的原理机制?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;5、heap和stack有什么区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。&lt;/p&gt;
&lt;p&gt;        堆是与栈作用不同的内存，一般用于存放不在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;6、GC是什么?为什么要有GC?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;7、垃圾回收的优点和原理。并考虑2种回收机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于垃圾回收机制，Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot;。&lt;/p&gt;
&lt;p&gt;        垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。&lt;/p&gt;
&lt;p&gt;        回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;8、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。&lt;/p&gt;
&lt;p&gt;        程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;9、Java 中，throw 和 throws 有什么区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个Exception，如： &lt;br/&gt;&lt;em&gt;throw new IllegalArgumentException(“XXXXXXXXX″)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;        而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;0，java中会存在内存泄漏吗，请简单描述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        先解释什么是内存泄漏：所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉。&lt;/p&gt;
&lt;p&gt;        由于Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的。&lt;/p&gt;
&lt;p&gt;        java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。&lt;/p&gt;

&lt;p&gt;关注微信公众号回复  &lt;strong&gt;Java面试题&lt;/strong&gt;  即可获取pdf版本！&lt;/p&gt;
&lt;p&gt;一个良心公众号【IT资源社】：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本公众号致力于免费分享全网最优秀的视频资源，学习资料，面试经验等，前端，PHP，JAVA，算法，Python，大数据等等，你想要的这都有&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IT资源社－QQ交流群：625494093&lt;/p&gt;
&lt;p&gt;也可添加微信拉你进微信群: super1319164238&lt;/p&gt;
&lt;p&gt;微信搜索公众号：ITziyuanshe 或者扫描下方二维码直接关注，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LWmkwQMsRCuCZADQFQIagDcHMV46tKaKickEPzO8ClwGl6MvWZFVqOV59bQK6RxYicVsFqHvZQNtaHaiadh4o1cmQ/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;176&quot; data-ratio=&quot;0.9637826961770624&quot; data-type=&quot;png&quot; data-w=&quot;497&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 10:43:00 +0000</pubDate>
<dc:creator>Lovebugs.cn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lovebugs/p/8723755.html</dc:identifier>
</item>
</channel>
</rss>